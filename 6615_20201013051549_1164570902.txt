{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-13 13:15:42","updatedTime":"2020-10-13 13:15:42","title":"适合Vue用户的React教程，你值得拥有","link":"https://segmentfault.com/a/1190000037442568","description":"<blockquote>\n 双节旅游人如山，不如家中代码闲。\n <br>学以致用加班少，王者荣耀家中玩。</br>\n</blockquote>\n<p>小编日常工作中使用的是<code>Vue</code>,对于<code>React</code>只是做过简单的了解，并没有做过深入学习。趁着这个双节假期，小编决定好好学一学<code>React</code>,今天这篇文章就是小编在学习<code>React</code>之后，将<code>React</code>与<code>Vue</code>的用法做的一个对比，通过这个对比，方便使用<code>Vue</code>的小伙伴可以快速将<code>Vue</code>中的写法转换为<code>React</code>的写法。</p>\n<p><strong>本文首发于公众号【前端有的玩】，玩前端，面试找工作，就在【前端有的玩】,欢迎关注</strong></p>\n<h3>插槽，在<code>React</code>中没找到？？</h3>\n<p>在使用<code>Vue</code>的时候，插槽是一个特别常用的功能，通过定义插槽，可以在调用组件的时候将外部的内容传入到组件内部，显示到指定的位置。在<code>Vue</code>中，插槽分为默认插槽，具名插槽和作用域插槽。其实不仅仅<code>Vue</code>,在<code>React</code>中其实也有类似插槽的功能，只是名字不叫做插槽，下面我将通过举例来说明。</p>\n<h4>默认插槽</h4>\n<p>现在项目需要开发一个卡片组件，如下图所示，卡片可以指定标题，然后卡片内容可以用户自定义，这时候对于卡片内容来说，就可以使用插槽来实现，下面我们就分别使用<code>Vue</code>和<code>React</code>来实现这个功能</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000037442571\" alt=\"\" title=\"\" /></p>\n<h4><code>Vue</code>实现</h4>\n<ol>\n <li><p>首先实现一个<code>card</code>组件，如下代码所示</p><pre><code class=\"vue\">&lt;template&gt;\n  &lt;div class=\"card\"&gt;\n    &lt;div class=\"card__title\"&gt;\n      &lt;span&gt;{{ title }}&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=\"card__body\"&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  props: {\n    title: {\n      type: String,\n      default: ''\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre><p>可以看到上面我们使用了<code>&lt;slot&gt;&lt;/slot&gt;</code>，这个就是组件的默认插槽，在使用组件的时候，传入的内容将会被放到<code>&lt;slot&gt;&lt;/slot&gt;</code>所在位置</p></li>\n <li><p>在外部使用定义的<code>card</code>组件</p><pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;my-card&gt;\n      &lt;div&gt;我将被放在card组件的默认插槽里面&lt;/div&gt;\n    &lt;/my-card&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport MyCard from '../components/card'\nexport default {\n  components: {\n    MyCard\n  }\n}\n&lt;/script&gt;\n</code></pre><p>如上代码，就可以使用组件的默认插槽将外部的内容应用到组件里面指定的位置了。</p></li>\n</ol>\n<h4><code>React</code>实现</h4>\n<p>虽然在<code>React</code>里面没有插槽的概念，但是<code>React</code>里面也可以通过<code>props.children</code>拿到组件标签内部的子元素的，就像上面代码<code>&lt;my-card&gt;</code>标签内的子元素，通过这个我们也可以实现类似<code>Vue</code>默认插槽的功能，一起看看代码。</p>\n<ol>\n <li><p>使用<code>React</code>定义<code>Card</code>组件</p><pre><code class=\"react\">import React from 'react'\n\nexport interface CardProps {\n  title: string,\n  children: React.ReactNode\n}\n\nexport default function(props: CardProps) {\n\n  return (\n    &lt;div className=\"card\"&gt;\n      &lt;div className=\"card__title\"&gt;\n        &lt;span&gt;{props.title}&lt;/span&gt;\n      &lt;/div&gt;\n      &lt;div className=\"card__body\"&gt;\n        {/**每个组件都可以获取到 props.children。它包含组件的开始标签和结束标签之间的内容 */}\n        {props.children}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n  <ol>\n   <li>在外部使用<code>Card</code>组件</li>\n  </ol><pre><code class=\"react\">import React from 'react'\nimport Card from './components/Card'\n\nexport default function () {\n\n  return (\n    &lt;div&gt;\n      &lt;Card title=\"标题\"&gt;\n        &lt;div&gt;我将被放在card组件的body区域内容&lt;/div&gt;\n      &lt;/Card&gt;\n    &lt;/div&gt;\n  );\n}</code></pre></li>\n</ol>\n<h4>具名插槽</h4>\n<p>继续以上面的<code>Card</code>组件为例，假如我们现在需求发生了变化，组件的<code>title</code>也可以使用插槽，这时候对于<code>Vue</code>就可以使用具名插槽了，而<code>React</code>也是有办法实现的哦。</p>\n<h5>Vue实现</h5>\n<p><code>Vue</code>的具名插槽主要解决的是一个组件需要多个插槽的场景，其实现是为<code>&lt;slot&gt;</code>添加<code>name</code>属性来实现了。</p>\n<ol>\n <li>我们就上面的需求对<code>card</code>组件进行修改</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div class=\"card\"&gt;\n    &lt;div class=\"card__title\"&gt;\n      &lt;!--如果传入了title，则使用title属性，否则使用具名插槽--&gt;\n      &lt;span v-if=\"title\"&gt;{{ title }}&lt;/span&gt;\n      &lt;slot v-else name=\"title\"&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n    &lt;div class=\"card__body\"&gt;\n      &lt;!--对于内容区域依然使用默认插槽--&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  props: {\n    title: {\n      type: String,\n      default: ''\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<ol>\n <li><code>card</code>组件修改完之后，我们再去调整一下使用<code>card</code>组件的地方</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;my-card&gt;\n      &lt;!--通过v-slot:title 使用具名插槽--&gt;\n      &lt;template v-slot:title&gt;\n        &lt;span&gt;这里是标题&lt;/span&gt;\n      &lt;/template&gt;\n      &lt;div&gt;我将被放在card组件的默认插槽里面&lt;/div&gt;\n    &lt;/my-card&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport MyCard from '../components/card'\nexport default {\n  components: {\n    MyCard\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<h5>React实现</h5>\n<p><code>React</code>连插槽都没有， 更别提具名插槽了，但是没有不代表不能模拟出来。对于<code>React</code>的<code>props</code>，我们不仅仅可以传入普通的属性，还可以传入一个函数，这时候我们就可以在传入的这个函数里面返回<code>JSX</code>,从而就实现了具名插槽的功能。</p>\n<ol>\n <li>对原有的<code>Card</code>组件进行修改</li>\n</ol>\n<pre><code class=\"react\">import React from 'react'\n\nexport interface CardProps {\n  title?: string,\n  // 加入了一个renderTitle属性，属性类型是Function\n  renderTitle?: Function,\n  children: React.ReactNode\n}\n\nexport default function(props: CardProps) {\n\n  const {title, renderTitle} = props\n  // 如果指定了renderTtile，则使用renderTitle,否则使用默认的title\n  let titleEl = renderTitle ? renderTitle() : &lt;span&gt;{title}&lt;/span&gt;\n\n  return (\n    &lt;div className=\"card\"&gt;\n      &lt;div className=\"card__title\"&gt;{titleEl}&lt;/div&gt;\n      &lt;div className=\"card__body\"&gt;\n        {/**每个组件都可以获取到 props.children。它包含组件的开始标签和结束标签之间的内容 */}\n        {props.children}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n<ol>\n <li>这时候就可以在外部自定义<code>title</code>了</li>\n</ol>\n<pre><code class=\"react\">import React from 'react'\nimport Card from './components/Card'\n\nexport default function () {\n  return (\n    &lt;div&gt;\n      &lt;Card  renderTitle={\n        () =&gt; {\n          return &lt;span&gt;我是自定义的标题&lt;/span&gt;\n        }\n      }&gt;\n        &lt;div&gt;我将被放在card组件的body区域内容&lt;/div&gt;\n      &lt;/Card&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n<h4>作用域插槽</h4>\n<p>有时让插槽内容能够访问子组件中才有的数据是很有用的，这个就是<code>Vue</code>提供作用域插槽的原因。我们继续使用上面的<code>Card</code>组件为例，现在我基于上面的卡片组件开发了一个人员信息卡片组件，用户直接使用人员信息卡片组件就可以将人员信息显示到界面中，但是在某些业务模块需要自定义人员信息显示方式，这时候我们就需要使用到作用域插槽了。</p>\n<h5><code>Vue</code>实现</h5>\n<ol>\n <li>实现用户信息卡片组件，里面使用了作用域插槽</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;custom-card title=\"人员信息卡片\"&gt;\n    &lt;div class=\"content\"&gt;\n      &lt;!--这里使用了作用域插槽，将userInfo传出去了--&gt;\n      &lt;slot name=\"userInfo\" :userInfo=\"userInfo\"&gt;\n        &lt;!--如果没有使用插槽，则显示默认内容--&gt;\n        &lt;span&gt;姓名: {{ userInfo.name }}&lt;/span&gt;\n        &lt;span&gt;性别: {{ userInfo.sex }}&lt;/span&gt;\n        &lt;span&gt;年龄: {{ userInfo.age }}&lt;/span&gt;\n      &lt;/slot&gt;\n    &lt;/div&gt;\n  &lt;/custom-card&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport CustomCard from '../card'\nexport default {\n  components: {\n    CustomCard\n  },\n  data() {\n    return {\n      userInfo: {\n        name: '张三',\n        sex: '男',\n        age: 25\n      }\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<ol>\n <li>在外部使用人员信息组件</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;user-card&gt;\n      &lt;template v-slot:userInfo=\"{ userInfo }\"&gt;\n        &lt;div class=\"custom-user\"&gt;\n          &lt;ul&gt;\n            &lt;li&gt;姓名: {{ userInfo.name }}&lt;/li&gt;\n            &lt;li&gt;年龄: {{ userInfo.age }}&lt;/li&gt;\n          &lt;/ul&gt;\n        &lt;/div&gt;\n      &lt;/template&gt;\n    &lt;/user-card&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport UserCard from '../components/user-card'\nexport default {\n  components: {\n    UserCard\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<h5><code>React</code>实现</h5>\n<p>在具名插槽那一小节我们通过给组件传入了一个函数，然后在函数中返回<code>JSX</code>的方式来模拟了具名插槽，那么对于作用域插槽，我们依然可以使用函数的这种方式，而作用域插槽传递的参数我们可以使用给函数传参的方式来替代</p>\n<ol>\n <li><p>实现人员信息卡片组件</p><pre><code class=\"react\">import React, { useState } from 'react'\n\nimport Card from './Card'\n\ninterface UserCardProps {\n  renderUserInfo?: Function\n}\n\nexport interface UserInfo {\n  name: string;\n  age: number;\n  sex: string;\n}\n\nexport default function(props: UserCardProps) {\n  const [userInfo] = useState&lt;UserInfo&gt;({\n    name: \"张三\",\n    age: 25,\n    sex: \"男\",\n  });\n\n  const content = props.renderUserInfo ? (\n    props.renderUserInfo(userInfo)\n  ) : (\n    &lt;div&gt;\n      &lt;span&gt;姓名: {userInfo.name}&lt;/span&gt;\n      &lt;span&gt;年龄: {userInfo.age}&lt;/span&gt;\n      &lt;span&gt;性别: {userInfo.sex}&lt;/span&gt;\n    &lt;/div&gt;\n  );\n\n  return &lt;Card title=\"人员信息\"&gt;\n    {content}\n  &lt;/Card&gt;\n}</code></pre></li>\n <li><p>在外部使用人员信息卡片组件</p><pre><code class=\"react\">import React from 'react'\nimport UserCard, { UserInfo } from \"./components/UserCard\";\n\nexport default function () {\n\n  return (\n    &lt;div&gt;\n      &lt;UserCard\n        renderUserInfo={(userInfo: UserInfo) =&gt; {\n          return (\n            &lt;ul&gt;\n              &lt;li&gt;姓名： {userInfo.name}&lt;/li&gt;\n            &lt;/ul&gt;\n          );\n        }}\n      &gt;&lt;/UserCard&gt;\n    &lt;/div&gt;\n  );\n}</code></pre></li>\n</ol>\n<h3><code>Context</code>, <code>React</code>中的<code>provide/inject</code></h3>\n<p>通常我们在项目开发中，对于多组件之间的状态管理，在<code>Vue</code>中会使用到<code>Vuex</code>,在<code>React</code>中会使用到<code>redux</code>或者<code>Mobx</code>,但对于小项目来说，使用这些状态管理库就显得比较大材小用了，那么在不使用这些库的情况下，如何去完成数据管理呢？比如面试最常问的祖孙组件通信。在<code>Vue</code>中我们可以使用<code>provide/inject</code>，在<code>React</code>中我们可以使用<code>Context</code>。</p>\n<p>假设有这样一个场景，系统现在需要提供一个换肤功能，用户可以切换皮肤，现在我们分别使用<code>Vue</code>和<code>React</code>来实现这个功能。</p>\n<h4><code>Vue</code>中的<code>provide/inject</code></h4>\n<p>在<code>Vue</code>中我们可以使用<code>provide/inject</code>来实现跨多级组件进行传值，就以上面所说场景为例，我们使用<code>provide/inject</code>来实现以下</p>\n<p>首先，修改<code>App.vue</code>内容为以下内容</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div id=\"app\"&gt;\n    &lt;router-view /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      themeInfo: {\n        theme: 'dark'\n      }\n    }\n  },\n  provide() {\n    return {\n      theme: this.themeInfo\n    }\n  }\n}\n&lt;/script&gt;</code></pre>\n<p>然后在任意层级的子组件中像下面这样使用</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div :class=\"`child-${theme.theme}`\"&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  inject: ['theme']\n}\n&lt;/script&gt;\n</code></pre>\n<p>这样就可以实现<code>theme</code>在所有子组件中进行共享了</p>\n<h4><code>React</code>中的<code>Context</code></h4>\n<p>在<code>Vue</code>中我们使用<code>provide/inject</code>实现了组件跨层级传值功能，在<code>React</code>中也提供了类似的功能即<code>Context</code>，下面我们使用<code>Context</code>来实现相同的功能。</p>\n<p>在项目<code>src</code>目录下新建<code>context</code>目录，添加<code>MyContext.js</code>文件，然后添加以下内容</p>\n<pre><code class=\"javascript\">import {createContext} from 'react'\n// 定义 MyContext,指定默认的主题为`light`\nexport const MyContext = createContext({\n  theme: 'light'\n})</code></pre>\n<p><code>MyContext</code>提供了一个<code>Provider</code>，通过<code>Provider</code>可以将<code>theme</code>共享到所有的子组件。现在我们在所有的组件的共同父组件比如<code>App.js</code>上面添加<code>MyContext.Provider</code>将<code>theme</code>共享出去</p>\n<pre><code class=\"react\">import { MyContext } from '@/context/MyContext';\n\nexport default function() {\n  \n  const [theme, setTheme] = useState('dark')\n  \n  return (\n    &lt;MyContext.Provider\n        value={{\n          theme\n        }}\n      &gt;\n        &lt;Children&gt;&lt;/Children&gt;\n     &lt;/MyContext.Provider&gt;\n    )\n  }\n</code></pre>\n<p>然后这时候就可以直接在所有的子组件里面使用定义的主题<code>theme</code>了</p>\n<pre><code class=\"react\">import React, { useContext } from 'react'\nimport { MyContext } from '@/context/MyContext';\n\nexport default function() {\n   const {theme}  = useContext(MyContext)\n   return &lt;div className={`child-${theme}`}&gt;\n}\n</code></pre>\n<h3>没有了<code>v-model</code>,但也不影响使用</h3>\n<p>我们知道<code>React</code>和<code>Vue</code>都是单向数据流的，即数据的流向都是由外层向内层组件进行传递和更新的，比如下面这段<code>React</code>代码就是标准的单向数据流.</p>\n<pre><code class=\"react\">import React, { useState } from \"react\";\n\nexport default function(){\n  const [name] = useState('子君')\n  return &lt;input value={name}&gt;&lt;/input&gt;\n}</code></pre>\n<h4>在<code>vue</code>中使用<code>v-model</code></h4>\n<p>如上代码，我们在通过通过<code>value</code>属性将外部的值传递给了<code>input</code>组件，这个就是一个简单的单向数据流。但是在使用<code>Vue</code>的时候，还有两个比较特殊的语法糖<code>v-model</code>和<code>.sync</code>，这两个语法糖可以让<code>Vue</code>组件拥有双向数据绑定的能力，比如下面的代码</p>\n<pre><code class=\"vue\">&lt;template&gt;\n   &lt;input v-model=\"name\"/&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    data() {\n      return {\n        name:'子君'\n      }\n    }\n  }\n&lt;/script&gt;</code></pre>\n<p>通过<code>v-model</code>,当用户修改<code>input</code>的值的时候，外部的<code>name</code>的值也将同步被修改。但这是<code>Vue</code>的语法糖啊，<code>React</code>是不支持的，所以<code>React</code>应该怎么办呢？这时候再想想自定义<code>v-model</code>，<code>v-model</code>实际上是通过定义<code>value</code>属性同时监听<code>input</code>事件来实现的，比如这样:</p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div class=\"custom-input\"&gt;\n     &lt;input :value=\"value\" @input=\"$_handleChange\"/&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    props:{\n      value:{\n        type: String,\n        default: ''\n      }\n    },\n    methods:{\n      $_handleChange(e) {\n        this.$emit('input', e.target.value)\n      }\n    }\n  }\n&lt;/script&gt;</code></pre>\n<h4>在<code>react</code>寻找<code>v-model</code>替代方案</h4>\n<p>同理，<code>React</code>虽然没有<code>v-model</code>语法糖，但是也可以通过传入属性然后监听事件来实现数据的双向绑定。</p>\n<pre><code class=\"react\">import React, { useState } from 'react'\n\nexport default function() {\n  const [name, setName] = useState('子君')\n\n  const handleChange = (e) =&gt; {\n    setName(e.target.value)\n  }\n  return &lt;div&gt;\n    &lt;input value={name} onChange={handleChange}&gt;&lt;/input&gt;\n  &lt;/div&gt;\n}</code></pre>\n<p>小编刚开始使用<code>react</code>，感觉没有<code>v-model</code>就显得比较麻烦，不过麻烦归麻烦，代码改写也要写。就像上文代码一样，每一个表单元素都需要监听<code>onChange</code>事件，越发显得麻烦了，这时候就可以考虑将多个<code>onChange</code>事件合并成一个，比如像下面代码这样</p>\n<pre><code class=\"react\">import React, { useState } from 'react'\n\nexport default function () {\n  const [name, setName] = useState('子君')\n  const [sex, setSex] = useState('男')\n\n  const handleChange = (e:any, method: Function) =&gt; {\n    method(e.target.value)\n  }\n  return &lt;div&gt;\n    &lt;input value={name} onChange={(e) =&gt; handleChange(e, setName)}&gt;&lt;/input&gt;\n    &lt;input value={sex} onChange={(e) =&gt; handleChange(e, setSex)}&gt;&lt;/input&gt;\n  &lt;/div&gt;\n}</code></pre>\n<h3>没有了指令，我感觉好迷茫</h3>\n<p>在<code>Vue</code>中我们一般绘制页面都会使用到<code>template</code>，<code>template</code>里面提供了大量的指令帮助我们完成业务开发，但是在<code>React</code>中使用的是<code>JSX</code>,并没有指令，那么我们应该怎么做呢？下面我们就将<code>Vue</code>中最常用的一些指令转换为<code>JSX</code>里面的语法(注意: 在Vue中也可以使用<code>JSX</code>)</p>\n<h4><code>v-show</code>与<code>v-if</code></h4>\n<p>在<code>Vue</code>中我们隐藏显示元素可以使用<code>v-show</code>或者<code>v-if</code>,当然这两者的使用场景是有所不同的，<code>v-show</code>是通过设置元素的<code>display</code>样式来显示隐藏元素的，而<code>v-if</code>隐藏元素是直接将元素从<code>dom</code>中移除掉。</p>\n<ol>\n <li><p>看一下<code>Vue</code>中的<code>v-show</code>与<code>v-if</code>的用法</p><pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;span v-show=\"showName\"&gt;姓名:{{ name }}&lt;/span&gt;\n    &lt;span v-if=\"showDept\"&gt;{{ dept }}&lt;/span&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      name: '子君',\n      dept: '银河帝国',\n      showName: false,\n      showDept: true\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre></li>\n <li><p>将<code>v-show</code>，<code>v-if</code>转换为<code>JSX</code>中的语法</p><p>在<code>Vue</code>中指令是为了在<code>template</code>方便动态操作数据而存在的，但是到了<code>React</code>中我们写的是<code>JSX</code>,可以直接使用<code>JS</code>,所以指令是不需要存在的，那么上面的<code>v-show</code>,<code>v-if</code>如何在<code>JSX</code>中替代呢</p><pre><code class=\"react\">import React, { useState } from 'react'\n\nexport default function() {\n  const [showName] = useState(false)\n\n  const [showDept] = useState(true)\n\n  const [userInfo] = useState({\n    name:'子君',\n    dept: '银河帝国'\n  })\n\n  return (\n    &lt;div&gt;\n      {/**模拟 v-show */}\n      &lt;span style={{display: showName ? 'block' : 'none'}}&gt;{userInfo.name}&lt;/span&gt;\n      {/**模拟 v-if */}\n      {showDept ? &lt;span&gt;{userInfo.dept}&lt;/span&gt;: undefined}\n    &lt;/div&gt;\n  )\n}</code></pre></li>\n</ol>\n<h4><code>v-for</code></h4>\n<p><code>v-for</code>在<code>Vue</code>中是用来遍历数据的，同时我们在使用<code>v-for</code>的时候需要给元素指定<code>key</code>，<code>key</code>的值一般是数据的<code>id</code>或者其他唯一且固定的值。不仅在<code>Vue</code>中，在<code>React</code>中也是存在<code>key</code>的，两者的<code>key</code>存在的意义基本一致，都是为了优化虚拟<code>DOM</code> <code>diff</code>算法而存在的。</p>\n<ol>\n <li><p>在<code>Vue</code>中使用<code>v-for</code></p><pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;ul&gt;\n      &lt;li v-for=\"item in list\" :key=\"item.id\"&gt;\n        {{ item.name }}\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      list: [\n        {\n          id: 1,\n          name: '子君'\n        },\n        {\n          id: '2',\n          name: '张三'\n        },\n        {\n          id: '3',\n          name: '李四'\n        }\n      ]\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre></li>\n <li><p>在<code>React</code>中使用<code>v-for</code>的替代语法</p><p>在<code>react</code>中虽然没有<code>v-for</code>，但是<code>JSX</code>中可以直接使用<code>JS</code>,所以我们可以直接遍历数组</p><pre><code class=\"react\">import React from 'react'\n\nexport default function() {\n  const data = [\n    {\n      id: 1,\n      name: \"子君\",\n    },\n    {\n      id: \"2\",\n      name: \"张三\",\n    },\n    {\n      id: \"3\",\n      name: \"李四\",\n    },\n  ];\n\n  return (\n    &lt;div&gt;\n      &lt;ul&gt;\n        {\n        data.map(item =&gt; {\n          return &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n        })\n      }\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  )\n}</code></pre></li>\n</ol>\n<h4><code>v-bind</code>与<code>v-on</code></h4>\n<p><code>v-bind</code>在<code>Vue</code>中是动态绑定属性的，<code>v-on</code>是用于监听事件的,因为<code>React</code>也有属性和事件的概念，所以我们在<code>React</code>也能发现可替代的方式。</p>\n<ol>\n <li><p>在<code>Vue</code>中使用<code>v-bind</code>与<code>v-on</code></p><pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;!--:value是v-bind:value的简写， @input是v-on:input的简写--&gt;\n    &lt;input :value=\"value\" @input=\"handleInput\" /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      value: '子君'\n    }\n  },\n  methods: {\n    handleInput(e) {\n      this.value = e.target.value\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre></li>\n <li><p>在<code>React</code>中寻找替代方案</p><p>在<code>Vue</code>中，作者将事件和属性进行了分离，但是在<code>React</code>中，其实事件也是属性，所以在本小节我们不仅看一下如何使用属性和事件，再了解一下如何在<code>React</code>中自定义事件</p>\n  <ul>\n   <li><p>开发一个<code>CustomInput</code>组件</p><pre><code class=\"react\">import React from 'react'\n\nexport interface CustomInputProps {\n  value: string;\n  //可以看出 onChange是一个普通的函数,也被定义到了组件的props里面了\n  onChange: ((value: string,event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; void) | undefined;\n}\n\nexport default function(props: CustomInputProps) {\n  \n  function handleChange(e: React.ChangeEvent&lt;HTMLInputElement&gt;) {\n    // props.onChange是一个属性，也是自定义的一个事件\n    props.onChange &amp;&amp; props.onChange(e.target.value, e)\n  }\n\n  return (\n    &lt;input value={props.value} onChange={handleChange}&gt;&lt;/input&gt;\n  )\n}</code></pre></li>\n   <li><p>使用<code>CustomInput</code>组件</p><pre><code class=\"react\">import React, { useState } from 'react'\n\nimport CustomInput from './components/CustomInput'\n\nexport default function() {\n const [value, setValue] =  useState('')\n\n function handleChange(value: string) {\n   setValue(value)\n }\n\n  return (\n    &lt;div&gt;\n      &lt;CustomInput value={value} onChange={handleChange}&gt;&lt;/CustomInput&gt;\n    &lt;/div&gt;\n  )\n}</code></pre></li>\n  </ul></li>\n</ol>\n<h3>总结</h3>\n<p>刚开始从<code>Vue</code>转到<code>React</code>的时候，其实是有点不适应的，但是当慢慢的习惯之后，就会发现<code>Vue</code>和<code>React</code>是存在很多共性的，可以参考的去学习。当然无论<code>Vue</code>还是<code>React</code>，上手比较快，但是想深入学习还是需要下功夫的，后续小编将会对<code>Vue</code>和<code>React</code>的用法在做更深入的介绍，敬请期待。</p>","descriptionType":"html","publishedDate":"Mon, 12 Oct 2020 07:10:01 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000037442571","linkMd5":"22be535b15b383611634f18e5ed0d4e7","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn100@2020_4/2020/10/13/05-15-48-745_56a8e0bb48ac8d39.webp","destWidth":800,"destHeight":423,"sourceBytes":8908,"destBytes":8908,"author":"子君","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000037442571":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn100@2020_4/2020/10/13/05-15-48-745_56a8e0bb48ac8d39.webp"},"publishedOrCreatedDate":1602566142722}],"record":{"createdTime":"2020-10-13 13:15:42","updatedTime":"2020-10-13 13:15:42","feedId":6615,"fetchDate":"Tue, 13 Oct 2020 05:15:42 +0000","fetchMs":5981,"handleMs":13489,"totalMs":27203,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"aa5b771909b552db8ae765322bbc0947","hostName":"europe62*","requestId":"d83c0251135047558d278966f32ab5d6_6615","contentType":"application/atom+xml; charset=UTF-8","totalBytes":8908,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":1,"articlesImgsGithubTotal":1,"successGithubMap":{"myreaderx21":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:33:08","updatedTime":"2020-08-25 07:11:24","id":6615,"name":"SegmentFault 最新的文章","url":"http://segmentfault.com/feeds/blogs","subscriber":null,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"https://segmentfault.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":8908,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1602566122329,"total":0,"statList":[{"spend":6904,"msg":"获取xml内容"},{"spend":13489,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"正文链接上传到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"}]},"extra5":1,"extra6":1,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000037442571","sourceStatusCode":200,"destWidth":800,"destHeight":423,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn100@2020_4/2020/10/13/05-15-48-745_56a8e0bb48ac8d39.webp","sourceBytes":8908,"destBytes":8908,"feedId":6615,"totalSpendMs":5125,"convertSpendMs":0,"createdTime":"2020-10-13 13:15:44","host":"us-032*","referer":"https://segmentfault.com/a/1190000037442568","linkMd5ListStr":"22be535b15b383611634f18e5ed0d4e7,22be535b15b383611634f18e5ed0d4e7","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"8.7 KB","destSize":"8.7 KB","compressRate":"100%"}],"successGithubMap":{"myreaderx21":1},"failGithubMap":{}}