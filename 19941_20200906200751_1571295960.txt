{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-09-07 04:07:16","updatedTime":"2020-09-07 04:07:16","title":"Solving an Obfuscated Crackme with Binary Ninja and Triton","link":"https://binary.ninja/2020/07/14/solving-an-obfuscated-crackme-with-binaryninja-and-triton","description":"<p>[Editor’s Note: This blog entry is being brought to you by one of our summer-interns, <a href=\"https://github.com/jeffli678/\">Xusheng</a>. You can find more of his <a href=\"https://github.com/jeffli678/writeups\">writeups</a> over on his github page.]</p> \n<p>The last week’s <a href=\"https://yurichev.com/blog/58/\">challenge</a> was created by <a href=\"https://yurichev.com/\">Dennis Yurichev</a>. It is also hosted on <a href=\"https://crackmes.one/crackme/5ab77f6233c5d40ad448c9e4\">crackmes.one</a>. The challenge is compiled by a modified <a href=\"https://bellard.org/tcc/\">Tiny C Compiler (TCC)</a> which obfuscates the generated code during compilation. We will cover the major techniques to deobfuscate the binary, followed by a quick analysis of the algorithm itself.</p> \n<!--more--> \n<h2 id=\"first-impression\">First Impression</h2> \n<p>The target (<a href=\"https://github.com/jeffli678/writeups/raw/master/obfuscation/keygenme4.exe\">keygenme4.exe</a>) is a PE. The entry point looks like this:</p> \n<p><img src=\"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/1.png?raw=true\" alt=\"\" /></p> \n<p>There are several things which we can notice easily:</p> \n<ol> \n <li>The basic block is quite long.</li> \n <li>It has excessive amounts of continuous arithmetic operations.</li> \n</ol> \n<p>Number 1 is quite common for obfuscated code. Several obfuscation techniques inflate the code and make it hard to read. Number 2 is unique to this obfuscator. If we look at the following instructions closely, we notice it is first loading a constant into <code class=\"highlighter-rouge\">eax</code>, does a series of arithmetic operations on it, and saving it to a variable.</p> \n<div class=\"highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code>0041af0a  mov     eax, dword [data_41c1b4]\n0041af10  shr     eax, 0x0\n0041af13  shr     eax, 0x1\n0041af16  xor     eax, 0xa8f3a9ca\n0041af1c  shl     eax, 0x7\n0041af1f  sub     eax, 0x5a041880\n0041af25  mov     dword [ebp-0x14 {var_18}], eax\n</code></pre>\n </div>\n</div> \n<p>After we check the dword value at data_41c1b4, we can emulate the above code snippet and find out the final value of <code class=\"highlighter-rouge\">eax</code>. It turns out to be 0. So the code is equivalent to:</p> \n<div class=\"highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code>0041af25  mov     dword [ebp-0x14 {var_18}], 0x0\n</code></pre>\n </div>\n</div> \n<p><code class=\"highlighter-rouge\">data_41c1b4</code> is a global variable. When we click on it, we can see all its cross-references. After browsing the list we find that the value is read a lot of time, but it is never written to.</p> \n<p><img src=\"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/9.png?raw=true\" alt=\"\" /></p> \n<p>This means the value never changes. And sequence of instructions like the above one can be simplified to just one constant load.</p> \n<p>We will call this <code class=\"highlighter-rouge\">convoluted constant load</code> later on. Not bad, we break one of the obfuscation! Well, not yet. We just understand how it works and solves it manually. But we need to solve them automatically. <code class=\"highlighter-rouge\">Automation</code> is an important topic in deobfuscation. Often the obfuscation is not hard to understand, but solving them can be much harder. We will discuss how to tackle it later.</p> \n<h2 id=\"hunting-for-other-obfuscation-techniques\">Hunting for Other Obfuscation Techniques</h2> \n<p>As we explore the binary, we can find the following obfuscation techniques:</p> \n<h3 id=\"obfuscated-calls\">Obfuscated Calls</h3> \n<p><img src=\"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/2.png?raw=true\" alt=\"\" /></p> \n<p>0x41c0fa is the string to be printed by <code class=\"highlighter-rouge\">printf</code>, which is nothing special. The next four instructions do the interesting stuff:</p> \n<div class=\"highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code>00416db8  call    $+5 {var_c}  {data_416dbd}\n00416dbd  pop     eax {var_c}\n00416dbe  add     eax, 0xa  {sub_416dc7}\n00416dc1  push    eax {var_c}  {sub_416dc7}\n</code></pre>\n </div>\n</div> \n<p>After the <code class=\"highlighter-rouge\">call $+5</code>, the <code class=\"highlighter-rouge\">eip</code> becomes 0x416dbd. Meanwhile, the return address is pushed onto the top of the stack. Note the return address is also 0x416dbd. The following <code class=\"highlighter-rouge\">pop, add, push</code> sequence would change the return address to <code class=\"highlighter-rouge\">sub_416dc7</code> (which is also calculated by Binary Ninja).</p> \n<p>Now it executes <code class=\"highlighter-rouge\">jmp printf</code>. Note this is a <code class=\"highlighter-rouge\">jmp</code> so it does not push a return address onto the stack. <code class=\"highlighter-rouge\">sub_416dc7</code> is still on the top of the stack. The string to be printed is right below it. In other words, this creates a fake call stack and it manipulates the return address so the code will continue execution from a different place (rather than the code below the printf).</p> \n<p>printf has no magic and it just prints the string. When the execution returns from the printf, the return address sub_416dc7 is popped from the stack and executed. In other words, the above code is equivalent to:</p> \n<!-- ```\n00416db2  mov     eax, 0x41c0fa\n00416db7  push    eax {var_8}  {0x41c0fa}\n00416db8  call    printf\n00416dbd  jmp     core\n``` --> \n<p><img src=\"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/3.png?raw=true\" alt=\"\" /></p> \n<p>This is not hard to deal with since the pattern is quite obvious. We will cover how to solve it later.</p> \n<h3 id=\"opaque-predicates\">Opaque Predicates</h3> \n<p><img src=\"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/6.png?raw=true\" alt=\"\" /></p> \n<p>Another abnormal thing we notice is the code has an excessive amount of branches. If we look at the code closely, we can see something like this:</p> \n<div class=\"highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code>00401248  sub     edx, edx  {0x883d6589}  {0x883d6589}\n0040124a  jne     0x40120a  {0x0}\n</code></pre>\n </div>\n</div> \n<p>Thanks to the <code class=\"highlighter-rouge\">sub edx, edx</code>, the zero flag is always set thus the jne never jumps. This is more obvious if we switch to the Low-Level IL (LLIL):</p> \n<p><img src=\"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/7.png?raw=true\" alt=\"\" /></p> \n<p>In other words, the branch is fake and the execution always gets to 0x40124c. We call this an <code class=\"highlighter-rouge\">opaque predicate</code>, something that’s been discussed here <a href=\"https://binary.ninja/2017/10/01/automated-opaque-predicate-removal.html\">before</a>.</p> \n<p>Opaque predicate is a well-known obfuscation technique that slows down reversers. When we reverse a piece of code, we often first get a grasp of the behavior of the code by looking at its layout (branches, loops, etc). Even beginners know to look for the critical branch that decides whether the code will print a “congratulation” or “sorry”.</p> \n<p>Opaque predicate can be removed statically – since they are opaque and one branch is always taken. However, in real-world, we can use some mathematical fact that is hard to be solved by a program. For example, for any integer <code class=\"highlighter-rouge\">x</code>, this is always true:</p> \n<div class=\"highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code>x * (x + 1) * (x + 2) == 0 (mod 6)\n</code></pre>\n </div>\n</div> \n<p>If we know the set of opaque predicates the obfuscator use, then we can do a pattern matching. Otherwise, we might need to use z3 to prove it. The good news is, in this particular binary, the opaque predicates are quite easy to deal with.</p> \n<h3 id=\"junk-code-insertion\">Junk Code Insertion</h3> \n<p>Inserting junk code is another popular obfuscation technique. Check out the following code:</p> \n<p><img src=\"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/5.png?raw=true\" alt=\"\" /></p> \n<p>It is pretty messy – which is a sign of useless code. And we see the register <code class=\"highlighter-rouge\">edx</code> is overwritten before it is used. By “used” I mean it is not written to the memory or used to calculate other values.</p> \n<p>Junk code insertion is very easy to implement, and not always easy to solve. There is no silver bullet for it, though optimization is the general method to deal with it. Yes, optimization not only helps compiler generate faster code, it also helps remove unnecessary code. For the interested readers, this <a href=\"https://github.com/JonathanSalwan/Tigress_protection\">script</a> uses LLVM to remove the Trigress VM.</p> \n<p>However, in this writeup, we will take a different approach. We will leverage some property of the code generated by TCC and solve it by backward taint analysis.</p> \n<h2 id=\"writing-a-deobfuscator\">Writing a deobfuscator</h2> \n<p>Before I discuss the details of the deobfuscator, I would like to first address the availability of the obfuscator source code. We all know TCC is open-source. And Dennis provided the <a href=\"http://conus.info/stuff/tcc-obfuscate/tcc-0.9.25-diff\">patch file</a>. So we can look at how the obfuscated binary is generated. This is of course a good thing since we can learn from the obfuscator. And I do recommend that everyone read it since it can show a relatively simple and lightweight way of implementing an obfuscating compiler.</p> \n<p>However, this also introduces a problem: in the real-world, we typically do not have the source code for the obfuscator. So we should avoid using too many details from it. Though I still use some – but I try to limit them as few as possible.</p> \n<p>Writing a deobfuscator is harder than understanding the obfuscation. I was once hesitant to start tackling this since I know it is going to take a few days. And now when I look at the code I have written, I still remember the hardship that I encountered. But I have succeeded! This is something that I am proud of.</p> \n<p>We probably cannot cover every detail of the deobfuscator. It is only 500 LoC but discussing every bit (as well as the reasoning behind it) is beyond the scope of this writeup. But I will cover the major highlights.</p> \n<h3 id=\"planning\">Planning</h3> \n<p>Writing a good deobfuscator needs some planning before actual coding. The first thing we need to consider is tooling. Binary analysis requires lots of tools to proceed. How do we get the disassembly? What is the processing pipeline?</p> \n<p>In this writeup, I use Binary Ninja as the primary tool. It has a powerful Python API so it is quite easy to access the disassembled functions, basic blocks, assembly lines, etc. Later I also used Triton for backward taint analysis, which allows me to remove junk code quite effectively.</p> \n<p>The goal is simple: produce deobfuscated code. Note, however, one hurdle here is we do not have the ground truth for the obfuscated binary. As a result, we need to write the code, see its result in action, and make modifications and adjustments accordingly. When I deal with the opaque predicate, once my assumption was too wide and the deobfuscated code is empty. Then I have to go back and examine every branch the tool patched out and see which one is wrong (and should not be wiped out). One thing I did is to write a simple test C program, produce both the original binary and an obfuscated binary, and then test my tool on it. This allows me to fix several bugs faster.</p> \n<p>Automation is the result we want. However, we also need to make some compromise on this. Ideally, our program should take the binary as input and produce a deobfuscated one. However, I found there are too many corner cases so I decided that my tool will process one basic block a time. This allows me to verify if the result is correct. Later on, I enhanced it to process a function a time – just iterate over the basic blocks in a function and process them one by one. Even this sometimes causes problem and I have to go back to process basic blocks one by one. The good part is my script is pretty robust that almost never needs any manual fixes.</p> \n<h3 id=\"the-skeleton-of-a-binary-ninja-plugin\">The Skeleton of a Binary Ninja Plugin</h3> \n<p>Binary Ninja allows a plugin to register a callback on an address.</p> \n<pre><code class=\"language-Python\">PluginCommand.register_for_address(\"Deobfuscate\",\n                                   \"Remove tcc\",\n                                   bootstrap)\n</code></pre> \n<p><code class=\"highlighter-rouge\">bootstrap</code> is the function that gets called every time we click the <code class=\"highlighter-rouge\">Deobfuscate</code> context menu. It is just a wrapper around the <code class=\"highlighter-rouge\">simplify_bbl_handler</code>:</p> \n<pre><code class=\"language-Python\">def simplify_bbl_handler(bv, addr):\n    bbl = bv.get_basic_blocks_at(addr)[0]\n    instrs_to_include = simplify_bbl(bv, bbl)\n    bv.begin_undo_actions()\n    nop_excluded_instrs(bv, bbl, instrs_to_include)\n    solve_load_bbl(bv, bbl)\n    bv.commit_undo_actions()\n</code></pre> \n<p>We get the basic block at the current address by <code class=\"highlighter-rouge\">bv.get_basic_blocks_at()</code>. Then we start the real deobfuscating. Note we also add undo actions which is quite handy during development – since we need to frequently change the code and see its result.</p> \n<h3 id=\"solving-convoluted-constant-load\">Solving Convoluted Constant Load</h3> \n<p>The convoluted constant load is the first obfuscation technique we discussed. And it is used a lot across the binary. It is not hard to solve since its operations are simple. The problem is we need to locate it in the binary – where it starts and where it ends. This is trivial for a human reverser, but it is not easy for a program.</p> \n<p>The implementation is in the function <code class=\"highlighter-rouge\">solve_load_bbl()</code> in the <a href=\"https://binary.ninja/2020/07/14/solution/de-obfuscate/de-obfuscate.py\">script</a>. The code is long so I cannot show it here. It does some pattern matching. It looks for consecutive arithmetic operations (<code class=\"highlighter-rouge\">'add|sub|shl|shr|xor'</code>) on registers <code class=\"highlighter-rouge\">['eax', 'ebx', 'ecx', 'edx']</code>. This might not be the <code class=\"highlighter-rouge\">best</code> solution, but it works. We have to make some compromise since it is very hard to write the best code for a deobfuscator, which deals with messy things.</p> \n<p>After discovering the pattern, it emulates the operations:</p> \n<pre><code class=\"language-Python\">def solve_load_ops(bv, ops):\n    val = 0\n    for opcode, operand in ops:\n        if opcode == 'mov':\n            addr = int(operand, 16)\n            val_bytes = bv.read(addr, 4)\n            val = struct.unpack('&lt;I', val_bytes)[0]\n            print(hex(val))\n        elif opcode == 'add':\n            val = (val + int(operand, 16)) &amp; 0xffffffff\n        elif opcode == 'sub':\n            val = (val - int(operand, 16)) % (1 &lt;&lt; 32)\n        elif opcode == 'xor':\n            val = val ^ int(operand, 16)\n        elif opcode == 'shl':\n            val = val &lt;&lt; int(operand, 16)\n            val &amp;= 0xffffffff\n        elif opcode == 'shr':\n            val = val &gt;&gt; int(operand, 16)\n        else:\n            print('unknown operation: %s' % opcode)\n\n    return val\n</code></pre> \n<p>After we calculate the final load value, we need to patch the code, which is super convenient in Binary Ninja.</p> \n<h3 id=\"solving-obfuscated-calls\">Solving Obfuscated Calls</h3> \n<p>The obfuscated call needs to be restored. Note the obfuscated code has <code class=\"highlighter-rouge\">jmp printf</code> in it, but we need to change it to <code class=\"highlighter-rouge\">call printf</code>. And then add a <code class=\"highlighter-rouge\">jmp</code> to the next function.</p> \n<pre><code class=\"language-Python\">def solve_push_jmp(bv, func):\n\n    for bbl in func.basic_blocks:\n        if bbl.instruction_count &lt; 5:\n            continue\n        \n        disassembly_text = bbl.get_disassembly_text()\n        if str(disassembly_text[-5]).startswith('call    $+5') and \\\n            str(disassembly_text[-4]).startswith('pop     eax') and \\\n            str(disassembly_text[-3]).startswith('add     eax, 0xa') and \\\n            str(disassembly_text[-2]).startswith('push    eax') and \\\n            str(disassembly_text[-1]).startswith('jmp'):\n\n            patch_addr = disassembly_text[-5].address\n            print('push_jump at: 0x%x' % patch_addr)\n\n            jmp_addr = disassembly_text[-1].address\n            callee_offset_bytes = bv.read(jmp_addr + 1, 4)\n            caller_offset = struct.unpack('&lt;i', callee_offset_bytes)[0]\n            callee_addr = jmp_addr + caller_offset + 5\n\n            dis = 'call 0x%x' % callee_addr\n            inst_bytes = arch.assemble(dis, patch_addr)\n            bv.write(patch_addr, inst_bytes)\n            \n            # this sequence is 15 byte long\n            return_addr = patch_addr + 15\n            jmp_addr = patch_addr + len(inst_bytes)\n            dis_jmp = 'jmp 0x%x' % return_addr\n\n            inst_bytes = arch.assemble(dis_jmp, jmp_addr)\n            bv.write(jmp_addr, inst_bytes)\n</code></pre> \n<p>We need to do some math to calculate the <code class=\"highlighter-rouge\">callee_addr</code>, <code class=\"highlighter-rouge\">return_addr</code>, and <code class=\"highlighter-rouge\">jmp_addr</code>. Once we finish this the control flow is much better since we now know which functions get called.</p> \n<h3 id=\"solving-opaque-predicate\">Solving Opaque Predicate</h3> \n<p>Binary Ninja already has a <a href=\"https://binary.ninja/2017/10/01/automated-opaque-predicate-removal.html\">plugin</a> for patching opaque predicates. It relies on the lifted LLIL to see if the flags used in the conditional jump can be deduced from the preceding code, and patch it if so.</p> \n<p>However, it does not suit my need because it does not take care of the convoluted constant load. Have a look at the following code:</p> \n<div class=\"highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code>00401172  mov     eax, dword [data_41c000]\n00401178  mov     ecx, dword [data_41c1ac]\n0040117e  xor     ecx, 0x32744b9b\n00401184  shl     ecx, 0x2\n00401187  shl     ecx, 0x4\n0040118a  sub     ecx, 0x63fa1799\n00401190  shr     ecx, 0x2\n00401193  xor     ecx, 0x6a18d496\n00401199  sub     ecx, 0x756243af\n0040119f  cmp     eax, ecx\n004011a1  jge     0x401516\n</code></pre>\n </div>\n</div> \n<p>The <code class=\"highlighter-rouge\">eax</code> is loaded directly from the memory, and <code class=\"highlighter-rouge\">ecx</code> is also a constant. So the result of the comparison is deterministic. However, LLIL does not squash these arithmetic operations so it does not know this is an opaque predicate.</p> \n<p>So I wrote my opaque predicate patcher. Here I read the source code of the obfuscator and found out that it only inject two types of opaque predicates: the first one is the <code class=\"highlighter-rouge\">sub-and-jump</code> and the second is <code class=\"highlighter-rouge\">xor-and-jump</code>. Both are quite easy to find. Then I just search for sub/xor instruction, whose two operands are the same, and it is followed by a conditional jump. If found, I patch it accordingly.</p> \n<pre><code class=\"language-Python\">def is_opaque_predicate(instr):\n\n    tokens = instr.tokens\n    if tokens[0].text == 'xor' and tokens[2].text == tokens[4].text:\n        return True\n    if tokens[0].text == 'sub' and tokens[2].text == tokens[4].text:\n        return True   \n    return False\n\ndef solve_opaque_predicate(bv, func):\n\n    for bbl in func.basic_blocks:\n\n        # jne to self\n        if bbl.instruction_count == 1:\n            instr = bbl.get_disassembly_text()[0]\n            if instr.tokens[0].text.startswith('jne'):\n                bv.never_branch(instr.address)  \n            continue\n\n        instrs = bbl.get_disassembly_text()\n\n        try:\n            instr1, instr2 = instrs[-2 :]\n        except:\n            print('error at: 0x%x' % bbl.start)\n\n        if is_opaque_predicate(instr1):\n            if should_patch_to_always_branch(instr2):\n                log_info('always branch at: 0x%x' % instr2.address)\n                bv.always_branch(instr2.address)\n            elif should_patch_to_never_branch(instr2):\n                log_info('never branch at: 0x%x' % instr2.address)\n                bv.never_branch(instr2.address)\n</code></pre> \n<p>A careful reader should already find that I made a mistake here. On the one hand, after I read the source code I find there are only two types of opaque predicates; on the other hand, I think the conditional shown above (<code class=\"highlighter-rouge\">0040119f cmp eax, ecx; 004011a1 jge 0x401516</code>) is also opaque. The problem is this is a <code class=\"highlighter-rouge\">cmp</code> followed by <code class=\"highlighter-rouge\">jge</code>, which is not opaque at all!</p> \n<p>The problem is the <code class=\"highlighter-rouge\">00401172 mov eax, dword [data_41c000]</code>. This is not a convoluted constant load; it is just a regular variable load! The value of <code class=\"highlighter-rouge\">dword [data_41c000]</code> could change and this is a meaningful branch. After I realized this, I went back to change the code that solves the constant load: it has to have two operations at least.</p> \n<h3 id=\"solving-junk-code\">Solving Junk Code</h3> \n<p>Junk code removal is the hardest part of this binary. It is not the most prominent technique used in it, but it does require a significant amount of work to solve. Junk code is easy to recognize for human reverser: it often contains a lot of meaningless/weird combinations of instructions. But this does not help a program to recognize them.</p> \n<p>As I mentioned, simplification is probably the <code class=\"highlighter-rouge\">right</code> way to do it. But it also requires a huge amount of work. I looked at the generated assembly and found one property of TCC can help us solve it more easily. This involves compiler theories but I will keep it as simple as possible.</p> \n<p>TCC is <code class=\"highlighter-rouge\">tiny</code> so it does not do a lot of optimization on the generated code. The <a href=\"https://lists.gnu.org/archive/html/tinycc-devel/2006-09/msg00028.html\">email list</a> writes:</p> \n<div class=\"highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code>TinyCC compiles every statement on its own. After every line of code,\nvalues in registers are written back to the stack. And even if the next\nline uses the variables that can still be found in registers, they are\nread again from the stack.\n</code></pre>\n </div>\n</div> \n<p>This means, for TCC emitted code, if a value is calculated (and held in register) but not written back to the memory, then it is to be discarded. Though we do not necessarily see the register holding the value being over-written. This allows us to remove junk code on a basic block level rather than a function level, which is a lot easier to implement.</p> \n<p>Note, however, the above statement is not true for other compilers, e.g., gcc. Gcc generates code that uses a register to hold the loop counter <code class=\"highlighter-rouge\">i</code>. The value is never written back to the memory inside the loop. For code like that, it is harder to deduce if a value is used later or not.</p> \n<p>The idea of the simplification is to pick all the useful instructions from a basic block. We start from instructions that write to the memory. And we do backward taint analysis on all of them to get a set of instructions that affect the final value written to the memory. We do this repeatedly until no new instructions are added. Then we get all the useful instructions. Finally, we remove all the useless instructions (junk code).</p> \n<p>The code is in <code class=\"highlighter-rouge\">simplify_bbl()</code>. It is quite long so I do not post it here. <a href=\"https://triton.quarkslab.com/\">Triton</a> does the taint analysis. The recursion part is the most difficult to write.</p> \n<p>This method will be voided if the obfuscator writes the junk value into the memory. However, it is also harder to implement since the obfuscator authors need to find a safe place to write to.</p> \n<p>One question puzzles me for a long time until I read the source of the obfuscator. How does the junk code inserter make sure that it does not accidentally destroy some useful register value? For example, when it writes to <code class=\"highlighter-rouge\">edx</code>, is it sure that <code class=\"highlighter-rouge\">edx</code> does not hold any value that is used later? The answer is, TCC uses value stack (vstack) to keep track of values. And the obfuscator avoids writing to any registers in the vstack. The relevant code is:</p> \n<pre><code class=\"language-C\">int is_reg_in_vstack (int r)\n{\n    SValue *p;\n\n    for(p=vstack; p&lt;=vtop; p++)\n        if (r==((p-&gt;r)&amp;0xFF))\n            return 1;\n\n    return 0;\n};\n</code></pre> \n<h3 id=\"nop-ing-out-useless-instructions\">Nop-ing Out Useless Instructions</h3> \n<p>We almost succeed! We have handled all the obfuscation techniques. The last step is to remove those junk code (as well as some residue of other obfuscations). We can simply <code class=\"highlighter-rouge\">nop</code> them, but then it creates looooong nop slides which make the code hard to read. Moving the remaining code to make it compact is non-trivial. It affects relocation, inline data, etc. Later, I learned (thx Jordan!) that switching to LLIL automatically removes these nops, as shown below:</p> \n<p><img src=\"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/10.png?raw=true\" alt=\"\" /></p> \n<p>However, when I approach the problem by myself, I found this is seldom discussed in deobfuscation literature so I came up with my own solution.</p> \n<p>We still first patch the junk code with <code class=\"highlighter-rouge\">nop</code>. Since a <code class=\"highlighter-rouge\">jmp</code> is only 5 bytes long, if there is a nop-slide that is longer than 5 bytes, we create a <code class=\"highlighter-rouge\">jmp</code> that directly jumps to the end of the nop slide. The logic is implemented in <code class=\"highlighter-rouge\">nop_excluded_instrs()</code>. The result does not look perfect, but it is already much more readable:</p> \n<p><img src=\"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/8.png?raw=true\" alt=\"\" /></p> \n<p>It first checks if argv[1] is 0. If so, it prints an error message. If not, it calls <code class=\"highlighter-rouge\">strlen</code> on it and jumps to another function, which I named <code class=\"highlighter-rouge\">check</code>.</p> \n<h2 id=\"analyzing-the-algorithm\">Analyzing the algorithm</h2> \n<p>Finally, we get a clean binary that can be analyzed. The algorithm itself is not trivial and it requires some patience. It is probably a level 3 crackme if no obfuscation is applied. Though we will only cover the most important pieces of it.</p> \n<p>Interestingly, the deobfuscated binary still has other obfuscations. The most prominent one is the buffer is processed in 16 functions. Each function takes care of 8 bytes of the buffer. the functions are functionally identical but it is not organized into a loop. The first function will call the second, the second will call the third, etc.</p> \n<p>The key must be 128 bytes long. The buffer is first decrypted using a CBC mode XOR. The key is 16 DWORDs calculated dynamically. We do not care about how the key is calculated; we just need to dump it once the programs calculated it.</p> \n<p>The decrypted buffer contains the serial number, user name, enabled feature sets, and expiration date. At the end of it, there is a checksum value. The checksum is calculated at sub_415353. One has to be familiar with the calculation of crc32 to understand this function. This is calculating a crc32 of the input buffer using magic value 0xedb88320 (see address 0x415747).</p> \n<p>Finally, we arrived at the keygen script:</p> \n<pre><code class=\"language-Python\">import struct \n\ndef crc32(s, init_val = 0, final_xor = 0):\n\n    poly = 0xedb88320\n    crc = init_val\n    for c in s:\n        if type(c) == str:\n            asc = ord(c)\n        else:\n            asc = c\n\n        asc ^= 0xffffffff\n        crc ^= asc\n\n        for _ in range(8):\n            eax = crc &amp; 1\n            var_c_1 = (-eax) % 0xffffffff\n\n            var_8 = crc &gt;&gt; 1\n            var_c_1 &amp;= poly\n\n            crc = var_8 ^ var_c_1\n\n        crc ^= 0xffffffff\n\n    crc ^= final_xor   \n    return crc  \n\ndef transform_back(buffer):\n\n    rngs_vals = [\n        0x10D88067, \n        0xBC16D3D5, \n        0xE7039A64, \n        0x39EC8A6D, \n        0xFF09B4BF, \n        0xF828DB76, \n        0x8BE40C8E, \n        0xF7AA583E, \n        0x60858E23, \n        0xE487F5A3, \n        0x39A57B89, \n        0xB006573E, \n        0x79609807, \n        0x620AD108, \n        0x5CD86398, \n        0x6CA94B51\n    ]\n    var_0x8c = 0\n\n    ints = struct.unpack('&lt;' + 'I' * 16, buffer)\n    restored_ints = []\n\n    for i in range(16):\n        restored_int = ints[i] ^ rngs_vals[i] ^ var_0x8c\n        restored_ints.append(restored_int)\n        var_0x8c = restored_int\n\n    return restored_ints\n\ndef main():\n\n    name = 'jeff'\n    sn = 0x12348765\n    feature = 0x123\n    expire_year = 0x2981\n    expire_month = 0x34\n    expire_date = 0x12\n\n    buffer = name + '\\x00' * (32 - len(name))\n    buffer += struct.pack('&lt;I', sn)\n    buffer += struct.pack('&lt;I', feature)\n    buffer += struct.pack('&lt;H', expire_year)\n    buffer += struct.pack('&lt;B', expire_month)\n    buffer += struct.pack('&lt;B', expire_date)\n\n    buffer += '\\x00' * 16\n\n    crc = crc32(buffer)\n    buffer += struct.pack('&lt;I', crc)\n    print(buffer.encode('hex'))\n\n    restored_int = transform_back(buffer)\n\n    key = ''\n    for val in restored_int:\n        key += '%08x' % val\n    \n    print('key: ')\n    print(key)\n\n\nif __name__ == '__main__':\n    main()\n</code></pre> \n<!-- 76bee50dcaa836d82dabacbc144726d1eb4e926e13664918988245966f281da81d9914eef91ee06ed28fb2666289e5581be97d5f79e3ac57253bcfcf254ff9d4 --> \n<p>An example run looks like this:</p> \n<div class=\"highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code>&gt;keygenme4.exe 76bee50dcaa836d82dabacbc144726d1eb4e926e13664918988245966f281da81d9914eef91ee06ed28fb2666289e5581be97d5f79e3ac57253bcfcf254ff9d4\nYonkie's keygenme#4 &lt;dennis@conus.info&gt;\nlicensed name=jeff\nsn=12348765\nfeatureset=0123\nexpiration=12342981\n</code></pre>\n </div>\n</div>","descriptionType":"html","publishedDate":"Tue, 14 Jul 2020 18:33:07 +0000","feedId":19941,"bgimg":"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/1.png?raw=true","linkMd5":"0f916aeef3748a298249f5b492c4f803","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn7@2020_4/2020/09/06/20-07-21-951_f6d0f6d6d9494970.webp","destWidth":979,"destHeight":979,"sourceBytes":168158,"destBytes":57946,"author":"xusheng","articleImgCdnMap":{"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/1.png?raw=true":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn7@2020_4/2020/09/06/20-07-21-951_f6d0f6d6d9494970.webp","https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/9.png?raw=true":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn27@2020_2/2020/09/06/20-07-24-067_bcd3f19ac09cbc83.webp","https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/2.png?raw=true":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn51@2020_3/2020/09/06/20-07-37-193_2ecad9f4a978b13f.webp","https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/3.png?raw=true":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn44@2020_6/2020/09/06/20-07-44-221_9bfa27f82cb2cec8.webp","https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/6.png?raw=true":"https://cdn.jsdelivr.net/gh/myreaderx/cdn39@2020_4/2020/09/06/20-07-39-727_dbaaacac99de5d2c.webp","https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/7.png?raw=true":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn31@2020_2/2020/09/06/20-07-23-828_69b4a17811bf7035.webp","https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/5.png?raw=true":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn47@2020_2/2020/09/06/20-07-23-701_0308e64bf217d991.webp","https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/10.png?raw=true":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn55@2020_3/2020/09/06/20-07-50-279_8bbb98c3f5e23225.webp","https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/8.png?raw=true":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn33@2020_3/2020/09/06/20-07-38-179_e43316923c525a0c.webp"},"publishedOrCreatedDate":1599422836872}],"record":{"createdTime":"2020-09-07 04:07:16","updatedTime":"2020-09-07 04:07:16","feedId":19941,"fetchDate":"Sun, 06 Sep 2020 20:07:16 +0000","fetchMs":468,"handleMs":2047,"totalMs":37491,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"aa5b771909b552db8ae765322bbc0947","hostName":"europe64*","requestId":"ebe1ff71b2274906a67482e330584a48_19941","contentType":"application/xml","totalBytes":238822,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":9,"articlesImgsGithubTotal":9,"successGithubMap":{"myreaderx14":1,"myreaderx15":1,"myreaderx16":1,"myreaderx27":1,"myreaderx21":1,"myreaderx22":1,"myreaderx18":1,"myreaderx29":1,"myreaderx":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:21:09","updatedTime":"2020-09-07 02:21:09","id":19941,"name":"Binary Ninja","url":"https://binary.ninja/feed.xml","subscriber":166,"website":null,"icon":"https://binary.ninja/ico/apple-icon-57x57.png","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx63/cdn87@2020_2/2020/09/06/20-07-15-804_7766ef09b62651b3.png","description":"Home of the Binary Ninja reverse engineering platform","weekly":null,"link":"https://binary.ninja"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":57946,"tmpBodyImgCdnBytes":180876,"tmpBgImgCdnBytes":0,"extra4":{"start":1599422833922,"total":0,"statList":[{"spend":904,"msg":"获取xml内容"},{"spend":2047,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":28467,"msg":"正文链接上传到cdn"}]},"extra5":9,"extra6":9,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{"https://binary.ninja/2020/07/14/solving-an-obfuscated-crackme-with-binaryninja-and-triton_solution/de-obfuscate/de-obfuscate.py":"https://binary.ninja/2020/07/14/solution/de-obfuscate/de-obfuscate.py"},"extra111_proxyServerAndStatMap":{"http://us-032.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-020.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-54.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-004.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe67.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-015.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-016.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-040.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/1.png?raw=true","sourceStatusCode":200,"destWidth":979,"destHeight":979,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn7@2020_4/2020/09/06/20-07-21-951_f6d0f6d6d9494970.webp","sourceBytes":168158,"destBytes":57946,"targetWebpQuality":75,"feedId":19941,"totalSpendMs":1713,"convertSpendMs":68,"createdTime":"2020-09-07 04:07:21","host":"us-036*","referer":"https://binary.ninja/2020/07/14/solving-an-obfuscated-crackme-with-binaryninja-and-triton","linkMd5ListStr":"0f916aeef3748a298249f5b492c4f803,0f916aeef3748a298249f5b492c4f803","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"164.2 KB","destSize":"56.6 KB","compressRate":"34.5%"},{"code":1,"isDone":false,"source":"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/5.png?raw=true","sourceStatusCode":200,"destWidth":547,"destHeight":342,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn47@2020_2/2020/09/06/20-07-23-701_0308e64bf217d991.webp","sourceBytes":59278,"destBytes":21630,"targetWebpQuality":75,"feedId":19941,"totalSpendMs":1543,"convertSpendMs":18,"createdTime":"2020-09-07 04:07:23","host":"us-54*","referer":"https://binary.ninja/2020/07/14/solving-an-obfuscated-crackme-with-binaryninja-and-triton","linkMd5ListStr":"0f916aeef3748a298249f5b492c4f803","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"57.9 KB","destSize":"21.1 KB","compressRate":"36.5%"},{"code":1,"isDone":false,"source":"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/7.png?raw=true","sourceStatusCode":200,"destWidth":727,"destHeight":186,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn31@2020_2/2020/09/06/20-07-23-828_69b4a17811bf7035.webp","sourceBytes":28231,"destBytes":11864,"targetWebpQuality":75,"feedId":19941,"totalSpendMs":1895,"convertSpendMs":11,"createdTime":"2020-09-07 04:07:23","host":"us-015*","referer":"https://binary.ninja/2020/07/14/solving-an-obfuscated-crackme-with-binaryninja-and-triton","linkMd5ListStr":"0f916aeef3748a298249f5b492c4f803","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"27.6 KB","destSize":"11.6 KB","compressRate":"42%"},{"code":1,"isDone":false,"source":"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/9.png?raw=true","sourceStatusCode":200,"destWidth":465,"destHeight":276,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn27@2020_2/2020/09/06/20-07-24-067_bcd3f19ac09cbc83.webp","sourceBytes":48401,"destBytes":23044,"targetWebpQuality":75,"feedId":19941,"totalSpendMs":1915,"convertSpendMs":41,"createdTime":"2020-09-07 04:07:23","host":"us-040*","referer":"https://binary.ninja/2020/07/14/solving-an-obfuscated-crackme-with-binaryninja-and-triton","linkMd5ListStr":"0f916aeef3748a298249f5b492c4f803","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"47.3 KB","destSize":"22.5 KB","compressRate":"47.6%"},{"code":1,"isDone":false,"source":"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/2.png?raw=true","sourceStatusCode":200,"destWidth":441,"destHeight":318,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn51@2020_3/2020/09/06/20-07-37-193_2ecad9f4a978b13f.webp","sourceBytes":47349,"destBytes":16600,"targetWebpQuality":75,"feedId":19941,"totalSpendMs":2694,"convertSpendMs":16,"createdTime":"2020-09-07 04:07:35","host":"us-032*","referer":"https://binary.ninja/2020/07/14/solving-an-obfuscated-crackme-with-binaryninja-and-triton","linkMd5ListStr":"0f916aeef3748a298249f5b492c4f803","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"46.2 KB","destSize":"16.2 KB","compressRate":"35.1%"},{"code":1,"isDone":false,"source":"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/8.png?raw=true","sourceStatusCode":200,"destWidth":848,"destHeight":885,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn33@2020_3/2020/09/06/20-07-38-179_e43316923c525a0c.webp","sourceBytes":100132,"destBytes":41240,"targetWebpQuality":75,"feedId":19941,"totalSpendMs":1876,"convertSpendMs":39,"createdTime":"2020-09-07 04:07:37","host":"us-016*","referer":"https://binary.ninja/2020/07/14/solving-an-obfuscated-crackme-with-binaryninja-and-triton","linkMd5ListStr":"0f916aeef3748a298249f5b492c4f803","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"97.8 KB","destSize":"40.3 KB","compressRate":"41.2%"},{"code":1,"isDone":false,"source":"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/6.png?raw=true","sourceStatusCode":200,"destWidth":1183,"destHeight":500,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn39@2020_4/2020/09/06/20-07-39-727_dbaaacac99de5d2c.webp","sourceBytes":70403,"destBytes":27944,"targetWebpQuality":75,"feedId":19941,"totalSpendMs":1381,"convertSpendMs":31,"createdTime":"2020-09-07 04:07:39","host":"us-004*","referer":"https://binary.ninja/2020/07/14/solving-an-obfuscated-crackme-with-binaryninja-and-triton","linkMd5ListStr":"0f916aeef3748a298249f5b492c4f803","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"68.8 KB","destSize":"27.3 KB","compressRate":"39.7%"},{"code":1,"isDone":false,"source":"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/3.png?raw=true","sourceStatusCode":200,"destWidth":426,"destHeight":98,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn44@2020_6/2020/09/06/20-07-44-221_9bfa27f82cb2cec8.webp","sourceBytes":14258,"destBytes":5246,"targetWebpQuality":75,"feedId":19941,"totalSpendMs":2078,"convertSpendMs":7,"createdTime":"2020-09-07 04:07:43","host":"europe67*","referer":"https://binary.ninja/2020/07/14/solving-an-obfuscated-crackme-with-binaryninja-and-triton","linkMd5ListStr":"0f916aeef3748a298249f5b492c4f803","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"13.9 KB","destSize":"5.1 KB","compressRate":"36.8%"},{"code":1,"isDone":false,"source":"https://github.com/jeffli678/writeups/blob/master/obfuscation/imgs/10.png?raw=true","sourceStatusCode":200,"destWidth":1032,"destHeight":672,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn55@2020_3/2020/09/06/20-07-50-279_8bbb98c3f5e23225.webp","sourceBytes":77114,"destBytes":33308,"targetWebpQuality":75,"feedId":19941,"totalSpendMs":1997,"convertSpendMs":42,"createdTime":"2020-09-07 04:07:49","host":"us-020*","referer":"https://binary.ninja/2020/07/14/solving-an-obfuscated-crackme-with-binaryninja-and-triton","linkMd5ListStr":"0f916aeef3748a298249f5b492c4f803","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"75.3 KB","destSize":"32.5 KB","compressRate":"43.2%"}],"successGithubMap":{"myreaderx14":1,"myreaderx15":1,"myreaderx16":1,"myreaderx27":1,"myreaderx21":1,"myreaderx22":1,"myreaderx18":1,"myreaderx29":1,"myreaderx":1},"failGithubMap":{}}