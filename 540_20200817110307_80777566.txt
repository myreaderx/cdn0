{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-08-17 19:02:45","updatedTime":"2020-08-17 19:02:45","title":"定位生产问题时，异常堆栈莫名丢了，何解？","link":"https://toutiao.io/k/531jcms","description":"<div>\n <div>\n  <div class=\"rich_media_content \" id=\"js_content\"> \n   <section data-mpa-powered-by=\"yiban.io\">\n    <section>\n     <span>今天分享的这个知识有点冷，相信很多 Java 程序员很少遇到，废话不多说，直接进入排查问题的真实讨论现场。</span>\n    </section>\n    <section>\n     <strong><span><br /></span></strong>\n    </section>\n    <section>\n     <span><strong><span>小&nbsp; &nbsp;猿：</span></strong><span>有个 NPE 异常，有空帮忙看看是哪里出的？</span><br /></span>\n    </section>\n    <p><span><strong><span>架构狮</span></strong></span><span><strong><span>：</span></strong><span>我没有看到空指针堆栈啊！？</span></span></p>\n    <p><span><strong><span><strong><span>小&nbsp; &nbsp;猿</span></strong>：</span></strong><span>有堆栈我就自己找问题了，就不劳驾您老啦（捂嘴笑）。</span></span></p>\n    <p></p>\n    <section>\n     <span><strong><span>架构狮</span></strong></span>\n     <span><strong><span>：</span></strong><span>是不是 NPE 报了好多次？</span></span>\n    </section>\n    <section>\n     <span><strong><span>小&nbsp; &nbsp;猿</span></strong>：是。</span>\n    </section>\n    <section>\n     <span><strong><span><strong><span>架构狮</span></strong></span></strong></span>\n     <span>：一猜就是，因为只有报了很多次，Java 才会自动不打印异常堆栈信息（言外之意：报了多了 java 会省略的），那就找找最开始报异常的日志，肯定会有堆栈信息的<span>（哈哈，心里有谱啦），这种机制叫做 fast throw</span>。</span>\n    </section>\n    <section data-mpa-template-id=\"1544239\" data-mpa-category=\"收藏\">\n     <section data-mpa-template-id=\"1495\" data-mpa-category=\"title\">\n      <section label=\"Copyright © 2017 playhudong All Rights Reserved.\">\n       <section>\n        <section>\n         <p><strong mpa-from-tpl=\"t\">1</strong></p>\n        </section>\n       </section>\n      </section>\n     </section>\n    </section>\n    <section>\n     <span><strong><strong><strong>&nbsp;异常堆栈信息丢了？&nbsp;</strong></strong></strong></span>\n     <strong><strong><strong>&nbsp;</strong></strong></strong>\n    </section>\n    <p><span>只见 Java 攻城狮小猿傻傻的盯着业务日志，一脸呆萌... ...</span></p>\n    <section class=\"code-snippet__fix code-snippet__js\">\n     <pre class=\"code-snippet__js\" data-lang=\"css\"><code><span class=\"code-snippet_outer\">[2020-08-15 00:00:00]: 668812118 Thread-8 [ERROR] payService:java.lang.NullPointerException</span></code></pre>\n    </section>\n    <p><span>与其傻傻迷思，不妨直接来个现场说法，talk is cheap，show me the code，直接上代码。</span></p>\n    <section class=\"code-snippet__fix code-snippet__js\">\n     <pre class=\"code-snippet__js\" data-lang=\"cs\"><code><span class=\"code-snippet_outer\">/**</span></code><code><span class=\"code-snippet_outer\"> * Fast Throw 知识点分享</span></code><code><span class=\"code-snippet_outer\"> * @author 一猿小讲</span></code><code><span class=\"code-snippet_outer\"> */</span></code><code><span class=\"code-snippet_outer\">public class NPETest {</span></code><code><span class=\"code-snippet_outer\">    public static void main(String[] args) {</span></code><code><span class=\"code-snippet_outer\">        String msg = null;</span></code><code><span class=\"code-snippet_outer\">        for (int i = 0; i &lt; 1000000; i++) {</span></code><code><span class=\"code-snippet_outer\">            try {</span></code><code><span class=\"code-snippet_outer\">                // msg 为空,会出现空指针异常</span></code><code><span class=\"code-snippet_outer\">                System.out.println(msg.length());</span></code><code><span class=\"code-snippet_outer\">            } catch (Exception e) {</span></code><code><span class=\"code-snippet_outer\">                e.printStackTrace();</span></code><code><span class=\"code-snippet_outer\">            }</span></code><code><span class=\"code-snippet_outer\">        }</span></code><code><span class=\"code-snippet_outer\">    }</span></code><code><span class=\"code-snippet_outer\">}</span></code></pre>\n    </section>\n    <p><span>程序刚开始跑的时候，程序输出是下面这样子的。</span></p>\n    <section class=\"code-snippet__fix code-snippet__js\">\n     <pre class=\"code-snippet__js\" data-lang=\"css\"><code><span class=\"code-snippet_outer\">java.lang.NullPointerException</span></code><code><span class=\"code-snippet_outer\">&nbsp;&nbsp;at&nbsp;NPETest.main(NPETest.java:11)</span></code><code><span class=\"code-snippet_outer\">... ... </span></code><code><span class=\"code-snippet_outer\">java.lang.NullPointerException</span></code><code><span class=\"code-snippet_outer\">  at NPETest.main(NPETest.java:11)</span></code></pre>\n    </section>\n    <p><span>一会儿的功夫，输出却变成下面这个样子，异常堆栈确实丢了。</span></p>\n    <section class=\"code-snippet__fix code-snippet__js\">\n     <pre class=\"code-snippet__js\" data-lang=\"css\"><code><span class=\"code-snippet_outer\">java.lang.NullPointerException</span></code><code><span class=\"code-snippet_outer\">java.lang.NullPointerException</span></code><code><span class=\"code-snippet_outer\">java.lang.NullPointerException</span></code><code><span class=\"code-snippet_outer\">java.lang.NullPointerException</span></code></pre>\n    </section>\n    <p></p>\n    <p><span><strong><span>架构狮</span></strong></span><span>：惊奇不？有没有匪夷所思。</span></p>\n    <p><strong><span>小&nbsp; &nbsp;猿</span></strong><span>：何解？</span></p>\n    <p><span><strong><span>架构狮</span></strong></span><span>：这种现象就叫做 fast throw，是 Java 虚拟机的一个优化，如果发现代码同一个位置频繁抛出同一类型的异常时，异常堆栈信息就会被清空，那么速度就会非常快，就不用再额外分配内存。</span></p>\n    <p><span></span></p>\n    <p><span><br /></span></p>\n    <p><span>到这儿，Java 攻城狮小猿，点了一根香烟，感觉受益颇深，不过却又陷入了沉思。</span></p>\n    <section data-mpa-template-id=\"1544239\" data-mpa-category=\"收藏\">\n     <section data-mpa-template-id=\"1495\" data-mpa-category=\"title\">\n      <section label=\"Copyright © 2017 playhudong All Rights Reserved.\">\n       <section>\n        <section>\n         <p><strong>2</strong></p>\n        </section>\n       </section>\n      </section>\n     </section>\n    </section>\n    <section>\n     <span><strong><strong><strong>&nbsp;Fast Throw 深入一点，又何妨？&nbsp;</strong></strong></strong></span>\n     <strong><strong><strong>&nbsp;</strong></strong></strong>\n    </section>\n    <p><strong><span>思考一：查问题也太不方面了，如何让异常堆栈信息展示呢？</span></strong></p>\n    <p><span><br /></span></p>\n    <p><span>首先要清楚，JVM 会默认开启&nbsp;Fast Throw&nbsp;优化。如果想关闭这个优化，通过配置&nbsp;-XX:-OmitStackTraceInFastThrow 就可以。</span></p>\n    <p><span><br /></span></p>\n    <p><span>接下来还是跑上面 NPETest 的例子，配置 VM 参数，一起操作一把。</span></p>\n    <p><span><br /></span></p>\n    <p><span>IDEA 运行时指定参数：<span>-XX:-OmitStackTraceInFastThrow。</span></span></p>\n    <p><img class=\"rich_pages\" data-ratio=\"0.15598290598290598\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWN9GqIiajQpY85BZIml3jRaN4iaLiaI8Px1ibepUGwYZ0qp4QGZs2oynQWyPqBHsFdbhXia3ib6dSyGia2ibw/640?wx_fmt=png\" data-type=\"png\" data-w=\"936\" /></p>\n    <p><span>控制台运行时指定参数：</span></p>\n    <section class=\"code-snippet__fix code-snippet__js\">\n     <pre class=\"code-snippet__js\" data-lang=\"css\"><code><span class=\"code-snippet_outer\">java -XX:-OmitStackTraceInFastThrow NPETest</span></code></pre>\n    </section>\n    <span>‍</span>\n    <p><span>效果很明显，异常堆栈信息一直坚挺到最后：<br /></span></p>\n    <section class=\"code-snippet__fix code-snippet__js\">\n     <pre class=\"code-snippet__js\" data-lang=\"css\"><code><span class=\"code-snippet_outer\">... ...</span></code><code><span class=\"code-snippet_outer\">java.lang.NullPointerException</span></code><code><span class=\"code-snippet_outer\">        at NPETest.main(NPETest.java:11)</span></code><code><span class=\"code-snippet_outer\">java.lang.NullPointerException</span></code><code><span class=\"code-snippet_outer\">        at NPETest.main(NPETest.java:11)</span></code><code><span class=\"code-snippet_outer\">java.lang.NullPointerException</span></code><code><span class=\"code-snippet_outer\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;NPETest.main(NPETest.java:11)</span></code></pre>\n    </section>\n    <span>‍</span>\n    <p><span>话又说来，如何再开启 fast throw 优化呢？</span></p>\n    <section class=\"code-snippet__fix code-snippet__js\">\n     <pre class=\"code-snippet__js\" data-lang=\"css\"><code><span class=\"code-snippet_outer\">方式一：默认就是开启优化；</span></code><code><span class=\"code-snippet_outer\">方式二：-XX:+OmitStackTraceInFastThrow</span></code></pre>\n    </section>\n    <p></p>\n    <p><strong><span>思考二：除了 NPE 异常，JVM 开启 fast throw 优化的异常还有哪些？</span></strong></p>\n    <p><strong><span><br /></span></strong></p>\n    <p><span><br /></span></p>\n    <p><span>烟味灭，酒过半，Java 攻城狮小猿彻底掌握了技巧，嘴角洋溢着笑容，此番操作不但解决了生产问题，而且又 get 一装逼技能... ...</span></p>\n    <section data-mpa-template-id=\"1544239\" data-mpa-category=\"收藏\">\n     <section data-mpa-template-id=\"1495\" data-mpa-category=\"title\">\n      <section label=\"Copyright © 2017 playhudong All Rights Reserved.\">\n       <section>\n        <section>\n         <p><strong>3</strong></p>\n        </section>\n       </section>\n      </section>\n     </section>\n    </section>\n    <section>\n     <span><strong><strong><strong><strong>&nbsp;寄语写最后&nbsp;</strong></strong></strong></strong></span>\n    </section>\n    <p><span>本次，主要对小猿在排查生产上遇到的一个匪夷所思的问题，作为基础进行展开，简单对 JVM 特定类型的异常的 fast throw 优化进行了解，</span><span>希望对大家有帮助。</span></p>\n    <section>\n     <strong><strong><span>好了，本次就谈到这里，</span></strong></strong>\n     <strong><strong><span>一起聊技术、谈业务、喷架构，少走弯路，不踩大坑。</span></strong><span>会持续输出原创精彩分享，敬请期待！</span></strong>\n     <img class=\"rich_pages\" data-ratio=\"0.3649122807017544\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOwkpyEoA1IiakYviaHIX4GnoUHGE4kNCqHqAM54WmxryEd76E7Uf1xibO18pftGiafQqI8ibxqMHG34xA/640?wx_fmt=jpeg\" data-type=\"jpeg\" data-w=\"1710\" data-backw=\"544\" data-backh=\"198\" />\n    </section>\n    <section>\n     <br />\n    </section>\n    <section>\n     <span><strong><span>推荐阅读：</span></strong></span>\n    </section>\n    <section>\n     <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485976&amp;idx=1&amp;sn=da09847714bb81039dbf3ececc41e285&amp;chksm=fc004115cb77c8037345126b650ff2666f74f0c8284216015a5212592521bc6de168fb9a563f&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>Java线程池深度揭秘</span></a>\n     <span><strong><span><br /></span></strong></span>\n    </section>\n    <section>\n     <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485946&amp;idx=1&amp;sn=f632fae59cd77f1c4ce07ec17e0cf55c&amp;chksm=fc0042f7cb77cbe175614f8f7cb4a801beace208af970f368220775521c6b696b3698c4f9555&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>彻底搞懂 Java 线程池，干啥都不再发憷</span></a>\n     <span><strong><span><br /></span></strong></span>\n    </section>\n    <section>\n     <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485927&amp;idx=1&amp;sn=ca86e449d91c389ce081e17bb1748264&amp;chksm=fc0042eacb77cbfc489be5a64fbdeaa800815a6426e4fc2c862384107ce2ac158b18f366f43a&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>Java程序跑的快，全要靠线程带</span></a>\n     <span><strong><span><br /></span></strong></span>\n    </section>\n    <section>\n     <span><a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485740&amp;idx=1&amp;sn=cfe3690b635d7376c9e8dec6242ff7f6&amp;chksm=fc004221cb77cb37dbe8654a8cb59eccdf9b0f9cb035c4dd188505f7d67d5548b68de05ac26a&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\">fastjson的这些坑，你误入了没？</a></span>\n    </section>\n    <section>\n     <span><a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485536&amp;idx=1&amp;sn=4347aea8740973fea3346fb48e7efd97&amp;chksm=fc00436dcb77ca7ba2c0fcc105c8adbf1c31f61fc6ed143b936fea806c973fdf37e169aeba61&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\">真实|技术人员该如何站好最后一班岗？</a></span>\n    </section>\n    <section>\n     <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485913&amp;idx=1&amp;sn=3b9742ac55f4c0dcfde4efdf48e365f8&amp;chksm=fc0042d4cb77cbc2606bc9fae868ac92627287bdd2bdbc9a2c33598df5a4ac788b6fe1f1cfc7&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\">Java 8 的这些特性，你知道吗？</a>\n    </section>\n    <section>\n     <span><a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485632&amp;idx=1&amp;sn=82008bf86d8a234561a12e8159b1db49&amp;chksm=fc0043cdcb77cadb8d807cd249f4943da9f4cd7a31a12253394544d00f0e4f593e493f56221d&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\">改掉这些坏习惯，还怕写不出健壮的代码？</a><a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485632&amp;idx=1&amp;sn=82008bf86d8a234561a12e8159b1db49&amp;chksm=fc0043cdcb77cadb8d807cd249f4943da9f4cd7a31a12253394544d00f0e4f593e493f56221d&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\">（一）</a><br /></span>\n    </section>\n    <section>\n     <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485653&amp;idx=1&amp;sn=5b7110ba49b3f84d25906c5120f77a21&amp;chksm=fc0043d8cb77cacecdf9ad853133ee618231d9aadc93f2bc2e72e31bd93edb6123ad5310a25b&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>改掉这些坏习惯，还怕写不出优雅的代码？</span></a>\n     <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485653&amp;idx=1&amp;sn=5b7110ba49b3f84d25906c5120f77a21&amp;chksm=fc0043d8cb77cacecdf9ad853133ee618231d9aadc93f2bc2e72e31bd93edb6123ad5310a25b&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>（二）</span></a>\n     <br />\n    </section>\n    <section>\n     <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485667&amp;idx=1&amp;sn=6ffb3fc831d97953ef2d27e39a768423&amp;chksm=fc0043eecb77caf8428f5a135be1c33de98d8386fa4a0520ef2dbfb071dc07084b1eecd457f7&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>改掉这些坏习惯，还怕写不出优雅的代码？</span></a>\n     <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485667&amp;idx=1&amp;sn=6ffb3fc831d97953ef2d27e39a768423&amp;chksm=fc0043eecb77caf8428f5a135be1c33de98d8386fa4a0520ef2dbfb071dc07084b1eecd457f7&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>（三）</span></a>\n     <br />\n    </section>\n    <section>\n     <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485686&amp;idx=1&amp;sn=658ac9361832f78b110a2b3d1f5af398&amp;chksm=fc0043fbcb77caed013af26972aa2855e7e93936ff3c07797f56f1181a818786c1e27c586adb&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>改掉这些坏习惯，还怕写不出健壮的代码？</span></a>\n     <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485686&amp;idx=1&amp;sn=658ac9361832f78b110a2b3d1f5af398&amp;chksm=fc0043fbcb77caed013af26972aa2855e7e93936ff3c07797f56f1181a818786c1e27c586adb&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>（四）</span></a>\n     <br />\n    </section>\n    <section>\n     <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485697&amp;idx=1&amp;sn=d46496bac254cb0b7a8531f427853ec5&amp;chksm=fc00420ccb77cb1ae2712ff8548c1b94492628733e5ba551ba7a6d6d43392003ebcc94f8bcd6&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>改掉这些坏习惯，还怕写不出精简的代码？</span></a>\n     <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485697&amp;idx=1&amp;sn=d46496bac254cb0b7a8531f427853ec5&amp;chksm=fc00420ccb77cb1ae2712ff8548c1b94492628733e5ba551ba7a6d6d43392003ebcc94f8bcd6&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>（五）</span></a>\n     <br />\n    </section>\n    <section>\n     <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485712&amp;idx=1&amp;sn=3b9e875f870a31f8b257416c29737ff3&amp;chksm=fc00421dcb77cb0b7f6f538221041b462f38602789bf1dfb7b98c02a6a12f53ec1a66e114fd6&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>改掉这些坏习惯，还怕写不出精简的代码？</span></a>\n     <span><a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;mid=2247485712&amp;idx=1&amp;sn=3b9e875f870a31f8b257416c29737ff3&amp;chksm=fc00421dcb77cb0b7f6f538221041b462f38602789bf1dfb7b98c02a6a12f53ec1a66e114fd6&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\">（六）</a></span>\n    </section>\n   </section> \n  </div> \n  <div class=\"reward_qrcode_area reward_area tc\" id=\"js_reward_qrcode\"> \n   <p class=\"tips_global\">Long-press QR code to transfer me a reward</p> \n   <p class=\"reward_tips\"></p> \n   <span class=\"reward_qrcode_img_wrp\"><img class=\"reward_qrcode_img\" id=\"js_reward_qrcode_img\" /></span> \n   <p class=\"tips_global\">As required by Apple's new policy, the Reward feature has been disabled on WeChat for iOS. You can still reward an Official Account by transferring money via QR code.</p> \n  </div> \n </div>\n</div>","descriptionType":"html","feedId":540,"bgimg":"http://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWN9GqIiajQpY85BZIml3jRaN4UPiayYNVAgt5AV2y45u7GGDgISefBEaFAz9pYkfHPW61FgrMEqDqoQ/0?wx_fmt=jpeg","linkMd5":"dfdf3c5d29e93cee21002656d895c0f9","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn9@2020_3/2020/08/17/11-03-03-801_e0aebbb1df1f781e.webp","metaImg":"http://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWN9GqIiajQpY85BZIml3jRaN4UPiayYNVAgt5AV2y45u7GGDgISefBEaFAz9pYkfHPW61FgrMEqDqoQ/0?wx_fmt=jpeg","destWidth":400,"destHeight":170,"author":""},{"createdTime":"2020-08-17 19:02:43","updatedTime":"2020-08-17 19:02:43","title":"​Linux CPU 性能优化指南","link":"https://toutiao.io/k/e6zbho6","description":"<div>\n <div>\n  <section data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\">\n   <h2 data-tool=\"mdnice编辑器\"><span></span></h2>\n   <p><img class=\"rich_pages\" data-ratio=\"0.1575\" data-src=\"https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif\" data-type=\"gif\" data-w=\"400\" /></p>\n   <p></p>\n   <p></p>\n   <p><span>本文作者：allenxguo，腾讯 QQ 音乐后台开发工程师</span></p>\n   <blockquote data-tool=\"mdnice编辑器\">\n    <p>本文主要帮助理解 CPU 相关的性能指标，常见的 CPU 性能问题以及解决方案梳理。</p>\n    <br />\n   </blockquote>\n   <h3 data-tool=\"mdnice编辑器\"><span></span><span>系统平均负载</span><span></span></h3>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>简介</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\"><strong>系统平均负载</strong>：是处于可运行或不可中断状态的平均进程数。</p>\n   <p data-tool=\"mdnice编辑器\"><strong>可运行进程</strong>：使用 CPU 或等待使用 CPU 的进程</p>\n   <p data-tool=\"mdnice编辑器\"><strong>不可中断状态进程</strong>：正在等待某些 IO 访问，一般是和硬件交互，不可被打断（不可被打断的原因是为了保护系统数据一致，防止数据读取错误）</p>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>查看系统平均负载</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">首先<code>top</code>命令查看<strong>进程运行状态</strong>，如下：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span></code><code><span class=\"code-snippet_outer\">10760 user   20   0 3061604  84832   5956 S  82.4  0.6 126:47.61 Process</span></code><code><span class=\"code-snippet_outer\">29424 user   20   0   54060   2668   1360 R  17.6  0.0   0:00.03 **top**</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\">程序状态<code>Status</code>进程<strong>可运行状态</strong>为<code>R</code>，<strong>不可中断运行</strong>为<code>D</code>（后续讲解 top 时会详细说明）</p>\n   <p data-tool=\"mdnice编辑器\"><strong>top</strong>查看系统平均负载：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">top - 13:09:42 up 888 days, 21:32,  8 users,  load average: 19.95, 14.71, 14.01</span></code><code><span class=\"code-snippet_outer\">Tasks: 642 total,   2 running, 640 sleeping,   0 stopped,   0 zombie</span></code><code><span class=\"code-snippet_outer\">%Cpu0  : 37.5 us, 27.6 sy,  0.0 ni, 30.9 id,  0.0 wa,  0.0 hi,  3.6 si,  0.3 st</span></code><code><span class=\"code-snippet_outer\">%Cpu1  : 34.1 us, 31.5 sy,  0.0 ni, 34.1 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st</span></code><code><span class=\"code-snippet_outer\">...</span></code><code><span class=\"code-snippet_outer\">KiB Mem : 14108016 total,  2919496 free,  6220236 used,  4968284 buff/cache</span></code><code><span class=\"code-snippet_outer\">KiB Swap:        0 total,        0 free,        0 used.  6654506 avail Mem</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\">这里的<code>load average</code>就表示系统最近 1 分钟、5 分钟、15 分钟的系统瓶颈负载。</p>\n   <p data-tool=\"mdnice编辑器\"><strong>uptime</strong>查看系统瓶颈负载</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">[root /home/user]# uptime</span></code><code><span class=\"code-snippet_outer\"> 13:11:01 up 888 days, 21:33,  8 users,  load average: 17.20, 14.85, 14.10</span></code></pre>\n   </section>\n   <h5 data-tool=\"mdnice编辑器\"><span></span><span>查看 CPU 核信息</span><span></span></h5>\n   <p data-tool=\"mdnice编辑器\">系统平均负载和 CPU 核数密切相关，我们可以通过以下命令查看当前机器 CPU 信息：</p>\n   <p data-tool=\"mdnice编辑器\"><strong>lscpu</strong>查看 CPU 信息：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">[root@Tencent-SNG /home/user_00]# lscpu</span></code><code><span class=\"code-snippet_outer\">Architecture:          x86_64</span></code><code><span class=\"code-snippet_outer\">CPU op-mode(s):        32-bit, 64-bit</span></code><code><span class=\"code-snippet_outer\">Byte Order:            Little Endian</span></code><code><span class=\"code-snippet_outer\">CPU(s):                8</span></code><code><span class=\"code-snippet_outer\">...</span></code><code><span class=\"code-snippet_outer\">L1d cache:             32K</span></code><code><span class=\"code-snippet_outer\">L1i cache:             32K</span></code><code><span class=\"code-snippet_outer\">L2 cache:              4096K</span></code><code><span class=\"code-snippet_outer\">NUMA node0 CPU(s):     0-7  // NUMA架构信息</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\"><strong>cat /proc/cpuinfo</strong>查看每个 CPU 核的信息：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">processor       : 7   // 核编号7</span></code><code><span class=\"code-snippet_outer\">vendor_id       : GenuineIntel</span></code><code><span class=\"code-snippet_outer\">cpu family      : 6</span></code><code><span class=\"code-snippet_outer\">model           : 6</span></code><code><span class=\"code-snippet_outer\">...</span></code></pre>\n   </section>\n   <h5 data-tool=\"mdnice编辑器\"><span></span><span>系统平均负载升高的原因</span><span></span></h5>\n   <p data-tool=\"mdnice编辑器\">一般来说，系统平均负载升高意味着 CPU 使用率上升。但是他们没有必然联系，CPU 密集型计算任务较多一般系统平均负载会上升，但是如果 IO 密集型任务较多也会导致系统平均负载升高但是此时的 CPU 使用率不一定高，可能很低因为很多进程都处于不可中断状态，<strong>等待 CPU 调度</strong>也会升高系统平均负载。</p>\n   <p data-tool=\"mdnice编辑器\">所以假如我们系统平均负载很高，但是 CPU 使用率不是很高，则需要考虑是否系统遇到了 IO 瓶颈，应该优化 IO 读写速度。</p>\n   <p data-tool=\"mdnice编辑器\">所以系统是否遇到 CPU 瓶颈需要结合 CPU 使用率，系统瓶颈负载一起查看（当然还有其他指标需要对比查看，下面继续讲解）</p>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>案例问题排查</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\"><code>stress</code>是一个施加系统压力和压力测试系统的工具，我们可以使用<code>stress</code>工具压测试 CPU，以便方便我们定位和排查 CPU 问题。</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">yum install stress // 安装stress工具</span></code></pre>\n   </section>\n   <h5 data-tool=\"mdnice编辑器\"><span></span><span>stress 命令使用</span><span></span></h5>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\"> // --cpu 8：8个进程不停的执行sqrt()计算操作</span></code><code><span class=\"code-snippet_outer\"> // --io 4：4个进程不同的执行sync()io操作（刷盘）</span></code><code><span class=\"code-snippet_outer\"> // --vm 2：2个进程不停的执行malloc()内存申请操作</span></code><code><span class=\"code-snippet_outer\"> // --vm-bytes 128M：限制1个执行malloc的进程申请内存大小</span></code><code><span class=\"code-snippet_outer\"> stress --cpu 8 --io 4 --vm 2 --vm-bytes 128M --timeout 10s</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\">我们这里主要验证 CPU、IO、进程数过多的问题</p>\n   <h5 data-tool=\"mdnice编辑器\"><span></span><span>CPU 问题排查</span><span></span></h5>\n   <p data-tool=\"mdnice编辑器\">使用<code>stress -c 1</code>模拟 CPU 高负载情况，然后使用如下命令观察负载变化情况：</p>\n   <p data-tool=\"mdnice编辑器\"><strong>uptime</strong>：使用<code>uptime</code>查看此时系统负载：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\"># -d 参数表示高亮显示变化的区域</span></code><code><span class=\"code-snippet_outer\">$ watch -d uptime</span></code><code><span class=\"code-snippet_outer\">... load average: 1.00, 0.75, 0.39</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\"><strong>mpstat</strong>：使用<code>mpstat -P ALL 1</code>则可以查看每一秒的 CPU 每一核变化信息，整体和<code>top</code>类似，好处是可以把每一秒（自定义）的数据输出方便观察数据的变化，最终输出平均数据：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">13:14:53     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span></code><code><span class=\"code-snippet_outer\">13:14:58     all   12.89    0.00    0.18    0.00    0.00    0.03    0.00    0.00    0.00   86.91</span></code><code><span class=\"code-snippet_outer\">13:14:58       0  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span></code><code><span class=\"code-snippet_outer\">13:14:58       1    0.40    0.00    0.20    0.00    0.00    0.20    0.00    0.00    0.00   99.20</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\">由以上输出可以得出结论，当前系统负载升高，并且其中 1 个核跑满主要在执行用户态任务，此时大多数属于业务工作。所以此时需要查哪个进程导致单核 CPU 跑满：</p>\n   <p data-tool=\"mdnice编辑器\"><strong>pidstat</strong>：使用<code>pidstat -u 1</code>则是每隔 1 秒输出当前系统进程、CPU 数据：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">13:18:00      UID       PID    %usr %system  %guest    %CPU   CPU  Command</span></code><code><span class=\"code-snippet_outer\">13:18:01        0         1    1.00    0.00    0.00    1.00     4  systemd</span></code><code><span class=\"code-snippet_outer\">13:18:01        0   3150617  100.00    0.00    0.00  100.00     0  stress</span></code><code><span class=\"code-snippet_outer\">...</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\"><strong>top</strong>：当然最方便的还是使用<code>top</code>命令查看负载情况：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">top - 13:19:06 up 125 days, 20:01,  3 users,  load average: 0.99, 0.63, 0.42</span></code><code><span class=\"code-snippet_outer\">Tasks: 223 total,   2 running, 221 sleeping,   0 stopped,   0 zombie</span></code><code><span class=\"code-snippet_outer\">%Cpu(s): 14.5 us,  0.3 sy,  0.0 ni, 85.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></code><code><span class=\"code-snippet_outer\">KiB Mem : 16166056 total,  3118532 free,  9550108 used,  3497416 buff/cache</span></code><code><span class=\"code-snippet_outer\">KiB Swap:        0 total,        0 free,        0 used.  6447640 avail Mem</span></code><code><span class=\"code-snippet_outer\"><br /></span></code><code><span class=\"code-snippet_outer\">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span></code><code><span class=\"code-snippet_outer\">3150617 root      20   0   10384    120      0 R 100.0  0.0   4:36.89 stress</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\">此时可以看到是<code>stress</code>占用了很高的 CPU。</p>\n   <h3 data-tool=\"mdnice编辑器\"><span></span><span>IO 问题排查</span><span></span></h3>\n   <p data-tool=\"mdnice编辑器\">我们使用<code>stress -i 1</code>来模拟 IO 瓶颈问题，即死循环执行 sync 刷盘操作：<strong>uptime</strong>：使用<code>uptime</code>查看此时系统负载：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">$ watch -d uptime</span></code><code><span class=\"code-snippet_outer\">...,  load average: 1.06, 0.58, 0.37</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\"><strong>mpstat</strong>：查看此时 IO 消耗，但是实际上我们发现这里 CPU 基本都消耗在了 sys 即系统消耗上。</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">Average:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span></code><code><span class=\"code-snippet_outer\">Average:     all    0.33    0.00   12.64    0.13    0.00    0.00    0.00    0.00    0.00   86.90</span></code><code><span class=\"code-snippet_outer\">Average:       0    0.00    0.00   99.00    1.00    0.00    0.00    0.00    0.00    0.00    0.00</span></code><code><span class=\"code-snippet_outer\">Average:       1    0.00    0.00    0.33    0.00    0.00    0.00    0.00    0.00    0.00   99.67</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\"><strong>IO 无法升高的问题</strong>：</p>\n   <p data-tool=\"mdnice编辑器\">iowait 无法升高的问题，是因为案例中 stress 使用的是 <code>sync()</code>系统调用，它的作用是刷新缓冲区内存到磁盘中。对于新安装的虚拟机，缓冲区可能比较小，无法产生大的 IO 压力，这样大部分就都是系统调用的消耗了。所以，你会看到只有系统 CPU 使用率升高。解决方法是使用 stress 的下一代 stress-ng，它支持更丰富的选项，比如<code>stress-ng -i 1 --hdd 1 --timeout 600</code>（--hdd 表示读写临时文件）。</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">Average:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span></code><code><span class=\"code-snippet_outer\">Average:     all    0.25    0.00    0.44   26.22    0.00    0.00    0.00    0.00    0.00   73.09</span></code><code><span class=\"code-snippet_outer\">Average:       0    0.00    0.00    1.02   98.98    0.00    0.00    0.00    0.00    0.00    0.00</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\"><strong>pidstat</strong>：同上（略）</p>\n   <p data-tool=\"mdnice编辑器\">可以看出 CPU 的 IO 升高导致系统平均负载升高。我们使用<code>pidstat</code>查找具体是哪个进程导致 IO 升高的。</p>\n   <p data-tool=\"mdnice编辑器\"><strong>top</strong>：这里使用 top 依旧是最方面的查看综合参数，可以得出<code>stress</code>是导致 IO 升高的元凶。</p>\n   <p data-tool=\"mdnice编辑器\"><strong>pidstat 没有 iowait 选项</strong>：可能是 CentOS 默认的<code>sysstat</code>太老导致，需要升级到 11.5.5 之后的版本才可用。</p>\n   <h5 data-tool=\"mdnice编辑器\"><span></span><span>进程数过多问题排查</span><span></span></h5>\n   <p data-tool=\"mdnice编辑器\">进程数过多这个问题比较特殊，如果系统运行了很多进程超出了 CPU 运行能，就会出现等待 CPU 的进程。使用<code>stress -c 24</code>来模拟执行 24 个进程（我的 CPU 是 8 核）<strong>uptime</strong>：使用<code>uptime</code>查看此时系统负载：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">$ watch -d uptime</span></code><code><span class=\"code-snippet_outer\">...,  load average: 18.50, 7.13, 2.84</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\"><strong>mpstat</strong>：同上（略）</p>\n   <p data-tool=\"mdnice编辑器\"><strong>pidstat</strong>：同上（略）</p>\n   <p data-tool=\"mdnice编辑器\">可以观察到此时的系统处理严重过载的状态，平均负载高达 <strong>18.50</strong>。</p>\n   <p data-tool=\"mdnice编辑器\"><strong>top</strong>：我们还可以使用<code>top</code>命令查看此时<code>Running</code>状态的进程数，这个数量很多就表示系统正在运行、等待运行的进程过多。</p>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>总结</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">通过以上问题现象及解决思路可以总结出：</p>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      平均负载高有可能是 CPU 密集型进程导致的\n     </section></li>\n    <li>\n     <section>\n      平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了\n     </section></li>\n    <li>\n     <section>\n      当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源\n     </section></li>\n   </ol>\n   <p data-tool=\"mdnice编辑器\">总结工具：<code>mpstat</code>、<code>pidstat</code>、<code>top</code>和<code>uptime</code></p>\n   <h3 data-tool=\"mdnice编辑器\"><span></span><span>CPU 上下文切换</span><span></span></h3>\n   <p data-tool=\"mdnice编辑器\"><strong>CPU 上下文</strong>：CPU 执行每个任务都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器（Program Counter，PC）包括 CPU 寄存器在内都被称为 CPU 上下文。</p>\n   <p data-tool=\"mdnice编辑器\"><strong>CPU 上下文切换</strong>：CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p>\n   <p data-tool=\"mdnice编辑器\"><strong>CPU 上下文切换</strong>：分为<strong>进程上下文切换</strong>、<strong>线程上下文切换</strong>以及<strong>中断上下文切换</strong>。</p>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>进程上下文切换</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">从用户态切换到内核态需要通过<strong>系统调用</strong>来完成，这里就会发生进程上下文切换（特权模式切换），当切换回用户态同样发生上下文切换。</p>\n   <p data-tool=\"mdnice编辑器\">一般每次上下文切换都需要几十纳秒到数微秒的 CPU 时间，如果切换较多还是很容易导致 CPU 时间的浪费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，这里同样会导致<strong>系统平均负载升高</strong>。</p>\n   <p data-tool=\"mdnice编辑器\">Linux 为每个 CPU 维护一个就绪队列，将 R 状态进程按照优先级和等待 CPU 时间排序，选择最需要的 CPU 进程执行。这里运行进程就涉及了进程上下文切换的时机：</p>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      进程时间片耗尽、。\n     </section></li>\n    <li>\n     <section>\n      进程在系统资源不足（内存不足）。\n     </section></li>\n    <li>\n     <section>\n      进程主动\n      <code>sleep</code>。\n     </section></li>\n    <li>\n     <section>\n      有优先级更高的进程执行。\n     </section></li>\n    <li>\n     <section>\n      硬中断发生。\n     </section></li>\n   </ol>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>线程上下文切换</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">线程和进程：</p>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      当进程只有一个线程时，可以认为进程就等于线程。\n     </section></li>\n    <li>\n     <section>\n      当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。\n     </section></li>\n    <li>\n     <section>\n      线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。\n     </section></li>\n   </ol>\n   <p data-tool=\"mdnice编辑器\">所以线程上下文切换包括了 2 种情况：</p>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      不同进程的线程，这种情况等同于进程切换。\n     </section></li>\n    <li>\n     <section>\n      通进程的线程切换，只需要切换线程私有数据、寄存器等不共享数据。\n     </section></li>\n   </ol>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>中断上下文切换</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p>\n   <p data-tool=\"mdnice编辑器\">对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>查看系统上下文切换</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\"><strong>vmstat</strong>：工具可以查看系统的内存、CPU 上下文切换以及中断次数：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">// 每隔1秒输出</span></code><code><span class=\"code-snippet_outer\">$ vmstat 1</span></code><code><span class=\"code-snippet_outer\">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span></code><code><span class=\"code-snippet_outer\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span></code><code><span class=\"code-snippet_outer\"> 3  0      0 157256 3241604 5144444    0    0    20     0 26503 33960 18  7 75  0  0</span></code><code><span class=\"code-snippet_outer\">17  0      0 159984 3241708 5144452    0    0    12     0 29560 37696 15 10 75  0  0</span></code><code><span class=\"code-snippet_outer\"> 6  0      0 162044 3241816 5144456    0    0     8   120 30683 38861 17 10 73  0  0</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\"><strong>cs</strong>：则为每秒的上下文切换次数。</p>\n   <p data-tool=\"mdnice编辑器\"><strong>in</strong>：则为每秒的中断次数。</p>\n   <p data-tool=\"mdnice编辑器\"><strong>r</strong>：就绪队列长度，正在运行或等待 CPU 的进程。</p>\n   <p data-tool=\"mdnice编辑器\"><strong>b</strong>：不可中断睡眠状态的进程数，例如正在和硬件交互。</p>\n   <p data-tool=\"mdnice编辑器\"><strong>pidstat</strong>：使用<code>pidstat -w</code>选项查看具体进程的上下文切换次数：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">$ pidstat -w -p 3217281 1</span></code><code><span class=\"code-snippet_outer\">10:19:13      UID       PID   cswch/s nvcswch/s  Command</span></code><code><span class=\"code-snippet_outer\">10:19:14        0   3217281      0.00     18.00  stress</span></code><code><span class=\"code-snippet_outer\">10:19:15        0   3217281      0.00     18.00  stress</span></code><code><span class=\"code-snippet_outer\">10:19:16        0   3217281      0.00     28.71  stress</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\">其中<code>cswch/s</code>和<code>nvcswch/s</code>表示自愿上下文切换和非自愿上下文切换。</p>\n   <p data-tool=\"mdnice编辑器\"><strong>自愿上下文切换</strong>：是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。</p>\n   <p data-tool=\"mdnice编辑器\"><strong>非自愿上下文切换</strong>：则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换</p>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>案例问题排查</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">这里我们使用<code>sysbench</code>工具模拟上下文切换问题。</p>\n   <p data-tool=\"mdnice编辑器\">先使用<code>vmstat 1</code>查看当前上下文切换信息：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">$ vmstat 1</span></code><code><span class=\"code-snippet_outer\">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span></code><code><span class=\"code-snippet_outer\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span></code><code><span class=\"code-snippet_outer\"> 2  0      0 514540 3364828 5323356    0    0    10    16    0    0  4  1 95  0  0</span></code><code><span class=\"code-snippet_outer\"> 1  0      0 514316 3364932 5323408    0    0     8     0 27900 34809 17 10 73  0  0</span></code><code><span class=\"code-snippet_outer\"> 1  0      0 507036 3365008 5323500    0    0     8     0 23750 30058 19  9 72  0  0</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\">然后使用<code>sysbench --threads=64 --max-time=300 threads run</code>模拟 64 个线程执行任务，此时我们再次<code>vmstat 1</code>查看上下文切换信息：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">$ vmstat 1</span></code><code><span class=\"code-snippet_outer\">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span></code><code><span class=\"code-snippet_outer\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span></code><code><span class=\"code-snippet_outer\"> 2  0      0 318792 3385728 5474272    0    0    10    16    0    0  4  1 95  0  0</span></code><code><span class=\"code-snippet_outer\"> 1  0      0 307492 3385756 5474316    0    0     8     0 15710 20569 20  8 72  0  0</span></code><code><span class=\"code-snippet_outer\"> 1  0      0 330032 3385824 5474376    0    0     8    16 21573 26844 19  9 72  0  0</span></code><code><span class=\"code-snippet_outer\"> 2  0      0 321264 3385876 5474396    0    0    12     0 21218 26100 20  7 73  0  0</span></code><code><span class=\"code-snippet_outer\"> 6  0      0 320172 3385932 5474440    0    0    12     0 19363 23969 19  8 73  0  0</span></code><code><span class=\"code-snippet_outer\">14  0      0 323488 3385980 5474828    0    0    64   788 111647 3745536 24 61 15  0  0</span></code><code><span class=\"code-snippet_outer\">14  0      0 323576 3386028 5474856    0    0     8     0 118383 4317546 25 64 11  0  0</span></code><code><span class=\"code-snippet_outer\">16  0      0 315560 3386100 5475056    0    0     8    16 115253 4553099 22 68  9  0  0</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\">我们可以明显的观察到：</p>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      当前 cs、in 此时剧增。\n     </section></li>\n    <li>\n     <section>\n      sy+us 的 CPU 占用超过 90%。\n     </section></li>\n    <li>\n     <section>\n      r 就绪队列长度达到 16 个超过了 CPU 核心数 8 个。\n     </section></li>\n   </ol>\n   <h5 data-tool=\"mdnice编辑器\"><span></span><span>分析 cs 上下文切换问题</span><span></span></h5>\n   <p data-tool=\"mdnice编辑器\">我们使用<code>pidstat</code>查看当前 CPU 信息和具体的进程上下文切换信息：</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">// -w表示查看进程切换信息，-u查看CPU信息，-t查看线程切换信息</span></code><code><span class=\"code-snippet_outer\">$ pidstat -w -u -t 1</span></code><code><span class=\"code-snippet_outer\"><br /></span></code><code><span class=\"code-snippet_outer\">10:35:01      UID       PID    %usr %system  %guest    %CPU   CPU  Command</span></code><code><span class=\"code-snippet_outer\">10:35:02        0   3383478   67.33  100.00    0.00  100.00     1  sysbench</span></code><code><span class=\"code-snippet_outer\"><br /></span></code><code><span class=\"code-snippet_outer\">10:35:01      UID       PID   cswch/s nvcswch/s  Command</span></code><code><span class=\"code-snippet_outer\">10:45:39        0   3509357         -      1.00      0.00  kworker/2:2</span></code><code><span class=\"code-snippet_outer\">10:45:39        0         -   3509357      1.00      0.00  |__kworker/2:2</span></code><code><span class=\"code-snippet_outer\">10:45:39        0         -   3509702  38478.00  45587.00  |__sysbench</span></code><code><span class=\"code-snippet_outer\">10:45:39        0         -   3509703  39913.00  41565.00  |__sysbench</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\">所以我们可以看到大量的<code>sysbench</code>线程存在很多的上下文切换。</p>\n   <h5 data-tool=\"mdnice编辑器\"><span></span><span>分析 in 中断问题</span><span></span></h5>\n   <p data-tool=\"mdnice编辑器\">我们可以查看系统的<code>watch -d cat /proc/softirqs</code>以及<code>watch -d cat /proc/interrupts</code>来查看系统的软中断和硬中断（内核中断）。我们这里主要观察<code>/proc/interrupts</code>即可。</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">$ watch -d cat /proc/interrupts</span></code><code><span class=\"code-snippet_outer\">RES:  900997016  912023527  904378994  902594579  899800739  897500263  895024925  895452133   Rescheduling interrupts</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\">这里明显看出重调度中断（RES）增多，这个中断表示唤醒空闲状态 CPU 来调度新任务执行，</p>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>总结</span><span></span></h4>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题。\n     </section></li>\n    <li>\n     <section>\n      非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈。\n     </section></li>\n    <li>\n     <section>\n      中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看\n      <code>/proc/interrupts</code>文件来分析具体的中断类型。\n     </section></li>\n   </ol>\n   <h3 data-tool=\"mdnice编辑器\"><span></span><span>CPU 使用率</span><span></span></h3>\n   <p data-tool=\"mdnice编辑器\">除了系统负载、上下文切换信息，最直观的 CPU 问题指标就是 CPU 使用率信息。Linux 通过<code>/proc</code>虚拟文件系统向用户控件提供系统内部状态信息，其中<code>/proc/stat</code>则是 CPU 和任务信息统计。</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">$ cat /proc/stat | grep cpu</span></code><code><span class=\"code-snippet_outer\">cpu  6392076667 1160 3371352191 52468445328 3266914 37086 36028236 20721765 0 0</span></code><code><span class=\"code-snippet_outer\">cpu0 889532957 175 493755012 6424323330 2180394 37079 17095455 3852990 0 0</span></code><code><span class=\"code-snippet_outer\">...</span></code></pre>\n   </section>\n   <p data-tool=\"mdnice编辑器\">这里每一列的含义如下：</p>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。\n     </section></li>\n    <li>\n     <section>\n      nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。\n     </section></li>\n    <li>\n     <section>\n      system（通常缩写为 sys），代表内核态 CPU 时间。\n     </section></li>\n    <li>\n     <section>\n      idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。\n     </section></li>\n    <li>\n     <section>\n      iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。\n     </section></li>\n    <li>\n     <section>\n      irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。\n     </section></li>\n    <li>\n     <section>\n      softirq（通常缩写为 si），代表处理软中断的 CPU 时间。\n     </section></li>\n    <li>\n     <section>\n      steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。\n     </section></li>\n    <li>\n     <section>\n      guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。\n     </section></li>\n    <li>\n     <section>\n      guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。\n     </section></li>\n   </ol>\n   <p data-tool=\"mdnice编辑器\">这里我们可以使用<code>top</code>、<code>ps</code>、<code>pidstat</code>等工具方便的查询这些数据，可以很方便的看到 CPU 使用率很高的进程，这里我们可以通过这些工具初步定为，但是具体的问题原因还需要其他方法继续查找。</p>\n   <p data-tool=\"mdnice编辑器\">这里我们可以使用<code>perf top</code>方便查看热点数据，也可以使用<code>perf record</code>可以将当前数据保存起来方便后续使用<code>perf report</code>查看。</p>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>CPU 使用率问题排查</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">这里总结一下 CPU 使用率问题及排查思路：</p>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      用户 CPU 和 Nice CPU 高，说明用户态进程占用了较多的 CPU，所以应该着重排查进程的性能问题。\n     </section></li>\n    <li>\n     <section>\n      系统 CPU 高，说明内核态占用了较多的 CPU，所以应该着重排查内核线程或者系统调用的性能问题。\n     </section></li>\n    <li>\n     <section>\n      I/O 等待 CPU 高，说明等待 I/O 的时间比较长，所以应该着重排查系统存储是不是出现了 I/O 问题。\n     </section></li>\n    <li>\n     <section>\n      软中断和硬中断高，说明软中断或硬中断的处理程序占用了较多的 CPU，所以应该着重排查内核中的中断服务程序。\n     </section></li>\n   </ol>\n   <h3 data-tool=\"mdnice编辑器\"><span></span><span>CPU 问题排查套路</span><span></span></h3>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>CPU 使用率</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">CPU 使用率主要包含以下几个方面：</p>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      用户 CPU 使用率，包括用户态 CPU 使用率（user）和低优先级用户态 CPU 使用率（nice），表示 CPU 在用户态运行的时间百分比。用户 CPU 使用率高，通常说明有应用程序比较繁忙。\n     </section></li>\n    <li>\n     <section>\n      系统 CPU 使用率，表示 CPU 在内核态运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明内核比较繁忙。\n     </section></li>\n    <li>\n     <section>\n      等待 I/O 的 CPU 使用率，通常也称为 iowait，表示等待 I/O 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互时间比较长。\n     </section></li>\n    <li>\n     <section>\n      软中断和硬中断的 CPU 使用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断。\n     </section></li>\n    <li>\n     <section>\n      除在虚拟化环境中会用到的窃取 CPU 使用率（steal）和客户 CPU 使用率（guest），分别表示被其他虚拟机占用的 CPU 时间百分比，和运行客户虚拟机的 CPU 时间百分比。\n     </section></li>\n   </ol>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>平均负载</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">反应了系统的整体负载情况，可以查看过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。</p>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>上下文切换</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">上下文切换主要关注 2 项指标：</p>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      无法获取资源而导致的自愿上下文切换。\n     </section></li>\n    <li>\n     <section>\n      被系统强制调度导致的非自愿上下文切换。\n     </section></li>\n   </ol>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>CPU 缓存命中率</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">CPU 的访问速度远大于内存访问，这样在 CPU 访问内存时不可避免的要等待内存响应。为了协调 2 者的速度差距出现了 CPU 缓存（多级缓存）。如果 CPU 缓存命中率越高则性能会更好，我们可以使用以下工具查看 CPU 缓存命中率，<a href=\"http://www.brendangregg.com/blog/2014-12-31/linux-page-cache-hit-ratio.html\" data-linktype=\"2\">工具地址</a>、<a href=\"https://github.com/brendangregg/perf-tools\" data-linktype=\"2\">项目地址 perf-tools</a></p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\"># ./cachestat -t</span></code><code><span class=\"code-snippet_outer\">Counting cache functions... Output every 1 seconds.</span></code><code><span class=\"code-snippet_outer\">TIME         HITS   MISSES  DIRTIES    RATIO   BUFFERS_MB   CACHE_MB</span></code><code><span class=\"code-snippet_outer\">08:28:57      415        0        0   100.0%            1        191</span></code><code><span class=\"code-snippet_outer\">08:28:58      411        0        0   100.0%            1        191</span></code><code><span class=\"code-snippet_outer\">08:28:59      362       97        0    78.9%            0          8</span></code><code><span class=\"code-snippet_outer\">08:29:00      411        0        0   100.0%            0          9</span></code><code><span class=\"code-snippet_outer\">08:29:01      775    20489        0     3.6%            0         89</span></code><code><span class=\"code-snippet_outer\">08:29:02      411        0        0   100.0%            0         89</span></code><code><span class=\"code-snippet_outer\">08:29:03     6069        0        0   100.0%            0         89</span></code><code><span class=\"code-snippet_outer\">08:29:04    15249        0        0   100.0%            0         89</span></code><code><span class=\"code-snippet_outer\">08:29:05      411        0        0   100.0%            0         89</span></code><code><span class=\"code-snippet_outer\">08:29:06      411        0        0   100.0%            0         89</span></code><code><span class=\"code-snippet_outer\">08:29:07      411        0        3   100.0%            0         89</span></code><code><span class=\"code-snippet_outer\">[...]</span></code></pre>\n   </section>\n   <h3 data-tool=\"mdnice编辑器\"><span></span><span>总结</span><span></span></h3>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>通过性能指标查工具(CPU 相关)</span><span></span></h4>\n   <figure data-tool=\"mdnice编辑器\"></figure>\n   <section data-tool=\"mdnice编辑器\">\n    <table>\n     <thead>\n      <tr>\n       <th>性能指标</th>\n       <th>工具</th>\n       <th>说明</th>\n      </tr>\n     </thead>\n     <tbody>\n      <tr>\n       <td><span>平均负载</span></td>\n       <td><span>uptime<br />top</span></td>\n       <td><span>uptime 简单展示最近一段时间的平均负载<br />top 展示更多指标</span></td>\n      </tr>\n      <tr>\n       <td><span>CPU 使用率</span></td>\n       <td><span>vmstat<br />mpstat<br />top<br />sar<br />/proc/stat<br /></span></td>\n       <td><span>top、vmstat、mpstat 只可以动态查看当前，而 sar 可以查看历史<br />/proc/stat 是其他性能工具的数据来源</span></td>\n      </tr>\n      <tr>\n       <td><span>进程 CPU 使用率</span></td>\n       <td><span>top<br />pidstat<br />ps<br />htop<br />atop<br /></span></td>\n       <td><span>top、ps 可以以排序方式展示进程 CPU、pidstat 不可排序展示<br />htop、atop 则以不同颜色展示各类数据更直观</span></td>\n      </tr>\n      <tr>\n       <td><span>系统上下文切换</span></td>\n       <td><span>vmstat</span></td>\n       <td><span>展示上下文切换此时、运行状态、不可中断状态进程数量</span></td>\n      </tr>\n      <tr>\n       <td><span>进程上下文切换</span></td>\n       <td><span>pidstat</span></td>\n       <td><span>展示项很多，包括进程上下文切换信息</span></td>\n      </tr>\n      <tr>\n       <td><span>软中断</span></td>\n       <td><span>top<br />/proc/softirqs<br />mpstat</span></td>\n       <td><span>top 可查看软中断 CPU 使用率<br />/proc/softirqs 和 mpstat 则可以查看每个 CPU 上的累计信息</span></td>\n      </tr>\n      <tr>\n       <td><span>硬中断</span></td>\n       <td><span>vmstat<br />/proc/interrupts</span></td>\n       <td><span>vmstat 查看总中断次数信息<br />/proc/interrupts 查看各种中断在每个 CPU 核心上的累计信息</span></td>\n      </tr>\n      <tr>\n       <td><span>网络</span></td>\n       <td><span>dstat<br />sar<br />tcpdump</span></td>\n       <td><span>dstat、sar 较详细的展示出总的网络收发情况<br />tcpdump 提供动态抓取数据包的能力</span></td>\n      </tr>\n      <tr>\n       <td><span>IO</span></td>\n       <td><span>dstat、sar</span></td>\n       <td><span>2 者都提供了详细的 IO 整体情况</span></td>\n      </tr>\n      <tr>\n       <td><span>CPU 信息</span></td>\n       <td><span>/proc/cpuinfo<br />lscpu</span></td>\n       <td><span>都可以查看 CPU 信息</span></td>\n      </tr>\n      <tr>\n       <td><span>系统分析</span></td>\n       <td><span>perf<br />execsnoop</span></td>\n       <td><span>perf 分析各种内核函数调用、热点函数信息<br />execsnoop 监控短时进程</span></td>\n      </tr>\n     </tbody>\n    </table>\n   </section>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>根据工具查性能指标(CPU 相关)</span><span></span></h4>\n   <figure data-tool=\"mdnice编辑器\"></figure>\n   <section data-tool=\"mdnice编辑器\">\n    <table>\n     <thead>\n      <tr>\n       <th>性能工具</th>\n       <th>CPU 性能指标</th>\n      </tr>\n     </thead>\n     <tbody>\n      <tr>\n       <td><span>uptime</span></td>\n       <td><span>5、10、15 分钟内的平均负载展示</span></td>\n      </tr>\n      <tr>\n       <td><span>top</span></td>\n       <td><span>平均负载、运行队列、CPU 各项使用率、进程状态和 CPU 使用率</span></td>\n      </tr>\n      <tr>\n       <td><span>htop</span></td>\n       <td><span>top 增强版，以不同颜色区分不同类型进程，展示更直观</span></td>\n      </tr>\n      <tr>\n       <td><span>atop</span></td>\n       <td><span>CPU、内存、磁盘、网络资源全访问监控，十分齐全</span></td>\n      </tr>\n      <tr>\n       <td><span>vmstat</span></td>\n       <td><span>系统整体 CPU 使用率、上下文切换次数、中断次数，还包括处于运行(r)和不可中断状态(b)的进程数量</span></td>\n      </tr>\n      <tr>\n       <td><span>pidstat</span></td>\n       <td><span>进程、线程(-t)的每个 CPU 占用信息，中断上下文切换次数</span></td>\n      </tr>\n      <tr>\n       <td><span>/proc/softirqs</span></td>\n       <td><span>展示每个 CPU 上的软中断类型及次数</span></td>\n      </tr>\n      <tr>\n       <td><span>/proc/inerrupts</span></td>\n       <td><span>展示每个 CPU 上的硬中断类型及次数</span></td>\n      </tr>\n      <tr>\n       <td><span>ps</span></td>\n       <td><span>每个进程的状态和 CPU 使用率</span></td>\n      </tr>\n      <tr>\n       <td><span>pstree</span></td>\n       <td><span>进程的父子关系展示</span></td>\n      </tr>\n      <tr>\n       <td><span>dstat</span></td>\n       <td><span>系统整体 CPU 使用率(以及相关 IO、网络信息)</span></td>\n      </tr>\n      <tr>\n       <td><span>sar</span></td>\n       <td><span>系统整体 CPU 使用率，以及使用率历史信息</span></td>\n      </tr>\n      <tr>\n       <td><span>strace</span></td>\n       <td><span>跟踪进程的系统调用</span></td>\n      </tr>\n      <tr>\n       <td><span>perf</span></td>\n       <td><span>CPU 性能事件分析，例如：函数调用链、CPU 缓存命中率、CPU 调度等</span></td>\n      </tr>\n      <tr>\n       <td><span>execsnoop</span></td>\n       <td><span>短时进程分析</span></td>\n      </tr>\n     </tbody>\n    </table>\n   </section>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>CPU 问题排查方向</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">有了以上性能工具，在实际遇到问题时我们并不可能全部性能工具跑一遍，这样效率也太低了，所以这里可以先运行几个常用的工具 top、vmstat、pidstat 分析系统大概的运行情况然后在具体定位原因。</p>\n   <section class=\"code-snippet__fix code-snippet__js\">\n    <pre class=\"code-snippet__js\" data-lang=\"\"><code><span class=\"code-snippet_outer\">top 系统CPU =&gt; vmstat 上下文切换次数 =&gt; pidstat 非自愿上下文切换次数 =&gt; 各类进程分析工具(perf strace ps execsnoop pstack)</span></code><code><span class=\"code-snippet_outer\"><br /></span></code><code><span class=\"code-snippet_outer\">top 用户CPU =&gt; pidstat 用户CPU =&gt; 一般是CPU计算型任务</span></code><code><span class=\"code-snippet_outer\"><br /></span></code><code><span class=\"code-snippet_outer\">top 僵尸进程 =&gt;  各类进程分析工具(perf strace ps execsnoop pstack)</span></code><code><span class=\"code-snippet_outer\"><br /></span></code><code><span class=\"code-snippet_outer\">top 平均负载 =&gt; vmstat 运行状态进程数 =&gt;  pidstat 用户CPU =&gt; 各类进程分析工具(perf strace ps execsnoop pstack)</span></code><code><span class=\"code-snippet_outer\"><br /></span></code><code><span class=\"code-snippet_outer\">top 等待IO CPU =&gt; vmstat 不可中断状态进程数  =&gt; IO分析工具(dstat、sar -d)</span></code><code><span class=\"code-snippet_outer\"><br /></span></code><code><span class=\"code-snippet_outer\">top 硬中断 =&gt; vmstat 中断次数 =&gt; 查看具体中断类型(/proc/interrupts)</span></code><code><span class=\"code-snippet_outer\"><br /></span></code><code><span class=\"code-snippet_outer\">top 软中断 =&gt; 查看具体中断类型(/proc/softirqs) =&gt; 网络分析工具(sar -n、tcpdump) 或者 SCHED(pidstat 非自愿上下文切换)</span></code></pre>\n   </section>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>CPU 问题优化方向</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">性能优化往往是多方面的，CPU、内存、网络等都是有关联的，这里暂且给出 CPU 优化的思路，以供参考。</p>\n   <h5 data-tool=\"mdnice编辑器\"><span></span><span>程序优化</span><span></span></h5>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      基本优化：程序逻辑的优化比如减少循环次数、减少内存分配，减少递归等等。\n     </section></li>\n    <li>\n     <section>\n      编译器优化：开启编译器优化选项例如\n      <code>gcc -O2</code>对程序代码优化。\n     </section></li>\n    <li>\n     <section>\n      算法优化：降低苏研发复杂度，例如使用\n      <code>nlogn</code>的排序算法，使用\n      <code>logn</code>的查找算法等。\n     </section></li>\n    <li>\n     <section>\n      异步处理：例如把轮询改为通知方式\n     </section></li>\n    <li>\n     <section>\n      多线程代替多进程：某些场景下多线程可以代替多进程，因为上下文切换成本较低\n     </section></li>\n    <li>\n     <section>\n      缓存：包括多级缓存的使用（略）加快数据访问\n     </section></li>\n   </ol>\n   <h5 data-tool=\"mdnice编辑器\"><span></span><span>系统优化</span><span></span></h5>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      CPU 绑定：绑定到一个或多个 CPU 上，可以提高 CPU 缓存命中率，减少跨 CPU 调度带来的上下文切换问题\n     </section></li>\n    <li>\n     <section>\n      CPU 独占：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。\n     </section></li>\n    <li>\n     <section>\n      优先级调整：使用 nice 调整进程的优先级，适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心应用得到优先处理。\n     </section></li>\n    <li>\n     <section>\n      为进程设置资源限制：使用 Linux cgroups 来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源。\n     </section></li>\n    <li>\n     <section>\n      NUMA 优化：支持 NUMA 的处理器会被划分为多个 Node，每个 Node 有本地的内存空间，这样 CPU 可以直接访问本地空间内存。\n     </section></li>\n    <li>\n     <section>\n      中断负载均衡：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把中断处理过程自动负载均衡到多个 CPU 上。\n     </section></li>\n   </ol>\n   <p data-tool=\"mdnice编辑器\"><strong>参考</strong></p>\n   <p data-tool=\"mdnice编辑器\">极客时间：Linux 性能优化实战</p>\n   <p data-tool=\"mdnice编辑器\"></p>\n   <p><img class=\"rich_pages\" data-ratio=\"0.729264475743349\" data-src=\"https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvatricjRxhpM1x45aB6doaVg7WMhINPwOiaqpskia1kH7hgibO0dicW2HLcW8HRGMzESQwehIcyckLXtwsA/640?wx_fmt=gif\" data-type=\"gif\" data-w=\"639\" /></p>\n  </section> \n </div>\n</div>","descriptionType":"html","feedId":540,"bgimg":"http://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauQTX4s0hVUVMDXiazR2JZvPVqW0QzKWbZXuWmEAz2M20SEFD81HiagsVgkFSxDHHS4PCeHaPDaicT2w/0?wx_fmt=jpeg","linkMd5":"0d76e13ac94360798d027b830ef86216","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn6@2020_6/2020/08/17/11-03-04-610_1b3ddf3d9d88516e.webp","metaImg":"http://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauQTX4s0hVUVMDXiazR2JZvPVqW0QzKWbZXuWmEAz2M20SEFD81HiagsVgkFSxDHHS4PCeHaPDaicT2w/0?wx_fmt=jpeg","destWidth":1280,"destHeight":546,"author":""},{"createdTime":"2020-08-17 19:02:39","updatedTime":"2020-08-17 19:02:39","title":"如何复用一套代码满足多样化的需求？","link":"https://toutiao.io/k/x35vow3","description":"<div> \n <div> \n  <article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"> \n   <h1><a id=\"user-content-如何复用一套代码满足多个产品经理\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#如何复用一套代码满足多个产品经理\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>如何复用一套代码满足多个产品经理？</h1> \n   <p>有太多的文章教你怎么组织代码了。但是这些文章大都是系统A，模块B的抽象写意派。虽然看着很有道理的样子，但就是看不懂。 本文的特点是有十多个带有具体业务场景的例子。从如何接新需求的角度来分析模块应该怎么拆分，才可以优雅地复用，延长遗留代码的寿命。 <strong>主要的内容都在例子里</strong>，请不要直接看结论，相信我，只看结论等于没看。</p> \n   <p>全文分为四个章节：</p> \n   <h1><a id=\"user-content-模块切分的好坏标准是什么-\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#模块切分的好坏标准是什么-\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>模块切分的好坏标准是什么？ <a name=\"user-content-criteria-of-modularization\"></a></h1> \n   <p>复用，以及支持多样性，都是同一个问题的不同表述。其实质问题是如何对系统进行模块分解。需要分成几个模块，模块之间的依赖关系是怎样的？ 我们通过4个例子来非常具象化地讨论。</p> \n   <h2><a id=\"user-content-公共模块应该稳定\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#公共模块应该稳定\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>公共模块应该稳定</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/criteria-of-modularization/common-module-should-be-stable\">【阅读该例子】</a></p> \n   <p>在 <a href=\"https://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/1292025948\" rel=\"nofollow\">Agile Software Development</a> 书中，Robert Martin 讲过了很重要的两个原则</p> \n   <ul> \n    <li>越是被很多模块依赖的模块，越应该减少改动。道理很简单，底层模块一改，上层的模块必然受到影响。依赖关系的方向，就是“不稳定”依赖“稳定”的方向。</li> \n    <li>要复用的模块不要把过多的东西捆绑，要复用就整体复用：Common Reuse Principle</li> \n   </ul> \n   <h2><a id=\"user-content-避免超级繁忙的顶层模块\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#避免超级繁忙的顶层模块\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>避免超级繁忙的顶层模块</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/criteria-of-modularization/avoid-crazy-busy-top-module\">【阅读该例子】</a></p> \n   <p>模块与模块之间的依赖关系，就是抽象与稳定的关系。但实践中，像“业务编排API”和“BFF”，你很难判断谁比谁更稳定，更抽象。当我们一个业务请求，需要经过一串模块的时候，往往是有问题的。因为当要做修改的时候，你会觉得在哪个环节拦一刀都有道理。David Parnas 在 <a href=\"https://www.researchgate.net/profile/David_Parnas/publication/200085877_On_the_Criteria_To_Be_Used_in_Decomposing_Systems_into_Modules/links/55956a7408ae99aa62c72622/On-the-Criteria-To-Be-Used-in-Decomposing-Systems-into-Modules.pdf?origin=publication_detail\" rel=\"nofollow\">The Secret History of Information Hiding</a> 一文中也写道，他认为 Levels of Abstraction 是很难判断的。</p> \n   <p>这个例子应该怎样调整是合适的?分法有很多，可以按流程步骤分，可以按业务变化频率分，但从依赖关系的结构上来说，一定是这样的结构</p> \n   <ul> \n    <li>一定是<strong>多个模块</strong>直接面向<strong>多个业务方向</strong>，每个模块承担一些，而不是集中把修改工作都压到一个顶层模块上</li> \n    <li>在这多个模块上面一定不能拿一个“业务收口”模块再往顶上套一层。所谓业务编排，其实就是业务编程。只要可以编程，就会抑制不住地往里面加东西。</li> \n   </ul> \n   <p>不会因为把函数调用，改叫“业务编排”，就改变模块之间的依赖关系。依赖关系才是真正决定性因素。</p> \n   <h2><a id=\"user-content-通过新增模块来扩展功能\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#通过新增模块来扩展功能\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>通过新增模块来扩展功能</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/criteria-of-modularization/extending-by-adding-new-module\">【阅读该例子】</a></p> \n   <p>从这个例子里我们可以看到如下的规律</p> \n   <ul> \n    <li>一个新功能要修改哪个模块取决于模块的依赖关系。typescript-language-features 在依赖关系里有 ts server，所以一些功能就得改它那里。</li> \n    <li>新增模块来实现新功能可以避免把给现有模块添加新的依赖，比如 mocha 这个依赖就只需要加到 mocha-test-explorer 上。是否新增一个模块，还是修改已有的模块，是否引入依赖是一个关键决策因素。</li> \n   </ul> \n   <p>稍微有点经验程序员都能体会到 vscode 做为 Eric Gamma 大神在 eclipse 之后的又一力作，架构上是很优秀的。但可能只是感觉优秀，又说不出来优秀在哪里。通过这个例子，我们就可以看到，判断一个模块拆分结构是否优秀的唯一标准，就是看它如何处理需求的变更和新增。当所有的需求都要往一个模块里改的时候，这个拆分就是糟糕的。当新的需求往往可以通过新增模块来实现的时候，这个拆分结构就是优秀的。</p> \n   <h2><a id=\"user-content-要更关注易变性而不是功能切分\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#要更关注易变性而不是功能切分\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>要更关注“易变性”而不是“功能切分”</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/criteria-of-modularization/more-focus-on-violatility-than-functionality\">【阅读该例子】</a></p> \n   <p>这个例子说明了</p> \n   <ul> \n    <li>按流程步骤切分未必是最优方案，“易变性”是更重要的可度量指标，其实看看 git 提交记录就知道了</li> \n    <li>前面三个例子都是说明不要把改动集中到一个模块里，这个其实相对好实现。极端情况下，每个函数，每一行代码都拆成一个模块就可以实现。</li> \n    <li>这个例子要说明的是反过来，如果一个需求要改动太多的模块，那也是有问题的。这个其实非常难以实现，但是是追求的目标。</li> \n   </ul> \n   <h2><a id=\"user-content-模块切分的好坏标准\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#模块切分的好坏标准\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>模块切分的好坏标准</h2> \n   <p>模块切分的出发点其实非常简单直白</p> \n   <ul> \n    <li>如果所有的需求都要集中到一个模块去等排期，那必然会拖慢速度 \n     <ul> \n      <li>公共模块应该稳定</li> \n      <li>避免超级繁忙的顶层模块</li> \n      <li>通过新增模块来扩展功能</li> \n     </ul> </li> \n    <li>如果一个需求动辄就要数个模块联合开发和调试，那必然会拖慢速度 </li> \n   </ul> \n   <p>综上，在这样的一个依赖关系下</p> \n   <p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://toutiao.io/taowen/modularization-examples/blob/master/shape.drawio.svg\"><img src=\"https://toutiao.io/taowen/modularization-examples/raw/master/shape.drawio.svg\" alt=\"shape\" /></a></p> \n   <p>经常修改的应该是中间这一层。最好是一个需求只添加，或者修改其中的一个模块。</p> \n   <p>模块划分的静态结构无所谓好坏，只关注新需求如何修改或者新增的问题。 不用去争辩是应该大前台，还是大中台。代码量不是问题，圈复杂度也不是问题。 唯一度量的标准就是去看每个新需求都是怎么改出来的。</p> \n   <h1><a id=\"user-content-这些经典的解决方案用了也就那样-\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#这些经典的解决方案用了也就那样-\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>这些经典的解决方案用了也就那样 <a name=\"user-content-module-boundary-unchanged\"></a></h1> \n   <p>上一章提出的好坏标准有任何一条是新鲜的么? 一条都没有。 以前的文章可能例子举得少了一点，但是总结的原则都是差不多的。 那接下来的追问就是，如果原则一直都在那里，那为什么我们过去看过的代码都没遵守这些原则呢? 我有三个猜测</p> \n   <ul> \n    <li>最容易想到的解决方案未必是最佳的方案</li> \n    <li>真正松耦合的接口定义形式并没有被大众所熟知</li> \n    <li>按照这些松耦合的接口去分解模块并不容易落地</li> \n   </ul> \n   <p>我先来分析第一个猜想，列举几个最常见的解决方案。</p> \n   <h2><a id=\"user-content-用-interface-代替-class\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#用-interface-代替-class\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>用 interface 代替 class</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/module-boundary-unchanged/replace-class-with-interface\">【阅读该例子】</a></p> \n   <p>这个例子里说明了两个现象：</p> \n   <ul> \n    <li>按流程步骤切分的模块，步骤之间必然有很强的数据依赖。这种业务逻辑上的依赖，用任何形式上的解耦合方式都是不起任何作用的</li> \n    <li>名字具有欺骗性，收银台这样的生活中能够遇见的物理存在的概念，和业务上实际承担的角色可能是不对等的。你在商场里看见的收银台，和你这个系统里的收银台，只是名字相同。不能简单地认为 <code>pay(100, 'USD')</code> 就可以完全把服务给封装起来。</li> \n   </ul> \n   <p>如果这种一个模块需要 <code>f(args)</code> 传递一个很大的结构体给另外一个模块的方式是不理想的。那么更理想的模块间接口形式是什么?<a href=\"https://www.ben-morris.com/why-is-loose-coupling-between-services-so-important/\" rel=\"nofollow\">有些文章</a>会把运行时的RPC性能，系统不宕机，和不易于独立做需求变更放在一起讨论。但是我认为这样混到一起来讨论问题会误入歧途。比如是不是数一数两个模块之间的 RPC 调用的数量，甚至是从运维系统里导出一份运行时的 RPC metrics 就可以说明两个模块的耦合程度呢?</p> \n   <p>应该聚焦在“新需求怎么接”这一个问题上，不要躲闪，不要旁顾左右而言它。其实就是看一下，两个模块之间边界无论用什么来定义，是不是经常要被修改。用 interfac 关键字代替 class 关键字不会有实质性的作用。用 gRPC 代替 jar 包也不会有实质性的作用。</p> \n   <h2><a id=\"user-content-阿里中台到底是什么\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#阿里中台到底是什么\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>阿里中台到底是什么?</h2> \n   <p>阿里巴巴公司有一个名字叫“中台”的技术。</p> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/module-boundary-unchanged/alibaba-middle-office-technology\">【阅读该例子】</a></p> \n   <p>这个例子说明了两个现象：</p> \n   <ul> \n    <li>没有复用价值的复用是不值得去复用的：阿里内部至少三套“中台”框架。商品和交易链路对于淘系，盒马，闲鱼也是不同的。因为大家做出了判断，之前的方案，之前的模块，对当前的业务需求没有复用价值。这是一个理性的决定，不复用很多时候是正确的选择。</li> \n    <li>没有消除 if/else 的银弹。不调整模块边界，只换一个if/else的表达方式，是换汤不换药的。</li> \n   </ul> \n   <h2><a id=\"user-content-打包和部署方式的调整\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#打包和部署方式的调整\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>打包和部署方式的调整</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/module-boundary-unchanged/packaging-deployment\">【阅读该例子】</a></p> \n   <p>这个例子说明了：</p> \n   <ul> \n    <li>代码生成，lowcode 等技术，实质上都是模块的打包和部署方案。</li> \n    <li>从纯静态，到纯动态，我们有一个光谱的选项。选择更静态，还是更动态，主要的看这个修改是程序员来做，还是运营人员来做。只是不同角色的“编程人员”的称谓差异。</li> \n    <li>打包和部署方案不会改变模块之间的边界，从管理依赖控制变更范围的角度来说，打包和部署的各种方案是等价的</li> \n   </ul> \n   <h2><a id=\"user-content-不调整模块边界是没有效果的\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#不调整模块边界是没有效果的\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>不调整模块边界是没有效果的</h2> \n   <p>上面的三个例子的共同特点就是用一个形式代替另外一个等价的形式。 调整打包和部署方式是容易的。 调整模块边界，重塑接口，这个是要触及灵魂的。痛彻心扉。 最容易想到也是最容易办到的方案，未必就是最好的方案。</p> \n   <h1><a id=\"user-content-松耦合的接口应该定义成什么样子\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#松耦合的接口应该定义成什么样子\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>松耦合的接口应该定义成什么样子？<a name=\"user-content-loosely-coupled-interface\"></a></h1> \n   <p>上一章我们看到了，只是改变依赖的“形式”，不会影响依赖的“实质”。 如果要让模块之间更好组合，最终仍然是要去调整模块之间的边界，也就是要把“模块接口”定义成“松耦合”的。 “松耦合”已经是陈词滥调了。能不能用具体的例子来说明到底这样的接口是长什么样子的?</p> \n   <h2><a id=\"user-content-基于-ui-的组合\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#基于-ui-的组合\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>基于 UI 的组合</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/loosely-coupled-interface/ui-composition\">【阅读该例子】</a></p> \n   <p>这个例子展示了两个最实用的技术：</p> \n   <ul> \n    <li>在 UI 上做组合，对于编排方来说，UI 组件内部就是一个完全的黑盒。</li> \n    <li>Opaque Business Pointer：透传业务 id，每个模块都可以根据这个 id 来解决出自己需要的含义来。对于透传方来说，这个 id 就是一个完全的黑盒。</li> \n   </ul> \n   <p>无论是“UI组件透传”，还是“id透传”，从耦合级别上来说都是最黑盒的那种。</p> \n   <h2><a id=\"user-content-不要返回值\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#不要返回值\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>不要返回值</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/loosely-coupled-interface/no-return-value\">【阅读该例子】</a></p> \n   <p>这个例子说明了两点：</p> \n   <ul> \n    <li>Event 就是不要返回值。所以两个模块之间交换的信息更少，接口就更松耦合。</li> \n    <li>单独由后台开发引入 Event 往往无法达成目的。需要配合前端团队引入“基于 UI 的组合”，以及配合产品团队引入“产品方案降级”才能调整得动边界。模块之间的边界是不能靠一个职能团队撬动的，必须集合前端，后端，产品多方的合力。</li> \n   </ul> \n   <h2><a id=\"user-content-虚拟文件系统\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#虚拟文件系统\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>虚拟文件系统</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/loosely-coupled-interface/virtual-file-system\">【阅读该例子】</a></p> \n   <p>这个例子说明了两个技术：</p> \n   <ul> \n    <li>一个模块可以把自己伪装成“虚拟文件系统”。让使用者感觉自己就是在读写一个存储而已。</li> \n    <li>pull v.s. push：在所有视图渲染，事件模式检测类的业务里。pull 都是更好的策略，它可以产生最精确的依赖关系，减少变更的影响范围。</li> \n   </ul> \n   <p>当“UI 组合”这种纯黑的方案不行，“不要返回值”这种半黑的方案也不行，那么伪装成存储是需要模块间双向通信的前提下的比较优的解决方案。</p> \n   <h1><a id=\"user-content-为什么实际的业务代码都没有写成你说的那个样子\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#为什么实际的业务代码都没有写成你说的那个样子\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>为什么实际的业务代码都没有写成你说的那个样子？<a name=\"user-content-patterns\"></a></h1> \n   <p>这是一个真正拷问灵魂的问题。</p> \n   <ul> \n    <li>有大量的实际业务中的项目，违反了所有的最佳实践。但是商业上仍然大获成功</li> \n    <li>从1971年的《On the criteria to be used in decomposing systems into modules》开始，就不断鼓吹要做好模块分解。为什么这么多年过去了，不但没有看见进步，甚至感觉还在退步?</li> \n   </ul> \n   <p>前两天在朋友圈刷到一句睿智的话</p> \n   <ul> \n    <li>当你听到别人的一个想法的时候，先想想为什么行得通</li> \n    <li>当你要提出一个想法的时候，先想想为什么行不通</li> \n   </ul> \n   <p>行得通的理由</p> \n   <ul> \n    <li>虽然不用最佳的模块切分，会导致更多的联合修改联合调试，但是仍然可以完成需求</li> \n    <li>目标是及时响应市场需求，这并不完全依赖好的模块切分。通过996，通过找更多的人，仍然可以达成目标。</li> \n    <li>编码只是响应市场需求要做的工作中的很少一部分，只要能实现，就不决定成败。有的时候系统宕机，可能更致命，更值得解决。</li> \n    <li>设计简单，新人更容易上手</li> \n    <li>弊端需要成年累月才会显现出来，对创业期没有影响</li> \n    <li>技术革新速度很快，新公司倒闭速度很快，代码本来就应该隔几年重写一次</li> \n    <li>数学家总是希望自己的定理尽可能泛化普适，而工程师为了效率等原因，更追求适用就好</li> \n   </ul> \n   <p>行不通的理由</p> \n   <ul> \n    <li>UI组合：前端技术最近几年变动特别剧烈，一直稳定不下来</li> \n    <li>UI组合：UI非常专业，需要独立的团队。没法实现端到端的业务切分</li> \n    <li>不要返回值：我要返回值啊，没返回值实现不了界面，实现不了需求</li> \n    <li>运行时报错信息是在一起的，这么分着写很难和运行时的现象对应起来</li> \n    <li>编辑的时候往往需要在更多的模块/目录/文件之间跳转</li> \n    <li>需求可能是跨模块的，创新性的需求往往会对模块化的假设产生剧烈的影响</li> \n    <li>产品经理的分工调整，产品需求的粒度是经常变化的，导致一个产品经理需要改多个模块</li> \n   </ul> \n   <p>我们要客观地看待复用和支持多样性。很多时候不复用就是最佳的解决方案。很多时候堆砌 if/else 就是最佳的解决方案。</p> \n   <p>在保持客观理性的同时，能不能把“行不通”的种种障碍逐一分析以下，给每种类型的障碍提供一个切实可行的解决方案呢? 也就是我们能不能给一个设计模式的列表，所谓设计模式就是“问题清单”。</p> \n   <h2><a id=\"user-content-如何发明底层抽象\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#如何发明底层抽象\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>如何发明底层抽象？</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/how-to-invent-abstraction\">【阅读该模式】</a></p> \n   <p>如何才能像大师一样，上来就知道抽象的接口应该如何定义? 我为什么总是想不出来该怎么抽象?</p> \n   <h2><a id=\"user-content-分模块之后代码不好读了怎么办\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#分模块之后代码不好读了怎么办\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>分模块之后代码不好读了怎么办？</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/how-to-maintain-readability\">【阅读该模式】</a></p> \n   <p>为了代码复用，拆了很多个模块，导致代码不好阅读了怎么办? 之前代码虽然写的挫，但是 ctrl+f 在一个文件里就可以找到对应的代码，现在找段代码可费劲了。</p> \n   <h2><a id=\"user-content-代码写成活的比写成死的要麻烦多了怎么办\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#代码写成活的比写成死的要麻烦多了怎么办\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>代码写成活的比写成死的要麻烦多了怎么办?</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/how-to-lower-plugin-tax-rate\">【阅读该模式】</a></p> \n   <p>开槽，开插件，都是为了把代码写得更灵活。但是每一开一个扩展点，就需要写一堆样板代码。如何才能降低“插件税”呢?</p> \n   <h2><a id=\"user-content-怎么扩展额外的字段呢\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#怎么扩展额外的字段呢\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>怎么扩展额外的字段呢?</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/how-to-add-field\">【阅读该模式】</a></p> \n   <p>经常看见一个表里面有 extra_fields 之类的字段，里面放一个大 JSON。每个需求都要加新字段怎么弄?</p> \n   <h2><a id=\"user-content-怎么支持新的订单类型\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#怎么支持新的订单类型\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>怎么支持新的订单类型?</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/how-to-add-new-order-type\">【阅读该模式】</a></p> \n   <p>为了支持新的业务，往往需要给 OrderType 这个字段上添加新的订单类型。为了不影响已有的业务，还经常要加 isNewBiz 这样的“Flag”来标识新的业务场景。除了一直加新的Flag，就没别的办法了吗?</p> \n   <h2><a id=\"user-content-ui组合为何难以落地\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#ui组合为何难以落地\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>UI组合为何难以落地?</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/ui-composition-obstacles\">【阅读该模式】</a></p> \n   <p>松耦合模块边界的最佳范例就是基于 UI 的组合。但是为什么在过去的历史经验里，这样的模块切分的方式很难落地? 有没有什么具体的技术方案可以借鉴?</p> \n   <h2><a id=\"user-content-事件驱动为何难以有收益\" class=\"anchor\" aria-hidden=\"true\" href=\"https://toutiao.io/k/x35vow3#事件驱动为何难以有收益\"> \n     <svg class=\"octicon octicon-link\" viewbox=\"0 0 16 16\" version=\"1.1\" aria-hidden=\"true\"> \n      <path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\" /> \n     </svg></a>事件驱动为何难以有收益?</h2> \n   <p><a href=\"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/event-driven-obstacles\">【阅读该模式】</a></p> \n   <p>事件驱动是大家谈论解耦的时候寄予众望的技术。但是具体到实际的项目中，经常发现事件驱动没有发挥出什么作用。为什么会这样?</p> \n  </article> \n </div> \n</div>","descriptionType":"html","feedId":540,"bgimg":"https://toutiao.io/taowen/modularization-examples/raw/master/shape.drawio.svg","linkMd5":"aaa1643fd589bbb7ae0c2785677d04f2","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","author":"","articleImgCdnMap":{"https://toutiao.io/taowen/modularization-examples/raw/master/shape.drawio.svg":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg"}},{"createdTime":"2020-08-17 19:02:43","updatedTime":"2020-08-17 19:02:43","title":"收藏! 超全的 GitHub 计算机算法、机器学习、深度学习的面试指南集锦","link":"https://toutiao.io/k/kumhh9k","description":"<div>\n <div>\n  <div class=\"rich_media_content \" id=\"js_content\"> \n   <p></p>\n   <p>这是github 上的计算机基础、算法、机器学习、深度学习的面试算法指南的汇总，非常值得收藏。</p>\n   <p><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.66171875\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/9ZHzCnhO6Yf5zxviaJnvTqYZTNRMes6LiaSs5Ak4yib8IibGEGlhvFSZHdMdPSMlwHpJ97PdtL3noAghHIXffGUYrA/640?wx_fmt=png\" data-type=\"png\" data-w=\"1280\" /></p>\n   <p></p>\n   <p><strong>1、leetcode 题解，记录自己的 leetcode 解题之路</strong></p>\n   <p>github上35万星</p>\n   <p>https://github.com/azl397985856/leetcode</p>\n   <p></p>\n   <p><strong>2、收录常见面试算法题，包括&nbsp;剑指offer&nbsp;和&nbsp;LeetCode</strong>&nbsp;</p>\n   <p>https://github.com/YaxeZhang/Just-Code</p>\n   <p></p>\n   <p><strong>3、作者将 LeetCode 上所有的题目都用动画的形式演示出来</strong></p>\n   <p>github上57万星</p>\n   <p>https://github.com/MisterBooo/LeetCodeAnimation</p>\n   <p></p>\n   <p><strong>4、</strong><span><strong><span>从零开始学算法，</span></strong></span><strong>LeetCode上算法的分类讲解</strong></p>\n   <p>https://muyids.github.io/simple-algorithm/</p>\n   <p></p>\n   <p><img class=\"rich_pages\" data-ratio=\"0.6597014925373135\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/9ZHzCnhO6Yf5zxviaJnvTqYZTNRMes6LiarhviaqOETeK9gMTOKZQj4RGx7lN0VncC774kSc2oFLgIkbbf5U5SgZw/640?wx_fmt=png\" data-type=\"png\" data-w=\"1340\" /></p>\n   <p><strong><br /></strong></p>\n   <p><strong>5、一份来自亚马逊工程师的Google面试指南</strong>，GitHub收获13万星</p>\n   <p>作者的介绍非常全面，以及总结了如何去全面的准备，非常值得学习</p>\n   <p>https://github.com/jwasham/coding-interview-university/blob/master/translations/README-cn.md</p>\n   <p></p>\n   <p><strong>6、2021秋招 计算机视觉算法岗面经整理</strong>——包含实习和校招等 内推整理</p>\n   <p>https://github.com/DWCTOD/interview</p>\n   <p></p>\n   <p></p>\n   <p><strong>7、从2010年10月起，</strong><strong>July</strong><strong>&nbsp;开始整理一个微软面试100题的系列</strong>，他在整理这个系列的过程当中，越来越强烈的感觉到，可以从那100题中精选一些更为典型的题，每一题详细阐述成章，不断优化，于此，便成了程序员编程艺术系列。</p>\n   <p>https://github.com/julycoding/The-Art-Of-Programming-By-July</p>\n   <p></p>\n   <p><strong>8、架构、搜索、推荐、广告系统优质资源整理</strong></p>\n   <p>这篇文章意图是收集市面上质量不错的后端架构、AI架构、搜索、 推荐、 广告引擎技术资料，内容来源包括开源项目官网（Lucene、Solr、Elastic）、综合技术网站（AIQ 、infoQ、Stackoverflow、github 等、国内外知名互联网公司技术博客（阿里中间件团队博客、美团技术博客等）、知名技术牛人公众号博客等。</p>\n   <p>https://github.com/cbamls/AI_Tutorial</p>\n   <p></p>\n   <p></p>\n   <p><strong>9、算法实现可视化</strong></p>\n   <p>https://github.com/algorithm-visualizer/algorithm-visualizer</p>\n   <p><img class=\"rich_pages\" data-ratio=\"0.5605381165919282\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/9ZHzCnhO6Yf5zxviaJnvTqYZTNRMes6Lia29icy1GrwgPjzf7Gd6IAVBJMC3SNWECjaJWHLdhFicRxhzu8pibFk1hNA/640?wx_fmt=png\" data-type=\"png\" data-w=\"1338\" /></p>\n   <p></p>\n   <p><strong>10、深度学习相关的系列文章</strong>，总结了在深度学习实践中的一些经验，包括常见深度学习框架、基础网络、神经网络的优化、模型之间的转换、适用于移动端的框架、神经网络的设计、神经网络的适用场景、基础网络的训练、相关面试题、对抗蒸馏</p>\n   <p>https://github.com/zeusees/HyperDL-Tutorial</p>\n   <p></p>\n   <p><strong>11、深度学习500问</strong>，以问答形式对常用的概率知识、线性代数、机器学习、深度学习、计算机视觉等热点问题进行阐述，以帮助自己及有需要的读者。</p>\n   <p>https://github.com/scutan90/DeepLearning-500-questions</p>\n   <p></p>\n   <p><strong>12、机器学习、深度学习、自然语言处理汇总</strong></p>\n   <p>https://github.com/apachecn/AiLearning</p>\n   <p></p>\n   <p>更多关注</p>\n   <p><img class=\"rich_pages\" data-ratio=\"0.3649122807017544\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/9ZHzCnhO6Yf5zxviaJnvTqYZTNRMes6Liaibtc2gfYGW472IHhpAAG01icJ0pYJybhxia0oIpicytDpDBXMFBngCpg2g/640?wx_fmt=png\" data-type=\"png\" data-w=\"1710\" /></p> \n  </div> \n </div>\n</div>","descriptionType":"html","feedId":540,"bgimg":"http://mmbiz.qpic.cn/mmbiz_jpg/9ZHzCnhO6Yf5zxviaJnvTqYZTNRMes6Lia1NdbbYGRTwvibibdmeH2L7gPfFhMQUkX8uSThqacficPiaYKrY82ZZeUXg/0?wx_fmt=jpeg","linkMd5":"eddd0fa1ac57c28dbc6263ed79cfc7ba","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn8@2020_5/2020/08/17/11-03-05-833_caa3d7e98235fafb.webp","metaImg":"http://mmbiz.qpic.cn/mmbiz_jpg/9ZHzCnhO6Yf5zxviaJnvTqYZTNRMes6Lia1NdbbYGRTwvibibdmeH2L7gPfFhMQUkX8uSThqacficPiaYKrY82ZZeUXg/0?wx_fmt=jpeg","destWidth":1280,"destHeight":542,"author":""},{"createdTime":"2020-08-17 19:02:39","updatedTime":"2020-08-17 19:02:39","title":"Facebook 对 Golang 依赖注入的实现","link":"https://toutiao.io/k/aiwwan4","description":"<div> \n <div> \n  <div class=\"post-body\" itemprop=\"articleBody\"> \n   <p>依赖注入是一个经典的设计模式，在解决复杂的对象依赖关系方面是一个非常行之有效的手段。</p> \n   <p>对于有反射功能的语言来说，实现依赖注入都比较方便一些。在 Golang 中有几个比较知名的依赖注入开源库，例如 <a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/google/wire\">google/wire</a>、<a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/uber-go/dig\">uber-go/dig</a> 以及 <a href=\"https://toutiao.io/k/github.com/facebookgo/inject\">facebookgo/inject</a> 等。</p> \n   <p>本文将基于 <code>facebookgo/inject</code> 介绍依赖注入, 接下来将会着重讨论以下几点内容：</p> \n   <ol> \n    <li>依赖注入的背景以及解决的问题</li> \n    <li>facebookgo/inject 的使用方法</li> \n    <li>facebookgo/inject 的缺陷</li> \n   </ol> \n   <a id=\"more\"></a> \n   <h1 id=\"依赖注入的背景\"><a href=\"https://toutiao.io/k/aiwwan4#依赖注入的背景\" class=\"headerlink\" title=\"依赖注入的背景\"></a>依赖注入的背景</h1> \n   <p>对于稍微复杂些的项目，我们往往就会遇到对象之间复杂的依赖关系。手动管理和初始化这些管理关系将会极其繁琐，依赖注入可以帮我们自动实现依赖的管理和对象属性的赋值，将我们从这些繁琐的依赖管理中解放出来。</p> \n   <p>以一个常见的 HTTP 服务为例，我们在开发后台时往往会把代码分为 Controller、Service 等层次。如下：</p> \n   <figure class=\"highlight go\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /><span class=\"line\">5</span><br /><span class=\"line\">6</span><br /><span class=\"line\">7</span><br /><span class=\"line\">8</span><br /><span class=\"line\">9</span><br /><span class=\"line\">10</span><br /><span class=\"line\">11</span><br /><span class=\"line\">12</span><br /><span class=\"line\">13</span><br /><span class=\"line\">14</span><br /><span class=\"line\">15</span><br /><span class=\"line\">16</span><br /><span class=\"line\">17</span><br /><span class=\"line\">18</span><br /><span class=\"line\">19</span><br /><span class=\"line\">20</span><br /><span class=\"line\">21</span><br /><span class=\"line\">22</span><br /><span class=\"line\">23</span><br /><span class=\"line\">24</span><br /></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> UserController <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    UserService *UserService</span><br /><span class=\"line\">    Conf        *Conf</span><br /><span class=\"line\">}</span><br /><span class=\"line\"></span><br /><span class=\"line\"><span class=\"keyword\">type</span> PostController <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    UserService *UserService</span><br /><span class=\"line\">    PostService *PostService</span><br /><span class=\"line\">    Conf        *Conf</span><br /><span class=\"line\">}</span><br /><span class=\"line\"></span><br /><span class=\"line\"><span class=\"keyword\">type</span> UserService <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    Db   *DB</span><br /><span class=\"line\">    Conf *Conf</span><br /><span class=\"line\">}</span><br /><span class=\"line\"></span><br /><span class=\"line\"><span class=\"keyword\">type</span> PostService <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    Db *DB</span><br /><span class=\"line\">}</span><br /><span class=\"line\"></span><br /><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    UserApi *UserController</span><br /><span class=\"line\">    PostApi *PostController</span><br /><span class=\"line\">}</span><br /></pre></td> \n     </tr> \n    </table> \n   </figure> \n   <p>上述的代码例子中，有两个 Controller：UserController 和 PostController，分别用来接收用户和文章的相关请求逻辑。除此之外还会有 Service 相关类、Conf 配置文件、DB 连接等。</p> \n   <p>这些对象之间存在比较复杂的依赖关系，这就给项目的初始化带来了一些困扰。对于以上代码，对应初始化逻辑大概就会是这样:</p> \n   <figure class=\"highlight go\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /><span class=\"line\">5</span><br /><span class=\"line\">6</span><br /><span class=\"line\">7</span><br /><span class=\"line\">8</span><br /><span class=\"line\">9</span><br /><span class=\"line\">10</span><br /><span class=\"line\">11</span><br /><span class=\"line\">12</span><br /><span class=\"line\">13</span><br /><span class=\"line\">14</span><br /><span class=\"line\">15</span><br /><span class=\"line\">16</span><br /><span class=\"line\">17</span><br /><span class=\"line\">18</span><br /><span class=\"line\">19</span><br /><span class=\"line\">20</span><br /><span class=\"line\">21</span><br /><span class=\"line\">22</span><br /><span class=\"line\">23</span><br /><span class=\"line\">24</span><br /><span class=\"line\">25</span><br /><span class=\"line\">26</span><br /><span class=\"line\">27</span><br /><span class=\"line\">28</span><br /><span class=\"line\">29</span><br /><span class=\"line\">30</span><br /><span class=\"line\">31</span><br /></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> {</span><br /><span class=\"line\">    conf := loadConf()</span><br /><span class=\"line\">    db := connectDB()</span><br /><span class=\"line\"></span><br /><span class=\"line\">    userService := &amp;UserService{</span><br /><span class=\"line\">        Db:   db,</span><br /><span class=\"line\">        Conf: conf,</span><br /><span class=\"line\">    }</span><br /><span class=\"line\"></span><br /><span class=\"line\">    postService := &amp;PostService{</span><br /><span class=\"line\">        Db: db,</span><br /><span class=\"line\">    }</span><br /><span class=\"line\"></span><br /><span class=\"line\">    userHandler := &amp;UserController{</span><br /><span class=\"line\">        UserService: userService,</span><br /><span class=\"line\">        Conf:        conf,</span><br /><span class=\"line\">    }</span><br /><span class=\"line\"></span><br /><span class=\"line\">    postHandler := &amp;PostController{</span><br /><span class=\"line\">        UserService: userService,</span><br /><span class=\"line\">        PostService: postService,</span><br /><span class=\"line\">        Conf:        conf,</span><br /><span class=\"line\">    }</span><br /><span class=\"line\"></span><br /><span class=\"line\">    server := &amp;Server{</span><br /><span class=\"line\">        UserApi: userHandler,</span><br /><span class=\"line\">        PostApi: postHandler,</span><br /><span class=\"line\">    }</span><br /><span class=\"line\"></span><br /><span class=\"line\">    server.Run()</span><br /><span class=\"line\">}</span><br /></pre></td> \n     </tr> \n    </table> \n   </figure> \n   <p>我们会有一大段的逻辑都是用来做对象初始化，而当接口越来越多的时候，整个初始化过程就会异常的冗长和复杂。</p> \n   <p>针对以上问题，依赖注入可以完美的解决。</p> \n   <h1 id=\"facebookgo-inject-的使用\"><a href=\"https://toutiao.io/k/aiwwan4#facebookgo-inject-的使用\" class=\"headerlink\" title=\"facebookgo/inject 的使用\"></a>facebookgo/inject 的使用</h1> \n   <p>接下来，我们试着使用 facebookgo/inject 的方式，对这段代码进行依赖注入的改造。如下：</p> \n   <figure class=\"highlight go\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /><span class=\"line\">5</span><br /><span class=\"line\">6</span><br /><span class=\"line\">7</span><br /><span class=\"line\">8</span><br /><span class=\"line\">9</span><br /><span class=\"line\">10</span><br /><span class=\"line\">11</span><br /><span class=\"line\">12</span><br /><span class=\"line\">13</span><br /><span class=\"line\">14</span><br /><span class=\"line\">15</span><br /><span class=\"line\">16</span><br /><span class=\"line\">17</span><br /><span class=\"line\">18</span><br /><span class=\"line\">19</span><br /><span class=\"line\">20</span><br /><span class=\"line\">21</span><br /><span class=\"line\">22</span><br /><span class=\"line\">23</span><br /><span class=\"line\">24</span><br /><span class=\"line\">25</span><br /><span class=\"line\">26</span><br /><span class=\"line\">27</span><br /><span class=\"line\">28</span><br /><span class=\"line\">29</span><br /><span class=\"line\">30</span><br /><span class=\"line\">31</span><br /><span class=\"line\">32</span><br /><span class=\"line\">33</span><br /><span class=\"line\">34</span><br /><span class=\"line\">35</span><br /><span class=\"line\">36</span><br /><span class=\"line\">37</span><br /><span class=\"line\">38</span><br /><span class=\"line\">39</span><br /><span class=\"line\">40</span><br /><span class=\"line\">41</span><br /><span class=\"line\">42</span><br /><span class=\"line\">43</span><br /><span class=\"line\">44</span><br /><span class=\"line\">45</span><br /><span class=\"line\">46</span><br /><span class=\"line\">47</span><br /><span class=\"line\">48</span><br /><span class=\"line\">49</span><br /><span class=\"line\">50</span><br /><span class=\"line\">51</span><br /><span class=\"line\">52</span><br /><span class=\"line\">53</span><br /></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> UserController <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    UserService *UserService <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">    Conf        *Conf        <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">}</span><br /><span class=\"line\"></span><br /><span class=\"line\"><span class=\"keyword\">type</span> PostController <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    UserService *UserService <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">    PostService *PostService <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">    Conf        *Conf        <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">}</span><br /><span class=\"line\"></span><br /><span class=\"line\"><span class=\"keyword\">type</span> UserService <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    Db   *DB   <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">    Conf *Conf <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">}</span><br /><span class=\"line\"></span><br /><span class=\"line\"><span class=\"keyword\">type</span> PostService <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    Db *DB <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">}</span><br /><span class=\"line\"></span><br /><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    UserApi *UserController <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">    PostApi *PostController <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">}</span><br /><span class=\"line\"></span><br /><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> {</span><br /><span class=\"line\">    conf := loadConf() <span class=\"comment\">// *Conf</span></span><br /><span class=\"line\">    db := connectDB() <span class=\"comment\">// *DB</span></span><br /><span class=\"line\"></span><br /><span class=\"line\">    server := Server{}</span><br /><span class=\"line\"></span><br /><span class=\"line\">    graph := inject.Graph{}</span><br /><span class=\"line\"></span><br /><span class=\"line\">    <span class=\"keyword\">if</span> err := graph.Provide(</span><br /><span class=\"line\">        &amp;inject.Object{</span><br /><span class=\"line\">            Value: &amp;server,</span><br /><span class=\"line\">        },</span><br /><span class=\"line\">        &amp;inject.Object{</span><br /><span class=\"line\">            Value: conf,</span><br /><span class=\"line\">        },</span><br /><span class=\"line\">        &amp;inject.Object{</span><br /><span class=\"line\">            Value: db,</span><br /><span class=\"line\">        },</span><br /><span class=\"line\">    ); err != <span class=\"literal\">nil</span> {</span><br /><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br /><span class=\"line\">    }</span><br /><span class=\"line\"></span><br /><span class=\"line\">    <span class=\"keyword\">if</span> err := graph.Populate(); err != <span class=\"literal\">nil</span> {</span><br /><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br /><span class=\"line\">    }</span><br /><span class=\"line\"></span><br /><span class=\"line\">    server.Run()</span><br /><span class=\"line\">}</span><br /></pre></td> \n     </tr> \n    </table> \n   </figure> \n   <ol> \n    <li><p>首先每一个需要注入的字段都需要打上 <code>inject:\"\"</code> 这样的 tag。所谓依赖注入，这里的依赖指的就是对象中包含的字段，而注入则是指有其它程序会帮你对这些字段进行赋值。</p> </li> \n    <li><p>其次，我们使用 <code>inject.Graph{}</code> 创建一个 graph 对象。这个 graph 对象将负责管理和注入所有的对象。至于为什么叫 Graph，其实这个名词起的非常形象，因为各个对象之间的依赖关系，也确实像是一张图一样。</p> </li> \n    <li><p>接下来，我们使用 <code>graph.Provide()</code> 将需要注入的对象提供给 <code>graph</code>。</p> \n     <figure class=\"highlight go\"> \n      <table> \n       <tr> \n        <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /><span class=\"line\">5</span><br /><span class=\"line\">6</span><br /><span class=\"line\">7</span><br /><span class=\"line\">8</span><br /><span class=\"line\">9</span><br /><span class=\"line\">10</span><br /><span class=\"line\">11</span><br /></pre></td> \n        <td class=\"code\"><pre><span class=\"line\">graph.Provide(</span><br /><span class=\"line\">    &amp;inject.Object{</span><br /><span class=\"line\">        Value: &amp;server,</span><br /><span class=\"line\">    },</span><br /><span class=\"line\">    &amp;inject.Object{</span><br /><span class=\"line\">        Value: &amp;conf,</span><br /><span class=\"line\">    },</span><br /><span class=\"line\">    &amp;inject.Object{</span><br /><span class=\"line\">        Value: &amp;db,</span><br /><span class=\"line\">    },</span><br /><span class=\"line\">);</span><br /></pre></td> \n       </tr> \n      </table> \n     </figure> </li> \n    <li><p>最后调用 <code>Populate</code> 函数，开始进行注入。</p> </li> \n   </ol> \n   <p>从代码中可以看到，我们一共就向 Graph 中 Provide 了三个对象。我们提供了 <code>server</code> 对象，是因为它是一个顶层对象。提供了 <code>conf</code> 和 <code>db</code>对象，是因为所有的对象都依赖于它们，可以说它们是基础对象了。</p> \n   <p>但是其他的对象呢？ 例如 <code>UserApi</code> 和 <code>UserService</code> 呢？我们并没有向 <code>graph</code> 调用 Provide 过。那么它们是怎么完成赋值和注入的呢？</p> \n   <p>其实从下面这张对象依赖图能够很简单的看清楚。</p> \n   <p><img src=\"https://toutiao.io/img/inject/graph.png\" alt=\"对象依赖图\" /></p> \n   <p>从这个依赖图中可以看出，<code>conf</code> 和 <code>db</code> 对象是属于根节点，所有的对象都依赖和包含着它们。而 <code>server</code> 属于叶子节点，不会有其他对象依赖它了。</p> \n   <p>我们需要提供给 Graph 的就是根节点和叶子节点，对于中间节点来说，Graph 会通过 <code>inject:\"\"</code> 标签，自动将其 Provide 到 Graph 中，并进行注入。</p> \n   <p>对以上例子，我们深入剖析下 Graph 内部进行 Populate 时都发生了哪些动作:</p> \n   <ol> \n    <li>Graph 首先解析 server 对象，发现其有两个标记为 inject 的字段：<code>UserApi</code> 和 <code>PostApi</code>。其类型 <code>UserController</code> 和 <code>PostController</code>, Graph 中从未出现过这两个类型。因此，Graph 会自动对该字段调用 Provide，提供给 Graph。</li> \n    <li>解析 UserApi 时，发现其依然有也有两个标记为 inject 的字段：<code>UserService</code> 和 <code>Conf</code>。对于 <code>UserService</code> 这种 Graph 中未登记过的类型，会自动 Provide。而对 <code>Conf</code>, Graph 中之前已经注册过了，因此直接将注册的对象赋值给该字段即可。</li> \n    <li>接下来就是继续逐步解析，直至没有tag为 inject 的字段。</li> \n   </ol> \n   <p>以上就是整个依赖注入的流程了。</p> \n   <p>这里需要注意的是，在我们上面的示例中，以这种方式注入，其中所有的对象都相当于单例对象。即一个类型，只会在 Graph 中存在一个实例对象。比如 <code>UserController</code> 和 <code>PosterController</code> 中的 <code>UserService</code> 实际上是同一个对象。</p> \n   <p>我们的 main 函数使用 inject 进行改造后，将会变得非常简洁。而且即使随着业务越来越复杂，Handler 和 Service 越来越多，这个 main 函数中的注入逻辑也不会任何改变，除非有新的根节点对象出现。</p> \n   <p>当然，对于 Graph 来说，也不是只能 Provide 根节点和叶子节点，我们也可以自行 Provide 一个 UserService 的实例进去，对于 Graph 的运作是没有任何影响的。只不过只 Provide 根节点和叶子节点，代码会更简洁一些。</p> \n   <h1 id=\"inject-的高级用法\"><a href=\"https://toutiao.io/k/aiwwan4#inject-的高级用法\" class=\"headerlink\" title=\"inject 的高级用法\"></a>inject 的高级用法</h1> \n   <p>我们在声明 tag 时，除了声明为 <code>inject:\"\"</code> 这种默认用法外，还可以有其他三种高级的用法:</p> \n   <ol> \n    <li><code>inject:\"private\"</code>。私有注入。</li> \n    <li><code>inject:\"inline\"</code>。内联注入。</li> \n    <li><code>inject:\"object_name\"</code>。命名注入，这里的 object_name 可以取成任意的名字。</li> \n   </ol> \n   <h2 id=\"private-私有注入\"><a href=\"https://toutiao.io/k/aiwwan4#private-私有注入\" class=\"headerlink\" title=\"private (私有注入)\"></a>private (私有注入)</h2> \n   <p>我们上文讲过，默认情况下，所有的对象都是单例对象。一个类型只会有一个实例对象存在。但也可以不使用单例对象，private 就是提供了这种可能。</p> \n   <p>例如:</p> \n   <figure class=\"highlight go\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> UserController <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    UserService *UserService <span class=\"string\">`inject:\"private\"`</span></span><br /><span class=\"line\">    Conf        *Conf        <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">}</span><br /></pre></td> \n     </tr> \n    </table> \n   </figure> \n   <p>我们将 UserController 中的 UserService 属性声明为 private 注入。这样的话，graph 遇到 private 标签时，会自动的 new 一个全新的 <code>UserService</code> 对象，将其赋值给该字段。</p> \n   <p>这样 Graph 中就同时存在了两个 UserService 的实例，一个是 UserService 的全局实例，给默认的 <code>inject:\"\"</code> 使用。一个是专门给 UserController 实例中的 UserService 使用。</p> \n   <p>但在实际开发中，这种 private 的场景似乎也比较少，大部分情况下，默认的单例对象就足够了。</p> \n   <h2 id=\"inline-内联注入\"><a href=\"https://toutiao.io/k/aiwwan4#inline-内联注入\" class=\"headerlink\" title=\"inline (内联注入)\"></a>inline (内联注入)</h2> \n   <p>默认情况下，需要注入的属性必须得是 <code>*Struct</code>。但是也是可以声明为普通对象的。例如：</p> \n   <figure class=\"highlight go\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> UserController <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    UserService UserService <span class=\"string\">`inject:\"inline\"`</span></span><br /><span class=\"line\">    Conf        *Conf       <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">}</span><br /></pre></td> \n     </tr> \n    </table> \n   </figure> \n   <p>注意，这里的 UserService 的类型，并非是 <code>*UserService</code> 指针类型了，而是普通的 struct 类型。struct 类型在 Go 里面都是值语义，这里当然也就不存在单例的问题了。</p> \n   <h2 id=\"命名注入\"><a href=\"https://toutiao.io/k/aiwwan4#命名注入\" class=\"headerlink\" title=\"命名注入\"></a>命名注入</h2> \n   <p>如果我们需要对某些字段注入专有的对象实例，那么我们可能会用到命名注入。使用方法就是在 <code>inject</code> 的 tag 里写上专有的名字。如下：</p> \n   <figure class=\"highlight go\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> UserController <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    UserService UserService <span class=\"string\">`inject:\"named_service\"`</span></span><br /><span class=\"line\">    Conf        *Conf       <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">}</span><br /></pre></td> \n     </tr> \n    </table> \n   </figure> \n   <p>当然，这个命名肯定不能命名为 <code>private</code> 和 <code>inline</code>，这两个属于保留词。</p> \n   <p>同时，我们一定要把这个命名实例 Provide 到 graph 里面，这样 graph 才能把两个对象联系起来。</p> \n   <figure class=\"highlight go\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /><span class=\"line\">5</span><br /><span class=\"line\">6</span><br /></pre></td> \n      <td class=\"code\"><pre><span class=\"line\">graph.Provide(</span><br /><span class=\"line\">    &amp;inject.Object{</span><br /><span class=\"line\">        Value: &amp;namedService,</span><br /><span class=\"line\">        Name: <span class=\"string\">\"named_service\"</span>,</span><br /><span class=\"line\">    },</span><br /><span class=\"line\">);</span><br /></pre></td> \n     </tr> \n    </table> \n   </figure> \n   <h2 id=\"注入-map\"><a href=\"https://toutiao.io/k/aiwwan4#注入-map\" class=\"headerlink\" title=\"注入 map\"></a>注入 map</h2> \n   <p>我们除了可以注入对象外，还可以注入 map。如下：</p> \n   <figure class=\"highlight go\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /><span class=\"line\">5</span><br /></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> UserController <span class=\"keyword\">struct</span> {</span><br /><span class=\"line\">    UserService UserService       <span class=\"string\">`inject:\"inline\"`</span></span><br /><span class=\"line\">    Conf        *Conf             <span class=\"string\">`inject:\"\"`</span></span><br /><span class=\"line\">    UserMap     <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span> <span class=\"string\">`inject:\"private\"`</span></span><br /><span class=\"line\">}</span><br /></pre></td> \n     </tr> \n    </table> \n   </figure> \n   <p>需要注意的是，map 的注入 tag 一定要是 <code>inject:\"private\"</code>。</p> \n   <h1 id=\"facebookgo-inject-的缺陷\"><a href=\"https://toutiao.io/k/aiwwan4#facebookgo-inject-的缺陷\" class=\"headerlink\" title=\"facebookgo/inject 的缺陷\"></a>facebookgo/inject 的缺陷</h1> \n   <p>facebookgo/inject 固然很好用，只要声明 <code>inject:\"\"</code> 的 tag，提供几个对象，就可以完全自动的注入所有依赖关系。</p> \n   <p>但是由于Golang本身的语言设计， facebookgo/inject 也会有一些缺陷和短板：</p> \n   <ol> \n    <li><p><strong>所有需要注入的字段都需要是 public 的。</strong> 这也是 Golang 的限制，不能对私有属性进行赋值。所以只能对public的字段进行注入。但这样就会把代码稍显的不那么优雅，毕竟很多变量我们其实并不想 public。</p> </li> \n    <li><p><strong>只能进行属性赋值，不能执行初始化函数。</strong> facebookgo/inject只会帮你注入好对象，把各个属性赋值好。但很多时候，我们往往需要在对象赋值完成后，再进行其他一些动作。但对于这个需求场景，facebookgo/inject并不能很好的支持。</p> </li> \n   </ol> \n   <p>这两个问题的原因总结归纳为：Golang没有构造函数……</p> \n  </div> \n </div> \n</div>","descriptionType":"html","feedId":540,"bgimg":"https://toutiao.io/img/inject/graph.png","linkMd5":"b865b9f8595e91321d244fa09b7b7368","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","author":"","articleImgCdnMap":{"https://toutiao.io/img/inject/graph.png":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg"}}],"record":{"createdTime":"2020-08-17 19:02:45","updatedTime":"2020-08-17 19:02:45","feedId":540,"fetchDate":"Mon, 17 Aug 2020 11:02:45 +0000","fetchMs":669,"handleMs":11846,"totalMs":34079,"newArticles":0,"totalArticles":5,"status":1,"type":0,"ip":"52.205.152.96","hostName":"fierce-hollows-56203.herokuapp.com","requestId":"b66c9aca98ed4f85b50d7c1b87df6421_540","bgimgsTotal":5,"bgimgsGithubTotal":5,"articlesImgsTotal":2,"articlesImgsGithubTotal":1},"feed":{"createdTime":"2020-08-16 17:44:27","updatedTime":"2020-08-16 17:44:27","id":540,"name":"开发者头条","url":"http://feedmaker.kindle4rss.com/feeds/toutiao.io.xml","subscriber":null,"website":null,"icon":"http://toutiao.io/apple-icon-57x57.png","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn30@2020_3/2020/08/17/11-02-38-704_072eae503565bd23.png","description":"","weekly":null,"link":"http://toutiao.io"},"extra4":{"start":1597662152624,"total":0,"statList":[{"spend":769,"msg":"获取xml内容"},{"spend":11846,"msg":"解释文章"},{"spend":1,"msg":"正文链接上传到cdn"},{"spend":3205,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"}]},"extra5":2,"extra6":2,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://toutiao.io/taowen/modularization-examples/raw/master/shape.drawio.svg","sourceStatusCode":404,"sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":2052,"convertSpendMs":0,"createdTime":"2020-08-17 19:02:58","host":"dry-shelf-60780.herokuapp.com","referer":"https://toutiao.io/k/x35vow3","linkMd5ListStr":"aaa1643fd589bbb7ae0c2785677d04f2,aaa1643fd589bbb7ae0c2785677d04f2","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/inject/graph.png","sourceStatusCode":404,"sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":3589,"convertSpendMs":0,"createdTime":"2020-08-17 19:02:58","host":"fierce-sierra-10390.herokuapp.com","referer":"https://toutiao.io/k/aiwwan4","linkMd5ListStr":"b865b9f8595e91321d244fa09b7b7368,b865b9f8595e91321d244fa09b7b7368","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/taowen/modularization-examples/raw/master/shape.drawio.svg","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":2925,"convertSpendMs":0,"createdTime":"2020-08-17 19:03:00","host":"infinite-dawn-93941.herokuapp.com","referer":"https://toutiao.io/k/x35vow3","linkMd5ListStr":"aaa1643fd589bbb7ae0c2785677d04f2,aaa1643fd589bbb7ae0c2785677d04f2","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/inject/graph.png","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":1723,"convertSpendMs":0,"createdTime":"2020-08-17 19:03:01","host":"murmuring-coast-63051.herokuapp.com","referer":"https://toutiao.io/k/aiwwan4","linkMd5ListStr":"b865b9f8595e91321d244fa09b7b7368,b865b9f8595e91321d244fa09b7b7368","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"}],"extra10_invalidATagHrefValue":{"https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/criteria-of-modularization/avoid-crazy-busy-top-module":"https://toutiao.io/taowen/modularization-examples/blob/master/criteria-of-modularization/avoid-crazy-busy-top-module","https://toutiao.io/k/x35vow3_#要更关注易变性而不是功能切分":"https://toutiao.io/k/x35vow3#要更关注易变性而不是功能切分","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/loosely-coupled-interface/no-return-value":"https://toutiao.io/taowen/modularization-examples/blob/master/loosely-coupled-interface/no-return-value","https://toutiao.io/k/x35vow3_#阿里中台到底是什么":"https://toutiao.io/k/x35vow3#阿里中台到底是什么","https://toutiao.io/k/x35vow3_#如何复用一套代码满足多个产品经理":"https://toutiao.io/k/x35vow3#如何复用一套代码满足多个产品经理","https://toutiao.io/k/x35vow3_#代码写成活的比写成死的要麻烦多了怎么办":"https://toutiao.io/k/x35vow3#代码写成活的比写成死的要麻烦多了怎么办","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/loosely-coupled-interface/ui-composition":"https://toutiao.io/taowen/modularization-examples/blob/master/loosely-coupled-interface/ui-composition","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/shape.drawio.svg":"https://toutiao.io/taowen/modularization-examples/blob/master/shape.drawio.svg","https://toutiao.io/k/x35vow3_#事件驱动为何难以有收益":"https://toutiao.io/k/x35vow3#事件驱动为何难以有收益","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/criteria-of-modularization/extending-by-adding-new-module":"https://toutiao.io/taowen/modularization-examples/blob/master/criteria-of-modularization/extending-by-adding-new-module","https://toutiao.io/k/x35vow3_#打包和部署方式的调整":"https://toutiao.io/k/x35vow3#打包和部署方式的调整","https://toutiao.io/k/x35vow3_#公共模块应该稳定":"https://toutiao.io/k/x35vow3#公共模块应该稳定","https://toutiao.io/k/aiwwan4_#inline-内联注入":"https://toutiao.io/k/aiwwan4#inline-内联注入","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/patterns/how-to-add-new-order-type":"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/how-to-add-new-order-type","https://toutiao.io/k/x35vow3_#怎么支持新的订单类型":"https://toutiao.io/k/x35vow3#怎么支持新的订单类型","https://toutiao.io/k/aiwwan4_#private-私有注入":"https://toutiao.io/k/aiwwan4#private-私有注入","https://toutiao.io/k/x35vow3_#分模块之后代码不好读了怎么办":"https://toutiao.io/k/x35vow3#分模块之后代码不好读了怎么办","https://toutiao.io/k/x35vow3_#避免超级繁忙的顶层模块":"https://toutiao.io/k/x35vow3#避免超级繁忙的顶层模块","https://toutiao.io/k/aiwwan4_github.com/facebookgo/inject":"https://toutiao.io/k/github.com/facebookgo/inject","https://toutiao.io/k/aiwwan4_#inject-的高级用法":"https://toutiao.io/k/aiwwan4#inject-的高级用法","https://toutiao.io/k/x35vow3_#不要返回值":"https://toutiao.io/k/x35vow3#不要返回值","https://toutiao.io/k/aiwwan4_#注入-map":"https://toutiao.io/k/aiwwan4#注入-map","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/criteria-of-modularization/common-module-should-be-stable":"https://toutiao.io/taowen/modularization-examples/blob/master/criteria-of-modularization/common-module-should-be-stable","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/patterns/how-to-lower-plugin-tax-rate":"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/how-to-lower-plugin-tax-rate","https://toutiao.io/k/x35vow3_#为什么实际的业务代码都没有写成你说的那个样子":"https://toutiao.io/k/x35vow3#为什么实际的业务代码都没有写成你说的那个样子","https://toutiao.io/k/x35vow3_#通过新增模块来扩展功能":"https://toutiao.io/k/x35vow3#通过新增模块来扩展功能","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/loosely-coupled-interface/virtual-file-system":"https://toutiao.io/taowen/modularization-examples/blob/master/loosely-coupled-interface/virtual-file-system","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/module-boundary-unchanged/replace-class-with-interface":"https://toutiao.io/taowen/modularization-examples/blob/master/module-boundary-unchanged/replace-class-with-interface","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/module-boundary-unchanged/alibaba-middle-office-technology":"https://toutiao.io/taowen/modularization-examples/blob/master/module-boundary-unchanged/alibaba-middle-office-technology","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/module-boundary-unchanged/packaging-deployment":"https://toutiao.io/taowen/modularization-examples/blob/master/module-boundary-unchanged/packaging-deployment","https://toutiao.io/k/x35vow3_#模块切分的好坏标准":"https://toutiao.io/k/x35vow3#模块切分的好坏标准","https://toutiao.io/k/x35vow3_#不调整模块边界是没有效果的":"https://toutiao.io/k/x35vow3#不调整模块边界是没有效果的","https://toutiao.io/k/aiwwan4_#命名注入":"https://toutiao.io/k/aiwwan4#命名注入","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/patterns/how-to-add-field":"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/how-to-add-field","https://toutiao.io/k/x35vow3_#ui组合为何难以落地":"https://toutiao.io/k/x35vow3#ui组合为何难以落地","https://toutiao.io/k/x35vow3_#虚拟文件系统":"https://toutiao.io/k/x35vow3#虚拟文件系统","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/patterns/event-driven-obstacles":"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/event-driven-obstacles","https://toutiao.io/k/x35vow3_#基于-ui-的组合":"https://toutiao.io/k/x35vow3#基于-ui-的组合","https://toutiao.io/k/aiwwan4_#依赖注入的背景":"https://toutiao.io/k/aiwwan4#依赖注入的背景","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/patterns/how-to-maintain-readability":"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/how-to-maintain-readability","https://toutiao.io/k/aiwwan4_#facebookgo-inject-的缺陷":"https://toutiao.io/k/aiwwan4#facebookgo-inject-的缺陷","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/patterns/ui-composition-obstacles":"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/ui-composition-obstacles","https://toutiao.io/k/x35vow3_#松耦合的接口应该定义成什么样子":"https://toutiao.io/k/x35vow3#松耦合的接口应该定义成什么样子","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/criteria-of-modularization/more-focus-on-violatility-than-functionality":"https://toutiao.io/taowen/modularization-examples/blob/master/criteria-of-modularization/more-focus-on-violatility-than-functionality","https://toutiao.io/k/x35vow3_#用-interface-代替-class":"https://toutiao.io/k/x35vow3#用-interface-代替-class","https://toutiao.io/k/x35vow3_#怎么扩展额外的字段呢":"https://toutiao.io/k/x35vow3#怎么扩展额外的字段呢","https://toutiao.io/k/x35vow3_#这些经典的解决方案用了也就那样-":"https://toutiao.io/k/x35vow3#这些经典的解决方案用了也就那样-","https://toutiao.io/k/x35vow3_/taowen/modularization-examples/blob/master/patterns/how-to-invent-abstraction":"https://toutiao.io/taowen/modularization-examples/blob/master/patterns/how-to-invent-abstraction","https://toutiao.io/k/x35vow3_#如何发明底层抽象":"https://toutiao.io/k/x35vow3#如何发明底层抽象","https://toutiao.io/k/x35vow3_#模块切分的好坏标准是什么-":"https://toutiao.io/k/x35vow3#模块切分的好坏标准是什么-","https://toutiao.io/k/aiwwan4_#facebookgo-inject-的使用":"https://toutiao.io/k/aiwwan4#facebookgo-inject-的使用"},"extra111_proxyServerAndStatMap":{},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://toutiao.io/taowen/modularization-examples/raw/master/shape.drawio.svg","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":2925,"convertSpendMs":0,"createdTime":"2020-08-17 19:03:00","host":"infinite-dawn-93941.herokuapp.com","referer":"https://toutiao.io/k/x35vow3","linkMd5ListStr":"aaa1643fd589bbb7ae0c2785677d04f2,aaa1643fd589bbb7ae0c2785677d04f2","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/inject/graph.png","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":1723,"convertSpendMs":0,"createdTime":"2020-08-17 19:03:01","host":"murmuring-coast-63051.herokuapp.com","referer":"https://toutiao.io/k/aiwwan4","linkMd5ListStr":"b865b9f8595e91321d244fa09b7b7368,b865b9f8595e91321d244fa09b7b7368","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"http://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWN9GqIiajQpY85BZIml3jRaN4UPiayYNVAgt5AV2y45u7GGDgISefBEaFAz9pYkfHPW61FgrMEqDqoQ/0?wx_fmt=jpeg","sourceStatusCode":200,"destWidth":400,"destHeight":170,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn9@2020_3/2020/08/17/11-03-03-801_e0aebbb1df1f781e.webp","sourceBytes":8852,"destBytes":6852,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1148,"convertSpendMs":22,"createdTime":"2020-08-17 19:03:03","host":"secure-citadel-84932.herokuapp.com","referer":"https://toutiao.io/k/531jcms","linkMd5ListStr":"dfdf3c5d29e93cee21002656d895c0f9","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"8.6 KB","destSize":"6.7 KB","compressRate":"77.4%"},{"code":1,"isDone":false,"source":"http://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauQTX4s0hVUVMDXiazR2JZvPVqW0QzKWbZXuWmEAz2M20SEFD81HiagsVgkFSxDHHS4PCeHaPDaicT2w/0?wx_fmt=jpeg","sourceStatusCode":200,"destWidth":1280,"destHeight":546,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn6@2020_6/2020/08/17/11-03-04-610_1b3ddf3d9d88516e.webp","sourceBytes":18514,"destBytes":13032,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1848,"convertSpendMs":19,"createdTime":"2020-08-17 19:03:03","host":"mysterious-ridge-34067.herokuapp.com","referer":"https://toutiao.io/k/e6zbho6","linkMd5ListStr":"0d76e13ac94360798d027b830ef86216","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.1 KB","destSize":"12.7 KB","compressRate":"70.4%"},{"code":1,"isDone":false,"source":"http://mmbiz.qpic.cn/mmbiz_jpg/9ZHzCnhO6Yf5zxviaJnvTqYZTNRMes6Lia1NdbbYGRTwvibibdmeH2L7gPfFhMQUkX8uSThqacficPiaYKrY82ZZeUXg/0?wx_fmt=jpeg","sourceStatusCode":200,"destWidth":1280,"destHeight":542,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn8@2020_5/2020/08/17/11-03-05-833_caa3d7e98235fafb.webp","sourceBytes":26099,"destBytes":14786,"targetWebpQuality":75,"feedId":540,"totalSpendMs":3189,"convertSpendMs":29,"createdTime":"2020-08-17 19:03:03","host":"safe-meadow-87857.herokuapp.com","referer":"https://toutiao.io/k/kumhh9k","linkMd5ListStr":"eddd0fa1ac57c28dbc6263ed79cfc7ba","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.5 KB","destSize":"14.4 KB","compressRate":"56.7%"}]}