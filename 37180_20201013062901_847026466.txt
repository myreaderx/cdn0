{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-13 14:29:01","updatedTime":"2020-10-13 14:29:01","title":"ROCA vs. ROBOT: An Eternal Golden Braid","link":"http://latacora.micro.blog/2018/08/08/roca-vs-robot.html","description":"\n\n<p>The ROCA RSA key generation flaw or ROBOT, the “Return Of Bleichenbacher” attack: which is most deserving of the “Best Cryptographic Attack” Pwnie award at the 2018 Black Hat USA conference? Only one can survive. Let us consider.</p>\n\n<p>Assume for the moment that it’s down to those two: ROBOT and ROCA. But first take a moment to consider the best cases for the “runners up”. They are all excellent; it was a very good year for crypto research.</p>\n\n<h2 id=\"efail\">Efail</h2>\n\n<p>The Efail attack broke PGP email. Also: S/MIME. All encrypted email! That is, by itself, a headlining cryptographic vulnerability. The case for Efail as Pwnie winner:</p>\n\n<ul>\n<li><p>The Efail Pwnie might do the most good for the community of all the Pwnie winners. The encrypted email ecosystem is broken, and has been known to be broken for over a decade. The Efail researchers took vulnerabilities we knew about and weaponized them to break actual email clients. In this sense, Efail looks a lot like BEAST, which weaponized work Bard had done years earlier that nobody had paid attention to. The TLS ecosystem needed a kick in the ass to move away from SSL 3.0, and so too does the messaging community with PGP.</p></li>\n\n<li><p>Efail is an elegant attack. It’s all exploit work! It’s based on the individuated quirks of a whole ecosystem of clients. It’s the cryptographic equivalent of the work clientside RCE people do memorizing all the offsets in Windows 7’s OLE DLLs.</p></li>\n</ul>\n\n<p>So why won&rsquo;t Efail win? Because cryptographers didn’t take PGP email seriously to begin with.</p>\n\n<p>Among serious cryptography researchers, Efail was met with a shrug, not because the attack wasn’t important or powerful, but because cryptographers had written off the PGP and S/MIME ecosystems long before — and for all the reasons pointed out in the Efail paper.</p>\n\n<p>Assume, arguendo, that Efail is out of the running.</p>\n\n<h2 id=\"iota\">IOTA</h2>\n\n<p>IOTA de-pantsed a custom cryptosystem built for a crypto-as-in-currency. The case for IOTA:</p>\n\n<ul>\n<li><p>It’s hi-larious. It is serious komedy gold. What are the Pwnies if not a key meant to unlock the safe in which our field keeps its joy?</p></li>\n\n<li><p>It involves a relatively serious cryptographic undertaking, a real understanding of attacks on cryptographic primitives. We don’t get to break crypto primitives all that often! Even the worst cryptosystems in the world tend to use SHA-2 and AES. Not IOTA! They built their own hash function, optimized (somehow, I assume, from the marketing material) for computation in ternary. You’re a crypto pentester, you kind of dream of finding a project dumb enough to make up a new hash function.</p></li>\n\n<li><p>“Optimized for ternary”. See point one.</p></li>\n\n<li><p>The IOTA community and its response to the work. See point one. If IOTA wins, there will be jubilation.</p></li>\n</ul>\n\n<p>Why not IOTA? Are the Pwnies a serious thing or not? In a very boring year for cryptographic attacks you could make the case for “both”, but not this year. Take IOTA out of the running.</p>\n\n<h2 id=\"krack\">KRACK</h2>\n\n<p>KRACK breaks WPA2. Everyone uses WPA2. Obviously, KRACK should be a finalist:</p>\n\n<ul>\n<li><p>KRACK leverages a nonce collision, which is practically as fundamental to cryptographic software as memory corruption is to software built in C and C++. A cryptographic researcher at a university might say: “yes, that’s why it shouldn’t win: it’s just another instance of a very well known attack”. Allow me to retort: everybody knows that you can’t copy a 200 byte string into a 100 byte buffer in a C program. We’ve known that since the mid-1990s. Is memory corruption dead? No! Attackers evolved, from noticing “hey, those extra bytes have to go somewhere” to “here is an elaborate sequence of steps involving the sequence of allocations and frees and the way numbers are represented on an X86 processor, that take a program that was coded defensively to avoid a class of attacks and revives that very attack against it”.</p></li>\n\n<li><p>That’s KRACK. The WPA2 designers knew that you couldn’t simply repeat nonces during handshaking. KRACK figured out a way to trick them into doing that.</p></li>\n\n<li><p>So I would argue: KRACK is the future of cryptographic vulnerability assessment: the recognition of a fundamental bug class and its application to systems built with that understanding. Every old crypto bug will become new again when someone figures out how to trick a target into reviving it.</p></li>\n</ul>\n\n<p>But, as with PGP, cryptography researchers wrote off WPA2 long ago. News flash: they’ve written off WPA3 as well! Good luck with those wireless networks.</p>\n\n<p><strong>Which brings us to the main event: ROCA or ROBOT?</strong></p>\n\n<p>Remember what the Pwnie for “Best Cryptographic Attack” represents. It’s “the most impactful cryptographic attack against real-world systems, protocols, or algorithms.” It’s not meant to be theoretical, but rather “requires actual pwnage”.</p>\n\n<h2 id=\"in-this-corner-roca\">In this corner: ROCA</h2>\n\n<p>ROCA broke all the Yubikeys. Also, Estonia. There will be ROCA-vulnerable RSA keys hidden in mission-critical infrastructure systems for the next 20 years. The real-world impact of ROCA is immense.</p>\n\n<p>The problem with ROCA is that it’s a problem with an exploit that takes core-years to execute. It’s a real vulnerability, but it’s closer to theory than any previous Pwnie nomination.</p>\n\n<h2 id=\"and-in-this-corner-robot\">And in this corner: ROBOT</h2>\n\n<p>ROBOT broke Facebook, Paypal, Cisco, a bunch of people running F5 middleboxes, Citrix, BouncyCastle, Erlang, WolfSSL, and Unisys ClearPath MCP. ClearPath! Someone finally broke it!</p>\n\n<p>The problem with ROBOT is that it’s cryptographically less interesting than ROCA. It exploits one of the better-known vulnerabilities in cryptography engineering: Bleichenbacher’s 1998 RSA oracle.</p>\n\n<h2 id=\"fight\">FIGHT!</h2>\n\n<p>ROCA is complicated. Complicated is good. The Pwnies are a celebration of elegant, high-degree-of-difficulty exploitation. ROCA is that. A lot of cryptography engineers who read the ROCA paper still don’t have their heads around the exploit.</p>\n\n<p>ROBOT is practical. Practical is good. The Pwnies are about “pwnage”; they’re about things that offensive security people can actually accomplish in the field, against real world systems. ROBOT broke the Unisys ClearPath MCP.</p>\n\n<p>ROCA is “practical” in a cryptographic sense. As a cryptosystem, the Infineon RSA generator it targets is a smoking crater. But put yourself in the shoes of a red team in 2018. Assume you’ve actually identified a vulnerable key to target. How long will it take you to factor that key? For a 2048 bit key, it’s around “100 CPU-years”.</p>\n\n<p>But ROCA is so bad that Estonia had to change its name and reissue new identity cards for the new nation of “post-ROCA Estonia”. All the Yubikey 4s got recalled. That’s impact. Impact is good.</p>\n\n<p>ROCA breaks hardware. Hardware is good. Exploit development against custom hardware is an elite skill. The Pwnies should celebrate elite skill. ROBOT took talent and finesse; the world is not full of Hanno Böcks finding systemic crypto vulnerabilities all across the Internet. But the degree of difficulty on ROCA is higher.</p>\n\n<p>On the other hand: ROCA affects just one hardware device. The error Infineon apparently made to wind up with the ROCA vulnerability is itself pretty elaborate. The bug was found during a survey of a large group of hardware and software RSA generators; Infineon was the only vendor with this problem. I could go into more detail here but the details are boring. No future vulnerability researcher is going to pull the ROCA paper out of their stack and find an equivalent vulnerability in a new target.</p>\n\n<p>ROBOT, different story. ROBOT is based on an older vulnerability, but the ROBOT research finally completes the weaponization of that vulnerability — not just in exploiting a single target in a single set of circumstances, but also in <em>detecting it in the first place</em>. In fact, in doing that, they found new ways to tickle the Bleichenbacher vulnerability, uncovering it in systems thought to be secure. The ROBOT methodology probably will get used by smart crypto testers in the future; it contributes to the craft in a broader way than ROCA.</p>\n\n<p>The crypto nerd in me wants ROCA to win.</p>\n\n<p>But if I put my “the spirit of the Pwnies” hat on, I’d probably have to give it to ROBOT.</p>\n","descriptionType":"text/html","publishedDate":"Wed, 08 Aug 2018 22:52:51 +0000","feedId":37180,"bgimg":"","linkMd5":"100d62c3a28fbf63f5241135a7d1ae4c","bgimgJsdelivr":"","metaImg":"","author":"","publishedOrCreatedDate":1602570541539}],"record":{"createdTime":"2020-10-13 14:29:01","updatedTime":"2020-10-13 14:29:01","feedId":37180,"fetchDate":"Tue, 13 Oct 2020 06:29:01 +0000","fetchMs":894,"handleMs":28510,"totalMs":29647,"newArticles":0,"totalArticles":17,"status":1,"type":0,"ip":"c38726fefc3aa4445f75f64d0364b5db","hostName":"europe68*","requestId":"bb3b20fb319f4bf6928789da7dc94e8f_37180","contentType":"text/xml","totalBytes":0,"bgimgsTotal":0,"bgimgsGithubTotal":0,"articlesImgsTotal":0,"articlesImgsGithubTotal":0,"successGithubMap":{},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 03:10:05","updatedTime":"2020-09-07 03:10:05","id":37180,"name":"Latacora","url":"https://latacora.micro.blog/feed.xml","subscriber":86,"website":null,"icon":"https://latacora.micro.blog/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"https://latacora.micro.blog"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1602570511892,"total":0,"statList":[{"spend":1137,"msg":"获取xml内容"},{"spend":28510,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":0,"msg":"正文链接上传到cdn"}]},"extra5":0,"extra6":0,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{},"extra12ImgCdnSuccessResultVector":[],"successGithubMap":{},"failGithubMap":{}}