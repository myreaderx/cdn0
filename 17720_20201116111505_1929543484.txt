{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-11-16 19:14:02","updatedTime":"2020-11-16 19:14:02","title":"Spring源码分析之循环依赖及解决方案","link":"https://juejin.im/post/6895645670120620045","description":"<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>分享是价值的传递，喜欢就点个赞</p>\n<hr>\n<p>正文：</p>\n<p>首先，我们需要明白什么是循环依赖？简单来说就是A对象创建过程中需要依赖B对象，而B对象创建过程中同样也需要A对象，所以A创建时需要先去把B创建出来，但B创建时又要先把A创建出来...死循环有木有...</p>\n<p><img alt=\"循环依赖\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dd93262e6da40d7a819c511380c85fc~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<p>那么在Spring中，有多少种循环依赖的情况呢？大部分人只知道两个普通的Bean之间的循环依赖，而Spring中其实存在三种对象（普通Bean，工厂Bean，代理对象），他们之间都会存在循环依赖，这里我给列举出来，大致分别以下几种：</p>\n<ul>\n<li>普通Bean与普通Bean之间</li>\n<li>普通Bean与代理对象之间</li>\n<li>代理对象与代理对象之间</li>\n<li>普通Bean与工厂Bean之间</li>\n<li>工厂Bean与工厂Bean之间</li>\n<li>工厂Bean与代理对象之间</li>\n</ul>\n<p>那么，在Spring中是如何解决这个问题的呢？</p>\n<h2 data-id=\"heading-0\">1. 普通Bean与普通Bean</h2>\n<p>首先，我们先设想一下，如果让我们自己来编码，我们会如何解决这个问题？</p>\n<h3 data-id=\"heading-1\">栗子</h3>\n<p>现在我们有两个互相依赖的对象A和B</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NormalBeanA</span> </span>{\n\n<span class=\"hljs-keyword\">private</span> NormalBeanB normalBeanB;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setNormalBeanB</span><span class=\"hljs-params\">(NormalBeanB normalBeanB)</span> </span>{\n<span class=\"hljs-keyword\">this</span>.normalBeanB = normalBeanB;\n}\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NormalBeanB</span> </span>{\n\n<span class=\"hljs-keyword\">private</span> NormalBeanA normalBeanA;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setNormalBeanA</span><span class=\"hljs-params\">(NormalBeanA normalBeanA)</span> </span>{\n<span class=\"hljs-keyword\">this</span>.normalBeanA = normalBeanA;\n}\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>然后我们想要让他们彼此都含有对象</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Main</span> </span>{\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n<span class=\"hljs-comment\">// 先创建A对象</span>\nNormalBeanA normalBeanA = <span class=\"hljs-keyword\">new</span> NormalBeanA();\n<span class=\"hljs-comment\">// 创建B对象</span>\nNormalBeanB normalBeanB = <span class=\"hljs-keyword\">new</span> NormalBeanB();\n<span class=\"hljs-comment\">// 将A对象的引用赋给B</span>\nnormalBeanB.setNormalBeanA(normalBeanA);\n<span class=\"hljs-comment\">// 再将B赋给A</span>\nnormalBeanA.setNormalBeanB(normalBeanB);\n}\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>发现了吗？我们并没有先创建一个完整的A对象，而是先创建了一个空壳对象（Spring中称为早期对象），将这个早期对象A先赋给了B，使得得到了一个完整的B对象，再将这个完整的B对象赋给A，从而解决了这个循环依赖问题，so easy!</p>\n<p>那么Spring中是不是也这样做的呢？我们就来看看吧～</p>\n<h3 data-id=\"heading-2\">Spring中的解决方案</h3>\n<blockquote>\n<p>由于上一篇已经分析过Bean的创建过程了，其中的某些部分就不再细讲了</p>\n</blockquote>\n<h4 data-id=\"heading-3\">先来到创建Bean的方法</h4>\n<blockquote>\n<p>AbstractAutowireCapableBeanFactory#doCreateBean</p>\n</blockquote>\n<p>假设此时在创建A</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title\">doCreateBean</span><span class=\"hljs-params\">(String beanName, RootBeanDefinition mbd, <span class=\"hljs-meta\">@Nullable</span> Object[] args)</span></span>{\n  <span class=\"hljs-comment\">// beanName -> A</span>\n  <span class=\"hljs-comment\">// 实例化A</span>\n  BeanWrapper instanceWrapper = createBeanInstance(beanName, mbd, args);\n  <span class=\"hljs-comment\">// 是否允许暴露早期对象</span>\n  <span class=\"hljs-keyword\">boolean</span> earlySingletonExposure = (mbd.isSingleton() && <span class=\"hljs-keyword\">this</span>.allowCircularReferences &&\n                                    isSingletonCurrentlyInCreation(beanName));\n  <span class=\"hljs-keyword\">if</span> (earlySingletonExposure) {\n    <span class=\"hljs-comment\">// 将获取早期对象的回调方法放到三级缓存中</span>\n    addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>addSingletonFactory</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addSingletonFactory</span><span class=\"hljs-params\">(String beanName, ObjectFactory<?> singletonFactory)</span> </span>{\n<span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>.singletonObjects) {\n<span class=\"hljs-comment\">// 单例缓存池中没有该Bean</span>\n<span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.singletonObjects.containsKey(beanName)) {\n<span class=\"hljs-comment\">// 将回调函数放入三级缓存</span>\n<span class=\"hljs-keyword\">this</span>.singletonFactories.put(beanName, singletonFactory);\n<span class=\"hljs-keyword\">this</span>.earlySingletonObjects.remove(beanName);\n<span class=\"hljs-keyword\">this</span>.registeredSingletons.add(beanName);\n}\n}\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>ObjectFactory是一个函数式接口</p>\n</blockquote>\n<p>在这里，我们发现在创建Bean时，Spring不管三七二十一，直接将一个获取早期对象的回调方法放进了一个三级缓存中，我们再来看一下回调方法的逻辑</p>\n<p>getEarlyBeanReference</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title\">getEarlyBeanReference</span><span class=\"hljs-params\">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>{\n  Object exposedObject = bean;\n  <span class=\"hljs-comment\">// 调用BeanPostProcessor对早期对象进行处理，在Spring的内置处理器中，并无相关的处理逻辑</span>\n  <span class=\"hljs-comment\">// 如果开启了AOP，将引入一个AnnotationAwareAspectJAutoProxyCreator,此时将可能对Bean进行动态代理</span>\n  <span class=\"hljs-keyword\">if</span> (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n    <span class=\"hljs-keyword\">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) {\n      <span class=\"hljs-keyword\">if</span> (bp <span class=\"hljs-keyword\">instanceof</span> SmartInstantiationAwareBeanPostProcessor) {\n        SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;\n        exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);\n      }\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> exposedObject;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>在这里，如果没有开启AOP，或者该对象不需要动态代理，会直接返回原对象</p>\n</blockquote>\n<p>此时，已经将A的早期对象缓存起来了，接下来在填充属性时会发生什么呢？</p>\n<p>相信大家也应该想到了，A对象填充属性时必然发现依赖了B对象，此时就将转头创建B，在创建B时同样会经历以上步骤，此时就该B对象填充属性了，这时，又将要转头创建A，那么，现在会有什么不一样的地方呢？我们看看getBean的逻辑吧</p>\n<p>doGetBean</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-keyword\">protected</span> <T> <span class=\"hljs-function\">T <span class=\"hljs-title\">doGetBean</span><span class=\"hljs-params\">(\nString name, <span class=\"hljs-meta\">@Nullable</span> Class<T> requiredType, <span class=\"hljs-meta\">@Nullable</span> Object[] args, <span class=\"hljs-keyword\">boolean</span> typeCheckOnly)</span></span>{\n  <span class=\"hljs-comment\">// 此时beanName为A</span>\n  String beanName = transformedBeanName(name);\n  <span class=\"hljs-comment\">// 尝试从三级缓存中获取bean,这里很关键</span>\n  Object sharedInstance = getSingleton(beanName);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title\">getSingleton</span><span class=\"hljs-params\">(String beanName, <span class=\"hljs-keyword\">boolean</span> allowEarlyReference)</span> </span>{\n  <span class=\"hljs-comment\">// 从单例缓存池中获取，此时仍然是取不到的</span>\n  Object singletonObject = <span class=\"hljs-keyword\">this</span>.singletonObjects.get(beanName);\n  <span class=\"hljs-comment\">// 获取不到，判断bean是否正在创建，没错，此时A确实正在创建</span>\n  <span class=\"hljs-keyword\">if</span> (singletonObject == <span class=\"hljs-keyword\">null</span> && isSingletonCurrentlyInCreation(beanName)) {\n    <span class=\"hljs-comment\">// 由于现在仍然是在同一个线程，基于同步锁的可重入性，此时不会阻塞</span>\n    <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>.singletonObjects) {\n      <span class=\"hljs-comment\">// 从早期对象缓存池中获取，这里是没有的</span>\n      singletonObject = <span class=\"hljs-keyword\">this</span>.earlySingletonObjects.get(beanName);\n      <span class=\"hljs-keyword\">if</span> (singletonObject == <span class=\"hljs-keyword\">null</span> && allowEarlyReference) {\n        <span class=\"hljs-comment\">// 从三级缓存中获取回调函数，此时就获取到了我们在创建A时放入的回调函数</span>\n        ObjectFactory<?> singletonFactory = <span class=\"hljs-keyword\">this</span>.singletonFactories.get(beanName);\n        <span class=\"hljs-keyword\">if</span> (singletonFactory != <span class=\"hljs-keyword\">null</span>) {\n          <span class=\"hljs-comment\">// 调用回调方法获取早期bean，由于我们现在讨论的是普通对象，所以返回原对象</span>\n          singletonObject = singletonFactory.getObject();\n          <span class=\"hljs-comment\">// 将早期对象放到二级缓存，移除三级缓存</span>\n          <span class=\"hljs-keyword\">this</span>.earlySingletonObjects.put(beanName, singletonObject);\n          <span class=\"hljs-keyword\">this</span>.singletonFactories.remove(beanName);\n        }\n      }\n    }\n  }\n  <span class=\"hljs-comment\">// 返回早期对象A</span>\n  <span class=\"hljs-keyword\">return</span> singletonObject;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>震惊！此时我们就拿到了A的早期对象进行返回，所以B得以被填充属性，B创建完毕后，又将返回到A填充属性的过程，A也得以被填充属性，A也创建完毕，这时，A和B都创建好了，循环依赖问题得以收场～</p>\n<p><img alt class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6a91986691a4534a4d7b985e117e5d6~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<blockquote>\n<p>普通Bean和普通Bean之间的问题就到这里了，不知道小伙伴们有没有晕呢～</p>\n</blockquote>\n<h2 data-id=\"heading-4\">2. 普通Bean和代理对象</h2>\n<p>普通Bean和代理对象之间的循环依赖与两个普通Bean的循环依赖其实大致相同，只不过是多了一次动态代理的过程，我们假设A对象是需要代理的对象，B对象仍然是一个普通对象，然后，我们开始创建A对象。</p>\n<p>刚开始创建A的过程与上面的例子是一模一样的，紧接着自然是需要创建B，然后B依赖了A，于是又倒回去创建A，此时，再次走到去缓存池获取的过程。</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-comment\">// 从三级缓存中获取回调函数</span>\nObjectFactory<?> singletonFactory = <span class=\"hljs-keyword\">this</span>.singletonFactories.get(beanName);\n<span class=\"hljs-keyword\">if</span> (singletonFactory != <span class=\"hljs-keyword\">null</span>) {\n  <span class=\"hljs-comment\">// 调用回调方法获取早期bean，此时返回的是一个A的代理对象</span>\n  singletonObject = singletonFactory.getObject();\n  <span class=\"hljs-comment\">// 将早期对象放到二级缓存，移除三级缓存</span>\n  <span class=\"hljs-keyword\">this</span>.earlySingletonObjects.put(beanName, singletonObject);\n  <span class=\"hljs-keyword\">this</span>.singletonFactories.remove(beanName);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>这时就不太一样了，在<code>singletonFactory.getObject()</code>时，由于此时A是需要代理的对象，在调用回调函数时，就会触发动态代理的过程</p>\n<p>AbstractAutoProxyCreator#getEarlyBeanReference</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">getEarlyBeanReference</span><span class=\"hljs-params\">(Object bean, String beanName)</span> </span>{\n  <span class=\"hljs-comment\">// 生成一个缓存Key</span>\n  Object cacheKey = getCacheKey(bean.getClass(), beanName);\n  <span class=\"hljs-comment\">// 放入缓存中，用于在初始化后调用该后置处理器时判断是否进行动态代理过</span>\n  <span class=\"hljs-keyword\">this</span>.earlyProxyReferences.put(cacheKey, bean);\n  <span class=\"hljs-comment\">// 将对象进行动态代理</span>\n  <span class=\"hljs-keyword\">return</span> wrapIfNecessary(bean, beanName, cacheKey);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>此时，B在创建时填充的属性就是A的代理对象了，B创建完毕，返回到A的创建过程，<strong>但此时的A仍然是一个普通对象，可B引用的A已经是个代理对象了</strong>，不知道小伙伴看到这里有没有迷惑呢？</p>\n<p>不急，让我们继续往下走，填充完属性自然是需要初始化的，在初始化后，会调用一次后置处理器，我们看看会不会有答案吧</p>\n<h3 data-id=\"heading-5\">初始化</h3>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title\">initializeBean</span><span class=\"hljs-params\">(String beanName, Object bean, <span class=\"hljs-meta\">@Nullable</span> RootBeanDefinition mbd)</span> </span>{\n<span class=\"hljs-comment\">//...省略前面的步骤...</span>\n  <span class=\"hljs-comment\">// 调用初始化方法</span>\n  invokeInitMethods(beanName, wrappedBean, mbd);\n  <span class=\"hljs-comment\">// 处理初始化后的bean</span>\n  wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>在处理初始化后的bean，又会调用动态代理的后置处理器了</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">postProcessAfterInitialization</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@Nullable</span> Object bean, String beanName)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (bean != <span class=\"hljs-keyword\">null</span>) {\n    Object cacheKey = getCacheKey(bean.getClass(), beanName);\n    <span class=\"hljs-comment\">// 判断缓存中是否有该对象，有则说明该对象已被动态代理，跳过</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.earlyProxyReferences.remove(cacheKey) != bean) {\n      <span class=\"hljs-keyword\">return</span> wrapIfNecessary(bean, beanName, cacheKey);\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> bean;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>不知道小伙伴发现没有，<code>earlyProxyReferences</code>这个缓存可不就是我们在填充B的属性，进而从缓存中获取A时放进去的吗？不信您往上翻到<code>getEarlyBeanReference</code>的步骤看看～</p>\n<p>所以，此时并未进行任何处理，依旧返回了我们的原对象A，看来这里并没有我们要的答案，那就继续吧～</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-comment\">// 是否允许暴露早期对象</span>\n<span class=\"hljs-keyword\">if</span> (earlySingletonExposure) {\n  <span class=\"hljs-comment\">// 从缓存池中获取早期对象</span>\n  Object earlySingletonReference = getSingleton(beanName, <span class=\"hljs-keyword\">false</span>);\n  <span class=\"hljs-keyword\">if</span> (earlySingletonReference != <span class=\"hljs-keyword\">null</span>) {\n    <span class=\"hljs-comment\">// bean为初始化前的对象，exposedObject为初始化后的对象</span>\n    <span class=\"hljs-comment\">// 判断两对象是否相等，基于上面的分析，这两者是相等的</span>\n    <span class=\"hljs-keyword\">if</span> (exposedObject == bean) {\n      <span class=\"hljs-comment\">// 将早期对象赋给exposedObject</span>\n      exposedObject = earlySingletonReference;\n    }\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>我们来分析一下上面的逻辑，<code>getSingleton</code>从缓存池中获取早期对象返回的是什么呢？</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>.singletonObjects) {\n  <span class=\"hljs-comment\">// 从早期对象缓存池中获取，此时就拿到了我们填充B属性时放入的A的代理对象</span>\n  singletonObject = <span class=\"hljs-keyword\">this</span>.earlySingletonObjects.get(beanName);\n  <span class=\"hljs-keyword\">if</span> (singletonObject == <span class=\"hljs-keyword\">null</span> && allowEarlyReference) {\n    <span class=\"hljs-comment\">// 从三级缓存中获取回调函数</span>\n    ObjectFactory<?> singletonFactory = <span class=\"hljs-keyword\">this</span>.singletonFactories.get(beanName);\n    <span class=\"hljs-keyword\">if</span> (singletonFactory != <span class=\"hljs-keyword\">null</span>) {\n      <span class=\"hljs-comment\">// 调用回调方法获取早期bean</span>\n      singletonObject = singletonFactory.getObject();\n      <span class=\"hljs-comment\">// 将早期对象放到二级缓存，移除三级缓存</span>\n      <span class=\"hljs-keyword\">this</span>.earlySingletonObjects.put(beanName, singletonObject);\n      <span class=\"hljs-keyword\">this</span>.singletonFactories.remove(beanName);\n    }\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>发现了吗？此时我们就获取到了A的代理对象，然后我们又把这个对象赋给了exposedObject，此时创建对象的流程走完，我们得到的A不就是个代理对象了吗～</p>\n<blockquote>\n<p>此次栗子是先创建需要代理的对象A，假设我们先创建普通对象B会发生什么呢？</p>\n</blockquote>\n<h2 data-id=\"heading-6\">3. 代理对象与代理对象</h2>\n<p>代理对象与代理对象的循环依赖是怎么样的呢？解决过程又是如何呢？这里就留给小伙伴自己思考了，其实和普通Bean与代理对象是一模一样的，小伙伴想想是不是呢，这里我就不做分析了。</p>\n<h2 data-id=\"heading-7\">4. 普通Bean与工厂Bean</h2>\n<p>这里所说的普通Bean与工厂Bean并非指bean与FactoryBean，这将毫无意义，而是指普通Bean与FactoryBean的<code>getObject</code>方法产生了循环依赖，因为<code>FactoryBean</code>最终产生的对象是由<code>getObject</code>方法所产出。我们先来看看栗子吧～</p>\n<p>假设工厂对象A依赖普通对象B，普通对象B依赖普通对象A。</p>\n<p>小伙伴看到这里就可能问了，诶～你这不对呀，怎么成了「普通对象B依赖普通对象A」呢？不应该是工厂对象A吗？是这样的，在Spring中，由于普通对象A是由工厂对象A产生，所有在普通对象B想要获取普通对象A时，其实最终寻找调用的是工厂对象A的<code>getObject</code>方法，所以只要普通对象B依赖普通对象A就可以了，Spring会自动帮我们把普通对象B和工厂对象A联系在一起。</p>\n<blockquote>\n<p>小伙伴，哦～</p>\n</blockquote>\n<p>普通对象A</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NormalBeanA</span> </span>{\n\n<span class=\"hljs-keyword\">private</span> NormalBeanB normalBeanB;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setNormalBeanB</span><span class=\"hljs-params\">(NormalBeanB normalBeanB)</span> </span>{\n<span class=\"hljs-keyword\">this</span>.normalBeanB = normalBeanB;\n}\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>工厂对象A</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FactoryBeanA</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">FactoryBean</span><<span class=\"hljs-title\">NormalBeanA</span>> </span>{\n<span class=\"hljs-meta\">@Autowired</span>\n<span class=\"hljs-keyword\">private</span> ApplicationContext context;\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> NormalBeanA <span class=\"hljs-title\">getObject</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\nNormalBeanA normalBeanA = <span class=\"hljs-keyword\">new</span> NormalBeanA();\nNormalBeanB normalBeanB = context.getBean(<span class=\"hljs-string\">\"normalBeanB\"</span>, NormalBeanB.class);\nnormalBeanA.setNormalBeanB(normalBeanB);\n<span class=\"hljs-keyword\">return</span> normalBeanA;\n}\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">public</span> Class<?> getObjectType() {\n<span class=\"hljs-keyword\">return</span> NormalBeanA.class;\n}\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>普通对象B</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NormalBeanB</span> </span>{\n<span class=\"hljs-meta\">@Autowired</span>\n<span class=\"hljs-keyword\">private</span> NormalBeanA normalBeanA;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>假设我们先创建对象A</p>\n<p>由于FactoryBean和Bean的创建过程是一样的，只是多了步<code>getObject</code>，所以我们直接定位到调用<code>getObject</code>入口</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-keyword\">if</span> (mbd.isSingleton()) {\n  <span class=\"hljs-comment\">// 开始创建bean</span>\n  sharedInstance = getSingleton(beanName, () -> {\n    <span class=\"hljs-comment\">// 创建bean</span>\n    <span class=\"hljs-keyword\">return</span> createBean(beanName, mbd, args);\n  });\n  <span class=\"hljs-comment\">// 处理FactoryBean</span>\n  bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title\">getObjectForBeanInstance</span><span class=\"hljs-params\">(\nObject beanInstance, String name, String beanName, <span class=\"hljs-meta\">@Nullable</span> RootBeanDefinition mbd)</span> </span>{\n<span class=\"hljs-comment\">// 先尝试从缓存中获取，保证多次从工厂bean获取的bean是同一个bean</span>\n  object = getCachedObjectForFactoryBean(beanName);\n  <span class=\"hljs-keyword\">if</span> (object == <span class=\"hljs-keyword\">null</span>) {\n    <span class=\"hljs-comment\">// 从FactoryBean获取对象</span>\n    object = getObjectFromFactoryBean(factory, beanName, !synthetic);\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title\">getObjectFromFactoryBean</span><span class=\"hljs-params\">(FactoryBean<?> factory, String beanName, <span class=\"hljs-keyword\">boolean</span> shouldPostProcess)</span> </span>{\n<span class=\"hljs-comment\">// 加锁，防止多线程时重复创建bean</span>\n  <span class=\"hljs-keyword\">synchronized</span> (getSingletonMutex()) {\n    <span class=\"hljs-comment\">// 这里是Double Check</span>\n    Object object = <span class=\"hljs-keyword\">this</span>.factoryBeanObjectCache.get(beanName);\n    <span class=\"hljs-keyword\">if</span> (object == <span class=\"hljs-keyword\">null</span>) {\n      <span class=\"hljs-comment\">// 获取bean，调用factoryBean的getObject()</span>\n      object = doGetObjectFromFactoryBean(factory, beanName);\n    }\n    <span class=\"hljs-comment\">// 又从缓存中取了一次，why? 我们慢慢分析</span>\n    Object alreadyThere = <span class=\"hljs-keyword\">this</span>.factoryBeanObjectCache.get(beanName);\n    <span class=\"hljs-keyword\">if</span> (alreadyThere != <span class=\"hljs-keyword\">null</span>) {\n      object = alreadyThere;\n    }<span class=\"hljs-keyword\">else</span>{\n      <span class=\"hljs-comment\">// ...省略初始化bean的逻辑...</span>\n      <span class=\"hljs-comment\">// 将获取到的bean放入缓存</span>\n      <span class=\"hljs-keyword\">this</span>.factoryBeanObjectCache.put(beanName, object);\n    }\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Object <span class=\"hljs-title\">doGetObjectFromFactoryBean</span><span class=\"hljs-params\">(FactoryBean<?> factory, String beanName)</span></span>{\n  <span class=\"hljs-keyword\">return</span> factory.getObject();\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>现在，就走到了我们自定义的<code>getObject</code>方法，由于我们调用了<code>context.getBean(\"normalBeanB\", NormalBeanB.class)</code>，此时，将会去创建B对象，在创建过程中，先将B的早期对象放入三级缓存，紧接着填充属性，发现依赖了A对象，又要倒回来创建A对象，从而又回到上面的逻辑，再次调用我们自定义的<code>getObject</code>方法，这个时候会发生什么呢？</p>\n<p>又要去创建B对象...(Spring:心好累)</p>\n<p>但是！此时我们在创建B时，是直接通过<code>getBean</code>在缓存中获取到了B的早期对象，得以返回了！于是我们自定义的<code>getObject</code>调用成功，返回了一个完整的A对象！</p>\n<p>但是此时<code>FactoryBean</code>的缓冲中还是什么都没有的。</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-comment\">// 又从缓存中取了一次</span>\nObject alreadyThere = <span class=\"hljs-keyword\">this</span>.factoryBeanObjectCache.get(beanName);\n<span class=\"hljs-keyword\">if</span> (alreadyThere != <span class=\"hljs-keyword\">null</span>) {\n  object = alreadyThere;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>这一次取<code>alreadyThere</code>必然是null，流程继续执行，将此时将获取到的bean放入缓存</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-keyword\">this</span>.factoryBeanObjectCache.put(beanName, object);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>从FactoryBean获取对象的流程结束，返回到创建B的过程中，B对象此时的属性也得以填充，再返回到第一次创建A的过程，也就是我们第一次调用自定义的<code>getObject</code>方法，调用完毕，返回到这里</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-comment\">// 获取bean，调用factoryBean的getObject()</span>\nobject = doGetObjectFromFactoryBean(factory, beanName);\nObject alreadyThere = <span class=\"hljs-keyword\">this</span>.factoryBeanObjectCache.get(beanName);\n<span class=\"hljs-keyword\">if</span> (alreadyThere != <span class=\"hljs-keyword\">null</span>) {\n  object = alreadyThere;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>那么，此时<code>this.factoryBeanObjectCache.get(beanName)</code>能从缓冲中拿到对象了吗？有没有发现，拿到了刚刚B对象填充属性时再次创建A对象放进去的！</p>\n<p>所以，明白这里为什么要再次从缓存中获取了吧？就是为了解决由于循环依赖时调用了两次自定义的<code>getObject</code>方法，从而创建了两个不相同的A对象，保证我们返回出去的A对象唯一！</p>\n<blockquote>\n<p>怕小伙伴晕了，画个图给大家</p>\n</blockquote>\n<p><img alt class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56ed8134acb84da8b043bcb38a08be41~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<h2 data-id=\"heading-8\">5. 工厂Bean与工厂Bean之间</h2>\n<p>我们已经举例4种循环依赖的栗子，Spring都有所解决，那么有没有Spring也无法解决的循环依赖问题呢？</p>\n<p>有的！就是这个<code>FactoryBean</code>与<code>FactoryBean</code>的循环依赖！</p>\n<p>假设工厂对象A依赖工厂对象B，工厂对象B依赖工厂对象A，那么，这次的栗子会是什么样呢？</p>\n<p>普通对象</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NormalBeanA</span> </span>{\n\n<span class=\"hljs-keyword\">private</span> NormalBeanB normalBeanB;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setNormalBeanB</span><span class=\"hljs-params\">(NormalBeanB normalBeanB)</span> </span>{\n<span class=\"hljs-keyword\">this</span>.normalBeanB = normalBeanB;\n}\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NormalBeanB</span> </span>{\n\n<span class=\"hljs-keyword\">private</span> NormalBeanA normalBeanA;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setNormalBeanA</span><span class=\"hljs-params\">(NormalBeanA normalBeanA)</span> </span>{\n<span class=\"hljs-keyword\">this</span>.normalBeanA = normalBeanA;\n}\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>工厂对象</p>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FactoryBeanA</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">FactoryBean</span><<span class=\"hljs-title\">NormalBeanA</span>> </span>{\n<span class=\"hljs-meta\">@Autowired</span>\n<span class=\"hljs-keyword\">private</span> ApplicationContext context;\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> NormalBeanA <span class=\"hljs-title\">getObject</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\nNormalBeanA normalBeanA = <span class=\"hljs-keyword\">new</span> NormalBeanA();\nNormalBeanB normalBeanB = context.getBean(<span class=\"hljs-string\">\"factoryBeanB\"</span>, NormalBeanB.class);\nnormalBeanA.setNormalBeanB(normalBeanB);\n<span class=\"hljs-keyword\">return</span> normalBeanA;\n}\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">public</span> Class<?> getObjectType() {\n<span class=\"hljs-keyword\">return</span> NormalBeanA.class;\n}\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs language-java copyable\" lang=\"java\"><span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FactoryBeanB</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">FactoryBean</span><<span class=\"hljs-title\">NormalBeanB</span>> </span>{\n<span class=\"hljs-meta\">@Autowired</span>\n<span class=\"hljs-keyword\">private</span> ApplicationContext context;\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> NormalBeanB <span class=\"hljs-title\">getObject</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\nNormalBeanB normalBeanB = <span class=\"hljs-keyword\">new</span> NormalBeanB();\nNormalBeanA normalBeanA = context.getBean(<span class=\"hljs-string\">\"factoryBeanA\"</span>, NormalBeanA.class);\nnormalBeanB.setNormalBeanA(normalBeanA);\n<span class=\"hljs-keyword\">return</span> normalBeanB;\n}\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">public</span> Class<?> getObjectType() {\n<span class=\"hljs-keyword\">return</span> NormalBeanB.class;\n}\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>首先，我们开始创建对象A，此时为调用工厂对象A的<code>getObject</code>方法，转而去获取对象B，便会走到工厂对象B的<code>getObject</code>方法，然后又去获取对象A，又将调用工厂对象A的<code>getObject</code>，再次去获取对象B，于是再次走到工厂对象B的<code>getObject</code>方法......此时，已经历了一轮循环，却没有跳出循环的迹象，妥妥的死循环了。</p>\n<p>我们画个图吧～</p>\n<p><img alt class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1c7211602df4dde816a0e579e960a71~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<p>没错！这个图就是这么简单，由于始终无法创建出一个对象，不管是早期对象或者完整对象，使得两个工厂对象反复的去获取对方，导致陷入了死循环。</p>\n<p>那么，我们是否有办法解决这个问题呢？</p>\n<p>我的答案是无法解决，如果有想法的小伙伴也可以自己想一想哦～</p>\n<p>我们发现，在发生循环依赖时，只要循环链中的某一个点可以先创建出一个早期对象，那么在下一次循环时，就会使得我们能够获取到早期对象从而跳出循环！</p>\n<p>而由于工厂对象与工厂对象间是无法创建出这个早期对象的，无法满足跳出循环的条件，导致变成了死循环。</p>\n<blockquote>\n<p>那么此时Spring中会抛出一个什么样的异常呢？</p>\n<p>当然是栈溢出异常啦！两个工厂对象一直相互调用，不断开辟栈帧，可不就是栈溢出有木有～</p>\n</blockquote>\n<h2 data-id=\"heading-9\">6. 工厂对象与代理对象</h2>\n<p>上面的情况是无法解决循环依赖的，那么这个情况可以解决吗？</p>\n<p>答案是可以的！</p>\n<p>我们分析了，一个循环链是否能够得到终止，关键在于是否能够在某个点创建出一个早期对象（临时对象），而代理对象在<code>doCreateBean</code>时，是会生成一个早期对象放入三级缓存的，于是该循环链得以终结。</p>\n<p>具体过程我这里就不再细分析了，就交由小伙伴自己动手吧～</p>\n<h2 data-id=\"heading-10\">总结</h2>\n<p>以上我们一共举例了6种情况，通过分析，总结出这样一条定律：</p>\n<p>在发生循环依赖时，判断一个循环链是否能够得到终止，关键在于是否能够在某个点创建出一个早期对象（临时对象），那么在下一次循环时，我们就能通过该早期对象进而跳出（打破）循环！</p>\n<p>通过这样的定律，我们得出工厂Bean与工厂Bean之间是无法解决循环依赖的，那么还有其他情况无法解决循环依赖吗？</p>\n<p>有的！以上的例子举的都是单例的对象，并且都是通过set方法形成的循环依赖。</p>\n<p>假使我们是由于构造方法形成的循环依赖呢？是否有解决办法吗？</p>\n<p>没有，因为这并不满足我们得出的定律</p>\n<blockquote>\n<p>无法执行完毕构造方法，自然无法创建出一个早期对象。</p>\n</blockquote>\n<p>假使我们的对象是多例的呢？</p>\n<p>也不能，因为多例的对象在每次创建时都是创建新的对象，即使能够创建出早期对象，也不能为下一次循环所用！</p>\n<blockquote>\n<p>好了，本文就到这里结束了，希望小伙伴们有所收获～</p>\n<p>Spring IOC的核心部分到此篇就结束了，下一篇就让我们进行AOP之旅吧～</p>\n</blockquote>\n<p>下文预告：Spring源码分析之AOP从解析到调用</p>\n<h5 data-id=\"heading-11\">Spring 源码系列-传送门</h5>\n<ol>\n<li><a href=\"https://juejin.im/post/6882642029261225998\" target=\"_blank\">Spring源码分析之 IOC 容器预启动流程</a>(已完结)</li>\n<li><a href=\"https://juejin.im/post/6881908719324659725\" target=\"_blank\">Spring源码分析之BeanFactory体系结构</a>(已完结)</li>\n<li><a href=\"https://juejin.im/post/6888140547249307661\" target=\"_blank\">Spring源码分析之BeanFactoryPostProcessor调用过程</a>(已完结)</li>\n<li><a href=\"https://juejin.im/post/6888970251822235655\" target=\"_blank\">Spring源码分析之Bean的创建过程</a>(已完结)</li>\n<li><strong>Spring源码分析之什么是循环依赖及解决方案</strong>(当前文章)</li>\n<li>Spring源码分析之AOP从解析到调用</li>\n<li>Spring源码分析之事务管理(上)，事物管理是spring作为容器的一个特点，总结一下他的基本实现与原理吧</li>\n<li>Spring源码分析之事务管理(下) ，关于他的底层事物隔离与事物传播原理，重点分析一下</li>\n</ol>\n<h5 data-id=\"heading-12\">Spring Mvc 源码系列</h5>\n<ol>\n<li>SpringMvc体系结构</li>\n<li>SpringMvc源码分析之Handler解析过程</li>\n<li>SpringMvc源码分析之请求链过程</li>\n</ol>\n<blockquote>\n<p>另外笔者公众号：奇客时间，有更多精彩的文章，有兴趣的同学，可以关注</p>\n</blockquote></div> <div class=\"image-viewer-box\" data-v-78c9b824><!----></div>","descriptionType":"text/html","publishedDate":"Mon, 16 Nov 2020 01:09:15 +0000","feedId":17720,"bgimg":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dd93262e6da40d7a819c511380c85fc~tplv-k3u1fbpfcp-zoom-1.image","linkMd5":"fd99229c101a83c64d156b68ce8975ed","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn34@2020_3/2020/11/16/11-14-03-895_261944a8d53d2e07.webp","destWidth":704,"destHeight":460,"sourceBytes":37405,"destBytes":13798,"author":"雕爷","articleImgCdnMap":{"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dd93262e6da40d7a819c511380c85fc~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn34@2020_3/2020/11/16/11-14-03-895_261944a8d53d2e07.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6a91986691a4534a4d7b985e117e5d6~tplv-k3u1fbpfcp-zoom-1.image":null,"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56ed8134acb84da8b043bcb38a08be41~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn41@2020_2/2020/11/16/11-14-06-362_4ada23417c7e6af7.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1c7211602df4dde816a0e579e960a71~tplv-k3u1fbpfcp-zoom-1.image":null},"publishedOrCreatedDate":1605525242933}],"record":{"createdTime":"2020-11-16 19:14:02","updatedTime":"2020-11-16 19:14:02","feedId":17720,"fetchDate":"Mon, 16 Nov 2020 11:14:02 +0000","fetchMs":76,"handleMs":32,"totalMs":62405,"newArticles":0,"totalArticles":5,"status":1,"type":0,"ip":"88cef4bdd08b957a3f46cf2634bfc2c6","hostName":"us-035*","requestId":"f1ebd6d51fcc4d8c95ef80a6a22bca7c_17720","contentType":"application/xml; charset=utf-8","totalBytes":72622,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":4,"articlesImgsGithubTotal":2,"successGithubMap":{"myreaderx6":1,"myreaderx24":1},"failGithubMap":{"myreaderx23":1}},"feed":{"createdTime":"2020-09-07 02:15:50","updatedTime":"2020-09-07 02:49:19","id":17720,"name":"掘金后端","url":"https://rsshub.app/juejin/category/backend","subscriber":187,"website":null,"icon":"https://juejin.im/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx63/cdn96@2020_3/2020/09/06/18-47-49-898_24cb365749d306f2.ico","description":"掘金后端 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2020-11-16 19:15:05","updatedTime":"2020-11-16 19:15:05","id":null,"feedId":17720,"linkMd5":"fd99229c101a83c64d156b68ce8975ed"}],"tmpCommonImgCdnBytes":13798,"tmpBodyImgCdnBytes":58824,"tmpBgImgCdnBytes":0,"extra4":{"start":1605525242816,"total":0,"statList":[{"spend":86,"msg":"获取xml内容"},{"spend":32,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":60468,"msg":"正文链接上传到cdn"}]},"extra5":4,"extra6":4,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1c7211602df4dde816a0e579e960a71~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":700,"destHeight":398,"sourceBytes":22584,"destBytes":9012,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":2053,"convertSpendMs":15,"createdTime":"2020-11-16 19:14:04","host":"europe70*","referer":"https://juejin.im/post/6895645670120620045","linkMd5ListStr":"fd99229c101a83c64d156b68ce8975ed","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn45/contents/2020/11/16/11-14-06-743_16436e58d2067140.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Mon, 16 Nov 2020 11:14:07 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["8FDC:5C52:3C3AC2B:454FD96:5FB25EF8"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1605528578"],"x-ratelimit-used":["61"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn45/contents/2020/11/16/11-14-06-743_16436e58d2067140.webp","historyStatusCode":[],"spendMs":171},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"22.1 KB","destSize":"8.8 KB","compressRate":"39.9%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1c7211602df4dde816a0e579e960a71~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":700,"destHeight":398,"sourceBytes":22584,"destBytes":9012,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":329,"convertSpendMs":14,"createdTime":"2020-11-16 19:14:06","host":"europe70*","referer":"https://juejin.im/post/6895645670120620045","linkMd5ListStr":"fd99229c101a83c64d156b68ce8975ed","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn45/contents/2020/11/16/11-14-07-149_16436e58d2067140.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Mon, 16 Nov 2020 11:14:07 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["8FDC:5C52:3C3ACBD:4550819:5FB25EFF"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1605528578"],"x-ratelimit-used":["61"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn45/contents/2020/11/16/11-14-07-149_16436e58d2067140.webp","historyStatusCode":[],"spendMs":171},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"22.1 KB","destSize":"8.8 KB","compressRate":"39.9%"},null,{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6a91986691a4534a4d7b985e117e5d6~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"sourceBytes":0,"destBytes":0,"feedId":17720,"totalSpendMs":239,"convertSpendMs":0,"createdTime":"2020-11-16 19:15:04","host":"us-007*","referer":"https://juejin.im/post/6895645670120620045","linkMd5ListStr":"fd99229c101a83c64d156b68ce8975ed","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"0","destSize":"0"}],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-007.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-019.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://europe70.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dd93262e6da40d7a819c511380c85fc~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":704,"destHeight":460,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn34@2020_3/2020/11/16/11-14-03-895_261944a8d53d2e07.webp","sourceBytes":37405,"destBytes":13798,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":1775,"convertSpendMs":13,"createdTime":"2020-11-16 19:14:02","host":"us-031*","referer":"https://juejin.im/post/6895645670120620045","linkMd5ListStr":"fd99229c101a83c64d156b68ce8975ed,fd99229c101a83c64d156b68ce8975ed","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"36.5 KB","destSize":"13.5 KB","compressRate":"36.9%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56ed8134acb84da8b043bcb38a08be41~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":2274,"destHeight":840,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn41@2020_2/2020/11/16/11-14-06-362_4ada23417c7e6af7.webp","sourceBytes":150114,"destBytes":58824,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":2548,"convertSpendMs":77,"createdTime":"2020-11-16 19:14:04","host":"us-007*","referer":"https://juejin.im/post/6895645670120620045","linkMd5ListStr":"fd99229c101a83c64d156b68ce8975ed","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"146.6 KB","destSize":"57.4 KB","compressRate":"39.2%"}],"successGithubMap":{"myreaderx6":1,"myreaderx24":1},"failGithubMap":{"myreaderx23":1}}