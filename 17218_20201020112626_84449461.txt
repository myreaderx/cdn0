{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-20 19:26:11","updatedTime":"2020-10-20 19:26:11","title":"Emerging Defense in Android Kernel","link":"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/","description":"<p>There was a time that every Linux kernel hacker loves Android. It comes with a kernel from stone-age with merely any exploit mitigation. Writing exploit with any N-day available was just a walk in the park.<br>Now a days Google, ARM and many other SoC/device vendors have put many efforts hardening the security of Android, including its kernel, which is (in most cases) the last defense against attack.</br></p> \n<p>As a group of Android gurus focusing on rooting, we probably facing these defense more than researchers in other fields. In this post we are going to summarize kernel exploit mitigations appeared in the recent 2 years, and sharing our opinions on their effectiveness.</p> \n<p>Note that we are going to focus on the implementation of mitigations in this post. We may point out its weakness, but we are not going to detail bypassing techniques for each mitigation.<br><a id=\"more\"></a></br></p> \n<h2 id=\"Outline\"><a href=\"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/#Outline\" class=\"headerlink\" title=\"Outline\"></a>Outline</h2> \n<ul> \n <li>Hardware</li> \n <li>Google/Linux</li> \n <li>Vendors \n  <ul> \n   <li>Samsung</li> \n   <li>Others</li> \n  </ul></li> \n</ul> \n<h2 id=\"Hardware\"><a href=\"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/#Hardware\" class=\"headerlink\" title=\"Hardware\"></a>Hardware</h2> \n<p>As Intel has officially abandoned its Atom product line, no one is going to challenge ARM’s Android dominance soon enough. We will be focusing on ARM for the rest part of this post, since no one cares any other architecture for Android :p</p> \n<p><strong>MMU</strong><br>Modern ARM processors come with a comprehensive MMU, providing basic V2P translation, access control, TLB, ASIDs and many other memory management features. Among them, both 32-bit (arm) and 64-bit (arm64) mode of recent ARM architectures provide full RWX access control on pages level. In addition, one of the key “advanced” security features is PXN (Privilege Execute-Never), a feature with similar idea of Intel’s SMEP but different in implementation details. PXN has been widely enabled on 64-bit devices as a relief of ret2usr attacks.<br>Details on how Android kernel utilize these features will be discussed in further sections.</br></br></p> \n<p><strong>TrustZone</strong><br>TrustZone is an extension to ARM cores, which creates two “worlds”. The following figure describes how this works:<br><img src=\"http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/tz_two_worlds.png\" alt=\"\"><br>Source: <a href=\"https://genode.org/documentation/articles/trustzone\" target=\"_blank\" rel=\"noopener\">https://genode.org/documentation/articles/trustzone</a></br></img></br></br></p> \n<p>Although few restrictions are there that how vendor can utilize Trustzone, usually the feature-rich OS, aka Android, in our case, is going to run in the normal world. The secure world will be hosting trustlets on a light-weight OS.<br>As a secure world running in parallel with the normal world, compromising the kernel in normal world shall not affect the secure world if the implementation was properly done, as their communication is handled by the privileged monitor mode code usually loaded by low-level bootrom. However, there are cases seen that secure world can also be compromised due to its own bug or bugs in monitor mode.</br></p> \n<h2 id=\"Google-Linux\"><a href=\"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/#Google-Linux\" class=\"headerlink\" title=\"Google/Linux\"></a>Google/Linux</h2> \n<p>As the open source software being used most widely, Linux kernel can be modified by many parties, which not all of these modifications are merged into mainline. Here we will be only discussing the features implemented in mainline and appear in Google’s Android kernel repositories.<br>Linux kernel has utilized many features to harden the kernel. One of them is protecting critical memory zones like kernel text and non-volatile data. Recent Linux mainline kernel has this feature implemented through CONFIG_DEBUG_RODATA:</br></p> \n<pre>CONFIG_DEBUG_RODATA    arm    prompt: Make kernel text and rodata read-only    type: bool    depends on: ( CONFIG_MMU &amp;&amp; ! CONFIG_XIP_KERNEL ) &amp;&amp; ( CONFIG_CPU_V7 )    defined in arch/arm/mm/Kconfig    found in Linux kernels: 3.19, 4.0–4.6, 4.6+HEAD    Help text:    If this is set, kernel text and rodata memory will be made read-only, and non-text kernel memory will be made non-executable. The tradeoff is that each region is padded to section-size (1MiB) boundaries (because their permissions are different and splitting the 1M pages into 4K ones causes TLB performance problems), which can waste memory.    arm64    prompt: Make kernel text and rodata read-only    type: bool    depends on: (none)    defined in arch/arm64/Kconfig.debug    found in Linux kernels: 4.0–4.6, 4.6+HEAD    Help text:    If this is set, kernel text and rodata will be made read-only. This is to help catch accidental or malicious attempts to change the kernel's executable code.    If in doubt, say Y</pre> \n<p>Note that despite having “DEBUG” in its name, this is actually recommended for arm64. It should be enabled by default for arm also.</p> \n<p>During kernel boot, in init/main.c, kernel_init() will call mark_rodata_ro() to literally mark every read-only section with proper permissions:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br /></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> __<span class=\"function\">ref <span class=\"title\">kernel_init</span><span class=\"params\">(<span class=\"keyword\">void</span> *unused)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    kernel_init_freeable();</span><br><span class=\"line\">...</span><br><span class=\"line\">    mark_rodata_ro();</span><br><span class=\"line\">...</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>Function mark_rodata_ro() will do nothing if CONFIG_DEBUG_RODATA is not defined:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br /></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> CONFIG_DEBUG_RODATA</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">mark_rodata_ro</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>{ }</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br /></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>If it is defined, though, the implementation of mark_rodata_ro() will be architecture specific, which means you should be looking for its definition in arch/arm and arch/arm64. For both architectures, Linux kernel leverages “section” page entry to improve performance and reduce memory profile of the page table for kernel virtual address space. A “section” page entry usually is one level up than actual page entry (which represents 1 page). Doing so will allow MMU to walk the page table faster by reducing the depth and make TLB more efficient, as there are far fewer entries to be cached. This does come with a cost though, that sections must be aligned at MiB level (1MB or 2MB), which means some physical RAM can be wasted. Of course, this is a minor problem for modern devices as many of them has more than 2GB of RAM.</p> \n<p>You may have noticed that the kernel versions mentioned above are far beyond common versions we seen in Android (3.19+ vs. 3.4/3.10/3.18). However, since the patch is really simple, Google and other vendors actively back-port these features to their own kernel repositories. This also caused some chaos that the actual code varies among different vendors, but eventually they are just doing the same stuff, which sets up the page table entries for kernel virtual address space.</p> \n<p>For arm, a section page entry means a first-level section type PMD (folded up). Per ARM definition, the 2nd bit of the entry indicates whether it is a conventional entry or a section one. Note that super-section is not utilized here.<br><img src=\"http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/1st_lvl_arm32.png\" alt=\"\"><br>Origin: <a href=\"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dai0425/BABCDECH.html\" target=\"_blank\" rel=\"noopener\">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dai0425/BABCDECH.html</a></br></img></br></p> \n<p>The bit AP[2], aka APX, together with AP[1:0], will determine both user and privileged permissions:</p> \n<pre>  APX    AP[1:0]      Privileged    User  0      b00          No access     No access  0      b01          Read/write    No access  0      b10          Read/write    Read-only  0      b11          Read/write    Read/write  1      b00          –             –[ 1      b01          Read-only     No access ]  1      b10          Read-only     Read-only  1      b11          Read-only     Read-only</pre> \n<p>Source: <a href=\"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0211k/Caceaije.html\" target=\"_blank\" rel=\"noopener\">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0211k/Caceaije.html</a><br>So for any kernel text/rodata section, it will be APX:=1 and AP[1:0]:=b01. This is defined in mainline code in arch/arm/mm/init.c:<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_DEBUG_RODATA</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">section_perm</span> <span class=\"title\">ro_perms</span>[] = {</span></span><br><span class=\"line\">       <span class=\"comment\">/* Make kernel code and rodata RX (set RO). */</span></span><br><span class=\"line\">       {</span><br><span class=\"line\">               .start  = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)_stext,</span><br><span class=\"line\"> .end = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)__init_begin,</span><br><span class=\"line\">...</span><br><span class=\"line\"> .mask = ~(PMD_SECT_APX | PMD_SECT_AP_WRITE),</span><br><span class=\"line\"> .prot = PMD_SECT_APX | PMD_SECT_AP_WRITE,</span><br><span class=\"line\"> .clear = PMD_SECT_AP_WRITE,</span><br><span class=\"line\">#endif</span><br><span class=\"line\"> },</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></br></p> \n<p>For arm64, there is a difference that by default it has a 3-level page table. This is for the apparent reason that the virtual address space is much bigger. So for now section (while still being PMD) is now a second-level one. Sometimes it is also called a “block”. The attributes available for a block are:<br><img src=\"http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/figure_d4_19.png\" alt=\"\"><br>Source: <a href=\"http://armv8-ref.codingbelief.com/en/chapter_d4/d43_3_memory_attribute_fields_in_the_vmsav8-64_translation_table_formats_descriptors.html\" target=\"_blank\" rel=\"noopener\">http://armv8-ref.codingbelief.com/en/chapter_d4/d43_3_memory_attribute_fields_in_the_vmsav8-64_translation_table_formats_descriptors.html</a></br></img></br></p> \n<p>It has only two bits for access permissions, noted as AP, and the mapping is simpler than arm:</p> \n<pre>  AP    Unprivileged (EL0)   Privileged (EL1/2/3)  00    No access             Read and write  01    Read and write        Read and write  10    No access             Read-only  11    Read-only             Read-only</pre> \n<p>Source: <a href=\"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABCEADG.html\" target=\"_blank\" rel=\"noopener\">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABCEADG.html</a></p> \n<p>It is quite clear that we need to set AP[1] for read-only. So we have the following code in arch/arm64/mm/mmu.c:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br /></br></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_DEBUG_RODATA</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mark_rodata_ro</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">        create_mapping_late(__pa(_stext), (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)_stext,</span><br><span class=\"line\">                                (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)_etext - (<span class=\"keyword\">unsigned</span> )_stext,</span><br><span class=\"line\"> PAGE_KERNEL_EXEC | PTE_RDONLY);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br /></br></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>One attack against kernel read-only protection is to modify the kernel page table and change the permission of corresponding entries. This requires a bug which may lead to kernel write, controlled bit flip or code execution. Note that Samsung has TrustZone/Hypervisor components which protects the page table, which will be discussed in later sections. Info-leak is not needed in this case since the “template” of kernel page table is a static object determined at link time. The location is assigned to init_mm as its initial value in mm/init-mm.c:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br /></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mm_struct</span> <span class=\"title\">init_mm</span> = {</span></span><br><span class=\"line\">  .mm_rb    = RB_ROOT,</span><br><span class=\"line\">  .pgd    = swapper_pg_dir,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">};</span><br /></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>The value of swapper_pg_dir varies from arch to arch. For both arm and arm64, they are defined in head.S. For arm:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br /></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PG_DIR_SIZE 0x4000  <span class=\"comment\">// aka 4 pages</span></span></span><br><span class=\"line\">  .globl  swapper_pg_dir</span><br><span class=\"line\">  .equ  swapper_pg_dir, KERNEL_RAM_VADDR - PG_DIR_SIZE</span><br /></br></br></pre></td> \n    </tr> \n   </table> \n  </figure><br>And for arm64:<br> \n    <figure class=\"highlight c\"> \n     <table> \n      <tr> \n       <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br /></br></br></br></pre></td> \n       <td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SWAPPER_DIR_SIZE  (3 * PAGE_SIZE)</span></span><br><span class=\"line\">...</span><br><span class=\"line\">  .globl  swapper_pg_dir</span><br><span class=\"line\">  .equ  swapper_pg_dir, KERNEL_RAM_VADDR - SWAPPER_DIR_SIZE</span><br /></br></br></br></pre></td> \n      </tr> \n     </table> \n    </figure></br></br></br></p> \n<p>So for these two architectures, it starts at 4 pages and 3 pages ahead of kernel text prespectively. Kernel text starts relatively at a fixed location for most of the devices (or at least for specific SoCs), so we can predict the beginning of this critical kernel data structure.</p> \n<p>Besides CONFIG_DEBUG_RODATA, PXN is also a very important security feature which has been enabled in recent kernel versions. By the time Android L was released, PXN has been enabled on all arm64 devices. Note that PXN bit also presents in arm32 since ARMv7, but seldomly used.</p> \n<p>PXN on arm64 was introduced into Linux kernel by commit 8e620b0476696e9428442d3551f3dad47df0e28f (<a href=\"https://kernel.googlesource.com/pub/scm/linux/kernel/git/jic23/iio/+/8e620b0476696e9428442d3551f3dad47df0e28f)\" target=\"_blank\" rel=\"noopener\">https://kernel.googlesource.com/pub/scm/linux/kernel/git/jic23/iio/+/8e620b0476696e9428442d3551f3dad47df0e28f)</a>. It basically set PXN bit on every permission templates for user-space, as well as UXN/PXN bits for non-executable pages. This makes sure that every user-space page is mapped with PXN bit set, which mitigates ret2usr attack:</p> \n<pre>    -#define PAGE_NONE        _MOD_PROT(pgprot_default, PTE_NG | PTE_XN | PTE_RDONLY)    -#define PAGE_SHARED        _MOD_PROT(pgprot_default, PTE_USER | PTE_NG | PTE_XN)    ...    -#define PAGE_KERNEL_EXEC    _MOD_PROT(pgprot_default, PTE_DIRTY)    +#define PAGE_NONE        _MOD_PROT(pgprot_default, PTE_NG | PTE_PXN | PTE_UXN | PTE_RDONLY)    +#define PAGE_SHARED        _MOD_PROT(pgprot_default, PTE_USER | PTE_NG | PTE_PXN | PTE_UXN)    +#define PAGE_SHARED_EXEC    _MOD_PROT(pgprot_default, PTE_USER | PTE_NG | PTE_PXN)    ...    +#define PAGE_KERNEL_EXEC    _MOD_PROT(pgprot_default, PTE_UXN | PTE_DIRTY)    -#define __PAGE_NONE        __pgprot(_PAGE_DEFAULT | PTE_NG | PTE_XN | PTE_RDONLY)    -#define __PAGE_SHARED        __pgprot(_PAGE_DEFAULT | PTE_USER | PTE_NG | PTE_XN)    ...    -#define __PAGE_READONLY_EXEC    __pgprot(_PAGE_DEFAULT | PTE_USER | PTE_NG | PTE_RDONLY)    +#define __PAGE_NONE        __pgprot(_PAGE_DEFAULT | PTE_NG | PTE_PXN | PTE_UXN | PTE_RDONLY)    +#define __PAGE_SHARED        __pgprot(_PAGE_DEFAULT | PTE_USER | PTE_NG | PTE_PXN | PTE_UXN)    ...    +#define __PAGE_READONLY_EXEC    __pgprot(_PAGE_DEFAULT | PTE_USER | PTE_NG | PTE_PXN | PTE_RDONLY)</pre> \n<p>Just like those read-only bits, PXN can also be disabled. But keep in mind that PXN bits are set in user virtual address space, which means they are dynamically allocated, so unlike kernel ones, you will need a good kernel read bug to locate the entry to be manipulated. Usually with both read and write, there is really no need of code execution. So this is not very practicable in real exploit.</p> \n<h2 id=\"Vendors\"><a href=\"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/#Vendors\" class=\"headerlink\" title=\"Vendors\"></a>Vendors</h2> \n<p><strong>Samsung</strong><br>Samsung has been a pioneer in terms of Android security hardening for the past years. It was actively involved in enabling SELinux (SEAndroid) for Android, implementing multiple security hardening in kernel and invented the KNOX Active Protection, which is the first TrustZone (TIMA) /Hypervisor based active protection for kernel.</br></p> \n<p>Taking kernel module as an example, since Galaxy S4 (or maybe even earlier), Samsung has implemented lkmauth (loadable kernel module authentication) based on TIMA (TrustZone based Integrity Measurement Architecture). For each kernel module get loaded, getting root privilege is not enough, which the kernel module itself will go through a mandatory digital signature verification happens in TrustZone instead of normal world OS. This means even though an attack can compromise kernel and gain arbitrary read/write, he/she can still not load any kernel module for convenient kernel code execution.</p> \n<p>However, lkmauth still had its weakness, which was pointed out in multiple public sessions, including:</p> \n<ul> \n <li>Advanced Bootkit Techniques on Android, Zhangqi Chen &amp; Di Shen, SyScan360 2014</li> \n <li>Adaptive Android Kernel Live Patching, Tim Xia &amp; Yulong Zhang, HITBSecConf 2016<br>It was pointed out that patching the code of lkmauth() itself can successfully bypass the logic and allow kernel module to be loaded. It’s actually a problem about the trusted computing basee is not really trustworthy (kernel text can be compromised). Samsung has fixed this weakness since Galaxy S5, by introducing TIMA protected page table and read-only kernel text/data into the kernel. It was a surprise that this weakness got mentioned again in the latter session in 2016. Per the slides, the device demonstrated was a Galaxy S4, which may explain why lkmauth() can still be patched.</br></li> \n</ul> \n<p>Besides kernel module authentication, Samsung has enforced KNOX Active Protection (KAP) since 5.1.1 ROMs for Galaxy S6/S6 Edge. This seems to be a reaction to the release of PingPong root. In that version of KAP, Samsung did not only protect the page table, but also put crucial kernel objects like credentials into consideration. For example, a dedicated cache (kmem_cache) is created for credential objects, which all pages assigned to the cache are marked as read-only for kernel. In kernel/cred.c:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> __<span class=\"function\">init <span class=\"title\">cred_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">  <span class=\"comment\">/* allocate a slab in which we can store credentials */</span></span><br><span class=\"line\">  cred_jar = kmem_cache_create(<span class=\"string\">\"cred_jar\"</span>, <span class=\"keyword\">sizeof</span>(struct cred),</span><br><span class=\"line\">             <span class=\"number\">0</span>, SLAB_HWCACHE_ALIGN|SLAB_PANIC, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_RKP_KDP</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span>(rkp_cred_enable) {</span><br><span class=\"line\"> cred_jar_ro = kmem_cache_create(<span class=\"string\">\"cred_jar_ro\"</span>, <span class=\"keyword\">sizeof</span>(struct cred),</span><br><span class=\"line\"> <span class=\"number\">0</span>, SLAB_HWCACHE_ALIGN|SLAB_PANIC, cred_ctor);</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(!cred_jar_ro) {</span><br><span class=\"line\"> panic(<span class=\"string\">\"Unable to create RO Cred cache\\n\"</span>);</span><br><span class=\"line\"> }</span><br><span class=\"line\"></span><br><span class=\"line\"> tsec_jar = kmem_cache_create(<span class=\"string\">\"tsec_jar\"</span>, rkp_get_task_sec_size(),</span><br><span class=\"line\"> <span class=\"number\">0</span>, SLAB_HWCACHE_ALIGN|SLAB_PANIC, sec_ctor);</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(!tsec_jar) {</span><br><span class=\"line\"> panic(<span class=\"string\">\"Unable to create RO security cache\\n\"</span>);</span><br><span class=\"line\"> }</span><br><span class=\"line\"></span><br><span class=\"line\"> rkp_call(RKP_CMDID(<span class=\"number\">0x42</span>),(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> )cred_jar_ro-&gt;size,(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)tsec_jar-&gt;size,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\"> }</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* CONFIG_RKP_KDP */</span></span></span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>The cred_ctor() and sec_ctor() are dummy constructor routines to make sure that the RO cred/security caches are not merged (SLUB merge) with other caches. The cache names are critical here since it has been hard coded in SLUB implementation. In mm/slub.c:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br /></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> check_cred_cache(s,r)     \\</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> {              \\</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((s-&gt;name) &amp;&amp; (!<span class=\"built_in\">strcmp</span>(s-&gt;name,CRED_JAR_RO) || !<span class=\"built_in\">strcmp</span>(s-&gt;name,TSEC_JAR) || !<span class=\"built_in\">strcmp</span>(s-&gt;name,VFSMNT_JAR) )) \\</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;   \\</span><br><span class=\"line\">} <span class=\"keyword\">while</span> (<span class=\"number\">0</span>)</span><br /></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>When the two “_ro” caches are create, the underlying implementation of kmem_cache_create, allocate_slab, is also modified to assign dedicated pages to the read-only caches:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> struct page *<span class=\"title\">allocate_slab</span><span class=\"params\">(struct kmem_cache *s, <span class=\"keyword\">gfp_t</span> flags, <span class=\"keyword\">int</span> node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">page</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kmem_cache_order_objects</span> <span class=\"title\">oo</span> = <span class=\"title\">s</span>-&gt;<span class=\"title\">oo</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_RKP_KDP</span></span><br><span class=\"line\"> <span class=\"keyword\">void</span> *virt_page = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/*CONFIG_RKP_KDP*/</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> CONFIG_RKP_KDP</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (s-&gt;name &amp;&amp;</span><br><span class=\"line\"> (!<span class=\"built_in\">strcmp</span>(s-&gt;name, CRED_JAR_RO) ||</span><br><span class=\"line\"> !<span class=\"built_in\">strcmp</span>(s-&gt;name, TSEC_JAR)||</span><br><span class=\"line\"> !<span class=\"built_in\">strcmp</span>(s-&gt;name, VFSMNT_JAR))) {</span><br><span class=\"line\"></span><br><span class=\"line\"> virt_page = rkp_ro_alloc();</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(!virt_page)</span><br><span class=\"line\"> <span class=\"keyword\">goto</span> def_alloc;</span><br><span class=\"line\"></span><br><span class=\"line\"> page = virt_to_page(virt_page);</span><br><span class=\"line\"> oo = s-&gt;min;</span><br><span class=\"line\"> } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">def_alloc:</span><br><span class=\"line\">#endif <span class=\"comment\">/*CONFIG_RKP_KDP*/</span></span><br><span class=\"line\">...</span><br><span class=\"line\">#ifdef CONFIG_RKP_KDP</span><br><span class=\"line\"> }</span><br><span class=\"line\">#endif <span class=\"comment\">/*CONFIG_RKP_KDP*/</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (kmemcheck_enabled &amp;&amp; page</span><br><span class=\"line\"> &amp;&amp; !(s-&gt;flags &amp; (SLAB_NOTRACK | DEBUG_DEFAULT_FLAGS))) {</span><br><span class=\"line\">...</span><br><span class=\"line\">#ifdef CONFIG_RKP_KDP</span><br><span class=\"line\"> <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * We modify the following so that slab alloc for protected data</span></span><br><span class=\"line\"><span class=\"comment\"> * types are allocated from our own pool.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (s-&gt;name) {</span><br><span class=\"line\"> u64 sc,va_page;</span><br><span class=\"line\"> va_page = (u64)__va(page_to_phys(page));</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span>(!<span class=\"built_in\">strcmp</span>(s-&gt;name, CRED_JAR_RO)){</span><br><span class=\"line\"> <span class=\"keyword\">for</span>(sc = <span class=\"number\">0</span>; sc &lt; (<span class=\"number\">1</span> &lt;&lt; oo_order(oo)) ; sc++) {</span><br><span class=\"line\"> rkp_call(RKP_CMDID(<span class=\"number\">0x50</span>),va_page,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\"> va_page += PAGE_SIZE;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> }</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> }</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> page;</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>With the pages read-only to kernel, any allocation/modification of these objects must be done through calling the hyp component. This helps mitigating conventional DKOM exploit. So far, this is the most efficient mitigation we’ve seen in Android. The best choice of bypassing this might be code-reuse attack, however, can still be further mitigated through validating in tz/hyp.</p> \n<p>Besides these “high-end” mitigations, Samsung also customized some syscalls to restrict post-exploit activities. Taking fork/execve as an example. These two are basically the underlying syscalls behind “system”, a very common routine an exploit will utilize after privilege escalation. So Samsung added some additional check in execve (fs/exec.c):<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\">SYSCALL_DEFINE3(execve,</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *, filename,</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *<span class=\"keyword\">const</span> __user *, argv,</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> __user *<span class=\"keyword\">const</span> __user *, envp)</span><br><span class=\"line\">{</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">filename</span> *<span class=\"title\">path</span> = <span class=\"title\">getname</span>(<span class=\"title\">filename</span>);</span></span><br><span class=\"line\"> <span class=\"keyword\">int</span> error = PTR_ERR(path);</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(CHECK_ROOT_UID(current)){</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(sec_restrict_fork()){</span><br><span class=\"line\"> PRINT_LOG(<span class=\"string\">\"Restricted making process. PID = %d(%s) \"</span></span><br><span class=\"line\"> <span class=\"string\">\"PPID = %d(%s)\\n\"</span>,</span><br><span class=\"line\"> current-&gt;pid, current-&gt;comm,</span><br><span class=\"line\"> current-&gt;parent-&gt;pid, current-&gt;parent-&gt;comm);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> -EACCES;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> }</span><br><span class=\"line\"> ...</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>For any root process, sec_restrict_fork() will check if it is originated from /data. In general, this directory is the only place that an user application can start in. Samsung is hoping that this can stop rooting applications from spawning new process, in most cases a daemon running as root. But since they failed to protect some critical data structures being used inside sec_restrict_fork(), bypassing this check if far easiler than bypassing a tz/hyp assisted protection.</p> \n<p><strong>Others</strong><br>Some mitigations were also seen on other manufacturers of Android devices. Besides system partition write protection, which seems to be the favourite of most vendors, a lot of efforts are also done to prevent devices from being rooted. The most ineffective way we have seen is to setup inotify on certain files, like /system/xbin/su. Simply killing the notifier is going to workaround this. But recently we’ve seen something more interesting from YunOS, a customized Android ROM from Alibaba.</br></p> \n<p>One of the generic route we take for rooting is by modifying the addr_limit of current task’s thread_info structure. This allows the kernel to take the whole virtual address space (or sometimes just enough virtual address space) as “USER_DS” so read/write operation in the address range won’t be restricted for certain syscalls, like pipe_read and pipe_write. In the kernel of YunOS, we noticed the following code in el0_svc_naked:<br><img src=\"http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/yunos_1.png\" alt=\"\" /></br></p> \n<p>The symbol el0_svc_naked is the entry of syscall of Linux on arm64. YunOS added one additional ext_security_pre_check before actually heading into the syscall. Apparently something is checked there. The function looks like this:<br><img src=\"http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/yunos_2.png\" alt=\"\" /></br></p> \n<p>The first basic block extracts addr_limit from current context and check against the standard USER_DS value, 0x8000000000 (1 &lt;&lt; 39). If it is not the desired value, it will enforce a SIGKILL to the calling process. Since SIGKILL can’t be masked, the calling process will be forcibly killed (which may lead to a panic if in the middle of exploit). This is by far the most effective exploit mitigation without tz/hyp assistance. Howevr, it can’t stop the following two scenarios:</p> \n<ul> \n <li>One vulnerabilities or a set of vulnerabilities for direct kernel read/write</li> \n <li>Pure code-reuse attack</li> \n</ul> \n<p>Vulnerabilities leads to direct kernel read/write are quite hard to find now, but the latter one is still achievable. Besides commit_cred, there are still quite some routines can be used conveniently to modify credential of a task. By controlling a certain function entry with 1 or 2 argument would be more than enough.</p>","descriptionType":"html","publishedDate":"Wed, 01 Jun 2016 13:33:23 +0000","feedId":17218,"bgimg":"http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/tz_two_worlds.png","linkMd5":"0b887c99a6b89545c430ffab65a16766","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn92@2020_4/2020/10/20/11-26-19-315_3c3b4820ad8607c6.webp","destWidth":800,"destHeight":317,"sourceBytes":180066,"destBytes":83216,"author":"","articleImgCdnMap":{"http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/tz_two_worlds.png":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn92@2020_4/2020/10/20/11-26-19-315_3c3b4820ad8607c6.webp","http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/1st_lvl_arm32.png":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn96@2020_5/2020/10/20/11-26-25-789_c1469319f31951f6.webp","http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/figure_d4_19.png":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn99@2020_3/2020/10/20/11-26-24-222_42380b5d82f8e82d.webp","http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/yunos_1.png":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn2@2020_5/2020/10/20/11-26-25-499_6cdcf2efd73eada5.webp","http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/yunos_2.png":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn7@2020_5/2020/10/20/11-26-24-796_9b4aa505772e3f6d.webp"},"publishedOrCreatedDate":1603193171669}],"record":{"createdTime":"2020-10-20 19:26:11","updatedTime":"2020-10-20 19:26:11","feedId":17218,"fetchDate":"Tue, 20 Oct 2020 11:26:11 +0000","fetchMs":5035,"handleMs":5515,"totalMs":26886,"newArticles":0,"totalArticles":19,"status":1,"type":0,"ip":"127b947ffb830011589be2c07906fee5","hostName":"us-013*","requestId":"5719b4ac9cca47ea81be2013996075bf_17218","contentType":"text/xml; charset=utf8","totalBytes":210640,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":5,"articlesImgsGithubTotal":5,"successGithubMap":{"myreaderx16":1,"myreaderx12":1,"myreaderx1":1,"myreaderx31":1,"myreaderx18":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:14:36","updatedTime":"2020-09-07 02:47:46","id":17218,"name":"Keen Security Lab Blog","url":"http://keenlab.tencent.com/en/atom.xml","subscriber":194,"website":null,"icon":"http://keenlab.tencent.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"http://keenlab.tencent.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":83216,"tmpBodyImgCdnBytes":127424,"tmpBgImgCdnBytes":0,"extra4":{"start":1603193159786,"total":0,"statList":[{"spend":6368,"msg":"获取xml内容"},{"spend":5515,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":5938,"msg":"正文链接上传到cdn"}]},"extra5":5,"extra6":5,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/_#Vendors":"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/#Vendors","http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/_#Hardware":"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/#Hardware","http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/_#Google-Linux":"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/#Google-Linux","http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/_#Outline":"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/#Outline"},"extra111_proxyServerAndStatMap":{"http://us-006.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-018.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-53.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-019.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/tz_two_worlds.png","sourceStatusCode":200,"destWidth":800,"destHeight":317,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn92@2020_4/2020/10/20/11-26-19-315_3c3b4820ad8607c6.webp","sourceBytes":180066,"destBytes":83216,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":5264,"convertSpendMs":38,"createdTime":"2020-10-20 19:26:15","host":"europe65*","referer":"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/","linkMd5ListStr":"0b887c99a6b89545c430ffab65a16766,0b887c99a6b89545c430ffab65a16766","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"175.8 KB","destSize":"81.3 KB","compressRate":"46.2%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/figure_d4_19.png","sourceStatusCode":200,"destWidth":992,"destHeight":365,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn99@2020_3/2020/10/20/11-26-24-222_42380b5d82f8e82d.webp","sourceBytes":63197,"destBytes":32076,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":4297,"convertSpendMs":21,"createdTime":"2020-10-20 19:26:20","host":"us-018*","referer":"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/","linkMd5ListStr":"0b887c99a6b89545c430ffab65a16766","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"61.7 KB","destSize":"31.3 KB","compressRate":"50.8%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/yunos_2.png","sourceStatusCode":200,"destWidth":549,"destHeight":871,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn7@2020_5/2020/10/20/11-26-24-796_9b4aa505772e3f6d.webp","sourceBytes":82907,"destBytes":41458,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":4959,"convertSpendMs":26,"createdTime":"2020-10-20 19:26:20","host":"us-006*","referer":"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/","linkMd5ListStr":"0b887c99a6b89545c430ffab65a16766","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"81 KB","destSize":"40.5 KB","compressRate":"50%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/yunos_1.png","sourceStatusCode":200,"destWidth":341,"destHeight":622,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn2@2020_5/2020/10/20/11-26-25-499_6cdcf2efd73eada5.webp","sourceBytes":50341,"destBytes":26968,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":5624,"convertSpendMs":96,"createdTime":"2020-10-20 19:26:20","host":"us-019*","referer":"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/","linkMd5ListStr":"0b887c99a6b89545c430ffab65a16766","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"49.2 KB","destSize":"26.3 KB","compressRate":"53.6%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Emerging-Defense-in-Android-Kernel/1st_lvl_arm32.png","sourceStatusCode":200,"destWidth":623,"destHeight":465,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn96@2020_5/2020/10/20/11-26-25-789_c1469319f31951f6.webp","sourceBytes":30419,"destBytes":26922,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":3912,"convertSpendMs":15,"createdTime":"2020-10-20 19:26:22","host":"us-53*","referer":"http://keenlab.tencent.com/2016/06/01/Emerging-Defense-in-Android-Kernel/","linkMd5ListStr":"0b887c99a6b89545c430ffab65a16766","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"29.7 KB","destSize":"26.3 KB","compressRate":"88.5%"}],"successGithubMap":{"myreaderx16":1,"myreaderx12":1,"myreaderx1":1,"myreaderx31":1,"myreaderx18":1},"failGithubMap":{}}