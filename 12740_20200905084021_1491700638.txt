{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-09-05 16:40:03","updatedTime":"2020-09-05 16:40:03","title":"Go Dumpling！让导出数据更容易","link":"https://juejin.im/post/6868156733383147527","description":"<div class=\"markdown-body\"><p><strong>作者介绍：李淳竹（lichunzhu），TiDB 研发工程师。</strong></p>\n<p><strong>Tools SIG Community</strong>：主要涵盖 TiDB 数据处理工具，包含 TiDB 数据备份/导入导出，TiDB 数据变更捕获，其他数据库数据迁移至 TiDB 等。</p>\n<p><a href=\"https://github.com/pingcap/dumpling\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><em>Dumpling</em></a> 是由 Go 语言编写的用于对数据库进行数据导出的工具。目前支持 MySQL 协议的数据库，并且针对 TiDB 的特性进行了优化。Dumpling 的主要特点包括：</p>\n<p><strong>1. 适配 Mydumper，轻松上手。</strong></p>\n<p><strong>2. Go 语言编写，定制开发简单。</strong></p>\n<ul>\n<li>\n<p>自定义导出过滤条件；</p>\n</li>\n<li>\n<p>多种导出格式。目前支持 SQL、CSV 格式的导出；</p>\n</li>\n<li>\n<p>多种目标源。目前支持本地盘，S3/GCS 正在开发中；</p>\n</li>\n<li>\n<p>未来计划支持导出多种数据库源。</p>\n</li>\n</ul>\n<h2 data-id=\"heading-0\">Go 语言支持</h2>\n<p>给 Mydumper 贡献代码没有那么容易。主要原因如下：</p>\n<ol>\n<li>\n<p>Mydumper 由 C 编写，相比起来编译与准备环境要更为复杂。</p>\n</li>\n<li>\n<p>Mydumper 调试不太方便，这也不利于在发现问题后查错。</p>\n</li>\n<li>\n<p>C 语言更难做抽象化，定制化功能困难。</p>\n</li>\n<li>\n<p>Mydumper repo 没有单元测试与集成测试，只能手动验证功能是否正确。</p>\n</li>\n</ol>\n<p><strong><em>而 Dumpling 由 Go 语言实现，非常易于维护。</em></strong> Go 生态有非常丰富的扩展包，这使得在 Dumpling 上实现添加新功能更加容易。同时 Go 语言方便的包管理系统与调试机制也更方便用户编译自己定制化的 Dumpling binary 并且调试功能，Dumpling 的单元测试与集成测试与 Go 简单的测试编写机制也可以帮助用户更容易地验证功能是否正确。</p>\n<h2 data-id=\"heading-1\">Mydumper 参数适配</h2>\n<p><strong>Dumpling 适配了 Mydumper 的常用参数，这使得 Mydumper 用户迁移到 Dumpling 的学习成本非常低。</strong> 同时 Dumpling 还对其中部分参数进行了改善，比如：</p>\n<ul>\n<li>\n<p>-B 参数支持了导出多个数据库，而 Mydumper 只支持指定一个数据库。</p>\n</li>\n<li>\n<p>将 Mydumper -x 参数改为用 table-filter -f 参数，原先要筛选库表用户必须手写规则为一条复杂的正则表达式，而 table-filter 类似 .gitignore 语法，更容易筛选库表。</p>\n</li>\n</ul>\n<p>更多 Dumpling 参数的详细使用可以阅读 <a href=\"https://docs.pingcap.com/zh/tidb/stable/dumpling-overview#dumpling-%E4%B8%BB%E8%A6%81%E9%80%89%E9%A1%B9%E8%A1%A8\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Dumpling 参数表</a>。如果是暂时没有支持的 Mydumper 参数或者有想到方便实用的参数，也欢迎大家在Dumpling Repo中提出 PR 或者 issue。此外 Go 语言新增参数功能非常容易，这也是大家参与开发开源项目一个很好的切入点。</p>\n<h2 data-id=\"heading-2\">CSV 导出定制</h2>\n<p>Dumpling 支持通过制定 filetype = xx 导出 csv 文件，通过配置相关的参数也可以定制化 csv 的输出格式，例如：</p>\n<ul>\n<li>\n<p>使用 <code>csv-null-value</code> 指定 csv 中空值的表示</p>\n</li>\n<li>\n<p>使用 <code>csv-seperator</code> 指定 csv 中各列数据的分隔符</p>\n</li>\n</ul>\n<p>详细配置说明参考<a href=\"https://docs.pingcap.com/zh/tidb/stable/table-filter\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">使用文档</a>。</p>\n<h2 data-id=\"heading-3\">作为 Library 被集成</h2>\n<p>Dumpling 支持作为 Library 被其他包所集成。Go 应用开发者可以在定义好导出配置文件 export.Config 后运行 export.Dump 函数即可。这也使得开发者可以在不需要调用外部工具，不需要额外编写代码的情况下实现数据库逻辑导出功能的集成。TiDB-DM 项目正是采用这种方式集成了 Dumpling。</p>\n<h2 data-id=\"heading-4\">性能对比</h2>\n<p>为了比较 Dumpling 和 Mydumper 的性能差异，我们在一台 2 物理 CPU (Intel(R) Xeon(R) CPU E5-2630 v4 @ 2.20GHz) 的机器上进行了导出测试，导出单个数据量大小为 87G，约 20 亿行的大表。测试了五种导出参数下的导出耗时与消耗系统资源情况，包括：</p>\n<ul>\n<li>\n<p>mydumper: 单线程，使用 -F 256MB 参数；</p>\n</li>\n<li>\n<p>dumpling: 单线程，使用 -F 256MB 参数；</p>\n</li>\n<li>\n<p>mydumper 8 线程：八线程，使用 -t 8 -r 500000 参数开启表内并发；</p>\n</li>\n<li>\n<p>dumpling 8 线程：八线程，使用 -t 8 -r 500000 参数开启表内并发。</p>\n</li>\n</ul>\n<p></p><figure><img class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09faf6f4b00e4c80b3170fbacbed3eee~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"><figcaption></figcaption></figure>\n<figure><img class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc1313b88a3540bc9ffc32e500508e6c~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"><figcaption></figcaption></figure><p></p>\n<p>可以看出目前 Dumpling 实验分支的 Dumpling 时间可以达到 Mydumper 的水平。值得注意的是，<strong>相比起 Mydumper，Go 语言的 profile 功能也使得我们更加容易排查和优化 Dumpling 的性能问题</strong>。我们也将在后续持续改进 Dumpling 的性能问题，提高导出速度。</p>\n<h2 data-id=\"heading-5\">Dumpling 后续开发计划</h2>\n<p>以下为 Dumpling 后续开发的一些计划与设想，也欢迎大家在 Dumpling Repo 一起交流讨论，参与开发。让我们一起让导出数据更加容易！</p>\n<p> <strong>支持并行导出主键分布不均匀的数据(issue#75)</strong></p>\n<p>目前 Mydumper 和 Dumpling 都可以通过指定 rows 参数开启表内并发，从而优化导出单个大数据表时的导出效率。它们的划分方式都是将表按照表的整数主键的从最小到最大划分为 count/rows 个区块再导出，然而这样的方式在数据的主键比较分散时导出效果会很差。尤其是 TiDB 4.0 后，开启了 auto-random 的数据表的主键将会更加离散，这势必引起数据块分布不均匀从而影响导出效率。</p>\n<p>Dumpling 可以在开启 chunk-by-region 选项后，通过 TiDB regions 的数据信息来按照 region 划分导出数据的区块，从而使数据块中数据分布更加均匀，进而提高导出的效率。该优化目前已有 PR。</p>\n<p><strong>支持导出到 S3、GCS 等云盘(issue#8)</strong></p>\n<p>Dumpling 计划在 TiDB 5.0 前支持直接导出数据到云盘，从而方便云上部署使用。</p>\n<p><strong>支持导出更多种类的源数据库(issue#11)</strong></p>\n<p>一般来说，只要需要支持的数据库有对应的 database driver 或 client，比如 Oracle 数据库的 golang driver godror，我们都可以轻微改造导出语句和调用的 Go 代码库后就实现该数据库的导出支持。这里也欢迎社区的小伙伴们参与，帮助 Dumpling 支持导出更多类型的数据库。</p>\n<p> <strong>欢迎通过 Slack 联系我们</strong>： <a href=\"https://slack.tidb.io/invite?team=tidb-community&channel=sig-tools&ref=pingcap-community\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">channel #sig-tools in the tidbcommunity slack workspace, you can join this   channel through this invitation link</a>。</p></div> <div class=\"image-viewer-box\" data-v-78c9b824><!----></div>","descriptionType":"text/html","publishedDate":"Wed, 02 Sep 2020 23:17:18 +0000","feedId":12740,"bgimg":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09faf6f4b00e4c80b3170fbacbed3eee~tplv-k3u1fbpfcp-zoom-1.image","linkMd5":"863f5db43d00ce6fa8bbb75c1a0de5ee","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn16@2020_2/2020/09/05/08-40-03-764_1474814b53265c7f.webp","destWidth":902,"destHeight":558,"sourceBytes":34370,"destBytes":13610,"author":"PingCAP","articleImgCdnMap":{"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09faf6f4b00e4c80b3170fbacbed3eee~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn16@2020_2/2020/09/05/08-40-03-764_1474814b53265c7f.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc1313b88a3540bc9ffc32e500508e6c~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn43@2020_2/2020/09/05/08-40-12-157_b468351814fcd131.webp"},"publishedOrCreatedDate":1599295203161},{"createdTime":"2020-09-05 16:40:03","updatedTime":"2020-09-05 16:40:03","title":"模块化、CommonJS 规范和 ES6 模块规范以及简单手写 CommonJS 的 require","link":"https://juejin.im/post/6868225991165083661","description":"<div class=\"markdown-body\"><h2 data-id=\"heading-0\">无模块化</h2>\n<p>简单的将所有的 js 文件统统放在一起，然后通过 <code><script></code> 标签引入。</p>\n<ul>\n<li>优点：<ul>\n<li>相比于使用一个js文件，这种多个js文件实现最简单的模块化的思想是进步的。　</li>\n</ul></li>\n<li>缺点：<ul>\n<li>污染全局作用域。因为每一个模块都是暴露在全局的，简单的使用，会导致全局变量命名冲突，当然，我们也可以使用命名空间的方式来解决。</li>\n<li>对于大型项目，各种js很多，开发人员必须手动解决模块和代码库的依赖关系，后期维护成本较高。</li>\n<li>依赖关系不明显，不利于维护。 比如 main.js 需要使用 jquery，但是，从上面的文件中，我们是看不出来的，如果 jquery 忘记了，那么就会报错。</li>\n</ul></li>\n</ul>\n<pre><code class=\"hljs language-html copyable\" lang=\"html\">  <span class=\"hljs-comment\"><!-- 页面内嵌的脚本 --></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"application/javascript\"</span>></span><span class=\"javascript\">\n  <span class=\"hljs-comment\">// module code</span>\n  </span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n\n  <span class=\"hljs-comment\"><!-- 外部脚本 --></span>\n  <span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"application/javascript\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"path/to/myModule.js\"</span>></span>\n  <span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此 type=\"application/javascript\" 可以省略。</p>\n</blockquote>\n<ul>\n<li>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到 <code><script></code> 标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。</li>\n<li>浏览器允许脚本异步加载，下面就是两种异步加载的语法。</li>\n</ul>\n<pre><code class=\"hljs language-html copyable\" lang=\"html\">    <span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"path/to/myModule.js\"</span> <span class=\"hljs-attr\">defer</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"path/to/myModule.js\"</span> <span class=\"hljs-attr\">async</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>上面代码中，<code><script></code> 标签打开 defer 或 async 属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p>\n</blockquote>\n<ul>\n<li>defer 与 async 的区别是：<ul>\n<li>defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行</li>\n<li>async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染</li>\n<li>一句话，defer 是 “渲染完再执行”，async 是 “下载完就执行”</li>\n<li>如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的</li>\n</ul></li>\n</ul>\n<h2 data-id=\"heading-1\">CommonJS 规范</h2>\n<h4 data-id=\"heading-2\">1. 概述</h4>\n<ul>\n<li>是一个 JavaScript 模块化的规范， <code>Nodejs</code> 环境所使用的模块系统就是基于 <code>CommonJS</code> 规范实现的，我们现在所说的 <code>CommonJS</code> 规范也大多是指 Node 的模块系统，前端的 webpack 也是对 CommonJS 原生支持。</li>\n<li>CommonJS 规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。</li>\n<li>有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。实际使用时，用 <code>module.exports</code> 定义当前模块对外输出的接口（不推荐直接用 exports ），用 <code>require</code> 加载模块。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">    <span class=\"hljs-comment\">// example.js</span>\n    <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">var</span> addX = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> value + x;\n    };\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>上面代码中，变量 x 和函数 addX，是当前文件 example.js 私有的，其他文件不可见。</p>\n</blockquote>\n<ul>\n<li>如果想在多个文件分享变量，必须定义为 <code>global</code> 对象的属性。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">    <span class=\"hljs-built_in\">global</span>.warning = <span class=\"hljs-literal\">true</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>上面代码的 warning 变量，可以被所有文件读取。当然，这样写法是不推荐的。</p>\n</blockquote>\n<ul>\n<li>CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">    <span class=\"hljs-comment\">// example.js</span>\n    <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">var</span> addX = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> value + x;\n    };\n    <span class=\"hljs-built_in\">module</span>.exports = {\n        <span class=\"hljs-attr\">x</span>: x,\n        <span class=\"hljs-attr\">addX</span>: addX\n    };\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>上面代码通过 module.exports 输出变量 x 和函数 addX。</p>\n</blockquote>\n<ul>\n<li><code>require</code> 方法用于加载模块</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">    <span class=\"hljs-keyword\">var</span> example = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./example.js'</span>);\n\n    <span class=\"hljs-built_in\">console</span>.log(example.x); <span class=\"hljs-comment\">// 5</span>\n    <span class=\"hljs-built_in\">console</span>.log(example.addX(<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// 6</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>\n<p>CommonJS 规范特点</p>\n<ul>\n<li>所有代码都运行在模块作用域，不会污染全局作用域</li>\n<li>CommonJS 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存</li>\n<li>CommonJS 模块加载的顺序，按照其在代码中出现的顺序</li>\n<li>由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用</li>\n</ul>\n</li>\n<li>\n<p>优点：</p>\n<ul>\n<li>CommonJS 规范在服务器端率先完成了 JavaScript 的模块化，解决了依赖、全局变量污染的问题，这也是 js 运行在服务器端的必要条件。</li>\n</ul>\n</li>\n<li>\n<p>缺点：</p>\n<ul>\n<li>由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS 是不适用于浏览器端的。</li>\n</ul>\n</li>\n</ul>\n<h4 data-id=\"heading-3\">2. module 对象</h4>\n<ul>\n<li>Node 内部提供一个 Module 构建函数。所有模块都是 Module 的实例。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Module</span>(<span class=\"hljs-params\">id, parent</span>) </span>{\n    <span class=\"hljs-built_in\">this</span>.id = id;\n    <span class=\"hljs-built_in\">this</span>.exports = {};\n    <span class=\"hljs-built_in\">this</span>.parent = parent;\n    <span class=\"hljs-comment\">// ...</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>每个模块内部，都有一个 module 对象，代表当前模块。它有以下属性。</li>\n</ul>\n<pre><code class=\"copyable\">  module.id 模块的识别符，通常是带有绝对路径的模块文件名。\n  module.filename 模块的文件名，带有绝对路径。\n  module.loaded 返回一个布尔值，表示模块是否已经完成加载。\n  module.parent 返回一个对象，表示调用该模块的模块。\n  module.children 返回一个数组，表示该模块要用到的其他模块。\n  module.exports 表示模块对外输出的值。\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>如果在命令行下调用某个模块，比如 node something.js ，那么 module.parent 就是 null 。如果是在脚本之中调用，比如 require('./something.js') ，那么 module.parent 就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">module</span>.parent) {\n    <span class=\"hljs-comment\">// ran with `node something.js`</span>\n    app.listen(<span class=\"hljs-number\">8088</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'app listening on port 8088'</span>);\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// used with `require('/.something.js')`</span>\n    <span class=\"hljs-built_in\">module</span>.exports = app;\n  }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>module.exports 属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取 module.exports 变量。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-keyword\">var</span> EventEmitter = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'events'</span>).EventEmitter;\n  <span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-keyword\">new</span> EventEmitter();\n\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-built_in\">module</span>.exports.emit(<span class=\"hljs-string\">'ready'</span>);\n  }, <span class=\"hljs-number\">1000</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>上面模块会在加载后1秒后，发出 ready 事件。其他文件监听该事件，可以写成下面这样。</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./a'</span>);\n  a.on(<span class=\"hljs-string\">'ready'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'module a is ready'</span>);\n  });\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 data-id=\"heading-4\">3. exports 变量</h4>\n<ul>\n<li>为了方便，Node 为每个模块提供一个 exports 变量，指向 module.exports。这等同在每个模块头部，有一行这样的命令。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-keyword\">var</span> <span class=\"hljs-built_in\">exports</span> = <span class=\"hljs-built_in\">module</span>.exports;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-built_in\">exports</span>.area = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">r</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.PI * r * r;\n  };\n\n  <span class=\"hljs-built_in\">exports</span>.circumference = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">r</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span> * <span class=\"hljs-built_in\">Math</span>.PI * r;\n  };\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>注意，不能直接将 exports 变量指向一个值，因为这样等于切断了 exports 与 module.exports 的联系。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-built_in\">exports</span>.hello = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'hello'</span>;\n  };\n\n  <span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-string\">'Hello world'</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>上面代码中，hello 函数是无法对外输出的，因为 module.exports 被重新赋值了</p>\n</blockquote>\n<ul>\n<li>这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用 exports 输出，只能使用 module.exports 输出,如下。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x</span>) </span>{ <span class=\"hljs-built_in\">console</span>.log(x); };\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 data-id=\"heading-5\">4. require 命令</h4>\n<h6 data-id=\"heading-6\">4.1 基本用法</h6>\n<p>Node 使用 CommonJS 模块规范，内置的 require 命令用于加载模块文件</p>\n<ul>\n<li>require 命令的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。如果没有发现指定模块，会报错。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-comment\">// example.js</span>\n  <span class=\"hljs-keyword\">var</span> invisible = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"invisible\"</span>);\n  }\n\n  <span class=\"hljs-built_in\">exports</span>.message = <span class=\"hljs-string\">\"hi\"</span>;\n\n  <span class=\"hljs-built_in\">exports</span>.say = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(message);\n  }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>运行以下命令输出 exports 对象</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-keyword\">var</span> example = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./example.js'</span>);\n  example\n  <span class=\"hljs-comment\">// {</span>\n  <span class=\"hljs-comment\">//   message: \"hi\",</span>\n  <span class=\"hljs-comment\">//   say: [Function]</span>\n  <span class=\"hljs-comment\">// }</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>如果模块输出的是一个函数，那就不能定义在 exports 对象上面，而要定义在 module.exports 变量上面。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"hello world\"</span>);\n  };\n\n  <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./example2.js'</span>)();\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h6 data-id=\"heading-7\">4.2 加载规则</h6>\n<ul>\n<li>require 命令用于加载文件，后缀名默认为 .js。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'foo'</span>);\n  <span class=\"hljs-comment\">//  等同于</span>\n  <span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'foo.js'</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>根据参数的不同格式，require命令去不同路径寻找模块文件。<ul>\n<li>（1）如果参数字符串以 <code>/</code> 开头，则表示加载的是一个位于绝对路径的模块文件。比如，require('/home/marco/foo.js') 将加载 /home/marco/foo.js。</li>\n<li>（2）如果参数字符串以 <code>./</code> 开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require('./circle') 将加载当前脚本同一目录的 circle.js。</li>\n<li>（3）如果参数字符串不以 <code>./</code> 或 <code>/</code> 开头，则表示加载的是一个默认提供的核心模块（<code>位于 Node 的系统安装目录中</code>），<code>或者一个位于各级 node_modules 目录的已安装模块</code>（全局安装或局部安装）。  </li>\n</ul></li>\n<li>举例来说，脚本 /home/user/projects/foo.js 执行了 require('bar.js') 命令，Node 会依次搜索以下文件。<ul>\n<li>（4）如果参数字符串不以 <code>./</code> 或 <code>/</code> 开头，而且是一个路径，比如 require('example-module/path/to/file')，则将先找到 example-module 的位置，然后再以它为参数，找到后续路径。</li>\n<li>（5）如果指定的模块文件没有发现，Node 会尝试为文件名添加 .js 、 .json 、 .node 后，再去搜索。 .js 件会以文本格式的 JavaScript 脚本文件解析， .json 文件会以 JSON 格式的文本文件解析， .node 文件会以编译后的二进制文件解析。</li>\n<li>（6）如果想得到 require 命令加载的确切文件名，使用 require.resolve() 方法。</li>\n</ul></li>\n</ul>\n<pre><code class=\"copyable\">  /usr/local/lib/node/bar.js\n  /home/user/projects/node_modules/bar.js\n  /home/user/node_modules/bar.js\n  /home/node_modules/bar.js\n  /node_modules/bar.js\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>这样设计的目的是，使得不同的模块可以将所依赖的模块本地化</p>\n</blockquote>\n<h6 data-id=\"heading-8\">4.3 目录的加载规则</h6>\n<ul>\n<li>通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让 require 方法可以通过这个入口文件，加载整个目录。</li>\n</ul>\n<blockquote>\n<p>在目录中放置一个 package.json 文件，并且将入口文件写入 main 字段。下面是一个例子。</p>\n</blockquote>\n<pre><code class=\"hljs language-json copyable\" lang=\"json\">  <span class=\"hljs-comment\">// package.json</span>\n  { \n    <span class=\"hljs-attr\">\"name\"</span> : <span class=\"hljs-string\">\"some-library\"</span>,\n    <span class=\"hljs-attr\">\"main\"</span> : <span class=\"hljs-string\">\"./lib/some-library.js\"</span>\n  }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>require 发现参数字符串指向一个目录以后，会自动查看该目录的 package.json 文件，然后加载 main 字段指定的入口文件。如果 package.json 文件没有 main 字段，或者根本就没有 package.json 文件，则会加载该目录下的 index.js 文件或 index.node 文件。 </li>\n</ul>\n<h6 data-id=\"heading-9\">4.4 模块的缓存</h6>\n<ul>\n<li>\n<p>第一次加载某个模块时，Node 会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的 module.exports 属性。</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"> <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./example.js'</span>);\n <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./example.js'</span>).message = <span class=\"hljs-string\">\"hello\"</span>;\n <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./example.js'</span>).message\n <span class=\"hljs-comment\">// \"hello\"</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n</li>\n</ul>\n<blockquote>\n<p>上面代码中，连续三次使用 require 命令，加载同一个模块。第二次加载的时候，为输出的对象添加了一个 message 属性。但是第三次加载的时候，这个 message 属性依然存在，这就证明 require 命令并没有重新加载模块文件，而是输出了缓存。</p>\n</blockquote>\n<ul>\n<li>如果想要多次执行某个模块，可以让该模块输出一个函数，然后每次 require 这个模块的时候，重新执行一下输出的函数。</li>\n</ul>\n<blockquote>\n<p>所有缓存的模块保存在 require.cache 之中，如果想删除模块的缓存，可以像下面这样写。</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-comment\">// 删除指定模块的缓存</span>\n  <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-built_in\">require</span>.cache[moduleName];\n\n  <span class=\"hljs-comment\">// 删除所有模块的缓存</span>\n  <span class=\"hljs-built_in\">Object</span>.keys(<span class=\"hljs-built_in\">require</span>.cache).forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key</span>) </span>{\n    <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-built_in\">require</span>.cache[key];\n  });\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，require 命令还是会重新加载该模块。</li>\n</ul>\n<h4 data-id=\"heading-10\">5. 环境变量 NODE_PATH</h4>\n<ul>\n<li>Node 执行一个脚本时，会先查看环境变量 NODE_PATH。它是一组以冒号分隔的绝对路径。在其他位置找不到指定模块时，Node 会去这些路径查找。</li>\n</ul>\n<blockquote>\n<p>可以将 NODE_PATH 添加到 .bashrc。</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-keyword\">export</span> NODE_PATH=<span class=\"hljs-string\">\"/usr/local/lib/node\"</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>所以，如果遇到复杂的相对路径，比如下面这样。</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-keyword\">var</span> myModule = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../../../../lib/myModule'</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>有两种解决方法，一是将该文件加入 node_modules 目录，二是修改 NODE_PATH 环境变量，package.json 文件可以采用下面的写法。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  {\n    <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"node_path\"</span>,\n    <span class=\"hljs-string\">\"version\"</span>: <span class=\"hljs-string\">\"1.0.0\"</span>,\n    <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"\"</span>,\n    <span class=\"hljs-string\">\"main\"</span>: <span class=\"hljs-string\">\"index.js\"</span>,\n    <span class=\"hljs-string\">\"scripts\"</span>: {\n      <span class=\"hljs-string\">\"start\"</span>: <span class=\"hljs-string\">\"NODE_PATH=lib node index.js\"</span>\n    },\n    <span class=\"hljs-string\">\"author\"</span>: <span class=\"hljs-string\">\"\"</span>,\n    <span class=\"hljs-string\">\"license\"</span>: <span class=\"hljs-string\">\"ISC\"</span>\n  }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>NODE_PATH 是历史遗留下来的一个路径解决方案，通常不应该使用，而应该使用 node_modules 目录机制。</li>\n</ul>\n<h6 data-id=\"heading-11\">4.6 模块的循环加载</h6>\n<ul>\n<li>如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-comment\">// a.js</span>\n  <span class=\"hljs-built_in\">exports</span>.x = <span class=\"hljs-string\">'a1'</span>;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'a.js '</span>, <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./b.js'</span>).x);\n  <span class=\"hljs-built_in\">exports</span>.x = <span class=\"hljs-string\">'a2'</span>;\n\n  <span class=\"hljs-comment\">// b.js</span>\n  <span class=\"hljs-built_in\">exports</span>.x = <span class=\"hljs-string\">'b1'</span>;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'b.js '</span>, <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./a.js'</span>).x);\n  <span class=\"hljs-built_in\">exports</span>.x = <span class=\"hljs-string\">'b2'</span>;\n\n  <span class=\"hljs-comment\">// main.js</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'main.js '</span>, <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./a.js'</span>).x);\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'main.js '</span>, <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./b.js'</span>).x);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>上面代码是三个 JavaScript 文件。其中，a.js 加载了 b.js，而 b.js 又加载 a.js。这时， Node 返回 a.js 的不完整版本，所以执行结果如下。</p>\n</blockquote>\n<pre><code class=\"hljs language-bash copyable\" lang=\"bash\">  $ node main.js\n  b.js  a1\n  a.js  b2\n  main.js  a2\n  main.js  b2\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>修改 main.js，再次加载 a.js 和 b.js。</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">    <span class=\"hljs-comment\">// main.js</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'main.js '</span>, <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./a.js'</span>).x);\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'main.js '</span>, <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./b.js'</span>).x);\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'main.js '</span>, <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./a.js'</span>).x);\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'main.js '</span>, <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./b.js'</span>).x);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>执行上面代码</p>\n</blockquote>\n<pre><code class=\"copyable\">  $ node main.js\n  b.js  a1\n  a.js  b2\n  main.js  a2\n  main.js  b2\n  main.js  a2\n  main.js  b2\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>上面代码中，第二次加载 a.js 和 b.js 时，会直接从缓存读取 exports 属性，所以 a.js 和 b.js 内部的 console.log 语句都不会执行了。</li>\n</ul>\n<h6 data-id=\"heading-12\">4.7 require.main</h6>\n<ul>\n<li>require 方法有一个 main 属性，可以用来判断模块是直接执行，还是被调用执行。</li>\n</ul>\n<blockquote>\n<p>直接执行的时候（node module.js），require.main 属性指向模块本身。</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">    <span class=\"hljs-built_in\">require</span>.main === <span class=\"hljs-built_in\">module</span>\n    <span class=\"hljs-comment\">// true</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>调用执行的时候（通过 require 加载该脚本执行），上面的表达式返回 false 。</p>\n</blockquote>\n<h4 data-id=\"heading-13\">5. 模块的加载机制</h4>\n<ul>\n<li>CommonJS 模块输出的是一个值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值</li>\n<li>CommonJS 模块是运行时加载，加载的是一个对象（即 <code>module.exports</code> 属性），该对象只有在脚本运行完才会生成</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-comment\">// lib.js</span>\n  <span class=\"hljs-keyword\">var</span> counter = <span class=\"hljs-number\">3</span>;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incCounter</span>(<span class=\"hljs-params\"></span>) </span>{\n    counter++;\n  }\n  <span class=\"hljs-built_in\">module</span>.exports = {\n    <span class=\"hljs-attr\">counter</span>: counter,\n    <span class=\"hljs-attr\">incCounter</span>: incCounter,\n  };\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>上面代码输出内部变量 counter 和改写这个变量的内部方法 incCounter。然后，在 main.js 里面加载这个模块。</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-comment\">// main.js</span>\n  <span class=\"hljs-keyword\">var</span> com = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./lib'</span>)\n\n  <span class=\"hljs-built_in\">console</span>.log(com.counter) <span class=\"hljs-comment\">// 3</span>\n  com.incCounter()\n  <span class=\"hljs-built_in\">console</span>.log(com.counter) <span class=\"hljs-comment\">// 3</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>上面代码说明，<code>lib.js</code> 模块加载以后，它的内部变化就影响不到输出的 <code>com.counter</code> 了。这是因为 <code>com.counter</code> 是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-comment\">// lib.js</span>\n  <span class=\"hljs-keyword\">var</span> counter = <span class=\"hljs-number\">3</span>;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incCounter</span>(<span class=\"hljs-params\"></span>) </span>{\n    counter++;\n  }\n  <span class=\"hljs-built_in\">module</span>.exports = {\n    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title\">counter</span>() {\n      <span class=\"hljs-keyword\">return</span> counter\n    },\n    <span class=\"hljs-attr\">incCounter</span>: incCounter,\n  };\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>上面代码中，输出的 counter 属性实际上是一个取值器函数。现在再执行 main.js ，就可以正确读取内部变量 counter 的变动了。</p>\n</blockquote>\n<pre><code class=\"hljs language-bash copyable\" lang=\"bash\">  $ node main.js\n  3\n  4\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h6 data-id=\"heading-14\">5.1 require 的内部处理流程</h6>\n<ul>\n<li>require 命令是 CommonJS 规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的 module.require 命令，而后者又调用 Node 的内部命令 Module._load 。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  Module._load = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">request, parent, isMain</span>) </span>{\n    <span class=\"hljs-comment\">// 1. 检查 Module._cache，是否缓存之中有指定模块</span>\n    <span class=\"hljs-comment\">// 2. 如果缓存之中没有，就创建一个新的Module实例</span>\n    <span class=\"hljs-comment\">// 3. 将它保存到缓存</span>\n    <span class=\"hljs-comment\">// 4. 使用 module.load() 加载指定的模块文件，</span>\n    <span class=\"hljs-comment\">//    读取文件内容之后，使用 module.compile() 执行文件代码</span>\n    <span class=\"hljs-comment\">// 5. 如果加载/解析过程报错，就从缓存删除该模块</span>\n    <span class=\"hljs-comment\">// 6. 返回该模块的 module.exports</span>\n  };\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>上面的第 4 步，采用 module.compile() 执行指定模块的脚本，逻辑如下。</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  Module.prototype._compile = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">content, filename</span>) </span>{\n    <span class=\"hljs-comment\">// 1. 生成一个require函数，指向module.require</span>\n    <span class=\"hljs-comment\">// 2. 加载其他辅助方法到require</span>\n    <span class=\"hljs-comment\">// 3. 将文件内容放到一个函数之中，该函数可调用 require</span>\n    <span class=\"hljs-comment\">// 4. 执行该函数</span>\n  };\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>上面的第 1 步和第 2 步， require 函数及其辅助方法主要如下。</p>\n</blockquote>\n<pre><code class=\"copyable\">  require(): 加载外部模块\n  require.resolve()：将模块名解析到一个绝对路径\n  require.main：指向主模块\n  require.cache：指向所有缓存的模块\n  require.extensions：根据文件的后缀名，调用不同的执行函数\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>一旦 require 函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括 require、module、exports ，以及其他一些参数。</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">exports, require, module, __filename, __dirname</span>) </span>{\n    <span class=\"hljs-comment\">// YOUR CODE INJECTED HERE!</span>\n  });\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>Module._compile 方法是同步执行的，所以 Module._load 要等它执行完成，才会向用户返回 module.exports 的值</li>\n</ul>\n<h2 data-id=\"heading-15\">CommonJS 规范 require 方法简单实现</h2>\n<ul>\n<li>通过读取文件内容将内容包装到一个自执行函数中，默认返回 module.exports 做为函数的结果。</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-string\">`function (exports, require, module, __filename, __dirname) {\n      let a = 1;\n      module.exports = 'hello';\n      return module.exports;\n  }(exports, require, module, xxxx, xxx)`</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Module</span>(<span class=\"hljs-params\">id</span>) </span>{\n    <span class=\"hljs-built_in\">this</span>.id = id;\n    <span class=\"hljs-comment\">// 代表的是模块的返回结果</span>\n    <span class=\"hljs-built_in\">this</span>.exports = {};\n  }\n\n  Module._cache = {};\n\n  Module.wrapper = [\n    <span class=\"hljs-string\">`(function(exports, require, module, __filename, __dirname) {`</span>,\n    <span class=\"hljs-string\">`})`</span>\n  ];\n\n  Module._extensions = {\n    <span class=\"hljs-string\">'.js'</span>(<span class=\"hljs-built_in\">module</span>) {\n      <span class=\"hljs-keyword\">let</span> content = fs.readFileSync(<span class=\"hljs-built_in\">module</span>.id, <span class=\"hljs-string\">'utf8'</span>);\n      content = Module.wrapper[<span class=\"hljs-number\">0</span>] + content + Module.wrapper[<span class=\"hljs-number\">1</span>];\n      <span class=\"hljs-comment\">// 需要让函数字符串变成真正的函数</span>\n      <span class=\"hljs-keyword\">let</span> fn = vm.runInThisContext(content);\n      <span class=\"hljs-keyword\">let</span> <span class=\"hljs-built_in\">exports</span> = <span class=\"hljs-built_in\">module</span>.exports; <span class=\"hljs-comment\">// {}</span>\n      <span class=\"hljs-keyword\">let</span> dirname = path.dirname(<span class=\"hljs-built_in\">module</span>.id);\n      <span class=\"hljs-comment\">// 让包装的函数执行 require 时会让包装的函数执行，并且把this改变</span>\n      fn.call(<span class=\"hljs-built_in\">exports</span>, <span class=\"hljs-built_in\">exports</span>, req, <span class=\"hljs-built_in\">module</span>, <span class=\"hljs-built_in\">module</span>.id, dirname);\n    },\n    <span class=\"hljs-string\">'.json'</span>(<span class=\"hljs-built_in\">module</span>) {\n      <span class=\"hljs-keyword\">let</span> content = fs.readFileSync(<span class=\"hljs-built_in\">module</span>.id, <span class=\"hljs-string\">'utf8'</span>);\n      <span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-built_in\">JSON</span>.parse(content);\n    }\n  };\n\n  Module._resolveFilename = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">filename</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> absPath = path.resolve(__dirname, filename);\n    <span class=\"hljs-comment\">// 查看路径是否存在 如果不存在 则增加 .js 或者 .json 后缀</span>\n    <span class=\"hljs-keyword\">let</span> isExists = fs.existsSync(absPath);\n    <span class=\"hljs-keyword\">if</span> (isExists) {\n      <span class=\"hljs-keyword\">return</span> absPath;\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">let</span> keys = <span class=\"hljs-built_in\">Object</span>.keys(Module._extensions);\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i < keys.length; i++) {\n        <span class=\"hljs-keyword\">let</span> newPath = absPath + keys[i];\n        <span class=\"hljs-keyword\">let</span> flag = fs.existsSync(newPath);\n        <span class=\"hljs-keyword\">if</span> (flag) {\n          <span class=\"hljs-keyword\">return</span> newPath;\n        }\n      }\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'module not exists'</span>);\n    }\n  };\n\n  Module.prototype.load = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">let</span> extname = path.extname(<span class=\"hljs-built_in\">this</span>.id);\n    <span class=\"hljs-comment\">// module.exports = 'hello'</span>\n    Module._extensions[extname](<span class=\"hljs-built_in\">this</span>);\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">req</span>(<span class=\"hljs-params\">filename</span>) </span>{ <span class=\"hljs-comment\">// 默认传入的文件名可能没有增加后缀，如果没有后缀我就尝试增加.js .json</span>\n    <span class=\"hljs-comment\">// 解析出绝对路径</span>\n    filename = Module._resolveFilename(filename);\n    <span class=\"hljs-comment\">// 创建一个模块</span>\n    <span class=\"hljs-comment\">// 这里加载前先看一眼 是否加载过了</span>\n    <span class=\"hljs-keyword\">let</span> cacheModule = Module._cache[filename]; <span class=\"hljs-comment\">//  多次引用同一个模块只运行一次</span>\n    <span class=\"hljs-keyword\">if</span> (cacheModule) {\n      <span class=\"hljs-keyword\">return</span> cacheModule.exports; <span class=\"hljs-comment\">// 返回缓存的结果即可</span>\n    }\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-built_in\">module</span> = <span class=\"hljs-keyword\">new</span> Module(filename);\n    Module._cache[filename] = <span class=\"hljs-built_in\">module</span>\n    <span class=\"hljs-comment\">// 加载模块</span>\n    <span class=\"hljs-built_in\">module</span>.load();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">module</span>.exports;\n  };\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 data-id=\"heading-16\">ES6 加载规则</h2>\n<ul>\n<li>浏览器加载 ES6 模块，也使用 <code><script></code> 标签，但是要加入 <code>type=\"module\"</code> 属性。</li>\n</ul>\n<pre><code class=\"hljs language-html copyable\" lang=\"html\">  <span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"module\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"./foo.js\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>上面代码在网页中插入一个模块 foo.js ，由于 type 属性设为 module ，所以浏览器知道这是一个 ES6 模块。</li>\n<li>浏览器对于带有 type=\"module\" 的 <code><script></code> ，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了 <code><script></code> 标签的 defer 属性。</li>\n</ul>\n<pre><code class=\"hljs language-html copyable\" lang=\"html\">    <span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"module\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"./foo.js\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n    <span class=\"hljs-comment\"><!-- 等同于 --></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"module\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"./foo.js\"</span> <span class=\"hljs-attr\">defer</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>如果网页有多个 <code><script type=\"module\"></code> ，它们会按照在页面出现的顺序依次执行。</li>\n<li><code><script></code> 标签的 async 属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</li>\n</ul>\n<pre><code class=\"hljs language-html copyable\" lang=\"html\">  <span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"module\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"./foo.js\"</span> <span class=\"hljs-attr\">async</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<ul>\n<li>一旦使用了 async 属性，<code><script type=\"module\"></code> 就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</li>\n<li>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</li>\n</ul>\n<pre><code class=\"hljs language-html copyable\" lang=\"html\">  <span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"module\"</span>></span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> utils <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./utils.js\"</span>;\n    <span class=\"hljs-comment\">// other code</span>\n  </span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>对于外部的模块脚本（上例是 foo.js ），有几点需要注意。</p>\n<ul>\n<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>\n<li>模块脚本自动采用严格模式，不管有没有声明 use strict 。</li>\n<li>模块之中，可以使用 import 命令加载其他模块（ .js 后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用 export 命令输出对外接口。</li>\n<li>模块之中，顶层的 this 关键字返回 undefined ，而不是指向 window 。也就是说，在模块顶层使用 this 关键字，是无意义的。</li>\n<li>同一个模块如果加载多次，将只执行一次。</li>\n</ul>\n<blockquote>\n<p>示例</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-keyword\">import</span> utils <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'https://example.com/js/utils.js'</span>;\n\n  <span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-number\">1</span>;\n\n  <span class=\"hljs-built_in\">console</span>.log(x === <span class=\"hljs-built_in\">window</span>.x); <span class=\"hljs-comment\">//false</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span> === <span class=\"hljs-literal\">undefined</span>); <span class=\"hljs-comment\">// true</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>利用顶层的 this 等于 undefined 这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">    <span class=\"hljs-keyword\">const</span> isNotModuleScript = <span class=\"hljs-built_in\">this</span> !== <span class=\"hljs-literal\">undefined</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 data-id=\"heading-17\">ES6 模块与 CommonJS 模块的差异</h2>\n<ul>\n<li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>\n</ul>\n<blockquote>\n<p>以之前 2-CommonJS 规范中的例子为例</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-comment\">// lib.js</span>\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> counter = <span class=\"hljs-number\">3</span>;\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incCounter</span>(<span class=\"hljs-params\"></span>) </span>{\n    counter++;\n  }\n\n  <span class=\"hljs-comment\">// main.js</span>\n  <span class=\"hljs-keyword\">import</span> { counter, incCounter } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./lib'</span>;\n  <span class=\"hljs-built_in\">console</span>.log(counter); <span class=\"hljs-comment\">// 3</span>\n  incCounter();\n  <span class=\"hljs-built_in\">console</span>.log(counter); <span class=\"hljs-comment\">// 4</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<blockquote>\n<p>再举一个例子</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">  <span class=\"hljs-comment\">// m1.js</span>\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">'bar'</span>;\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> foo = <span class=\"hljs-string\">'baz'</span>, <span class=\"hljs-number\">500</span>);\n\n  <span class=\"hljs-comment\">// m2.js</span>\n  <span class=\"hljs-keyword\">import</span> {foo} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./m1.js'</span>;\n  <span class=\"hljs-built_in\">console</span>.log(foo);\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-built_in\">console</span>.log(foo), <span class=\"hljs-number\">500</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre></div> <div class=\"image-viewer-box\" data-v-78c9b824><!----></div>","descriptionType":"text/html","publishedDate":"Thu, 03 Sep 2020 03:45:15 +0000","feedId":12740,"bgimg":"","linkMd5":"e6f35a0feb151bf9f3926fdda2badbce","bgimgJsdelivr":"","metaImg":"","author":"HongqinMa","publishedOrCreatedDate":1599295203163},{"createdTime":"2020-09-05 16:40:03","updatedTime":"2020-09-05 16:40:03","title":"[Web翻译]移植库到Web Components","link":"https://juejin.im/post/6868235002824359949","description":"<div class=\"markdown-body\"><blockquote>\n<p>原文地址：<a href=\"https://matsu.fi/posts/porting-libraries-to-web-components/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">matsu.fi/posts/porti…</a></p>\n<p>原文作者：<a href=\"https://matsu.fi/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">matsu.fi</a></p>\n<p>发布时间：2020年6月27日</p>\n</blockquote>\n<p>随着Web Components成为<a href=\"https://html.spec.whatwg.org/multipage/custom-elements.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Web标准</a>的一部分，越来越多的库正在用Web Components创建，而不仅仅是暴露上述库的API。</p>\n<p>但是在Web Components兴起之前创建的库呢？它们能否被移植到Web Components中，这将是一个什么样的工作量？这就是我们今天要讨论的内容。</p>\n<h1 data-id=\"heading-0\">前言</h1>\n<p>那么，如果已经有了一个现有的实现，我们为什么还要创建一个相当于库的Web组件呢？首先想到的是易用性和易实现性。通过创建一个库的Web组件，上述功能的实现就会从原来的</p>\n<pre><code class=\"hljs language-html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"paragraph-to-highlight\"</span>></span>Please highlight me with the library<span class=\"hljs-tag\"></<span class=\"hljs-name\">p</span>></span>\n\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/library/api.js\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n    <span class=\"hljs-built_in\">window</span>.onload = <span class=\"hljs-function\">() =></span> {\n        <span class=\"hljs-keyword\">const</span> par = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'#paragraph-to-highlight'</span>);\n        HighlightLibrary.highlight(par);\n    };\n</span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>更简单的说</p>\n<pre><code class=\"hljs language-html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">highlight-library</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">p</span>></span>Please highlight me with the library<span class=\"hljs-tag\"></<span class=\"hljs-name\">p</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">highlight-library</span>></span>\n\n<span class=\"hljs-tag\"><<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/library/wc.js\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"module\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">script</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>有多个亲的。</p>\n<ul>\n<li>减少代码</li>\n<li>不污染ID/类空间</li>\n<li>没有与窗口加载事件等绑定的任意代码片段。</li>\n</ul>\n<p>还有很多其他的问题。当然，其中一些问题可能会通过使用现代框架或库来消除，在这种情况下，javascript位于单独的文件中，而不是在HTML中，但在这种情况下，你仍然需要写一些类似<code>initializeHighlights()</code>的东西，并在页面加载时调用它。</p>\n<p>通过在Web组件中自动完成这个过程，并让组件负责它的工作，我们可以大大简化开发过程。</p>\n<h1 data-id=\"heading-1\">入门</h1>\n<p>在这篇文章中，我将以我移植的一个名为 <a href=\"https://github.com/pshihn/rough-notation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Rough Notation</a> 的库为例。</p>\n<p>Rough Notation是一个小库，用于在html页面上用漂亮的手绘动画突出显示内容。</p>\n<p>Rough Notation的常规用法是这样的。</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { annotate } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rough-notation'</span>;\n\n<span class=\"hljs-keyword\">const</span> element = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'#myElement'</span>);\n<span class=\"hljs-keyword\">const</span> annotation = annotate(element, { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'underline'</span> });\nannoation.show();\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>如果要用我写的Web组件<a href=\"https://github.com/Matsuuu/vanilla-rough-notation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Vanilla Rough Notation</a>来获得同样的功能，你只需要编写</p>\n<pre><code class=\"hljs language-html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">rough-notation</span> <span class=\"hljs-attr\">showOnLoad</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"underline\"</span>></span>\n    <span class=\"hljs-tag\"><<span class=\"hljs-name\">p</span>></span>Please underline me<span class=\"hljs-tag\"></<span class=\"hljs-name\">p</span>></span>\n<span class=\"hljs-tag\"></<span class=\"hljs-name\">rough-notation</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>这为使用该库进行开发创造了良好的环境，因为不需要额外的javascript。你只需将元素封装在一个Web组件中，功能就会被立即应用。</p>\n<p>这使得工作流程更快，因为开发人员不必在代码库中编写初始化函数，只需在创建元素时将效果应用到元素上即可。</p>\n<p>这种工作方式也更适合初学者，因为它需要0javascript知识才能上手，所以很容易在例如CMS服务中使用。</p>\n<p>那么这个功能是如何实现的呢？</p>\n<h1 data-id=\"heading-2\">设置阶段</h1>\n<p>在开发Web组件时，我希望尽可能的保持Vanilla，使Rough Notation成为项目中唯一的依赖。</p>\n<p>为了让开发更容易，我还添加了<a href=\"https://www.npmjs.com/package/es-dev-server\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">es-dev-server</a>作为开发依赖。Es Dev Server让我们有了一个热重载的无构建环境。</p>\n<p>在发布的时候，<code>package.json</code>看起来是这样的。</p>\n<pre><code class=\"hljs language-json copyable\" lang=\"json\">{\n    <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"vanilla-rough-notation\"</span>,\n    <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"0.4.2\"</span>,\n    <span class=\"hljs-attr\">\"description\"</span>: <span class=\"hljs-string\">\"A vanilla implementation of the Rough Notation library\"</span>,\n    <span class=\"hljs-attr\">\"main\"</span>: <span class=\"hljs-string\">\"index.js\"</span>,\n    <span class=\"hljs-attr\">\"module\"</span>: <span class=\"hljs-string\">\"index.js\"</span>,\n    <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"module\"</span>,\n    <span class=\"hljs-attr\">\"files\"</span>: [<span class=\"hljs-string\">\"*.js\"</span>],\n    <span class=\"hljs-attr\">\"scripts\"</span>: {\n        <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-string\">\"es-dev-server --app-index index.html --node-resolve --watch --open\"</span>\n    },\n    <span class=\"hljs-attr\">\"author\"</span>: <span class=\"hljs-string\">\"Matsuuu\"</span>,\n    <span class=\"hljs-attr\">\"license\"</span>: <span class=\"hljs-string\">\"MIT\"</span>,\n    <span class=\"hljs-attr\">\"devDependencies\"</span>: {\n        <span class=\"hljs-attr\">\"es-dev-server\"</span>: <span class=\"hljs-string\">\"^1.54.0\"</span>\n    },\n    <span class=\"hljs-attr\">\"dependencies\"</span>: {\n        <span class=\"hljs-attr\">\"rough-notation\"</span>: <span class=\"hljs-string\">\"^0.4.0\"</span>\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>接下来让我们跳到代码本身。</p>\n<h1 data-id=\"heading-3\">编写Web组件</h1>\n<p>首先我们要做的事情是</p>\n<ul>\n<li>导入我们要移植的库</li>\n<li>创建一个包含我们代码的类</li>\n<li>让我们的类扩展HTMLElement类。</li>\n<li>将Web组件声明为一个自定义元素。</li>\n</ul>\n<p>一旦我们这样做了，代码应该是这样的</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { annotate } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rough-notation'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">VanillaRoughNotation</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">HTMLElement</span> </span>{}\n\n<span class=\"hljs-keyword\">if</span> (!customElements.get(<span class=\"hljs-string\">'rough-notation'</span>)) {\n    customElements.define(<span class=\"hljs-string\">'rough-notation'</span>, VanillaRoughNotation);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>现在如果我们使用html标签<code><rough-notation></rough-notation></code>，我们的类里面的代码就会被执行，如果有的话。</p>\n<p>接下来让我们添加一些初始设置。</p>\n<h1 data-id=\"heading-4\">让我们开始影子盒</h1>\n<p>Web Components的一大优点是封装了样式和代码。这是通过在Web组件中附加一个ShadowRoot来实现的。</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">影子根</a>是影子DOM API的一部分，作为主DOM树的子树。Shadow Root与文档的主DOM树是分开渲染的，并且不受主DOM树样式的影响。</p>\n<p>在我们的组件中使用影子DOM是必要的，因为影子DOM除了创建一个封装的环境之外，还可以使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Slot</a>。</p>\n<p>Slots是Web Components技术套件的相关部分。它们的功能是在Web组件中的占位符，可以用markdown来填充。</p>\n<p>让我们开始我们的Web组件代码库，创建一个影子根，并在里面附加一个槽。</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">VanillaRoughNotation</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">HTMLElement</span> </span>{\n    connectedCallback() {\n        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.shadowRoot) {\n            <span class=\"hljs-built_in\">this</span>.attachShadow({ <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">'open'</span> });\n        }\n        <span class=\"hljs-built_in\">this</span>.shadowRoot.innerHTML = <span class=\"hljs-string\">'<slot></slot>'</span>;\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p><code>connectedCallback</code>方法是我们扩展的HTMLElement API的一部分，每次当自定义元素被添加到文档连接的元素中时，<code>connectedCallback</code>都会被调用</p>\n<p>在函数中，我们检查元素是否已经有一个shadowRoot，如果没有shadowRoot，我们就用<code>this.attachShadow({mode: 'open'})</code>附加一个。</p>\n<p>通过将模式设置为 \"open\"，我们使我们的元素可以从影子根之外的Javascript中访问。元素的内容可以通过<code>document.querySelector(\"roough-notation\").shadowRoot</code>来查询。</p>\n<p>如果我们将模式设置为 \"封闭\"，我们就有效地拒绝了外界对影子根内部节点的所有访问。</p>\n<p>我们还将<code><slot></code>元素设置为shadowRoot的主体。现在我们可以在粗注html标签里面添加其他DOM元素，它们将和组件一起显示。</p>\n<p>好了，现在我们可以把元素放在我们的网页里面了。现在我们可以把元素放在我们的Web组件里面了。让我们开始实现该库的功能。</p>\n<h1 data-id=\"heading-5\">锁定和编码</h1>\n<p>为了实现我们前面所经历的API的功能，我们首先需要一种方法来获取我们Web组件内部的所有元素。</p>\n<p>这可以通过查询我们槽元素的分配节点来实现。</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">const</span> assignedNodes = <span class=\"hljs-built_in\">this</span>.shadowRoot\n    .querySelector(<span class=\"hljs-string\">'slot'</span>)\n    .assignedNodes()\n    .filter(<span class=\"hljs-function\">(<span class=\"hljs-params\">node</span>) =></span> node <span class=\"hljs-keyword\">instanceof</span> HTMLElement);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>当查询assignedNodes时，我们可能也会捕获一些<code>#text</code>元素，因为换行符会生成文本节点。我们要过滤掉这些，只需将节点过滤为HTMLElement的实例就可以轻松完成。</p>\n<p>接下来我们要将库的功能应用到所有的节点上。与通常调用API不同，在Web组件中，我们需要考虑到所有可能的变量。</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">assignedNodes.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">an</span>) =></span> {\n    <span class=\"hljs-built_in\">this</span>.annotation = annotate(an, {\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">this</span>.type,\n        <span class=\"hljs-attr\">animate</span>: <span class=\"hljs-built_in\">this</span>.animate,\n        <span class=\"hljs-attr\">animationDuration</span>: <span class=\"hljs-built_in\">this</span>.animationDuration,\n        <span class=\"hljs-attr\">color</span>: <span class=\"hljs-built_in\">this</span>.color,\n        <span class=\"hljs-attr\">strokeWidth</span>: <span class=\"hljs-built_in\">this</span>.strokeWidth,\n        <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-built_in\">this</span>.padding,\n        <span class=\"hljs-attr\">multiline</span>: <span class=\"hljs-built_in\">this</span>.multiline,\n        <span class=\"hljs-attr\">iterations</span>: <span class=\"hljs-built_in\">this</span>.iterations,\n    });\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 data-id=\"heading-6\">属性和特性</h1>\n<p>但是等等，你可能会问。我们还没有声明这些变量。是的，没错。接下来我们将看看设置属性。</p>\n<p>一个Web组件的属性的基本值是在元素的<code>constructor</code>函数中设置的。</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-built_in\">super</span>();\n    <span class=\"hljs-built_in\">this</span>.type = <span class=\"hljs-string\">'underline'</span>;\n    <span class=\"hljs-built_in\">this</span>.animation = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-built_in\">this</span>.animationDuration = <span class=\"hljs-number\">800</span>;\n    <span class=\"hljs-built_in\">this</span>.color = <span class=\"hljs-string\">'currentColor'</span>;\n    <span class=\"hljs-built_in\">this</span>.strokeWidth = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-built_in\">this</span>.padding = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-built_in\">this</span>.showOnLoad = <span class=\"hljs-literal\">false</span>;\n    <span class=\"hljs-built_in\">this</span>.order = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">this</span>.multiline = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-built_in\">this</span>.iterations = <span class=\"hljs-number\">2</span>;\n\n    <span class=\"hljs-built_in\">this</span>.annotation = <span class=\"hljs-literal\">null</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>在这里，我们可以使用库的默认值，或者声明一个我们选择的默认情况。我决定实现库中的默认值，同时也将<code>underline</code>设置为默认的符号类型。</p>\n<p>目前我们正在摇摆着使用默认值，但我们当然希望用户能够自己声明属性。</p>\n<p>让我们创建一个方法来设置HTML元素属性中的变量。</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">setAttributes() {\n    <span class=\"hljs-built_in\">this</span>.type = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'type'</span>) || <span class=\"hljs-built_in\">this</span>.type;\n    <span class=\"hljs-built_in\">this</span>.animation = <span class=\"hljs-built_in\">this</span>.hasAttribute(<span class=\"hljs-string\">'animation'</span>) ? <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'animation'</span>) === <span class=\"hljs-string\">'true'</span> : <span class=\"hljs-built_in\">this</span>.animation;\n    <span class=\"hljs-built_in\">this</span>.animationDuration = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'animationDuration'</span>) || <span class=\"hljs-built_in\">this</span>.animationDuration;\n    <span class=\"hljs-built_in\">this</span>.color = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'color'</span>) || <span class=\"hljs-built_in\">this</span>.color;\n    <span class=\"hljs-built_in\">this</span>.strokeWidth = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'strokeWidth'</span>) || <span class=\"hljs-built_in\">this</span>.strokeWidth;\n    <span class=\"hljs-built_in\">this</span>.padding = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'padding'</span>) || <span class=\"hljs-built_in\">this</span>.padding;\n    <span class=\"hljs-built_in\">this</span>.showOnLoad = <span class=\"hljs-built_in\">this</span>.hasAttribute(<span class=\"hljs-string\">'showOnLoad'</span>);\n    <span class=\"hljs-built_in\">this</span>.order = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'order'</span>) || <span class=\"hljs-built_in\">this</span>.order;\n    <span class=\"hljs-built_in\">this</span>.multiline = <span class=\"hljs-built_in\">this</span>.hasAttribute(<span class=\"hljs-string\">'multiline'</span>) ? <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'multiline'</span>) === <span class=\"hljs-string\">'true'</span> : <span class=\"hljs-built_in\">this</span>.multiline;\n    <span class=\"hljs-built_in\">this</span>.brackets = <span class=\"hljs-built_in\">this</span>.getBrackets();\n    <span class=\"hljs-built_in\">this</span>.iterations = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'iterations'</span>) || <span class=\"hljs-built_in\">this</span>.iterations;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>一般的属性我们只需要使用<code>this.getAttribute(attr)</code>方法就可以获取。但是我们的组件中还有几个布尔属性。这些属性比较棘手，因为HTML属性只能是字符串。在这些情况下，我们需要检查属性的存在。</p>\n<p>这可以通过<code>this.hasAttribute(attr)</code>来完成。所以现在我们可以通过省略属性的值部分来使用布尔运算符，就像这样。</p>\n<pre><code class=\"hljs language-html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">rough-notation</span> <span class=\"hljs-attr\">showOnLoad</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">rough-notation</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>但是如果属性的默认值是true，这就不行了。在这种情况下，我们要检查属性是否是一个字符串，值为true。所以在这种情况下，如果我们想禁用动画，我们可以直接写。</p>\n<pre><code class=\"hljs language-html copyable\" lang=\"html\"><span class=\"hljs-tag\"><<span class=\"hljs-name\">rough-notation</span> <span class=\"hljs-attr\">animation</span>=<span class=\"hljs-string\">\"false\"</span>></span><span class=\"hljs-tag\"></<span class=\"hljs-name\">rough-notation</span>></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>如果我们想观察这些属性内部的变化，我们可以使用<code>attributeChangedCallback</code>函数和自定义属性设置器。然而我们的Web组件的值是在元素初始化中设置的，所以这里不需要这样做。</p>\n<h1 data-id=\"heading-7\">回到正轨</h1>\n<p>现在让我们回到我们的初始化代码。</p>\n<p>你可能已经注意到了，我们在API中添加了一个新属性：<code>showOnLoad</code>。这可以用来轻松地使动画在准备好后立即显示，而不是在调用<code>show()</code>方法时运行动画。现在我们来实现这个功能。</p>\n<p>Rough Notation库在主DOM中添加了一个样式元素 其中有一些关键的动画关键帧 我们要确保这些关键帧也能应用到我们的开槽元素中去。请记住。Shadow Root封装了样式 所以如果我们的开槽元素在Shadow Root里面 主DOM的样式不会影响到它们</p>\n<p>快速浏览一下库的源代码，就会发现样式元素被分配到一个全局变量<code>__rno_kf_s</code>。是 \"Rough Notation Keyframe styles \"的缩写。</p>\n<p>我们可以在我们的元素中克隆这个节点。</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-built_in\">this</span>.append(<span class=\"hljs-built_in\">window</span>.__rno_kf_s.cloneNode(<span class=\"hljs-literal\">true</span>));\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>我们要确保我们克隆了它，而不是仅仅从主 DOM 中拽出它。</p>\n<p>现在，如果我们在克隆节点后立即调用<code>show()</code>，一切都应该正常工作，对吗？</p>\n<p>但现在我们注意到动画似乎没有播放。这是怎么回事呢？</p>\n<p>如果我们看一下我们要克隆的样式，我们注意到它是一个关键帧样式，大致如下。</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">@keyframes rough-notation-dash {\n    to {\n        stroke-dashoffset: <span class=\"hljs-number\">0</span>;\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>这意味着，这给我们的库元素提供了一个动画的结束状态。但是以Javascript的工作方式，只要克隆节点并立即调用show方法，样式元素还没来得及在DOM中初始化自己，这意味着它的样式还不能应用。</p>\n<p>你可能首先想到的一个解决方案是</p>\n<blockquote>\n<p>但如果我加个<code>setTimeout</code>就能解决这个问题，对吧？</p>\n</blockquote>\n<p>那么... 是的，但不是。</p>\n<p>SetTimeout是各种讨厌的东西，不应该在这种情况下被过度使用。它确实可以解决这个问题，但它可能会给我们的组件引入一些新的错误。</p>\n<p>相反，我们可以告诉我们的代码等待下一个动画帧，然后运行<code>show()</code>命令。这应该可以解决我们的问题。</p>\n<p>要做到这一点，我们只需写下</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-built_in\">window</span>.requestAnimationFrame(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.showOnLoad) {\n        <span class=\"hljs-built_in\">this</span>.annotation.show();\n    }\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p><code>requestAnimationFrame</code>需要一个回调作为参数，然后在浏览器发送一帧后调用它。</p>\n<h1 data-id=\"heading-8\">逼近目标</h1>\n<p>所以，现在我们应该有一个有点功能的Web组件的移植。我们的源代码看起来是这样的。</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { annotate } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rough-notation'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">VanillaRoughNotation</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">HTMLElement</span> </span>{\n    <span class=\"hljs-keyword\">constructor</span>() {\n        <span class=\"hljs-built_in\">super</span>();\n        <span class=\"hljs-built_in\">this</span>.type = <span class=\"hljs-string\">'underline'</span>;\n        <span class=\"hljs-built_in\">this</span>.animation = <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-built_in\">this</span>.animationDuration = <span class=\"hljs-number\">800</span>;\n        <span class=\"hljs-built_in\">this</span>.color = <span class=\"hljs-string\">'currentColor'</span>;\n        <span class=\"hljs-built_in\">this</span>.strokeWidth = <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-built_in\">this</span>.padding = <span class=\"hljs-number\">5</span>;\n        <span class=\"hljs-built_in\">this</span>.showOnLoad = <span class=\"hljs-literal\">false</span>;\n        <span class=\"hljs-built_in\">this</span>.order = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-built_in\">this</span>.multiline = <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-built_in\">this</span>.iterations = <span class=\"hljs-number\">2</span>;\n\n        <span class=\"hljs-built_in\">this</span>.annotation = <span class=\"hljs-literal\">null</span>;\n    }\n\n    setAttributes() {\n        <span class=\"hljs-built_in\">this</span>.type = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'type'</span>) || <span class=\"hljs-built_in\">this</span>.type;\n        <span class=\"hljs-built_in\">this</span>.animation = <span class=\"hljs-built_in\">this</span>.hasAttribute(<span class=\"hljs-string\">'animation'</span>) ? <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'animation'</span>) === <span class=\"hljs-string\">'true'</span> : <span class=\"hljs-built_in\">this</span>.animation;\n        <span class=\"hljs-built_in\">this</span>.animationDuration = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'animationDuration'</span>) || <span class=\"hljs-built_in\">this</span>.animationDuration;\n        <span class=\"hljs-built_in\">this</span>.color = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'color'</span>) || <span class=\"hljs-built_in\">this</span>.color;\n        <span class=\"hljs-built_in\">this</span>.strokeWidth = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'strokeWidth'</span>) || <span class=\"hljs-built_in\">this</span>.strokeWidth;\n        <span class=\"hljs-built_in\">this</span>.padding = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'padding'</span>) || <span class=\"hljs-built_in\">this</span>.padding;\n        <span class=\"hljs-built_in\">this</span>.showOnLoad = <span class=\"hljs-built_in\">this</span>.hasAttribute(<span class=\"hljs-string\">'showOnLoad'</span>);\n        <span class=\"hljs-built_in\">this</span>.order = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'order'</span>) || <span class=\"hljs-built_in\">this</span>.order;\n        <span class=\"hljs-built_in\">this</span>.multiline = <span class=\"hljs-built_in\">this</span>.hasAttribute(<span class=\"hljs-string\">'multiline'</span>) ? <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'multiline'</span>) === <span class=\"hljs-string\">'true'</span> : <span class=\"hljs-built_in\">this</span>.multiline;\n        <span class=\"hljs-built_in\">this</span>.iterations = <span class=\"hljs-built_in\">this</span>.getAttribute(<span class=\"hljs-string\">'iterations'</span>) || <span class=\"hljs-built_in\">this</span>.iterations;\n    }\n\n    connectedCallback() {\n        <span class=\"hljs-built_in\">this</span>.setAttributes();\n        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.shadowRoot) {\n            <span class=\"hljs-built_in\">this</span>.attachShadow({ <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">'open'</span> });\n        }\n        <span class=\"hljs-built_in\">this</span>.shadowRoot.innerHTML = <span class=\"hljs-string\">'<slot></slot>'</span>;\n        <span class=\"hljs-keyword\">const</span> assignedNodes = <span class=\"hljs-built_in\">this</span>.shadowRoot\n            .querySelector(<span class=\"hljs-string\">'slot'</span>)\n            .assignedNodes()\n            .filter(<span class=\"hljs-function\">(<span class=\"hljs-params\">node</span>) =></span> node <span class=\"hljs-keyword\">instanceof</span> HTMLElement);\n\n        assignedNodes.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">an</span>) =></span> {\n            <span class=\"hljs-built_in\">this</span>.annotation = annotate(an, {\n                <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">this</span>.type,\n                <span class=\"hljs-attr\">animate</span>: <span class=\"hljs-built_in\">this</span>.animate,\n                <span class=\"hljs-attr\">animationDuration</span>: <span class=\"hljs-built_in\">this</span>.animationDuration,\n                <span class=\"hljs-attr\">color</span>: <span class=\"hljs-built_in\">this</span>.color,\n                <span class=\"hljs-attr\">strokeWidth</span>: <span class=\"hljs-built_in\">this</span>.strokeWidth,\n                <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-built_in\">this</span>.padding,\n                <span class=\"hljs-attr\">brackets</span>: <span class=\"hljs-built_in\">this</span>.brackets,\n                <span class=\"hljs-attr\">multiline</span>: <span class=\"hljs-built_in\">this</span>.multiline,\n                <span class=\"hljs-attr\">iterations</span>: <span class=\"hljs-built_in\">this</span>.iterations,\n            });\n        });\n        <span class=\"hljs-comment\">// Clone the style element from the windows styles to shadow dom.</span>\n        <span class=\"hljs-built_in\">this</span>.append(<span class=\"hljs-built_in\">window</span>.__rno_kf_s.cloneNode(<span class=\"hljs-literal\">true</span>));\n\n        <span class=\"hljs-built_in\">window</span>.requestAnimationFrame(<span class=\"hljs-function\">() =></span> {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.showOnLoad) {\n                <span class=\"hljs-built_in\">this</span>.annotation.show();\n            }\n        });\n    }\n}\n\n<span class=\"hljs-keyword\">if</span> (!customElements.get(<span class=\"hljs-string\">'rough-notation'</span>)) {\n    customElements.define(<span class=\"hljs-string\">'rough-notation'</span>, VanillaRoughNotation);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>现在，在我们发布这款产品之前，进行最后的修饰。</p>\n<h1 data-id=\"heading-9\">暴露API</h1>\n<p>你可能已经注意到了，Rough Notation库公开了一组函数供我们调用。我们想让我们的用户也能使用这些函数。幸运的是，我们可以像原来的库一样，用同样的方式来公开这些API。</p>\n<p>我们看到，该库有4个主要函数。</p>\n<ul>\n<li>show()</li>\n<li>hide()</li>\n<li>remove()</li>\n<li>isShowing()</li>\n</ul>\n<p>为了暴露这些API，我们可以在我们的组件中创建封装函数。</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">isShowing() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.annotation != <span class=\"hljs-literal\">null</span> && <span class=\"hljs-built_in\">this</span>.annotation.isShowing();\n}\n\nshow() {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.annotation) {\n        <span class=\"hljs-built_in\">this</span>.annotation.show();\n    }\n}\n\nhide() {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.annotation) {\n        <span class=\"hljs-built_in\">this</span>.annotation.hide();\n    }\n}\n\nremove() {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.annotation) {\n        <span class=\"hljs-built_in\">this</span>.annotation.remove();\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>现在我们的用户只要从DOM中选择我们的Web组件并调用它，就可以调用这些函数。</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'roough-notation'</span>).show();\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h1 data-id=\"heading-10\">收尾工作</h1>\n<p>现在我们应该有一个功能性的Web组件，我们可以在我们的项目中使用，无论框架如何。</p>\n<p>纯香草Web组件最好的地方在于它们是不可知的框架，不需要依赖React或LitElement来导入到项目中，这使得它们真的只是即插即用。</p>\n<p>当然，在这种情况下，我们仍然依赖于粗略的符号库，但有很多Web Components的构建是不需要任何依赖的。</p>\n<p>移植现有的库是一种很好的方式，可以让我们进入编写Web Components的感觉。它们同时也让世界变得更简单，因为既然组件已经做到了，那么就不需要再去调用那些库的API了。</p>\n<p><strong>相关链接</strong></p>\n<ul>\n<li><a href=\"https://github.com/rough-stuff/rough-notation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Original Library</a></li>\n<li><a href=\"https://github.com/rough-stuff/rough-notation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Web Component Port</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MDN Resource on Web Components</a></li>\n<li><a href=\"https://www.npmjs.com/package/es-dev-server\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ES Dev Server</a></li>\n</ul>\n<hr>\n<p>通过<a href=\"http://www.deepl.com/Translator\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">www.DeepL.com/Translator</a> （免费版）翻译</p></div> <div class=\"image-viewer-box\" data-v-78c9b824><!----></div>","descriptionType":"text/html","publishedDate":"Thu, 03 Sep 2020 04:20:11 +0000","feedId":12740,"bgimg":"","linkMd5":"02f2d25d66985da00c309b251ab5a59e","bgimgJsdelivr":"","metaImg":"","author":"Sunbreak","publishedOrCreatedDate":1599295203164},{"createdTime":"2020-09-05 16:40:03","updatedTime":"2020-09-05 16:40:03","title":"用 TypeScript 模板字符串类型来制作 URL parser","link":"https://juejin.im/post/6868156971393449997","description":"<div class=\"markdown-body\"><h2 data-id=\"heading-0\">想法</h2>\n<p>昨天写了一些简单的基于 TypeScript 模板字符串类型的字符串操作后，看到 <a href=\"https://github.com/Kingwl\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">@Kingwl</a> 做了一个 <a href=\"https://github.com/microsoft/TypeScript/pull/40336#issuecomment-684784211\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">算术（只有加和减）执行器</a>，于是手有点痒，想写一个 parser。</p>\n<p>无疑写一个 JSON parser 是相对高大上的，但是很复杂（毕竟完全基于类型系统）。后来决定做一个 URL parser，这样相对简单。</p>\n<p>关于 URL 的结构，我参考的是 <a href=\"https://nodejs.org/api/url.html#url_url_strings_and_url_objects\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Node.js 的文档</a>，里面有介绍 URL 中各个 component 的情况。</p>\n<h2 data-id=\"heading-1\">实现</h2>\n<p>由于纯粹是为了好玩，因此这个 URL parser 不会考虑到一些 edge cases，但也针对常见的情况做了一些处理。例如：不允许「端口」中出现非数字字符；URL 中的用户名、密码、端口、query string 以及 hash 都是可选的，缺少它们不会导致解析失败。</p>\n<p>代码如下：</p>\n<pre><code class=\"hljs language-typescript copyable\" lang=\"typescript\"><span class=\"hljs-keyword\">type</span> ParseProtocol<I, AST> =\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${infer P}</span>://<span class=\"hljs-subst\">${infer Rest}</span>`</span> ? [AST & { protocol: P }, Rest] : <span class=\"hljs-built_in\">never</span>\n\n<span class=\"hljs-keyword\">type</span> ParseAuth<I, AST> =\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${infer A}</span>@<span class=\"hljs-subst\">${infer Rest}</span>`</span> ?\n    A <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${infer U}</span>:<span class=\"hljs-subst\">${infer P}</span>`</span> ? [AST & { username: U, password: P }, Rest] :\n    [AST & { username: A }, Rest] : [AST, I]\n\n<span class=\"hljs-keyword\">type</span> ParseHost<I, AST> =\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${infer H}</span>/<span class=\"hljs-subst\">${infer Rest}</span>`</span> ?\n    H <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${infer Name}</span>:<span class=\"hljs-subst\">${infer Port}</span>`</span> ?\n    ParsePort<Port> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">never</span> ? <span class=\"hljs-built_in\">never</span> :\n    ParsePort<Port> <span class=\"hljs-keyword\">extends</span> infer Port ?\n    [AST & { hostname: Name, port: Port }, Rest] :\n    [AST & { hostname: H }, Rest] :\n    <span class=\"hljs-built_in\">never</span> : <span class=\"hljs-built_in\">never</span>\n<span class=\"hljs-keyword\">type</span> Digit = <span class=\"hljs-string\">'0'</span> | <span class=\"hljs-string\">'1'</span> | <span class=\"hljs-string\">'2'</span> | <span class=\"hljs-string\">'3'</span> | <span class=\"hljs-string\">'4'</span> | <span class=\"hljs-string\">'5'</span> | <span class=\"hljs-string\">'6'</span> | <span class=\"hljs-string\">'7'</span> | <span class=\"hljs-string\">'8'</span> | <span class=\"hljs-string\">'9'</span>\n<span class=\"hljs-keyword\">type</span> ParsePort<I, O <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">''</span>> =\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">''</span> ? O :\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${Digit}</span><span class=\"hljs-subst\">${infer Rest}</span>`</span> ?\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${infer Char}</span><span class=\"hljs-subst\">${Rest}</span>`</span> ?\n    ParsePort<Rest, <span class=\"hljs-string\">`<span class=\"hljs-subst\">${O}</span><span class=\"hljs-subst\">${Char}</span>`</span>> :\n    <span class=\"hljs-built_in\">never</span> : <span class=\"hljs-built_in\">never</span>\n\n<span class=\"hljs-keyword\">type</span> ParsePathname<I, AST> =\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${infer P}</span>?<span class=\"hljs-subst\">${infer Rest}</span>`</span> ? [AST & { pathname: <span class=\"hljs-string\">`/<span class=\"hljs-subst\">${P}</span>`</span> }, <span class=\"hljs-string\">`?<span class=\"hljs-subst\">${Rest}</span>`</span>] :\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${infer P}</span>#<span class=\"hljs-subst\">${infer Rest}</span>`</span> ? [AST & { pathname: <span class=\"hljs-string\">`/<span class=\"hljs-subst\">${P}</span>`</span> }, <span class=\"hljs-string\">`#<span class=\"hljs-subst\">${Rest}</span>`</span>] :\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${infer P}</span>`</span> ? [AST & { pathname: <span class=\"hljs-string\">`/<span class=\"hljs-subst\">${P}</span>`</span> }, <span class=\"hljs-string\">''</span>] : <span class=\"hljs-built_in\">never</span>\n\n<span class=\"hljs-keyword\">type</span> ParseQuery<I, AST> =\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`?<span class=\"hljs-subst\">${infer Q}</span>#<span class=\"hljs-subst\">${infer Rest}</span>`</span> ? [AST & { query: ParseQueryItems<Q> }, <span class=\"hljs-string\">`#<span class=\"hljs-subst\">${Rest}</span>`</span>] :\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`?<span class=\"hljs-subst\">${infer Q}</span>`</span> ? [AST & { query: ParseQueryItems<Q> }, <span class=\"hljs-string\">''</span>] : [AST, I]\n<span class=\"hljs-keyword\">type</span> ParseQueryItems<I> =\n    <span class=\"hljs-built_in\">string</span> <span class=\"hljs-keyword\">extends</span> I ? [] :\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">''</span> ? [] :\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${infer K}</span>=<span class=\"hljs-subst\">${infer V}</span>&<span class=\"hljs-subst\">${infer Rest}</span>`</span> ? [{ key: K, value: V }, ...ParseQueryItems<Rest>] :\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${infer K}</span>&<span class=\"hljs-subst\">${infer Rest}</span>`</span> ? [{ key: K, value: <span class=\"hljs-literal\">null</span> }, ...ParseQueryItems<Rest>] :\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${infer K}</span>=<span class=\"hljs-subst\">${infer V}</span>`</span> ? [{ key: K, value: V }] :\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${infer K}</span>`</span> ? [{ key: K, value: <span class=\"hljs-literal\">null</span> }] : []\n\n<span class=\"hljs-keyword\">type</span> ParseHash<I, AST> =\n    I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`#<span class=\"hljs-subst\">${infer H}</span>`</span> ? [AST & { hash: <span class=\"hljs-string\">`#<span class=\"hljs-subst\">${H}</span>`</span> }] : [AST]\n\n<span class=\"hljs-keyword\">type</span> ParseURL<I <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span>> =\n    ParseProtocol<I, {}> <span class=\"hljs-keyword\">extends</span> [infer AST, infer Rest] ?\n    ParseAuth<Rest, AST> <span class=\"hljs-keyword\">extends</span> [infer AST, infer Rest] ?\n    ParseHost<Rest, AST> <span class=\"hljs-keyword\">extends</span> [infer AST, infer Rest] ?\n    ParsePathname<Rest, AST> <span class=\"hljs-keyword\">extends</span> [infer AST, infer Rest] ?\n    ParseQuery<Rest, AST> <span class=\"hljs-keyword\">extends</span> [infer AST, infer Rest] ?\n    ParseHash<Rest, AST> <span class=\"hljs-keyword\">extends</span> [infer AST] ? AST :\n    <span class=\"hljs-built_in\">never</span> : <span class=\"hljs-built_in\">never</span> : <span class=\"hljs-built_in\">never</span> : <span class=\"hljs-built_in\">never</span> : <span class=\"hljs-built_in\">never</span> : <span class=\"hljs-built_in\">never</span>\n\n<span class=\"hljs-keyword\">type</span> Merge<T> = { [P <span class=\"hljs-keyword\">in</span> keyof T <span class=\"hljs-keyword\">as</span> T[P] <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">''</span> ? <span class=\"hljs-built_in\">never</span> : P]: T[P] }\n\n<span class=\"hljs-keyword\">type</span> Result = Merge<ParseURL<<span class=\"hljs-string\">'https://username:password@example.com:443/p/a/t/h?k1=v1&k2=v2#h'</span>>>\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>可以在 <a href=\"https://www.typescriptlang.org/play?ts=4.1.0-pr-40336-8#code/C4TwDgpgBACghgJwM4Rgg9sdBjdAbAHgEkAaKAQQGUAVAPigF4AoKVqIqCAD2AgDsAJkigADACQBvAJZ8AZhASwAvgC4A9Gskz5igEoQkwJSKgB+KAG0q1KADIoEqGAxZceFbChKy+wwF0oDz4IADcFJiZQSFhEFHIAV2AAC2Iya3pmNnZOHn4hUS05BQolAAFCnShfIxNTFjZyHN5BYXFpIsUAVVUK4phjM0trOwcoeJQEPjgAWwgPTrIwOCQkAHd0BAEPGC8fA2AAlXrWKxoRx3GFKdmPRu8q-cOhmjIiPwio6HhkCAAJdEMqQoNAyx2y3Ga+Ta2mKvyUmnalWqAzqWV+TTyrV6igAcjMID1EX0NjUzGDvigYCSCFSEMB6BDMVBgmFFOYWcUjlkKahqbT6RiWlAYYp+WSsqcbPZHEkAcBrnMoHjZosSdsSbsHv5AmDJecoLLDAqPOj7tVDmCOYogqFwp8oAARKQAcykwEYUAA5AAGT1QAA+XoAjH7A56AEyhr0AZijnoALHGAKxxgBscYA7HGABxxgCcnsi4C+sV5dKBAHlBflDAgZM6PZ7PaCshxGUKm4Mq1y2G3ckK2k7XUZsVrSaje9WsUTFABhJKIJSSZG1cml-kEapkNoVpcSeeLkT0HusK2BZm2hAfYsxH7wZIKoHpRhgvuQ6ci5SmUcrwZ66VOHAD74h4IgIv0Jj3CI34SCuFqtlOBQzsoADEP77CizxSqMSzATcojgQMUFobBGEiPBk7tlCo4QX+wwAbhSTGgRki0fcTZPFa17RDyACK8QKCAT4gi+CFUa0MGfrxSgkZ+v7mP+owAI4CQgIDbKW-GCUQvDTEgBC8fQxHLmRFGsG+TLQaO0m1Fh+oqYJGk-Fpak6RAekGUZZAceekqvO89p8apIBuR5RAtmwtb1ohHAKWZ4L9vknZxTqYmJR+HRQAA0koDCjgAakotjoYYmEWI4ADWEDqdlZAhHAeACR4+WagAdO1QXabp+nVLQ8UWQOo45cVyHyZYlXVR4WV1Q1TXMvEeB4G1HWacFoU9fsfWpZR6VIZ+OV5chhW2eVUBVTV01QPVjWKi1Sj9Yh0KZTlJ0TRdM03UEC1LfdvnvEWPGlr8ywpKQwJ0KJO3vqIsmZXCJ30aMC5IEkoEkfDXhPJK-2BaWnS6AAMsQiFRXwzoRawPJoJgOD4ECEhKAyu0WJ+1hkHJjzimwPIJMkm77GkIniZYrMvMKmXmlzlNA3K-OGILEPCyzmVs+LSKcxO0t3kBTH4nLwAK0z0PK5Uqsc9qmu3igLlCVu4NG0yJvFGbEsa2uPzAyj+uG4hTuKNYATmMMJ4Xqy55njaYeR5yocx1xAPQAAsgozoQAQEMMKMFg7DIZ3VegshQDYyxF9nATC8lsfWrAfgeNQZdeNx0C+At7qZ8nCCpzSeOEwQnpJMAwBgEg6hqJckwgUsKzrJspTcDMYB4BArW4NMKjxvG0ZqGAahwGowBqEkpgVUGDAhEGtgVeGZ-hihSTNrQTBAA\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TypeScript Playground</a> 上进行试玩。</p>\n<h2 data-id=\"heading-2\">分析</h2>\n<h3 data-id=\"heading-3\">概览</h3>\n<p>所有名字以 <code>Parse</code> 开头的类型都是负责完成解析工作。其中，除了 <code>ParseHash</code> 和 <code>ParseURL</code> 这两个类型以外，其它的用于解析的类型都返回一个二元组。元组的第一个分量是 AST（Abstract Syntax Tree），第二个分量是完成当前解析工作剩下的字符串内容（为了给后面的解析继续使用）。<code>ParseHash</code> 只返回一元组是因为 hash 已经是 URL 中最后的一部分，不再需要继续解析；而 <code>ParseURL</code> 作为整个 parser 没必要返回未被解析的字符串。</p>\n<h3 data-id=\"heading-4\">解析「协议」</h3>\n<p>这个比较简单，位于 <code>://</code> 前面的就是 URL 的「协议」，后面的用 <code>infer Rest</code> 把它提取出来就可以了。因为协议是必需的，因此解析失败要返回 <code>never</code>。</p>\n<p>得到「协议」之后，利用联合类型将 <code>{ protocol: P }</code> 合并到 AST 对象中。后面的 parser 也一样。</p>\n<h3 data-id=\"heading-5\">解析「认证」</h3>\n<p>这一部分的格式是 <code>username:password@xxx</code>，其中 <code>password</code> 是可以被忽略的，<code>@</code> 后面的字符串就是主机名及后续的内容。需要注意的是，「认证」这一部分是可选的（我们看到的大多数 URL 也没有这一部分），因此缺少这一部分时不能返回 <code>never</code>，而要将输入的字符串和 AST 原样返回：<code>[AST, I]</code>。</p>\n<p>我们先用一个 conditional types 将位于 <code>@</code> 前面的字符串提取出来。如果输入的字符串不符合这个格式，说明没有「认证」这一部分，返回 <code>[AST, I]</code>。</p>\n<p>取出这一部分字符串后，我们还分别对「用户名」和「密码」进行分析。由于「密码」是可选的，因此采用跟上面同样的办法去分别提取「用户名」和「密码」。最后将提取到的信息合并到 AST 中并返回剩下的字符串。</p>\n<h3 data-id=\"heading-6\">解析「主机名」</h3>\n<p>实际上我把「主机名」的解析和「端口」的解析写在了一起，因为「端口」不是必需的，不过我在这里分开分析。</p>\n<p>从输入的字符串开始一直到 <code>/</code> 出现为止，这中间的字符串都是「主机」，而「主机」包含「主机名」和「端口」。<code>/</code> 往后的就是「路径」（path）。</p>\n<p>「主机名」与「端口」之间以冒号隔开，所以可以先用带有冒号的 pattern 尝试进行匹配。如果匹配上了，说明里面含有「端口」，然后将「主机名」和「端口」分别提取出来。如果不匹配，说明不包含「端口」，则整个字符串都是「主机名」，这时候将整个字符串当作「主机名」返回即可。</p>\n<h3 data-id=\"heading-7\">解析「端口」</h3>\n<p>这里我们还对「端口」进行简单的检查，确保里面只有数字字符。</p>\n<p>首先定义一个 <code>Digit</code> 类型，里面包含了从 <code>0</code> 到 <code>9</code> 的 10 个数字。</p>\n<p>然后 <code>ParsePort</code> 类型需要两个类型参数。第一个参数是输入的字符串；第二个参数是输出的字符串，它在解析过程中会被跟其它字符串一起拼接，在最后被返回。为了方便，我们指定一个空的字符串用作默认类型。这个有点像 reduce 操作。</p>\n<p>开始检查输入的字符串的第一个字符是不是数字，如果不是则表示解析失败，并返回 <code>never</code>。如果是数字，则使用 <code>infer Rest</code> 将后面的字符串提取出来以便继续解析。</p>\n<p>但我们还需要获取刚刚匹配到的第一个数字，以便我们把它拼接起来并返回。因此，我们借助另外一个 conditional types 并在里面使用 <code>infer</code> 来提取刚刚那个数字。后面直接使用 <code>${Rest}</code> 即可，而不是用 <code>infer</code>。</p>\n<p>接着就将剩下的字符串 <code>Rest</code> 作为输入传入到 <code>ParsePort</code> 类型中，而 <code>ParsePort</code> 的第二个参数则是新拼接的字符串 <code>${O}${Char}</code>。如此递归下去，直到遇到空的字符串。</p>\n<p>遇到空的字符串，表示已经完成解析，此时将 <code>ParsePort</code> 类型的第二个参数原样返回即可。</p>\n<h3 data-id=\"heading-8\">解析「路径」</h3>\n<p>这个比较简单。要注意的是，URL 中的 query string 和 hash 是可选的，因此要对这些情况分别处理——即允许以 <code>?</code> 或 <code>#</code> 作为 pattern 中的分隔符。</p>\n<p>还要一点要注意的是，这时候输入的字符串已经不再以 <code>/</code> 开头，因为在前面解析「主机」的时候已经被 consume 掉，所以在 AST 中还要手动把它补上。</p>\n<h3 data-id=\"heading-9\">解析「查询字符串」</h3>\n<p>同样要注意 hash 可选的问题。</p>\n<p>另外，我还对 query string 中的 key-value 进行解析并组成数组。（但在 TypeScript 的类型系统里这其实是元组，是有固定长度的）</p>\n<p>解析 key-value 不算太复杂，适当地处理一些 edge cases 即可。例如，只有 key 而没有 value 的情况，还有 key-value 位于整个 query string 的最后这种情况。</p>\n<p>这里利用了 <code>[T, ...T[]]</code> 的语法来实现了递归并组成最终的数组。元组中的每个元素是一个 object：<code>{ key: K, value: V }</code>，如果某个 key 没有对应的 value，则 value 为 <code>null</code>。</p>\n<p>需要注意的是，可能是由于 TypeScript 的限制，需要在最前面加入 <code>string extends I</code>  的判断才不会导致 TypeScript 报告类型递归的深度太深的问题。</p>\n<h3 data-id=\"heading-10\">解析 Hash</h3>\n<p>这个就很简单了。Hash 在最后的位置，直接把输入字符串当作解析结果直接返回就是了。注意需要带上前缀的 <code>#</code>，因为这个 <code>#</code> 已经在它的 conditional types 中被 consume 掉。</p>\n<h3 data-id=\"heading-11\">组合</h3>\n<p>类型 <code>ParseURL</code> 就是将上面所有的 parser 组合起来，一步一步地解析。每完成一步的解析，就检查它是否返回一个二元组：如果是，表示解析成功，并将得到的 AST 和剩下的字符串传递给下一个 parser 继续解析；如果不是（这里解析失败会返回 <code>never</code>），则返回 <code>never</code> 而不再继续解析。解析到最后会得到 AST。</p>\n<h3 data-id=\"heading-12\">整理</h3>\n<p>由于每个 parser 都利用了联合类型将当前解析得到的信息与原 AST 合并，因此最终生成的 AST 类型会像这样：</p>\n<pre><code class=\"hljs language-typescript copyable\" lang=\"typescript\"><span class=\"hljs-keyword\">type</span> AST = { protocol: P } & { hostname: H } & { pathname: P }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>这样很难看。于是我弄了一个类型 <code>Merge</code> 将所有的内容合并到一个 object 中，使 AST 显得更直观。</p>\n<p>在整理的过程中，我还使用了与模板字符串类型一起的新特性：mapped type <code>as</code> clauses。利用这个特性，将 AST 中那些值为空字符串的属性去掉。原理是 <code>as</code> clauses 中返回 <code>never</code> 表示不包含这个属性。</p>\n<p>全文完。</p></div> <div class=\"image-viewer-box\" data-v-78c9b824><!----></div>","descriptionType":"text/html","publishedDate":"Wed, 02 Sep 2020 23:17:41 +0000","feedId":12740,"bgimg":"","linkMd5":"ca078640f07a108f4745ef6f867f2989","bgimgJsdelivr":"","metaImg":"","author":"gplane","publishedOrCreatedDate":1599295203164},{"createdTime":"2020-09-05 16:40:03","updatedTime":"2020-09-05 16:40:03","title":"Vuex设计理念兼谈Flux","link":"https://juejin.im/post/6868213807446949896","description":"<div class=\"markdown-body\"><h2 data-id=\"heading-0\">前文</h2>\n<p>当你刚开始使用Vuex的时候，相信你都感到过一些别扭，或者有类似的疑惑：</p>\n<ul>\n<li>组件间状态共享为什么不推荐使用eventBus？</li>\n<li>为什么修改Vuex的store需要使用<code>$store.commit('updateXXX', value)</code>，而不是直接<code>$store.XXX = value</code>？</li>\n</ul>\n<p>这些疑问甚至会让你怀疑Vuex存在的意义，在了解Vuex的理念之前，这些确实是灵魂之问，让我们带着疑问来看看为什么吧。</p>\n<h2 data-id=\"heading-1\">本文将讨论以下信息</h2>\n<ol>\n<li>Vuex的使用背景</li>\n<li>Flux架构的介绍</li>\n<li>Vuex如何践行Flux理念</li>\n</ol>\n<p>本文假设你已经了解Vuex的基本使用，也不会具体介绍Vuex实现方式。</p>\n<h2 data-id=\"heading-2\">Vuex是什么</h2>\n<blockquote>\n<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用<code>集中式</code>存储管理应用的所有组件的状态，并以相应的规则保证状态以一种<code>可预测</code>的方式发生变化。</p>\n</blockquote>\n<p>注意这两个关键词：<code>集中式</code>，<code>可预测</code></p>\n<h3 data-id=\"heading-3\">背景问题</h3>\n<blockquote>\n<p>当我们的vue应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：</p>\n<ul>\n<li>多个视图依赖于同一状态。</li>\n<li>来自不同视图的行为需要变更同一状态。</li>\n</ul>\n<p>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p>\n</blockquote>\n<p>为了减少干扰，我们暂时简单的用MVC来代替vue的MVVM，，上面描述的数据的流动问题可能如图所示：</p>\n<p></p><figure><img class=\"lazyload\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dcc368021204e5f8509aaa6bdb38073~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"><figcaption></figcaption></figure><p></p>\n<p></p><figure><img class=\"lazyload\" src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e7880c3839840a7b13ca9d106a6319d~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"><figcaption></figcaption></figure><p></p>\n<p>甚至夸张一点</p>\n<p></p><figure><img class=\"lazyload\" src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a81aebdaddc44615a53c926eb396e0f6~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"><figcaption></figcaption></figure><p></p>\n<p>很容易理解，复杂的数据流动必定会带来维护上的困难。</p>\n<p>那么现在我们就可以回答第一个问题了-- 组件间传值为什么不使用eventBus？</p>\n<p>答：eventBus虽然是事件总线，但是却缺少了<code>数据中心仓库</code>，没有把组件的共享状态抽取出来，是<code>去中心化</code>的，分散地传递数据，需要手动维护数据。</p>\n<p>以下可以看做是eventBus的数据流动</p>\n<p></p><figure><img class=\"lazyload\" src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75e5bdce65154688b6eb31c4b310e0e2~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"><figcaption></figcaption></figure><p></p>\n<p>举个例子。有一个display组件，他的作用是展现App根组件上increment的当前值。你新招了两个新员工，给他们分配了两个任务。</p>\n<ol>\n<li>你让小A开发一个新的计数器在一个新的组件(childDisplay)，实现点击一次增加increment一次，并在组件内展现increment当前的数字。这个计数器订阅了increment，点击计数器成功让display和childDisplay显示increment增加1后的数字。小A完成这个任务便push代码了</li>\n<li>让小B开发按钮组件，这个按钮组件向App实例emit了一个reset事件，将重置App上increment为0，小B也完成这个任务便push代码了</li>\n<li>这个时候你会发现当你点击A组件时，在display和childDiplay上都成功显示了increment增加1以后的数字，但点击B组件触发reset事件时，根组件上的increment重置为了0，但由于小B并不知道A组件也订阅了increment这个数据，导致A组件状态没有更新。</li>\n</ol>\n<p>即缺少<code>集中式</code>状态中心，需要手动维护数据导致的。</p>\n<h3 data-id=\"heading-4\">问题结论</h3>\n<blockquote>\n<p>因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！--<code>集中式</code></p>\n<p>通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。--<code>可预测</code></p>\n<p>这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux 和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。</p>\n</blockquote>\n<p>注意，此时提到了Vuex与Flux关系，现在我们来讲讲Flux架构的基本理念</p>\n<h2 data-id=\"heading-5\">Flux架构</h2>\n<p>在前文我们提到了因为多向数据流带来状态管理上的问题，Flux 试图通过强制<code>单向数据流</code>来解决这个复杂度。</p>\n<p>在这种架构当中，Views 查询 Stores（而不是 Models），并且用户交互将会触发 Actions，Actions 则会被提交到一个集中的 Dispatcher 当中。当 Actions 被派发之后，Stores 将会随之更新自己并且通知 Views 进行修改，这些 Store 当中的修改会进一步促使 Views 查询新的数据。</p>\n<p>一个简单的Flux架构模型如下</p>\n<p></p><figure><img class=\"lazyload\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c72b159254646edb0baae469219fb63~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"><figcaption></figcaption></figure><p></p>\n<p>当有多个Store和View被添加后，复杂的Flux流程图如下图所示</p>\n<p></p><figure><img class=\"lazyload\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf2414de96b145c48e08f562bc7a2179~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"><figcaption></figcaption></figure><p></p>\n<p>如果还是让你感觉到复杂的话，只留下Flux最精简的流程：</p>\n<p></p><figure><img class=\"lazyload\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d1b9a5d00164e6aa264fe60d571d765~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"><figcaption></figcaption></figure><p></p>\n<p>Flux 最大的特点就是查询和更新的分离，View 从 Store 获取的数据是只读的。而 Stores 只能通过 Actions 被更新，这就会影响 Store 本身而不是那些只读的数据。</p>\n<p>由此可见即使是复杂的Flux应用，它的数据流和程序的运作过程仍然是清晰可辨的，所以这样做的好处就是<code>可预测</code>。</p>\n<h2 data-id=\"heading-6\">Vuex中对于Flux架构的实践</h2>\n<p>Vuex与Flux的理念一拍即合，都是期望用单向数据流动来代替多向数据流动，从而减少维护成本。那么，Vuex是怎么实践Flux呢？</p>\n<p>先来看看Vuex官网的一张图\n</p><figure><img class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3642ff8a91a043cb88224d033b5b7ddc~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"><figcaption></figcaption></figure><p></p>\n<p>Vuex中保留了action与store的概念，并且引入了新的mutation。action和mutation广义上来说都是提交对store修改，不同的是action可以是异步的，并且大多数情况是在event handler中提交，通过$store.dispatch方法；唯一修改 Store 的地方只能通过mutation，而且mutation必须是同步的，直接对store进行修改，所以便可以保证：<code>集中式</code>，<code>可预测</code>。</p>\n<p>此外，Vuex也获得官方调试工具vue-devtools的支持，提供了零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>\n<p>现在就可以回答第二个问题：为什么修改store需要使用<code>$store.commit('updateXXX', value)</code>，而不是直接<code>$store.XXX = value</code>？</p>\n<p>使用<code>$store.commit('updateXXX', value)</code>，每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照（action的意义也在于此），使用<code>$store.XXX = value</code>则无法获得开发工具的追踪功能，也不能对这个修改动作进行统一的管理。这么做的好处就是为了做到<code>单向数据流</code>, 保证<code>可预测</code>。</p>\n<h2 data-id=\"heading-7\">小结</h2>\n<p>本文从多个vue组件状态传递这个难题出发，到介绍提出单向数据流的Flux架构，再到Vuex对Flux的实践，围绕<code>集中式</code>，<code>可预测</code>进行分析，相信你多多少少会有自己的收获，本文如有错误，欢迎大家斧正！</p></div> <div class=\"image-viewer-box\" data-v-78c9b824><!----></div>","descriptionType":"text/html","publishedDate":"Thu, 03 Sep 2020 02:58:52 +0000","feedId":12740,"bgimg":"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dcc368021204e5f8509aaa6bdb38073~tplv-k3u1fbpfcp-zoom-1.image","linkMd5":"5b861f318eaaadc1eaeb62d7ac7843c6","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn20@2020_5/2020/09/05/08-40-10-544_906875279e0cf757.webp","destWidth":660,"destHeight":449,"sourceBytes":17049,"destBytes":15848,"author":"caozhong","articleImgCdnMap":{"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dcc368021204e5f8509aaa6bdb38073~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn20@2020_5/2020/09/05/08-40-10-544_906875279e0cf757.webp","https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e7880c3839840a7b13ca9d106a6319d~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn52@2020_6/2020/09/05/08-40-12-529_5af59e0d6a49669a.webp","https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a81aebdaddc44615a53c926eb396e0f6~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn36@2020_4/2020/09/05/08-40-12-943_6ad734aadc235b1e.webp","https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75e5bdce65154688b6eb31c4b310e0e2~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn23@2020_4/2020/09/05/08-40-13-125_efeaf36ca6fcd5a0.webp","https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c72b159254646edb0baae469219fb63~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn28@2020_1/2020/09/05/08-40-14-812_7ebbf625a447c1b2.webp","https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf2414de96b145c48e08f562bc7a2179~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn39@2020_1/2020/09/05/08-40-14-363_91bf69590fa4916f.webp","https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d1b9a5d00164e6aa264fe60d571d765~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn48@2020_6/2020/09/05/08-40-20-809_b6dadc579e087d31.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3642ff8a91a043cb88224d033b5b7ddc~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn31@2020_4/2020/09/05/08-40-12-200_0f725749054f6929.webp"},"publishedOrCreatedDate":1599295203161}],"record":{"createdTime":"2020-09-05 16:40:03","updatedTime":"2020-09-05 16:40:03","feedId":12740,"fetchDate":"Sat, 05 Sep 2020 08:40:03 +0000","fetchMs":693,"handleMs":8753,"totalMs":27902,"newArticles":0,"totalArticles":5,"status":1,"type":0,"ip":"a7d54052e8673d13da536025ef9c200b","hostName":"europe67*","requestId":"b9b5f867cf3d4938be0d3510bcef9a60_12740","contentType":"application/xml; charset=utf-8","totalBytes":132704,"bgimgsTotal":2,"bgimgsGithubTotal":2,"articlesImgsTotal":10,"articlesImgsGithubTotal":10,"successGithubMap":{"myreaderx8":1,"myreaderx6":1,"myreaderx4":1,"myreaderx32":1,"myreaderx22":1,"myreaderx11":1,"myreaderx12":1,"myreaderx2":1,"myreaderx31":1,"myreaderx29":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:37:55","updatedTime":"2020-09-01 09:22:18","id":12740,"name":"掘金前端","url":"https://rsshub.app/juejin/category/frontend","subscriber":null,"website":null,"icon":"https://juejin.im/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx65/cdn53@2020_2/2020/09/05/08-40-02-078_24cb365749d306f2.ico","description":"掘金前端 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)","weekly":null,"link":"https://juejin.im"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":29458,"tmpBodyImgCdnBytes":103246,"tmpBgImgCdnBytes":0,"extra4":{"start":1599295193716,"total":0,"statList":[{"spend":695,"msg":"获取xml内容"},{"spend":8753,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":10199,"msg":"正文链接上传到cdn"}]},"extra5":10,"extra6":10,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://europe-25.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe62.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-004.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-028.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe66.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-016.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-040.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-012.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09faf6f4b00e4c80b3170fbacbed3eee~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":902,"destHeight":558,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn16@2020_2/2020/09/05/08-40-03-764_1474814b53265c7f.webp","sourceBytes":34370,"destBytes":13610,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":1498,"convertSpendMs":20,"createdTime":"2020-09-05 16:40:03","host":"us-036*","referer":"https://juejin.im/post/6868156733383147527","linkMd5ListStr":"863f5db43d00ce6fa8bbb75c1a0de5ee,863f5db43d00ce6fa8bbb75c1a0de5ee","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"33.6 KB","destSize":"13.3 KB","compressRate":"39.6%"},{"code":1,"isDone":false,"source":"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dcc368021204e5f8509aaa6bdb38073~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":660,"destHeight":449,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn20@2020_5/2020/09/05/08-40-10-544_906875279e0cf757.webp","sourceBytes":17049,"destBytes":15848,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":8080,"convertSpendMs":34,"createdTime":"2020-09-05 16:40:03","host":"us-024*","referer":"https://juejin.im/post/6868213807446949896","linkMd5ListStr":"5b861f318eaaadc1eaeb62d7ac7843c6,5b861f318eaaadc1eaeb62d7ac7843c6","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"16.6 KB","destSize":"15.5 KB","compressRate":"93%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc1313b88a3540bc9ffc32e500508e6c~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":902,"destHeight":558,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn43@2020_2/2020/09/05/08-40-12-157_b468351814fcd131.webp","sourceBytes":55694,"destBytes":21476,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":1461,"convertSpendMs":20,"createdTime":"2020-09-05 16:40:11","host":"us-016*","referer":"https://juejin.im/post/6868156733383147527","linkMd5ListStr":"863f5db43d00ce6fa8bbb75c1a0de5ee","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"54.4 KB","destSize":"21 KB","compressRate":"38.6%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3642ff8a91a043cb88224d033b5b7ddc~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":701,"destHeight":551,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn31@2020_4/2020/09/05/08-40-12-200_0f725749054f6929.webp","sourceBytes":24744,"destBytes":16166,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":1815,"convertSpendMs":21,"createdTime":"2020-09-05 16:40:11","host":"europe62*","referer":"https://juejin.im/post/6868213807446949896","linkMd5ListStr":"5b861f318eaaadc1eaeb62d7ac7843c6","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.2 KB","destSize":"15.8 KB","compressRate":"65.3%"},{"code":1,"isDone":false,"source":"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e7880c3839840a7b13ca9d106a6319d~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":517,"destHeight":320,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn52@2020_6/2020/09/05/08-40-12-529_5af59e0d6a49669a.webp","sourceBytes":32386,"destBytes":9786,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":1996,"convertSpendMs":12,"createdTime":"2020-09-05 16:40:11","host":"europe66*","referer":"https://juejin.im/post/6868213807446949896","linkMd5ListStr":"5b861f318eaaadc1eaeb62d7ac7843c6","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"31.6 KB","destSize":"9.6 KB","compressRate":"30.2%"},{"code":1,"isDone":false,"source":"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a81aebdaddc44615a53c926eb396e0f6~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":390,"destHeight":221,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn36@2020_4/2020/09/05/08-40-12-943_6ad734aadc235b1e.webp","sourceBytes":67450,"destBytes":10440,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":2122,"convertSpendMs":8,"createdTime":"2020-09-05 16:40:11","host":"us-040*","referer":"https://juejin.im/post/6868213807446949896","linkMd5ListStr":"5b861f318eaaadc1eaeb62d7ac7843c6","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"65.9 KB","destSize":"10.2 KB","compressRate":"15.5%"},{"code":1,"isDone":false,"source":"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75e5bdce65154688b6eb31c4b310e0e2~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":431,"destHeight":504,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn23@2020_4/2020/09/05/08-40-13-125_efeaf36ca6fcd5a0.webp","sourceBytes":66772,"destBytes":16672,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":2553,"convertSpendMs":25,"createdTime":"2020-09-05 16:40:11","host":"us-012*","referer":"https://juejin.im/post/6868213807446949896","linkMd5ListStr":"5b861f318eaaadc1eaeb62d7ac7843c6","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"65.2 KB","destSize":"16.3 KB","compressRate":"25%"},{"code":1,"isDone":false,"source":"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf2414de96b145c48e08f562bc7a2179~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":660,"destHeight":574,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn39@2020_1/2020/09/05/08-40-14-363_91bf69590fa4916f.webp","sourceBytes":16866,"destBytes":12386,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":3342,"convertSpendMs":45,"createdTime":"2020-09-05 16:40:11","host":"us-028*","referer":"https://juejin.im/post/6868213807446949896","linkMd5ListStr":"5b861f318eaaadc1eaeb62d7ac7843c6","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"16.5 KB","destSize":"12.1 KB","compressRate":"73.4%"},{"code":1,"isDone":false,"source":"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c72b159254646edb0baae469219fb63~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":660,"destHeight":177,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn28@2020_1/2020/09/05/08-40-14-812_7ebbf625a447c1b2.webp","sourceBytes":13181,"destBytes":7414,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":4295,"convertSpendMs":7,"createdTime":"2020-09-05 16:40:11","host":"europe-25*","referer":"https://juejin.im/post/6868213807446949896","linkMd5ListStr":"5b861f318eaaadc1eaeb62d7ac7843c6","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12.9 KB","destSize":"7.2 KB","compressRate":"56.2%"},{"code":1,"isDone":false,"source":"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d1b9a5d00164e6aa264fe60d571d765~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":697,"destHeight":450,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn48@2020_6/2020/09/05/08-40-20-809_b6dadc579e087d31.webp","sourceBytes":12217,"destBytes":8906,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":9996,"convertSpendMs":12,"createdTime":"2020-09-05 16:40:11","host":"us-004*","referer":"https://juejin.im/post/6868213807446949896","linkMd5ListStr":"5b861f318eaaadc1eaeb62d7ac7843c6","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"11.9 KB","destSize":"8.7 KB","compressRate":"72.9%"}],"successGithubMap":{"myreaderx8":1,"myreaderx6":1,"myreaderx4":1,"myreaderx32":1,"myreaderx22":1,"myreaderx11":1,"myreaderx12":1,"myreaderx2":1,"myreaderx31":1,"myreaderx29":1},"failGithubMap":{}}