{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2021-05-02 14:10:21","updatedTime":"2021-05-02 14:10:21","title":"啊？排序字段的大小也会影响排序性能？？？","link":"http://itindex.net/detail/61377-%E6%8E%92%E5%BA%8F-%E5%A4%A7%E5%B0%8F-%E6%8E%92%E5%BA%8F","description":"<div>  <h4>导读</h4>\n  <p>作为一个交友平台，我们还是以它的核心功能，即搜索用户来开启今天的分享。</p>\n  <p>假设我们要搜索年龄在18到24之间的女生，同时要求按年龄排序，如果平台注册用户达到千万级，那么，我们一般会对这个搜索结果分页，避免结果页加载很慢，所以，为了实现这个功能，基于用户表，我们会写这样一条SQL：</p>\n  <pre>   <code>SELECT * FROM user WHERE age &gt;= 18 AND age &lt;= 24 AND sex = 0 ORDER BY age LIMIT 0, 50\n复制代码</code></pre>\n  <p>对索引实践有较多经验的同学应该已经想到了，如果我要在用户规模达到千万级时，还要保证这条SQL的查询效率，我们肯定会加一个覆盖索引   <code>index_age_sex(age,sex)</code>，保证查询大规模用户时，性能杠杠滴！</p>\n  <p>那么，为什么使用覆盖索引，查询性能就好呢？所以，今天我就先讲解一下什么是覆盖索引及MySQL使用覆盖索引查找记录的过程，了解这个过程后，我们就知道为什么使用覆盖索引查找更快了。</p>\n  <h4>覆盖索引</h4>\n  <p>覆盖索引就是将排序字段加入索引中，保证该索引树的节点包含排序字段。</p>\n  <p>你可以结合《为什么MySQL能够支撑千万数据规模的快速查询？》和《IN字段查询多少个值最合适？》两篇文章理解一下上面这条SQL，对覆盖索引   <code>index_age_sex(age,sex)</code>是如何查找的，通过这个查找过程我们会发现很重要的一点：</p>\n  <p>   <strong>    <code>index_age_sex</code>索引树的叶子节点包含排序字段    <code>age</code>，保证了    <code>age</code>自身已排序。</strong></p>\n  <p>所以，MySQL只需要2步就可以查找到满足条件的有序结果：</p>\n  <ol>\n   <li>遍历    <code>index_age_sex</code>索引树中的叶子节点，找到满足条件的记录主键id</li>\n   <li>通过上面的主键id到聚簇索引的叶子节点查找对应的记录</li>\n</ol>\n  <p>正是排序字段在索引树叶子节点有序，减少了不必要的排序过程，所以，大大提升了SQL查询的效率。</p>\n  <p>如果此时，通过上面的用户搜索，我找到了喜欢的女生，然后关注了她，彼此通过平台的聊天功能聊得也很好。但是，之后有一段时间工作忙，没有及时再跟对方有更多的沟通，忙完之后，你想再找她聊天，由于你只是模糊记得她的账号中的一部分，同时，记得她的昵称前半部分字母比较小，于是，你试图通过在自己关注列表中搜索昵称关键字来快速查找她，此时的查询SQL变成：</p>\n  <pre>   <code>SELECT * FROM user WHERE user_name LIKE &quot;%am%&quot; AND age &gt;= 18 AND age &lt;= 24 AND sex = 0 ORDER BY age, user_name LIMIT 0, 50\n复制代码</code></pre>\n  <p>假设现在我们的用户表user中已经添加了索引   <code>index_un_age_sex(user_name,age,sex)</code>，表示给字段   <code>user_name</code>、   <code>age</code>和   <code>sex</code>添加了一个联合索引   <code>index_un_age_sex</code>，但是根据上面覆盖索引的查找过程，我们发现上面这条SQL，由于查询条件中   <code>user_name</code>为字符串两端模糊匹配，所以，无法通过索引   <code>index_un_age_sex</code>查找用户，即无法命中索引   <code>index_un_age_sex</code>，这在大规模用户的场景下，势必影响查询性能。那么，此时，我们有什么办法解决这个问题呢？</p>\n  <p>我们先用explain语句来分析上面这条SQL，我们看到explain结果中出现了   <code>Using index condition; Using where; Using filesort</code>，像下面这样：</p>\n  <p>   <img alt=\"image-20210206192623928.png\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/576ebfb19632455bbed17003e367e1ce~tplv-k3u1fbpfcp-watermark.image\"></img></p>\n  <p>   <code>Using index condition; Using where; Using filesort</code>是什么意思？其实，这个关键字描述了这样一个过程：</p>\n  <ol>\n   <li>MySQL先使用索引    <code>index_age_sex</code>过滤出部分用户记录，对应上面关键字中的    <code>Using index</code></li>\n   <li>使用条件中的    <code>user_name</code>字段模糊匹配，从步骤1的结果中再过滤出部分用户记录，对应上面关键字中的    <code>Using where</code></li>\n   <li>对上一步得到的用户记录进行排序，对应上面关键字中的    <code>Using filesort</code></li>\n</ol>\n  <p>这下你大概知道Filesort是怎么一回事了。</p>\n  <h4>Filesort</h4>\n  <p>Filesort表示MySQL使用了临时文件对where条件过滤的中间结果进行排序。我们就以上面使用Filesort的SQL为例，看一下具体的排序过程：</p>\n  <ol>\n   <li>\n    <p>命中索引     <code>index_age_sex</code>(字段     <code>age</code>和     <code>sex</code>的联合索引)，在索引树     <code>index_age_sex</code>中查找     <code>age &gt;= 18 AND age &lt;= 24 AND sex = 0</code>的用户记录，详细查找过程，可以顺序阅读《为什么MySQL能够支撑千万数据规模的快速查询？》和《InnoDB是顺序查找B-Tree叶子节点的吗？》两篇文章。</p>\n</li>\n   <li>\n    <p>顺序遍历上一步中的查找结果，查找满足     <code>user_name LIKE &quot;%am%”</code>的记录。</p>\n</li>\n   <li>\n    <p>顺序遍历上一步中的查找结果并排序，这里MySQL使用了快速排序，MySQL给每个线程分配一块内存用于排序，这块内存区域叫做     <code>sort_buffer</code>。关于快速排序，很多同学在大学里已经学过了，我就不详细讲解这个过程了，只说一下两种情况：</p>\n    <p>(1) 当SELECT中的字段 + 排序字段的值大小小于等于参数     <code>max_length_for_sort_data</code>，在     <code>sort_buffer</code>中写入全字段，然后，对排序字段排序。</p>\n    <p>比如：本章《覆盖索引》中的SQL，SELECT子句为*，假如SELECT中的字段 + 排序字段的值大小小于等于参数     <code>max_length_for_sort_data</code>，即表全部字段大小总和小于等于参数     <code>max_length_for_sort_data</code>，MySQL将user表中满足查询条件的记录的所有字段写入     <code>sort_buffer</code>，然后，依次对字段     <code>age</code>和     <code>username</code>排序，最终得到排序后的完整结果。</p>\n    <p>(2) 当SELECT中的字段 + 排序字段的值大小大于参数     <code>max_length_for_sort_data</code>，在     <code>sort_buffer</code>中写入排序字段+主键ID，然后，对排序字段排序，最后，根据主键ID到聚簇索引取出对应记录。</p>\n    <p>比如：本章《覆盖索引》中的SQL，SELECT子句为*，假如SELECT中的字段 + 排序字段的值大小大于参数     <code>max_length_for_sort_data</code>，即表全部字段大小总和大于参数     <code>max_length_for_sort_data</code>，MySQL将user表中满足查询条件的记录     <code>age</code>、     <code>username</code>和     <code>id</code>写入     <code>sort_buffer</code>，然后，依次对字段     <code>age</code>和     <code>username</code>排序，排序后，根据主键id到聚簇索引获取对应记录。</p>\n</li>\n</ol>\n  <p>对比上面两种排序的过程，我们发现采用下面的方案进行排序，会多一次回表(聚簇索引查找)的过程，如果聚簇索引在磁盘上，那么就会产生磁盘IO，影响性能。</p>\n  <p>所以，我们可以采用下面两个手段避免回表查询：</p>\n  <ol>\n   <li>    <strong>SQL中的SELECT部分中的字段尽量不要用     <code>*</code>，而是指定字段，确保SELECT中的字段 + 排序字段的值大小小于等于参数     <code>max_length_for_sort_data</code>，这样MySQL就会采用上面的(1)方案排序</strong></li>\n   <li>    <strong>如果一定要使用     <code>*</code>，那么，务必保证表中字段的总长度不超过     <code>max_length_for_sort_data</code>，这样MySQL也会采用上面的(1)方案排序</strong></li>\n</ol>\n  <p>那么，是不是只要保证SELECT中的字段 + 排序字段的值大小小于等于参数   <code>max_length_for_sort_data</code>，排序性能一定是最好的呢？</p>\n  <p>假如本章《覆盖索引》中的排序字段   <code>username</code>，我们设计它的长度为32字节和200字节，同时保证了SELECT中的字段 + 排序字段的值大小小于等于参数   <code>max_length_for_sort_data</code>，那么，两种字段长度的设计对排序性能有什么不同的影响呢？</p>\n  <p>这时，我就不得不提一下这个排序比较的过程，通过这个过程的讲解，我来揭开上面这个问题的答案！</p>\n  <h5>排序比较</h5>\n  <p>MySQL对排序字段进行排序对比时使用了C函数库的   <code>memcmp</code>，因为   <code>memcmap</code>充分利用了64位CPU的特性，所以，性能非常高！为什么呢？</p>\n  <p>这里我就以64位CPU为例，看一下   <code>memcmp</code>的比较过程，   <code>memcmp</code>函数转化为汇编指令后，主要包含了下面这些过程：</p>\n  <ol>\n   <li>通过MOV指令，从内存中读取用于比较的两个入参地址，并将地址分别写入两个rax寄存器</li>\n   <li>通过NOP指令，对上面的rax寄存器中的地址做内存对齐</li>\n   <li>通过CMP指令，对没有对齐的部分，单字节(byte)比较</li>\n   <li>通过CMP指令，针对对齐的部分，以32个字节为单位，通过冗余指令，做4次8字节(qword)比较，为什么以32字节单位，拆分4次比较两个入参地址？下面我会讲到。</li>\n   <li>通过CMP指令，针对步骤4中不足32个字节的部分，以8个字节为单位，做8字节(qword)比较</li>\n   <li>通过CMP指令，针对步骤5中最后剩余不足8个字节的部分，做单字节(byte)比较</li>\n</ol>\n  <p>我先以上面的第一步的MOV指令为例，看下指令在CPU中的处理过程。</p>\n  <p>下图是Intel的Nehalem处理器的内核架构，我们从上到下看一下MOV指令的处理过程：\n   <img alt=\"image-20210214230725035.png\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/700d8be6a1994aecb4b94be3ef872fbf~tplv-k3u1fbpfcp-watermark.image\"></img></p>\n  <ol>\n   <li>\n    <p>指令提取单元(IFU)从ITLB读取指令MOV在CPU L1 Cache中的位置</p>\n</li>\n   <li>\n    <p>指令提取单元(IFU)从分支预测单元(BPU)读取if...then中分支then中的起始指令，由于MOV指令操作不涉及if条件，所以，该读取结果为空</p>\n</li>\n   <li>\n    <p>指令提取单元(IFU)根据步骤1得到的位置到CPU L1 Cache中的     <code>Instruction Cache</code>中找到指令MOV，并提取MOV</p>\n</li>\n   <li>\n    <p>指令提取单元(IFU)将MOV指令传递给解码器(ILD)</p>\n</li>\n   <li>\n    <p>解码器(ILD)对指令MOV进行预解码，校验指令长度等，如果超过指定长度，会做其他处理，     <strong>ps：这个将来我会在其他文章中详细讲解。</strong></p>\n</li>\n   <li>\n    <p>解码器(ILD)将MOV指令传递给指令队列(Instruction Queue)进行缓冲，ps：当指令非常多时，指令队列可以收集一批指令后，在一个时钟周期批量将这批指令下传，一批4条指令</p>\n</li>\n   <li>\n    <p>指令队列将MOV指令传递给指令解码器(Instruction Decoders)进行解码，指令解码器包含4个解码器：1个复杂解码器(Complex Deocder)和3个简单解码器(Simple Decoder)，前者用于解析复杂的一条指令，将其解析为1 ~ 4条微指令(不包含1)，后者将一条简单指令解析为一条微指令，微指令一般缩写为uop。上面     <code>memcmp</code>函数中的MOV指令含义是从内存中读取用于比较的两个入参地址，并将地址分别写入两个rax寄存器，属于复杂指令，所以，这条MOV指令被解析为两条微指令uops：从内存中读取入参地址     <code>uop1</code>和将地址写入rax寄存器     <code>uop2</code></p>\n</li>\n   <li>\n    <p>指令解析器将分解的两个uops传递给指令解码队列(IDQ)，进行指令去重</p>\n    <p>(1) 指令解码队列(IDQ)依次将两个uops传递给循环检测器(LSD)，循环检测器检查uop是否存在类似while这样的循环语句，如果存在，对循环中重复的uop去重。由于     <code>uop1</code>和     <code>uop2</code>均不存在循环，所以，循环检测器直接返回     <code>uop1</code>和     <code>uop2</code>给指令解码队列(IDQ)</p>\n    <p>(2) 微指令序列号生成器给     <code>uop1</code>和     <code>uop2</code>生成两个序列号，将序列号传递给指令解码队列，分配给     <code>uop1</code>和     <code>uop2</code></p>\n</li>\n   <li>\n    <p>指令解码队列将     <code>uop1</code>和     <code>uop2</code>传递给MicroOps Fusion，做微指令聚合。对于有些指令相同的，在这里就聚合为一条微指令 + 指令个数。     <code>uop1</code>和     <code>uop2</code>不相同，所以，不做聚合。</p>\n</li>\n   <li>\n    <p>至此，CPU完成了指令MOV的执行前工作，这个过程一般称作Front End。接着，Fusion将     <code>uop1</code>和     <code>uop2</code>传递给分配器Allocator，进行微指令执行单元分配</p>\n    <p>(1) Dispatcher分别将微指令     <code>uop1</code>和     <code>uop2</code>写入重排序缓冲区(ROB)，等待指令执行结果。</p>\n    <p>(2) Dispatcher同时将微指令写入中继器(RS)，对于     <code>uop1</code>和     <code>uop2</code>，这个写入是有区别的：</p>\n    <p>​ a.      <code>uop1</code>是一个内存读取操作，所以，写入重排序缓冲区的     <code>uop1</code>是完整微指令：     <code>uop1 ADDR1</code>，     <code>ADDR1</code>为读取的内存地址。又因为     <code>uop1</code>无依赖前置数据，所以，Dispatcher将     <code>uop1</code>完整指令同时写入中继器(RS)，待执行。</p>\n    <p>​ b.      <code>uop2</code>是一个写寄存器操作，写入源数据当前不存在，所以，Dispatcher不会将     <code>uop2</code>的完整指令写入中继器(RS)</p>\n</li>\n   <li>\n    <p>中继器分析哪些微指令有依赖关系，哪些没有依赖关系，有依赖关系的串行执行，无依赖的并行执行。由于，当前中继器中只包含     <code>uop1</code>，所以，只给     <code>uop1</code>分配执行单元，即通过port2端口，将     <code>uop1</code>完整指令传递给AGU Load执行单元，执行     <code>uop1</code>，即该执行单元从内存排序缓冲区(MOB)中读取地址为     <code>ADDR1</code>，如果不存在，再从CPU L1 Data Cache中读取，L1 Data Cache中没有，继续从L2 Cache读取，L2 Cache没有，就从L3 Data Cache中读取，CPU三级缓存中都没有，那只能通过地址总线从内存中读取     <code>ADDR1</code></p>\n</li>\n   <li>\n    <p>当AGU Load执行单元成功读取到     <code>ADDR1</code>后，发送完成状态     <code>COMPLETE</code>和     <code>ADDR1</code>到重排序缓冲区(ROB)</p>\n</li>\n   <li>\n    <p>重排序缓冲区将     <code>uop1</code>执行结果(状态)和     <code>ADDR1</code>写入回退寄存器文件(RRF)</p>\n</li>\n   <li>\n    <p>重排序缓冲区移除微指令     <code>uop1</code></p>\n</li>\n   <li>\n    <p>此时，重排序缓冲区中有了     <code>ADDR1</code>和步骤10写入的     <code>uop2</code>，于是，重排序缓冲区将     <code>uop2</code>和     <code>ADDR1</code>传递给Dispatcher，Dispatcher从寄存器别名表中命名一个rax寄存器，构造完整的     <code>uop2</code>指令，即     <code>uop2 rax, ADDR1</code>，表示将     <code>ADDR1</code>写入rax寄存器，然后，将完整指令写入中继器(RS)，准备执行     <code>uop2</code>。</p>\n</li>\n   <li>\n    <p>中继器通过port 3端口分配AGU Store Address执行单元执行     <code>uop2</code>，将     <code>ADDR1</code>写入rax寄存器</p>\n</li>\n   <li>\n    <p>执行单元执行成功后，将结果状态     <code>COMPLETE</code>写入重排序缓冲区</p>\n</li>\n   <li>\n    <p>重排序缓冲区将     <code>uop2</code>执行结果(     <code>uop2,rax</code>)写入回退寄存器文件(RRF)，记录下rax寄存器中的值     <code>ADDR1</code></p>\n</li>\n   <li>\n    <p>重排序缓冲区移除微指令     <code>uop2</code></p>\n</li>\n</ol>\n  <p>通过上面的步骤，你应该了解一条指令在CPU中的处理过程，那么，回到上面的一个问题：   <strong>为什么    <code>memcmp</code>函数，要以32字节单位，拆分4次比较两个入参地址呢？</strong></p>\n  <ol>\n   <li>从上图可以发现，右侧L2 Data Cache和底部L1 Data Cache连接在一起，用来传输数据，而这个传输的带宽为256bit，即一次最多可以传输32个字节的数据，所以，将入参地址以32字节为单位执行    <code>uop1</code>微指令，可以充分利用L2 Data Cache和L1 Data Cache之间的带宽。</li>\n   <li>结合上面的步骤11，由于CPU每个时钟周期可以同时从中继器(RS)中挑选可并发执行的4条微指令并发执行，所以，将相同的比较指令CMP拆分4次，同时对比较的入参地址的4个部分并发比较，最后将比较结果汇总。这样，原来串行执行4次的比较任务变成的并行的一次执行，性能将大大提升。</li>\n</ol>\n  <p>结合上面   <code>memcmp</code>函数中MOV指令在CPU中的处理过程，我们知道如果用于比较的排序字段长度超过32字节，而此时该字段值不在CPU L1 Cache中，那么，CPU不得不分多次将字段值写入L1 Cache，影响了性能，所以，   <strong>建议排序字段的大小不要超过32字节</strong>。</p>\n  <h4>小结</h4>\n  <p>通过本章内容的讲解，我们知道了一些排序优化的方法：</p>\n  <ol>\n   <li>将排序字段加入索引，实现覆盖索引，避免排序</li>\n   <li>SQL中SELECT字段 + 排序字段的值大小小于等于参数    <code>max_length_for_sort_data</code>，可以避免回表查询，提升性能</li>\n   <li>排序字段大小尽量不要超过32字节，充分利用64位CPU的特性，提升排序性能</li>\n</ol>\n  <h4>思考题</h4>\n  <p>关于《覆盖索引》中的那条SQL：</p>\n  <pre>   <code>SELECT * FROM user WHERE user_name LIKE &quot;%am%&quot; AND age &gt;= 18 AND age &lt;= 24 AND sex = 0 ORDER BY age, user_name LIMIT 0, 50\n复制代码</code></pre>\n  <p>本章中，使用了快速排序对   <code>age,username</code>排序，有没有更好的办法，提升排序的性能？</p></div><div> <a href=\"http://itindex.net/\"  title=\"IT 资讯\"><img src=\"http://itindex.net/images/iconWarning.gif\" title=\"IT 资讯\" border=\"0\"/> </a>","descriptionType":"text/html","publishedDate":"Sat, 01 May 2021 17:29:23 +0000","feedId":13052,"bgimg":"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/576ebfb19632455bbed17003e367e1ce~tplv-k3u1fbpfcp-watermark.image","linkMd5":"08628cdc7c5bc0de903f7cedfdbd126d","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn11@2020_1/2021/05/02/06-11-25-712_52173bd15360e9e2.webp","destWidth":1972,"destHeight":188,"sourceBytes":48414,"destBytes":20758,"author":"","articleImgCdnMap":{"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/576ebfb19632455bbed17003e367e1ce~tplv-k3u1fbpfcp-watermark.image":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn11@2020_1/2021/05/02/06-11-25-712_52173bd15360e9e2.webp","https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/700d8be6a1994aecb4b94be3ef872fbf~tplv-k3u1fbpfcp-watermark.image":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn54@2020_5/2021/05/02/06-11-28-895_8b35cfa221549e2d.webp","http://itindex.net/images/iconWarning.gif":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn51@2020_1/2021/05/02/06-11-26-514_fca5840e49ccdcfd.webp"},"publishedOrCreatedDate":1619935821588}],"record":{"createdTime":"2021-05-02 14:10:21","updatedTime":"2021-05-02 14:10:21","feedId":13052,"fetchDate":"Sun, 02 May 2021 06:10:21 +0000","fetchMs":136,"handleMs":14,"totalMs":68134,"newArticles":0,"totalArticles":20,"status":1,"type":0,"ip":"79b59b7ab14b8d981e3d8a220e20848a","hostName":"us-015*","requestId":"9bdc21f6e1d846b6841b6a7c636aa8f1_13052","contentType":"text/xml;charset=UTF-8","totalBytes":77392,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":3,"articlesImgsGithubTotal":3,"successGithubMap":{"myreaderx7":1,"myreaderx11":1,"myreaderx33":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:38:12","updatedTime":"2020-09-05 16:45:18","id":13052,"name":"IT社区推荐资讯 - ITIndex.net","url":"http://itindex.net/feed.jsp","subscriber":237,"website":null,"icon":"http://itindex.net/images/logo.gif","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn43@2020_4/2020/09/05/08-44-56-218_d0d0f0b8681d9991.gif","description":"IT社区推荐资讯 - ITIndex.net","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":20758,"tmpBodyImgCdnBytes":56634,"tmpBgImgCdnBytes":0,"extra4":{"start":1619935821250,"total":0,"statList":[{"spend":324,"msg":"获取xml内容"},{"spend":14,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":3250,"msg":"正文链接上传到cdn"}]},"extra5":3,"extra6":3,"extra7ImgCdnFailResultVector":[null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://europe-25.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-24.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/576ebfb19632455bbed17003e367e1ce~tplv-k3u1fbpfcp-watermark.image","sourceStatusCode":200,"destWidth":1972,"destHeight":188,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn11@2020_1/2021/05/02/06-11-25-712_52173bd15360e9e2.webp","sourceBytes":48414,"destBytes":20758,"targetWebpQuality":75,"feedId":13052,"totalSpendMs":3097,"convertSpendMs":13,"createdTime":"2021-05-02 14:11:23","host":"europe-24*","referer":"http://itindex.net/detail/61377-%E6%8E%92%E5%BA%8F-%E5%A4%A7%E5%B0%8F-%E6%8E%92%E5%BA%8F","linkMd5ListStr":"08628cdc7c5bc0de903f7cedfdbd126d,08628cdc7c5bc0de903f7cedfdbd126d","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"47.3 KB","destSize":"20.3 KB","compressRate":"42.9%"},{"code":1,"isDone":false,"source":"http://itindex.net/images/iconWarning.gif","sourceStatusCode":200,"destWidth":14,"destHeight":13,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn51@2020_1/2021/05/02/06-11-26-514_fca5840e49ccdcfd.webp","sourceBytes":108,"destBytes":266,"targetWebpQuality":75,"feedId":13052,"totalSpendMs":698,"convertSpendMs":3,"createdTime":"2021-05-02 14:11:26","host":"europe-24*","referer":"http://itindex.net/detail/61377-%E6%8E%92%E5%BA%8F-%E5%A4%A7%E5%B0%8F-%E6%8E%92%E5%BA%8F","linkMd5ListStr":"08628cdc7c5bc0de903f7cedfdbd126d","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"108 B","destSize":"266 B","compressRate":"246.3%"},{"code":1,"isDone":false,"source":"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/700d8be6a1994aecb4b94be3ef872fbf~tplv-k3u1fbpfcp-watermark.image","sourceStatusCode":200,"destWidth":974,"destHeight":1638,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn54@2020_5/2021/05/02/06-11-28-895_8b35cfa221549e2d.webp","sourceBytes":476131,"destBytes":56368,"targetWebpQuality":75,"feedId":13052,"totalSpendMs":3089,"convertSpendMs":49,"createdTime":"2021-05-02 14:11:26","host":"europe-25*","referer":"http://itindex.net/detail/61377-%E6%8E%92%E5%BA%8F-%E5%A4%A7%E5%B0%8F-%E6%8E%92%E5%BA%8F","linkMd5ListStr":"08628cdc7c5bc0de903f7cedfdbd126d","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"465 KB","destSize":"55 KB","compressRate":"11.8%"}],"successGithubMap":{"myreaderx7":1,"myreaderx11":1,"myreaderx33":1},"failGithubMap":{}}