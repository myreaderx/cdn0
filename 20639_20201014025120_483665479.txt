{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-14 10:47:15","updatedTime":"2020-10-14 10:47:15","title":"Introduction to Windows Kernel Security Research","link":"https://blog.cmpxchg8b.com/2013/05/introduction-to-windows-kernel-security.html","description":"<br />A few months ago, I <a href=\"https://twitter.com/taviso/status/309157606247768064\" target=\"_blank\">mentioned</a> a crash I'd encountered under memory pressure on windows. I was hoping sharing a reproducer might stimulate someone who was interested in learning about kernel debugging to investigate, learning some new skills and possibly getting some insight into researching security issues, potentially getting a head start on discovering their own.<br /><br />Sadly, I've yet to hear back from anyone who had done any work on it. I think the path subsystem is obscure enough that &nbsp;it felt too daunting a task for someone new to jump into, and the fact that the reproducer is not reliable might have been scary. I've decided to help get you started, hopefully someone will feel inspired enough to continue. Before reading this post, I assume you're comfortable with kd, IDA Pro and debugging without source code.<br /><br />First some background, hopefully you're already familiar with <a href=\"http://msdn.microsoft.com/en-us/library/windows/hardware/ff566501(v=vs.85).aspx\" target=\"_blank\">GDI basics</a> and understand <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/dd162786(v=vs.85).aspx\" target=\"_blank\">Pens</a>, <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/dd183394(v=vs.85).aspx\" target=\"_blank\">Brushes</a> and so on. <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/dd162779(v=vs.85).aspx\" target=\"_blank\">Paths</a> are basically shapes that can be created by moving between points, they can be straight lines, or irregular and composed of curves, arcs, etc. Internally, a path is stored as a linked list of it's components (points, curves, etc).<br /><br /><a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/dd162779(v=vs.85).aspx\">http://msdn.microsoft.com/en-us/library/windows/desktop/dd162779(v=vs.85).aspx</a><br /><br />The path subsystem is very old (pre-NT?), and uses it's own object allocator called PATHALLOC. PATHALLOC is relatively simple, it's backed (indirectly) by HeavyAllocPool() with the tag 'tapG', but does include it's own simple freelist implementation to reduce calls to HeavyAllocPool.<br /><br />The PATHALLOC entrypoints are newpathalloc() and freepathalloc(), if you look at the code you'll see it's very simple and easy to understand. Notice that if an allocation cannot be satisfied from the freelist, newpathalloc will always memset zero allocations via PALLOCMEM(), similar to what you might expect from calloc.<br /><br />However, take a look at the freelist check, if the allocation is satisfied from the freelist, it skips the memset zero. Therefore, it <i>might</i> return allocations that have not been initialized, and callers must be sure to do this themselves.<br /><br />It turns out, getting an object from the freelist happens quite rarely, so the few cases that don't initialize their path object have survived over 20 years in NT. The case we're going to take a look at is EPATHOBJ::pprFlattenRec().<br /><br />Hopefully you're familiar with the concept of flattening, the process of translating a bezier curve into a sequence of lines. The details of how this works are not important, just remember that curves are converted into lines.<br /><br /><br /><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://i.msdn.microsoft.com/dynimg/IC32740.gif\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"><img border=\"0\" height=\"141\" src=\"http://i.msdn.microsoft.com/dynimg/IC32740.gif\" width=\"400\" /></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\">Flattening a curve, illustration from GraphicsPath MSDN <a href=\"http://msdn.microsoft.com/en-us/library/xk7x2780.aspx\" target=\"_blank\">documentation</a>.</td></tr></tbody></table><br /><br />EPATHOBJ::pprFlattenRec() is an internal routine for applying this process to a linked list of PATHRECORD objects. If you follow the logic, you can see that the PATHRECORD object retrieved from newpathrec() is mostly initialized, but with one obvious error:<br /><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">EPATHOBJ::pprFlattenRec(_PATHRECORD *)+33:</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">.text:BFA122CD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; eax, [esi+PATHRECORD.prev] &nbsp; &nbsp; &nbsp; ; load old prev</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">.text:BFA122D0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;edi</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">.text:BFA122D1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; edi, [ebp+new] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get the new PATHRECORD</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">.text:BFA122D4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; [edi+PATHRECORD.prev], eax &nbsp; &nbsp; &nbsp; ; copy prev pointer over</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">.text:BFA122D7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lea &nbsp; &nbsp; eax, [edi+PATHRECORD.count] &nbsp; &nbsp; &nbsp;; save address of count member</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">.text:BFA122DA &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xor &nbsp; &nbsp; edx, edx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set count to zero</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">.text:BFA122DC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; [eax], edx</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">.text:BFA122DE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; ecx, [esi+PATHRECORD.flags] &nbsp; &nbsp; &nbsp;; load flags</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">.text:BFA122E1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and &nbsp; &nbsp; ecx, 0FFFFFFEFh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; clear bezier flag (bezier means divide points by 3 because you need two control points and an ending point).</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">.text:BFA122E4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; [edi+PATHRECORD.flags], ecx &nbsp; &nbsp; &nbsp;; copy old flags over</span><br /><br />The next pointer is never initialized! Most of the time you want a new list node to have the next pointer set to NULL, so this works if you don't get your object from the freelist, but otherwise it won't work!<br /><br />How can we verify this hypothesis? Let's patch newpathrec() to always set the next pointer to a recognisable<br />value, and see if we can reproduce the crash (Note: I don't use conditional breakpoints because of the performance overhead, if you're using something fancy like virtualkd, it's probably better to use them).<br /><br />There's a useless assertion in the checked build I don't need, I'll just overwrite the code with mov [pathrec-&gt;next], dword 0x41414141, like this (you can use the&nbsp;built in&nbsp;assembler if you want, but I don't like the syntax):<br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\"><br /></span><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">kd&gt; ba e 1 win32k!EPATHOBJ::newpathrec+31</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">kd&gt; g</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">Breakpoint 0 hit</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">win32k!EPATHOBJ::newpathrec+0x31:</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">96611e9a 83f8ff &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmp &nbsp; &nbsp; eax,0FFFFFFFFh</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">kd&gt; eb @eip c7 41 F0 41 41 41 41 90 90 90 90 90 90 90 90 90 90</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">kd&gt; bc *</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">kd&gt; g</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">Access violation - code c0000005 (!!! second chance !!!)</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">win32k!EPATHOBJ::bFlatten+0x15:</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">9661252c f6400810 &nbsp; &nbsp; &nbsp; &nbsp;test &nbsp; &nbsp;byte ptr [eax+8],10h</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">kd&gt; r</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">eax=41414141 ebx=9659017e ecx=a173bbec edx=00000001 esi=a173bbec edi=03010034</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">eip=9661252c esp=a173bbe4 ebp=a173bc28 iopl=0 &nbsp; &nbsp; &nbsp; &nbsp; nv up ei pl nz na pe nc</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">cs=0008 &nbsp;ss=0010 &nbsp;ds=0023 &nbsp;es=0023 &nbsp;fs=0030 &nbsp;gs=0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; efl=00010206</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">win32k!EPATHOBJ::bFlatten+0x15:</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: x-small;\">9661252c f6400810 &nbsp; &nbsp; &nbsp; &nbsp;test &nbsp; &nbsp;byte ptr [eax+8],10h &nbsp; &nbsp; &nbsp; ds:0023:41414149=??</span><br /><br />This looks like convincing evidence that a newpathrec() caller is not initialising new objects correctly. When bFlatten() tried to traverse the linked list of PATHREC objects, it doesn't find the NULL it was expecting.<br /><br />We know the PATHREC list starts at EPATHOBJ+8, the pointer to the first element is in PATHREC+14, and the next pointer is at +0, so we can look at the chain of PATHREC objects that caused bFlatten() to crash in kd.<br /><br /><ol><li>The EPATHOBJ is in ecx (Because of the <a href=\"https://en.wikipedia.org/wiki/Thiscall#thiscall\" target=\"_blank\">thiscall</a> calling convention).</li><li>The PATHREC list starts at poi(ecx+8)</li><li>The first element in the list is at poi(poi(ecx+8)+14) (i.e. the head pointer)</li><li>The next pointer for the first record will be at +0 in the PATHREC&nbsp;poi(poi(poi(ecx+8)+14))</li></ol><div>We can keep adding poi() calls until we find the bad next pointer:</div><div><br /></div><div><ul><li>this</li><ul><li>ecx</li></ul><li>this-&gt;pathlist</li><ul><li>poi(ecx+8)</li></ul><li>this-&gt;pathlist-&gt;head</li><ul><li>poi(poi(ecx+8)+14)</li></ul><li>this-&gt;pathlist-&gt;head-&gt;next</li><ul><li>poi(poi(poi(ecx+8)+14))</li></ul><li>this-&gt;pathlist-&gt;head-&gt;next-&gt;next</li><ul><li>poi(poi(poi(poi(ecx+8)+14)))</li></ul><li>this-&gt;pathlist-&gt;head-&gt;next-&gt;next-&gt;next</li><ul><li>poi(poi(poi(poi(poi(ecx+8)+14))))</li></ul><li>etc.</li></ul></div><br />Here is the object with the bad next pointer for me:<br /><br /><span style=\"font-family: Courier New, Courier, monospace;\">kd&gt; dd poi(poi(poi(ecx+8)+14))</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe9395a4 &nbsp;ff1fdde5 fe93904c 00000000 00000149</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe9395b4 &nbsp;01a6d0bf 00ec8b39 01a68f40 00ec19f2</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe9395c4 &nbsp;01a64da5 00eba8c0 01a60bee 00eb37a5</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe9395d4 &nbsp;01a5ca1b 00eac69f 01a5882d 00ea55af</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe9395e4 &nbsp;01a54623 00e9e4d5 01a503fd 00e97411</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe9395f4 &nbsp;01a4c1bb 00e90362 01a47f5e 00e892ca</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe939604 &nbsp;01a43ce6 00e82247 01a3fa52 00e7b1da</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe939614 &nbsp;01a3b7a2 00e74183 01a374d7 00e6d142</span><br /><br />The standard process for researching this kind of problem is to implement the various primitives we can chain together to get the behaviour we want reliably. These are the building blocks we use to control what's happening.<br /><br />Conceptually, this is something like:<br /><br />Primitive 1: Allocate a path object with as much contents controlled as possible.<br />Primitive 2: Get that path object released and added to the freelist.<br />Primitive 3: Trigger the bad allocation from the freelist.<br /><br />Once we have implemented these, we can chain them together to move an EPATHOBJ reliably into userspace, and then we can investigate if it's exploitable. Let's work on this.<br /><br /><u><b>Controlling the contents of a PATHREC object</b></u><br /><br />A PATHREC looks something like this:<br /><br /><span style=\"font-family: Courier New, Courier, monospace;\">struct PATHREC {</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; VOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*next;</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; VOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*prev;</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;flags;</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count; &nbsp; &nbsp; &nbsp; // Number of points in array</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; POINTFIX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; points[0]; &nbsp; // variable length array</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">};</span><br /><br />POINTFIX is <a href=\"http://msdn.microsoft.com/en-us/library/windows/hardware/ff566501(v=vs.85).aspx\" target=\"_blank\">documented</a> in msdn as \"A point structure that consists of {FIX x, y;}.\". Let's try adding a large number of points to a path consisting of recognisable values as x,y coordinates with PolyBezierTo() and see if we can find it.<br /><br />If we break during the bounds checking in newpathrec(), we should be able to dump out the points and see if we hit it.<br /><br />I wrote some code like this (pseudocode):<br /><br /><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; POINT &nbsp;*Points = calloc(8192, sizeof(POINT));</span><br /><span style=\"font-family: Courier New, Courier, monospace;\"><br /></span><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; while (TRUE) {</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; 8192; i++) {</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Points[i].x = 0xDEAD;</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Points[i].y = 0xBEEF;</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br /><span style=\"font-family: Courier New, Courier, monospace;\"><br /></span><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; &nbsp; &nbsp; BeginPath(Device);</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; &nbsp; &nbsp; PolyBezierTo(Device, Points, 8192 / 3);</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; &nbsp; &nbsp; EndPath(Device);</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">&nbsp; &nbsp; }</span><br /><br />And put a breakpoint in newpathrec(), and after some waiting, I see this:<br /><br /><span style=\"font-family: Courier New, Courier, monospace;\">kd&gt; ba e 1 win32k!EPATHOBJ::newpathrec+23 \"dd @ecx; gc\"</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">kd&gt; g</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe85814c &nbsp;000dead0 000beef0 000dead0 000beef0</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe85815c &nbsp;000dead0 000beef0 000dead0 000beef0</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe85816c &nbsp;000dead0 000beef0 000dead0 000beef0</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe85817c &nbsp;000dead0 000beef0 000dead0 000beef0</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe85818c &nbsp;000dead0 000beef0 000dead0 000beef0</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe85819c &nbsp;000dead0 000beef0 000dead0 000beef0</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe8581ac &nbsp;000dead0 000beef0 000dead0 000beef0</span><br /><span style=\"font-family: Courier New, Courier, monospace;\">fe8581bc &nbsp;000dead0 000beef0 000dead0 000beef0</span><br /><br />This confirms the theory, that this trick can be used to get our blocks on the freelist. I spent some time making this reliable.<br /><br /><b><u>Spamming the freelist with our POINTFIX structures</u></b><br /><b><u><br /></u></b>Lets make sure that our paths are full of curves with these points, and then flatten them to resize them (thus reducing the number of points). If it works, just by chance we should start to see the original testcase crashing at recognisable addresses.<br /><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">GDISRV:AllocateObject failed alloc of 2268 bytes</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">GDISRV:AllocateObject failed alloc of 2268 bytes</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">GDISRV:AllocateObject failed alloc of 2268 bytes</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">Access violation - code c0000005 (!!! second chance !!!)</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">9661252c f6400810 &nbsp; &nbsp; &nbsp; &nbsp;test &nbsp; &nbsp;byte ptr [eax+8],10h</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">kd&gt; r</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">eax=04141410 ebx=9659017e ecx=8ef67bec edx=00000001 esi=8ef67bec edi=03010034</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">eip=9661252c esp=8ef67be4 ebp=8ef67c28 iopl=0 &nbsp; &nbsp; &nbsp; &nbsp; nv up ei pl nz na po nc</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">cs=0008 &nbsp;ss=0010 &nbsp;ds=0023 &nbsp;es=0023 &nbsp;fs=0030 &nbsp;gs=0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; efl=00010202</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">win32k!EPATHOBJ::bFlatten+0x15:</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">9661252c f6400810 &nbsp; &nbsp; &nbsp; &nbsp;test &nbsp; &nbsp;byte ptr [eax+8],10h &nbsp; &nbsp; &nbsp; ds:0023:<b>04141418</b>=??</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">kd&gt; kv</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">ChildEBP RetAddr &nbsp;Args to Child &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">8ef67be4 965901ce 00000001 00000119 fe71cef0 win32k!EPATHOBJ::bFlatten+0x15 (FPO: [0,0,4])</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">8ef67c28 829e0173 03010034 001cfb48 76f0a364 win32k!NtGdiFlattenPath+0x50 (FPO: [Non-Fpo])</span><br /><span style=\"font-family: Courier New, Courier, monospace; font-size: xx-small;\">8ef67c28 76f0a364 03010034 001cfb48 76f0a364 nt!KiFastCallEntry+0x163 (FPO: [0,3] TrapFrame @ 8ef67c34)</span><br /><br />Success! Now we have at least some control over the address, which is something to work with. You can see in EPATHOBJ::bFlatten() the object is handed over to EPATHOBJ::pprFlattenRec(), which is a good place to start looking to look for exploitation opportunities, possibly turning this into code execution.<br /><br />You can copy my portable shellcode from my <a href=\"http://seclists.org/fulldisclosure/2010/Jan/341\" target=\"_blank\">KiTrap0D exploit</a> if you need one, which should work reliably on many different kernels, the source code is available here:<br /><br /><a href=\"http://lock.cmpxchg8b.com/c0af0967d904cef2ad4db766a00bc6af/KiTrap0D.zip\">http://lock.cmpxchg8b.com/c0af0967d904cef2ad4db766a00bc6af/KiTrap0D.zip</a><br /><div><br /></div><div>If nobody jumps in, I'll keep adding more notes. Feel free to ask me questions if you get stuck or need a hand!</div><div><br /></div><div>If you solve the mystery and determine this is a security issue, send me an email and I'll update this post. If you confirm it is exploitable, feel free to send your work to Microsoft if you feel so compelled, if this is your first time researching a potential vulnerability it might be an interesting experience.<br /><br />Note that Microsoft treat vulnerability researchers with great hostility, and are often very difficult to work with. I would advise only speaking to them under a pseudonym, using <a href=\"https://www.torproject.org/\" target=\"_blank\">tor</a> and anonymous email to protect yourself.</div>","descriptionType":"html","publishedDate":"Thu, 16 May 2013 02:12:00 +0000","feedId":20639,"bgimg":"http://i.msdn.microsoft.com/dynimg/IC32740.gif","linkMd5":"fe4d39657db7319a6d546fb1e8fbd660","author":"taviso","articleImgCdnMap":{"http://i.msdn.microsoft.com/dynimg/IC32740.gif":null},"publishedOrCreatedDate":1602643635707}],"record":{"createdTime":"2020-10-14 10:47:15","updatedTime":"2020-10-14 10:47:15","feedId":20639,"fetchDate":"Wed, 14 Oct 2020 02:47:15 +0000","fetchMs":246,"handleMs":120,"totalMs":244957,"newArticles":0,"totalArticles":12,"status":1,"type":0,"ip":"fa10cf689958fca83c3f2c65b7f12392","hostName":"us-038*","requestId":"a6bfbfd1932747349fdea5d47d18c6f8_20639","contentType":"application/atom+xml; charset=UTF-8","totalBytes":0,"bgimgsTotal":1,"bgimgsGithubTotal":0,"articlesImgsTotal":1,"articlesImgsGithubTotal":0,"successGithubMap":{},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:22:57","updatedTime":"2020-09-07 04:10:44","id":20639,"name":"Tavis Ormandy","url":"http://blog.cmpxchg8b.com/feeds/posts/default","subscriber":161,"website":null,"icon":"http://blog.cmpxchg8b.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx61/cdn58@2020_2/2020/09/06/20-10-40-274_ae8b8cb439cacbfe.ico","description":"Vulnerability Discovery, Mitigation and Exploitation.","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2020-10-14 10:51:20","updatedTime":"2020-10-14 10:51:20","id":null,"feedId":20639,"linkMd5":"fe4d39657db7319a6d546fb1e8fbd660"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1602643635329,"total":0,"statList":[{"spend":258,"msg":"获取xml内容"},{"spend":120,"msg":"解释文章"},{"spend":122969,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":122987,"msg":"正文链接上传到cdn"}]},"extra5":1,"extra6":0,"extra7ImgCdnFailResultVector":[null,null,null,null,null,null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://europe61.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://europe-60.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]}},"extra12ImgCdnSuccessResultVector":[],"successGithubMap":{},"failGithubMap":{}}