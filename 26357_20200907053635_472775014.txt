{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-09-07 13:35:51","updatedTime":"2020-09-07 13:35:51","title":"React Native 触摸事件处理详解","link":"https://www.race604.com/react-native-touch-event/","description":"<img src=\"https://img.race604.com/The_Golden_Gate_Bridge.jpeg\" alt=\"React Native 触摸事件处理详解\"><p>触控是移动设备的核心功能，也移动应用交互的基础，Android 和 iOS 各自都有完善的触摸事件处理机制。React Native（以下简称 RN）提供了一套统一的处理方式，能够方便的处理界面中组件的触摸事件、用户手势等。本文尝试介绍 RN 中触摸事件处理。</p>\n\n<h2 id=\"1rn\">1. RN 基本触摸组件</h2>\n\n<p>RN 的组件除了 Text，其他组件默认是不支持点击事件，也不能响应基本触摸事件，所以 RN 中提供了几个直接处理响应事件的组件，基本上能够满大部分的点击处理需求<code>TouchableHighlight</code>, <code>TouchableNativeFeedback</code>, <code>TouchableOpacity</code> 和 <code>TouchableWithoutFeedback</code>。因为这几个组件的功能和使用方法基本类似，只是 Touch 的反馈效果不一样，所以一般我们用 <code>Touchable**</code> 代替。<code>Touchable**</code> 有如下几个回调方法：</p>\n\n<ul>\n<li><code>onPressIn</code>：点击开始；</li>\n<li><code>onPressOut</code>：点击结束或者离开；</li>\n<li><code>onPress</code>：单击事件回调；</li>\n<li><code>onLongPress</code>：长按事件回调。</li>\n</ul>\n\n<p>它们的基本使用方法如下，这里以 TouchableHighlight 为例：</p>\n\n<pre><code>&#60;TouchableHighlight  \n  onPressIn={() =&#62; console.log(\"onPressIn\")}\n  onPressOut={() =&#62; console.log(\"onPressOut\")}\n  onPress={() =&#62; console.log(\"onPress\")}\n  onLongPress={() =&#62; console.log(\"onLongPress\")}\n  &#62;\n  &#60;Image\n    style={styles.button}\n    source={require('./img/rn_logo.png')} /&#62;\n&#60;/TouchableHighlight&#62;  \n</code></pre>\n\n<p>RN 中提供的触摸组件使用非常简单，可以参考 <a href=\"http://facebook.github.io/react-native/docs/touchablehighlight.html\">官方文档</a>，这里也不做详细的介绍了。下面主要介绍用户触摸事件处理。</p>\n\n<h2 id=\"2\">2. 单组件触摸事件处理</h2>\n\n<p>我们知道，RN 的组件默认不进行处理触摸事件。组件要处理触摸事件，首先要“申请”成为摸事件的响应者（Responder），完成事件处理以后，会释放响应者的角色。一个触摸事件处理周期，是从用户手指按下屏幕，到用户抬起手指抬起结束，这是用户的一次完整触摸操作。</p>\n\n<p>单个组件的单次操作交互处理的生命周期如下：</p>\n\n<p><img src=\"https://img.race604.com/7-1-responder-lifecycle.jpg\" alt=\"React Native 触摸事件处理详解\"></p>\n\n<p>我们来详细分析一下事件处理的生命周期，在整个事件处理的过程中，组件有可能处于两种身份中的一种，并且可以相互切换：<strong>非事件响应者</strong>和<strong>事件响应者</strong>。</p>\n\n<h4 id=\"\">非事件响应者</h4>\n\n<p>默认情况下，触摸事件输入不会直接传递给组件，不能进行事件响应处理，也就是非事件响应者。如果组件要进行触摸事件处理，首先要申请成为事件响应者，组件有如下两个属性可以做这样的申请：</p>\n\n<ul>\n<li><code>View.props.onStartShouldSetResponder</code>，这个属性接收一个回调函数，函数原型是 <code>function(evt): bool</code>，在触摸事件开始（touchDown）的时候，RN 会回调此函数，询问组件是否需要成为事件响应者，接收事件处理，如果返回 <code>true</code>，表示需要成为响应者；</li>\n<li><code>View.props.onMoveShouldSetResponder</code>，它和前一个属性类似，不过这是触摸是进行过程中（touchMove），RN 询问组件是否要成为响应者，返回 <code>true</code> 表示是。</li>\n</ul>\n\n<p>假如组件通过上面的方法返回了 <code>true</code>，表示发出了申请要成为事件响应者请求，想要接收后续的事件输入。因为同一时刻，只能有一个事件处理响应者，RN 还需要协调所有组件的事件处理请求，所以不是每个组件申请都能成功，RN 通过如下两个回调来通知告诉组件它的申请结果，：</p>\n\n<ul>\n<li><code>View.props.onResponderGrant: (evt) =&#62; {}</code>：表示申请成功，组件成为了事件处理响应者，这时组件就开始接收后序的触摸事件输入。一般情况下，这时开始，组件进入了激活状态，并进行一些事件处理或者手势识别的初始化。</li>\n<li><code>View.props.onResponderReject: (evt) =&#62; {}</code>：表示申请失败了，这意味者其他组件正在进行事件处理，并且它不想放弃事件处理，所以你的申请被拒绝了，后续输入事件不会传递给本组件进行处理。</li>\n</ul>\n\n<h4 id=\"\">事件响应者</h4>\n\n<p>如果通过上面的步骤，组件申请成为了事件响应者，后续的事件输入都会通过回调函数通知到组件，如下：</p>\n\n<ul>\n<li><code>View.props.onResponderStart: (evt) =&#62; {}</code>：表示手指按下时，成功申请为事件响应者的回调；</li>\n<li><code>View.props.onResponderMove: (evt) =&#62; {}</code>：表示触摸手指移动的事件，这个回调可能非常频繁，所以这个回调函数的内容需要尽量简单；</li>\n<li><code>View.props.onResponderRelease: (evt) =&#62; {}</code>：表示触摸完成（touchUp）的时候的回调，表示用户完成了本次的触摸交互，这里应该完成手势识别的处理，这以后，组件不再是事件响应者，组件取消激活。</li>\n<li><code>View.props.onResponderEnd: (evt) =&#62; {}</code>：表示组件结束事件响应的回调。</li>\n</ul>\n\n<p>从前面的图中也看到，在组件成为事件响应者期间，其他组件也可能会申请触摸事件处理。此时 RN 会通过回调询问你是否可以释放响应者角色让给其他组件。回调如下：</p>\n\n<pre><code>View.props.onResponderTerminationRequest: (evt) =&#62; bool  \n</code></pre>\n\n<p>如果回调函数返回为 <code>true</code>，则表示同意释放响应者角色，同时会回调如下函数，通知组件事件响应处理被终止了：</p>\n\n<pre><code>View.props.onResponderTerminate: (evt) =&#62; {}  \n</code></pre>\n\n<p>这个回调也会发生在系统直接终止组件的事件处理，例如用户在触摸操作过程中，突然来电话的情况。</p>\n\n<h4 id=\"\">事件数据结构</h4>\n\n<p>从前面我们看到，触摸事件处理的回调都有一个 <code>evt</code> 参数，包含一个触摸事件数据 <code>nativeEvent</code>。<code>nativeEvent</code> 的详细内容如下：</p>\n\n<ul>\n<li><code>identifier</code>：触摸的 ID，一般对应手指，在多点触控的时候，用来区分是哪个手指的触摸事件；</li>\n<li><code>locationX</code> 和 <code>locationY</code>：触摸点相对组件的位置；</li>\n<li><code>pageX</code> 和 <code>pageY</code>：触摸点相对于屏幕的位置；</li>\n<li><code>timestamp</code>：当前触摸的事件的时间戳，可以用来进行滑动计算；</li>\n<li><code>target</code>：接收当前触摸事件的组件 ID；</li>\n<li><code>changedTouches</code>：evt 数组，从上次回调上报的触摸事件，到这次上报之间的所有事件数组。因为用户触摸过程中，会产生大量事件，有时候可能没有及时上报，系统用这种方式批量上报；</li>\n<li><code>touches</code>：evt 数组，多点触摸的时候，包含当前所有触摸点的事件。</li>\n</ul>\n\n<p>这些数据中，最常用的是 <code>locationX</code> 和 <code>locationY</code> 数据，需要注意的是，因为这里是 Native 的数据，所以他们的单位是实际像素。如果要转换为 RN 中的逻辑单位，可以示使用如下方法：</p>\n\n<pre><code>var pX = evt.nativeEvent.locationX / PixelRatio.get();  \n</code></pre>\n\n<h2 id=\"3\">3. 嵌套组件事件处理</h2>\n\n<p>上一小节介绍的都是针对单个组件来说，事件处理的流程和机制。但是前面也提到了，当组件需要作为事件处理响应者时，需要通过 <code>onStartShouldSetResponder</code> 或者 <code>onMoveShouldSetResponder</code> 回调返回值为 <code>true</code> 来申请。假如当多个组件嵌套的时候，这两个回调都返回了 <code>true</code> 的时候，但是同一个只能有一个事件处理响应者，这种情况怎么处理呢？为了便于描述，假设我们的组件布局如下：</p>\n\n<p><img src=\"https://img.race604.com/7-2-nest-layout-demo.jpg\" alt=\"React Native 触摸事件处理详解\"></p>\n\n<p>在 RN 中，默认情况下使用冒泡机制，响应最深的组件最先开始响应，所以前面描述的这种情况，如图中，如果 A、B、C 三个组件的 <code>on*ShouldSetResponder</code> 都返回为 <code>true</code>，那么只有 C 组件会得到响应成为响应者。这种机制才能保证了界面所有的组件才能得到响应。但是有些情况下，可能父组件可能需要处理事件，而禁止子组件响应。RN 提供了一个劫持机制，也就是在触摸事件往下传递的时候，先询问父组件是否需要劫持，不给子组件传递事件，也就是如下两个回调：</p>\n\n<ul>\n<li><code>View.props.onStartShouldSetResponderCapture</code>：这个属性接收一个回调函数，函数原型是 <code>function(evt): bool</code>，在触摸事件开始（touchDown）的时候，RN 容器组件会回调此函数，询问组件是否要劫持事件响应者设置，自己接收事件处理，如果返回 <code>true</code>，表示需要劫持；</li>\n<li><code>View.props.onMoveShouldSetResponderCapture</code>：此函数类似，不过是在触摸移动事件（touchMove）询问容器组件是否劫持。</li>\n</ul>\n\n<p>可以把这种劫持机制看成是一种下沉机制，与上面的冒泡机制对应，我们可以总结 RN 事件处理流程如下图：</p>\n\n<p><img src=\"https://img.race604.com/7-3-touch-event-handle.jpg\" alt=\"React Native 触摸事件处理详解\"></p>\n\n<p>注，图中的 <strong>*</strong> 表示可以为 <em>Start</em> 或者 <em>Move</em>，例如 <em>on*ShouldSetResponderCapture</em> 表示 <code>onStartShouldSetResponderCapture</code> 或者 <code>onMoveShouldSetResponderCapture</code>，其他的类似。</p>\n\n<p>触摸事件开始，首先调用 A 组件的 <code>onStartShouldSetResponderCapture</code>，若此回调返回 <code>false</code>，则按照图传递到 B 组件，然后调用 B 组件 <code>onStartShouldSetResponderCapture</code>，若返回 <code>true</code>，则事件不再传递给 C 组件，直接调用本组件的 <code>onResponderStart</code>，则 B 组件就成为事件响应者，后续事件直接传递给它。其他的分析类似。</p>\n\n<p>注意到，图中还有 <code>onTouchStart/onTouchStop</code> 回调，这个回调并不受响应者的影响，在范围内的组件都会回调此函数，而且调用顺序是从最深层组件到最上层组件。</p>\n\n<h2 id=\"4\">4. 手势识别</h2>\n\n<p>前面只是介绍了简单的触摸事件处理机制及其使用方法，其实连续的触摸事件，可以组成一些更高级手势，例如我们最常见的滑动屏幕内容，双指缩放（Pinch）或者旋转图片都是通过手势识别完成的。</p>\n\n<p>因为有些手势是很常用的，RN 也提供了内置的手势识别库 <code>PanResponder</code>，它封装了上面的事件回调函数，对触摸事件数据进行加工，完成滑动手势识别，向我们提供更加高级有意义的接口，如下：</p>\n\n<ul>\n<li>onMoveShouldSetPanResponder: (e, gestureState) => bool</li>\n<li>onMoveShouldSetPanResponderCapture: (e, gestureState) => bool</li>\n<li>onStartShouldSetPanResponder: (e, gestureState) => bool</li>\n<li>onStartShouldSetPanResponderCapture: (e, gestureState) => bool</li>\n<li>onPanResponderReject: (e, gestureState) => {...}</li>\n<li>onPanResponderGrant: (e, gestureState) => {...}</li>\n<li>onPanResponderStart: (e, gestureState) => {...}</li>\n<li>onPanResponderEnd: (e, gestureState) => {...}</li>\n<li>onPanResponderRelease: (e, gestureState) => {...}</li>\n<li>onPanResponderMove: (e, gestureState) => {...}</li>\n<li>onPanResponderTerminate: (e, gestureState) => {...}</li>\n<li>onPanResponderTerminationRequest: (e, gestureState) => {...}</li>\n<li>onShouldBlockNativeResponder: (e, gestureState) => bool</li>\n</ul>\n\n<p>可以看到，这些接口与前面接收的基础回调基本上是一一对应的，其功能也是类似，这里就不再赘述。这里有一个特别的回调 <code>onShouldBlockNativeResponder</code> 表示是否用 Native 平台的事件处理，默认是禁用的，全部使用 JS 中的事件处理，注意此函数目前只能在 Android 平台上使用。不过这里回调函数都有一个新的参数 <code>gestureState</code>，这是与滑动相关的数据，是对基本触摸数据的分析处理，它的内容如下：</p>\n\n<ul>\n<li><code>stateID</code>：滑动手势的 ID，在一次完整的交互中此 ID 保持不变；</li>\n<li><code>moveX</code> 和 <code>moveY</code>：自上次回调，手势移动距离；</li>\n<li><code>x0</code> 和 <code>y0</code>：滑动手势识别开始的时候的在屏幕中的坐标；</li>\n<li><code>dx</code> 和 <code>dy</code>：从手势开始时，到当前回调是移动距离；</li>\n<li><code>vx</code> 和 <code>vy</code>：当前手势移动的速度；</li>\n<li><code>numberActiveTouches</code>：当期触摸手指数量。</li>\n</ul>\n\n<p>下面介绍一个简单的实例，本例实现可以使用手指拖动界面的圆形控件，使用实例如下：</p>\n\n<pre><code>import React from 'react';  \nimport {  \n  AppRegistry,\n  PanResponder,\n  StyleSheet,\n  View,\n  processColor,\n} from 'react-native';\n\nvar CIRCLE_SIZE = 80;  \nvar CIRCLE_COLOR = 'blue';  \nvar CIRCLE_HIGHLIGHT_COLOR = 'green';\n\nvar PanResponderExample = React.createClass({\n\n  statics: {\n    title: 'PanResponder Sample',\n    description: 'Shows the use of PanResponder to provide basic gesture handling.',\n  },\n\n  _panResponder: {},\n  _previousLeft: 0,\n  _previousTop: 0,\n  _circleStyles: {},\n  circle: (null : ?{ setNativeProps(props: Object): void }),\n\n  componentWillMount: function() {\n    this._panResponder = PanResponder.create({\n      onStartShouldSetPanResponder: (evt, gestureState) =&#62; true,\n      onMoveShouldSetPanResponder: (evt, gestureState) =&#62; true,\n      onPanResponderGrant: this._handlePanResponderGrant,\n      onPanResponderMove: this._handlePanResponderMove,\n      onPanResponderRelease: this._handlePanResponderEnd,\n      onPanResponderTerminate: this._handlePanResponderEnd,\n    });\n    this._previousLeft = 20;\n    this._previousTop = 84;\n    this._circleStyles = {\n      style: {\n        left: this._previousLeft,\n        top: this._previousTop\n      }\n    };\n  },\n\n  componentDidMount: function() {\n    this._updatePosition();\n  },\n\n  render: function() {\n    return (\n      &#60;View style={styles.container}&#62;\n        &#60;View\n          ref={(circle) =&#62; {\n            this.circle = circle;\n          }}\n          style={styles.circle}\n          {...this._panResponder.panHandlers}\n        /&#62;\n      &#60;/View&#62;\n    );\n  },\n\n  _highlight: function() {\n    const circle = this.circle;\n    circle &#38;&#38; circle.setNativeProps({\n      style: {\n        backgroundColor: processColor(CIRCLE_HIGHLIGHT_COLOR)\n      }\n    });\n  },\n\n  _unHighlight: function() {\n    const circle = this.circle;\n    circle &#38;&#38; circle.setNativeProps({\n      style: {\n        backgroundColor: processColor(CIRCLE_COLOR)\n      }\n    });\n  },\n\n  _updatePosition: function() {\n    this.circle &#38;&#38; this.circle.setNativeProps(this._circleStyles);\n  },\n\n  _handlePanResponderGrant: function(e: Object, gestureState: Object) {\n    this._highlight();\n  },\n  _handlePanResponderMove: function(e: Object, gestureState: Object) {\n    this._circleStyles.style.left = this._previousLeft + gestureState.dx;\n    this._circleStyles.style.top = this._previousTop + gestureState.dy;\n    this._updatePosition();\n  },\n  _handlePanResponderEnd: function(e: Object, gestureState: Object) {\n    this._unHighlight();\n    this._previousLeft += gestureState.dx;\n    this._previousTop += gestureState.dy;\n  },\n});\n\nvar styles = StyleSheet.create({  \n  circle: {\n    width: CIRCLE_SIZE,\n    height: CIRCLE_SIZE,\n    borderRadius: CIRCLE_SIZE / 2,\n    backgroundColor: CIRCLE_COLOR,\n    position: 'absolute',\n    left: 0,\n    top: 0,\n  },\n  container: {\n    flex: 1,\n    paddingTop: 64,\n  },\n});\n</code></pre>\n\n<p>可见，在 <code>componentWillMount</code> 中创建一个 <code>PanResponder</code> 实例，并设置想好相关的属性，然后把这个对象设置给 View 的属性，如下:</p>\n\n<pre><code>&#60;View  \n  {...this._panResponder.panHandlers}\n/&#62;\n</code></pre>\n\n<p>其余的代码也比较简单，这里就不详述了。</p>\n\n<h2 id=\"5\">5. 总结</h2>\n\n<p>通过上面的介绍，可以看到 RN 中提供了类似 Native 平台的事件处理机制，所以也可以实现各种的触摸事件处理，甚至也可以实现复杂的手势识别。</p>\n\n<p>在嵌套组件的事件处理中，RN 中提供了“冒泡”和“下沉”两个方向的事件处理，这有点类似于 Android Native 上不久前才支持的 <a href=\"http://www.race604.com/android-nested-scrolling/\">NestedScrolling</a>，这就提供更加强大的事件处理机制。</p>\n\n<p>另外需要注意，因为 RN 的异步通信和执行机制，前面描述的所有回调函数都是在 JS 线程中，并不是 Native 的 UI 线程，而 Native 平台的 Touch 事件都是在 UI 线程中。所以在 JS 中通过 Touch 或者手势实现动画，可能会延迟的问题。</p>","descriptionType":"html","publishedDate":"Sun, 19 Jun 2016 12:11:15 +0000","feedId":26357,"bgimg":"https://img.race604.com/The_Golden_Gate_Bridge.jpeg","linkMd5":"deaa1a14d23932c17fc81605d9508f90","sourceBytes":0,"destBytes":0,"author":"Race604","articleImgCdnMap":{"https://img.race604.com/The_Golden_Gate_Bridge.jpeg":null,"https://img.race604.com/7-1-responder-lifecycle.jpg":null,"https://img.race604.com/7-2-nest-layout-demo.jpg":null,"https://img.race604.com/7-3-touch-event-handle.jpg":null},"publishedOrCreatedDate":1599456951966}],"record":{"createdTime":"2020-09-07 13:35:51","updatedTime":"2020-09-07 13:35:51","feedId":26357,"fetchDate":"Mon, 07 Sep 2020 05:35:51 +0000","fetchMs":4800,"handleMs":11,"totalMs":48809,"newArticles":0,"totalArticles":15,"status":1,"type":0,"ip":"cf4f74a178f607b72fe1e5b4c372768e","hostName":"us-014*","requestId":"84612282c7de48848fc94c28c23eca52_26357","contentType":"text/xml; charset=utf-8","totalBytes":0,"bgimgsTotal":1,"bgimgsGithubTotal":0,"articlesImgsTotal":4,"articlesImgsGithubTotal":0,"successGithubMap":{},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:38:21","updatedTime":"2020-09-07 04:38:04","id":26357,"name":"Jlog","url":"http://www.race604.com/rss/","subscriber":124,"website":null,"icon":"https://www.race604.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn29@2020_6/2020/09/06/20-37-26-538_8646508251cd1775.ico","description":"Coding, thoughts. @Android笔记","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2020-09-07 13:36:35","updatedTime":"2020-09-07 13:36:35","id":null,"feedId":26357,"linkMd5":"deaa1a14d23932c17fc81605d9508f90"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1599456946926,"total":0,"statList":[{"spend":5029,"msg":"获取xml内容"},{"spend":11,"msg":"解释文章"},{"spend":1,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":26703,"msg":"正文链接上传到cdn"}]},"extra5":4,"extra6":4,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://img.race604.com/The_Golden_Gate_Bridge.jpeg","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":26357,"totalSpendMs":8972,"convertSpendMs":0,"createdTime":"2020-09-07 13:35:51","host":"us-54*","referer":"https://www.race604.com/react-native-touch-event/","linkMd5ListStr":"deaa1a14d23932c17fc81605d9508f90,deaa1a14d23932c17fc81605d9508f90","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://img.race604.com/The_Golden_Gate_Bridge.jpeg","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":26357,"totalSpendMs":8035,"convertSpendMs":0,"createdTime":"2020-09-07 13:36:00","host":"us-017*","referer":"https://www.race604.com/react-native-touch-event/","linkMd5ListStr":"deaa1a14d23932c17fc81605d9508f90,deaa1a14d23932c17fc81605d9508f90","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://img.race604.com/7-1-responder-lifecycle.jpg","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":26357,"totalSpendMs":5355,"convertSpendMs":0,"createdTime":"2020-09-07 13:36:09","host":"us-021*","referer":"https://www.race604.com/react-native-touch-event/","linkMd5ListStr":"deaa1a14d23932c17fc81605d9508f90","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://img.race604.com/7-2-nest-layout-demo.jpg","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":26357,"totalSpendMs":6745,"convertSpendMs":0,"createdTime":"2020-09-07 13:36:09","host":"us-033*","referer":"https://www.race604.com/react-native-touch-event/","linkMd5ListStr":"deaa1a14d23932c17fc81605d9508f90","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://img.race604.com/7-1-responder-lifecycle.jpg","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":26357,"totalSpendMs":5597,"convertSpendMs":0,"createdTime":"2020-09-07 13:36:14","host":"europe-59*","referer":"https://www.race604.com/react-native-touch-event/","linkMd5ListStr":"deaa1a14d23932c17fc81605d9508f90","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://img.race604.com/7-3-touch-event-handle.jpg","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":26357,"totalSpendMs":11481,"convertSpendMs":0,"createdTime":"2020-09-07 13:36:09","host":"us-008*","referer":"https://www.race604.com/react-native-touch-event/","linkMd5ListStr":"deaa1a14d23932c17fc81605d9508f90","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://img.race604.com/7-3-touch-event-handle.jpg","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":26357,"totalSpendMs":9287,"convertSpendMs":0,"createdTime":"2020-09-07 13:36:20","host":"us-030*","referer":"https://www.race604.com/react-native-touch-event/","linkMd5ListStr":"deaa1a14d23932c17fc81605d9508f90","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://img.race604.com/7-2-nest-layout-demo.jpg","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":26357,"totalSpendMs":8029,"convertSpendMs":0,"createdTime":"2020-09-07 13:36:27","host":"us-026*","referer":"https://www.race604.com/react-native-touch-event/","linkMd5ListStr":"deaa1a14d23932c17fc81605d9508f90","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"}],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-021.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[0]},"http://us-033.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[0]},"http://europe-59.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[0]},"http://us-008.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[0]},"http://us-030.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[0]},"http://us-026.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[0]}},"extra12ImgCdnSuccessResultVector":[],"successGithubMap":{},"failGithubMap":{}}