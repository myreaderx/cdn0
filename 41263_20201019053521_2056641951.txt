{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-19 13:35:21","updatedTime":"2020-10-19 13:35:21","title":"Requests Per Second","link":"http://www.therailsway.com/2009/1/6/requests-per-second","description":"\n            <p>One of the most harmful things about people discussing the performance of web applications is the key metric that we use.  Requests per second seems like the obvious metric to use, but it has several insidious characteristics that poison the discourse and lead developers down ever deeper rabbit holes chasing irrelevant gains.  The metric prevents us from doing A/B comparisons, or discussing potential improvements without doing some mental arithmetic which appears beyond the capabilities of most of us.</p>\n\n\n\t<p>Instead of talking about requests per second, we should always be focussed on the duration of a given request.  It’s what our users notice, and it’s the only thing which gives us a notice.</p>\n\n\n\t<p>I should prefix the remaining discussion here by saying that most of it does <strong>not</strong> apply to discussing performance problems at the scale of facebook, google or yahoo.  The thing is, statistically speaking, none of you are building applications that will operate at that scale.  Sorry if I’m the one who broke this to you, but you’re not building the next google :).</p>\n\n\n\t<p>I should also state that requests per second is a really interesting metric when considering the throughput of a whole cluster.  But throughput isn’t performance.</p>\n\n\n\t<h2>Diminshing marginal returns</h2>\n\n\n\t<p>The biggest problem I have with requests per second is the fact that developers seem incapable of knowing when to stop optimising their applications.  As the requests per second get higher and higher, the improvements become less and less relevant.  This lets us think we’ve defeated <a href=\"http://en.wikipedia.org/wiki/Vilfredo_Pareto\">that pareto guy</a>, while we waste ever-larger amounts of our employers’ time.</p>\n\n\n\t<p>Let’s take two different performance improvements and compare them using both duration and req/s.</p>\n\n\n<table>\n    <tr>\n        Patch\n        Before\n        After\n        Improvement\n    </tr>\n    <tr>\n        <td>A</td>\n        <td>120 req/s</td>\n        <td>300 req/s</td>\n        <td><strong>180 req/s</strong></td>\n    </tr>\n    <tr>\n        <td>B</td>\n        <td>3000 req/s</td>\n        <td>4000 req/s</td>\n        <td><strong>1000 req/s</strong></td>\n    </tr>\n</table>\n\n\t<p>As you can see, when you use req/s as your metric, change B seems like a <span class=\"caps\">MUCH</span> bigger saving.  It improves performance by 1000 requests a second instead of that measly 180, give that guy a raise!  But let’s see what happens when we switch to using durations:</p>\n\n\n<table>\n    <tr>\n        Patch\n        Before\n        After\n        Improvement\n    </tr>\n    <tr>\n        <td>A</td>\n        <td>8.33 ms</td>\n        <td>3.33 ms</td>\n        <td><strong>5 ms</strong></td>\n    </tr>\n    <tr>\n        <td>B</td>\n        <td>0.33 ms</td>\n        <td>0.25 ms</td>\n        <td><strong>0.08 ms</strong></td>\n    </tr>\n</table>\n\n\t<p>You see that the actual changes in duration in B is vanishingly tiny.  8% of one millisecond!  Odds are that that improvement will vanish into statistical noise when compared to the latency of your network, or your user’s internet connection.</p>\n\n\n\t<p>But when we use requests per second, that 1000 is so big and enticing that developers will do almost anything to get it.  If they used durations as their metric, they’d probably have spent that time implementing a neat new feature, or responding to customer feedback.</p>\n\n\n\t<h2>Deltas become meaningless</h2>\n\n\n\t<p>A special case of my first complaint is that with requests per second the deltas aren’t meaningful without knowing the start and the finish points.  As I showed above, a 1000 req/s change could be a tiny change, but it could also be an amazing performance coup.  Take this next example:</p>\n\n\n<table>\n    <tr>\n        Before\n        After\n        Diff\n    </tr>\n    <tr>\n        <td>1 req/s</td>\n        <td>1001 req/s</td>\n        <td>1000 req/s</td>\n    </tr>\n</table>\n\n\t<p>When expressed as durations you can see that it made a huge difference</p>\n\n\n<table>\n    <tr>\n        Before\n        After\n        Diff\n    </tr>\n    <tr>\n        <td>1000 ms</td>\n        <td>0.99 ms</td>\n        <td>999.01 ms</td>\n    </tr>\n</table>\n\n\t<p>So 1000 requests per second could either be irrelevant, or fantastic.  Durations don’t have this problem at all. 0.02ms is obviously questionable, and 999.01 ms is an obvious improvement.</p>\n\n\n\t<p>This problem most commonly expresses itself when people say “that changeset took 50 requests per second off my application”.  Without the before and after numbers, we can’t tell if that’s a big deal, or if the guy needs to take a deep breath and get back to work.</p>\n\n\n\t<h2>The numbers don’t add up</h2>\n\n\n\t<p>Finally, requests per second don’t lend themselves nicely to arithmetic, and make developers make silly decisions.  The most common case I see this is when comparing web servers to put in front of their rails applications.  The reasoning goes something like this:</p>\n\n\n\t<blockquote>\n\t\t<p>Nginx does over 9000 requests per second, and apache only does 6000 requests per second!! I’d better use nginx unless I want to pay a 3000 requests per second tax.</p>\n\t</blockquote>\n\n\n\t<p>When people do this comparison they seem to believe that by switching to nginx from apache their application will go from 100 req/s to 3100 req/s.  As always, durations tell us a different story.</p>\n\n\n<table>\n    <tr>\n        Apache\n        Nginx\n        Diff\n    </tr>\n    <tr>\n        <td>6000 req/s</td>\n        <td>9000 req/s</td>\n        <td>3000 req/s</td>\n    </tr>\n    <tr>\n        <td>0.16 ms</td>\n        <td>0.11 ms</td>\n        <td>0.05 ms</td>\n    </tr>\n</table>\n\n\t<p>So we can see that odds are you’ll only gain a 5% of a millisecond’s improvement when switching.  Perhaps that improvement is worthwhile for your application, but is it worth the additional complexity?</p>\n\n\n\t<h2>Conclusion</h2>\n\n\n\t<p>Durations are a much more useful, and more honest, metric when comparing performance changes in your applications.  Requests per second is too wide-spread for us to stop using it entirely, but <strong>please</strong> don’t use it when talking about performance of your web applications or libraries.</p>\n          ","descriptionType":"html","publishedDate":"Tue, 06 Jan 2009 07:12:00 +0000","feedId":41263,"bgimg":"","linkMd5":"24ef420c2a5eb7a34def3a596e5eab88","bgimgJsdelivr":"","metaImg":"","author":"Koz","publishedOrCreatedDate":1603085721917}],"record":{"createdTime":"2020-10-19 13:35:21","updatedTime":"2020-10-19 13:35:21","feedId":41263,"fetchDate":"Mon, 19 Oct 2020 05:35:21 +0000","fetchMs":49,"handleMs":180236,"totalMs":180301,"newArticles":0,"totalArticles":15,"status":1,"type":0,"ip":"127b947ffb830011589be2c07906fee5","hostName":"us-023*","requestId":"2741492670a843d69b5989438f44c0f3_41263","contentType":"text/xml; charset=UTF-8","totalBytes":0,"bgimgsTotal":0,"bgimgsGithubTotal":0,"articlesImgsTotal":0,"articlesImgsGithubTotal":0,"successGithubMap":{},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 03:23:30","updatedTime":"2020-09-07 05:43:13","id":41263,"name":"The Rails Way - Home","url":"http://feeds.feedburner.com/TheRailsWay","subscriber":78,"website":null,"icon":"http://www.therailsway.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"http://www.therailsway.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1603085541622,"total":0,"statList":[{"spend":59,"msg":"获取xml内容"},{"spend":180236,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":0,"msg":"正文链接上传到cdn"}]},"extra5":0,"extra6":0,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{},"extra12ImgCdnSuccessResultVector":[],"successGithubMap":{},"failGithubMap":{}}