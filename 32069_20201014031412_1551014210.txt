{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-14 11:13:39","updatedTime":"2020-10-14 11:13:39","title":"雕虫晓技(五) 网格分页布局源码解析(上)","link":"https://xiaozhuanlan.com/topic/5841730926","description":"<h3 id=\"关于作者\">关于作者</h3> \n<p>GcsSloop，一名 2.5 次元魔法师。<br /> <a href=\"http://weibo.com/GcsSloop/home\">微博</a> | <a href=\"https://github.com/GcsSloop\">GitHub</a> | <a href=\"http://www.gcssloop.com/\">博客</a></p> \n<h2 id=\"0前言\">0.前言</h2> \n<p><strong>pager-layoutmanager： <a href=\"https://github.com/GcsSloop/pager-layoutmanager\">https://github.com/GcsSloop/pager-layoutmanager</a></strong></p> \n<p>这个是我之前公开分享的一个开源库 <a href=\"https://github.com/GcsSloop/pager-layoutmanager\">【PagerLayoutManager(网格分页布局)】</a> 的详细解析，在开始讲解之前，先看看它能实现的一些效果。</p> \n<p><img src=\"http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo1.gif\" alt=\"emo\" /> <img src=\"http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo2.gif\" alt=\"emo\" /></p> \n<p>上面是它的应用场景之一，再看一下实现这种场景所需的代码：</p> \n<div class=\"language-java highlighter-rouge\">\n <pre class=\"highlight\"><code><span class=\"c1\">// 布局管理器</span>\n<span class=\"n\">PagerGridLayoutManager</span> <span class=\"n\">layoutManager</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">PagerGridLayoutManager</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"n\">PagerGridLayoutManager</span><span class=\"o\">.</span><span class=\"na\">HORIZONTAL</span><span class=\"o\">);</span>\n<span class=\"n\">mRecyclerView</span><span class=\"o\">.</span><span class=\"na\">setLayoutManager</span><span class=\"o\">(</span><span class=\"n\">layoutManager</span><span class=\"o\">);</span>\n\n<span class=\"c1\">// 滚动辅助器</span>\n<span class=\"n\">PagerGridSnapHelper</span> <span class=\"n\">snapHelper</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">PagerGridSnapHelper</span><span class=\"o\">();</span>\n<span class=\"n\">snapHelper</span><span class=\"o\">.</span><span class=\"na\">attachToRecyclerView</span><span class=\"o\">(</span><span class=\"n\">mRecyclerView</span><span class=\"o\">);</span>\n</code></pre> \n</div> \n<p>没错，想要实现这样分页滚动的效果，只需要四五行代码就可以了，至于 RecyclerView 和 Adapter 使用官方提供的即可。</p> \n<h2 id=\"1-摘要\">1. 摘要</h2> \n<p>之前项目中有类似的需求，在网上寻找了一些实现方案，结果均不太满意。</p> \n<p>有些方案使用起来过于麻烦，例如 ViewPager + GridView，不用我说，用过的都知道，这种方案数据绑定十分麻烦，并且会多一层View嵌套，相对来说会损耗一些性能。</p> \n<p>有些则是存在重大缺陷，例如内存泄露，性能问题等，像上面那种场景仅展示几个固定条目的情况还不明显，但是当需要动态加载几百个条目的时候缺陷就显现出来了，会造成严重的滑动卡顿，当数据达到一定数量级的时候，可能直接导致ANR。</p> \n<p>在试过诸多方案，踩过很多坑以后，依旧没有找到合适的方案，于是自己动手，丰衣足食，也就有了这个项目。</p> \n<p>这个项目已经在公司多个项目上使用，经过十几个版本的迭代更新，基本上已经没有重大bug了，更新日志可以见这里： <a href=\"https://github.com/GcsSloop/pager-layoutmanager\">PagerLayoutManager</a>。</p> \n<p>如果你只是需要这样一个组件，那么直接点击上面的链接，看它的说明文档就可以了，本文不是你需要的，但如果你想要知道它的具体实现方案，对它进行改进的话，那么下文的内容可能会对你有所帮助。</p> \n<h2 id=\"2-基础网格布局解析\">2. 基础网格布局解析</h2> \n<h3 id=\"21-方案选择\">2.1 方案选择</h3> \n<p>首先项目所需要的核心内容主要有以下几点：</p> \n<ol> \n <li>网格效果</li> \n <li>分页显示</li> \n <li>横向排布</li> \n</ol> \n<p><img src=\"http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo3.jpg\" alt=\"demo3\" /></p> \n<p>所需效果大概就如上图所示，为了避免重复造轮子，在一开始我想要使用一些现有的组件来完成。</p> \n<ol> \n <li> <p>最先想到的自然是网格布局，但是呢，项目需要动态加载数百条的数据，网格布局本身不带有条目自动回收创建功能，如果同让上百个View存在于一个页面之中，不卡爆才怪。</p> </li> \n <li> <p>之后想到的是 ViewPager+GridLayout，但是这种方案数据拆分和绑定十分麻烦，遂放弃。</p> </li> \n <li> <p>然后想 RecyclerView + GridLayoutManager 看起来靠谱一点，首先使用 GridLayoutMnager，作出网格效果，然后监听滚动事件来控制滚动距离，一切看起来都是那么美好，但是，事实证明这种方案还是太难使用。</p> <p>首先网格布局同时只能控制行数或者列数其中一个，如果想要如果想要像设定那样2行3列，一页整好现实6条数据，那么View的宽高是需要动态计算的，如果设置了固定大小，必然会导致适配问题，</p> <p>其次，数据不一定是整页，如果是2行3列，一页6条数据，那么使用 GridLayoutManager滑动后可能会出现这样的效果，另外，数据排列顺序也并非我所需要的：</p> <p><img src=\"http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo4.jpg\" alt=\"demo4\" /></p> <p>这显然不是我想要的效果，在数据不足一页时，我需要的效果是这样的：</p> <p><img src=\"http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo5.jpg\" alt=\"demo5\" /></p> <p>如果想要在不动 GridLayoutManager 的情况下实现需求，则需要执行如下操作：</p> <p>假设，需要显示2行3列，共8条数据，那么需要执行如下操作：</p> \n  <ol> \n   <li> <p>将不足一页部分补足一页</p> \n    <div class=\"highlighter-rouge\">\n     <pre class=\"highlight\"><code>1、2、3、4、5、6、7、8\n1、2、3、4、5、6、7、8、空、空、空、空\n</code></pre> \n    </div> </li> \n   <li> <p>通过数据变换调整数据次序使其显示符合预期</p> \n    <div class=\"highlighter-rouge\">\n     <pre class=\"highlight\"><code>1、2、3、4、5、6、7、8、空、空、空、空\n1、4、2、5、3、6、7、空、8、空、空、空\n</code></pre> \n    </div> </li> \n   <li> <p>通过监听滚动控制滚动距离来实现分页显示</p> </li> \n  </ol> <p>另外，页面数据是分页加载显示的，如果使用上面这种方案，单是数据处理逻辑就能把我绕进去。</p> </li> \n</ol> \n<p><strong>在经过深思熟虑之后，我决定自定义一个 LayoutManager 来实现这个“简单”的需求。</strong>幸好 RecyclerView 的扩展性非常强，自定义一个 LayoutManager 也不是什么难事，下面我们就一步步的的实现一个分页网格布局。</p> \n<h3 id=\"22-创建一个基础的-layoutmanager\">2.2 创建一个基础的 LayoutManager</h3> \n<p>首先我们创建一个 PagerGridLayoutManager 并继承 RecyclerView.LayoutManager，实现其抽象方法，一个LayoutManager 就可以用了，如下：</p> \n<div class=\"language-java highlighter-rouge\">\n <pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">PagerGridLayoutManager</span> <span class=\"kd\">extends</span> <span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">LayoutManager</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">LayoutParams</span> <span class=\"nf\">generateDefaultLayoutParams</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">LayoutParams</span><span class=\"o\">(</span><span class=\"n\">ViewGroup</span><span class=\"o\">.</span><span class=\"na\">LayoutParams</span><span class=\"o\">.</span><span class=\"na\">WRAP_CONTENT</span><span class=\"o\">,</span>\n                <span class=\"n\">ViewGroup</span><span class=\"o\">.</span><span class=\"na\">LayoutParams</span><span class=\"o\">.</span><span class=\"na\">WRAP_CONTENT</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre> \n</div> \n<p>这是一个符合规范的 LayoutManager，但是目前它不会将任何View显示在界面上，因为它没有对条目进行处理，也就意味着没有条目会添加到界面上。但我们先不着急处理子条目，在真正布局之前，我们先来解决一些简单的基础问题。</p> \n<h3 id=\"23-确定行列数数和滚动方向\">2.3 确定行列数数和滚动方向</h3> \n<p>由于行列数会直接关系到一个页面显示条目的个数，进而影响到总共可以滚动的j距离和页数总数，所以它们要在构造方法中设置。</p> \n<p>而滚动方向一般都是确定的，横向或者竖向，并且基本不变，所以，它也可以在构造方法中进行设置，提醒使用者不要忘记滚动方向。</p> \n<p>所以为 PagerGridLayoutManager 添加如下的属性和构造方法：</p> \n<pre><code class=\"language-Java\">public static final int VERTICAL = 0;           // 垂直滚动\npublic static final int HORIZONTAL = 1;         // 水平滚动\n\n@IntDef({VERTICAL, HORIZONTAL})\npublic @interface OrientationType {}            // 滚动类型\n\n@OrientationType\nprivate int mOrientation = HORIZONTAL;          // 默认水平滚动\n\nprivate int mRows = 0;                          // 行数\nprivate int mColumns = 0;                       // 列数\nprivate int mOnePageSize = 0;                   // 一页的条目数量\n\n/**\n * 构造函数\n *\n * @param rows        行数\n * @param columns     列数\n * @param orientation 方向\n */\npublic PagerGridLayoutManager(@IntRange(from = 1, to = 100) int rows,\n                              @IntRange(from = 1, to = 100) int columns,\n                              @OrientationType int orientation) {\n    mOrientation = orientation;\n    mRows = rows;\n    mColumns = columns;\n    mOnePageSize = mRows * mColumns;\n}\n</code></pre> \n<p>注意：</p> \n<ol> \n <li>上面使用了 @IntDef 注解自定义了一个 OrientationType 注解，用于防治用户随意设置数值。</li> \n <li>使用 @IntRange 方法将行列数限制在一个较合理的范围内。</li> \n <li>在初始化的时候利用行列数计算出了一页应该有多少个条目，方面后面使用。</li> \n</ol> \n<p>在确定了滚动方向后，顺便就可以实现 LayoutManager 以下两个方法了，这两个方法会真正的决定 RecyclerView 可以滚动的方向。</p> \n<div class=\"language-java highlighter-rouge\">\n <pre class=\"highlight\"><code><span class=\"cm\">/** 是否可以水平滚动\n * @return true 是，false 不是。\n */</span>\n<span class=\"nd\">@Override</span>\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">canScrollHorizontally</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">mOrientation</span> <span class=\"o\">==</span> <span class=\"n\">HORIZONTAL</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/** 是否可以垂直滚动\n * @return true 是，false 不是。\n */</span>\n<span class=\"nd\">@Override</span>\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">canScrollVertically</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">mOrientation</span> <span class=\"o\">==</span> <span class=\"n\">VERTICAL</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</code></pre> \n</div> \n<h3 id=\"24-计算子条目的宽高\">2.4 计算子条目的宽高</h3> \n<p>由于我们是分页网格显示，目前已经知道了行列数，如果再知道 RecyclerView 的宽高，就能算出单个自条目的所能占用的宽高了。</p> \n<p>因此我们再添加两个方法用于获取 RecyclerView 的可用宽高：</p> \n<pre><code class=\"language-Java\">/** 获取可用的宽度\n * @return 宽度 - padding\n */\nprivate int getUsableWidth() {\n    return getWidth() - getPaddingLeft() - getPaddingRight();\n}\n\n/** 获取可用的高度\n * @return 高度 - padding\n */\nprivate int getUsableHeight() {\n    return getHeight() - getPaddingTop() - getPaddingBottom();\n}\n</code></pre> \n<p>注意：可用宽高要减去 Padding 数值。</p> \n<p>有了总的可用宽高，在分别处以行列数就可以得到每一个子条目占用的宽高了。</p> \n<pre><code class=\"language-Java\">private int mItemWidth = 0;  // 条目宽度\nprivate int mItemHeight = 0; // 条目高度\nmItemWidth = getUsableWidth() / mColumns;\nmItemHeight = getUsableHeight() / mRows;\n</code></pre> \n<h3 id=\"25-计算条目显示区域\">2.5 计算条目显示区域</h3> \n<p>既然知道了条目的宽高，那么只要知道这个条目所在位置就能确切的知道它的显示区域了。</p> \n<p>这里使用的计算方案是：<strong>条目所在页面的偏移量 + 条目在页面内的偏移量</strong>。<br /> 同时由于页面可能会反复的滑动，因此不可能每次滚动时都重新计算一下条目的位置，因此计算过的条目用 <code class=\"highlighter-rouge\">mItemFrames</code> 存储起来，之后想要获取该条目的显示区域，直接从 <code class=\"highlighter-rouge\">mItemFrames</code> 中取出即可，防止重复计算造成的性能浪费。至于存储所耗费的内存空间，其实并不算大，存储 10 万个 Rect 耗费内存也才 4M 左右，正常情况下一般不会超过一万条数据，所耗费的空间一般不会超过 0.5M，大可以放心使用。</p> \n<pre><code class=\"language-Java\">private SparseArray&lt;Rect&gt; mItemFrames;  // 条目的显示区域\n\n/** 获取条目显示区域\n * @param pos 位置下标\n * @return 显示区域\n */\nprivate Rect getItemFrameByPosition(int pos) {\n    Rect rect = mItemFrames.get(pos);\n    if (null == rect) {\n        rect = new Rect();\n        // 计算显示区域 Rect\n        // 1. 获取当前View所在页数\n        int page = pos / mOnePageSize;\n\n        // 2. 计算当前页数左上角的总偏移量\n        int offsetX = 0;\n        int offsetY = 0;\n        if (canScrollHorizontally()) {\n            offsetX += getUsableWidth() * page;\n        } else {\n            offsetY += getUsableHeight() * page;\n        }\n\n        // 3. 根据在当前页面中的位置确定具体偏移量\n        int pagePos = pos % mOnePageSize;       // 在当前页面中是第几个\n        int row = pagePos / mColumns;           // 获取所在行\n        int col = pagePos - (row * mColumns);   // 获取所在列\n\n        offsetX += col * mItemWidth;\n        offsetY += row * mItemHeight;\n\n        rect.left = offsetX;\n        rect.top = offsetY;\n        rect.right = offsetX + mItemWidth;\n        rect.bottom = offsetY + mItemHeight;\n\n        // 存储\n        mItemFrames.put(pos, rect);\n    }\n    return rect;\n}\n</code></pre> \n<h3 id=\"26-布局-childview\">2.6 布局 ChildView</h3> \n<p>在进行完上面几步操作添加了这些基础方法后后，这个 PagerGridLayoutManager 实际上还是没法使用的，因为它依旧没有将子条目添加的屏幕上，因此屏幕上什么也不会有。</p> \n<blockquote> \n <p>如果熟悉 ViewGroup 的人可能会知道，要控制 ChildView 在 ParentView 中的位置，需要在 ParentView 的 onLayout 方法中调整 ChildView 的具体摆放位置和大小。其实 LayoutManager 和 ViewGroup 的布局是有些类似的，需要在 LayoutManager 的 onLayoutChildren 方法中控制 ChildView 的大小和显示位置。</p> \n</blockquote> \n<p>那么具体如何将子条目添加的屏幕上呢，像下面这样就可以：</p> \n<div class=\"language-java highlighter-rouge\">\n <pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">onLayoutChildren</span><span class=\"o\">(</span><span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">Recycler</span> <span class=\"n\">recycler</span><span class=\"o\">,</span> <span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">State</span> <span class=\"n\">state</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    <span class=\"c1\">// 获取第 0 个条目，如果不存在的话 RecyclerView 会自动创建</span>\n    <span class=\"n\">View</span> <span class=\"n\">child</span> <span class=\"o\">=</span> <span class=\"n\">recycler</span><span class=\"o\">.</span><span class=\"na\">getViewForPosition</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\t\n    <span class=\"c1\">// 获取该条目的具体应该显示位置</span>\n    <span class=\"n\">Rect</span> <span class=\"n\">rect</span> <span class=\"o\">=</span> <span class=\"n\">getItemFrameByPosition</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n    <span class=\"c1\">// 将该条目添加的界面上</span>\n    <span class=\"n\">addView</span><span class=\"o\">(</span><span class=\"n\">child</span><span class=\"o\">);</span>\n    <span class=\"c1\">// 测量该条目，注意 mWidthUsed = 总可用宽度-其余条目占用的宽度， mHeightUsed = 总可用高度-其余条目占用高度</span>\n    <span class=\"n\">measureChildWithMargins</span><span class=\"o\">(</span><span class=\"n\">child</span><span class=\"o\">,</span> <span class=\"n\">mWidthUsed</span><span class=\"o\">,</span> <span class=\"n\">mHeightUsed</span><span class=\"o\">);</span>\n    <span class=\"c1\">// 获取布局参数 LayoutParams</span>\n    <span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">LayoutParams</span> <span class=\"n\">lp</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">LayoutParams</span><span class=\"o\">)</span> <span class=\"n\">child</span><span class=\"o\">.</span><span class=\"na\">getLayoutParams</span><span class=\"o\">();</span>\n    <span class=\"c1\">// 使用 layoutDecorated 确定具体显示位置，注意 margin 数值的处理(此处代码不完整，非最终代码)</span>\n    <span class=\"n\">layoutDecorated</span><span class=\"o\">(</span><span class=\"n\">child</span><span class=\"o\">,</span>\n            <span class=\"n\">rect</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">+</span> <span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"na\">leftMargin</span><span class=\"o\">,</span>\n            <span class=\"n\">rect</span><span class=\"o\">.</span><span class=\"na\">top</span> <span class=\"o\">+</span> <span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"na\">topMargin</span><span class=\"o\">,</span>\n            <span class=\"n\">rect</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">-</span> <span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"na\">rightMargin</span><span class=\"o\">,</span>\n            <span class=\"n\">rect</span><span class=\"o\">.</span><span class=\"na\">bottom</span> <span class=\"o\">-</span> <span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"na\">bottomMargin</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n</code></pre> \n</div> \n<p>这样子就可以将第 0 个 ViewView 添加到页面上了，鹅妹子嘤！但是这样子只能添加一个 View 如果有很多个 View 需要显示怎么办呢？第一反应自然是循环大法：</p> \n<div class=\"language-java highlighter-rouge\">\n <pre class=\"highlight\"><code><span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">getItemCount</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++){</span>\n    <span class=\"c1\">// 省略添加View的代码</span>\n<span class=\"o\">}</span>\n</code></pre> \n</div> \n<p>哈哈，似乎一切都很完美，<strong>稍等，似乎有点不对，话说 RecyclerView 最强大的不是条目的回收和复用吗？它是自动进行回收和复用的吗？</strong></p> \n<p>这个自然不是，一个条目是否需要被添加到缓存池或者销毁，是由 LayoutManager 进行控制的，而上面这段代码并没有回收复用条目相关的代码，这显然是不正确的。不仅如此，上面这段代码会将所有的条目都转化为 View 放到页面上，假如只有几个条目还可以，若是存在几百上千个条目，就上面这一个 for 循环一下子就能把内存耗尽，因此这种写法是万万不可的。</p> \n<p>一个 RecyclerView 可以有很多的条目，但设备屏幕大小是有限的，所以显示在屏幕上的 View 数量始终是有限的，因此我们将当前显示在屏幕上的 View 显示出来，超出显示区域的 View 则放入缓冲区或者销毁掉。因此我们要知道当前哪些 View 应该被显示，哪些应该被销毁。</p> \n<p>首先我们要知道当前的总偏移量，根据偏移量和 RecyclerView 的大小来计算出显示区域，之后将显示区域外的 View 移除掉，显示区域内的 View 添加到当前的界面上。</p> \n<h4 id=\"261-计算偏移量\">2.6.1 计算偏移量</h4> \n<p>在计算和更新偏移量时注意最大可以用偏移量，防止越界。</p> \n<div class=\"language-java highlighter-rouge\">\n <pre class=\"highlight\"><code><span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">mOffsetX</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>                       <span class=\"c1\">// 水平滚动距离(偏移量)</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">mOffsetY</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>                       <span class=\"c1\">// 垂直滚动距离(偏移量)</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">mMaxScrollX</span><span class=\"o\">;</span>                        <span class=\"c1\">// 最大允许滑动的宽度</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">mMaxScrollY</span><span class=\"o\">;</span>                        <span class=\"c1\">// 最大允许滑动的高度</span>\n\n\n<span class=\"c1\">// 在 onLayoutChildren 时计算可以滚动的最大数值，并对滚动距离进行修正</span>\n<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">canScrollHorizontally</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n    <span class=\"n\">mMaxScrollX</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">mPageCount</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">*</span> <span class=\"n\">getUsableWidth</span><span class=\"o\">();</span>\n    <span class=\"n\">mMaxScrollY</span> <span class=\"o\">=</span> <span class=\"n\">getUsableHeight</span><span class=\"o\">();</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">mOffsetX</span> <span class=\"o\">&gt;</span> <span class=\"n\">mMaxScrollX</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">mOffsetX</span> <span class=\"o\">=</span> <span class=\"n\">mMaxScrollX</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n    <span class=\"n\">mMaxScrollX</span> <span class=\"o\">=</span> <span class=\"n\">getUsableWidth</span><span class=\"o\">();</span>\n    <span class=\"n\">mMaxScrollY</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">mPageCount</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">*</span> <span class=\"n\">getUsableHeight</span><span class=\"o\">();</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">mOffsetY</span> <span class=\"o\">&gt;</span> <span class=\"n\">mMaxScrollY</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">mOffsetY</span> <span class=\"o\">=</span> <span class=\"n\">mMaxScrollY</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n\n<span class=\"c1\">// 更新偏移量</span>\n<span class=\"nd\">@Override</span>\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">scrollHorizontallyBy</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">dx</span><span class=\"o\">,</span> <span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">Recycler</span> <span class=\"n\">recycler</span><span class=\"o\">,</span> <span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">State</span>\n        <span class=\"n\">state</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">newX</span> <span class=\"o\">=</span> <span class=\"n\">mOffsetX</span> <span class=\"o\">+</span> <span class=\"n\">dx</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">dx</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">newX</span> <span class=\"o\">&gt;</span> <span class=\"n\">mMaxScrollX</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">mMaxScrollX</span> <span class=\"o\">-</span> <span class=\"n\">mOffsetX</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">newX</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"o\">-</span> <span class=\"n\">mOffsetX</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">mOffsetX</span> <span class=\"o\">+=</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n    <span class=\"n\">setPageIndex</span><span class=\"o\">(</span><span class=\"n\">getPageIndexByOffset</span><span class=\"o\">(),</span> <span class=\"kc\">true</span><span class=\"o\">);</span>\n    <span class=\"n\">offsetChildrenHorizontal</span><span class=\"o\">(-</span><span class=\"n\">result</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"nd\">@Override</span>\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">scrollVerticallyBy</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">dy</span><span class=\"o\">,</span> <span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">Recycler</span> <span class=\"n\">recycler</span><span class=\"o\">,</span> <span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">State</span>\n        <span class=\"n\">state</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">newY</span> <span class=\"o\">=</span> <span class=\"n\">mOffsetY</span> <span class=\"o\">+</span> <span class=\"n\">dy</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">dy</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">newY</span> <span class=\"o\">&gt;</span> <span class=\"n\">mMaxScrollY</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">mMaxScrollY</span> <span class=\"o\">-</span> <span class=\"n\">mOffsetY</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">newY</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"o\">-</span> <span class=\"n\">mOffsetY</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">mOffsetY</span> <span class=\"o\">+=</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n    <span class=\"n\">offsetChildrenVertical</span><span class=\"o\">(-</span><span class=\"n\">result</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n</code></pre> \n</div> \n<h4 id=\"262-计算显示区域\">2.6.2 计算显示区域</h4> \n<p>根据 offset 和 view 的大小计算当前实际的显示区域，有了显示区域就能知道哪些条目应该显示在当前界面上。</p> \n<div class=\"language-java highlighter-rouge\">\n <pre class=\"highlight\"><code><span class=\"n\">Rect</span> <span class=\"n\">displayRect</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Rect</span><span class=\"o\">(</span>\n    <span class=\"n\">getPaddingLeft</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"n\">mOffsetX</span><span class=\"o\">,</span>\n    <span class=\"n\">getPaddingTop</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"n\">mOffsetY</span><span class=\"o\">,</span>\n    <span class=\"n\">getWidth</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"n\">getPaddingLeft</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"n\">getPaddingRight</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"n\">mOffsetX</span><span class=\"o\">,</span>\n    <span class=\"n\">getHeight</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"n\">getPaddingTop</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"n\">getPaddingBottom</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"n\">mOffsetY</span><span class=\"o\">);</span>\n</code></pre> \n</div> \n<h4 id=\"263-判断哪些条目应该被更新\">2.6.3 判断哪些条目应该被更新</h4> \n<p>这个判断自然也是有些技巧的，如果是像前面那样，每一次更新都直接一个 for 循环判断所有的条目是否应该显示，那么当条目数量上千时，滑动肯定会卡爆，因为每一次滑动都会导致多次界面的刷新，如果每一次刷新都直接一个 for 循环循环上千次，那么一次滑动循环体执行次数就可能有上万次了，卡顿那才奇怪呢。</p> \n<p>所以我们这里使用这样的策略：</p> \n<ol> \n <li>刷新前将所有的 View 都移除放到缓冲区</li> \n <li>计算当前显示区域的页面是哪个</li> \n <li>只刷新与之临近页面的 View</li> \n</ol> \n<p>这样不论总共有多少个条目，我们每一次刷新都只会更新几个到几十个条目，会节省大量到时间。</p> \n<div class=\"language-java highlighter-rouge\">\n <pre class=\"highlight\"><code><span class=\"c1\">// 1.移除所有View</span>\n<span class=\"n\">detachAndScrapAttachedViews</span><span class=\"o\">(</span><span class=\"n\">recycler</span><span class=\"o\">);</span> \n\n<span class=\"c1\">// 2.根据偏移量来计算当前页面和临近页面，计算出这些页面的开始和结束位置</span>\n<span class=\"kt\">int</span> <span class=\"n\">startPos</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">pageIndex</span> <span class=\"o\">=</span> <span class=\"n\">getPageIndexByOffset</span><span class=\"o\">();</span>\n<span class=\"n\">startPos</span> <span class=\"o\">=</span> <span class=\"n\">pageIndex</span> <span class=\"o\">*</span> <span class=\"n\">mOnePageSize</span><span class=\"o\">;</span>\n<span class=\"n\">Logi</span><span class=\"o\">(</span><span class=\"s\">\"startPos = \"</span> <span class=\"o\">+</span> <span class=\"n\">startPos</span><span class=\"o\">);</span>\n<span class=\"n\">startPos</span> <span class=\"o\">=</span> <span class=\"n\">startPos</span> <span class=\"o\">-</span> <span class=\"n\">mOnePageSize</span> <span class=\"o\">*</span> <span class=\"mi\">2</span><span class=\"o\">;</span>\n<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">startPos</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">startPos</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n<span class=\"kt\">int</span> <span class=\"n\">stopPos</span> <span class=\"o\">=</span> <span class=\"n\">startPos</span> <span class=\"o\">+</span> <span class=\"n\">mOnePageSize</span> <span class=\"o\">*</span> <span class=\"mi\">4</span><span class=\"o\">;</span>\n<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">stopPos</span> <span class=\"o\">&gt;</span> <span class=\"n\">getItemCount</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n    <span class=\"n\">stopPos</span> <span class=\"o\">=</span> <span class=\"n\">getItemCount</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 3.针对这些 View 添加到屏幕上或者移除</span>\n<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">startPos</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">stopPos</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 添加或者移除</span>\n    <span class=\"n\">addOrRemove</span><span class=\"o\">(</span><span class=\"n\">recycler</span><span class=\"o\">,</span> <span class=\"n\">displayRect</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n</code></pre> \n</div> \n<p><strong>注意：如果你去看项目的源码会看到下面这样的逻辑：</strong></p> \n<div class=\"language-java highlighter-rouge\">\n <pre class=\"highlight\"><code><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">isStart</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">startPos</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">stopPos</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">addOrRemove</span><span class=\"o\">(</span><span class=\"n\">recycler</span><span class=\"o\">,</span> <span class=\"n\">displayRect</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">stopPos</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"n\">startPos</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n        <span class=\"n\">addOrRemove</span><span class=\"o\">(</span><span class=\"n\">recycler</span><span class=\"o\">,</span> <span class=\"n\">displayRect</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre> \n</div> \n<p>大家可能会奇怪，为啥会有这样的迷之逻辑呢？一个 For 循环居然还要区分正反。<br /> 实际上这是为了控制条目移除和添加的顺序，要先移除再添加，这样会移除的 View 会被先放到缓冲区中，再添加 View 时就可以直接从缓冲区中把被移除的条目直接取出来使用了，而不用重新创建，以减少开销。如果不控制顺序的话，先执行添加操作，由于缓冲区中没有可以使用的 View，会进行先创建，之后再添加到界面上，最后执行移除操作会导致有大量的 View 滞留在缓冲区中，会造成严重的性能浪费。</p> \n<h4 id=\"264-添加或者移除条目\">2.6.4 添加或者移除条目</h4> \n<p>如果条目的显示区域和当前显示区域有重叠部分(有交集)，就将 View 添加到界面上，否则就将 View 移除。</p> \n<div class=\"language-java highlighter-rouge\">\n <pre class=\"highlight\"><code><span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">addOrRemove</span><span class=\"o\">(</span><span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">Recycler</span> <span class=\"n\">recycler</span><span class=\"o\">,</span> <span class=\"n\">Rect</span> <span class=\"n\">displayRect</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">View</span> <span class=\"n\">child</span> <span class=\"o\">=</span> <span class=\"n\">recycler</span><span class=\"o\">.</span><span class=\"na\">getViewForPosition</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n    <span class=\"n\">Rect</span> <span class=\"n\">rect</span> <span class=\"o\">=</span> <span class=\"n\">getItemFrameByPosition</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\t<span class=\"c1\">// 获得当前条目显示区域</span>\n    <span class=\"c1\">// 判断条目显示区域和当前显示区域是否有重叠，如果有重叠就添加，没有就移除</span>\n    <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">Rect</span><span class=\"o\">.</span><span class=\"na\">intersects</span><span class=\"o\">(</span><span class=\"n\">displayRect</span><span class=\"o\">,</span> <span class=\"n\">rect</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n        <span class=\"n\">removeAndRecycleView</span><span class=\"o\">(</span><span class=\"n\">child</span><span class=\"o\">,</span> <span class=\"n\">recycler</span><span class=\"o\">);</span>   <span class=\"c1\">// 回收入暂存区</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"n\">addView</span><span class=\"o\">(</span><span class=\"n\">child</span><span class=\"o\">);</span>\n        <span class=\"n\">measureChildWithMargins</span><span class=\"o\">(</span><span class=\"n\">child</span><span class=\"o\">,</span> <span class=\"n\">mWidthUsed</span><span class=\"o\">,</span> <span class=\"n\">mHeightUsed</span><span class=\"o\">);</span>\n        <span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">LayoutParams</span> <span class=\"n\">lp</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">RecyclerView</span><span class=\"o\">.</span><span class=\"na\">LayoutParams</span><span class=\"o\">)</span> <span class=\"n\">child</span><span class=\"o\">.</span><span class=\"na\">getLayoutParams</span><span class=\"o\">();</span>\n        <span class=\"n\">layoutDecorated</span><span class=\"o\">(</span><span class=\"n\">child</span><span class=\"o\">,</span>\n                <span class=\"n\">rect</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">-</span> <span class=\"n\">mOffsetX</span> <span class=\"o\">+</span> <span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"na\">leftMargin</span><span class=\"o\">,</span>\n                <span class=\"n\">rect</span><span class=\"o\">.</span><span class=\"na\">top</span> <span class=\"o\">-</span> <span class=\"n\">mOffsetY</span> <span class=\"o\">+</span> <span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"na\">topMargin</span><span class=\"o\">,</span>\n                <span class=\"n\">rect</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">-</span> <span class=\"n\">mOffsetX</span> <span class=\"o\">-</span> <span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"na\">rightMargin</span><span class=\"o\">,</span>\n                <span class=\"n\">rect</span><span class=\"o\">.</span><span class=\"na\">bottom</span> <span class=\"o\">-</span> <span class=\"n\">mOffsetY</span> <span class=\"o\">-</span> <span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"na\">bottomMargin</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre> \n</div> \n<p>经过上面几步操作，一个最基础的网格布局就完成啦，但是请注意的是，为了比较清晰的表达出核心逻辑，上面的部分代码移除了一部相对无关紧要的逻辑，因此并非最终的代码，最终代码请参考 <a href=\"https://github.com/GcsSloop/pager-layoutmanager\">【GitHub · pager-layoutmanager 】</a>。</p> \n<h2 id=\"3-结语\">3. 结语</h2> \n<p>在本篇中，只是讲解了有关网格布局相关的知识，此处假设大家已经了解了 RecyclerView 中自定义 LayoutManager 的基础内容，如果不太了解的话，可以先去搜索了解一下基础的知识。另外，关于分页对齐等相关内容会在后续的文章中给大家介绍。</p> \n<p><strong>pager-layoutmanager： <a href=\"https://github.com/GcsSloop/pager-layoutmanager\">https://github.com/GcsSloop/pager-layoutmanager</a></strong></p> \n<p>如果喜欢本文的话，欢迎点赞、分享或者打赏支持。</p> \n<h4 id=\"关于作者-1\"><strong>关于作者</strong></h4> \n<p>GcsSloop，一名 2.5 次元魔法师。</p>","descriptionType":"text/html","publishedDate":"Sat, 07 Apr 2018 16:00:00 +0000","feedId":32069,"bgimg":"https://xiaozhuanlan.com/assets/gebug/05-pager-layoutmanager/demo1.gif","linkMd5":"2626f059302a76d3390bd7347e9d1833","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"author":"","articleImgCdnMap":{"http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo1.gif":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn14@2020_3/2020/10/14/03-14-10-861_d245406e9362f458.webp","http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo2.gif":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn18@2020_4/2020/10/14/03-14-10-986_2267a894acb44f03.webp","http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo3.jpg":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn26@2020_1/2020/10/14/03-14-10-560_9c6516e7b49d69c8.webp","http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo4.jpg":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn22@2020_6/2020/10/14/03-14-10-292_05702d92731fb154.webp","http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo5.jpg":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn30@2020_2/2020/10/14/03-14-10-115_9a19d4e2047c30bf.webp"},"publishedOrCreatedDate":1602645219707}],"record":{"createdTime":"2020-10-14 11:13:39","updatedTime":"2020-10-14 11:13:39","feedId":32069,"fetchDate":"Wed, 14 Oct 2020 03:13:39 +0000","fetchMs":2665,"handleMs":8375,"totalMs":45022,"newArticles":0,"totalArticles":51,"status":1,"type":0,"ip":"d74ee4cd41d209f5fd2464bcfd300583","hostName":"europe-58*","requestId":"df8a339106404439ac1becf58d1620c5_32069","contentType":"text/xml; charset=utf-8","totalBytes":219610,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":5,"articlesImgsGithubTotal":5,"successGithubMap":{"myreaderx15":1,"myreaderx27":1,"myreaderx4":1,"myreaderx3":1,"myreaderx24":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:54:30","updatedTime":"2020-09-07 05:03:31","id":32069,"name":"GcsSloop","url":"http://www.gcssloop.com/feed.xml","subscriber":100,"website":null,"icon":"http://www.gcssloop.com/favicon.ico","icon_jsdelivr":null,"description":"嗨，我是 GcsSloop，一名来自2.5次元的魔法师，Android自定义View系列文章作者，非著名程序员。","weekly":null,"link":"http://www.gcssloop.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":219610,"tmpBgImgCdnBytes":0,"extra4":{"start":1602645207357,"total":0,"statList":[{"spend":3975,"msg":"获取xml内容"},{"spend":8375,"msg":"解释文章"},{"spend":3452,"msg":"上传封面图到cdn"},{"spend":1,"msg":"修正封面图上传失败重新上传"},{"spend":5099,"msg":"正文链接上传到cdn"}]},"extra5":5,"extra6":5,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://xiaozhuanlan.com/assets/gebug/05-pager-layoutmanager/demo1.gif","sourceStatusCode":404,"sourceBytes":0,"destBytes":0,"feedId":32069,"totalSpendMs":1376,"convertSpendMs":0,"createdTime":"2020-10-14 11:14:07","host":"us-013*","referer":"https://xiaozhuanlan.com/topic/5841730926","linkMd5ListStr":"2626f059302a76d3390bd7347e9d1833","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://xiaozhuanlan.com/assets/gebug/05-pager-layoutmanager/demo1.gif","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":32069,"totalSpendMs":1885,"convertSpendMs":0,"createdTime":"2020-10-14 11:14:08","host":"europe-60*","referer":"https://xiaozhuanlan.com/topic/5841730926","linkMd5ListStr":"2626f059302a76d3390bd7347e9d1833","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"}],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-001.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-017.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe64.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-51.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-029.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://xiaozhuanlan.com/assets/gebug/05-pager-layoutmanager/demo1.gif","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":32069,"totalSpendMs":1885,"convertSpendMs":0,"createdTime":"2020-10-14 11:14:08","host":"europe-60*","referer":"https://xiaozhuanlan.com/topic/5841730926","linkMd5ListStr":"2626f059302a76d3390bd7347e9d1833","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo5.jpg","sourceStatusCode":200,"destWidth":742,"destHeight":206,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn30@2020_2/2020/10/14/03-14-10-115_9a19d4e2047c30bf.webp","sourceBytes":19505,"destBytes":9738,"targetWebpQuality":75,"feedId":32069,"totalSpendMs":3446,"convertSpendMs":8,"createdTime":"2020-10-14 11:14:07","host":"us-017*","referer":"https://xiaozhuanlan.com/topic/5841730926","linkMd5ListStr":"2626f059302a76d3390bd7347e9d1833","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"19 KB","destSize":"9.5 KB","compressRate":"49.9%"},{"code":1,"isDone":false,"source":"http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo4.jpg","sourceStatusCode":200,"destWidth":573,"destHeight":206,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn22@2020_6/2020/10/14/03-14-10-292_05702d92731fb154.webp","sourceBytes":18622,"destBytes":9930,"targetWebpQuality":75,"feedId":32069,"totalSpendMs":3651,"convertSpendMs":15,"createdTime":"2020-10-14 11:14:07","host":"us-51*","referer":"https://xiaozhuanlan.com/topic/5841730926","linkMd5ListStr":"2626f059302a76d3390bd7347e9d1833","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.2 KB","destSize":"9.7 KB","compressRate":"53.3%"},{"code":1,"isDone":false,"source":"http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo3.jpg","sourceStatusCode":200,"destWidth":404,"destHeight":206,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn26@2020_1/2020/10/14/03-14-10-560_9c6516e7b49d69c8.webp","sourceBytes":12302,"destBytes":7218,"targetWebpQuality":75,"feedId":32069,"totalSpendMs":4018,"convertSpendMs":9,"createdTime":"2020-10-14 11:14:07","host":"us-029*","referer":"https://xiaozhuanlan.com/topic/5841730926","linkMd5ListStr":"2626f059302a76d3390bd7347e9d1833","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12 KB","destSize":"7 KB","compressRate":"58.7%"},{"code":1,"isDone":false,"source":"http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo1.gif","sourceStatusCode":200,"destWidth":300,"destHeight":510,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn14@2020_3/2020/10/14/03-14-10-861_d245406e9362f458.webp","sourceBytes":205402,"destBytes":114116,"targetWebpQuality":75,"feedId":32069,"totalSpendMs":4417,"convertSpendMs":190,"createdTime":"2020-10-14 11:14:07","host":"us-001*","referer":"https://xiaozhuanlan.com/topic/5841730926","linkMd5ListStr":"2626f059302a76d3390bd7347e9d1833","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"200.6 KB","destSize":"111.4 KB","compressRate":"55.6%"},{"code":1,"isDone":false,"source":"http://www.gcssloop.com/assets/gebug/05-pager-layoutmanager/demo2.gif","sourceStatusCode":200,"destWidth":300,"destHeight":510,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn18@2020_4/2020/10/14/03-14-10-986_2267a894acb44f03.webp","sourceBytes":138828,"destBytes":78608,"targetWebpQuality":75,"feedId":32069,"totalSpendMs":5065,"convertSpendMs":166,"createdTime":"2020-10-14 11:14:07","host":"europe64*","referer":"https://xiaozhuanlan.com/topic/5841730926","linkMd5ListStr":"2626f059302a76d3390bd7347e9d1833","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"135.6 KB","destSize":"76.8 KB","compressRate":"56.6%"}],"successGithubMap":{"myreaderx15":1,"myreaderx27":1,"myreaderx4":1,"myreaderx3":1,"myreaderx24":1},"failGithubMap":{}}