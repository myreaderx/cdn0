{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"上手了RabbitMQ？再来看看它的交换机(Exchange)吧","link":"https://segmentfault.com/a/1190000023684246","description":"<blockquote>\n 人生终将是场单人旅途，孤独之前是迷茫，孤独过后是成长。\n</blockquote>\n<h2>楔子</h2>\n<p>本篇是消息队列<code>RabbitMQ</code>的第三弹。</p>\n<p><a href=\"https://segmentfault.com/a/1190000023473302\">RabbitMQ的入门</a>和<a href=\"https://segmentfault.com/a/1190000023564860\">RabbitMQ+SpringBoot的整合</a>可以点此链接进去回顾，今天要讲的是<code>RabbitMQ</code>的交换机。</p>\n<p>本篇是理解<code>RabbitMQ</code>很重要的一篇，交换机是消息的第一站，只有理解了交换机的分发模式，我们才能知道不同交换机根据什么规则分发消息，才能明白在面对不同业务需求的时候应采用哪种交换机。</p>\n<hr>\n <p><a href=\"https://juejin.im/user/5cc53c8251882524f72ccef6/posts\" rel=\"nofollow noreferrer\">祝有好收获，先赞后看，快乐无限。</a></p>\n <p><strong>本文代码：</strong> <a href=\"https://gitee.com/he-erduo/spring-boot-learning-demo\" rel=\"nofollow noreferrer\">码云地址</a> <a href=\"https://github.com/he-erduo/spring-boot-learning-demo\" rel=\"nofollow noreferrer\">GitHub地址</a></p>\n <h2>1. 🔍Exchange</h2>\n <p><img src=\"https://segmentfault.com/img/remote/1460000023473305\" alt=\"rabbit架构图\" title=\"rabbit架构图\" /></p>\n <p>先来放上几乎每篇都要出现一遍的我画了好久的<code>RabbitMQ</code>架构图。</p>\n <p>前两篇文中我们一直没有显式的去使用<code>Exchange</code>，都是使用的默认<code>Exchange</code>，其实<code>Exchange</code>是一个非常关键的组件，有了它才有了各种消息分发模式。</p>\n <p>我先简单说说<code>Exchange</code>有哪几种类型：</p>\n <ol>\n  <li><strong>fanout</strong>：<code>Fanout-Exchange</code>会将它接收到的消息发往所有与他绑定的Queue中。</li>\n  <li><strong>direct</strong>：<code>Direct-Exchange</code>会把它接收到的消息发往与它有绑定关系且<code>Routingkey</code>完全匹配的Queue中（默认）。</li>\n  <li><strong>topic</strong>：<code>Topic-Exchange</code>与Direct-Exchange相似，不过Topic-Exchange不需要全匹配，可以部分匹配，它约定：<code>Routingkey</code>为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词）。</li>\n  <li><strong>header</strong>：<code>Header-Exchange</code>不依赖于RoutingKey或绑定关系来分发消息，而是根据发送的消息内容中的headers属性进行匹配。此模式已经不再使用，本文中也不会去讲，大家知道即可。</li>\n </ol>\n <p>本文中我们主要讲前三种<code>Exchange</code>方式，相信凭借着我简练的文字和灵魂的画技给大家好好讲讲，争取老妪能解。</p>\n <p><strong>Tip</strong>：本文的代码演示直接使用SpringBoot+RabbitMQ的模式。</p>\n <h2>2. 📕Fanout-Exchange</h2>\n <p>先来看看<code>Fanout-Exchange</code>，<code>Fanout-Exchange</code>又称扇形交换机，这个交换机应该是最容易理解的。</p>\n <p><img src=\"https://segmentfault.com/img/remote/1460000023684249\" alt=\"扇形交换机\" title=\"扇形交换机\" /></p>\n <p><code>Exchange</code>和<code>Queue</code>建立一个绑定关系，<code>Exchange</code>会分发给所有和它有绑定关系的<code>Queue</code>中，绑定了十个<code>Queue</code>就把消息复制十份进行分发。</p>\n <p>这种绑定关系为了效率肯定都会维护一张表，从算法效率上来说一般是O(1)，所以<code>Fanout-Exchange</code>是这几个交换机中<strong>查找需要被分发队列</strong>最快的交换机。</p>\n <hr>\n  <p>下面是一段代码演示：</p>\n  <pre><code class=\"java\">    @Bean\n    public Queue fanout1() {\n        return new Queue(\"fanout1\");\n    }\n\n    @Bean\n    public Queue fanout2() {\n        return new Queue(\"fanout2\");\n    }\n\n    @Bean\n    public FanoutExchange fanoutExchange() {\n        // 三个构造参数：name durable autoDelete\n        return new FanoutExchange(\"fanoutExchange\", false, false);\n    }\n\n    @Bean\n    public Binding binding1() {\n        return BindingBuilder.bind(fanout1()).to(fanoutExchange());\n    }\n\n    @Bean\n    public Binding binding2() {\n        return BindingBuilder.bind(fanout2()).to(fanoutExchange());\n    }</code></pre>\n  <p>为了清晰明了，我新建了两个演示用的队列，然后建了一个<code>FanoutExchange</code>，最后给他们都设置上绑定关系，这样一组队列和交换机的绑定设置就算完成了。</p>\n  <p>紧接着编写一下生产者和消费者：</p>\n  <pre><code class=\"java\">    public void sendFanout() {\n        Client client = new Client();\n\n        // 应读者要求，以后代码打印的地方都会改成log方式，这是一种良好的编程习惯，用System.out.println一般是不推荐的。\n        log.info(\"Message content : \" + client);\n\n        rabbitTemplate.convertAndSend(\"fanoutExchange\",null,client);\n        System.out.println(\"消息发送完毕。\");\n    }\n\n    @Test\n    public void sendFanoutMessage() {\n        rabbitProduce.sendFanout();\n    }</code></pre>\n  <pre><code class=\"java\">@Slf4j\n@Component(\"rabbitFanoutConsumer\")\npublic class RabbitFanoutConsumer {\n    @RabbitListener(queues = \"fanout1\")\n    public void onMessage1(Message message, Channel channel) throws Exception {\n        log.info(\"Message content : \" + message);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);\n        log.info(\"消息已确认\");\n    }\n\n    @RabbitListener(queues = \"fanout2\")\n    public void onMessage2(Message message, Channel channel) throws Exception {\n        log.info(\"Message content : \" + message);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);\n        log.info(\"消息已确认\");\n    }\n\n}</code></pre>\n  <p>这两段代码都很好理解，不再赘述，有遗忘的可以去看<a href=\"https://juejin.im/post/6856571028496351239\" rel=\"nofollow noreferrer\">RabbitMQ第一弹</a>的内容。</p>\n  <p>其中发送消息的代码有三个参数，第一个参数是<code>Exchange</code>的名称，第二个参数是<code>routingKey</code>的名称，这个参数在扇形交换机里面用不到，在其他两个交换机类型里面会用到。</p>\n  <p>代码的准备到此结束，我们可以运行发送方法之后run一下了~</p>\n  <p>项目启动后，我们可以先来观察一下队列与交换机的绑定关系有没有生效，我们在RabbitMQ控制台使用<code>rabbitmqctl list_bindings</code>命令查看绑定关系。</p>\n  <p><img src=\"https://segmentfault.com/img/remote/1460000023684252\" alt=\"扇形交换机绑定关系\" title=\"扇形交换机绑定关系\" /></p>\n  <p>关键部分我用红框标记了起来，这就代表着名叫<code>fanoutExchange</code>的交换机绑定着两个队列，一个叫<code>fanout1</code>，另一个叫<code>fanout2</code>。</p>\n  <p>紧接着，我们来看控制台的打印情况：</p>\n  <p><img src=\"https://segmentfault.com/img/remote/1460000023684251\" alt=\"扇形交换机确认消息\" title=\"扇形交换机确认消息\" /></p>\n  <p>可以看到，一条信息发送出去之后，两个队列都接收到了这条消息，紧接着由我们的两个消费者消费。</p>\n  <p><strong>Tip：</strong> 如果你的演示应用启动之后没有消费信息，可以尝试重新运行一次生产者的方法发送消息。</p>\n  <h2>3. 📗Direct-Exchange</h2>\n  <p><code>Direct-Exchange</code>是一种精准匹配的交换机，我们之前一直使用默认的交换机，其实默认的交换机就是Direct类型。</p>\n  <p>如果将Direct交换机都比作一所公寓的管理员，那么队列就是里面的住户。(绑定关系)</p>\n  <p>管理员每天都会收到各种各样的信件(消息)，这些信件的地址不光要标明地址(ExchangeKey)还需要标明要送往哪一户(routingKey)，不然消息无法投递。</p>\n  <p><img src=\"https://segmentfault.com/img/remote/1460000023684250\" alt=\"扇形交换机\" title=\"扇形交换机\" /></p>\n  <p>以上图为例，准备一条消息发往名为<code>SendService</code>的直接交换机中去，这个交换机主要是用来做发送服务，所以其绑定了两个队列，SMS队列和MAIL队列，用于发送短信和邮件。</p>\n  <p>我们的消息除了指定<code>ExchangeKey</code>还需要指定<code>routingKey</code>，<code>routingKey</code>对应着最终要发送的是哪个队列，我们的示例中的<code>routingKey</code>是sms，这里这条消息就会交给SMS队列。</p>\n  <hr>\n   <p>听了上面这段，可能大家对<code>routingKey</code>还不是很理解，我们上段代码实践一下，大家应该就明白了。</p>\n   <p><strong>准备工作：</strong></p>\n   <pre><code class=\"java\">    @Bean\n    public Queue directQueue1() {\n        return new Queue(\"directQueue1\");\n    }\n\n    @Bean\n    public Queue directQueue2() {\n        return new Queue(\"directQueue2\");\n    }\n\n    @Bean\n    public DirectExchange directExchange() {\n        // 三个构造参数：name durable autoDelete\n        return new DirectExchange(\"directExchange\", false, false);\n    }\n\n    @Bean\n    public Binding directBinding1() {\n        return BindingBuilder.bind(directQueue1()).to(directExchange()).with(\"sms\");\n    }\n\n    @Bean\n    public Binding directBinding2() {\n        return BindingBuilder.bind(directQueue2()).to(directExchange()).with(\"mail\");\n    }</code></pre>\n   <p>新建两个队列，新建了一个直接交换机，并设置了绑定关系。</p>\n   <p>这里的示例代码和上面扇形交换机的代码很像，唯一可以说不同的就是绑定的时候多调用了一个<code>with</code>将<code>routingKey</code>设置了上去。</p>\n   <p>所以是交换机和队列建立绑定关系的时候设置的<code>routingKey</code>，一个消息到达交换机之后，交换机通过消息上带来的<code>routingKey</code>找到自己与队列建立绑定关系时设置的<code>routingKey</code>，然后将消息分发到这个队列去。</p>\n   <p><strong>生产者：</strong></p>\n   <pre><code class=\"java\">    public void sendDirect() {\n        Client client = new Client();\n\n        log.info(\"Message content : \" + client);\n\n        rabbitTemplate.convertAndSend(\"directExchange\",\"sms\",client);\n        System.out.println(\"消息发送完毕。\");\n    }</code></pre>\n   <p><strong>消费者：</strong></p>\n   <pre><code class=\"java\">@Slf4j\n@Component(\"rabbitDirectConsumer\")\npublic class RabbitDirectConsumer {\n    @RabbitListener(queues = \"directQueue1\")\n    public void onMessage1(Message message, Channel channel) throws Exception {\n        log.info(\"Message content : \" + message);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);\n        log.info(\"消息已确认\");\n    }\n\n    @RabbitListener(queues = \"directQueue2\")\n    public void onMessage2(Message message, Channel channel) throws Exception {\n        log.info(\"Message content : \" + message);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);\n        log.info(\"消息已确认\");\n    }\n\n}</code></pre>\n   <p><strong>效果图如下：</strong></p>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000023684253\" alt=\"扇形交换机\" title=\"扇形交换机\" /></p>\n   <p>只有一个消费者进行了消息，符合我们的预期。</p>\n   <h2>4. 📙Topic-Exchange</h2>\n   <p><code>Topic-Exchange</code>是直接交换机的模糊匹配版本，Topic类型的交换器，支持使用\"*\"和\"#\"通配符定义模糊bindingKey，然后按照<code>routingKey</code>进行模糊匹配队列进行分发。</p>\n   <ul>\n    <li><code>*</code>：能够模糊匹配一个单词。</li>\n    <li><code>#</code>：能够模糊匹配零个或多个单词。</li>\n   </ul>\n   <p>因为加入了两个通配定义符，所以Topic交换机的<code>routingKey</code>也有些变化，<code>routingKey</code>可以使用<code>.</code>将单词分开。</p>\n   <hr>\n    <p>这里我们直接来用一个例子说明会更加的清晰：</p>\n    <p><strong>准备工作：</strong></p>\n    <pre><code class=\"java\">    // 主题交换机示例\n    @Bean\n    public Queue topicQueue1() {\n        return new Queue(\"topicQueue1\");\n    }\n\n    @Bean\n    public Queue topicQueue2() {\n        return new Queue(\"topicQueue2\");\n    }\n\n    @Bean\n    public TopicExchange topicExchange() {\n        // 三个构造参数：name durable autoDelete\n        return new TopicExchange(\"topicExchange\", false, false);\n    }\n\n    @Bean\n    public Binding topicBinding1() {\n        return BindingBuilder.bind(topicQueue1()).to(topicExchange()).with(\"sms.*\");\n    }\n\n    @Bean\n    public Binding topicBinding2() {\n        return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(\"mail.#\");\n    }</code></pre>\n    <p>新建两个队列，新建了一个Topic交换机，并设置了绑定关系。</p>\n    <p>这里的示例代码我们主要看设置<code>routingKey</code>，这里的<code>routingKey</code>用上了通配符，且中间用<code>.</code>隔开，这就代表<code>topicQueue1</code>消费<code>sms</code>开头的消息，<code>topicQueue2</code>消费<code>mail</code>开头的消息，具体不同往下看。</p>\n    <p><strong>生产者：</strong></p>\n    <pre><code class=\"java\">    public void sendTopic() {\n        Client client = new Client();\n\n        log.info(\"Message content : \" + client);\n\n        rabbitTemplate.convertAndSend(\"topicExchange\",\"sms.liantong\",client);\n        System.out.println(\"消息发送完毕。\");\n    }</code></pre>\n    <p><strong>消费者：</strong></p>\n    <pre><code class=\"java\">@Slf4j\n@Component(\"rabbitTopicConsumer\")\npublic class RabbitTopicConsumer {\n    @RabbitListener(queues = \"topicQueue1\")\n    public void onMessage1(Message message, Channel channel) throws Exception {\n        log.info(\"Message content : \" + message);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);\n        log.info(\"消息已确认\");\n    }\n\n    @RabbitListener(queues = \"topicQueue2\")\n    public void onMessage2(Message message, Channel channel) throws Exception {\n        log.info(\"Message content : \" + message);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);\n        log.info(\"消息已确认\");\n    }\n\n}</code></pre>\n    <p>这里我们的生产者发送的消息<code>routingKey</code>是<code>sms.liantong</code>，它就会被发到<code>topicQueue1</code>队列中去，这里消息的<code>routingKey</code>也需要用<code>.</code>隔离开，用其他符号无法正确识别。</p>\n    <p>如果我们的<code>routingKey</code>是<code>sms.123.liantong</code>，那么它将无法找到对应的队列，因为<code>topicQueue1</code>的模糊匹配用的通配符是<code>*</code>而不是<code>#</code>，只有<code>#</code>是可以匹配多个单词的。</p>\n    <p><code>Topic-Exchange</code>和<code>Direct-Exchange</code>很相似，我就不再赘述了，通配符<code>*</code>和<code>#</code>的区别也很简单，大家可以自己试一下。</p>\n    <h2>后记</h2>\n    <p>周一没更文实在惭愧，去医院抽血了，抽了三管~，吃多少才能补回来~</p>\n    <p>RabbitMQ已经更新了三篇了，这三篇的内容有些偏基础，下一篇将会更新高级部分内容：包括防止消息丢失，防止消息重复消费等等内容，希望大家持续关注。</p>\n    <hr>\n     <p>最近这段时间压力挺大，优狐令我八月底之前升级到三级，所以各位读者的赞对我很重要，希望大家能够高抬贵手，帮我一哈~</p>\n     <p>好了，以上就是本期的全部内容，感谢你能看到这里，欢迎对本文点赞收藏与评论，👍你们的每个点赞都是我创作的最大动力。</p>\n     <p>我是耳朵，一个一直想做知识输出的伪文艺程序员，我们下期见。</p>\n     <p><strong>本文代码：</strong><a href=\"https://gitee.com/he-erduo/spring-boot-learning-demo\" rel=\"nofollow noreferrer\">码云地址</a> <a href=\"https://github.com/he-erduo/spring-boot-learning-demo\" rel=\"nofollow noreferrer\">GitHub地址</a></p>\n    </hr>\n   </hr>\n  </hr>\n </hr>\n</hr>","descriptionType":"html","publishedDate":"Wed, 19 Aug 2020 05:28:31 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023473305","linkMd5":"420bda976c9e79232c9adc2d2bfab39b","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn14@2020_2/2020/08/24/23-08-22-277_79d59aaca7438433.webp","destWidth":800,"destHeight":317,"sourceBytes":62172,"destBytes":17268,"author":"和耳朵","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023473305":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn14@2020_2/2020/08/24/23-08-22-277_79d59aaca7438433.webp","https://segmentfault.com/img/remote/1460000023684249":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn32@2020_2/2020/08/24/23-08-39-108_9e9ebdfe1d798e4b.webp","https://segmentfault.com/img/remote/1460000023684252":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn72@2020_5/2020/08/24/23-08-39-252_6e03b370097de657.webp","https://segmentfault.com/img/remote/1460000023684251":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn64@2020_1/2020/08/24/23-08-39-180_f004b02cd44eaa50.webp","https://segmentfault.com/img/remote/1460000023684250":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn60@2020_2/2020/08/24/23-08-38-560_259f8fe4710a279d.webp","https://segmentfault.com/img/remote/1460000023684253":"https://cdn.jsdelivr.net/gh/myreaderx/cdn76@2020_6/2020/08/24/23-08-40-810_153921800664839e.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"redux、mobx、concent特性大比拼, 看后生如何对局前辈","link":"https://segmentfault.com/a/1190000022332809","description":"<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/banner-rmc-compare.png\" alt=\"\" title=\"\" /></p>\n<p><strong><a href=\"https://github.com/concentjs/concent\" rel=\"nofollow noreferrer\">❤ star me if you like concent ^_^</a></strong></p>\n<h2>序言</h2>\n<p><code>redux</code>、<code>mobx</code>本身是一个独立的状态管理框架，各自有自己的抽象api，以其他UI框架无关（react, vue...），本文主要说的和<code>react</code>搭配使用的对比效果，所以下文里提到的<code>redux</code>、<code>mobx</code>暗含了<code>react-redux</code>、<code>mobx-react</code>这些让它们能够在<code>react</code>中发挥功能的绑定库，而<code>concent</code>本身是为了<code>react</code>贴身打造的开发框架，数据流管理只是作为其中一项功能，附带的其他增强react开发体验的特性可以按需使用，后期会刨去<code>concent</code>里所有与<code>react</code>相关联的部分发布<code>concent-core</code>，它的定位才是与<code>redux</code>、<code>mobx</code> 相似的。</p>\n<p>所以其实将在本文里登场的选手分别是</p>\n<h3>redux &amp; react-redux</h3>\n<ul>\n <li>slogan <br> JavaScript 状态容器，提供可预测化的状态管理</br></li>\n <li>设计理念 <br> 单一数据源，使用纯函数修改状态</br></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/1.png\" alt=\"\" title=\"\" /></p>\n<h3>mobx &amp; mobx-react</h3>\n<ul>\n <li>slogan： <br> 简单、可扩展的状态管理</br></li>\n <li>设计理念 <br> 任何可以从应用程序状态派生的内容都应该派生</br></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/2.png\" alt=\"\" title=\"\" /></p>\n<h3>concent</h3>\n<ul>\n <li>slogan： <br> 可预测、0入侵、渐进式、高性能的react开发方案</br></li>\n <li>设计理念 <br> 相信融合不可变+依赖收集的开发方式是react的未来，增强react组件特性，写得更少，做得更多。</br></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/3.png\" alt=\"\" title=\"\" /></p>\n<p>介绍完三者的背景，我们的舞台正式交给它们，开始一轮轮角逐，看谁到最后会是你最中意的范儿？</p>\n<h3>结果预览</h3>\n<p>以下5个较量回合实战演示代码较多，此处将对比结果提前告知，方便粗读看客可以快速了解。</p>\n<table>\n <thead>\n  <tr>\n   <th>store配置</th>\n   <th>concent</th>\n   <th>mbox</th>\n   <th>redux</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>支持分离</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>无根Provider &amp; 使用处无需显式导入</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>reducer无<code>this</code></td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>Yes</td>\n  </tr>\n  <tr>\n   <td>store数据或方法无需人工映射到组件</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n </tbody>\n</table>\n<p><strong><a href=\"https://codesandbox.io/s/redux-counter-2mk1g\" rel=\"nofollow noreferrer\">redux counter示例</a></strong> <br> <strong><a href=\"https://codesandbox.io/s/counter-mobx-9kt50\" rel=\"nofollow noreferrer\">mobx counter示例</a></strong> <br> <strong><a href=\"https://codesandbox.io/s/concent-counter-y61if\" rel=\"nofollow noreferrer\">concent counter示例</a></strong> <br><em>_</em></br></br></br></p>\n<table>\n <thead>\n  <tr>\n   <th>状态修改</th>\n   <th>concent</th>\n   <th>mbox</th>\n   <th>redux</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>基于不可变原则</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>Yes</td>\n  </tr>\n  <tr>\n   <td>最短链路</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>ui源头可追踪</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>无this</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>Yes</td>\n  </tr>\n  <tr>\n   <td>原子拆分&amp;合并提交</td>\n   <td>Yes(基于lazy)</td>\n   <td>Yes(基于transaction)</td>\n   <td>No</td>\n  </tr>\n </tbody>\n</table>\n<p><em>_</em></p>\n<table>\n <thead>\n  <tr>\n   <th>依赖收集</th>\n   <th>concent</th>\n   <th>mbox</th>\n   <th>redux</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>支持运行时收集依赖</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>精准渲染</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>无this</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>只需一个api介入</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>No</td>\n  </tr>\n </tbody>\n</table>\n<p><strong><a href=\"https://codesandbox.io/s/mobx-login-dx4wl\" rel=\"nofollow noreferrer\">mobx 示例</a></strong> <br> <strong><a href=\"https://codesandbox.io/s/concent-login-ylbl4\" rel=\"nofollow noreferrer\">concent 示例</a></strong> </br></p>\n<p><em>_</em></p>\n<table>\n <thead>\n  <tr>\n   <th>衍生数据</th>\n   <th>concent</th>\n   <th>mbox</th>\n   <th>redux(reselect)</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>自动维护计算结果之间的依赖</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>触发读取计算结果时收集依赖</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>计算函数无this</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>Yes</td>\n  </tr>\n </tbody>\n</table>\n<p><strong><a href=\"https://codesandbox.io/s/redux-login-6uqg8\" rel=\"nofollow noreferrer\">redux computed示例</a></strong> <br> <strong><a href=\"https://codesandbox.io/s/mobx-login-dx4wl\" rel=\"nofollow noreferrer\">mobx computed示例</a></strong> <br> <strong><a href=\"https://codesandbox.io/s/concent-login-ylbl4\" rel=\"nofollow noreferrer\">concent computed示例</a></strong> </br></br></p>\n<p><em>_</em><br>todo-mvc实战 <br><strong><a href=\"https://codesandbox.io/s/todo-mvc-redux-49kg0\" rel=\"nofollow noreferrer\">redux todo-mvc</a></strong> <br><strong><a href=\"https://codesandbox.io/s/todo-mvc-mbox-k42q1\" rel=\"nofollow noreferrer\">mobx todo-mvc</a></strong> <br><strong><a href=\"https://codesandbox.io/s/todoapp-react-concent-fvgvc\" rel=\"nofollow noreferrer\">concent todo-mvc</a></strong></br></br></br></br></p>\n<h2>round 1 - 代码风格初体验</h2>\n<p>counter作为demo界的靓仔被无数次推上舞台，这一次我们依然不例外，来个counter体验3个框架的开发套路是怎样的，以下3个版本都使用<code>create-react-app</code>创建，并以<strong>多模块的方式</strong>来组织代码，力求接近真实环境的代码场景。</p>\n<h3>redux(action、reducer)</h3>\n<p>通过<code>models</code>把按模块把功能拆到不同的reducer里，目录结构如下</p>\n<pre><code>|____models             # business models\n| |____index.js         # 暴露store\n| |____counter          # counter模块相关的action、reducer\n| | |____action.js     \n| | |____reducer.js     \n| |____ ...             # 其他模块\n|____CounterCls         # 类组件\n|____CounterFn          # 函数组件\n|____index.js           # 应用入口文件</code></pre>\n<blockquote>\n 此处仅与redux的原始模板组织代码，实际情况可能不少开发者选择了\n <code>rematch</code>，\n <code>dva</code>等基于redux做二次封装并改进写法的框架，但是并不妨碍我们理解counter实例。\n</blockquote>\n<p>构造counter的<code>action</code></p>\n<pre><code class=\"js\">// code in models/counter/action\nexport const INCREMENT = \"INCREMENT\";\n\nexport const DECREMENT = \"DECREMENT\";\n\nexport const increase = number =&gt; {\n  return { type: INCREMENT, payload: number };\n};\n\nexport const decrease = number =&gt; {\n  return {  type: DECREMENT, payload: number };\n};</code></pre>\n<p>构造counter的<code>reducer</code></p>\n<pre><code class=\"js\">// code in models/counter/reducer\nimport { INCREMENT, DECREMENT } from \"./action\";\n\nexport default (state = { count: 0 }, action) =&gt; {\n  const { type, payload } = action;\n  switch (type) {\n    case INCREMENT:\n      return { ...state, count: state.count + payload };\n    case DECREMENT:\n      return { ...state, count: state.count - payload };\n    default:\n      return state;\n  }\n};\n</code></pre>\n<p>合并<code>reducer</code>构造<code>store</code>，并注入到根组件</p>\n<pre><code class=\"jsx\">mport { createStore, combineReducers } from \"redux\";\nimport  countReducer  from \"./models/counter/reducer\";\n\nconst store = createStore(combineReducers({counter:countReducer}));\n\nReactDOM.render(\n  &lt;Provider store={store}&gt;\n    &lt;App /&gt;\n  &lt;/Provider&gt;,\n  document.getElementById(\"root\")\n);</code></pre>\n<p>使用connect连接ui与<code>store</code></p>\n<pre><code class=\"jsx\">import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { increase, decrease } from \"./redux/action\";\n\n@connect(\n  state =&gt; ({ count: state.counter.count }),// mapStateToProps\n  dispatch =&gt; ({// mapDispatchToProps\n    increase: () =&gt; dispatch(increase(1)),\n    decrease: () =&gt; dispatch(decrease(1))\n  }),\n)\nclass Counter extends React.Component {\n  render() {\n    const { count, increase, decrease } = this.props;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Count : {count}&lt;/h1&gt;\n        &lt;button onClick={increase}&gt;Increase&lt;/button&gt;\n        &lt;button onClick={decrease}&gt;decrease&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default Counter;</code></pre>\n<p>上面的示例书写了一个类组件，而针对现在火热的<code>hook</code>，<code>redux v7</code>也发布了相应的api<code>useSelector</code>、<code>useDispatch</code></p>\n<pre><code class=\"jsx\">import * as React from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport * as counterAction from \"models/counter/action\";\n\nconst Counter = () =&gt; {\n  const count = useSelector(state =&gt; state.counter.count);\n  const dispatch = useDispatch();\n  const increase = () =&gt; dispatch(counterAction.increase(1));\n  const decrease = () =&gt; dispatch(counterAction.decrease(1));\n\n  return (\n    &lt;&gt;\n      &lt;h1&gt;Fn Count : {count}&lt;/h1&gt;\n      &lt;button onClick={increase}&gt;Increase&lt;/button&gt;\n      &lt;button onClick={decrease}&gt;decrease&lt;/button&gt;\n    &lt;/&gt;\n  );\n};\n\nexport default Counter;</code></pre>\n<p>渲染这两个counter，<strong><a href=\"https://codesandbox.io/s/redux-counter-2mk1g\" rel=\"nofollow noreferrer\">查看redux示例</a></strong></p>\n<pre><code class=\"jsx\">function App() {\n  return (\n      &lt;div className=\"App\"&gt;\n        &lt;CounterCls/&gt;\n        &lt;CounterFn/&gt;\n      &lt;/div&gt;\n  );\n}</code></pre>\n<h3>mobx(store, inject)</h3>\n<p>当应用存在多个store时(这里我们可以把一个store理解成redux里的一个reducer块，聚合了数据、衍生数据、修改行为)，mobx的store获取方式有多种，例如在需要用的地方直接引入放到成员变量上</p>\n<pre><code class=\"js\">import someStore from 'models/foo';// 是一个已经实例化的store实例\n\n@observer\nclass Comp extends React.Component{\n    foo = someStore;\n    render(){\n        this.foo.callFn();//调方法\n        const text = this.foo.text;//取数据\n    }\n}</code></pre>\n<p>我们此处则按照公认的最佳实践来做，即把所有store合成一个根store挂到Provider上，并将Provider包裹整个应用根组件，在使用的地方标记<code>inject</code>装饰器即可，我们的目录结构最终如下，和<code>redux</code>版本并无区别</p>\n<pre><code>|____models             # business models\n| |____index.js         # 暴露store\n| |____counter          # counter模块相关的store\n| | |____store.js     \n| |____ ...             # 其他模块\n|____CounterCls         # 类组件\n|____CounterFn          # 函数组件\n|____index.js           # 应用入口文件</code></pre>\n<p>构造counter的<code>store</code></p>\n<pre><code class=\"js\">import { observable, action, computed } from \"mobx\";\n\nclass CounterStore {\n  @observable\n  count = 0;\n\n  @action.bound\n  increment() {\n    this.count++;\n  }\n\n  @action.bound\n  decrement() {\n    this.count--;\n  }\n}\n\nexport default new CounterStore();</code></pre>\n<p>合并所有<code>store</code>为<code>根store</code>，并注入到根组件</p>\n<pre><code class=\"jsx\">// code in models/index.js\nimport counter from './counter';\nimport login from './login';\n\nexport default {\n  counter,\n  login,\n}\n\n// code in index.js\nimport React, { Component } from \"react\";\nimport { render } from \"react-dom\";\nimport { Provider } from \"mobx-react\";\nimport store from \"./models\";\nimport CounterCls from \"./CounterCls\";\nimport CounterFn from \"./CounterFn\";\n\nrender(    \n    &lt;Provider store={store}&gt;\n      &lt;App /&gt;\n    &lt;/Provider&gt;, \n    document.getElementById(\"root\")\n);</code></pre>\n<p>创建一个类组件</p>\n<pre><code class=\"jsx\">import React, { Component } from \"react\";\nimport { observer, inject } from \"mobx-react\";\n\n@inject(\"store\")\n@observer\nclass CounterCls extends Component {\n  render() {\n    const counter = this.props.store.counter;\n    return (\n      &lt;div&gt;\n        &lt;div&gt; class Counter {counter.count}&lt;/div&gt;\n        &lt;button onClick={counter.increment}&gt;+&lt;/button&gt;\n        &lt;button onClick={counter.decrement}&gt;-&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default CounterCls;</code></pre>\n<p>创建一个函数组件</p>\n<pre><code class=\"jsx\">import React from \"react\";\nimport { useObserver, observer } from \"mobx-react\";\nimport store from \"./models\";\n\nconst CounterFn = () =&gt; {\n  const { counter } = store;\n  return useObserver(() =&gt; (\n      &lt;div&gt;\n        &lt;div&gt; class Counter {counter.count}&lt;/div&gt;\n        &lt;button onClick={counter.increment}&gt;++&lt;/button&gt;\n        &lt;button onClick={counter.decrement}&gt;--&lt;/button&gt;\n      &lt;/div&gt;\n  ));\n};\n\nexport default CounterFn;</code></pre>\n<p>渲染这两个counter，<strong><a href=\"https://codesandbox.io/s/counter-mobx-9kt50\" rel=\"nofollow noreferrer\">查看mobx示例</a></strong></p>\n<pre><code class=\"jsx\">function App() {\n  return (\n      &lt;div className=\"App\"&gt;\n        &lt;CounterCls/&gt;\n        &lt;CounterFn/&gt;\n      &lt;/div&gt;\n  );\n}</code></pre>\n<h3>concent(reducer, register)</h3>\n<p>concent和redux一样，存在一个全局单一的根状态<code>RootStore</code>，该根状态下第一层key用来当做模块命名空间，concent的一个模块必需配置<code>state</code>，剩下的<code>reducer</code>、<code>computed</code>、<code>watch</code>、<code>init</code>是可选项，可以按需配置，如果把store所有模块写到一处，最简版本的<code>concent</code>示例如下</p>\n<pre><code class=\"js\">import { run, setState, getState, dispatch } from 'concent';\nrun({\n    counter:{// 配置counter模块\n        state: { count: 0 }, // 【必需】定义初始状态, 也可写为函数 ()=&gt;({count:0})\n        // reducer: { ...}, // 【可选】修改状态的方法\n        // computed: { ...}, // 【可选】计算函数\n        // watch: { ...}, // 【可选】观察函数\n        // init: { ...}, // 【可选】异步初始化状态函数\n    }\n})；\n\nconst count = getState('counter').count;// count is: 0\n// count is: 1，如果有组件属于该模块则会被触发重渲染\nsetState('counter', {count:count + 1});\n\n// 如果定义了counter.reducer下定义了changeCount方法\n// dispatch('counter/changeCount')</code></pre>\n<p>启动<code>concent</code>载入store后，可在其它任意类组件或函数组件里注册其属于于某个指定模块或者连接多个模块</p>\n<pre><code class=\"jsx\">import { useConcent, register } from 'concent';\n\nfunction FnComp(){\n    const { state, setState, dispatch } = useConcent('counter');\n    // return ui ...\n}\n\n@register('counter')\nclass ClassComp extends React.Component(){\n    render(){\n        const { state, setState, dispatch } = this.ctx;\n        // return ui ...\n    }\n}</code></pre>\n<p>但是推荐将模块定义选项放置到各个文件中，以达到职责分明、关注点分离的效果，所以针对counter，目录结构如下</p>\n<pre><code>|____models             # business models\n| |____index.js         # 配置store各个模块\n| |____counter          # counter模块相关\n| | |____state.js       # 状态\n| | |____reducer.js     # 修改状态的函数\n| | |____index.js       # 暴露counter模块\n| |____ ...             # 其他模块\n|____CounterCls         # 类组件\n|____CounterFn          # 函数组件\n|____index.js           # 应用入口文件\n|____runConcent.js      # 启动concent </code></pre>\n<p>构造counter的<code>state</code>和<code>reducer</code></p>\n<pre><code class=\"jsx\">// code in models/counter/state.js\nexport default {\n  count: 0,\n}\n\n// code in models/counter/reducer.js\nexport function increase(count, moduleState) {\n  return { count: moduleState.count + count };\n}\n\nexport function decrease(count, moduleState) {\n  return { count: moduleState.count - count };\n}</code></pre>\n<p>两种方式配置store</p>\n<ul>\n <li>配置在run函数里</li>\n</ul>\n<pre><code class=\"js\">import counter from 'models/counter';\n\nrun({counter});</code></pre>\n<ul>\n <li>通过<code>configure</code>接口配置, <code>run</code>接口只负责启动concent</li>\n</ul>\n<pre><code class=\"js\">// code in runConcent.js\nimport { run } from 'concent';\nrun();\n\n// code in models/counter/index.js\nimport state from './state';\nimport * as reducer from './reducer';\nimport { configure } from 'concent';\n\nconfigure('counter', {state, reducer});// 配置counter模块</code></pre>\n<p>创建一个函数组件</p>\n<pre><code class=\"jsx\">import * as React from \"react\";\nimport { useConcent } from \"concent\";\n\nconst Counter = () =&gt; {\n  const { state, dispatch } = useConcent(\"counter\");\n  const increase = () =&gt; dispatch(\"increase\", 1);\n  const decrease = () =&gt; dispatch(\"decrease\", 1);\n\n  return (\n    &lt;&gt;\n      &lt;h1&gt;Fn Count : {state.count}&lt;/h1&gt;\n      &lt;button onClick={increase}&gt;Increase&lt;/button&gt;\n      &lt;button onClick={decrease}&gt;decrease&lt;/button&gt;\n    &lt;/&gt;\n  );\n};\n\nexport default Counter;</code></pre>\n<p>该函数组件我们是按照传统的<code>hook</code>风格来写，即每次渲染执行<code>hook</code>函数，利用<code>hook</code>函数返回的基础接口再次定义符合当前业务需求的动作函数。</p>\n<p>但是由于concent提供<code>setup</code>接口，我们可以利用它只会在初始渲染前执行一次的能力，将这些动作函数放置到<code>setup</code>内部定义为静态函数，避免重复定义，所以一个更好的函数组件应为</p>\n<pre><code class=\"jsx\">import * as React from \"react\";\nimport { useConcent } from \"concent\";\n\nexport const setup = ctx =&gt; {\n  return {\n    // better than ctx.dispatch('increase', 1);\n    increase: () =&gt; ctx.moduleReducer.increase(1),\n    decrease: () =&gt; ctx.moduleReducer.decrease(1)\n  };\n};\n\nconst CounterBetter = () =&gt; {\n  const { state, settings } = useConcent({ module: \"counter\", setup });\n  const { increase, decrease } = settings;\n  // return ui...\n};\n\nexport default CounterBetter;\n</code></pre>\n<p>创建一个类组件，复用<code>setup</code>里的逻辑</p>\n<pre><code class=\"jsx\">import React from \"react\";\nimport { register } from \"concent\";\nimport { setup } from './CounterFn';\n\n@register({module:'counter', setup})\nclass Counter extends React.Component {\n  render() {\n    // this.state 和 this.ctx.state 取值效果是一样的\n    const { state, settings } = this.ctx;\n     // return ui...\n  }\n}\n\nexport default Counter;</code></pre>\n<p>渲染这两个counter，<strong><a href=\"https://codesandbox.io/s/concent-counter-y61if\" rel=\"nofollow noreferrer\">查看concent示例</a></strong></p>\n<pre><code class=\"jsx\">function App() {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;CounterCls /&gt;\n      &lt;CounterFn /&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n<h3>回顾与总结</h3>\n<p>此回合里展示了3个框架对定义多模块状态时，不同的代码组织与结构</p>\n<ul>\n <li><code>redux</code>通过<code>combineReducers</code>配合<code>Provider</code>包裹根组件，同时还收手写<code>mapStateToProps</code>和<code>mapActionToProps</code>来辅助组件获取store的数据和方法</li>\n <li><code>mobx</code>通过合并多个<code>subStore</code>到一个<code>store</code>对象并配合<code>Provider</code>包裹根组件，store的数据和方法可直接获取</li>\n <li><code>concent</code>通过<code>run</code>接口集中配置或者<code>configure</code>接口分离式的配置，store的数据和方法可直接获取</li>\n</ul>\n<table>\n <thead>\n  <tr>\n   <th>store配置</th>\n   <th>concent</th>\n   <th>mbox</th>\n   <th>redux</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>支持分离</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>无根Provider &amp; 使用处无需显式导入</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>reducer无<code>this</code></td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>Yes</td>\n  </tr>\n  <tr>\n   <td>store数据或方法无需人工映射到组件</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n </tbody>\n</table>\n<h2>round 2 - 状态修改</h2>\n<p>3个框架对状态的修改风格差异较大。<br><code>redux</code>里严格限制状态修改途径，所以的修改状态行为都必须派发<code>action</code>，然后命中相应<code>reducer</code>合成新的状态。</br></p>\n<p><code>mobx</code>具有响应式的能力，直接修改即可，但因此也带来了数据修改途径不可追溯的烦恼从而产生了<code>mobx-state-tree</code>来配套约束修改数据行为。</p>\n<p><code>concent</code>的修改完完全全遵循<code>react</code>的修改入口<code>setState</code>风格，在此基础之上进而封装<code>dispatch</code>、<code>invoke</code>、<code>sync</code>系列api，且无论是调用哪一种api，都能够不只是追溯数据修改完整链路，还包括触发数据修改的源头。</p>\n<h3>redux(dispatch)</h3>\n<p>同步的action</p>\n<pre><code class=\"js\">export const changeFirstName = firstName =&gt; {\n  return {\n    type: CHANGE_FIRST_NAME,\n    payload: firstName\n  };\n};</code></pre>\n<p>异步的action，借助<code>redux-thunk</code>来完成</p>\n<pre><code class=\"js\">// code in models/index.js, 配置thunk中间件\nimport  thunk  from \"redux-thunk\";\nimport { createStore, combineReducers, applyMiddleware } from \"redux\";\nconst store = createStore(combineReducers({...}), applyMiddleware(thunk));\n\n// code in models/login/action.js\nexport const CHANGE_FIRST_NAME = \"CHANGE_FIRST_NAME\";\n\nconst delay = (ms = 1000) =&gt; new Promise(r =&gt; setTimeout(r, ms));\n// 工具函数，辅助写异步action\nconst asyncAction = asyncFn =&gt; {\n  return dispatch =&gt; {\n    asyncFn(dispatch).then(ret =&gt; {\n      if(ret){\n        const [type, payload] = ret;\n        dispatch({ type, payload });\n      }\n    }).catch(err=&gt;alert(err));\n  };\n};\n\nexport const asyncChangeFirstName = firstName =&gt; {\n  return asyncAction(async (dispatch) =&gt; {//可用于中间过程多次dispatch\n    await delay();\n    return [CHANGE_FIRST_NAME, firstName];\n  });\n};</code></pre>\n<h3>mobx版本(this.XXX)</h3>\n<p>同步action与异步action</p>\n<pre><code class=\"js\">import { observable, action, computed } from \"mobx\";\n\nconst delay = (ms = 1000) =&gt; new Promise(r =&gt; setTimeout(r, ms));\n\nclass LoginStore {\n  @observable firstName = \"\";\n\n  @observable lastName = \"\";\n\n  @action.bound\n  changeFirstName(firstName) {\n    this.firstName = firstName;\n  }\n\n  @action.bound\n  async asyncChangeFirstName(firstName) {\n    await delay();\n    this.firstName = firstName;\n  }\n\n  @action.bound\n  changeLastName(lastName) {\n    this.lastName = lastName;\n  }\n}\n\nexport default new LoginStore();</code></pre>\n<p>直接修改</p>\n<pre><code class=\"js\">const LoginFn = () =&gt; {\n  const { login } = store;\n  const changeFirstName = e =&gt; login.firstName = e.target.value;\n  // ...    \n}</code></pre>\n<p>通过action修改</p>\n<pre><code class=\"js\">const LoginFn = () =&gt; {\n  const { login } = store;\n  const const changeFirstName = e =&gt; login.changeFirstName(e.target.value);\n  // ...    \n}</code></pre>\n<h3>concent(dispatch,setState,invoke,sync)</h3>\n<p>concent里不再区分<code>action</code>和<code>reducer</code>，ui直接调用<code>reducer</code>方法即可，同时<code>reducer</code>方法可以是同步也可以是异步，支持相互任意组合和lazy调用，大大减轻开发者的心智负担。</p>\n<p>同步<code>reducer</code>与异步<code>reducer</code></p>\n<pre><code class=\"js\">// code in models/login/reducer.js\nconst delay = (ms = 1000) =&gt; new Promise(r =&gt; setTimeout(r, ms));\n\nexport function changeFirstName(firstName) {\n  return { firstName };\n}\n\nexport async function asyncChangeFirstName(firstName) {\n  await delay();\n  return { firstName };\n}\n\nexport function changeLastName(lastName) {\n  return { lastName };\n}</code></pre>\n<p>可任意组合的reducer，属于同一个模块内的方法可以直接基于方法引用调用，且reducer函数并非强制一定要返回一个新的片断状态，仅用于组合其他reducer也是可以的。</p>\n<pre><code class=\"jsx\">// reducerFn(payload:any, moduleState:{}, actionCtx:IActionCtx)\n// 当lazy调用此函数时，任何一个函数出错了，中间过程产生的所有状态都不会提交到store\nexport async changeFirstNameAndLastName([firstName, lastName], m, ac){\n    await ac.dispatch(changeFirstName, firstName);\n    await ac.dispatch(changeFirstName, lastName);\n    // return {someNew:'xxx'};//可选择此reducer也返回新的片断状态\n}\n\n// 视图处\nfunction UI(){\n    const ctx useConcent('login');\n    // 触发两次渲染\n    const normalCall = ()=&gt;ctx.mr.changeFirstNameAndLastName(['first', 'last']);\n    // 触发一次渲染\n    const lazyCall = ()=&gt;ctx.mr.changeFirstNameAndLastName(['first', 'last'], {lazy:true});\n    \n    return (\n        &lt;&gt;\n            &lt;button onClick={handleClick}&gt; normalCall &lt;/button&gt;\n            &lt;button onClick={handleClick}&gt; lazyCall &lt;/button&gt;\n        &lt;/&gt;\n    )\n}</code></pre>\n<p><strong><a href=\"https://stackblitz.com/edit/concent-lazy-dispatch\" rel=\"nofollow noreferrer\">lazyReducer示例</a></strong></p>\n<p>非lazy调用流程</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/4.png\" alt=\"\" title=\"\" /></p>\n<p>lazy调用流程</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/5.png\" alt=\"\" title=\"\" /></p>\n<p>当然了，除了<code>reducer</code>，其他3种方式都可以任意搭配，且和<code>reducer</code>一样拥有同步状态到其他属于同一个模块且对某状态有依赖的实例上</p>\n<ul>\n <li>setState</li>\n</ul>\n<pre><code class=\"js\">function FnUI(){\n    const {setState} = useConcent('login');\n    const changeName = e=&gt; setState({firstName:e.target.name});\n    // ... return ui\n}\n\n@register('login')\nclass ClsUI extends React.Component{\n    changeName = e=&gt; this.setState({firstName:e.target.name})\n    render(){...}\n}</code></pre>\n<ul>\n <li>invoke</li>\n</ul>\n<pre><code class=\"js\">function _changeName(firstName){\n    return {firstName};\n}\n\nfunction FnUI(){\n    const {invoke} = useConcent('login');\n    const changeName = e=&gt; invoke(_changeName, e.target.name);\n    // ... return ui\n}\n\n@register('login')\nclass ClsUI extends React.Component{\n    changeName = e=&gt; this.ctx.invoke(_changeName, e.target.name)\n    render(){...}\n}</code></pre>\n<ul>\n <li>sync</li>\n</ul>\n<p><strong><a href=\"https://codesandbox.io/s/green-tdd-g2mcr\" rel=\"nofollow noreferrer\">更多关于sync, 查看App2-1-sync.js文件</a></strong></p>\n<pre><code class=\"jsx\">function FnUI(){\n    const {sync, state} = useConcent('login');\n    return  &lt;input value={state.firstName} onChange={sync('firstName')} /&gt;\n}\n\n@register('login')\nclass ClsUI extends React.Component{\n    changeName = e=&gt; this.ctx.invoke(_changeName, e.target.name)\n    render(){\n        return  &lt;input value={this.state.firstName} onChange={this.ctx.sync('firstName')} /&gt;\n    }\n}</code></pre>\n<p>还记得我们在round 2开始比较前对concent提到了这样一句话：<strong>能够不只是追溯数据修改完整链路，还包括触发数据修改的源头</strong>，它是何含义呢，因为每一个concent组件的<code>ctx</code>都拥有一个唯一id<code>ccUniqueKey</code>标识当前组件实例，它是按<code>{className}_{randomTag}_{seq}</code>自动生成的，即类名(不提供是就是组件类型<code>$$CClass`, `$$CCFrag</code>, <code>$$CCHook</code>)加随机标签加自增序号，如果想刻意追踪修改源头ui，则人工维护<code>tag</code>，<code>ccClassKey</code>既可，再配合上<a href=\"https://github.com/concentjs/concent-plugin-redux-devtool/actions/new\" rel=\"nofollow noreferrer\">concent-plugin-redux-devtool</a>就能完成我们的目标了。</p>\n<pre><code class=\"js\">function FnUI(){\n    const {sync, state, ccUniqueKey} = useConcent({module:'login', tag:'xxx'}, 'FnUI');\n    // tag 可加可不加，\n    // 不加tag，ccUniqueKey形如: FnUI_xtst4x_1\n    // 加了tag，ccUniqueKey形如: FnUI_xxx_1\n}\n\n@register({module:'login', tag:'yyy'}, 'ClsUI')\nclass ClsUI extends React.Component{...}</code></pre>\n<p>接入<code>concent-plugin-redux-devtool</code>后，可以看到任何动作修改Action里都会包含一个字段<code>ccUniqueKey</code>。<br><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/6.png\" alt=\"\" title=\"\" /></br></p>\n<h3>回顾与总结</h3>\n<p>这一个回合我们针对数据修改方式做了全面对比，从而让开发者了解到从<code>concent</code>的角度来说，为了开发者的编码体验做出的各方面巨大努力。</p>\n<p>针对状态更新方式, 对比<code>redux</code>，当我们的所有动作流程压到最短，无action--&gt;reducer这样一条链路，无所谓的存函数还是副作用函数的区分(<code>rematch</code>、<code>dva</code>等提取的概念)，把这些概念交给<code>js</code>语法本身，会显得更加方便和清晰，你需要纯函数，就写<code>export function</code>，需要副作用函数就写<code>export async function</code>。</p>\n<p>对比<code>mobx</code>，一切都是可以任何拆开任意组合的基础函数，没有<code>this</code>，彻底得面向FP，给一个<code>input</code>预期<code>output</code>，这样的方式对测试容器也更加友好。</p>\n<table>\n <thead>\n  <tr>\n   <th>状态修改</th>\n   <th>concent</th>\n   <th>mbox</th>\n   <th>redux</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>基于不可变原则</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>Yes</td>\n  </tr>\n  <tr>\n   <td>最短链路</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>ui源头可追踪</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>无this</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>Yes</td>\n  </tr>\n  <tr>\n   <td>原子拆分&amp;合并提交</td>\n   <td>Yes(基于lazy)</td>\n   <td>Yes(基于transaction)</td>\n   <td>No</td>\n  </tr>\n </tbody>\n</table>\n<h2>round 3 - 依赖收集</h2>\n<p>这个回合是非常重量级的一个环节，依赖收集让ui渲染可以保持最小范围更新，即精确更新，所以<code>vue</code>某些测试方面会胜出<code>react</code>，当我们为<code>react</code>插上依赖收集的翅膀后，看看会有什么更有趣的事情发生吧。</p>\n<p>再开始聊<code>依赖收集</code>之前，我们复盘一下<code>react</code>原本的渲染机制吧，当某一个组件发生状态改变时，如果它的自定义组件没有人工维护<code>shouldComponentUpdate</code>判断时，总是会从上往下全部渲染一遍，而<code>redux</code>的<code>cconnect</code>接口接管了<code>shouldComponentUpdate</code>行为，当一个action触发了动作修改时，所有connect过的组件都会将上一刻<code>mapStateToProps</code>得到的状态和当前最新<code>mapStateToProps</code>得到的状态做浅比较，从而决定是否要刷新包裹的子组件。</p>\n<p>到了hook时代，提供了<code>React.memo</code>来用户阻断这种\"株连式\"的更新，但是需要用户尽量传递<code>primitive</code>类型数据或者不变化的引用给<code>props</code>，否则<code>React.memo</code>的浅比较会返回false。</p>\n<p>但是<code>redux</code>存在的一个问题是，如果视图里某一刻已经不再使用某个状态了，它不该被渲染却被渲染了，<code>mobx</code>携带得基于运行时获取到ui对数据的最小订阅子集理念优雅的解决了这个问题，但是<code>concent</code>更近一步将依赖收集行为隐藏的更优雅，用户不需要不知道<code>observable</code>等相关术语和概念，某一次渲染你取值有了点这个值的依赖，而下一次渲染没有了对某个<code>stateKey</code>的取值行为就应该移出依赖，这一点<code>vue</code>做得很好，为了让<code>react</code>拥有更优雅、更全面的依赖收集机制，<code>concent</code>同样做出了很多努力。</p>\n<h3>redux版本(不支持)</h3>\n<p>解决依赖收集不是<code>redux</code>诞生的初衷，这里我们只能默默的将它请到候选区，参与下一轮的较量了。</p>\n<h3>mobx版本(computed,useObserver)</h3>\n<p>利用装饰器或者<code>decorate</code>函数标记要观察的属性或者计算的属性</p>\n<pre><code class=\"js\">import { observable, action, computed } from \"mobx\";\n\nconst delay = (ms = 1000) =&gt; new Promise(r =&gt; setTimeout(r, ms));\n\nclass LoginStore {\n  @observable firstName = \"\";\n\n  @observable lastName = \"\";\n\n  @computed\n  get fullName(){\n    return `${this.firstName}_${this.lastName}`\n  }\n\n  @computed\n  get nickName(){\n    return `${this.firstName}&gt;&gt;nicknick`\n  }\n\n  @computed\n  get anotherNickName(){\n    return `${this.nickName}_another`\n  }\n}\n\nexport default new LoginStore();</code></pre>\n<p>ui里使用了观察状态或者结算结果时，就产生了依赖</p>\n<ul>\n <li>仅对计算结果有依赖，类组件写法</li>\n</ul>\n<pre><code class=\"jsx\">@inject(\"store\")\n@observer\nclass LoginCls extends Component {\n  state = {show:true};\n  toggle = ()=&gt; this.setState({show:!this.state.show})\n  render() {\n    const login = this.props.store.login;\n    return (\n      &lt;&gt;\n        &lt;h1&gt;Cls Small Comp&lt;/h1&gt;\n        &lt;button onClick={this.toggle}&gt;toggle&lt;/button&gt;\n        {this.state.show ? &lt;div&gt; fullName:{login.fullName}&lt;/div&gt;: \"\"}\n      &lt;/&gt;\n    )\n  }\n}</code></pre>\n<ul>\n <li>仅对计算结果有依赖，函数组件写法</li>\n</ul>\n<pre><code class=\"jsx\">import { useObserver } from \"mobx-react\";\n\n// show为true时，当前组件读取了fullName，\n// fullName由firstName和lastName计算而出\n// 所以他的依赖是firstName、lastName\n// 当show为false时，当前组件无任何依赖\nexport const LoginFnSmall = React.memo((props) =&gt; {\n  const [show, setShow] = React.useState(true);\n  const toggle = () =&gt; setShow(!show);\n  const { login } = store;\n\n  return useObserver(() =&gt; {\n    return (\n      &lt;&gt;\n        &lt;h1&gt;Fn Small Comp&lt;/h1&gt;\n        &lt;button onClick={toggle}&gt;toggle&lt;/button&gt;\n        {show ? &lt;div&gt; fullName:{login.fullName}&lt;/div&gt;: \"\"}\n      &lt;/&gt;\n    )\n  });\n});</code></pre>\n<p>对状态有依赖和对计算结果有依赖无任何区别，都是在运行时从<code>this.props.login</code>上获取相关结果就产生了ui对数据的依赖关系。</p>\n<p><strong><a href=\"https://codesandbox.io/s/mobx-login-dx4wl\" rel=\"nofollow noreferrer\">查看mobx示例</a></strong></p>\n<h3>concent(state,moduleComputed)</h3>\n<p>无需任何装饰器来标记观察属性和计算结果，仅仅是普通的<code>json</code>对象和函数，运行时阶段被自动转为<code>Proxy</code>对象。</p>\n<p>计算结果依赖</p>\n<pre><code class=\"js\">// code in models/login/computed.js\n// n: newState, o: oldState, f: fnCtx\n\n// fullName的依赖是firstName lastName\nexport function fullName(n, o, f){\n  return `${n.firstName}_${n.lastName}`;\n}\n\n// nickName的依赖是firstName\nexport function nickName(n, o, f){\n  return `${n.firstName}&gt;&gt;nicknick`\n}\n\n// anotherNickName基于nickName缓存结果做二次计算，而nickName的依赖是firstName\n// 所以anotherNickName的依赖是firstName，注意需将此函数放置到nickName下面\nexport function anotherNickName(n, o, f){\n  return `${f.cuVal.nickName}_another`;\n}</code></pre>\n<ul>\n <li>仅对计算结果有依赖，类组件写法</li>\n</ul>\n<pre><code class=\"jsx\">@register({ module: \"login\" })\nclass _LoginClsSmall extends React.Component {\n  state = {show:true};\n  render() {\n    const { state, moduleComputed: mcu, syncBool } = this.ctx;\n\n    // show为true时实例的依赖为firstName+lastName\n    // 为false时，则无任何依赖\n    return (\n      &lt;&gt;\n        &lt;h1&gt;Fn Small Comp&lt;/h1&gt;\n        &lt;button onClick={syncBool(\"show\")}&gt;toggle&lt;/button&gt;\n        {state.show ? &lt;div&gt; fullName:{mcu.fullName}&lt;/div&gt; : \"\"}\n      &lt;/&gt;\n    );\n  }\n}</code></pre>\n<ul>\n <li>仅对计算结果有依赖，函数组件写法</li>\n</ul>\n<pre><code class=\"jsx\">export const LoginFnSmall = React.memo(props =&gt; {\n  const { state, moduleComputed: mcu, syncBool } = useConcent({\n    module: \"login\",\n    state: { show: true }\n  });\n\n  return (\n    &lt;&gt;\n      &lt;h1&gt;Fn Small Comp&lt;/h1&gt;\n      &lt;button onClick={syncBool(\"show\")}&gt;toggle&lt;/button&gt;\n      {state.show ? &lt;div&gt; fullName:{mcu.fullName}&lt;/div&gt; : \"\"}\n    &lt;/&gt;\n  );\n});</code></pre>\n<p>和<code>mobx</code>一样，对状态有依赖和对计算结果有依赖无任何区别，在运行时从<code>ctx.state</code>上获取相关结果就产生了ui对数据的依赖关系，每一次渲染<code>concent</code>都在动态的收集当前实例最新的依赖，在实例<code>didUpdate</code>阶段移出已消失的依赖。</p>\n<ul>\n <li>生命周期依赖</li>\n</ul>\n<p><code>concent</code>的架构里是统一了类组件和函数组件的生命周期函数的，所以当某个状态被改变时，对此有依赖的生命周期函数会被触发，并支持类与函数共享此逻辑</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/7.png\" alt=\"\" title=\"\" /></p>\n<pre><code class=\"js\">export const setupSm = ctx=&gt;{\n  // 当firstName改变时，组件渲染渲染完毕后会触发\n  ctx.effect(()=&gt;{\n    console.log('fisrtName changed', ctx.state.fisrtName);\n  }, ['firstName'])\n}\n\n// 类组件里使用\nexport const LoginFnSmall = React.memo(props =&gt; {\n  console.log('Fn Comp ' + props.tag);\n  const { state, moduleComputed: mcu, sync } = useConcent({\n    module: \"login\",setup: setupSm, state: { show: true }\n  });\n  //...\n}\n\n// 函数组件里使用\n@register({ module: \"login\", setup:setupSm })\nclass _LoginClsSmall extends React.Component {...}</code></pre>\n<p><strong><a href=\"https://codesandbox.io/s/concent-login-ylbl4\" rel=\"nofollow noreferrer\">查看concent示例</a></strong></p>\n<p><strong><a href=\"https://juejin.im/post/5deb43256fb9a0166316c3e9\" rel=\"nofollow noreferrer\">查看更多关于ctx.effect</a></strong></p>\n<h3>回顾与总结</h3>\n<p>在依赖收集这一个回合，<code>concent</code>的依赖收集形式、和组件表达形式，和<code>mobx</code>区别都非常大，整个依赖收集过程没有任何其他多余的api介入, 而<code>mbox</code>需用<code>computed</code>修饰getter字段，在函数组件需要使用<code>useObserver</code>包状态返回UI，<code>concent</code>更注重一切皆函数，在组织计算代码的过程中消除的<code>this</code>这个关键字，利用<code>fnCtx</code>函数上下文传递已计算结果，同时显式的区分<code>state</code>和<code>computed</code>的盛放容器对象。</p>\n<table>\n <thead>\n  <tr>\n   <th>依赖收集</th>\n   <th>concent</th>\n   <th>mbox</th>\n   <th>redux</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>支持运行时收集依赖</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>精准渲染</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>无this</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>只需一个api介入</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>No</td>\n  </tr>\n </tbody>\n</table>\n<h2>round 4 - 衍生数据</h2>\n<p>还记得<code>mobx</code>的口号吗？任何可以从应用程序状态派生的内容都应该派生，揭示了一个的的确确存在且我们无法逃避的问题，大多数应用状态传递给ui使用前都会伴随着一个计算过程，其计算结果我们称之为衍生数据。</p>\n<p>我们都知道在<code>vue</code>里已内置了这个概念，暴露了一个可选项<code>computed</code>用于处理计算过程并缓存衍生数据，<code>react</code>并无此概念，<code>redux</code>也并不提供此能力，但是<code>redux</code>开放的中间件机制让社区得以找到切入点支持此能力，所以此处我们针对<code>redux</code>说到的计算指的已成为事实上的流行标准库<code>reslect</code>.</p>\n<p><code>mobx</code>和<code>concent</code>都自带计算支持，我们在上面的<strong>依赖收集</strong>回合里已经演示了<code>mobx</code>和<code>concent</code>的衍生数据代码，所以此轮仅针对<code>redux</code>书写衍生数据示例</p>\n<h3>redux(reselect)</h3>\n<p>redux最新发布<code>v7</code>版本，暴露了两个api，<code>useDispatch</code>和<code>useSelector</code>，用法以之前的<code>mapStateToState</code>和<code>mapDispatchToProps</code>完全对等，我们的示例里会用类组件和函数组件都演示出来。</p>\n<p>定义selector</p>\n<pre><code class=\"js\">import { createSelector } from \"reselect\";\n\n// getter，仅用于取值，不参与计算\nconst getFirstName = state =&gt; state.login.firstName;\nconst getLastName = state =&gt; state.login.lastName;\n\n// selector，等同于computed，手动传入计算依赖关系\nexport const selectFullName = createSelector(\n  [getFirstName, getLastName],\n  (firstName, lastName) =&gt; `${firstName}_${lastName}`\n);\n\nexport const selectNickName = createSelector(\n  [getFirstName],\n  (firstName) =&gt; `${firstName}&gt;&gt;nicknick`\n);\n\nexport const selectAnotherNickName = createSelector(\n  [selectNickName],\n  (nickname) =&gt; `${nickname}_another`\n);\n</code></pre>\n<p>类组件获取selector</p>\n<pre><code class=\"js\">import React from \"react\";\nimport { connect } from \"react-redux\";\nimport * as loginAction from \"models/login/action\";\nimport {\n  selectFullName,\n  selectNickName,\n  selectAnotherNickName\n} from \"models/login/selector\";\n\n@connect(\n  state =&gt; ({\n    firstName: state.login.firstName,\n    lastName: state.login.lastName,\n    fullName: selectFullName(state),\n    nickName: selectNickName(state),\n    anotherNickName: selectAnotherNickName(state),\n  }), // mapStateToProps\n  dispatch =&gt; ({\n    // mapDispatchToProps\n    changeFirstName: e =&gt;\n      dispatch(loginAction.changeFirstName(e.target.value)),\n    asyncChangeFirstName: e =&gt;\n      dispatch(loginAction.asyncChangeFirstName(e.target.value)),\n    changeLastName: e =&gt; dispatch(loginAction.changeLastName(e.target.value))\n  })\n)\nclass Counter extends React.Component {\n  render() {\n    const {\n      firstName,\n      lastName,\n      fullName,\n      nickName,\n      anotherNickName,\n      changeFirstName,\n      asyncChangeFirstName,\n      changeLastName\n    } = this.props;\n    return 'ui ...'\n  }\n}\n\nexport default Counter;</code></pre>\n<p>函数组件获取selector</p>\n<pre><code class=\"js\">import * as React from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport * as loginAction from \"models/login/action\";\nimport {\n  selectFullName,\n  selectNickName,\n  selectAnotherNickName\n} from \"models/login/selector\";\n\nconst Counter = () =&gt; {\n  const { firstName, lastName } = useSelector(state =&gt; state.login);\n  const fullName = useSelector(selectFullName);\n  const nickName = useSelector(selectNickName);\n  const anotherNickName = useSelector(selectAnotherNickName);\n  const dispatch = useDispatch();\n  const changeFirstName = (e) =&gt; dispatch(loginAction.changeFirstName(e.target.value));\n  const asyncChangeFirstName = (e) =&gt; dispatch(loginAction.asyncChangeFirstName(e.target.value));\n  const changeLastName = (e) =&gt; dispatch(loginAction.changeLastName(e.target.value));\n\n  return 'ui...'\n  );\n};\n\nexport default Counter;</code></pre>\n<p><strong><a href=\"https://codesandbox.io/s/redux-login-6uqg8\" rel=\"nofollow noreferrer\">redux衍生数据在线示例</a></strong></p>\n<h3>mobx(computed装饰器)</h3>\n<p>见上面依赖收集的实例代码，此处不再重叙。</p>\n<h3>concent(moduleComputed直接获取)</h3>\n<p>见上面依赖收集的实例代码，此处不再重叙。</p>\n<h3>回顾与总结</h3>\n<p>相比<code>mobx</code>可以直接从<code>this.pops.someStore</code>获取，<code>concent</code>可以直接从<code>ctx.moduleComputed</code>上获取，多了一个手动维护计算依赖的过程或映射挑选结果的过程，相信哪种方式是开发者更愿意使用的这个结果已经一目了然了。</p>\n<table>\n <thead>\n  <tr>\n   <th>衍生数据</th>\n   <th>concent</th>\n   <th>mbox</th>\n   <th>redux(reselect)</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>自动维护计算结果之间的依赖</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>触发读取计算结果时收集依赖</td>\n   <td>Yes</td>\n   <td>Yes</td>\n   <td>No</td>\n  </tr>\n  <tr>\n   <td>计算函数无this</td>\n   <td>Yes</td>\n   <td>No</td>\n   <td>Yes</td>\n  </tr>\n </tbody>\n</table>\n<h2>round 5 - 实战TodoMvc</h2>\n<p>上面4个回合结合了一个个鲜活的代码示例，综述了3个框架的特点与编码风格，相信读者期望能有更加接近生产环境的代码示例来看出其差异性吧，那么最后让我们以<code>TodoMvc</code>来收尾这次特性大比拼，期待你能够更多的了解并体验<code>concent</code>，开启 <strong>不可变</strong> &amp; <strong>依赖收集</strong> 的react编程之旅吧。</p>\n<h3>redux-todo-mvc</h3>\n<p><strong><a href=\"https://codesandbox.io/s/todo-mvc-redux-49kg0\" rel=\"nofollow noreferrer\">查看redux-todo-mvc演示</a></strong></p>\n<p>action 相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/8.png\" alt=\"\" title=\"\" /></p>\n<p>reducer 相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/9.png\" alt=\"\" title=\"\" /></p>\n<p>computed 相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/10.png\" alt=\"\" title=\"\" /></p>\n<h3>mobx-todo-mvc</h3>\n<p><strong><a href=\"https://codesandbox.io/s/todo-mvc-mbox-k42q1\" rel=\"nofollow noreferrer\">查看mobx-todo-mvc演示</a></strong></p>\n<p>action 相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/11.png\" alt=\"\" title=\"\" /></p>\n<p>computed 相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/12.png\" alt=\"\" title=\"\" /></p>\n<h3>concent-todo-mvc</h3>\n<p><strong><a href=\"https://codesandbox.io/s/todoapp-react-concent-fvgvc\" rel=\"nofollow noreferrer\">查看concent-todo-mvc演示</a></strong></p>\n<p>reducer相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/13.png\" alt=\"\" title=\"\" /></p>\n<p>computed相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/14.png\" alt=\"\" title=\"\" /></p>\n<h2>end</h2>\n<p>最后让我们用一个<a href=\"https://codesandbox.io/s/concent-watch-7j0mw\" rel=\"nofollow noreferrer\">最简版本的concent应用</a>结束此文，未来的你会选择concent作为你的react开发武器吗？</p>\n<pre><code class=\"jsx\">import React from \"react\";\nimport \"./styles.css\";\nimport { run, useConcent, defWatch } from 'concent';\n\nrun({\n  login:{\n    state:{\n      name:'c2',\n      addr:'bj',\n      info:{\n        sex: '1',\n        grade: '19',\n      }\n    },\n    reducer:{\n      selectSex(sex, moduleState){\n        const info = moduleState.info;\n        info.sex = sex;\n        return {info};\n      }\n    },\n    computed: {\n      funnyName(newState){\n        // 收集到funnyName对应的依赖是 name\n        return `${newState.name}_${Date.now()}`\n      },\n      otherFunnyName(newState, oldState, fnCtx){\n        // 获取了funnyName的计算结果和newState.addr作为输入再次计算\n        // 所以这里收集到otherFunnyName对应的依赖是 name addr\n        return `${fnCtx.cuVal.funnyName}_${newState.addr}`\n      }\n    },\n    watch:{\n      // watchKey name和stateKey同名，默认监听name变化\n      name(newState, oldState){\n        console.log(`name changed from ${newState.name} to ${oldState.name}`);\n      },\n      // 从newState 读取了addr， info两个属性的值，当前watch函数的依赖是 addr, info\n      // 它们任意一个发生变化时，都会触发此watch函数\n      addrOrInfoChanged: defWatch((newState, oldState, fnCtx)=&gt;{\n        const {addr, info} = newState;\n        if(fnCtx.isFirstCall)return;// 仅为了收集到依赖，不执行逻辑\n        console.log(`addr is${addr}, info is${JSON.stringify(info)}`);\n      }, {immediate:true})\n    }\n  }\n})\n\nfunction UI(){\n  console.log('UI with state value');\n  const {state, sync, dispatch} = useConcent('login');\n  return (\n    &lt;div&gt;\n      name:&lt;input value={state.name} onChange={sync('name')} /&gt;\n      addr:&lt;input value={state.addr} onChange={sync('addr')} /&gt;\n      &lt;br /&gt;\n      info.sex:&lt;input value={state.info.sex} onChange={sync('info.sex')} /&gt;\n      info.grade:&lt;input value={state.info.grade} onChange={sync('info.grade')} /&gt;\n      &lt;br /&gt;\n      &lt;select value={state.info.sex} onChange={(e)=&gt;dispatch('selectSex', e.target.value)}&gt;\n        &lt;option value=\"male\"&gt;male&lt;/option&gt;\n        &lt;option value=\"female\"&gt;female&lt;/option&gt;\n      &lt;/select&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction UI2(){\n  console.log('UI2 with comptued value');\n  const {state, moduleComputed, syncBool} = useConcent({module:'login', state:{show:true}});\n  return (\n    &lt;div&gt;\n      {/* 当show为true的时候，当前组件的依赖是funnyName对应的依赖 name */}\n      {state.show? &lt;span&gt;dep is name: {moduleComputed.funnyName}&lt;/span&gt; : 'UI2 no deps now'}\n      &lt;br/&gt;&lt;button onClick={syncBool('show')}&gt;toggle show&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction UI3(){\n  console.log('UI3 with comptued value');\n  const {state, moduleComputed, syncBool} = useConcent({module:'login', state:{show:true}});\n  return (\n    &lt;div&gt;\n      {/* 当show为true的时候，当前组件的依赖是funnyName对应的依赖 name addr */}\n      {state.show? &lt;span&gt;dep is name,addr: {moduleComputed.otherFunnyName}&lt;/span&gt; : 'UI3 no deps now'}\n      &lt;br/&gt;&lt;button onClick={syncBool('show')}&gt;toggle show&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default function App() {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;h3&gt;try click toggle btn and open console to see render log&lt;/h3&gt;\n      &lt;UI /&gt;\n      &lt;UI /&gt;\n      &lt;UI2 /&gt;\n      &lt;UI3 /&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n<p><a href=\"https://github.com/concentjs/concent\" rel=\"nofollow noreferrer\">❤ star me if you like concent ^_^</a></p>\n<p><a href=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/15.png\" rel=\"nofollow noreferrer\">Edit on CodeSandbox</a><br><img src=\"https://segmentfault.com/img/remote/1460000022332831\" alt=\"https://codesandbox.io/s/concent-guide-xvcej\" title=\"https://codesandbox.io/s/concent-guide-xvcej\" /></br></p>\n<p><a href=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/16.png\" rel=\"nofollow noreferrer\">Edit on StackBlitz</a><br><img src=\"https://segmentfault.com/img/remote/1460000022332833\" alt=\"https://stackblitz.com/edit/cc-multi-ways-to-wirte-code\" title=\"https://stackblitz.com/edit/cc-multi-ways-to-wirte-code\" /></br></p>","descriptionType":"html","publishedDate":"Fri, 10 Apr 2020 11:20:28 +0000","feedId":6615,"bgimg":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/banner-rmc-compare.png","linkMd5":"cb41ea759b4fff7fa2c9b843d9a3559f","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn26@2020_4/2020/08/24/23-08-20-365_ca3ba6545607b5e9.webp","destWidth":900,"destHeight":383,"sourceBytes":526228,"destBytes":26564,"author":"钟正楷","articleImgCdnMap":{"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/banner-rmc-compare.png":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn26@2020_4/2020/08/24/23-08-20-365_ca3ba6545607b5e9.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/1.png":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn100@2020_2/2020/08/24/23-08-39-801_b3b0bbd56733612b.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/2.png":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn47@2020_4/2020/08/24/23-08-39-007_71ea8796fe8a5213.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/3.png":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn28@2020_2/2020/08/24/23-08-38-581_dc3226984ea6a4b1.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/4.png":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn68@2020_3/2020/08/24/23-08-38-545_133d4c84d77e836a.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/5.png":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn8@2020_3/2020/08/24/23-08-43-737_c66e8101d9194ace.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/6.png":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn51@2020_2/2020/08/24/23-08-42-743_5e3a1f6dde644120.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/7.png":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn98@2020_5/2020/08/24/23-08-41-746_deecbd4b726849a4.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/8.png":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn12@2020_5/2020/08/24/23-08-40-119_7b2769b97c50b3fb.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/9.png":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn82@2020_6/2020/08/24/23-08-29-965_b89ab3d0fde9ac24.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/10.png":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn17@2020_3/2020/08/24/23-08-42-141_e9b5f179c2619f81.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/11.png":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn3@2020_4/2020/08/24/23-08-38-385_6664d5c4cdec1a50.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/12.png":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn80@2020_6/2020/08/24/23-08-38-200_ba0f32660e8bc151.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/13.png":"https://cdn.jsdelivr.net/gh/myreaderx/cdn88@2020_2/2020/08/24/23-08-39-593_22e0b3f2ff5b9946.webp","https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/14.png":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn51@2020_4/2020/08/24/23-08-38-994_c44d50e66064c4ab.webp","https://segmentfault.com/img/remote/1460000022332831":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn54@2020_6/2020/08/24/23-08-33-768_ab7bb1a669ed6d43.webp","https://segmentfault.com/img/remote/1460000022332833":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn62@2020_5/2020/08/24/23-08-34-275_d188d26ff603bb94.webp"},"publishedOrCreatedDate":1598310388576},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"JavaScript中的函数式编程","link":"https://segmentfault.com/a/1190000023685018","description":"<h3>函数式编程</h3>\n<p>函数式编程是一种编程范式，是一种构建计算机程序结构和元素的风格，它把计算看作是对数学函数的评估，避免了状态的变化和数据的可变，与函数式编程相对的是命令式编程。我们有这样一个需求，给数组的每个数字加一：</p>\n<pre><code class=\"javascript\">// 数组每个数字加一, 命令式编程\nlet arr = [1, 2, 3, 4];\nlet newArr = [];\nfor(let i = 0; i &lt; arr.length; i++){\n  newArr.push(arr[i] + 1);\n}\n\nconsole.log(newArr); // [2, 3, 4, 5]</code></pre>\n<p>这段代码结果没有问题，但是没法重用。我们换一个思维，这里面包含的操作其实就两个，一个是遍历数组，一个是成员加一。我们把这两个方法拆出来：</p>\n<pre><code class=\"javascript\">// 先拆加一出来\nlet add1 = x =&gt; x +1;\n\n// 然后拆遍历方法出来，通过遍历返回一个操作后的新数组\n// fn是我们需要对每个数组想进行的操作\nlet createArr = (arr, fn) =&gt; {\n  const newArr = [];\n  for(let i = 0; i &lt; arr.length; i++){\n    newArr.push(fn(arr[i]));\n  }\n\n  return newArr;\n} \n\n// 用这两个方法来得到我们期望的结果\nconst arr = [1, 2, 3, 4];\nconst newArr = createArr(arr, add1);\nconsole.log(newArr);  // [2, 3, 4, 5], 结果仍然是对的</code></pre>\n<p>这样拆分后，如果我们下次的需求是对数组每个元素乘以2，我们只需要写一个乘法的方法，然后复用之前的代码就行：</p>\n<pre><code class=\"javascript\">let multiply2 = x =&gt; x * 2;\n\n// 调用之前的createArr\nconst arr2 = [1, 2, 3, 4];\nconst newArr2 = createArr(arr2, multiply2);\nconsole.log(newArr2);  // [2, 4, 6, 8], 结果是对的</code></pre>\n<p>事实上我们的加一函数只能加一，也不好复用，它还可以继续拆：</p>\n<pre><code class=\"javascript\">// 先写一个通用加法，他接收第一个加数，返回一个方法\n// 返回的这个方法接收第二个加数，第一个加数是上层方法的a\n// 这样当我们需要计算1+2是，就是add(1)(2)\nlet add = (a) =&gt; {\n  return (b) =&gt; {\n    return a + b;\n  }\n}\n\n// 我们也可以将返回的函数赋给一个变量，这个变量也就变成一个能特定加a的一个方法\nlet add1 = add(1);\n\nlet res = add1(4); \nconsole.log(res);  // 5</code></pre>\n<p>所以函数式编程就是将程序分解为一些更可重用、更可靠且更易于理解的部分，然后将他们组合起来，形成一个更易推理的程序整体。</p>\n<h3>纯函数</h3>\n<p>纯函数是指一个函数，如果它的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，只依赖于其输入参数。同时函数的运行也不改变任何外部数据，它只通过它的返回值与外部通讯。</p>\n<p>下面这个函数就不是纯函数，因为函数内部需要的<code>discount</code>需要从外部获取：</p>\n<pre><code class=\"javascript\">let discount = 0.8;\nconst calPrice = price =&gt; price * discount;\nlet price = calPrice(200);  // 160\n\n// 当discount变了，calPrice传同样额参数，结果不一样，所以不纯\ndiscount = 0.9;\nprice = calPrice(200);  // 180</code></pre>\n<p>要改为纯函数也很简单，将<code>discount</code>作为参数传递进去就行了</p>\n<pre><code class=\"javascript\">const calPrice = (price, discount) =&gt; price * discount;</code></pre>\n<p>纯函数可以保证代码的稳定性，因为相同的输入永远会得到相同结果。不纯的函数可能会带来副作用。</p>\n<h3>函数副作用</h3>\n<p>函数副作用是指调用函数时除了返回函数值之外，还对主调用函数产生附加的影响，比如修改全局变量或者外部变量，或者修改参数。这可能会带来难以查找的问题并降低代码的可读性。下面的<code>foo</code>就有副作用，当后面有其他地方需要使用a，可能就会拿到一个被污染的值</p>\n<pre><code class=\"javascript\">let a = 5;\nlet foo = () =&gt; a = a * 10;\nfoo();\nconsole.log(a); // 50</code></pre>\n<p>除了我们自己写的函数有副作用外，一些原生API也可能有副作用，我们写代码时应该注意：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023685022\" alt=\"image-20200109232215022\" title=\"image-20200109232215022\" /></p>\n<p>我们的目标是尽可能的减少副作用，将函数写为纯函数，下面这个不纯的函数使用了<code>new Date</code>，每次运行结果不一样，是不纯的：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023685021\" alt=\"image-20200109232541307\" title=\"image-20200109232541307\" /></p>\n<p>要给为纯函数可以将依赖注入进去，所谓依赖注入就是将不纯的部分提取出来作为参数，这样我们可以让副作用代码集中在外部，远离核心代码，保证核心代码的稳定性</p>\n<pre><code>// 依赖注入\nconst foo = (d, log, something) =&gt; {\n  const dt = d.toISOString();\n  return log(`${dt}: ${something}`);\n}\n\nconst something = 'log content';\nconst d = new Date();\nconst log = console.log.bind(console);\nfoo(d, log, something);</code></pre>\n<p>所以减少副作用一般的方法就是：</p>\n<pre><code>1. 函数使用参数进行运算，不要修改参数\n2. 函数内部不修改外部变量\n3. 运算结果通过返回值返回给外部</code></pre>\n<h3>可变性和不可变性</h3>\n<ul>\n <li><strong>可变性</strong>：指一个变量创建以后可以任意修改</li>\n <li><strong>不可变性</strong>： 指一个变量被创建后永远不会发生改变，不可变性是函数式编程的核心概念</li>\n</ul>\n<p>下面是一个可变的例子：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023685024\" alt=\"image-20200109233313733\" title=\"image-20200109233313733\" /></p>\n<p>如果我们一定要修改这个参数，我们应该将这个参数进行深拷贝后再操作，这样就不会修改参数了：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023685023\" alt=\"image-20200109233515929\" title=\"image-20200109233515929\" /></p>\n<p><strong>文章的最后，感谢你花费宝贵的时间阅读本文，如果本文给了你一点点帮助或者启发，请不要吝啬你的赞和GitHub小星星，你的支持是作者持续创作的动力。</strong></p>\n<p><strong>作者博文GitHub项目地址： <a href=\"https://github.com/dennis-jiang/Front-End-Knowledges\" rel=\"nofollow noreferrer\">https://github.com/dennis-jiang/Front-End-Knowledges</a></strong></p>","descriptionType":"html","publishedDate":"Wed, 19 Aug 2020 06:10:38 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023685022","linkMd5":"c6ea63b543bcf14780252f9af45af4e0","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn33@2020_6/2020/08/24/23-08-24-844_33ebdc5c0e4cb893.webp","destWidth":653,"destHeight":128,"sourceBytes":64675,"destBytes":10000,"author":"蒋鹏飞","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023685022":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn33@2020_6/2020/08/24/23-08-24-844_33ebdc5c0e4cb893.webp","https://segmentfault.com/img/remote/1460000023685021":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn86@2020_1/2020/08/24/23-08-28-842_9dd4a1623c27860b.webp","https://segmentfault.com/img/remote/1460000023685024":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn93@2020_6/2020/08/24/23-08-30-679_209c5d3f7df6d78a.webp","https://segmentfault.com/img/remote/1460000023685023":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn89@2020_6/2020/08/24/23-08-30-573_1334f2d2165df788.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"Deno从零到架构级系列（二）——注解路由","link":"https://segmentfault.com/a/1190000023572844","description":"<p><img src=\"https://segmentfault.com/img/bVbK4w3\" alt=\"image\" title=\"image\" /></p>\n<p>上回介绍了Deno的基本安装、使用。基于oak框架搭建了控制层、路由层、对入口文件进行了改造。那这回我们接着继续改造路由，模拟springmvc实现注解路由。</p>\n<h2>装饰器模式</h2>\n<p>装饰者模式(decorator)，就是给对象动态添加职责的方式称为装饰者模式。直接先上例子：</p>\n<pre><code class=\"javascript\">// 新建文件fox.ts\n// 创建一个fox类\nclass Fox {\n // skill方法，返回狐狸会跑的字样，假设就是构建了狐狸类都会跑的技能\n skill() {\n   return '狐狸会跑。'\n }\n}\n// 创建一个flyingfox类\nclass Flyingfox  {\n   private fox: any  \n   // 构造方法，传入要装饰的对象\n   constructor(fox: any) {\n     this.fox = fox;\n     // 这里直接打印该类的skill方法返回值\n     console.log(this.skill())\n   }\n   // 该类的skill方法\n   skill() {\n     // 在这里获取到了被装饰者\n     let val = this.fox.skill();\n     // 这里简单的加字符串，假设给被装饰者加上了新的技能\n     return val + '再加一对翅膀，就会飞啦！'\n   }\n}\n// new一个fox对象\nlet fox = new Fox();\n\n// 打印结果为：狐狸会跑。再加一对翅膀，就会飞啦！\nnew Flyingfox(fox);</code></pre>\n<p>直接运行deno run fox.ts就会打印结果啦。这是一个非常简单的装饰者模式例子，我们继续往下，用TS的注解来实现这个例子。</p>\n<p><img src=\"https://segmentfault.com/img/bVbK4xe\" alt=\"image\" title=\"image\" /></p>\n<h3>TypeScript装饰器配置</h3>\n<p>因为deno本来就支持TS，但用TS实现<strong>装饰器</strong>，需要先配置。在根目录新建配置文件tsconfig.json，配置文件如下：</p>\n<pre><code class=\"javascript\">{\n \"compilerOptions\": {\n   \"allowJs\": true,\n   \"module\": \"esnext\",\n   \"emitDecoratorMetadata\": true,\n   \"experimentalDecorators\": true\n }\n}</code></pre>\n<h3>TS装饰器</h3>\n<p>这里提一下，注解和装饰器是两个东西，对于不同的语言来讲，功能不同。</p>\n<ul>\n <li>注解（Annotation）：仅提供附加元数据支持，并不能实现任何操作。需要另外的 Scanner 根据元数据执行相应操作。</li>\n <li>装饰器（Decorator）：仅提供定义劫持，能够对类及其方法的定义并没有提供任何附加元数据的功能。</li>\n</ul>\n<p>我一直称注解称习惯了。大家理解就好。</p>\n<p>TypeScript装饰器是一种函数，写法：<strong>@ + 函数名</strong>。作用于类和类方法前定义。 还是拿上面的例子来改写，如下</p>\n<pre><code class=\"javascript\">@Flyingfox\nclass Fox {}\n\n// 等同于\nclass Fox {}\nFox = Flyingfox(Fox) || Fox;</code></pre>\n<p>很多小伙伴经常看到这样的写法，如下：</p>\n<pre><code class=\"javascript\">function Flyingfox(...list) {\n  return function (target: any) {\n    Object.assign(target.prototype, ...list)\n  }\n}</code></pre>\n<p>这样在装饰器外面再封装一层函数，好处是便于传参数。基本语法掌握了，我们就来实战一下，实战中才知道更深层次的东东。</p>\n<h2>装饰器修饰类class</h2>\n<p>装饰器可以修饰类，也可以修饰方法。我们先来看修饰类的例子，如下：</p>\n<pre><code class=\"javascript\">// test.ts\n// 定义一个Time方法\nfunction Time(ms: string){\n  console.log('1-第一步')\n  // 这里的target就是你要修饰的那个类\n  return function(target: Function){\n    console.log(`4-第四步，${value}`)\n  }\n}\n// 定义一个Controller方法，也是个工厂函数\nfunction Controller(path: string) {\n  console.log('2-第二步')\n  return function(target: Function){\n    console.log(`3-第三步，${value}`)\n  }\n}\n\n@Time('计算时间')\n@Controller('这是controller')\nclass Controller {\n}\n// 运行：deno run -c tsconfig.json ./test.ts\n// 1-第一步\n// 2-第二步\n// 3-第三步, 这是controller\n// 4-第四步, 计算时间</code></pre>\n<p>有疑问的小伙伴可以console出来看看这个target。 这里要注意三个点：</p>\n<ul>\n <li>运行命令：deno run -c tsconfig.json ./test.ts，这里的-c是执行ts配置文件，注意是json文件</li>\n <li>外层工厂函数的执行顺序：从上到下依次执行。</li>\n <li>装饰器函数的执行顺序：从下到上依次执行。</li>\n</ul>\n<h2>TS注解路由</h2>\n<p>好啦，下面我们接着上一回的内容，正式改造注解路由了。oak和以前koa、express改造思路都一样。改造之前，按照路由分发请求流程，如下图：</p>\n<p><img src=\"https://segmentfault.com/img/bVbK4xf\" alt=\"image\" title=\"image\" /></p>\n<p>改造之后，我们的流程如下图。</p>\n<p><img src=\"https://segmentfault.com/img/bVbK4xg\" alt=\"image\" title=\"image\" /></p>\n<p>新建decorators文件夹，包含三个文件，如下：</p>\n<pre><code class=\"javascript\">// decorators/router.ts\n// 这里统一引入oak框架\nimport { Application, Router } from 'https://deno.land/x/oak@v6.0.1/mod.ts'\n// 统一导出oak的app和router，这里的其实可以单独放一个文件，因为还有入口文件server.ts会用到\nexport const app: Application = new Application();\nexport const router: Router  = new Router();\n// 路由前缀，这里其实应该放到配置文件\nconst prefix: string = '/api'\n// 构建一个map，用来存放路由\nconst routeMap: Map&lt;{target: any, method: string, path: string}, Function | Function[]&gt; = new Map()\n\n// 这里就是我们作用于类的修饰器\nexport function Controller (root: string): Function {\n  return (target: any) =&gt; {\n    // 遍历所有路由\n    for (let [conf, controller] of routeMap) {\n      // 这里是判断如果类的路径是@Controller('/')，否则就跟类方法上的路径合并\n      conf.path = prefix + (root === '/' ? conf.path : `${root}${conf.path}`)\n      // 强制controller为数组\n      let controllers = Array.isArray(controller) ? controller : [controller]\n      // 这里是最关键的点，也就是分发路由\n      controllers.forEach((controller) =&gt; (router as any)[conf.method.toLowerCase()](conf.path, controller))\n    }\n  }\n}</code></pre>\n<p>这里就是类上的路由了，每一行我都加了注释。给小伙伴们一个建议，哪里不明白，就在哪里console一下。 这里用的Map来存放路由，其实用反射更好，只是原生的reflect支持比较少，需要额外引入reflect的文件。有兴趣可以去看alosaur框架的实现方式。</p>\n<pre><code class=\"javascript\">// decorators/index.ts\nexport * from \"./router.ts\";\nexport * from \"./controller.ts\";</code></pre>\n<p>这个其实没什么好讲的了，就是入口文件，把该文件夹下的文件导出。这里的controller.ts先留个悬念，放到彩蛋讲。 接着改造控制层，代码如下：</p>\n<pre><code class=\"javascript\">// controller/bookController.ts\nimport { Controller } from \"../decorators/index.ts\";\n// 这里我们假装是业务层过来的数据\nconst bookService = new Map&lt;string, any&gt;();\nbookService.set(\"1\", {\n  id: \"1\",\n  title: \"听飞狐聊deno\",\n  author: \"飞狐\",\n});\n\n// 这里是类的装饰器\n@Controller('/book')\nexport default class BookController {\n  getbook (context: any) {\n    context.response.body = Array.from(bookService.values());\n  }\n  getbookById (context: any) {\n    if (context.params &amp;&amp; context.params.id &amp;&amp; bookService.has(context.params.id)) {\n      context.response.body = bookService.get(context.params.id);\n    }\n  }\n}</code></pre>\n<p>接着改造项目入口文件server.ts</p>\n<pre><code class=\"javascript\">// server.ts\n// 这里的loadControllers先不管，彩蛋会讲\nimport { app, router, loadControllers } from './decorators/index.ts'\n\nclass Server {\n  constructor () {\n    this.init()\n  }\n\n  async init () {\n    // 这里就是导入所有的controller，这里的controller是控制层文件夹的名称\n    await loadControllers('controller');\n    app.use(router.routes());\n    app.use(router.allowedMethods());\n    this.listen()\n  }\n\n  async listen () {\n    // await app.listen({ port: 8000 });\n    setTimeout(async () =&gt; {\n      await app.listen({ port: 8000 })\n    }, 1);\n  }\n}\nnew Server()</code></pre>\n<p>好啦，整个类的装饰器改造就结束了。整个项目目录结构如下：</p>\n<p><img src=\"https://segmentfault.com/img/bVbK4xh\" alt=\"image\" title=\"image\" /></p>\n<p>先不着急运行，虽然运行也会成功，但啥都做不了，为啥呢？ 因为类方法的路由还没有做，不卖关子了，接下来做类方法的装饰器。</p>\n<h3>TS类方法的装饰器</h3>\n<p>还是先从代码上来，先改造控制层，如下：</p>\n<pre><code class=\"javascript\">// controller/bookController.ts\nconst bookService = new Map&lt;string, any&gt;();\nbookService.set(\"1\", {\n  id: \"1\",\n  title: \"听飞狐聊deno\",\n  author: \"飞狐\",\n});\n\n@Controller('/book')\nexport default class BookController {\n  // 这里就是类方法修饰器\n  @Get('/getbook')\n  getbook (context: any) {\n    context.response.body = Array.from(bookService.values());\n  }\n  // 这里就是类方法修饰器\n  @Get('/getbookById')\n  getbookById (context: any) {\n    if (context.params &amp;&amp; context.params.id &amp;&amp; bookService.has(context.params.id)) {\n      context.response.body = bookService.get(context.params.id);\n    }\n  }\n}</code></pre>\n<p>类方法修饰器实现，这里就只讲解有改动的地方，如下：</p>\n<pre><code class=\"javascript\">// decorators/router.ts\nimport { Application, Router } from 'https://deno.land/x/oak@v6.0.1/mod.ts'\n// 这里是TS的枚举\nenum MethodType {\n  GET='GET',\n  POST='POST',\n  PUT='PUT',\n  DELETE='DELETE'\n}\n\nexport const app: Application = new Application();\nexport const router: Router  = new Router();\nconst prefix: string = '/api'\n\nconst routeMap: Map&lt;{target: any, method: string, path: string}, Function | Function[]&gt; = new Map()\n\nexport function Controller (root: string): Function {\n  return (target: any) =&gt; {\n    for (let [conf, controller] of routeMap) {\n      conf.path = prefix + (root === '/' ? conf.path : `${root}${conf.path}`)\n      let controllers = Array.isArray(controller) ? controller : [controller]\n      controllers.forEach((controller) =&gt; (router as any)[conf.method.toLowerCase()](conf.path, controller))\n    }\n  }\n}\n// 这里就是http请求工厂函数，传入的type就是http的get、post等\nfunction httpMethodFactory (type: MethodType) {\n  // path是类方法的路径，如：@Get('getbook')，这个path就是指getbook。\n  // 类方法修饰器传入三个参数，target是方法本身，key是属性名\n  return (path: string) =&gt; (target: any, key: string, descriptor: any) =&gt; {\n    // 第三个参数descriptor我们这里不用，但是还是讲解一下，对象的值如下：\n    // {\n    //   value: specifiedFunction,\n    //   enumerable: false,\n    //   configurable: true,\n    //   writable: true\n    // };\n    (routeMap as any).set({\n      target: target.constructor,\n      method: type,\n      path: path,\n    }, \n    target[key])\n  }\n}\n\nexport const Get = httpMethodFactory(MethodType.GET)\nexport const Post = httpMethodFactory(MethodType.POST)\nexport const Delete = httpMethodFactory(MethodType.DELETE)\nexport const Put = httpMethodFactory(MethodType.PUT)</code></pre>\n<p>到这里，注解路由就改造完了。但是，这个时候请大家跳到彩蛋把导入文件的方法补上。然后一气呵成的运行入口文件，就大功告成了。</p>\n<p><img src=\"https://segmentfault.com/img/bVbK4xi\" alt=\"image\" title=\"image\" /></p>\n<h2>彩蛋</h2>\n<p>这里的彩蛋部分，其实是一个deno的导入文件方法，代码如下：</p>\n<pre><code class=\"javascript\">// decorators/controller.ts\nexport async function loadControllers (controllerPath: string) {\n  try {\n    for await (const dirEntry of Deno.readDirSync(controllerPath)) {\n      import(`../${controllerPath}/${dirEntry.name}`);\n    }\n  } catch (error) {\n    console.error(error)\n    console.log(\"no such file or dir :---- \" + controllerPath)\n  }\n}</code></pre>\n<p>这里的readDirSync就是读取传入的文件夹路径，然后用import导入迭代的文件。</p>\n<h2>解决Deno的bug</h2>\n<p>另外大家如果在1.2以前的版本遇到报错如下：</p>\n<pre><code>Error: Another accept task is ongoing</code></pre>\n<p>不要着急，这个是deno的错误。解决方法如下：</p>\n<pre><code class=\"javascript\">async listen () {\n  // await app.listen({ port: 8000 });\n  setTimeout(async () =&gt; {\n    await app.listen({ port: 8000 })\n  }, 1);\n}</code></pre>\n<p>找到入口文件，在监听端口方法加个setTimeout就可以搞定了。之前deno官方的issue，很多人在提这个bug。飞狐在此用点特殊的手法解决了。嘿嘿~</p>\n<p><img src=\"https://segmentfault.com/img/bVbK4xj\" alt=\"image\" title=\"image\" /></p>\n<h3>下回预告</h3>\n<p>学会了TS装饰器可以做的很多，比如：请求参数注解、日志、权限判断等等。回顾一下，这篇的内容比较多，也比较深入。大家可以好好消化一下，概括一下：</p>\n<ul>\n <li>装饰者模式</li>\n <li>TS类的装饰器，TS类方法的装饰器</li>\n <li>文件夹的导入，文件的引入</li>\n</ul>\n<p>下回我们讲全局错误处理，借鉴alosaur做异常处理。有任何问题大家可以在评论区留言~</p>\n<p>Ta-ta for now ヾ(￣▽￣)</p>","descriptionType":"html","publishedDate":"Thu, 13 Aug 2020 01:00:00 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbK4w3","linkMd5":"b422d5e4e3dee35be3d3afd3b84c77cd","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn14@2020_6/2020/08/24/23-08-22-984_c34630b4bcb95121.webp","destWidth":800,"destHeight":450,"sourceBytes":40285,"destBytes":12508,"author":"飞狐","articleImgCdnMap":{"https://segmentfault.com/img/bVbK4w3":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn14@2020_6/2020/08/24/23-08-22-984_c34630b4bcb95121.webp","https://segmentfault.com/img/bVbK4xe":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn80@2020_2/2020/08/24/23-08-40-513_d8c8f7bcd0b2f161.webp","https://segmentfault.com/img/bVbK4xf":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn84@2020_3/2020/08/24/23-08-40-464_0f4e5e7d74c38a3f.webp","https://segmentfault.com/img/bVbK4xg":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn63@2020_4/2020/08/24/23-08-40-963_15be9c0256e0e892.webp","https://segmentfault.com/img/bVbK4xh":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn68@2020_3/2020/08/24/23-08-41-099_18c413ba34379e95.webp","https://segmentfault.com/img/bVbK4xi":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn72@2020_6/2020/08/24/23-08-40-953_0fe59535c76a90d2.webp","https://segmentfault.com/img/bVbK4xj":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn76@2020_3/2020/08/24/23-08-40-898_06b93a933331770f.webp"},"publishedOrCreatedDate":1598310388569},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"下载的附件名总乱码？你该去读一下 RFC 文档了！ ","link":"https://segmentfault.com/a/1190000023601065","description":"<blockquote>\n 纸上得来终觉浅，绝知此事要躬行\n</blockquote>\n<p>Web 开发过程中，相信大家都遇到过附件下载的场景，其中，各浏览器下载后的文件名中文乱码问题或许一度让你苦恼不已。</p>\n<p>网上搜索一下，大部分都是通过<code>Request Headers</code>中的<code>UserAgent</code>字段来判断浏览器类型，根据不同的浏览器做不同的处理，类似下面的代码：</p>\n<pre><code class=\"java\">// MicroSoft Browser\nif (agent.contains(\"msie\") || agent.contains(\"trident\") || agent.contains(\"edge\")) {\n  // filename 特殊处理\n}\n// firefox\nelse if (agent.contains(\"firefox\")) {\n  // filename 特殊处理\n}\n// safari\nelse if (agent.contains(\"safari\")) {\n  // filename 特殊处理\n}\n// Chrome\nelse if (agent.contains(\"chrome\")) {\n  // filename 特殊处理\n}\n// 其他\nelse{\n // filename 特殊处理\n}\n//最后把特殊处理后的文件名放到head里\nresponse.setHeader(\"Content-Disposition\",\n                    \"attachment;fileName=\" + filename);</code></pre>\n<p>不过，这样的代码看起来很魔幻，为什么每个浏览器的处理方式都不一样？难道每次新出一个浏览器都要做兼容吗？就没有一个统一标准来约束一下这帮浏览器吗？</p>\n<p>带着这个疑惑，我翻阅了 RFC 文档，最终得出了一个优雅的解决方案：</p>\n<pre><code class=\"java\">// percentEncodedFileName 为百分号编码后的文件名\nresponse.setHeader(\"Content-disposition\",\n        \"attachment;filename=\" + percentEncodedFileName +\n        \";filename*=utf-8''\" + percentEncodedFileName);</code></pre>\n<p>经过测试，这段响应头可以兼容市面上所有主流浏览器，由于是 HTTP 协议范畴，所以语言无关。只要按这个规则设置响应头，就能一劳永逸地解决恼人的附件名中文乱码问题。</p>\n<p>接下来课代表带大家抽丝剥茧，通过阅读 RFC 文档，还原一下这个响应头的产出过程。</p>\n<h2>1. Content-Disposition</h2>\n<p>一切要从 <a href=\"https://tools.ietf.org/html/rfc6266\" rel=\"nofollow noreferrer\">RFC 6266</a> 开始，在这份文档中，介绍了<code>Content-Disposition</code>响应头，其实它并不属于<code>HTTP</code>标准，但是因为使用广泛，所以在该文档中进行了约束。它的语法格式如下：</p>\n<pre><code class=\"java\">content-disposition = \"Content-Disposition\" \":\"\n                            disposition-type *( \";\" disposition-parm )\n\n     disposition-type    = \"inline\" | \"attachment\" | disp-ext-type\n                         ; case-insensitive\n     disp-ext-type       = token\n\n     disposition-parm    = filename-parm | disp-ext-parm\n\n     filename-parm       = \"filename\" \"=\" value\n                         | \"filename*\" \"=\" ext-value</code></pre>\n<p>其中的<code>disposition-type</code>有两种：</p>\n<ul>\n <li>inline 代表默认处理，一般会在页面展示</li>\n <li>attachment 代表应该被保存到本地，需要配合设置<code>filename</code>或<code>filename*</code></li>\n</ul>\n<p>注意到<code>disposition-parm</code>中的<code>filename</code>和<code>filename*</code>，文档规定：这里的信息可以用于保存的文件名。</p>\n<p>它俩的区别在于，filename 的 value 不进行编码，而<code>filename*</code>遵从 <a href=\"https://tools.ietf.org/html/rfc5987\" rel=\"nofollow noreferrer\">RFC 5987</a>中定义的编码规则：</p>\n<pre><code class=\"java\">Producers MUST use either the \"UTF-8\" ([RFC3629]) or the \"ISO-8859-1\" ([ISO-8859-1]) character set.</code></pre>\n<p>由于<code>filename*</code>是后来才定义的，许多老的浏览器并不支持，所以文档规定，当二者同时出现在头字段中时，需要采用<code>filename*</code>，忽略<code>filename</code>。</p>\n<p>至此，响应头的骨架已经呼之欲出了，摘录 [RFC 6266] 中的示例如下：</p>\n<pre><code class=\"java\"> Content-Disposition: attachment;\n                      filename=\"EURO rates\";\n                      filename*=utf-8''%e2%82%ac%20rates</code></pre>\n<p>这里对<code>filename*=utf-8''%e2%82%ac%20rates</code>做一下说明，这个写法乍一看可能会觉得很奇怪，它其实是用单引号作为分隔符，将等号右边分成了三部分：第一部分是字符集(<code>utf-8</code>)，中间部分是语言(未填写)，最后的<code>%e2%82%ac%20rates</code>代表了实际值。对于这部分的组成，在<a href=\"https://tools.ietf.org/html/rfc2231\" rel=\"nofollow noreferrer\">RFC 2231</a>.section 4 中有详细说明：</p>\n<pre><code class=\"java\"> A single quote is used to\n   separate the character set, language, and actual value information in\n   the parameter value string, and an percent sign is used to flag\n   octets encoded in hexadecimal.</code></pre>\n<h2>2.PercentEncode</h2>\n<p>PercentEncode 又叫 Percent-encoding 或 URL encoding.</p>\n<p>正如前文所述，<code>filename*</code>遵守的是[RFC 5987] 中定义的编码规则，在[RFC 5987] 3.2中定义了必须支持的字符集：</p>\n<pre><code class=\"java\">recipients implementing this specification\nMUST support the character sets \"ISO-8859-1\" and \"UTF-8\".</code></pre>\n<p>并且在[RFC 5987] 3.2.1规定，百分号编码遵从 <a href=\"https://tools.ietf.org/html/rfc3986\" rel=\"nofollow noreferrer\">RFC 3986</a>.section 2.1中的定义，摘录如下：</p>\n<pre><code class=\"java\">A percent-encoding mechanism is used to represent a data octet in a\ncomponent when that octet's corresponding character is outside the\nallowed set or is being used as a delimiter of, or within, the\ncomponent.  A percent-encoded octet is encoded as a character\ntriplet, consisting of the percent character \"%\" followed by the two\nhexadecimal digits representing that octet's numeric value.  For\nexample, \"%20\" is the percent-encoding for the binary octet\n\"00100000\" (ABNF: %x20), which in US-ASCII corresponds to the space\ncharacter (SP).  Section 2.4 describes when percent-encoding and\ndecoding is applied.</code></pre>\n<p>注意了，<strong>[RFC 3986]</strong> 明确规定了<strong>空格 会被百分号编码为<code>%20</code></strong></p>\n<p>而在另一份文档 <a href=\"https://tools.ietf.org/html/rfc1866\" rel=\"nofollow noreferrer\">RFC 1866</a>.Section 8.2.1 <em>The form-urlencoded Media Type</em> 中却规定：</p>\n<pre><code class=\"java\">The default encoding for all forms is `application/x-www-form-\n   urlencoded'. A form data set is represented in this media type as\n   follows:\n\n        1. The form field names and values are escaped: space\n        characters are replaced by `+', and then reserved characters\n        are escaped as per [URL]</code></pre>\n<p>这里要求<code>application/x-www-form-urlencoded</code>类型的消息中，空格要被替换为<code>+</code>,其他字符按照[URL]中的定义来转义，其中的[URL]指向的是<a href=\"https://tools.ietf.org/html/rfc1738\" rel=\"nofollow noreferrer\">RFC 1738</a> 而它的修订版中和 URL 有关的最新文档恰恰就是 <strong>[RFC 3986]</strong></p>\n<p>这也就是为什么很多文档中描述空格(white space)的百分号编码结果都是 <code>+</code>或<code>%20</code>，如：</p>\n<p>w3schools:<code>URL encoding normally replaces a space with a plus (+) sign or with %20.</code></p>\n<p>MDN:<code>Depending on the context, the character ' ' is translated to a '+' (like in the percent-encoding version used in an application/x-www-form-urlencoded message), or in '%20' like on URLs.</code></p>\n<p>那么问题来了，开发过程中，对于空格符的百分号编码我们应该怎么处理？</p>\n<p>课代表建议大家遵循最新文档，因为 [RFC 1866] 中定义的情况仅适用于<code>application/x-www-form-urlencoded</code>类型， 就百分号编码的定义来说，我们应该以 <strong>[RFC 3986]</strong> 为准，所以，任何需要百分号编码的地方，都应该将空格符 百分号编码为<code>%20</code>，stackoverflow 上也有支持此观点的答案：<a href=\"https://stackoverflow.com/questions/2678551/when-to-encode-space-to-plus-or-20\" rel=\"nofollow noreferrer\">When to encode space to plus (+) or %20?</a></p>\n<h2>3. 代码实践</h2>\n<p>有了理论基础，代码写起来就水到渠成了，直接上代码：</p>\n<pre><code class=\"java\">@GetMapping(\"/downloadFile\")\npublic String download(String serverFileName, HttpServletRequest request, HttpServletResponse response) throws IOException {\n\n    request.setCharacterEncoding(\"utf-8\");\n    response.setContentType(\"application/octet-stream\");\n\n    String clientFileName = fileService.getClientFileName(serverFileName);\n    // 对真实文件名进行百分号编码\n    String percentEncodedFileName = URLEncoder.encode(clientFileName, \"utf-8\")\n            .replaceAll(\"\\\\+\", \"%20\");\n\n    // 组装contentDisposition的值\n    StringBuilder contentDispositionValue = new StringBuilder();\n    contentDispositionValue.append(\"attachment; filename=\")\n            .append(percentEncodedFileName)\n            .append(\";\")\n            .append(\"filename*=\")\n            .append(\"utf-8''\")\n            .append(percentEncodedFileName);\n    response.setHeader(\"Content-disposition\",\n            contentDispositionValue.toString());\n    \n    // 将文件流写到response中\n    try (InputStream inputStream = fileService.getInputStream(serverFileName);\n         OutputStream outputStream = response.getOutputStream()\n    ) {\n        IOUtils.copy(inputStream, outputStream);\n    }\n\n    return \"OK!\";\n}</code></pre>\n<p>代码很简单，其中有两点需要说明一下：</p>\n<ol>\n <li><p><code>URLEncoder.encode(clientFileName, \"utf-8\")</code>方法之后，为什么还要<code>.replaceAll(\"\\\\+\", \"%20\")</code>。</p><p>正如前文所述，我们已经明确，任何需要百分号编码的地方，都应该把 空格符编码为 <code>%20</code>，而<code>URLEncoder</code>这个类的说明上明确标注其会将空格符转换为<code>+</code>:</p>\n  <blockquote>\n   The space character \" &nbsp; \" is converted into a plus sign \"{@code +}\".\n  </blockquote><p>其实这并不怪 JDK，因为它的备注里说明了其遵循的是<code>application/x-www-form-urlencoded</code>( PHP 中也有这么一个函数，也是这么个套路)</p>\n  <blockquote>\n   Translates a string into {@code application/x-www-form-urlencoded} format using a specific encoding scheme. This method uses the\n  </blockquote><p>所以这里我们用<code>.replaceAll(\"\\\\+\", \"%20\")</code> 把<code>+</code>号处理一下，使其完全符合 <strong>[RFC 3986]</strong> 的百分号编码规范。这里为了方便说明问题，把所有操作都展现出来了。当然，你完全可以自己实现一个<code>PercentEncoder</code>类，丰俭由人。</p></li>\n <li>[RFC 6266] 标准中<code>filename=</code>的<code>value</code>是不需要编码的，这里的<code>filename=</code>后面的 value 为什么要百分号编码？<p>回顾 [RFC 6266] 文档， <code>filename</code>和<code>filename*</code>同时出现时取后者，浏览器太老不支持新标准时取前者。</p><p>目前主流的浏览器都采用自升级策略，所以大部分都支持新标准------除了老版本IE。老版本的IE对 value 的处理策略是 进行百分号解码 并使用。所以这里专门把<code>filename=</code>的<code>value</code>进行百分号编码，用来兼容老版本 IE。</p><p>PS：课代表实测 IE11 及 Edge 已经支持新标准了。</p></li>\n</ol>\n<h2>4. 浏览器测试</h2>\n<p>根据下图 statcounter 统计的 2019 年中国市场浏览器占有率，课代表设计了一个包含中文，英文，空格的文件名 <code>下载-down test .txt</code>用来测试</p>\n<p><img src=\"https://segmentfault.com/img/bVbLbdV\" alt=\"image\" title=\"image\" /></p>\n<p>测试结果：</p>\n<table>\n <thead>\n  <tr>\n   <th>Browser</th>\n   <th>Version</th>\n   <th>pass</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>Chrome</td>\n   <td>84.0.4147.125</td>\n   <td>true</td>\n  </tr>\n  <tr>\n   <td>UC</td>\n   <td>V6.2.4098.3</td>\n   <td>true</td>\n  </tr>\n  <tr>\n   <td>Safari</td>\n   <td>13.1.2</td>\n   <td>true</td>\n  </tr>\n  <tr>\n   <td>QQ Browser</td>\n   <td>10.6.1(4208)</td>\n   <td>true</td>\n  </tr>\n  <tr>\n   <td>IE</td>\n   <td>7-11</td>\n   <td>true</td>\n  </tr>\n  <tr>\n   <td>Firefox</td>\n   <td>79.0</td>\n   <td>true</td>\n  </tr>\n  <tr>\n   <td>Edge</td>\n   <td>44.18362.449.0</td>\n   <td>true</td>\n  </tr>\n  <tr>\n   <td>360安全浏览器12</td>\n   <td>12.2.1.362.0</td>\n   <td>true</td>\n  </tr>\n  <tr>\n   <td>Edge(chromium)</td>\n   <td>84.0.522.59</td>\n   <td>true</td>\n  </tr>\n </tbody>\n</table>\n<p>根据测试结果可知：基本已经能够兼容市面上所有主流浏览器了。</p>\n<h2>5.总结</h2>\n<p>回顾本文内容，其实就是浏览器兼容性问题引发的附件名乱码，为了解决这个问题，查阅了两类标准文档：</p>\n<ol>\n <li>HTTP 响应头相关标准<p>[RFC 6266]、[RFC 1866]</p></li>\n <li>编码标准<p>[RFC 5987]、[RFC 2231]、[3986]、[1738]</p></li>\n</ol>\n<p>我们以 [RFC 6266] 为切入点，全文总共引用了 6 个 [RFC] 相关文档，引用都标明了出处，感兴趣的同学可以跟着文章思路阅读一下原文档，相信你会对这个问题有更深入的理解。文中代码已上传 <a href=\"https://github.com/zhengxl5566/springboot-demo\" rel=\"nofollow noreferrer\">github</a></p>\n<p>最后不禁要感叹一下：规范真是个好东西，它就像 Java 语言中的 <code>interface</code>，只制定标准，具体实现留给大家各自发挥。</p>\n<p>如果觉得本文对你有帮助，欢迎收藏、分享、在看三连</p>\n<h2>6.参考资料</h2>\n<p>[1]RFC 6266: <em><a href=\"https://tools.ietf.org/html/rfc6266\" rel=\"nofollow noreferrer\">https://tools.ietf.org/html/r...</a></em></p>\n<p>[2]RFC 5987: <em><a href=\"https://tools.ietf.org/html/rfc5987\" rel=\"nofollow noreferrer\">https://tools.ietf.org/html/r...</a></em></p>\n<p>[3]RFC 2231: <em><a href=\"https://tools.ietf.org/html/rfc2231\" rel=\"nofollow noreferrer\">https://tools.ietf.org/html/r...</a></em></p>\n<p>[4]RFC 3986: <em><a href=\"https://tools.ietf.org/html/rfc3986\" rel=\"nofollow noreferrer\">https://tools.ietf.org/html/r...</a></em></p>\n<p>[5]RFC 1866: <em><a href=\"https://tools.ietf.org/html/rfc1866\" rel=\"nofollow noreferrer\">https://tools.ietf.org/html/r...</a></em></p>\n<p>[6]RFC 1738: <em><a href=\"https://tools.ietf.org/html/rfc1738\" rel=\"nofollow noreferrer\">https://tools.ietf.org/html/r...</a></em></p>\n<p>[7]When to encode space to plus (+) or %20?: <em><a href=\"https://stackoverflow.com/questions/2678551/when-to-encode-space-to-plus-or-20\" rel=\"nofollow noreferrer\">https://stackoverflow.com/que...</a></em></p>\n<hr>\n <p>2020年8月19日更新：<br>文中内容已合并进入开源框架 <a href=\"https://gitee.com/y_project/RuoYi\" rel=\"nofollow noreferrer\">若依</a> （pull request：<a href=\"https://gitee.com/y_project/RuoYi/pulls/196\" rel=\"nofollow noreferrer\">196</a>）</br></p>\n <hr>\n  <p>👇关注 Java课代表，获取最新 Java 干货👇<br><img src=\"https://segmentfault.com/img/bVbLbSq\" alt=\"image\" title=\"image\" /></br></p>\n </hr>\n</hr>","descriptionType":"html","publishedDate":"Thu, 13 Aug 2020 00:12:10 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLbdV","linkMd5":"76c9c6e6cb88560c51a4d8dfd2fa525b","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn90@2020_2/2020/08/24/23-08-22-917_b612e89919e9c268.webp","destWidth":800,"destHeight":361,"sourceBytes":60839,"destBytes":11212,"author":"Java课代表","articleImgCdnMap":{"https://segmentfault.com/img/bVbLbdV":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn90@2020_2/2020/08/24/23-08-22-917_b612e89919e9c268.webp","https://segmentfault.com/img/bVbLbSq":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn46@2020_2/2020/08/24/23-08-28-505_e4ee0051d3ebdd4a.webp"},"publishedOrCreatedDate":1598310388569},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"聊聊最近很火的eBPF","link":"https://segmentfault.com/a/1190000023602033","description":"<p><img src=\"https://segmentfault.com/img/remote/1460000023602036\" alt=\"\" title=\"\" /></p>\n<p>如果非要说当前计算机领域最有前途的两个基础软件技术，那非eBPF和wasm莫属了。</p>\n<h3>什么是eBPF？</h3>\n<p>Linux内核一直是实现监视/可观察性，网络和安全性的理想场所。不幸的是，这通常是不切实际的，因为它需要更改内核源代码或加载内核模块，并导致彼此堆叠的抽象层。 eBPF是一项革命性的技术，可以在Linux内核中运行沙盒程序，而无需更改内核源代码或加载内核模块。通过使Linux内核可编程，基础架构软件可以利用现有的层，从而使它们更加智能和功能丰富，而无需继续为系统增加额外的复杂性层。</p>\n<p>eBPF导致了网络，安全性，应用程序配置/跟踪和性能故障排除等领域的新一代工具的开发，这些工具不再依赖现有的内核功能，而是在不影响执行效率或安全性的情况下主动重新编程运行时行为。</p>\n<p>如果直接解释eBPF，有点不明所以。那我们就看看有哪些基于eBPF的工程，这些工程或许你已经知道，或是已经经常使用，也许你会明白eBPF距离我们并不遥远。</p>\n<h3>基于eBPF的项目</h3>\n<p>1：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/iovisor/bcc\" rel=\"nofollow noreferrer\">bcc</a></p>\n<p>BCC是用于创建基于eBPF的高效内核跟踪和操作程序的工具包，其中包括一些有用的命令行工具和示例。 BCC简化了用C进行内核检测的eBPF程序的编写，包括LLVM的包装器以及Python和Lua的前端。它还提供了用于直接集成到应用程序中的高级库。</p>\n<p>2：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/iovisor/bpftrace\" rel=\"nofollow noreferrer\">bpftrace</a></p>\n<p>bpftrace是Linux eBPF的高级跟踪语言。它的语言受awk和C以及DTrace和SystemTap等以前的跟踪程序的启发。 bpftrace使用LLVM作为后端将脚本编译为eBPF字节码，并利用BCC作为与Linux eBPF子系统以及现有Linux跟踪功能和连接点进行交互的库。</p>\n<p>3：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/cilium/cilium\" rel=\"nofollow noreferrer\">Cilium</a></p>\n<p>Cilium是一个开源项目，提供基于eBPF的联网，安全性和可观察性。它是从头开始专门设计的，旨在将eBPF的优势带入Kubernetes的世界，并满足容器工作负载的新可伸缩性，安全性和可见性要求。</p>\n<p>4：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/falcosecurity/falco\" rel=\"nofollow noreferrer\">Falco</a></p>\n<p>Falco是一种行为活动监视器，旨在检测应用程序中的异常活动。 Falco在eBPF的帮助下审核Linux内核层的系统。它使用其他输入流（例如容器运行时度量标准和Kubernetes度量标准）丰富了收集的数据，并允许连续监视和检测容器，应用程序，主机和网络活动。</p>\n<p>5：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/facebookincubator/katran\" rel=\"nofollow noreferrer\">Katran</a></p>\n<p>Katran是一个C ++库和eBPF程序，用于构建高性能的第4层负载平衡转发平面。 Katran利用Linux内核中的XDP基础结构来提供用于快速数据包处理的内核功能。它的性能与NIC接收队列的数量成线性比例，并且使用RSS友好的封装转发到L7负载平衡器。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023602037\" alt=\"\" title=\"\" /></p>\n<p>6：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/draios/sysdig\" rel=\"nofollow noreferrer\">Sysdig</a></p>\n<p>Sysdig是提供深层系统可见性的简单工具，并具有对容器的原生支持。</p>\n<p>其他基于eBPF技术的项目还有很多，比如<a href=\"https://link.zhihu.com/?target=https%3A//github.com/iovisor/kubectl-trace\" rel=\"nofollow noreferrer\">kubectl-trace</a> ，<a href=\"https://link.zhihu.com/?target=https%3A//github.com/iovisor/ply\" rel=\"nofollow noreferrer\">ply</a> 等，这里不再赘述。</p>\n<h3>如何编写一个eBPF程序？</h3>\n<p>在很多情况下，不是直接使用eBPF，而是通过Cilium，bcc或bpftrace等项目间接使用eBPF，这些项目在eBPF之上提供了抽象，并且不需要直接编写程序，而是提供了指定基于意图的定义的功能，然后使用eBPF实施。</p>\n<p>如果不存在更高级别的抽象，则需要直接编写程序。 Linux内核希望eBPF程序以字节码的形式加载。虽然当然可以直接编写字节码，但更常见的开发实践是利用LLVM之类的编译器套件将伪C代码编译为eBPF字节码。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023602038\" alt=\"\" title=\"\" /></p>\n<p>在编写eBPF程序之前，需要简单了解几个概念。</p>\n<p>1）map(映射) ：BPF最令人着迷的方面之一是，内核上运行的代码和加载了该代码的程序可以在运行时使用消息传递相互通信。</p>\n<p>BPF映射是驻留在内核中的键/值存储。任何BPF程序都可以访问它们。在用户态中运行的程序也可以使用文件描述符访问这些映射。只要事先正确指定数据大小，就可以在映射中存储任何类型的数据。内核将键和值视为二进制 blobs，它并不关心您在映射中保留的内容。</p>\n<p>BPF验证程序包括多种保护措施，以确保您创建和访问映射的方式是安全的。当我们解释如何访问这些映射中的数据时，我们也将解释这些保护措施。</p>\n<p>当然BPF映射类型有很多，比如哈希表映射，数组映射，Cgroup 数组映射等，分别满足不同的场景。</p>\n<p>2）验证器</p>\n<p>BPF验证程序也是在您的系统上运行的程序，因此，对其进行严格审查是确保其正确执行工作的目标。</p>\n<p>验证程序执行的第一项检查是对VM即将加载的代码的静态分析。第一次检查的目的是确保程序有预期的结果。为此，验证程序将使用代码创建有向循环图（DAG）。验证程序分析的每个指令将成为图中的一个节点，并且每个节点都链接到下一条指令。验证程序生成此图后，它将执行深度优先搜索（DFS），以确保程序完成并且代码不包含危险路径。这意味着它将遍历图的每个分支，一直到分支的底部，以确保没有递归循环。</p>\n<p>这些是验证器在第一次检查期间可能拒绝您的代码的情形，要求有以下几个方面：</p>\n<ul>\n <li>该程序不包含控制循环。为确保程序不会陷入无限循环，验证程序会拒绝任何类型的控制循环。已经提出了在BPF程序中允许循环的建议，但是截至撰写本文时，没有一个被采用。</li>\n <li>该程序不会尝试执行超过内核允许的最大指令数的指令。此时，可执行的最大指令数为4,096。此限制是为了防止BPF永远运行。在第3章，我们讨论如何嵌套不同的BPF程序，以安全的方式解决此限制。</li>\n <li>该程序不包含任何无法访问的指令，例如从未执行过的条件或功能。这样可以防止在VM中加载无效代码，这也会延迟BPF程序的终止。</li>\n <li>该程序不会尝试越界。</li>\n</ul>\n<p>验证者执行的第二项检查是BPF程序的空运行。这意味着验证者将尝试分析程序将要执行的每条指令，以确保它不会执行任何无效的指令。此执行还将检查所有内存指针是否均已正确访问和取消引用。最后，空运行向验证程序通知程序中的控制流，以确保无论程序采用哪个控制路径，它都会到达BPF_EXIT指令。为此，验证程序会跟踪堆栈中所有访问过的分支路径，并在采用新路径之前对其进行评估，以确保它不会多次访问特定路径。经过这两项检查后，验证者认为程序可以安全执行。</p>\n<p>3) hook ： 由于eBPF是事件驱动的，所以ebpf是作用于具体的hook的。根据不同的作用，常用的有XDP，trace，套接字等。</p>\n<p>4）帮助函数：eBPF程序无法调用任意内核功能。允许这样做会将eBPF程序绑定到特定的内核版本，并使程序的兼容性复杂化。取而代之的是，eBPF程序可以调用帮助函数，该函数是内核提供的众所周知且稳定的API。</p>\n<h3>总结</h3>\n<p>安全，网络，负载均衡，故障分析，追踪等领域都是eBPF的主战场。</p>\n<p>对于云原生领域，Cilium 已经使用eBPF 实现了无kube-proxy的容器网络。利用eBPF解决iptables带来的性能问题。</p>\n<p>整个eBPF生态发展比较好，社区已经提供了诸多工具方便大家编写自己的eBPF程序。</p>","descriptionType":"html","publishedDate":"Thu, 13 Aug 2020 01:30:17 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023602036","linkMd5":"a52d5aa652910e157d09aa5f6fb7920b","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn30@2020_2/2020/08/24/23-08-24-482_02dc9380d0589ef6.webp","destWidth":800,"destHeight":445,"sourceBytes":56763,"destBytes":40328,"author":"iyacontrol","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023602036":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn30@2020_2/2020/08/24/23-08-24-482_02dc9380d0589ef6.webp","https://segmentfault.com/img/remote/1460000023602037":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn54@2020_3/2020/08/24/23-08-28-794_86f6da9014919043.webp","https://segmentfault.com/img/remote/1460000023602038":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn49@2020_6/2020/08/24/23-08-28-724_8b97a00e92f7b9a5.webp"},"publishedOrCreatedDate":1598310388568},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"想要在JS中把正则玩得飘逸，学会这几个函数的使用必不可少","link":"https://segmentfault.com/a/1190000023733064","description":"<p><img src=\"https://segmentfault.com/img/bVbLKdl\" alt=\"image\" title=\"image\" /></p>\n<p>在之前的一系列文章中，我们讲解了很多关于正则表达式的知识。那么作为一个前端工程师，如果想要把这些知识应用到我们平时的开发中去的话，就需要知道在<strong>JavaScript</strong>中，能够使用正则的函数有哪些？然后它们各自的功能是什么？有哪些需要注意的地方？只有掌握好了每一个方法的使用场景，我们才可能在需要使用的时候能够很快的想起来使用哪个方法效率最高，效果最好。</p>\n<p>这些确实是一些基础的知识，但是我相信应该有很多同学还没有系统的把这些知识学习一边。<strong>相信我，如果你能够把这篇文章看完的话，你肯定可以学习到一些新的知识。知道每一个方法的用途，使用场景，学会在合适的场景选择合适的方法</strong>。当然你还能够掌握这些方法需要注意的地方，以防在以后使用的时候陷入了困境。</p>\n<p>文章中的代码示例如果没有特别说明的话，都是在<code>Chrome</code>浏览器中进行的。本篇文章的内容比较长，建议先收藏起来，可以以后慢慢细看。</p>\n<p>在<strong>JavaScript</strong>中，能够使用正则表达式的函数有（排除了过时的方法）：</p>\n<ul>\n <li><p>RegExp.prototype</p>\n  <ul>\n   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test\" rel=\"nofollow noreferrer\">RegExp.prototype.test()</a></li>\n   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\" rel=\"nofollow noreferrer\">RegExp.prototype.exec()</a></li>\n  </ul></li>\n <li><p>String.prototype</p>\n  <ul>\n   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match\" rel=\"nofollow noreferrer\">String.prototype.match()</a></li>\n   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll\" rel=\"nofollow noreferrer\">String.prototype.matchAll()</a></li>\n   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace\" rel=\"nofollow noreferrer\">String.prototype.replace()</a></li>\n   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll\" rel=\"nofollow noreferrer\">String.prototype.replaceAll()</a></li>\n   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/search\" rel=\"nofollow noreferrer\">String.prototype.search()</a></li>\n   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split\" rel=\"nofollow noreferrer\">String.prototype.split()</a></li>\n  </ul></li>\n</ul>\n<h2>RegExp.prototype</h2>\n<p>首先我们要讲解的是<strong>RegExp</strong>对象上的两个方法</p>\n<h3>RegExp.prototype.test()</h3>\n<ul>\n <li><strong>作用</strong>：检测给定的字符串中是否有满足正则的匹配</li>\n <li><strong>代码示例</strong>：</li>\n</ul>\n<p>简单的匹配，根据匹配的结果确定是否匹配成功。</p>\n<pre><code class=\"javascript\">const reg = /\\d{4}-\\d{2}-\\d{2}/;\nconst str1 = '2000-02-22';\nconst str2 = '20-20-20';\nconsole.log(reg.test(str1)); // true\nconsole.log(reg.test(str2)); // false</code></pre>\n<p>上面的正则表达式没有设置全局的标志符<code>g</code>，如果设置了全局的标志符的话，我们在使用这个方法的时候就要小心一些了。<strong>因为如果正则表达式设置了全局的标识符<code>g</code>，那么对于同一个正则表达式来说，在运行<code>test</code>方法的时候，如果匹配成功的话，它会修改这个正则对象的<code>lastIndex</code>属性，可能会在下次匹配的时候导致一些问题，我们下面来看一个例子</strong>。</p>\n<pre><code class=\"javascript\">const reg = /abc/g;\nconst str1 = 'abcd';\nconst str2 = 'abcdabcd';\n\nconsole.log(reg.lastIndex);  // 0\nconsole.log(reg.test(str1));  // true\nconsole.log(reg.lastIndex);  // 3\nconsole.log(reg.test(str1));  // false\n\nconsole.log(reg.lastIndex);  // 0\nconsole.log(reg.test(str2));  // true\nconsole.log(reg.lastIndex);  // 3\nconsole.log(reg.test(str2));  // true</code></pre>\n<p>上面的例子很好地说明了这种情况，如果我们设置了全局标识符<code>g</code>的话，<strong>只要我们当前的匹配是成功的，那么接下来如果再次使用同样的正则进行匹配的话就可能会出现问题，因为上一个成功的匹配导致正则表达式对象的<code>lastIndex</code>属性的值发生了变化，那么下次进行匹配的时候是从<code>lastIndex</code>位置开始的，所以就可能会出现一些问题</strong>。</p>\n<ul>\n <li><strong>注意事项</strong>：如果在使用<code>test</code>方法的时候，需要注意正则表达式是否带有<code>g</code>标识符。如果这个正则表达式需要进行多次的匹配的话，最好不要设置<code>g</code>标识符。除非你知道自己确实需要这样做。</li>\n <li><strong>使用场景</strong>：</li>\n</ul>\n<p>假如有这样一个需求，你需要判断用户输入的用户名是否满足需求，需求如下：<strong>（1）用户名长度需要是8-16位。（2）用户名可以包含数字，字母（大小写都可以），下划线。（3）数字和字母是必须包含的</strong>。</p>\n<p>当然对于熟悉正则表达式的你来说，这不是一个问题，能用一行代码解决的问题绝不用两行代码去解决。你可以很快可以通过使用<code>test</code>方法来解决这个问题。</p>\n<pre><code class=\"javascript\">const validNameRE = /^(?=_*(?:\\d+_*[a-zA-Z]+|[a-zA-Z]+_*\\d+))\\w{8,16}$/;\n// 假如这是用户输入的用户名\nconst userInputName = '1234567890';\n// 检查用户输入的用户名是否合乎要求\nconst isValidName = validNameRE.test(userInputName); // false</code></pre>\n<p>在平时的开发中，<strong>如果需要判断页面所处的宿主环境的话，我们也会使用<code>test</code>方法去判断当前页面所处的环境</strong>。例如，你需要判断当前页面所处的环境是不是<code>iPhone</code>的话，你可能会写出这样的判断：</p>\n<pre><code class=\"javascript\">const iPhoneReg = /iPhone/;\nconsole.log(iPhoneReg.test(navigator.userAgent));  // true</code></pre>\n<h3>RegExp.prototype.exec()</h3>\n<ul>\n <li><strong>作用</strong>：这个方法是比较常用的一个方法，<strong>在给定的字符串中进行匹配，返回一个匹配的结果数组或者<code>null</code></strong>。通常情况下我们会使用这个方法来提取字符串中符合匹配的一些字符串。</li>\n <li><strong>代码示例</strong>：</li>\n</ul>\n<p><strong>需要注意的是，如果没有符合的匹配，返回的结果是<code>null</code>，而不是一个空数组<code>[]</code></strong>。所以当我们需要判断是否有匹配的结果的时候，不能凭感觉觉得返回的值是一个空的数组<code>[]</code>。</p>\n<pre><code class=\"javascript\">const reg1 = /(\\d{2}):(\\d{2}):(\\d{2})/;\nconst str1 = 'Sat Aug 22 2020 17:31:55 GMT+0800 (中国标准时间)';\nconst str2 = 'Sat Aug 22 2020';\n\nconsole.log(reg1.exec(str1));  // [\"17:31:55\", \"17\", \"31\", \"55\", index: 16, input: \"Sat Aug 22 2020 17:31:55 GMT+0800 (中国标准时间)\", groups: undefined]\nconsole.log(reg1.exec(str2));  // null</code></pre>\n<p>从上面的代码中我们可以看到，<strong>如果没有匹配结果的话，返回的结果是<code>null</code>。如果能够匹配成功的话，返回的结果是一个数组</strong>。在这个结果数组中，第<code>0</code>项表示正则表达式匹配的内容。其中第<code>1..n</code>项表示的是正则表达式中括号的捕获内容，对于上面的示例来说，第<code>1..3</code>项表示的是捕获时间的时分秒。数组还有额外的属性<code>index</code>和<code>input</code>，其中<code>index</code>表示正则表达式匹配到的字符串在原字符串中的位置。<code>input</code>表示原始待匹配的字符串。</p>\n<ul>\n <li><p><strong>注意事项</strong>：</p>\n  <ul>\n   <li>注意正则表达式是否设置了<code>g</code>标识符，如果设置了<code>g</code>标识符，那么我们可以使用这个正则表达式进行全局的搜索。可以看下面的代码示例。</li>\n  </ul><pre><code class=\"javascript\">const reg = /\\d/g;\nconst str = '654321';\nlet result;\nwhile ((result = reg.exec(str))) {\n  console.log(\n    `本次匹配到的数字是：${result[0]}, 正则表达式的 lastIndex 的值是：${\n      reg.lastIndex\n    }`\n  );\n}</code></pre></li>\n</ul>\n<p>输出的结果如下：</p>\n<pre><code>本次匹配到的数字是：6, 正则表达式的 lastIndex 的值是：1\n本次匹配到的数字是：5, 正则表达式的 lastIndex 的值是：2\n本次匹配到的数字是：4, 正则表达式的 lastIndex 的值是：3\n本次匹配到的数字是：3, 正则表达式的 lastIndex 的值是：4\n本次匹配到的数字是：2, 正则表达式的 lastIndex 的值是：5\n本次匹配到的数字是：1, 正则表达式的 lastIndex 的值是：6</code></pre>\n<p><strong>需要注意的是，如果上面匹配的正则表达式没有设置<code>g</code>标识符，或者在<code>while</code>循环的条件判断中使用的是正则表达式的字面量的话，都会造成“死循环”。因为那样的话，每次循环开始的时候，正则表达式的<code>lastIndex</code>属性都会是<code>0</code>，导致<code>result</code>一直都是有值的，所以就导致了“死循环”。所以我们在<code>while</code>循环中使用<code>exec</code>方法的时候一定要小心一些</strong>。</p>\n<ul>\n <li><p><strong>使用场景</strong>：这个方法主要用来在原始文本中提取一些我们想要的关键信息，所以只要是这样的一个需求场景，都可以使用正则表达式的<code>exec</code>方法去处理。比如：</p>\n  <ul>\n   <li><strong>对用户输入内容中的链接进行自动识别</strong>，然后对相应的链接内容进行样式和功能上的处理。</li>\n   <li><strong>可以提取url中的查询参数</strong>，如果我们需要自己把url中的查询参数提取出来的话，使用<code>exec</code>方法也是一个选择。</li>\n   <li>如果你阅读过vue的源码的话，<strong>在编译模块中的<a href=\"https://github.com/vuejs/vue/blob/8f04135dbaa5f5f0500d42c0968beba8043f5363/src/compiler/parser/text-parser.js#L32\" rel=\"nofollow noreferrer\">文本解析</a>使用到了<code>exec</code>方法</strong>，有兴趣的话大家可以看一看相关的代码实现。</li>\n  </ul></li>\n</ul>\n<p>当然还有很多的场景可以使用<code>exec</code>方法去处理的，大家在平时的开发中有没有使用过<code>exec</code>方法处理一些问题呢？可以在下面留言，我们大家一起讨论一下，加深一下对这个方法的理解。</p>\n<h2>String.prototype</h2>\n<p>接下来我们来讲解一下<code>String.prototype</code>上面有关正则的一些方法。</p>\n<h3>String.prototype.match()</h3>\n<ul>\n <li><strong>作用</strong>：这个方法返回字符串匹配正则表达式的结果。</li>\n <li><strong>代码示例</strong>：</li>\n</ul>\n<pre><code class=\"javascript\">const reg = /\\d/;\nconst str = 'abc123';\nconsole.log(str.match(reg));  // [\"1\", index: 3, input: \"abc123\", groups: undefined]</code></pre>\n<ul>\n <li><p><strong>注意事项</strong>：</p>\n  <ul>\n   <li>没有匹配到结果的返回结果是<code>null</code>。</li>\n  </ul><pre><code class=\"javascript\">const reg = /\\d/;\nconst str = 'abc';\nconsole.log(str.match(reg));  // null</code></pre>\n  <ul>\n   <li>是否设置了<code>g</code>标识符，如果没有设置<code>g</code>的话，<code>match</code>的返回结果跟对应的<code>exec</code>的返回结果是一样的。如果设置了<code>g</code>标识符的话，返回的结果是与正则表达式相匹配的结果的集合。</li>\n  </ul><pre><code class=\"javascript\">const reg = /\\d/g;\nconst str = 'abc123';\nconsole.log(str.match(reg));  // [\"1\", \"2\", \"3\"]</code></pre>\n  <ul>\n   <li>如果<code>match</code>方法没有传递参数的话，返回的结果是<code>['']</code>，一个包含空字符串的数组。</li>\n  </ul><pre><code class=\"javascript\">const str = 'abc123';\nconsole.log(str.match());  // [\"\", index: 0, input: \"abc123\", groups: undefined]</code></pre>\n  <ul>\n   <li>如果<code>match</code>方法传递的参数是一个字符串或者数字的话，会在内部隐式调用<code>new RegExp(regex)</code>，将传入的参数转变为一个正则表达式。</li>\n  </ul><pre><code class=\"javascript\">const str = 'abc123';\nconsole.log(str.match('b'));  // [\"b\", index: 1, input: \"abc123\", groups: undefined]</code></pre></li>\n <li><p><strong>使用场景</strong>：</p><p>简单获取url中的查询参数：</p><pre><code class=\"javascript\">const query = {};\n// 首先使用带有g标识符的正则，表示全局查找\nconst kv = location.search.match(/\\w*=\\w*/g);\nif (kv) {\n  kv.forEach(v =&gt; {\n      // 使用不带g标识符的正则，需要获取括号中的捕获内容\n    const q = v.match(/(\\w*)=(\\w*)/);\n    query[q[1]] = q[2];\n  });\n}</code></pre></li>\n</ul>\n<h3>String.prototype.matchAll()</h3>\n<ul>\n <li><strong>作用</strong>：这个方法返回一个包含所有匹配正则表达式以及正则表达式中括号的捕获内容的迭代器。需要注意的是这个方法存在兼容性，具体内容可以查看<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll\" rel=\"nofollow noreferrer\">String.prototype.matchAll</a>。</li>\n <li><strong>代码示例</strong>：</li>\n</ul>\n<pre><code class=\"javascript\">const reg = /(\\w*)=(\\w*)/g;\nconst str = 'a=1,b=2,c=3';\nconsole.log([...str.matchAll(reg)]);</code></pre>\n<p><img src=\"https://segmentfault.com/img/bVbLKdp\" alt=\"String.prototype.matchAll()\" title=\"String.prototype.matchAll()\" /></p>\n<ul>\n <li><p><strong>注意事项</strong>：</p>\n  <ul>\n   <li>跟<code>match</code>方法相同的地方是，如果传递给<code>matchAll</code>方法的参数不是一个正则表达式的话，那么会隐式调用<code>new RegExp(obj)</code>将其转换为一个正则表达式对象。</li>\n   <li>传递给<code>matchAll</code>的正则表达式需要是设置了<code>g</code>标识符的，如果没有设置<code>g</code>标识符，那么就会抛出一个错误。</li>\n  </ul><pre><code class=\"javascript\">const reg = /(\\w*)=(\\w*)/;\nconst str = 'a=1,b=2,c=3';\nconsole.log([...str.matchAll(reg)]);  // Uncaught TypeError: String.prototype.matchAll called with a non-global RegExp argument</code></pre>\n  <ul>\n   <li>在可以使用<code>matchAll</code>的情况下，使用<code>matchAll</code>比使用<code>exec</code>方法更便捷一些。因为在全局需要匹配的情况下，使用<code>exec</code>方法需要配合循环来使用，但是使用<code>matchAll</code>就可以不使用循环。</li>\n   <li><code>matchAll</code>方法在字符串执行匹配的过程中，正则表达式的<code>lastIndex</code>属性不会更新。更多详情可以参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll\" rel=\"nofollow noreferrer\">String.prototype.matchAll()</a>。</li>\n  </ul></li>\n <li><strong>使用场景</strong>：</li>\n</ul>\n<p>还是以上面的获取url中的查询参数这个小功能来实践一下：</p>\n<pre><code class=\"javascript\">const query = {};\nconst kvs = location.search.matchAll(/(\\w*)=(\\w*)/g);\nif (kvs) {\n    for (let kv of kvs) {\n        query[kv[1]] = kv[2];\n    }\n}\nconsole.log(query);</code></pre>\n<h3>String.prototype.replace()</h3>\n<ul>\n <li><strong>作用</strong>：这个方法在平时的开发中应该比较常用，那么它的作用就是使用<strong>替换物</strong><code>replacement</code>替换原字符串中符合某种<strong>模式</strong><code>pattern</code>的字符串。其中<strong>替换物</strong>可以是一个字符串，或者返回值是字符串的函数；<strong>模式</strong>可以是正则表达式或者字符串。</li>\n <li><p><strong>代码示例</strong>：</p><p>因为这个函数的入参可以是不同的类型，所以对每种类型的入参我们都来实践一下吧。</p>\n  <ul>\n   <li><strong><code>pattern</code>是字符串，<code>replacement</code>也是字符串</strong>。这种形式在平时的开发中使用的比较多。</li>\n  </ul><pre><code class=\"javascript\">const pattern = 'a';\nconst replacement = 'A';\nconst str = 'aBCD';\nconsole.log(str.replace(pattern, replacement));  // ABCD</code></pre>\n  <ul>\n   <li><strong><code>pattern</code>是正则表达式，<code>replacement</code>是字符串</strong>。</li>\n  </ul><pre><code class=\"javascript\">const pattern = /__(\\d)__/;\nconst replacement = \"--$$--$&amp;--$`--$'--$1--\";\nconst str = 'aaa__1__bbb';\nconsole.log(str.replace(pattern, replacement));  // aaa--$--__1__--aaa--bbb--1--bbb</code></pre></li>\n</ul>\n<p>如果<code>replacement</code>是字符串，那么在这个字符串中可以使用一些特殊的变量，具体可参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter\" rel=\"nofollow noreferrer\">Specifying a string as a parameter</a>。</p>\n<ul>\n <li><p><strong><code>pattern</code>是正则表达式，<code>replacement</code>是函数</strong>。</p><pre><code class=\"javascript\">const pattern = /__(?&lt;number&gt;\\d)__/;\nconst replacement = function(match, p1, offset, str, groups) {\n  console.log(`匹配到的字符串是：${match}\\n捕获到的内容是：${p1}\\n匹配的位置是：${offset}\\n原始待匹配的字符串是：${str}\\n命名的捕获内容是：${JSON.stringify(groups)}`);\n  return '======';\n};\nconst str = 'aaa__1__bbb';\nconsole.log(str.replace(pattern, replacement)); // aaa======bbb</code></pre></li>\n</ul>\n<p>其中控制台的输出如下所示：</p>\n<pre><code class=\"javascript\">匹配到的字符串是：__1__\n捕获到的内容是：1\n匹配的位置是：3\n原始待匹配的字符串是：aaa__1__bbb\n命名的捕获内容是：{\"number\":\"1\"}</code></pre>\n<p>如果你对<code>replacement</code>是函数这种情况不是很了解的话可以看看<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter\" rel=\"nofollow noreferrer\">Specifying a function as a parameter</a>，里面会有详细的解释，这里就不在具体解释了。</p>\n<ul>\n <li><strong>注意事项</strong>：<p>需要注意的地方就是当我们的<code>pattern</code>是正则表达式的时候，要注意是否设置了<code>g</code>标识符，因为如果没有设置<code>g</code>标识符的话，只会进行一次匹配。设置了<code>g</code>标识符的话，会进行全局的匹配。</p></li>\n <li><p><strong>使用场景</strong>：</p><p>对于前端来说，对用户的输入进行校验时很常见的需求。假如我们有一个输入框，只允许用户输入数字，我们可以这样处理：</p><pre><code class=\"javascript\">const reg = /\\D/g;\nconst str = 'abc123';\nconsole.log(str.replace(reg, ''));  // 123</code></pre><p>这样就能够保证用户的输入只有数字了。</p></li>\n</ul>\n<h3>String.prototype.replaceAll()</h3>\n<blockquote>\n As of August 2020 the replaceAll() method is supported by Firefox but not by Chrome. It will become available in Chrome 85.\n</blockquote>\n<p>这个方法和<code>replace</code>方法的作用差不多，从名字上就能够知道<code>replaceAll</code>是全局的替换。因为这个方法的兼容性问题，我们需要在<code>Firefox</code>浏览器上进行试验。</p>\n<pre><code class=\"javascript\">const pattern = 'a';\nconst replacement = 'A';\nconst str = 'aBCDa';\nconsole.log(str.replace(pattern, replacement));  // ABCDa\nconsole.log(str.replaceAll(pattern, replacement));  // ABCDA</code></pre>\n<ul>\n <li><strong>注意事项</strong>：如果给函数传递的<code>pattern</code>参数是个正则表达式的话，这个正则表达式必须设置了<code>g</code>标识符，不然会抛出一个错误。</li>\n</ul>\n<pre><code class=\"javascript\">const pattern = /a/;\nconst replacement = 'A';\nconst str = 'aBCDa';\nconsole.log(str.replace(pattern, replacement));  // ABCDa\nconsole.log(str.replaceAll(pattern, replacement));  // Uncaught TypeError: replaceAll must be called with a global RegExp</code></pre>\n<h3>String.prototype.search()</h3>\n<ul>\n <li><strong>作用</strong>：这个方法用来在字符串中寻找是否含有特定模式的匹配，如果找到对应的模式，返回匹配开始的下标；没有找到的话返回<code>-1</code>。</li>\n <li><strong>代码示例</strong>：</li>\n</ul>\n<pre><code class=\"javascript\">const reg = /\\d/;\nconst str1 = '123';\nconst str2 = 'abc';\nconsole.log(str1.search(reg));  // 0\nconsole.log(str2.search(reg));  // -1</code></pre>\n<ul>\n <li><p><strong>注意事项</strong>：</p>\n  <ul>\n   <li>如果传入的参数不是一个正则表达式的话，会隐式的调用<code>new RegExp(regexp)</code>将其转换为一个正则表达式。</li>\n   <li>没有找到相应匹配的时候，返回的值是<code>-1</code>；所以大家在使用这个方法做判断的时候要注意，只有返回值是<code>-1</code>的时候，才表示没有找到相应的匹配。</li>\n  </ul></li>\n <li><strong>使用场景</strong>：</li>\n</ul>\n<p>如果你需要找到特定匹配在字符串中的位置的话，那么可以使用<code>search</code>方法。</p>\n<pre><code class=\"javascript\">const reg = /\\d/;\nconst str = 'abc6def';\nconsole.log(str.search(reg));  // 3</code></pre>\n<h3>String.prototype.split()</h3>\n<ul>\n <li><strong>作用</strong>：将一个字符串按照分割器进行分割，将分割后的字符串片段组成一个新的数组，其中<strong>分割器</strong><code>separator</code>可以是一个字符串或者一个正则表达式。</li>\n <li><p><strong>代码示例</strong>：</p>\n  <ul>\n   <li><strong>分割器</strong><code>separator</code>是字符串：</li>\n  </ul><pre><code class=\"javascript\">const str = 'hello, world!';\nconsole.log(str.split(''));  // [\"h\", \"e\", \"l\", \"l\", \"o\", \",\", \" \", \"w\", \"o\", \"r\", \"l\", \"d\", \"!\"]</code></pre>\n  <ul>\n   <li><strong>分割器</strong><code>separator</code>是正则表达式：</li>\n  </ul><pre><code class=\"javascript\">const str = 'abc1abc2abc3';\nconst separator = /\\w(?=\\d)/;\nconsole.log(str.split(separator));  // [\"ab\", \"1ab\", \"2ab\", \"3\"]</code></pre></li>\n <li><p><strong>注意事项</strong>：</p>\n  <ul>\n   <li>如果<code>split</code>方法没有传递参数的话，会返回一个包含原字符串的数组：</li>\n  </ul><pre><code class=\"javascript\">const str = 'hello, world!';\nconsole.log(str.split());  // [\"hello, world!\"]</code></pre>\n  <ul>\n   <li>因为<code>JavaScript</code>的字符串是使用<code>UTF-16</code>进行编码的，该编码使用一个16比特的编码单元来表示大部分常见的字符，使用两个编码单元表示不常用的字符。所以对于一些不常用的字符来说，在使用<code>split</code>方法进行字符串分割的时候可能会出现一些问题：</li>\n  </ul><pre><code class=\"javascript\">const str = '😀😃😄😁😆😅';\nconsole.log(str.split(''));  // [\"�\", \"�\", \"�\", \"�\", \"�\", \"�\", \"�\", \"�\", \"�\", \"�\", \"�\", \"�\"]</code></pre></li>\n</ul>\n<p>如何解决这种类型的问题呢？第一种方法是使用数组的扩展运算符：</p>\n<pre><code class=\"javascript\">const str = '😀😃😄😁😆😅';\nconsole.log([...str]);  // [\"😀\", \"😃\", \"😄\", \"😁\", \"😆\", \"😅\"]</code></pre>\n<p>第二种方法是使用设置了<code>u</code>标识符的正则表达式：</p>\n<pre><code class=\"javascript\">const str = '😀😃😄😁😆😅';\nconst separator = /(?=[\\s\\S])/u;\nconsole.log(str.split(separator)); // [\"😀\", \"😃\", \"😄\", \"😁\", \"😆\", \"😅\"]</code></pre>\n<li>\n <ul>\n  <li>如果传入的正则表达参数中含有捕获的括号，那么捕获的内容也会包含在返回的数组中：</li>\n </ul><pre><code class=\"javascript\">const str = 'abc1abc2abc3';\nconst separator = /(\\w)(?=\\d)/;\nconsole.log(str.split(separator));  // [\"ab\", \"c\", \"1ab\", \"c\", \"2ab\", \"c\", \"3\"]</code></pre>\n <ul>\n  <li><code>split</code>方法还可以传入第二个参数，用来控制返回的数组的长度：</li>\n </ul><pre><code class=\"javascript\">const str = 'hello, world!';\nconsole.log(str.split('', 3));  // [\"h\", \"e\", \"l\"]</code></pre></li>\n<ul>\n <li><strong>使用场景</strong>：</li>\n</ul>\n<p>在实际的开发中，最常用的场景就是将一个字符串转换为一个数组了：</p>\n<pre><code class=\"javascript\">const str = 'a/b/c/d/e';\nconsole.log(str.split('/')); // [\"a\", \"b\", \"c\", \"d\", \"e\"]</code></pre>\n<h2>总结</h2>\n<p>当我们能够把上面的这些方法都熟练的掌握之后，那么在实际的开发中再结合正则表达式来使用的话，那简直就是如虎添翼，能够在一些场景下提高我们开发的效率。</p>\n<p><strong>当然光靠看看文章是不能够很好地将这些知识点都记牢固的，你需要的是一个一个的实践一下，这样才能够加深自己的记忆，才能够记得更牢固</strong>。</p>\n<p>如果大家还想了解更多关于正则表达式的知识点的话，可以看看我之前写的一系列的文章：</p>\n<ul>\n <li><a href=\"https://mp.weixin.qq.com/s/cKOkAVcMThmgldI3gJzMbA\" rel=\"nofollow noreferrer\">正则表达式匹配素数的原理讲解</a></li>\n <li><a href=\"https://mp.weixin.qq.com/s/VqiZ6fVL20sJ8NUoQJjm2g\" rel=\"nofollow noreferrer\">距离弄懂正则的环视，你只差这一篇文章</a></li>\n <li><a href=\"https://mp.weixin.qq.com/s/AxTuXvKINhX6qLzj6Q9UJw\" rel=\"nofollow noreferrer\">正则表达式量词匹配方式的讲解（上篇）</a></li>\n <li><a href=\"https://mp.weixin.qq.com/s/ezul6Dg4f6_WLHXAkEgd6g\" rel=\"nofollow noreferrer\">想写出效率更高的正则表达式？试试固化分组和占有优先匹配吧</a></li>\n</ul>\n<p>如果你对本篇文章有什么意见和建议，都可以直接在文章下面留言，也可以在<a href=\"https://github.com/dreamapplehappy/blog/issues/12\" rel=\"nofollow noreferrer\">这里</a>提出来。也欢迎大家关注我的公众号<a href=\"https://image-static.segmentfault.com/822/336/822336066-322f46895b4b1d98\">关山不难越</a>，学习更多实用的前端知识，让我们一起努力进步吧。</p>","descriptionType":"html","publishedDate":"Mon, 24 Aug 2020 00:00:00 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLKdl","linkMd5":"2bab059fcc83687a9e4e5c0f8280a58a","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn21@2020_1/2020/08/24/23-08-23-024_2805d581158c2c2d.webp","destWidth":800,"destHeight":342,"sourceBytes":70114,"destBytes":27064,"author":"dreamapplehappy","articleImgCdnMap":{"https://segmentfault.com/img/bVbLKdl":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn21@2020_1/2020/08/24/23-08-23-024_2805d581158c2c2d.webp","https://segmentfault.com/img/bVbLKdp":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn24@2020_1/2020/08/24/23-08-39-802_6dcde18ff4f9579f.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"脏读、幻读和不可重复读","link":"https://segmentfault.com/a/1190000023689023","description":"<p><img src=\"https://segmentfault.com/img/bVbLyLa\" alt=\"\" title=\"\" /></p>\n<h2>一、引言</h2>\n<p>脏读、不可重复读和幻读是数据库中由于<strong>并发访问</strong>导致的数据读取问题。当多个事务同时进行时可以通过修改数据库事务的隔离级别来处理这三个问题。</p>\n<h2>二、问题解释</h2>\n<h3>1、脏读（读取未提交的数据）</h3>\n<p>脏读又称无效数据的读出，是指在数据库访问中，事务 A 对一个值做修改，事务 B 读取这个值，但是由于某种原因事务 A 回滚撤销了对这个值得修改，这就导致事务 B 读取到的值是无效数据。</p>\n<h3>2、不可重复读（前后数据多次读取，结果集内容不一致）</h3>\n<p>不可重复读即当事务 A 按照查询条件得到了一个结果集，这时事务 B 对事务 A 查询的结果集数据做了修改操作，之后事务 A 为了数据校验继续按照之前的查询条件得到的结果集<strong>与前一次查询不同</strong>，导致不可重复读取原始数据。</p>\n<h3>3、幻读（前后数据多次读取，结果集数量不一致）</h3>\n<p>幻读是指当事务 A 按照查询条件得到了一个结果集，这时事务 B 对事务 A 查询的结果集数据做新增操作，之后事务 A 继续按照之前的查询条件得到的结果集平白无故<strong>多了几条数据</strong>，好像出现了幻觉一样。</p>\n<h2>三、事务隔离</h2>\n<p>在并发条件下会出现上述问题，如何着手解决他们保证我们程序运行的正确性是非常重要的。数据库提供了 <strong>Read uncommitted 、Read committed 、Repeatable read 、Serializable</strong> 四种事务隔离级别来解决脏读、幻读和不可重复读问题，同时容易想到，可以通过加锁的方式实现事务隔离。</p>\n<p>在数据库的增删改查操作中，insert 、delete 、update 都会加排他锁，<strong>排它锁会阻止其他事务对其加锁的数据加任何类型的锁</strong>。而 select 只有显示声明才会加锁。</p>\n<ul>\n <li><p>Read uncommitted</p>\n  <blockquote>\n   读未提交，说的是一个事务可以读取到另一个事务未提交的数据修改。\n  </blockquote><p>读若不显式声明是不加锁的，可以直接读取到另一个事务对数据的操作，没有避免脏读、不可重复读、幻读。</p></li>\n <li><p>Read committed</p>\n  <blockquote>\n   读已提交，说的是一个事务只能读取到另一个事务已经提交的数据修改。\n  </blockquote><p>很明显，这种隔离级别避免了脏读，但是可能会出现不可重复读、幻读。</p></li>\n <li><p>Repeatable read</p>\n  <blockquote>\n   可重复读，保证了同一事务下多次读取相同的数据返回的结果集是一样的。\n  </blockquote><p>这种隔离级别解决了脏读和不可重复读问题，但是扔有可能出现幻读。</p></li>\n <li><p>Serializable</p>\n  <blockquote>\n   串行化，对同一数据的读写全加锁，即对同一数据的读写全是互斥了，数据可靠行很强，但是并发性能不忍直视。\n  </blockquote><p>这种隔离级别虽然解决了上述三个问题，但是牺牲了性能。</p></li>\n</ul>\n<p>总结如下表： <code>√ 代表可能出现，× 代表不会出现。</code></p>\n<table>\n <thead>\n  <tr>\n   <th align=\"left\">隔离级别</th>\n   <th align=\"left\">脏读</th>\n   <th align=\"left\">不可重复读</th>\n   <th align=\"left\">幻读</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td align=\"left\">Read uncommitted</td>\n   <td align=\"left\">√</td>\n   <td align=\"left\">√</td>\n   <td align=\"left\">√</td>\n  </tr>\n  <tr>\n   <td align=\"left\">Read committed</td>\n   <td align=\"left\">×</td>\n   <td align=\"left\">√</td>\n   <td align=\"left\">√</td>\n  </tr>\n  <tr>\n   <td align=\"left\">Repeatable read</td>\n   <td align=\"left\">×</td>\n   <td align=\"left\">×</td>\n   <td align=\"left\">√</td>\n  </tr>\n  <tr>\n   <td align=\"left\">Serializable</td>\n   <td align=\"left\">×</td>\n   <td align=\"left\">×</td>\n   <td align=\"left\">×</td>\n  </tr>\n </tbody>\n</table>\n<h2>四、MySQL 事务隔离级别的实现</h2>\n<p>在 MySQL 中只有 InnoDB 存储引擎支持事务，但是在日常使用 MySQL 时我们好像没有怎么关心过上述三个问题啊...</p>\n<p>原因很简单，MySQL 默认 <strong>Repeatable read</strong> 隔离级别，使用了 MVCC 技术，并且解决了幻读问题。</p>\n<h3>MVCC</h3>\n<hr>\n <p>MVCC 全名多版本并发控制，使用它可以保证 InnoDB 存储引擎下读操作的一致性。使用 MVCC 可以查询被另一个事务修改的行数据，并且可以查看这些行被更新之前的数据，值得注意的是<strong>使用 MVCC 增加了多事务的并发性能，但是并没有解决幻读问题</strong>。</p>\n <h4>1、原理</h4>\n <p>MVCC 是通过保存数据在某个时间点的快照来实现的。也就是说在同一个事务的生命周期中，数据的快照始终是相同的；而在多个事务中，由于事务的时间点很可能不相同，数据的快照也不尽相同。</p>\n <h4>2、实现细节</h4>\n <ul>\n  <li>每行数据都存在一个版本，每次数据更新时都更新该版本。</li>\n  <li>修改时Copy出当前版本随意修改，各个事务之间互不干扰。</li>\n  <li>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）。</li>\n </ul>\n <p>通过上面特点我们可以看出，MVCC 其实就是类似乐观锁的一种实现。</p>\n <h4>3、InnoDB 中 MVCC 实现</h4>\n <p>在 InnoDB 中为每行增加两个隐藏的字段，分别是该行数据<strong>创建时的版本号</strong>和<strong>删除时的版本号</strong>，这里的版本号是系统版本号（可以简单理解为事务的 ID），每开始一个新的事务，系统版本号就自动递增，作为事务的 ID 。通常这两个版本号分别叫做创建时间和删除时间。</p>\n <p>下面通过具体的例子来帮助理解 InnoDB 中 MVCC 实现，</p>\n <p>首先创建一个表：</p>\n <pre><code>create table info( \nid int primary key auto_increment, \nname varchar(20));</code></pre>\n <p>INSERT<br>InnoDB 为新插入的每一行保存当前系统版本号作为版本号。现在假设事务的版本号从 1 开始。</br></p>\n <p><strong>第一个事务</strong> ID为1；</p>\n <pre><code>start transaction;\ninsert into info values(NULL,'a');\ninsert into info values(NULL,'b');\ninsert into info values(NULL,'c');\ncommit;</code></pre>\n <p>对应在数据中的表如下(后面两列是隐藏列,也就是版本号)</p>\n <table>\n  <thead>\n   <tr>\n    <th>id</th>\n    <th>name</th>\n    <th>创建版本(事务ID)</th>\n    <th>删除版本(事务ID)</th>\n   </tr>\n  </thead>\n  <tbody>\n   <tr>\n    <td>1</td>\n    <td>a</td>\n    <td>1</td>\n    <td>undefined</td>\n   </tr>\n   <tr>\n    <td>2</td>\n    <td>b</td>\n    <td>1</td>\n    <td>undefined</td>\n   </tr>\n   <tr>\n    <td>3</td>\n    <td>c</td>\n    <td>1</td>\n    <td>undefined</td>\n    <td> </td>\n   </tr>\n  </tbody>\n </table>\n <blockquote>\n  SELECT\n </blockquote>\n <p>InnoDB 会根据下面两个条件检查每行记录:</p>\n <ul>\n  <li>只会查找版本<strong>早于当前事务版本的数据行</strong>（行的系统版本号小于或等于事务的系统版本号)，这样可以确保事务读取的行，要么是<strong>在事务开始前已经存在的</strong>，要么是<strong>事务自身插入或者修改过的</strong>。</li>\n  <li><strong>行的删除版本要么未定义</strong>,<strong>要么大于当前事务版本号</strong>,这可以确保事务读取到的行，在<strong>事务开始之前未被删除</strong>。</li>\n </ul>\n <p>只有 a, b 同时满足的记录，才能返回作为查询结果.</p>\n <hr>\n  <blockquote>\n   DELETE\n  </blockquote>\n  <p>InnoDB会为删除的每一行保存当前系统的版本号(事务的ID)作为删除标识.<br>看下面的具体例子分析:</br></p>\n  <p><strong>第二个事务</strong> ID为2;</p>\n  <pre><code>start transaction;\nselect * from info;  //(1)\nselect * from info;  //(2)\ncommit;</code></pre>\n  <ul>\n   <li>假设1<br>假设在执行这个事务 ID 为 2 的过程中，刚执行到 (1) ,这时,有另一个事务 ID 为 3 往这个表里插入了一条数据;</br></li>\n  </ul>\n  <p><strong>第三个事务</strong>ID为3;</p>\n  <pre><code>start transaction;\ninsert into info values(NULL,'d');\ncommit;</code></pre>\n  <p>这时表中的数据如下:</p>\n  <table>\n   <thead>\n    <tr>\n     <th>id</th>\n     <th>name</th>\n     <th>创建版本(事务ID)</th>\n     <th>删除版本(事务ID)</th>\n    </tr>\n   </thead>\n   <tbody>\n    <tr>\n     <td>1</td>\n     <td>a</td>\n     <td>1</td>\n     <td>undefined</td>\n    </tr>\n    <tr>\n     <td>2</td>\n     <td>b</td>\n     <td>1</td>\n     <td>undefined</td>\n    </tr>\n    <tr>\n     <td>3</td>\n     <td>c</td>\n     <td>1</td>\n     <td>undefined</td>\n    </tr>\n    <tr>\n     <td>4</td>\n     <td>d</td>\n     <td>3</td>\n     <td>undefined</td>\n    </tr>\n   </tbody>\n  </table>\n  <p>然后接着执行 <strong>事务2</strong> 中的 (2) ，由于 id=4 的数据的创建时间(事务 ID 为 3 ),执行当前事务的 ID 为 2 ，而 InnoDB 只会查找事务 ID 小于等于当前事务 ID 的数据行,所以 id=4 的数据行并不会在执行 <strong>事务2</strong> 中的 (2) 被检索出来,在 <em>*事务2</em> *中的两条 select 语句检索出来的数据都只会如下表:</p>\n  <table>\n   <thead>\n    <tr>\n     <th>id</th>\n     <th>name</th>\n     <th>创建版本(事务ID)</th>\n     <th>删除版本(事务ID)</th>\n    </tr>\n   </thead>\n   <tbody>\n    <tr>\n     <td>1</td>\n     <td>a</td>\n     <td>1</td>\n     <td>undefined</td>\n    </tr>\n    <tr>\n     <td>2</td>\n     <td>b</td>\n     <td>1</td>\n     <td>undefined</td>\n    </tr>\n    <tr>\n     <td>3</td>\n     <td>c</td>\n     <td>1</td>\n     <td>undefined</td>\n    </tr>\n   </tbody>\n  </table>\n  <ul>\n   <li>假设2<br>假设在执行这个事务 ID 为 2 的过程中，刚执行到 (1) ,假设事务执行完 <strong>事务3</strong> 后，接着又执行了 <strong>事务4</strong> ;</br></li>\n  </ul>\n  <p><strong>第四个事务</strong>:</p>\n  <pre><code>start   transaction;  \ndelete from info where id=1;\ncommit;</code></pre>\n  <p>此时数据库中的表数据如下:</p>\n  <table>\n   <thead>\n    <tr>\n     <th>id</th>\n     <th>name</th>\n     <th>创建版本(事务ID)</th>\n     <th>删除版本(事务ID)</th>\n    </tr>\n   </thead>\n   <tbody>\n    <tr>\n     <td>1</td>\n     <td>a</td>\n     <td>1</td>\n     <td>4</td>\n    </tr>\n    <tr>\n     <td>2</td>\n     <td>b</td>\n     <td>1</td>\n     <td>undefined</td>\n    </tr>\n    <tr>\n     <td>3</td>\n     <td>c</td>\n     <td>1</td>\n     <td>undefined</td>\n    </tr>\n    <tr>\n     <td>4</td>\n     <td>d</td>\n     <td>3</td>\n     <td>undefined</td>\n    </tr>\n   </tbody>\n  </table>\n  <p>接着执行事务 ID 为 2 的 <strong>事务(2)</strong>，根据 SELECT 检索条件可以知道,它会检索创建时间(创建事务的 ID )小于当前事务 ID 的行和删除时间(删除事务的 ID )大于当前事务的行,而 id=4 的行上面已经说过，而 id=1 的行由于删除时间(删除事务的 ID )大于当前事务的 ID ，所以 <strong>事务2</strong> 的 (2) select * from info 也会把 id=1 的数据检索出来。所以，<strong>事务2</strong> 中的两条 select 语句检索出来的数据都如下:</p>\n  <table>\n   <thead>\n    <tr>\n     <th>id</th>\n     <th>name</th>\n     <th>创建版本(事务ID)</th>\n     <th>删除版本(事务ID)</th>\n    </tr>\n   </thead>\n   <tbody>\n    <tr>\n     <td>1</td>\n     <td>a</td>\n     <td>1</td>\n     <td>4</td>\n    </tr>\n    <tr>\n     <td>2</td>\n     <td>b</td>\n     <td>1</td>\n     <td>undefined</td>\n    </tr>\n    <tr>\n     <td>3</td>\n     <td>c</td>\n     <td>1</td>\n     <td>undefined</td>\n    </tr>\n   </tbody>\n  </table>\n  <hr>\n   <blockquote>\n    UPDATE\n   </blockquote>\n   <p>InnoDB 执行 UPDATE，实际上是<strong>新插入了一行记录</strong>，并保存其创建时间为当前事务的 ID ，同时保存当前事务 ID 到要 UPDATE 的行的删除时间。</p>\n   <ul>\n    <li>假设3<br>假设在执行完 <strong>事务2</strong> 的 (1) 后又执行，其它用户执行了事务 3和 4，这时，又有一个用户对这张表执行了 UPDATE 操作:</br></li>\n   </ul>\n   <p><strong>第五个事务</strong>:</p>\n   <pre><code>start  transaction;\nupdate info set name='b' where id=2;\ncommit;</code></pre>\n   <p>根据update的更新原则：会生成新的一行，并在原来要修改的列的删除时间列上添加本事务ID，得到表如下:</p>\n   <table>\n    <thead>\n     <tr>\n      <th>id</th>\n      <th>name</th>\n      <th>创建版本(事务ID)</th>\n      <th>删除版本(事务ID)</th>\n     </tr>\n    </thead>\n    <tbody>\n     <tr>\n      <td>1</td>\n      <td>a</td>\n      <td>1</td>\n      <td>4</td>\n     </tr>\n     <tr>\n      <td>2</td>\n      <td>b</td>\n      <td>1</td>\n      <td>5</td>\n     </tr>\n     <tr>\n      <td>3</td>\n      <td>c</td>\n      <td>1</td>\n      <td>undefined</td>\n     </tr>\n     <tr>\n      <td>4</td>\n      <td>d</td>\n      <td>3</td>\n      <td>undefined</td>\n     </tr>\n     <tr>\n      <td>2</td>\n      <td>b</td>\n      <td>5</td>\n      <td>undefined</td>\n     </tr>\n    </tbody>\n   </table>\n   <p>继续执行 <strong>事务2</strong> 的 (2) ，根据 select 语句的检索条件，得到下表:</p>\n   <table>\n    <thead>\n     <tr>\n      <th>id</th>\n      <th>name</th>\n      <th>创建版本(事务ID)</th>\n      <th>删除版本(事务ID)</th>\n     </tr>\n    </thead>\n    <tbody>\n     <tr>\n      <td>1</td>\n      <td>a</td>\n      <td>1</td>\n      <td>4</td>\n     </tr>\n     <tr>\n      <td>2</td>\n      <td>b</td>\n      <td>1</td>\n      <td>5</td>\n     </tr>\n     <tr>\n      <td>3</td>\n      <td>c</td>\n      <td>1</td>\n      <td>undefined</td>\n     </tr>\n    </tbody>\n   </table>\n   <p>还是和 <strong>事务2</strong> 中 (1) select 得到相同的结果。</p>\n   <p>❀ 总结：</p>\n   <blockquote>\n    <ul>\n     <li>SELECT<br>读取创建版本号小于或等于当前事务版本号，并且删除版本号为空或大于当前事务版本号的记录。如此可以保证在事务在读取之前记录是存在的。</br></li>\n     <li>INSERT<br>将当前事务的版本号保存至插入行的创建版本号。</br></li>\n     <li>UPDATE<br>新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号。</br></li>\n     <li>DELETE<br>将当前事务的版本号保存至行的删除版本号。</br></li>\n    </ul>\n   </blockquote>\n   <p>例子参考：<a href=\"https://blog.csdn.net/whoamiyang/article/details/51901888\" rel=\"nofollow noreferrer\">https://blog.csdn.net/whoamiy...</a></p>\n   <hr>\n    <h4>4、 InnoDB 如何解决幻读问题</h4>\n    <p>在 InnoDB 中分为<strong>快照读</strong>和<strong>当前读</strong>。快照读读的是数据的快照，也就是数据的历史版本；当前读就是读的最新版本的数据，并且在读的时候加锁，其他事务都不能对当前行做修改。</p>\n    <blockquote>\n     <ul>\n      <li>快照读：简单的 select 操作，属于快照读，不加锁。<br>select * from table where ?;</br></li>\n      <li>当前读：特殊的读操作，插入、更新、删除操作，属于当前读，需要加锁。<br>select * from table where ? lock in share mode;<br>select * from table where ? for update;<br>insert into table values (…);<br>update table set ? where ?;<br>delete from table where ?;</br></br></br></br></br></li>\n     </ul>\n    </blockquote>\n    <p>对于上面当前读的语句，第一条读取记录加共享锁，其他的全部加排它锁。</p>\n    <p>也就是说在做数据的修改操作时，都会使用当前读的方式，当前读是通过行锁和间隙锁控制的，此时是加了排他锁的，所有其他的事务都不能动当前的事务，所以避免了出现幻读的可能。</p>\n    <p>而为了防止幻读，行锁和间隙锁扮演了重要角色，下面简单说一下：</p>\n    <ul>\n     <li>行锁<br>字面意思简单理解对数据行加锁，注意 InnoDB 行锁是通过给索引上的索引项加锁来实现的，也就是说<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></br></li>\n     <li>间隙锁<br>间隙锁就是用来为数据行之间的间隙来进行加锁。</br></li>\n    </ul>\n    <p>举个例子：</p>\n    <pre><code>select * from info where id &gt; 5;</code></pre>\n    <p>上面 SQL 中，其中 id 是主键，假设在一个 <strong>事务 A</strong> 中执行这个查询，第一次查询为一个 <strong>结果集 1</strong> 。在做第二次查询时，另一个 <strong>事务 B</strong> 在 info 表进行了插入数据 7 和 10 的操作。在 <strong>事务 A</strong> 再次执行此查询查询出 <strong>结果集 2</strong> 的时候，发现多了几条记录，如此便产生了幻读。</p>\n    <ul>\n     <li>结果集1</li>\n    </ul>\n    <pre><code>6,8,9</code></pre>\n    <ul>\n     <li>结果集2</li>\n    </ul>\n    <pre><code>6,7,8,9,10</code></pre>\n    <p>所以试想为了防止幻读，我们不但要现存的 id &gt; 5 的数据行（6,8,9）上面加锁（行锁），还要在它们的间隙加锁（间隙锁）。</p>\n    <p>我们以区间来表示要加锁对象：</p>\n    <p>(5,6]<br>(6,8]<br>(8,9]<br>(9,+∞)</br></br></br></p>\n    <p>其中区间的右闭即为要加的行锁，而区间的范围即是要加的间隙锁。</p>\n    <h2>五、结语</h2>\n    <p>关于脏读、不可重复读和幻读的理解便记录到这里了，因笔者水平有限，如有错误欢迎指正。</p>\n    <blockquote>\n     欢迎访问\n     <a href=\"https://aysaml.com\" rel=\"nofollow noreferrer\">个人博客</a> 获取更多知识分享。\n    </blockquote>\n   </hr>\n  </hr>\n </hr>\n</hr>","descriptionType":"html","publishedDate":"Wed, 19 Aug 2020 09:15:20 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLyLa","linkMd5":"5a738e1afa2c3c1a2044a79c194873cd","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn66@2020_4/2020/08/24/23-08-23-072_538d4e9f5497d55e.webp","destWidth":800,"destHeight":450,"sourceBytes":100901,"destBytes":51728,"author":"AYSAML","articleImgCdnMap":{"https://segmentfault.com/img/bVbLyLa":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn66@2020_4/2020/08/24/23-08-23-072_538d4e9f5497d55e.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"好孩子的编码习惯","link":"https://segmentfault.com/a/1190000023660020","description":"<h2>前言</h2>\n<p>我经常能听到一些对话<br>狗腿子A:哇 我刚刚去改**项目的代码，看的我有点怀疑人生<br>狗腿子B: 我现在项目的跟屎山一样<br>狗腿子C: 我隔壁那哥们每天写代码都特别随性，我有点按耐不住我的刀<br>.....<br><img src=\"https://segmentfault.com/img/bVbLqMU\" alt=\"image.png\" title=\"image.png\"><br>今天跟大家聊聊一些 <strong>我眼中</strong> 好孩子的编码习惯，而不是代码风格习惯 ，当然还是强烈建议大家代码风格跟<code>psr-12</code>和<code>psr-1</code>靠齐。</br></img></br></br></br></br></br></p>\n<blockquote>\n <code>psr-1</code>基础编码规范 、\n <code>psr-12</code>编码规范托充\n <br>This specification extends, expands and replaces <a href=\"https://www.php-fig.org/psr/psr-2/\" rel=\"nofollow noreferrer\">PSR-2</a>, the coding style guide and requires adherence to <a href=\"https://www.php-fig.org/psr/psr-1/\" rel=\"nofollow noreferrer\">PSR-1</a>, the basic coding standard.</br>\n</blockquote>\n<p><img src=\"https://segmentfault.com/img/bVbLnDZ\" alt=\"离职流程.png\" title=\"离职流程.png\" /></p>\n<blockquote>\n 推荐一本《代码整洁之道》，这本书我已经书都快翻烂了，墙裂推荐！！！\n</blockquote>\n<p><img src=\"https://segmentfault.com/img/bVbLnZN\" alt=\"image.png\" title=\"image.png\" /></p>\n<h2>不过度的if嵌套判断</h2>\n<p><strong>案例背景</strong><br>有个函数需要判断用户是否参与活动<br><img src=\"https://segmentfault.com/img/bVbLnGW\" alt=\"流程图1.png\" title=\"流程图1.png\" /></br></br></p>\n<p><strong>案例代码</strong></p>\n<pre><code>    if (用户 == VIP) {\n        if (用户的过期时间 &lt;= 1个月内) {\n            if (用户没参加过任务) {\n                return true;\n            }\n        } else {\n            return false;\n        }\n    } else {\n        return true\n    }\n    </code></pre>\n<p>面对这种多条件的判断可以试着用<code>拦截法</code>和<code>逆向思维</code><br><code>拦截法</code>只要符合条件立马返回结果，不再嵌套的if。可以理解成横向判断变成纵向判断。</br></p>\n<p><strong>舒适感</strong><br>从上往下看 &gt; 从左往右看</br></p>\n<p><code>逆向思维</code> 大家上学的时候都了解过，与其漫天去找符合的条件还不如找不符合条件，这样的逻辑代码可以少很多。</p>\n<pre><code>    if (用户 != VIP) {\n        return true;\n    } \n    \n    if (用户参加过任务) {\n        return false;\n    }\n    \n    if (用户的过期时间 &lt;= 1个月内) {\n        return true;    \n    }\n    \n    return false;\n    </code></pre>\n<h2>不过度的try-catch嵌套</h2>\n<p>我遇到过很多项目都过度嵌套<code>try-catch</code>导致最上层的<code>try-catch</code> <strong>catch</strong>了寂寞。<br><img src=\"https://segmentfault.com/img/bVbLnYJ\" alt=\"image.png\" title=\"image.png\" /></br></p>\n<p><strong>案例代码</strong></p>\n<pre><code>function insertUser($data)\n{\n    try {\n        userIsInValid();\n    } catch (Exception $exception) {\n    }\n}\n\nfunction userIsInValid()\n{\n    try {\n        //逻辑判断\n    } catch (Exception $exception) {\n        return true;\n    }\n    return true;\n    \n}</code></pre>\n<p>这样的代码没有问题，但是如果假设<code>userIsInValid</code>真的发生代码级的错误没法知道那里出问题，虽然不会破坏业务的健壮性。<br>可能有人说了在Excetion加个日志，但是如果嵌套的try-catch多了，排查日志也是一件很痛苦的事情。</br></p>\n<p>1.尽可能业务最上层包裹异常 除非网络IO请求函数。<br>2.如果非要异常嵌套 需要定义每个异常的类型。<br>3.尽可能根据特定的异常进行catch 不建议直接catch Exception。<br>4.异常和日志是个<code>cp</code>，还是不要忘记了。<br><img src=\"https://segmentfault.com/img/bVbLqQQ\" alt=\"image.png\" title=\"image.png\" /></br></br></br></br></p>\n<pre><code>&lt;?php\n\nfunction insertUser($data)\n{\n    try {\n        userIsInValid();\n    } catch (Exception $exception) {\n        // 日志\n        // 业务处理\n    } catch (HttpException $httpException) {\n       // 日志\n       // 业务处理\n    }\n}\n\nfunction userIsInValid()\n{\n    //\n    return true;\n}</code></pre>\n<h2>不要用if-else做错误类型判断</h2>\n<p><strong>案例代码</strong> (来源某个网民前段时间咨询)</p>\n<pre><code>&lt;?php\n\n.....\nif ($code === 'NOTENOUGH') {\n    packApiData(400014, 'Company have no enough money to pay', [], '企业余额不足');\n} elseif ($code === 'AMOUNT_LIMIT') {\n    packApiData(400015, 'Amount limit', [], '金额超限或被微信风控拦截');\n} elseif ($code === 'OPENID_ERROR') {\n    packApiData(400016, 'Appid and Openid does not match', [], 'Openid格式错误或不属于此公众号');\n} elseif ($code === 'SEND_FAILED') {\n    // 付款错误,要查单来看最终结果\n    if ($orderInfo[1]['status'] == 'SUCCESS') {\n        // 还是成功给了，扣回余额\n        \n        packApiData(200, 'success', [$orderInfo[1]]);\n    } else {\n        packApiData(400017, 'Weixin pay failed', [], '微信支付付款失败');\n    }\n} elseif ($code === 'SYSTEMERROR') {\n    packApiData(400018, 'Weixin pay server error', [], '微信支付服务器错误');\n} elseif ($code === 'NAME_MISMATCH') {\n    packApiData(400019, 'Real name mismatch', [], '微信用户的真名校验失败');\n} elseif ($code === 'FREQ_LIMIT') {\n    packApiData(400020, 'Api request frequently', [], '微信支付接口调用过于频繁，请稍候再请求');\n} elseif ($code === 'MONEY_LIMIT') {\n    packApiData(400021, 'Company have reached total payment limit', [], '已经达到今日付款总额上限');\n} elseif ($code === 'V2_ACCOUNT_SIMPLE_BAN') {\n    packApiData(400022, 'This payment account has no real name', [], '用户的微信支付账户未实名');\n} elseif ($code === 'SENDNUM_LIMIT') {\n    packApiData(400023, 'The number of times the user paid today exceeded the limit', [], '该用户今日收款次数超过限制');\n}</code></pre>\n<p>这样的代码可能写起来特别舒服，但是后期进行业务的增加改写和时间的沉淀，容易变成让人害怕的屎山代码。</p>\n<p><img src=\"https://segmentfault.com/img/bVbLqNT\" alt=\"image.png\" title=\"image.png\" /></p>\n<p>我们用mapping错误码来调整下</p>\n<pre><code>function packApiDataByOrderError($code)\n{\n    $errorCodeMappins = [\n        \"NOTENOUGH\" =&gt; [\n            \"code\" =&gt; 400014,\n            \"wx_message\" =&gt; \"Company have no enough money to pay\",\n            \"error_message\" =&gt; \"企业余额不足\"\n        ],\n\n        \"AMOUNT_LIMIT\" =&gt; [\n            \"code\" =&gt; 400015,\n            \"wx_message\" =&gt; \"Amount limit\",\n            \"error_message\" =&gt; \"金额超限或被微信风控拦截\"\n        ],\n\n        .....\n    ];\n\n    if (array_key_exists($code, $errorCodeMappins)) {\n        packApiData(\n            $errorCodeMappins[$code]['code'],\n            $errorCodeMappins[$code]['wx_message'],\n            [],\n            $errorCodeMappins[$code]['error_message']\n        );\n    }\n\n    packApiData(\n        999999,\n        \"undefined message\",\n        [],\n        \"未知错误\"\n    );\n}</code></pre>\n<p>建议<code>errorCodeMappins</code>不要放在函数内，可以放在类顶部或者专门枚举类。<br>通过errorCode 可以避免调整主流程代码，能够保证主流程的代码比较精简也能对不同的code进行错误的定义</br></p>\n<pre><code>if ($code == \"SEND_FAILED\") {\n    // 付款错误,要查单来看最终结果\n    if ($orderInfo[1]['status'] == 'SUCCESS') {\n        // 还是成功给了，扣回余额\n        PDOQuery($dbcon, 'UPDATE user SET money=money-? WHERE open_id=?', [$payAmount, $openId], [PDO::PARAM_INT, PDO::PARAM_STR]);\n        packApiData(200, 'success', [$orderInfo[1]]);\n    } else {\n        packApiData(400017, 'Weixin pay failed', [], '微信支付付款失败');\n    }\n}\n\npackApiDataByOrderError($code);</code></pre>\n<h2>在合适的场景使用设计模式</h2>\n<p>上述可能只能针对错误码进行改造，如果万一我们需要不同的错误进行逻辑处理还怎么办。这时候可以考虑用设计模式 (比如用以多态取代条件表达式)</p>\n<blockquote>\n <code>设计模式</code>固好但不要过度使用，不然整个项目更难维护，你要坚信未来的你队友不知道是什么样的生物\n</blockquote>\n<p><img src=\"https://segmentfault.com/img/bVbLqT9\" alt=\"image.png\" title=\"image.png\" /></p>\n<pre><code>$callbackCodeMappings = [\n    \"SEND_FAILED\" =&gt; OrderSendFailed::class,\n];\n\nif (array_key_exists($code, $callbackCodeMappings)) {\n    $class = new $callbackCodeMappings[$code];\n    $class-&gt;handle();\n}\n\n\ninterface OrderStateImp\n{\n    public function handle($context);\n}\n\nclass OrderSendFailed implements  OrderStateImp\n{\n    public function handle($context)\n    {\n\n    }\n}</code></pre>\n<p><code>$callbackCodeMappings</code>同样建议配置专门枚举文件内。<br>给出得代码比较粗糙，其实可以更加健壮性的做一些判断</br></p>\n<h2>统一处理浮点运算结果</h2>\n<p>由于php是弱对象语言，所以面对一堆情况总能出现，这个订单数据怎么不对了，接口有问题。</p>\n<pre><code>$int = 0.58; var_dump(intval($int * 100));\noutput:57</code></pre>\n<p>在浮点数里面 58是被视为57.999999999999999999999……9999无限接近58 <br>再intval强制转换乘整型的时候就默认采用截取法取整</br></p>\n<p>所以最好养成一个好习惯每次在计算浮点数的时候用<br> <a href=\"https://www.php.net/bcMath\" rel=\"nofollow noreferrer\">BC Math</a></br></p>\n<pre><code>$int = 0.58;\nintval(strval($int * 100))</code></pre>\n<p>或者使用BC MATH</p>\n<pre><code>bcmul(0.58, 100, 0);</code></pre>\n<p><img src=\"https://segmentfault.com/img/bVbLuVG\" alt=\"image.png\" title=\"image.png\" /></p>\n<h2>鼓励用全局错误码来控制错误</h2>\n<p>写接口的我们对以下的json格式特别熟悉</p>\n<pre><code>{\n    \"success\": true,\n    \"error_code\": 0,\n    \"message\": \"\",\n    \"results\": []\n}</code></pre>\n<p>对以下的代码也已经熟悉</p>\n<pre><code>if (***) {\n    $this-&gt;error(999,\"****\", []);\n}</code></pre>\n<p>这样的结果的错误码容易重复没有统一管理，事实上唯一错误码应该有以下帮助。<br>1.前端可以根据错误码做逻辑处理<br>2.根据错误码能直接快速定位到错误代码</br></br></p>\n<p>建议</p>\n<pre><code>&lt;?php\n\nnamespace App\\ErrorCode;\n\nclass UserErrorCode\n{\n    const USER_DISABLE_ERROR = [\n        \"error_code\" =&gt; 1050001,\n        \"message\" =&gt; \"用户已被停用\"\n    ];\n}\n\n$this-&gt;error(UserErrorCode::USER_DISABLE_ERROR);</code></pre>\n<p>错误码建议</p>\n<p>1-2位 - 项目码 | 3-4位 - 模块码 | 5-7位具体业务错误码</p>\n<h2>可靠的命名规范</h2>\n<p>不可靠的命名总会让人误导。<br>比如变量命名为userArrayList 我以为是个数组列表变量,事实上这个特么是个对象列表。</br></p>\n<p>1.做有意义的区分<br>比如 <code>singleUserItem</code>跟<code>userItem</code>有啥区别 <br>比如 <code>getUserList</code>跟<code>getUsers</code>有啥区别<br><img src=\"https://segmentfault.com/img/bVbLnYZ\" alt=\"image.png\" title=\"image.png\" /></br></br></br></p>\n<p>2.可以通过<code>搜索翻译</code>能知道的变量含义 <br>不要把变量贴入<code>搜索翻译</code>会出现七七八八的东西<br>3.如果真的不知道该怎么翻试试用拼音把别硬凹了<br>比如之前做<code>百度</code>的一个接口对接<br>变量命名为<code>hundredDegree</code>而不是<code>baidu</code><br><img src=\"https://segmentfault.com/img/bVbLq6p\" alt=\"image.png\" title=\"image.png\"><br>其他的可以参照《代码简洁之道》</br></img></br></br></br></br></br></p>\n<h2>擅用middleware</h2>\n<p>middleware可以理解成观察者模式，我们开发的接口总会遇到很多同样操作，比如<br>1.身份检测<br>2.权限判断<br>3.请求参数filter调整<br>4.记录接口信息<br>5.接口限流<br>我见过挨个接口去实现、也见过初始化一个ControllerBase的类，实现这些，子类的Controller去继承这些。<br>其实我们可以抽离成middleware去实现<br><img src=\"https://segmentfault.com/img/bVbLuyc\" alt=\"image.png\" title=\"image.png\" /></br></br></br></br></br></br></br></br></p>\n<p>好处可以根据不同接口对middleware进行组合选择，而不是对代码进行各特殊化处理.</p>\n<h2>函数的单一职责</h2>\n<p>最最最最后也是最重要的，代码的恶心大多数来源于函数的职责不清晰，有全都塞在一起的、东一块西一块的。<br>其实关于单一职责有很多文章在描述，如何去检验或者去写符合标准的单一职责。<br><strong><em>画流程图</em></strong><br>如果你能把业务的流程图画的特别清晰，那么你的函数的职责也就定下来了。<br><img src=\"https://segmentfault.com/img/bVbLrbr\" alt=\"image.png\" title=\"image.png\" /></br></br></br></br></p>\n<pre><code>&lt;?php\n\n// 兑换逻辑\nfunction doExchange()\n{\n    if (checkIsLock()) {\n        \n    }\n    lock();\n    if (!checkUserIsExchange()) {\n        \n    }\n    costUserPoint();\n    exchangeGoods();\n}\n// 判断是否悲观锁\nfunction checkIsLock(){}\n// 上悲观锁\nfunction lock(){}\n// 判断用户是否可以兑换\nfunction checkUserIsExchange(){}\n// 扣除积分\nfunction costUserPoint(){}\n// 兑换商品\nfunction exchangeGoods(){}</code></pre>\n<h2>最后</h2>\n<p>上述为<code>洪光光</code>心中的好孩子的习惯，也有可能是你眼中坏孩子的习惯。如果你认为是坏孩子的习惯或者认为还有其他好孩子的习惯欢迎评论<del>撕逼</del>讨论。<br>毕竟<br><img src=\"https://segmentfault.com/img/bVbLrdc\" alt=\"image.png\" title=\"image.png\" /></br></br></p>\n<p>留个彩蛋 看看大家怎么实现 <br>写一个函数<code>returnScoreResult</code>,请根据输入的分数，返回对应的成绩的等级。<br>1.如果分数小于0或者大于100 返回 【无效分数】<br>2.如果分数&gt;=0，&lt;60 返回 【不及格】<br>3.如果分数&gt;=60，&lt;70 返回【及格】<br>4.如果分数&gt;=70，&lt;80 返回 【一般】<br>5.如果分数&gt;=80， &lt;90 返回 【良好】<br>5.如果分数&gt;=90， &lt;100 返回 【优秀】<br>6.如果分数=100 返回【满分】</br></br></br></br></br></br></br></br></p>","descriptionType":"html","publishedDate":"Mon, 17 Aug 2020 09:01:13 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLqMU","linkMd5":"6a526c91c6f56ccea5eb637c9da38dee","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn65@2020_5/2020/08/24/23-08-22-735_cebd68292a8c6202.webp","destWidth":300,"destHeight":300,"sourceBytes":20447,"destBytes":5946,"author":"风中有php做的云","articleImgCdnMap":{"https://segmentfault.com/img/bVbLqMU":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn65@2020_5/2020/08/24/23-08-22-735_cebd68292a8c6202.webp","https://segmentfault.com/img/bVbLnDZ":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn44@2020_6/2020/08/24/23-08-39-925_15e73f90245f980f.webp","https://segmentfault.com/img/bVbLnZN":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn10@2020_1/2020/08/24/23-08-42-916_d4723e98ac161e6d.webp","https://segmentfault.com/img/bVbLnGW":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn8@2020_5/2020/08/24/23-08-39-315_adc2628a7dd7bf8a.webp","https://segmentfault.com/img/bVbLnYJ":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn2@2020_2/2020/08/24/23-08-43-211_4c945cb1f7458133.webp","https://segmentfault.com/img/bVbLqQQ":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn42@2020_3/2020/08/24/23-08-28-490_cccdf6bf3e166584.webp","https://segmentfault.com/img/bVbLqNT":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn58@2020_5/2020/08/24/23-08-32-542_96997f4a7107446a.webp","https://segmentfault.com/img/bVbLqT9":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn58@2020_3/2020/08/24/23-08-28-734_c26934c85deabe10.webp","https://segmentfault.com/img/bVbLuVG":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn18@2020_2/2020/08/24/23-08-28-788_0f370e0b14289a17.webp","https://segmentfault.com/img/bVbLnYZ":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn5@2020_3/2020/08/24/23-08-43-205_580793b106d90c39.webp","https://segmentfault.com/img/bVbLq6p":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn20@2020_5/2020/08/24/23-08-45-396_546149266b4954c9.webp","https://segmentfault.com/img/bVbLuyc":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn32@2020_1/2020/08/24/23-08-39-566_da9fdf1e5cbe5397.webp","https://segmentfault.com/img/bVbLrbr":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn14@2020_6/2020/08/24/23-08-44-242_8fce31e013f973d0.webp","https://segmentfault.com/img/bVbLrdc":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn70@2020_5/2020/08/24/23-08-43-038_f7428127a3a50bf0.webp"},"publishedOrCreatedDate":1598310388564},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"Bash技巧：把变量赋值为换行符，判断文件是否以换行符结尾","link":"https://segmentfault.com/a/1190000023553682","description":"<h2>把变量赋值为换行符</h2>\n<p>在 bash 中，如果要把变量赋值为换行符，写为 <code>'\\n'</code> 没有效果，需要写为 <code>$'\\n'</code>。具体举例如下：</p>\n<pre><code class=\"bash\">$ newline='\\n'\n$ echo $newline\n\\n\n$ newline=$'\\n'\n$ echo $newline\n</code></pre>\n<p>可以看到，把 <em>newline</em> 变量赋值为 'n'，得到的是 <em>n</em> 这个字符串，而不是换行符自身。</p>\n<p>这是 bash 和 C 语言不一样的地方。 <br>在 C 语言中，'n' 对应换行符自身，只有一个字符；而 \"n\" 对应一个字符串。 <br>但是在 bash 中，'n' 也是对应一个字符串。</br></br></p>\n<p>把 <em>newline</em> 赋值为 <code>$'\\n'</code>，就能获取到换行符自身。查看 man bash 对这个写法的说明如下：</p>\n<blockquote>\n Words of the form $'string' are treated specially. The word expands to string, with backslash-escaped characters replaced as specified by the ANSI C standard. Backslash escape sequences, if present, are decoded as follows:\n</blockquote>\n<pre><code>    \\n     new line\n    \\r     carriage return\n    \\t     horizontal tab\n    \\'     single quote</code></pre>\n<blockquote>\n The expanded result is single-quoted, as if the dollar sign had not been present.\n</blockquote>\n<p>即，<code>$'string'</code> 这个写法可以使用 C 语言的转义字符来获取到对应的字符自身。</p>\n<h2>判断文件的最后一行是否以换行符结尾</h2>\n<p>在 Linux 中，可以使用下面命令来判断文件的最后一行是否以换行符结尾：</p>\n<pre><code class=\"bash\">test -n \"$(tail filename -c 1)\"</code></pre>\n<p>这里使用 <code>tail filename -c 1</code> 命令获取到 <em>filename</em> 文件的最后一个字符。</p>\n<p>实际使用时，需要把 <em>filename</em> 换成具体要判断的文件名。</p>\n<p><code>tail</code> 命令可以获取文件末尾的内容。它的 <code>-c</code> 选项指定要获取文件末尾的多少个字节。</p>\n<p>查看 man tail 对 <code>-c</code> 选项的说明如下：</p>\n<blockquote>\n <strong>-c, --bytes=K</strong>\n <p>output the last K bytes; alternatively, use -c +K to output bytes starting with the Kth of each file.</p>\n</blockquote>\n<p>即，<code>tail -c 1</code> 命令指定获取所给文件的最后一个字符。</p>\n<p>获取到文件的最后一个字符后，要判断该字符是不是换行符。这里不能直接判断该字符是否等于换行符，而是要判断该字符是否为空。</p>\n<p>原因在于，使用 <code>$(tail filename -c 1)</code> 命令替换来获取内部命令的输出结果时，bash 会去掉末尾的换行符。</p>\n<p>所以当文件的最后一行以换行符结尾时，<code>$(tail filename -c 1)</code> 命令替换会去掉获取到的换行符，最终结果为空，并不会返回换行符自身。</p>\n<p>查看 man bash 对命令替换（command substitution）的说明如下：</p>\n<blockquote>\n Command substitution allows the output of a command to replace the command name. There are two forms:\n</blockquote>\n<pre><code>        $(command)\n    or\n        `command`</code></pre>\n<blockquote>\n Bash performs the expansion by executing command and replacing the command substitution with the standard output of the command, with any trailing newlines deleted. Embedded newlines are not deleted, but they may be removed during word splitting.\n</blockquote>\n<p>可以看到，经过命令替换后，会去掉末尾的换行符。</p>\n<p>由于 <code>$(tail filename -c 1)</code> 命令替换会去掉末尾的换行符，这里使用 <code>test -n</code> 来判断最终结果是否为空字符串。</p>\n<p>如果文件最后一行以换行符结尾，那么 <code>$(tail filename -c 1)</code> 的结果为空，<code>test -n</code> 命令会返回 1，也就是 false。</p>\n<p>如果文件最后一行没有以换行符结尾，那么 <code>$(tail filename -c 1)</code> 的结果不为空，<code>test -n</code> 命令会返回 0，也就是 true。</p>\n<p>可以根据实际需要，改用 <code>test -z</code> 来判断。如果文件最后一行以换行符结尾，<code>$(tail filename -c 1)</code> 的结果为空，<code>test -z</code> 命令会返回 0，也就是 true。</p>","descriptionType":"html","publishedDate":"Mon, 17 Aug 2020 04:00:00 +0000","feedId":6615,"bgimg":"","linkMd5":"d04e541e8e5edb37890557d2eb089a57","bgimgJsdelivr":"","metaImg":"","author":"霜鱼片","publishedOrCreatedDate":1598310388564},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"图解两数之和：双指针法","link":"https://segmentfault.com/a/1190000023552474","description":"<p><img src=\"https://segmentfault.com/img/bVbKYWU\" alt=\"image\" title=\"image\" /></p>\n<p>两数之和是一道非常经典，也非常高频的面试题，题目大意如下：</p>\n<blockquote>\n 给定一个整数数组\n <code>nums</code>&nbsp;和一个目标值\n <code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\n <br>case:<br>给定 <code>nums = [2, 1, 7, 11, 15], target = 9</code><br>因为 <code>nums[0] + nums[2] = 2 + 7 = 9</code><br>所以返回 <code>[0, 2]</code></br></br></br></br>\n</blockquote>\n<p>之前我们探讨了这个问题的暴力运算法和哈希表法，今天我们使用双指针法来解决它。</p>\n<h2>太长不看版</h2>\n<ul>\n <li>首先排序数组；</li>\n <li>使用<code>left</code>，<code>right</code>两个指针；</li>\n <li>比较<code>target</code>与<code>left</code>值加<code>right</code>值的和，移动对应的指针；</li>\n <li>双指针解法的时间复杂度取决于对应的排序算法，空间复杂度为O(n)。</li>\n</ul>\n<h2>什么是双指针？</h2>\n<p>双指针和快速排序、冒泡排序等具体算法不同。它更接近于一种思（tào）路，一种使用两个指针互相配合来存储节点以便于运算的技巧。</p>\n<p>双指针法适用于数组、链表等线性数据结构，常用的思路有：碰撞指针、滑动窗口、快慢指针等。</p>\n<p>在两数之和这个case中我们使用<strong>碰撞指针</strong>的方式来实现，其它两种套路会在后续文章中介绍。</p>\n<h3>0.排序</h3>\n<p>所谓碰撞指针，是指在有序数组中定义<code>left</code>（数组起始位置）、<code>right</code>（数组终止位置）两个指针，在遍历时根据对应条件的不同来判断应该移动哪个指针，进而从数组两端遍历数组。</p>\n<p>所以在两数之和中我们需要先将目标数组进行排序：</p>\n<hr>\n <p><img src=\"https://segmentfault.com/img/bVbKY8w\" alt=\"image\" title=\"image\" /></p>\n <hr>\n  <p>排序算法的时间复杂度决定了整个计算的时间复杂度。因为双指针遍历的复杂度是O(n)。</p>\n  <h3>1.创建双指针</h3>\n  <p>在排好序的数组（以下简称数组）两端分别创建<code>left</code>、<code>right</code>指针：</p>\n  <hr>\n   <p><img src=\"https://segmentfault.com/img/bVbKY8B\" alt=\"image\" title=\"image\" /></p>\n   <hr>\n    <h3>2.左移右指针</h3>\n    <p>此时<code>left</code>值与<code>right</code>值之和（以下简称<code>sum</code>）大于<code>target</code>，此时应该将<code>right</code>左移一位，减小<code>sum</code>使其更接近<code>target</code>。</p>\n    <p>从这里就可以看出，为什么对有序数组才适用碰撞指针。</p>\n    <hr>\n     <p><img src=\"https://segmentfault.com/img/bVbKY8C\" alt=\"image\" title=\"image\" /></p>\n     <hr>\n      <h3>3.继续遍历数组</h3>\n      <p>在这个case中我们需要继续遍历数组，直到<code>right</code>指针指向7，此时<code>sum</code>小于<code>target</code>：</p>\n      <hr>\n       <p><img src=\"https://segmentfault.com/img/bVbKY8E\" alt=\"image\" title=\"image\" /></p>\n       <hr>\n        <h3>4.右移左指针</h3>\n        <p>与步骤2类似，当<code>sum</code>小于<code>target</code>时我们需要右移左指针，增加<code>sum</code>值使得两者更加接近：</p>\n        <hr>\n         <p><img src=\"https://segmentfault.com/img/bVbKY8G\" alt=\"image\" title=\"image\" /></p>\n         <hr>\n          <h3>5.匹配成功！</h3>\n          <p>在当前case中，<code>left</code>指向2时<code>sum</code>与<code>target</code>相等，匹配成功！<br>此时返回<code>left</code>值和<code>right</code>值在原数组中的下标即可：</br></p>\n          <hr>\n           <p><img src=\"https://segmentfault.com/img/bVbKY8H\" alt=\"image\" title=\"image\" /></p>\n           <hr>\n            <h3>6.完整示例代码</h3>\n            <p>示例代码如下：</p>\n            <hr>\n             <p><img src=\"https://segmentfault.com/img/bVbKY8I\" alt=\"image\" title=\"image\" /></p>\n             <hr>\n              <p>需要注意的是，由于JavaScript引用类型的特性，我们首先拷贝了<code>nums</code>，才使用<code>Array.sort</code>对拷贝数组进行排序。</p>\n              <p>另外，对于<code>nums=[1,2,2,3],target=4</code>这种case，其期望的返回值是<code>[1,2]</code>而不是<code>[1,1]</code>或者<code>[2,2]</code>。所以这里我们使用了<code>Array.lastIndexOf()</code>这个API。</p>\n              <h2>小结</h2>\n              <ul>\n               <li>采用碰撞双指针进行运算；</li>\n               <li>碰撞双指针运算的时间复杂度取决于具体的排序算法，空间复杂度为O(n)；</li>\n               <li>碰撞指针需要对数组进行排序；</li>\n               <li>排序时注意不要污染原数组；</li>\n               <li>返回结果需要考虑数组含有相同项；</li>\n              </ul>\n              <p>再复习一下暴力运算法和哈希表法：</p>\n              <ul>\n               <li>双层<code>for</code>循环暴力运算简单直观，时间复杂度O(n<sup>2</sup>)、空间复杂度O(1)；</li>\n               <li>哈希表法时间复杂度和空间复杂度都是O(n)；</li>\n               <li>考察点是对哈希表这种数据结构的熟悉程度；</li>\n               <li>多一种解法就多一分胜算；</li>\n               <li>整体难度不高。</li>\n              </ul>\n              <hr>\n               <p><strong><em>一入JS深似海，希望这个专栏能在你乘风破浪的旅途中有所帮助。欢迎关注我的公众号：「JS漫步指南」，更多精彩等待您发现！</em></strong></p>\n               <p><img src=\"https://segmentfault.com/img/bVbKY9n\" alt=\"image\" title=\"image\" /></p>\n              </hr>\n             </hr>\n            </hr>\n           </hr>\n          </hr>\n         </hr>\n        </hr>\n       </hr>\n      </hr>\n     </hr>\n    </hr>\n   </hr>\n  </hr>\n </hr>\n</hr>","descriptionType":"html","publishedDate":"Fri, 14 Aug 2020 01:00:00 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbKYWU","linkMd5":"518d797df1c7c9d30e2acaaec433d26b","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn69@2020_4/2020/08/24/23-08-23-184_0d30b74097bcfe0f.webp","destWidth":800,"destHeight":450,"sourceBytes":209291,"destBytes":39226,"author":"王亮hengg","articleImgCdnMap":{"https://segmentfault.com/img/bVbKYWU":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn69@2020_4/2020/08/24/23-08-23-184_0d30b74097bcfe0f.webp","https://segmentfault.com/img/bVbKY8w":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn78@2020_4/2020/08/24/23-08-33-533_03ba1729d180dc44.webp","https://segmentfault.com/img/bVbKY8B":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn84@2020_5/2020/08/24/23-08-42-674_0778a1e1cb410796.webp","https://segmentfault.com/img/bVbKY8C":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn90@2020_1/2020/08/24/23-08-43-089_00fb40bbb61603de.webp","https://segmentfault.com/img/bVbKY8E":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn94@2020_3/2020/08/24/23-08-43-312_99173a1bbea09ba0.webp","https://segmentfault.com/img/bVbKY8G":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn1@2020_1/2020/08/24/23-08-31-021_13b83779e9282377.webp","https://segmentfault.com/img/bVbKY8H":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn6@2020_2/2020/08/24/23-08-31-343_f69c4c9c378440c7.webp","https://segmentfault.com/img/bVbKY8I":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn10@2020_5/2020/08/24/23-08-31-367_4e367cfe16dd2bc7.webp","https://segmentfault.com/img/bVbKY9n":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn98@2020_1/2020/08/24/23-08-33-472_6992bf171c48ab6b.webp"},"publishedOrCreatedDate":1598310388567},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"如何使用华为云服务一键构建部署发布前端和Node.js服务","link":"https://segmentfault.com/a/1190000023663451","description":"<h2>如何使用华为云服务一键构建部署发布前端和Node.js服务</h2>\n<h2><img src=\"https://segmentfault.com/img/remote/1460000023663455\" alt=\"image.png\" title=\"image.png\" /></h2>\n<h4>构建部署,一直是一个很繁琐的过程</h4>\n<ul>\n <li>作为开发,最害怕遇到版本发布,特别是前、后端一起上线发布,项目又特别多的时候</li>\n <li>例如你有<code>10</code>个项目,前后端都要同时发布,那么就需要多次合并代码、构建,重复很多动作..而且还要去关心构建机器环境是不是变了?配置是否能扛住同时构建多个应用,人为的操作次数多了,就很难保证万无一失</li>\n <li>那这种局面怎么破? 是不是要考虑从技术角度来提效? 假如我把所有的构建、发布都迁移到云端,可以一键<code>push</code>代码,然后自动完成构建,我只要执行一个命令就可以完成部署,又不需要关心机器配置和环境变化,那我们的工作效率是不是可以大大提升?</li>\n</ul>\n<h4>我之前的构建发布流程</h4>\n<ul>\n <li>之前我是使用<code>Travis CI</code>和<code>gitHub</code>以及<code>docker-compose</code>结合进行一键代码<code>push</code>构建发布</li>\n <li>但是有一个很明显的问题,<code>gitHub</code>和<code>Travis</code>这两个平台是完全独立的,特别是我代码托管在<code>gitHub</code>上，有时候访问速度还很慢,更要命的是没有在一个平台上形成完整的链路闭环</li>\n <li>于是我找了很多个平台，最终发现，<code>华为云</code>可以满足我的需求,既可以代码托管,也有可配置的自动化构建流程,而且访问速度快,纯中文界面友好</li>\n</ul>\n<h2>新建项目 &amp; 迁移到华为云</h2>\n<ul>\n <li>像我们前端和<code>Node.js</code>都是有一些脚手架，例如<code>React</code>这种框架,就有很多脚手架可以一键生成项目模板,让你不再关心工程化配置的问题,华为云的<code>developer</code>模块也提供了这个功能<p><img src=\"https://segmentfault.com/img/remote/1460000023663454\" alt=\"image.png\" title=\"image.png\" /></p></li>\n <li>选择想要的模板,像我选择的是<code>React</code>+<code>express</code>模板,10秒钟左右就生成好了,此时就可以在我的模板产物中看<p><img src=\"https://segmentfault.com/img/remote/1460000023663458\" alt=\"image.png\" title=\"image.png\" /></p></li>\n <li>此时下载压缩包,解压运行以下命令即可开始开发</li>\n</ul>\n<p>`npm run install-all <br>npm run dev <br>`</br></br></p>\n<ul>\n <li>新建项目时候,我们可以选择上面这种模式快速根据模版生成代码,但是我今天是要把我的代码从<code>gitHub</code>迁移到华为云上托管,然后在华为云上完成整个开发流程的闭环</li>\n</ul>\n<h4>将我<code>gitHub</code>仓库代码导入到华为云托管</h4>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023663456\" alt=\"image.png\" title=\"image.png\" /></p>\n<ul>\n <li>进入华为云<code>devcloud</code>模块,输入想要导入的<code>gitHub</code>仓库地址和账号密码（如果需要）,然后开始导入,大约耗时<code>30S</code></li>\n <li>此时,在本地生成<code>git ssh</code>,将公钥放置到华为云上<p><img src=\"https://segmentfault.com/img/remote/1460000023663462\" alt=\"image.png\" title=\"image.png\" /></p></li>\n <li>我们此时可以点击代码仓库,进去就可以看到仓库详情了(<code>纯中文界面,真的友好</code>)<p><img src=\"https://segmentfault.com/img/remote/1460000023663464\" alt=\"image.png\" title=\"image.png\" /></p></li>\n <li>在本地使用以下命令即可完成<code>clone</code>和启动</li>\n</ul>\n<p>`git clone&nbsp;remoteurl <br>cd&nbsp;your projectName <br>npm install <br>npm run dev </br></br></br></p>\n<p>`</p>\n<ul>\n <li>以上完成了代码迁移,目前我们代码已经托管到<code>华为云</code>上,为了完成整套研发环节的闭环,我们需要将构建、发布都迁移到<code>华为云鲲鹏服务器</code>上</li>\n</ul>\n<h4>改变我的构建策略</h4>\n<ul>\n <li>我之前是基于<code>gitHub</code>和<code>Travis CI</code>和<code>docker-compose</code>完成一键<code>push</code>代码,然后一键完成发布,现在要在<code>华为云</code>上实现一套自动化构建流程</li>\n</ul>\n<h4>构建策略适配难度极低,远超我的想象</h4>\n<ul>\n <li>我的项目是一个前端基于<code>React</code>,后端基于<code>Node.js</code>的<code>express</code>框架,跟华为云的<code>devstar</code>的模板非常像</li>\n <li>如何设计这个任务流?</li>\n</ul>\n<h4>编写任务流</h4>\n<ul>\n <li>基于项目,新建编译构建任务<p><img src=\"https://segmentfault.com/img/remote/1460000023663459\" alt=\"image.png\" title=\"image.png\" /></p></li>\n <li>编写任务流任务流,所谓任务流,就是完成一个,然后接着下一个,华为云这里比较贴心,根据不同的环境进行了区分环境,不像传统的服务器,你还要去装<code>docker、node.js</code>等等这些(<code>PS:</code>任务新建后可以修改任务～)</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023663457\" alt=\"image.png\" title=\"image.png\" /></p>\n<ul>\n <li>这里默认使用了华为的镜像源仓库,解决了因为环境配置问题导致下载慢的问题~</li>\n</ul>\n<h4>如何编写任务流?</h4>\n<ul>\n <li>以我的一个资料网站项目为例子,基于<code>docker-compose</code>发布,前后端都打包在一个镜像中</li>\n <li>首先代码<code>push</code>后,构建任务不一定需要马上执行,而且我的推送次数可能很频繁,此时我可以调成定时任务,还能限制次数(真的很贴心)</li>\n <li><img src=\"https://segmentfault.com/img/remote/1460000023663461\" alt=\"image.png\" title=\"image.png\" /></li>\n</ul>\n<h4>编写dockerfile</h4>\n<ul>\n <li>此时先编写<code>dockerfile</code>文件,用于<code>docker</code>,基于<code>Node.js 12.16.3</code>版本的镜像,指定端口</li>\n</ul>\n<p>`#引用镜像 <br>FROM node:12.16.3</br></p>\n<h1>执行命令，创建文件夹</h1>\n<p>RUN mkdir -p /usr/www <br>WORKDIR /usr/www <br>COPY . /usr/www <br>RUN npm run build</br></br></br></p>\n<h1>配置环境变量</h1>\n<p>&nbsp;ENV HOST 0.0.0.0 <br>&nbsp;ENV PORT 8080</br></p>\n<h1>定义程序默认端口</h1>\n<p>EXPOSE 8080</p>\n<h1>运行程序命令</h1>\n<p>CMD [\"node\",\"./server/index.js\"] <br>`</br></p>\n<ul>\n <li>此时可以想象,我们推送代码后(<code>可以选择什么分支</code>),根据配置定时自动构建,然后可以通过接口或者手动借助<code>docker-compose</code>命令进行一键更新发布</li>\n <li><img src=\"https://segmentfault.com/img/remote/1460000023663460\" alt=\"image.png\" title=\"image.png\" /></li>\n <li>简单三个命令,完成<code>docker-image</code>的制作和<code>push</code>（具体参数可以参考提示）</li>\n <li><img src=\"https://segmentfault.com/img/remote/1460000023663463\" alt=\"image.png\" title=\"image.png\" /></li>\n <li>首先登陆<code>docker</code>,然后<code>build</code>打包镜像,最后<code>push</code>即可完成构建这一步,我们本地完全是无感知的~也不需要考虑配置和环境的问题</li>\n <li>此时我们手动触发构建任务（像我们公司项目特别大，一台<code>4核8G</code>的机器可能就扛不住几个项目同时构建，在这里就不用担心）</li>\n <li><img src=\"https://segmentfault.com/img/remote/1460000023663466\" alt=\"image.png\" title=\"image.png\" /></li>\n <li>等待一段时间后,发现命令执行完成,<code>docker</code>镜像已经发布完成</li>\n <li><img src=\"https://segmentfault.com/img/remote/1460000023663465\" alt=\"image.png\" title=\"image.png\" /></li>\n</ul>\n<h4>发布</h4>\n<ul>\n <li>两种手段</li>\n <li>通过<code>ssh</code>连接华为云服务器,执行编写好的<code>docker-compose</code>文件</li>\n <li>通过接口带<code>token</code>方式(有权限的人才可以发布)调用,执行<code>docker-compose</code>命令,达到发布目的</li>\n <li>我们重点关注第一种,通过<code>ssh</code>连接到<code>华为云鲲鹏服务器</code></li>\n <li>`<img src=\"https://segmentfault.com/img/remote/1460000023663467\" alt=\"image.png\" title=\"image.png\"> <br>`</br></img></li>\n <li>输入用户和<code>ip</code>地址后,<code>ssh</code>连接成功,编写<code>docker-compose</code>文件</li>\n</ul>\n<p>`version: \"3.7\" <br>services: <br>&nbsp; &nbsp; redis: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; image: redis:3 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; container_name: redis <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; hostname: redis <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; command: redis-server /usr/local/etc/redis/redis.conf --requirepass huaweiapp666 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; volumes: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; - ./redis/redis.conf:/usr/local/etc/redis/redis.conf <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; ports: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; - \"6379:6379\" <br>&nbsp; &nbsp; huaweiapp: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; image: jinjietan/huaweiapp:latest <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; ports: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; - \"8080:8080\" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; restart: on-failure <br>`</br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></p>\n<ul>\n <li>执行命令，拉取镜像<p><code>docker-compose pull</code></p></li>\n <li>拉取完成后,运行<code>docker-compose</code></li>\n</ul>\n<p><code>docker-compose up -d</code></p>\n<ul>\n <li>启动成功,输入域名,即可访问到我的网站了,完成这个迁移和整套开发构建流程的闭环,仅仅用了1个小时不到</li>\n</ul>\n<h4><img src=\"https://segmentfault.com/img/remote/1460000023663468\" alt=\"image.png\" title=\"image.png\" /></h4>\n<h4>感受</h4>\n<ul>\n <li>华为云从开发者角度出来,项目模板一键生成,定时构建任务,任务流的定制化处理这些,非常人性化,大大降低了开发运维门槛,形成整套研发构建流程的闭环</li>\n <li>我司也正在准备购买迁移华为云产品，所有托管、构建发布都放在云端完成闭环</li>\n <li>相信你通过这篇文章，也可以快速的将你的代码托管、构建发布快速迁移到<code>华为云鲲鹏服务器</code>上</li>\n</ul>","descriptionType":"html","publishedDate":"Tue, 18 Aug 2020 00:00:00 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023663455","linkMd5":"aa2132e98ae80a419b6636569f23b0d7","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn38@2020_4/2020/08/24/23-08-24-961_f11044dd1174001a.webp","destWidth":770,"destHeight":494,"sourceBytes":334245,"destBytes":28466,"author":"Peter谭金杰","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023663455":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn38@2020_4/2020/08/24/23-08-24-961_f11044dd1174001a.webp","https://segmentfault.com/img/remote/1460000023663454":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn1@2020_2/2020/08/24/23-08-31-134_9fa46c777ab520a1.webp","https://segmentfault.com/img/remote/1460000023663458":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn65@2020_6/2020/08/24/23-08-28-473_cec3b758d21a710e.webp","https://segmentfault.com/img/remote/1460000023663456":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn98@2020_2/2020/08/24/23-08-32-493_66d56292ccba60f9.webp","https://segmentfault.com/img/remote/1460000023663462":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn10@2020_2/2020/08/24/23-08-28-508_51ef71423df3d477.webp","https://segmentfault.com/img/remote/1460000023663464":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn54@2020_6/2020/08/24/23-08-28-853_f70d6764a3ae6436.webp","https://segmentfault.com/img/remote/1460000023663459":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn62@2020_5/2020/08/24/23-08-28-683_06ae40cf5655a06c.webp","https://segmentfault.com/img/remote/1460000023663457":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn69@2020_6/2020/08/24/23-08-29-241_e461d9020d0ef79a.webp","https://segmentfault.com/img/remote/1460000023663461":"https://cdn.jsdelivr.net/gh/myreaderx/cdn14@2020_5/2020/08/24/23-08-28-862_28c5749083b296c8.webp","https://segmentfault.com/img/remote/1460000023663460":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn21@2020_2/2020/08/24/23-08-28-891_e2bd700b6524c208.webp","https://segmentfault.com/img/remote/1460000023663463":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn6@2020_2/2020/08/24/23-08-28-516_a78bd2cd84532ab6.webp","https://segmentfault.com/img/remote/1460000023663466":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn38@2020_2/2020/08/24/23-08-32-798_eb0a0c56eee8bbb0.webp","https://segmentfault.com/img/remote/1460000023663465":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn50@2020_4/2020/08/24/23-08-28-553_0db805f790b2fe3b.webp","https://segmentfault.com/img/remote/1460000023663467":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn26@2020_3/2020/08/24/23-08-28-656_c96df5d663364d77.webp","https://segmentfault.com/img/remote/1460000023663468":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn33@2020_5/2020/08/24/23-08-30-799_c54b3b3ab9067f97.webp"},"publishedOrCreatedDate":1598310388563},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"Go多协程并发环境下的错误处理","link":"https://segmentfault.com/a/1190000023691221","description":"<h2>引言</h2>\n<p>在Go语言中，我们通常会用到panic和recover来抛出错误和捕获错误，这一对操作在单协程环境下我们正常用就好了，并不会踩到什么坑。但是在多协程并发环境下，我们常常会碰到以下两个问题。假设我们现在有2个协程，我们叫它们协程A和B好了：</p>\n<ul>\n <li>如果协程A发生了panic，协程B是否会因为协程A的panic而挂掉？</li>\n <li>如果协程A发生了panic，协程B是否能用recover捕获到协程A的panic？</li>\n</ul>\n<p>答案分别是：会、不能。<br>那么下面我们来一一验证，并给出在具体的业务场景下的最佳实践。</br></p>\n<h2>问题一</h2>\n<ul>\n <li>如果协程A发生了panic，协程B是否会因为协程A的panic而挂掉？</li>\n</ul>\n<p>为了验证这个问题，我们写一段程序：</p>\n<pre><code class=\"go\">package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n\n    // 协程A\n    go func() {\n        for {\n            fmt.Println(\"goroutine1_print\")\n        }\n    }()\n\n    // 协程B\n    go func() {\n        time.Sleep(1 * time.Second)\n        panic(\"goroutine2_panic\")\n    }()\n\n    time.Sleep(2 * time.Second)\n}</code></pre>\n<p>首先主协程开启两个子协程A和B，A协程不停的循环打印goroutine1_print字符串；B协程在睡眠1s后，就会抛出panic（睡眠这一步为了确保在A跑起来开始打印了之后，B才会panic），主协程睡眠2s，等待A、B子协程全部执行完毕，主协程退出。最终打印结果如下：</p>\n<pre><code class=\"go\">...\ngoroutine1_print\ngoroutine1_print\ngoroutine1_print\ngoroutine1_print\ngoroutine1_print\ngoroutine1_print\ngoroutine1_print\ngoroutine1_print\ngoroutine1_print\ngoroutine1_print\ngoroutine1_print\ngoroutine1_print\npanic: goroutine2_panicgoroutine1_print\n\n\ngoroutine1_print\ngoroutine goroutine1_print\n19goroutine1_print\ngoroutine1_print\ngoroutine1_print\ngoroutine1_print\n [runninggoroutine1_print\n]:\ngoroutine1_print\ngoroutine1_print\ngoroutine1_print\nmain.main.func2()\n        /Users/jiangbaiyan/go/src/awesomeProject/main.go:18 +0x46\ncreated by main.main\n        /Users/jiangbaiyan/go/src/awesomeProject/main.go:16 +0x4d\n</code></pre>\n<p>我们可以看到，在协程B发生panic之前，协程A一直在打印字符串；然后协程A和panic交替打印字符串，最后主协程与协程A、B全部退出。所以我们可以看到，一个协程panic之后，是会导致所有的协程全部挂掉的，程序会整体退出，到这里我们就验证了第一个问题的答案。<br>至于panic和协程A交替打印的原因，可能是因为panic也需要打印字符串。因为打印也是需要时间的，当我们执行panic这一行代码的时候，到panic真正触发所有协程挂掉，是需要一定的时间的（尽管这个时间很短暂），所以再这一小段时间内，我们会看到交替打印的现象。</br></p>\n<h2>问题二</h2>\n<ul>\n <li>如果协程A发生了panic，其他协程是否能用recover捕获到协程A的panic？</li>\n</ul>\n<p>还是类似上面那段代码，我们还可以再精简一下：</p>\n<pre><code class=\"go\">package main\n\nimport (\n   \"fmt\"\n   \"time\"\n)\n\nfunc main() {\n\n   defer func() {\n       if e := recover(); e != nil {\n           fmt.Println(\"recover_panic\")\n       }\n   }()\n\n   go func() {\n       panic(\"goroutine2_panic\")\n   }()\n\n   time.Sleep(2 * time.Second)\n}</code></pre>\n<p>我们这次只开启一个协程，并在主协程中加入了recover，希望它能够捕获到子协程中的panic，但是结果未能如愿：</p>\n<pre><code class=\"go\">panic: goroutine2_panic\n\ngoroutine 6 [running]:\nmain.main.func2()\n       /Users/jiangbaiyan/go/src/awesomeProject/main.go:17 +0x39\ncreated by main.main\n       /Users/jiangbaiyan/go/src/awesomeProject/main.go:16 +0x57\n\nProcess finished with exit code 2\n</code></pre>\n<p>我们看到，recover并没有生效。所以，哪个协程发生了panic，我们就需要在哪个协程recover，我们改成这样：</p>\n<pre><code class=\"golang\">package main\n\nimport (\n   \"fmt\"\n   \"time\"\n)\n\nfunc main() {\n\n   go func() {\n       defer func() {\n           if e := recover(); e != nil {\n               fmt.Println(\"recover_panic\")\n           }\n       }()\n       panic(\"goroutine2_panic\")\n   }()\n\n   time.Sleep(2 * time.Second)\n}</code></pre>\n<p>结果成功打印recover_panic字符串：</p>\n<pre><code class=\"go\">recover_panic\n\nProcess finished with exit code 0</code></pre>\n<p>所以我们的答案也得到了验证：协程A发生panic，协程B无法recover到协程A的panic，只有协程自己内部的recover才能捕获自己抛出的panic。</p>\n<h2>最佳实践</h2>\n<p>我们先假设有这样一个场景，我们要开发一个客户端，这个客户端需要调用2个服务，这2个服务没有任何先后顺序的依赖，所以我们可以开启2个goroutine，通过并发调用这两个服务来获得性能提升。那么这个时候我们刚才所谈到的问题一就成了问题。<br>通常来讲，我们不希望其中一个服务调用失败，另一个服务调用也跟着失败，而是要继续执行完其他几个服务调用逻辑，这个时候我们该怎么办呢？<br>聪明的你一定会想到，我在每个协程内部编写一个recover语句，让他接住每个协程自己可能会发生的panic，就能够解决一个协程panic而导致所有协程挂掉的问题了。我们编写如下代码，这就是在业务开发中，结合问题二解决问题一的最佳实践：</br></br></p>\n<pre><code class=\"go\">// 并发调用服务，每个handler都会传入一个调用逻辑函数\nfunc GoroutineNotPanic(handlers ...func() error) (err error) {\n\n    var wg sync.WaitGroup\n    // 假设我们要调用handlers这么多个服务\n    for _, f := range handlers {\n\n        wg.Add(1)\n        // 每个函数启动一个协程\n        go func(handler func() error) {\n\n            defer func() {\n                // 每个协程内部使用recover捕获可能在调用逻辑中发生的panic\n                if e := recover(); e != nil {\n                    // 某个服务调用协程报错，可以在这里打印一些错误日志\n                }\n                wg.Done()\n            }()\n\n            // 取第一个报错的handler调用逻辑，并最终向外返回\n            e := handler()\n            if err == nil &amp;&amp; e != nil {\n                err = e\n            }\n        }(f)\n    }\n\n    wg.Wait()\n\n    return\n}</code></pre>\n<p>以上方法调用示例：</p>\n<pre><code class=\"go\">// 调用示例\nfunc main() {\n\n    // 调用逻辑1\n    aRpc := func() error {\n        panic(\"rpc logic A panic\")\n        return nil\n    }\n    \n    // 调用逻辑2\n    bRpc := func() error {\n        fmt.Println(\"rpc logic B\")\n        return nil\n    }\n\n    err := GoroutineNotPanic(aRpc, bRpc)\n    if err != nil {\n        fmt.Println(err)\n    }\n}</code></pre>\n<p>这样我们就实现了一个通用的并发处理逻辑，每次调用我们只需要把业务逻辑的函数传入即可，不用每次自己单独编写一套并发控制逻辑；同时调用逻辑2就不会因为调用逻辑1的panic而挂掉了，容错率更高。在业务开发中我们可以参考这种实现方式~</p>\n<h2>关注我们</h2>\n<p>欢迎各位订阅我们的公众号，关注博主下次不迷路～</p>\n<p><img src=\"https://segmentfault.com/img/bVbESbH\" alt=\"Nosay\" title=\"Nosay\" /></p>","descriptionType":"html","publishedDate":"Wed, 19 Aug 2020 11:56:47 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbESbH","linkMd5":"ed2d9ff0860340e13c972d901109e6db","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn79@2020_4/2020/08/24/23-08-22-002_23e3d2b285dd74b0.webp","destWidth":258,"destHeight":258,"sourceBytes":9980,"destBytes":9980,"author":"NoSay","articleImgCdnMap":{"https://segmentfault.com/img/bVbESbH":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn79@2020_4/2020/08/24/23-08-22-002_23e3d2b285dd74b0.webp"},"publishedOrCreatedDate":1598310388559},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"不知道怎么封装代码？看看这几种设计模式吧！","link":"https://segmentfault.com/a/1190000023735149","description":"<h2>为什么要封装代码？</h2>\n<p>我们经常听说：“写代码要有良好的封装，要高内聚，低耦合”。那怎样才算良好的封装，我们为什么要封装呢？其实封装有这样几个好处：</p>\n<blockquote>\n <ol>\n  <li>封装好的代码，内部变量不会污染外部。</li>\n  <li>可以作为一个模块给外部调用。外部调用者不需要知道实现的细节，只需要按照约定的规范使用就行了。</li>\n  <li>对扩展开放，对修改关闭，即开闭原则。外部不能修改模块，既保证了模块内部的正确性，又可以留出扩展接口，使用灵活。</li>\n </ol>\n</blockquote>\n<h2>怎么封装代码？</h2>\n<p>JS生态已经有很多模块了，有些模块封装得非常好，我们使用起来很方便，比如jQuery，Vue等。如果我们仔细去看这些模块的源码，我们会发现他们的封装都是有规律可循的。这些规律总结起来就是设计模式，用于代码封装的设计模式主要有<code>工厂模式</code>，<code>创建者模式</code>，<code>单例模式</code>，<code>原型模式</code>四种。下面我们结合一些框架源码来看看这四种设计模式：</p>\n<h2>工厂模式</h2>\n<p>工厂模式的名字就很直白，封装的模块就像一个工厂一样批量的产出需要的对象。常见工厂模式的一个特征就是调用的时候不需要使用<code>new</code>，而且传入的参数比较简单。但是调用次数可能比较频繁，经常需要产出不同的对象，频繁调用时不用<code>new</code>也方便很多。一个工厂模式的代码结构如下所示:</p>\n<pre><code class=\"javascript\">function factory(type) {\n  switch(type) {\n    case 'type1':\n      return new Type1();\n    case 'type2':\n      return new Type2();\n    case 'type3':\n      return new Type3();\n  }\n}</code></pre>\n<p>上述代码中，我们传入了<code>type</code>，然后工厂根据不同的<code>type</code>来创建不同的对象。</p>\n<h3>实例: 弹窗组件</h3>\n<p>下面来看看用工厂模式的例子，假如我们有如下需求：</p>\n<blockquote>\n 我们项目需要一个弹窗，弹窗有几种：消息型弹窗，确认型弹窗，取消型弹窗，他们的颜色和内容可能是不一样的。\n</blockquote>\n<p>针对这几种弹窗，我们先来分别建一个类：</p>\n<pre><code class=\"javascript\">function infoPopup(content, color) {}\nfunction confirmPopup(content, color) {}\nfunction cancelPopup(content, color) {}</code></pre>\n<p>如果我们直接使用这几个类，就是这样的:</p>\n<pre><code class=\"javascript\">let infoPopup1 = new infoPopup(content, color);\nlet infoPopup2 = new infoPopup(content, color);\nlet confirmPopup1 = new confirmPopup(content, color);\n...</code></pre>\n<p>每次用的时候都要去<code>new</code>对应的弹窗类，我们用工厂模式改造下，就是这样：</p>\n<pre><code class=\"javascript\">// 新加一个方法popup把这几个类都包装起来\nfunction popup(type, content, color) {\n  switch(type) {\n    case 'infoPopup':\n      return new infoPopup(content, color);\n    case 'confirmPopup':\n      return new confirmPopup(content, color);\n    case 'cancelPopup':\n      return new cancelPopup(content, color);\n  }\n}</code></pre>\n<p>然后我们使用<code>popup</code>就不用<code>new</code>了，直接调用函数就行:</p>\n<pre><code class=\"javascript\">let infoPopup1 = popup('infoPopup', content, color); </code></pre>\n<h3>改造成面向对象</h3>\n<p>上述代码虽然实现了工厂模式，但是<code>switch</code>始终感觉不是很优雅。我们使用面向对象改造下<code>popup</code>，将它改为一个类，将不同类型的弹窗挂载在这个类上成为工厂方法：</p>\n<pre><code class=\"javascript\">function popup(type, content, color) {\n  // 如果是通过new调用的，返回对应类型的弹窗\n  if(this instanceof popup) {\n    return new this[type](content, color);\n  } else {\n    // 如果不是new调用的，使用new调用，会走到上面那行代码\n    return new popup(type, content, color);\n  }\n}\n\n// 各种类型的弹窗全部挂载在原型上成为实例方法\npopup.prototype.infoPopup = function(content, color) {}\npopup.prototype.confirmPopup = function(content, color) {}\npopup.prototype.cancelPopup = function(content, color) {}</code></pre>\n<h3>封装成模块</h3>\n<p>这个<code>popup</code>不仅仅让我们调用的时候少了一个<code>new</code>，他其实还把相关的各种弹窗都封装在了里面，这个<code>popup</code>可以直接作为模块<code>export</code>出去给别人调用，也可以挂载在<code>window</code>上作为一个模块给别人调用。因为<code>popup</code>封装了弹窗的各种细节，即使以后<code>popup</code>内部改了，或者新增了弹窗类型，或者弹窗类的名字变了，只要保证对外的接口参数不变，对外面都没有影响。挂载在<code>window</code>上作为模块可以使用自执行函数：</p>\n<pre><code class=\"javascript\">(function(){\n     function popup(type, content, color) {\n    if(this instanceof popup) {\n      return new this[type](content, color);\n    } else {\n      return new popup(type, content, color);\n    }\n  }\n\n  popup.prototype.infoPopup = function(content, color) {}\n  popup.prototype.confirmPopup = function(content, color) {}\n  popup.prototype.cancelPopup = function(content, color) {}\n  \n  window.popup = popup;\n})()\n\n// 外面就直接可以使用popup模块了\nlet infoPopup1 = popup('infoPopup', content, color); </code></pre>\n<h3>jQuery的工厂模式</h3>\n<p>jQuery也是一个典型的工厂模式，你给他一个参数，他就给你返回符合参数DOM对象。那jQuery这种不用<code>new</code>的工厂模式是怎么实现的呢？其实就是jQuery内部帮你调用了<code>new</code>而已，jQuery的调用流程简化了就是这样:</p>\n<pre><code class=\"javascript\">(function(){\n  var jQuery = function(selector) {\n    return new jQuery.fn.init(selector);   // new一下init, init才是真正的构造函数\n  }\n\n  jQuery.fn = jQuery.prototype;     // jQuery.fn就是jQuery.prototype的简写\n\n  jQuery.fn.init = function(selector) {\n    // 这里面实现真正的构造函数\n  }\n\n  // 让init和jQuery的原型指向同一个对象，便于挂载实例方法\n  jQuery.fn.init.prototype = jQuery.fn;  \n\n  // 最后将jQuery挂载到window上\n  window.$ = window.jQuery = jQuery;\n})();</code></pre>\n<p>上述代码结构来自于jQuery源码，从中可以看出，你调用时省略的<code>new</code>在jQuery里面帮你调用了，目的是为了使大量调用更方便。但是这种结构需要借助一个<code>init</code>方法，最后还要将<code>jQuery</code>和<code>init</code>的原型绑在一起，其实还有一种更加简便的方法可以实现这个需求:</p>\n<pre><code class=\"javascript\">var jQuery = function(selector) {\n  if(!(this instanceof jQuery)) {\n    return new jQuery(selector);\n  }\n  \n  // 下面进行真正构造函数的执行\n}</code></pre>\n<p>上述代码就简洁多了，也可以实现不用<code>new</code>直接调用，这里利用的特性是<code>this</code>在函数被<code>new</code>调用时，指向的是<code>new</code>出来的对象，<code>new</code>出来的对象自然是类的<code>instance</code>，这里的<code>this instanceof jQuery</code>就是<code>true</code>。如果是普通调用，他就是<code>false</code>，我们就帮他<code>new</code>一下。</p>\n<h2>建造者模式</h2>\n<p>建造者模式是用于比较复杂的大对象的构建，比如<code>Vue</code>，<code>Vue</code>内部包含一个功能强大，逻辑复杂的对象，在构建的时候也需要传很多参数进去。像这种需要创建的情况不多，创建的对象本身又很复杂的时候就适用建造者模式。建造者模式的一般结构如下：</p>\n<pre><code class=\"javascript\">function Model1() {}   // 模块1\nfunction Model2() {}   // 模块2\n\n// 最终使用的类\nfunction Final() {\n  this.model1 = new Model1();\n  this.model2 = new Model2();\n}\n\n// 使用时\nvar obj = new Final();</code></pre>\n<p>上述代码中我们最终使用的是<code>Final</code>，但是<code>Final</code>里面的结构比较复杂，有很多个子模块，<code>Final</code>就是将这些子模块组合起来完成功能，这种需要精细化构造的就适用于建造者模式。</p>\n<h3>实例：编辑器插件</h3>\n<p>假设我们有这样一个需求：</p>\n<blockquote>\n 写一个编辑器插件，初始化的时候需要配置大量参数，而且内部的功能很多很复杂，可以改变字体颜色和大小，也可以前进后退。\n</blockquote>\n<p>一般一个页面就只有一个编辑器，而且里面的功能可能很复杂，可能需要调整颜色，字体等。也就是说这个插件内部可能还会调用其他类，然后将他们组合起来实现功能，这就适合建造者模式。我们来分析下做这样一个编辑器需要哪些模块:</p>\n<blockquote>\n <ol>\n  <li>编辑器本身肯定需要一个类，是给外部调用的接口</li>\n  <li>需要一个控制参数初始化和页面渲染的类</li>\n  <li>需要一个控制字体的类</li>\n  <li>需要一个状态管理的类</li>\n </ol>\n</blockquote>\n<pre><code class=\"javascript\">// 编辑器本身，对外暴露\nfunction Editor() {\n  // 编辑器里面就是将各个模块组合起来实现功能\n  this.initer = new HtmlInit();\n  this.fontController = new FontController();\n  this.stateController = new StateController(this.fontController);\n}\n\n// 初始化参数，渲染页面\nfunction HtmlInit() {\n  \n}\nHtmlInit.prototype.initStyle = function() {}     // 初始化样式\nHtmlInit.prototype.renderDom = function() {}     // 渲染DOM\n\n// 字体控制器\nfunction FontController() {\n  \n}\nFontController.prototype.changeFontColor = function() {}    // 改变字体颜色\nFontController.prototype.changeFontSize = function() {}     // 改变字体大小\n\n// 状态控制器\nfunction StateController(fontController) {\n  this.states = [];       // 一个数组，存储所有状态\n  this.currentState = 0;  // 一个指针，指向当前状态\n  this.fontController = fontController;    // 将字体管理器注入，便于改变状态的时候改变字体\n}\nStateController.prototype.saveState = function() {}     // 保存状态\nStateController.prototype.backState = function() {}     // 后退状态\nStateController.prototype.forwardState = function() {}     // 前进状态</code></pre>\n<p>上面的代码其实就将一个编辑器插件的架子搭起来了，具体实现功能就是往这些方法里面填入具体的内容就行了，其实就是各个模块的相互调用，比如我们要实现后退状态的功能就可以这样写:</p>\n<pre><code class=\"javascript\">StateController.prototype.backState = function() {\n  var state = this.states[this.currentState - 1];  // 取出上一个状态\n  this.fontController.changeFontColor(state.color);  // 改回上次颜色\n  this.fontController.changeFontSize(state.size);    // 改回上次大小\n}</code></pre>\n<h2>单例模式</h2>\n<p>单例模式适用于全局只能有一个实例对象的场景，单例模式的一般结构如下：</p>\n<pre><code class=\"javascript\">function Singleton() {}\n\nSingleton.getInstance = function() {\n  if(this.instance) {\n    return this.instance;\n  }\n  \n  this.instance = new Singleton();\n  return this.instance;\n}</code></pre>\n<p>上述代码中，<code>Singleton</code>类挂载了一个静态方法<code>getInstance</code>，如果要获取实例对象只能通过这个方法拿，这个方法会检测是不是有现存的实例对象，如果有就返回，没有就新建一个。</p>\n<h3>实例：全局数据存储对象</h3>\n<p>假如我们现在有这样一个需求:</p>\n<blockquote>\n 我们需要对一个全局的数据对象进行管理，这个对象只能有一个，如果有多个会导致数据不同步。\n</blockquote>\n<p>这个需求要求全局只有一个数据存储对象，是典型的适合单例模式的场景，我们可以直接套用上面的代码模板，但是上面的代码模板获取<code>instance</code>必须要调<code>getInstance</code>才行，要是某个使用者直接调了<code>Singleton()</code>或者<code>new Singleton()</code>就会出问题，这次我们换一种写法，让他能够兼容<code>Singleton()</code>和<code>new Singleton()</code>，使用起来更加傻瓜化:</p>\n<pre><code class=\"javascript\">function store() {\n  if(store.instance) {\n    return store.instance;\n  }\n  \n  store.instance = this;\n}</code></pre>\n<p>上述代码支持使用<code>new store()</code>的方式调用，我们使用了一个静态变量<code>instance</code>来记录是否有进行过实例化，如果实例化了就返回这个实例，如果没有实例化说明是第一次调用，那就把<code>this</code>赋给这个这个静态变量，因为是使用<code>new</code>调用，这时候的<code>this</code>指向的就是实例化出来的对象，并且最后会隐式的返回<code>this</code>。</p>\n<p>如果我们还想支持<code>store()</code>直接调用，我们可以用前面工厂模式用过的方法，检测<code>this</code>是不是当前类的实例，如果不是就帮他用<code>new</code>调用就行了：</p>\n<pre><code class=\"javascript\">function store() {\n  // 加一个instanceof检测\n  if(!(this instanceof store)) {\n    return new store();\n  }\n  \n  // 下面跟前面一样的\n  if(store.instance) {\n    return store.instance;\n  }\n  \n  store.instance = this;\n}</code></pre>\n<p>然后我们用两种方式调用来检测下:</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023735152\" alt=\"image-20200521154322364\" title=\"image-20200521154322364\" /></p>\n<h3>实例：vue-router</h3>\n<p><code>vue-router</code>其实也用到了单例模式，因为如果一个页面有多个路由对象，可能造成状态的冲突，<code>vue-router</code>的单例实现方式又有点不一样，<a href=\"https://github.com/vuejs/vue-router/blob/dev/src/install.js\" rel=\"nofollow noreferrer\">下列代码来自<code>vue-router</code>源码</a>：</p>\n<pre><code class=\"javascript\">let _Vue;\n\nfunction install(Vue) {\n  if (install.installed &amp;&amp; _Vue === Vue) return;\n  install.installed = true\n\n  _Vue = Vue\n}</code></pre>\n<p>每次我们调用<code>vue.use(vueRouter)</code>的时候其实都会去执行<code>vue-router</code>模块的<code>install</code>方法，如果用户不小心多次调用了<code>vue.use(vueRouter)</code>就会造成<code>install</code>的多次执行，从而产生不对的结果。<code>vue-router</code>的<code>install</code>在第一次执行时，将<code>installed</code>属性写成了<code>true</code>，并且记录了当前的<code>Vue</code>，这样后面在同一个<code>Vue</code>里面再次执行<code>install</code>就会直接<code>return</code>了，这也是一种单例模式。</p>\n<p>可以看到我们这里三种代码都是单例模式，他们虽然形式不一样，但是核心思想都是一样的，都是用一个变量来标记代码是否已经执行过了，如果执行过了就返回上次的执行结果，这样就保证了多次调用也会拿到一样的结果。</p>\n<h2>原型模式</h2>\n<p>原型模式最典型的应用就是JS本身啊，JS的原型链就是原型模式。JS中可以使用<code>Object.create</code>指定一个对象作为原型来创建对象:</p>\n<pre><code class=\"javascript\">const obj = {\n  x: 1,\n  func: () =&gt; {}\n}\n\n// 以obj为原型创建一个新对象\nconst newObj = Object.create(obj);\n\nconsole.log(newObj.__proto__ === obj);    // true\nconsole.log(newObj.x);    // 1</code></pre>\n<p>上述代码我们将<code>obj</code>作为原型，然后用<code>Object.create</code>创建的新对象都会拥有这个对象上的属性和方法，这其实就算是一种原型模式。还有JS的面向对象其实更加是这种模式的体现，比如JS的继承可以这样写:</p>\n<pre><code class=\"javascript\">function Parent() {\n  this.parentAge = 50;\n}\nfunction Child() {}\n\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;      // 注意重置constructor\n\nconst obj = new Child();\nconsole.log(obj.parentAge);    // 50</code></pre>\n<p>这里的继承其实就是让子类<code>Child.prototype.__proto__</code>的指向父类的<code>prototype</code>，从而获取父类的方法和属性。<a href=\"https://segmentfault.com/a/1190000023201844\">JS中面向对象的内容较多，我这里不展开了，有一篇文章专门讲这个问题</a>。</p>\n<h2>总结</h2>\n<ol>\n <li>很多用起来顺手的开源库都有良好的封装，封装可以将内部环境和外部环境隔离，外部用起来更顺手。</li>\n <li>针对不同的场景可以有不同的封装方案。</li>\n <li>需要大量产生类似实例的组件可以考虑用工厂模式来封装。</li>\n <li>内部逻辑较复杂，外部使用时需要的实例也不多，可以考虑用建造者模式来封装。</li>\n <li>全局只能有一个实例的需要用单例模式来封装。</li>\n <li>新老对象之间可能有继承关系的可以考虑用原型模式来封装，JS本身就是一个典型的原型模式。</li>\n <li>使用设计模式时不要生搬硬套代码模板，更重要的是掌握思想，同一个模式在不同的场景可以有不同的实现方案。</li>\n</ol>\n<p><strong>感谢你花费宝贵的时间阅读本文，如果本文给了你一点点帮助或者启发，请不要吝啬你的赞和GitHub小星星，你的支持是作者持续创作的动力。</strong></p>\n<p><strong>本文主要素材来自于<a href=\"https://mooc.study.163.com/smartSpec/detail/1202851605.htm\" rel=\"nofollow noreferrer\">网易高级前端开发工程师微专业</a>唐磊老师的设计模式视频课程。</strong></p>\n<p><strong>作者博文GitHub项目地址： <a href=\"https://github.com/dennis-jiang/Front-End-Knowledges\" rel=\"nofollow noreferrer\">https://github.com/dennis-jiang/Front-End-Knowledges</a></strong></p>","descriptionType":"html","publishedDate":"Mon, 24 Aug 2020 02:22:08 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023735152","linkMd5":"e96585e49877b1a5d367d8d830ee693d","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn94@2020_3/2020/08/24/23-08-22-973_d9a4a0f3fdb1bd81.webp","destWidth":254,"destHeight":121,"sourceBytes":8576,"destBytes":3076,"author":"蒋鹏飞","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023735152":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn94@2020_3/2020/08/24/23-08-22-973_d9a4a0f3fdb1bd81.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"[Concent小课堂]认识组合api，换个姿势撸更清爽的react","link":"https://segmentfault.com/a/1190000023648364","description":"<p><img src=\"https://segmentfault.com/img/remote/1460000023648367\" alt=\"\" title=\"\" /></p>\n<p>开源不易，感谢你的支持，<a href=\"https://github.com/concentjs/concent\" rel=\"nofollow noreferrer\">❤ star me if you like concent ^_^</a></p>\n<p>这里有一份收集中的状态管理清单，欢迎有兴趣的朋友了解^_^<br><a href=\"https://github.com/fantasticsoul/awesome-state/blob/master/README.md\" rel=\"nofollow noreferrer\">awesome-state</a></br></p>\n<h2>序言</h2>\n<p><code>composition api</code>（组合api） 和 <code>optional api</code>（可选api） 两种组织代码的方式，相信大家在<code>vue3</code>各种相关的介绍文里已经了解到不少了，它们可以同时存在，并非强制你只能使用哪一种，但组合api两大优势的确让开发者们更倾向于使用它来替代可选api。</p>\n<ul>\n <li>以函数为基础单位来打包可复用逻辑，并注入到任意组件，让视图和业务解耦更优雅</li>\n <li>让相同功能的业务更加紧密的放置到一起，不被割裂开，提高开发与维护体验</li>\n</ul>\n<p>以上两点在react里均被<code>hook</code>优雅的解决了，那么相比<code>hook</code>，组合api还具有什么优势呢？这里就不卖关子了，相信已有小伙伴在尤大大介绍组合api时已经知道，组合api是静态定义的，解决了<code>hook</code>必需每次渲染都重新生成临时闭包函数的性能问题，也没有了<code>hook</code>里闭包旧值陷阱，人工检测依赖等编码体验问题。</p>\n<p>但是，react是<strong>all in js</strong>的编码方式，所以只要我们敢想、敢做，一切优秀的编程模型都可以吸纳进来，接下来我们用原生<code>hook</code>和concent的<code>setup</code>并通过实例和讲解，来彻底解决尤大提到的这个关于<code>hook</code>的痛点吧^_^</p>\n<h2>react hook</h2>\n<p>我们在此先设计一个传统的计数器，要求如下</p>\n<ul>\n <li>有一个小数，一个大数</li>\n <li>有两组加、减按钮，分别对小数大数做操作，小数按钮加减1，大数按钮加减100</li>\n <li>计数器初次挂载时拉取欢迎问候语</li>\n <li>当小数达到100时，按钮变为红色，否则变为绿色</li>\n <li>当大数达到1000时，按钮变为紫色，否则变为绿色</li>\n <li>当大数达到10000时，上报大数的数字</li>\n <li>计算器卸载时，上报当前的数字</li>\n</ul>\n<p>为了完成此需求，我们需要用到以下5把钩子</p>\n<h3>useState</h3>\n<p>过完需求，我们需要用到第一把钩子<code>useState</code>来做组件首次渲染的状态初始化</p>\n<pre><code class=\"js\">function Counter() {\n  const [num, setNum] = useState(6);\n  const [bigNum, setBigNum] = useState(120);\n}</code></pre>\n<h3>useCallback</h3>\n<p>如需使用缓存函数，则要用到第二把钩子<code>useCallback</code>，此处我们使用这把钩子来定义加减函数</p>\n<pre><code class=\"js\">  const addNum = useCallback(() =&gt; setNum(num + 1), [num]);\n  const addNumBig = useCallback(() =&gt; setBigNum(bigNum + 100), [bigNum]);</code></pre>\n<h3>useMemo</h3>\n<p>如需用到缓存的计算结果，则要用到第三把钩子<code>useMemo</code>，此处我们使用这把钩子来计算按钮颜色</p>\n<pre><code class=\"js\"> const numBtnColor = useMemo(() =&gt; {\n    return num &gt; 100 ? 'red' : 'green';\n  }, [num]);\n  const bigNumBtnColor = useMemo(() =&gt; {\n    return bigNum &gt; 1000 ? 'purple' : 'green';\n  }, [bigNum]);</code></pre>\n<h3>useEffect</h3>\n<p>处理函数的副作用则需用到第四把钩子<code>useEffect</code>，此处我们用来处理一下两个需求</p>\n<ul>\n <li>当大数达到10000时，上报大数的数字</li>\n <li>计算器卸载时，上报当前的数字</li>\n</ul>\n<pre><code class=\"js\">  useEffect(() =&gt; {\n    if (bigNum &gt; 10000) api.report('reach 10000')\n  }, [bigNum])\n  useEffect(() =&gt; {\n    return ()=&gt;{\n      api.reportStat(num, bigNum)\n    }\n  }, [])</code></pre>\n<h3>useRef</h3>\n<p>上面使用清理函数的<code>useEffect</code>写法在IDE是会被警告的，因为内部使用了<code>num, bigNum</code>变量(不写依赖会陷入闭包旧值陷阱)，所以要求我们声明依赖</p>\n<p>可是如果为了避免IDE警告，我们改为如下方式显然不是我们表达的本意，我们只是想组件卸载时报告一下数字，而不是每一轮渲染都触发清理函数</p>\n<pre><code class=\"js\">  useEffect(() =&gt; {\n    return ()=&gt;{\n      api.reportStat(num, bigNum)\n    }\n  }, [num, bigNum])</code></pre>\n<p>这个时候我们需要第5把钩子<code>useRef</code>，来帮忙我们固定依赖了，所以正确的写法是</p>\n<pre><code class=\"js\">  const ref = useRef();// ref是一个固定的变量，每一轮渲染都指向同一个值\n  ref.current = {num, bigNum};// 帮我们记住最新的值\n  useEffect(() =&gt; {\n    return () =&gt; {\n      const {num, bigNum} = ref.current;\n      reportStat(num, bigNum);\n    };\n  }, [ref]);</code></pre>\n<h3>完整的计数器</h3>\n<p>使完5把钩子，我们完整的组件如下</p>\n<pre><code class=\"js\">function Counter() {\n  const [num, setNum] = useState(88);\n  const [bigNum, setBigNum] = useState(120);\n  const addNum = useCallback(() =&gt; setNum(num + 1), [num]);\n  const addNumBig = useCallback(() =&gt; setBigNum(bigNum + 100), [bigNum]);\n  const numBtnColor = useMemo(() =&gt; {\n    return num &gt; 100 ? \"red\" : \"green\";\n  }, [num]);\n  const bigNumBtnColor = useMemo(() =&gt; {\n    return bigNum &gt; 1000 ? \"purple\" : \"green\";\n  }, [bigNum]);\n  useEffect(() =&gt; {\n    if (bigNum &gt; 10000) report(\"reach 10000\");\n  }, [bigNum]);\n\n  const ref = useRef();\n  ref.current = {num, bigNum};\n  useEffect(() =&gt; {\n    return () =&gt; {\n      const {num, bigNum} = ref.current;\n      reportStat(num, bigNum);\n    };\n  }, [ref]);\n\n  // render ui ...\n}</code></pre>\n<p>当然我们可以基于<code>hook</code>可定制的特性，将这段代码单独抽象为一个钩子，这样的话只需将数据和方法导出，以便让多种ui表达的Counter组件可以复用，同时也做到ui与业务隔离，利于维护。</p>\n<pre><code class=\"js\">function useMyCounter(){\n  // .... 略\n  return { num, bigNum. addNum, addNumBig, numBtnColor, bigNumBtnColor}\n}</code></pre>\n<h2>concent setup</h2>\n<p><code>hook</code>函数在每一轮渲染期间一定是需要全部重新执行一遍的，所以不可避免的在每一轮渲染期间都会产生大量的临时闭包函数，如果我们能省掉他们，的确能帮gc减轻一些回收压力的，现在我们来看看使用<code>setup</code>改造完毕后的Counter会是什么样子吧。</p>\n<p>使用<code>concent</code>非常简单，只需要在根组件之前，先使用<code>run</code>api启动即可，因此处我们没有模块定义，直接调用就可以了。</p>\n<pre><code class=\"js\">import { run } from 'concent';\n\nrun();// 先启动，在render\nReactDOM.render(&lt;App /&gt;, rootEl)\n</code></pre>\n<p>接着我们将以上逻辑稍加改造，全部包裹到<code>setup</code>内部，setup函数内部的逻辑只会被执行一次，需要用到的由渲染上下文<code>ctx</code>提供的api有<code>initState</code>、<code>computed</code>、 <code>effect</code>、 <code>setState</code>，同时配合<code>setState</code>调用时还需要读取的状态<code>state</code>，也由<code>ctx</code>获得。</p>\n<pre><code class=\"js\">function setup(ctx) {// 渲染上下文\n  const { initState, computed, effect, state, setState } = ctx;\n  // setup仅在组件首次渲染之前执行一次，我们可在内部书写相关业务逻辑\n}</code></pre>\n<h3>initState</h3>\n<p><code>initState</code>用于初始化状态，替代了<code>useState</code>，当我们的组件状态较大时依然可以不用考虑如何切分状态粒度。</p>\n<pre><code class=\"js\">initState({ num: 6, bigNum: 120 });</code></pre>\n<p>此处也支持函数是写法初始化状态</p>\n<pre><code class=\"js\">initState(()=&gt;({ num: 6, bigNum: 120 }));</code></pre>\n<h3>computed</h3>\n<p><code>computed</code>用于定义计算函数，从参数列表里解构时就确定了计算的输入依赖，相比<code>useMemo</code>，更直接与优雅。</p>\n<pre><code class=\"js\">// 仅当num发生变化时，才触发此计算函数\ncomputed('numBtnColor', ({ num }) =&gt; (num &gt; 100 ? 'red' : 'green'));</code></pre>\n<p>此处我们需要定义两个计算函数，可以用你计算对象描述体来配置计算函数，这样只需调用一次<code>computed</code>即可</p>\n<pre><code class=\"js\">computed({\n  numBtnColor: ({ num }) =&gt; num &gt; 100 ? 'red' : 'green',\n  bigNumBtnColor: ({ bigNum }) =&gt; bigNum &gt; 1000 ? 'purple' : 'green',\n});</code></pre>\n<h3>effect</h3>\n<p><code>effect</code>的用法和<code>useEffect</code>是一模一样的，区别仅仅是依赖数组仅传入key名称即可，同时<code>effect</code>内部将函数组件和类组件的生命周期进行了统一封装，用户可以将业务不做任何修改便迁移到类组件身上</p>\n<pre><code class=\"js\">effect(() =&gt; {\n  if (state.bigNum &gt; 10000) api.report('reach 10000')\n}, ['bigNum'])\neffect(() =&gt; {\n  // 这里可以书写首次渲染完毕时需要做的事情\n  return () =&gt; {\n      // 卸载时触发的清理函数\n    api.reportStat(state.num, state.bigNum)\n  }\n}, []);</code></pre>\n<h3>setState</h3>\n<p>用于修改状态，我们在<code>setup</code>内部基于<code>setState</code>定义完方法后，然后返回即可，接着我们可以在任意使用此<code>setup</code>的组件里，通过<code>ctx.settings</code>拿到这些方法句柄便可调用</p>\n<pre><code class=\"js\">function setup(ctx) {// 渲染上下文\n  const { state, setState } = ctx;\n  return {// 导出方法\n    addNum: () =&gt; setState({ num: state.num + 1 }),\n    addNumBig: () =&gt; setState({ bigNum: state.bigNum + 100 }),\n  }\n}</code></pre>\n<h3>完整的Setup Counter</h3>\n<p>基于上述几个api，我们最终的Counter的逻辑代码如下</p>\n<pre><code class=\"js\">function setup(ctx) {// 渲染上下文\n  const { initState, computed, effect, state, setState } = ctx;\n  // 初始化数据\n  initState({ num: 6, bigNum: 120 });\n  // 定义计算函数\n  computed({\n    // 参数列表解构时就确定了计算的输入依赖\n    numBtnColor: ({ num }) =&gt; num &gt; 100 ? 'red' : 'green',\n    bigNumBtnColor: ({ bigNum }) =&gt; bigNum &gt; 1000 ? 'purple' : 'green',\n  });\n  // 定义副作用\n  effect(() =&gt; {\n    if (state.bigNum &gt; 10000) api.report('reach 10000')\n  }, ['bigNum'])\n  effect(() =&gt; {\n    return () =&gt; {\n      api.reportStat(state.num, state.bigNum)\n    }\n  }, []);\n\n  return {// 导出方法\n    addNum: () =&gt; setState({ num: state.num + 1 }),\n    addNumBig: () =&gt; setState({ bigNum: state.bigNum + 100 }),\n  }\n}</code></pre>\n<p>定义完核心的业务逻辑，紧接着，我们可在任意函数组件内部使用<code>useConcent</code>装配我们定义好的<code>setup</code>来使用它了，<code>useConcent</code>会返回一个渲染上下文（和setup函数参数列表里指的是同一个对象引用，有时我们也称实例上下文），我们可按需获从<code>ctx</code>上取出目标数据和方法，针对此示例，我们可以导出<br><code>state</code>(数据)，<code>settings</code>(setup打包返回的法法)，<code>refComputed</code>(实例的计算函数结果容器)这3个key来使用即可。</br></p>\n<pre><code class=\"js\">import { useConcent } from 'concent';\n\nfunction NewCounter() {\n  const { state, settings, refComputed } = useConcent(setup);\n  // const { num, bigNum } = state;\n  // const { addNum, addNumBig } = settings;\n  // const { numBtnColor, bigNumBtnColor } = refComputed;\n}</code></pre>\n<p>我们上面提到<code>setup</code>同样可以装配给类组件，使用<code>register</code>即可，需要注意的是装配后的类组件，可以从<code>this.ctx</code>上直接获取<code>concent</code>为其生成的渲染上下文，同时呢<code>this.state</code>和<code>this.ctx.state</code>是等效的，<code>this.setState</code>和<code>this.ctx.setState</code>也是等效的，方便用户代码0改动即可接入<code>concent</code>使用。</p>\n<pre><code class=\"js\">import { register } from 'concent';\n\n@register(setup)\nclass NewClsCounter extends Component{\n  render(){\n   const { state, settings, refComputed } = this.ctx;\n  }\n}</code></pre>\n<h2>结语</h2>\n<p>对比原生hook，<code>setup</code>将业务逻辑固定在只会被执行一次的函数内部，提供了更友好的api，且同时完美兼容类组件与函数组件，让用户可以逃离<code>hook</code>的使用规则烦恼（想想看 useEffect 配合 useRef，是不是都有不小的认知成本？）,而不是将这些约束学习障碍转嫁给用户， 同时对gc也更加友好了，相信大家都已默认了<code>hook</code>是<code>react</code>的一个重要发明，但是其实它不是针对用户的，而是针对框架的，用户其实是不需要了解那些烧脑的细节与规则的，而对于concent用户来说，其实只需一个钩子开启一个传送门，即可在另一个空间内部实现所有业务逻辑，而且这些逻辑同样可以复用到类组件上。</p>\n<p>亲爱的客官看了这么多，还不赶紧上手试试，以下提供了两种写法的链接，供你把玩😀</p>\n<li>\n <ul>\n  <li><a href=\"https://codesandbox.io/s/hook-counter-cu1i9\" rel=\"nofollow noreferrer\">原始hook Counter</a></li>\n </ul></li>\n<ul>\n <li><a href=\"https://codesandbox.io/s/setup-counter-y7g0u\" rel=\"nofollow noreferrer\">setup Counter</a></li>\n</ul>\n<h3>one more thing</h3>\n<p>上诉两个hook Counter如果想做状态共享，我们需要改造代码接入<code>redux</code>或者自建<code>Context</code>，但是在<code>concent</code>的开发模式下，<code>setup</code>无需任何改造，仅仅只需要提前声明一个模块，然后注册组件内属于该模块即可，这种丝滑般的迁移过程可以让用户灵活应对各种复杂场景。</p>\n<pre><code class=\"js\">import { run } from 'concent';\n\nrun({\n  counter:{\n    state: { num:88, bigNum: 120 },\n  },\n  //reducer: {...}, // 如操作数据流程复杂，可再将业务提升到此处\n})\n\n// 对于函数组件\nuseConcent({setup});\n//  ---&gt; 改为\nuseConcent({setup, module:'counter'})\n\n// 对于函数组件\n@register({setup});\n//  ---&gt; 改为\n@register({setup, module:'counter'});</code></pre>\n<ul>\n <li><a href=\"https://codesandbox.io/s/shared-counter-hetl9\" rel=\"nofollow noreferrer\">shared Counter</a></li>\n</ul>\n<h2>完</h2>\n<p>往期文章</p>\n<ul>\n <li><a href=\"https://segmentfault.com/a/1190000022935695\">细聊Concent &amp; Recoil , 探索react数据流的新开发模式</a></li>\n <li><a href=\"https://segmentfault.com/a/1190000022332809\">redux、mobx、concent特性大比拼, 看后生如何对局前辈</a></li>\n</ul>\n<p><a href=\"https://github.com/concentjs/concent\" rel=\"nofollow noreferrer\">❤ star me if you like concent ^_^</a></p>\n<p><a href=\"https://codesandbox.io/s/concent-guide-xvcej\" rel=\"nofollow noreferrer\">Edit on CodeSandbox</a><br><img src=\"https://segmentfault.com/img/remote/1460000022332831\" alt=\"https://codesandbox.io/s/concent-guide-xvcej\" title=\"https://codesandbox.io/s/concent-guide-xvcej\" /></br></p>\n<p><a href=\"https://stackblitz.com/edit/cc-multi-ways-to-wirte-code\" rel=\"nofollow noreferrer\">Edit on StackBlitz</a><br><img src=\"https://segmentfault.com/img/remote/1460000022332833\" alt=\"https://stackblitz.com/edit/cc-multi-ways-to-wirte-code\" title=\"https://stackblitz.com/edit/cc-multi-ways-to-wirte-code\" /></br></p>","descriptionType":"html","publishedDate":"Sun, 16 Aug 2020 11:03:39 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023648367","linkMd5":"47f945d0758f841a94d5a32def62ad1a","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn98@2020_1/2020/08/24/23-08-22-613_13d61e813eca2336.webp","destWidth":800,"destHeight":337,"sourceBytes":128310,"destBytes":26444,"author":"钟正楷","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023648367":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn98@2020_1/2020/08/24/23-08-22-613_13d61e813eca2336.webp","https://segmentfault.com/img/remote/1460000022332831":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn54@2020_6/2020/08/24/23-08-33-768_ab7bb1a669ed6d43.webp","https://segmentfault.com/img/remote/1460000022332833":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn62@2020_5/2020/08/24/23-08-34-275_d188d26ff603bb94.webp"},"publishedOrCreatedDate":1598310388567},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"Spark优化之小文件是否需要合并?","link":"https://segmentfault.com/a/1190000023604337","description":"<p>我们知道，大部分Spark计算都是在内存中完成的，所以Spark的瓶颈一般来自于集群(standalone, yarn, mesos, k8s)的资源紧张，CPU，网络带宽，内存。Spark的性能，想要它快，就得充分利用好系统资源，尤其是内存和CPU。有时候我们也需要做一些优化调整来减少内存占用，例如将小文件进行合并的操作。</p>\n<h2>一、问题现象</h2>\n<p>我们有一个15万条总数据量133MB的表，使用SELECT * FROM bi.dwd_tbl_conf_info全表查询耗时3min，另外一个500万条总数据量6.3G的表ods_tbl_conf_detail，查询耗时23秒。两张表均为列式存储的表。</p>\n<p>大表查询快，而小表反而查询慢了，为什么会产生如此奇怪的现象呢？</p>\n<h2>二、问题探询</h2>\n<p>数据量6.3G的表查询耗时23秒，反而数据量133MB的小表查询耗时3min，这非常奇怪。我们收集了对应的建表语句，发现两者没有太大的差异，大部分为String，两表的列数也相差不大。</p>\n<pre><code class=\"text\">CREATE TABLE IF NOT EXISTS  `bi`.`dwd_tbl_conf_info`  (\n  `corp_id` STRING COMMENT '',\n  `dept_uuid` STRING COMMENT '',\n  `user_id` STRING COMMENT '',\n  `user_name` STRING COMMENT '',\n  `uuid` STRING COMMENT '',\n  `dtime` DATE COMMENT '',\n  `slice_number` INT COMMENT '',\n  `attendee_count` INT COMMENT '',\n  `mr_id` STRING COMMENT '',\n  `mr_pkg_id` STRING COMMENT '',\n  `mr_parties` INT COMMENT '',\n  `is_mr` TINYINT COMMENT 'R',\n  `is_live_conf` TINYINT COMMENT ''\n)</code></pre>\n<pre><code class=\"text\">CREATE TABLE IF NOT EXISTS `bi`.`ods_tbl_conf_detail` (\n    `id` string,\n    `conf_uuid` string,\n    `conf_id` string,\n    `name` string,\n    `number` string,\n    `device_type` string,\n    `j_time` bigint,\n    `l_time` bigint,\n    `media_type` string,\n    `dept_name` string,\n    `UPDATETIME` bigint,\n    `CREATETIME` bigint,\n    `user_id` string,\n    `USERAGENT` string,\n    `corp_id` string,\n    `account` string\n  )</code></pre>\n<p>因为两张表均为很简单的SELECT查询操作，无任何复杂的聚合join操作，也无UDF相关的操作，所以基本确认查询慢的应该发生的读表的时候，我们将怀疑的点放到了读表操作上。通过查询两个查询语句的DAG和任务分布，我们发现了不一样的地方。</p>\n<p>查询快的表，查询时总共有68个任务，任务分配比如均匀，平均7~9s左右，而查询慢的表，查询时总共1160个任务，平均也是9s左右。如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023604341\" alt=\"\" title=\"\" /></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023604340\" alt=\"\" title=\"\" /></p>\n<p>至此，我们基本发现了猫腻所在。大表6.3G但文件个数小，只有68个，所以很快跑完了。而小表虽然只有133MB，但文件个数特别多，导致产生的任务特别多，而由于单个任务本身比较快，大部分时间花费在任务调度上，导致任务耗时较长。</p>\n<p>那如何才能解决小表查询慢的问题呢？</p>\n<h2>三、业务调优</h2>\n<p>那现在摆在我们面前就存在现在问题：</p>\n<p>1、为什么小表会产生这么小文件</p>\n<p>2、已经产生的这么小文件如何合并</p>\n<p>带着这两个问题，我们和业务的开发人员聊了一个发现小表是业务开发人员从原始数据表中，按照不同的时间切片查询并做数据清洗后插入到小表中的，而由于时间切片切的比较小，导致这样的插入次数特别多，从而产生了大量的小文件。</p>\n<p>那么我们需要解决的问题就是2个，如何才能把这些历史的小文件进行合并以及如何才能保证后续的业务流程中不再产生小文件，我们指导业务开发人员做了以下优化：</p>\n<p>1）使用INSERT OVERWRITE bi.dwd_tbl_conf_info SELECT * FROM bi.dwd_tbl_conf_info合并下历史的数据。由于DLI做了数据一致性保护，OVERWRITE期间不影响原有数据的读取和查询，OVERWRITE之后就会使用新的合并后的数据。合并后全表查询由原来的3min缩短到9s内完成。</p>\n<p>2）原有表修改为分区表，插入时不同时间放入到不同分区，查询时只查询需要的时间段内的分区数据，进一步减小读取数据量。</p>\n<p><a href=\"https://bbs.huaweicloud.com/blogs/187212?utm_source=segmentfault&amp;utm_medium=bbs-ex&amp;utm_campaign=ei&amp;utm_content=content\" rel=\"nofollow noreferrer\"><strong>点击关注，第一时间了解华为云新鲜技术~</strong></a></p>","descriptionType":"html","publishedDate":"Thu, 13 Aug 2020 03:03:41 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023604341","linkMd5":"7fbcd44c2485b915a169b959a08502eb","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn90@2020_2/2020/08/24/23-08-22-943_ebf9b33d099efdb6.webp","destWidth":720,"destHeight":365,"sourceBytes":32507,"destBytes":23038,"author":"华为云开发者社区","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023604341":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn90@2020_2/2020/08/24/23-08-22-943_ebf9b33d099efdb6.webp","https://segmentfault.com/img/remote/1460000023604340":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn95@2020_3/2020/08/24/23-08-44-556_9e65854396b9e3eb.webp"},"publishedOrCreatedDate":1598310388568},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"从零搭建 Node.js 企业级 Web 服务器（十五）：总结与展望","link":"https://segmentfault.com/a/1190000023653863","description":"<h2>总结</h2>\n<p>截止到本章 “从零搭建 Node.js 企业级 Web 服务器” 主题共计 16 章内容就更新完毕了，回顾第零章曾写道：</p>\n<blockquote>\n <strong>搭建一个 Node.js 企业级 Web 服务器并非难事，只是必须做好几个关键事项</strong>\n</blockquote>\n<p>这几件必须做好的关键事项就是到目前为止每个章节聊到的各个内容，为方便查阅整理成以下表格：</p>\n<table>\n <thead>\n  <tr>\n   <th align=\"left\">序号</th>\n   <th align=\"left\">标题</th>\n   <th align=\"left\">代码</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td align=\"left\">第零章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023311123\">静态服务</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/00-static\" rel=\"nofollow noreferrer\">00-static</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第一章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023324135\">接口与分层</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/01-api-and-layering\" rel=\"nofollow noreferrer\">01-api-and-layering</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第二章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023340748\">校验</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/02-validate\" rel=\"nofollow noreferrer\">02-validate</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第三章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023351467\">中间件</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/03-middleware\" rel=\"nofollow noreferrer\">03-middleware</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第四章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023368597\">异常处理</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/04-exception\" rel=\"nofollow noreferrer\">04-exception</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第五章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023375620\">数据库访问</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/05-database\" rel=\"nofollow noreferrer\">05-database</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第六章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023388061\">会话</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/06-session\" rel=\"nofollow noreferrer\">06-session</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第七章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023410877\">认证登录</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/07-authentication\" rel=\"nofollow noreferrer\">07-authentication</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第八章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023428158\">网络安全</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/08-security\" rel=\"nofollow noreferrer\">08-security</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第九章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023443092\">配置项</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/09-config\" rel=\"nofollow noreferrer\">09-config</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第十章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023454393\">日志</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/10-log\" rel=\"nofollow noreferrer\">10-log</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第十一章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023469997\">定时任务</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/11-schedule\" rel=\"nofollow noreferrer\">11-schedule</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第十二章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023495075\">远程调用</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/12-rpc\" rel=\"nofollow noreferrer\">12-rpc</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第十三章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023520714\">断点调试与性能分析</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/13-debugging-and-profiling\" rel=\"nofollow noreferrer\">13-debugging-and-profiling</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第十四章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023648009\">自动化测试</a></td>\n   <td align=\"left\"><a href=\"https://github.com/host1-tech/nodejs-server-examples/tree/master/14-testing\" rel=\"nofollow noreferrer\">14-testing</a></td>\n  </tr>\n  <tr>\n   <td align=\"left\">第十五章</td>\n   <td align=\"left\"><a href=\"https://segmentfault.com/a/1190000023653863\">总结与展望</a></td>\n   <td align=\"left\">-</td>\n  </tr>\n </tbody>\n</table>\n<p>本文已同步收录于 Github 示例代码仓库 <a href=\"https://github.com/host1-tech/nodejs-server-examples\" rel=\"nofollow noreferrer\">host1-tech/nodejs-server-examples</a>，可以 Star 或 Fork 收藏。</p>\n<p>感谢一路以来读者朋友们的关注与支持，给了我坚持的动力。感谢指出不足并给出改进建议的朋友们，让本文更加的严谨。</p>\n<h2>展望</h2>\n<p>有些 Java 背景的开发者会对 Node.js 持有怀疑，其实大可不必。能否建成强大稳定的企业级 Web 服务器的症结不在于业务逻辑是运行在 Node.js 还是 JVM 上，而在于企业级 Web 服务器的关键事项能否得到妥当处理。Node.js 经过十余年的发展，具备了非常完善的社区储备与方案沉淀来解决企业级 Web 服务器的各种问题，Netflix、PayPal、Uber、阿里、腾讯等大中型企业规模化使用 Node.js 开发服务器已有多年，再加上 Node.js 高性能 IO 设计与 JS 人才复用带来的成本节省，许多初创小微企业也开始纷纷首选 Node.js 进行开发服务器。随着云原生技术的发展，通用能力逐渐下沉，单个节点技术栈的影响一点点被淡化，使用老技术栈实现业务逻辑变得不再必要，为 Node.js 技术栈的应用与发展进一步带来更多的机会。</p>\n<p>笔者十分看好 Node.js 的当下与未来，通过本文希望更多的人能够了解 Node.js、接受 Node.js、使用 Node.js、喜欢 Node.js。本文只着重表述了 Web 后端技术本身内容，更全面的实践我会尝试以开源项目的方式沉淀下来，届时还希望读者朋友们不吝赐教，也欢迎有兴趣的朋友们共同参与。</p>\n<h2>更多阅读</h2>\n<p><a href=\"https://segmentfault.com/a/1190000023311123\">从零搭建 Node.js 企业级 Web 服务器（零）：静态服务</a> <br><a href=\"https://segmentfault.com/a/1190000023324135\">从零搭建 Node.js 企业级 Web 服务器（一）：接口与分层</a> <br><a href=\"https://segmentfault.com/a/1190000023340748\">从零搭建 Node.js 企业级 Web 服务器（二）：校验</a> <br><a href=\"https://segmentfault.com/a/1190000023351467\">从零搭建 Node.js 企业级 Web 服务器（三）：中间件</a> <br><a href=\"https://segmentfault.com/a/1190000023368597\">从零搭建 Node.js 企业级 Web 服务器（四）：异常处理</a> <br><a href=\"https://segmentfault.com/a/1190000023375620\">从零搭建 Node.js 企业级 Web 服务器（五）：数据库访问</a> <br><a href=\"https://segmentfault.com/a/1190000023388061\">从零搭建 Node.js 企业级 Web 服务器（六）：会话</a> <br><a href=\"https://segmentfault.com/a/1190000023410877\">从零搭建 Node.js 企业级 Web 服务器（七）：认证登录</a> <br><a href=\"https://segmentfault.com/a/1190000023428158\">从零搭建 Node.js 企业级 Web 服务器（八）：网络安全</a> <br><a href=\"https://segmentfault.com/a/1190000023443092\">从零搭建 Node.js 企业级 Web 服务器（九）：配置项</a> <br><a href=\"https://segmentfault.com/a/1190000023454393\">从零搭建 Node.js 企业级 Web 服务器（十）：日志</a> <br><a href=\"https://segmentfault.com/a/1190000023469997\">从零搭建 Node.js 企业级 Web 服务器（十一）：定时任务</a> <br><a href=\"https://segmentfault.com/a/1190000023495075\">从零搭建 Node.js 企业级 Web 服务器（十二）：远程调用</a> <br><a href=\"https://segmentfault.com/a/1190000023520714\">从零搭建 Node.js 企业级 Web 服务器（十三）：断点调试与性能分析</a><br><a href=\"https://segmentfault.com/a/1190000023648009\">从零搭建 Node.js 企业级 Web 服务器（十四）：自动化测试</a><br>从零搭建 Node.js 企业级 Web 服务器（十五）：总结与展望</br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></p>","descriptionType":"html","publishedDate":"Mon, 17 Aug 2020 03:21:07 +0000","feedId":6615,"bgimg":"","linkMd5":"f5c416c4a565f3e0e270206e2f8d5e93","bgimgJsdelivr":"","metaImg":"","author":"乌柏木","publishedOrCreatedDate":1598310388565},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"阿里的秒杀系统是怎么设计的？","link":"https://segmentfault.com/a/1190000023651246","description":"<h2>背景</h2>\n<p>我之前写过一个秒杀系统的文章不过有些许瑕疵，所以我准备在之前的基础上进行二次创作，不过让我决心二创秒杀系统的原因是我最近面试了很多读者，动不动就是秒杀系统把我整蒙蔽了，我懵的主要是秒杀系统的细节大家都不知道，甚至不知道电商公司一个秒杀系统的组成部分。</p>\n<p>我之前在某电商公司就是做电商活动的，所以这样的场景和很多解决方案我是比较清楚的，那我就从我自身去带着大家看看一个秒杀的设计细节以及中间各种解决方案的利弊，以下就是我设计的秒杀系统，几乎涵盖了市面上所有秒杀的实现细节：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023517942\" alt=\"\" title=\"\" /></p>\n<h2>正文</h2>\n<p>首先设计一个系统之前，我们需要先确认我们的业务场景是怎么样子的，我就<strong>带着大家一起假设一个场景</strong>好吧。</p>\n<p>我们现场要卖1000件下面这个<strong>婴儿纸尿裤</strong>，然后我们根据以往这样秒杀活动的数据经验来看，目测来抢这100件纸尿裤的人足足有10万人。（南极人打钱！）</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023517943\" alt=\"\" title=\"\" /></p>\n<p>你一听，完了呀，这我们的服务器哪里顶得住啊！说真的直接打DB肯定挂，但是别急嘛，有<strong>暖男</strong>敖丙在，任何系统我们开始设计之前我们都应该去思考<strong>会出现哪些问题</strong>？这里我罗列了几个非常经典的问题：</p>\n<h2>问题</h2>\n<h4>高并发：</h4>\n<p>是的<strong>高并发</strong>这个是我们想都不用想的一个点，一瞬间这么多人进来这不是高并发什么时候是呢？</p>\n<p>是吧，秒杀的特点就是这样<strong>时间极短</strong>、 <strong>瞬间用户量大</strong>。</p>\n<p>正常的店铺营销都是用极低的价格配合上短信、APP的精准推送，吸引特别多的用户来参与这场秒杀，<strong>爽了商家苦了开发呀</strong>。</p>\n<p>秒杀大家都知道如果真的营销到位，价格诱人，几十万的流量我觉得完全不是问题，那单机的<strong>Redis</strong>我感觉3-4W的QPS还是能顶得住的，但是再高了就没办法了，那这个数据随便搞个热销商品的秒杀可能都不止了。</p>\n<p>大量的请求进来，我们需要考虑的点就很多了，<strong>缓存雪崩</strong>，<strong>缓存击穿</strong>，<strong>缓存穿透</strong>这些我之前提到的点都是有可能发生的，出现问题打挂DB那就很难受了，活动失败用户体验差，活动人气没了，最后背锅的还是<strong>开发</strong>。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023517944\" alt=\"\" title=\"\" /></p>\n<h4>超卖：</h4>\n<p>但凡是个秒杀，都怕<strong>超卖</strong>，我这里举例的只是尿不湿，要是换成100个MacBook Pro，商家的预算经费卖100个可以赚点还可以造势，结果你写错程序多卖出去200个，你不发货用户<strong>投诉你</strong>，平台<strong>封你店</strong>，你发货就<strong>血亏</strong>，你怎么办？ （没事看了敖丙的文章直接不怕）</p>\n<p>那最后只能<strong>杀个开发祭天</strong>解气了，秒杀的价格本来就低了，基本上都是不怎么赚钱的，超卖了就恐怖了呀，所以超卖也是很关键的一个点。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023517945\" alt=\"\" title=\"\" /></p>\n<h4>恶意请求：</h4>\n<p>你这么低的价格，假如我抢到了，我转手卖掉我不是<strong>血赚</strong>？就算我不卖我也不亏啊，那用户知道，你知道，别的别有用心的人（黑客、黄牛...）肯定也知道的。</p>\n<p>那简单啊，我知道你什么时候抢，我搞个几十台机器搞点脚本，我也模拟出来十几万个人左右的请求，那我是不是意味着我基本上有80%的成功率了。</p>\n<p>真实情况可能远远不止，因为机器请求的速度比人的手速往往快太多了，在贵州的敖丙我每年回家抢高铁票都是<strong>秒光</strong>的，我也不知道有没有黄牛的功劳，我要Diss你，黄牛。杰伦演唱会门票抢不到，我也Diss你。</p>\n<p>Tip：科普下，小道消息了解到的，黄牛的抢票系统，比国内很多小公司的系统还吊很多，架构设计都是顶级的，我用<strong>顶配的服务</strong>加上<strong>顶配的架构设计</strong>，你还想看演唱会？还想回家？</p>\n<p>不过不用黄牛我回家都难，我们云贵川跟我一样要回家过年的仔太多了555！</p>\n<h4>链接暴露：</h4>\n<p>前面几个问题大家可能都很好理解，一看到这个有的小伙伴可能会比较疑惑，啥是<strong>链接暴露</strong>呀？</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000021954610\" alt=\"\" title=\"\" /></p>\n<p>相信是个开发同学都对这个画面一点都不陌生吧，懂点行的仔都可以打开谷歌的<strong>开发者模式</strong>，然后看看你的网页代码，有的就有URL，但是我写VUE的时候是事件触发然后去调用文件里面的接口看源码看不到，但是我可以点击一下<strong>查看你的请求地址</strong>啊，不过你好像可以对按钮在秒杀前置灰。</p>\n<p>不管怎么样子都有危险，撇开外面的所有的东西你都挡住了，你卖这个东西实在便宜得过分，有诱惑力，你能保证<strong>开发不动心</strong>？开发知道地址，在秒杀的时候自己提前请求。。。（开发：怎么TM又是我）</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023517946\" alt=\"\" title=\"\" /></p>\n<h4>数据库：</h4>\n<p>每秒上万甚至十几万的<strong>QPS</strong>（每秒请求数）直接打到<strong>数据库</strong>，基本上都要把库打挂掉，而且你服务不单单是做秒杀的还涉及其他的业务，你没做<strong>降级、限流、熔断</strong>啥的，别的一起挂，小公司的话可能<strong>全站崩溃404</strong>。</p>\n<p>反正不管你秒杀怎么挂，你别把别的搞挂了对吧，搞挂了就不是杀一个程序员能搞定的。</p>\n<p>程序员：我TM好难啊！</p>\n<p><strong>问题都列出来了，那怎么设计，怎么解决这些问题就是接下去要考虑的了，我们对症下药。</strong></p>\n<p>我会从我设计的秒杀系统从上到下去给大家介绍我们正常电商秒杀系统在每一层做了些什么，每一层存在的问题，难点等。</p>\n<p>我们从前端开始：</p>\n<h2>前端</h2>\n<p>秒杀系统普遍都是商城网页、H5、APP、小程序这几项。</p>\n<p>在前端这一层其实我们可以做的事情有很多，如果用node去做，甚至能直接处理掉整个秒杀，但是node其实应该属于后端，所以我不讨论node Service了。</p>\n<h4>资源静态化：</h4>\n<p>秒杀一般都是特定的商品还有页面模板，现在一般都是前后端分离的，页面一般都是不会经过后端的，但是前端也要自己的服务器啊，那就把能提前放入<strong>cdn服务器</strong>的东西都放进去，反正把所有能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力。</p>\n<h4>秒杀链接加盐：</h4>\n<p>我们上面说了链接要是提前暴露出去可能有人直接访问url就提前秒杀了，那又有小伙伴要说了我做个时间的校验就好了呀，那我告诉你，知道链接的地址比起页面人工点击的还是有<strong>很大优势</strong>。</p>\n<p>我知道url了，那我通过程序不断获取最新的北京时间，可以达到<strong>毫秒级别</strong>的，我就在00毫秒的时候请求，我敢说绝对比你人工点的成功率大太多了，而且我可以一毫秒发送N次请求，搞不好你卖100个产品我全拿了。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023517947\" alt=\"\" title=\"\" /></p>\n<p><strong>那这种情况怎么避免？</strong></p>\n<p>简单，把<strong>URL动态化</strong>，就连写代码的人都不知道，你就通过MD5之类的摘要算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过。</p>\n<p>这个只能防止一部分没耐心继续破解下去的黑客，有耐心的人研究出来还是能破解，在电商场景存在很多这样的羊毛党，那怎么做呢？</p>\n<p>后面我会说。</p>\n<h4>限流：</h4>\n<p>限流这里我觉得应该分为<strong>前端限流</strong>和<strong>后端限流</strong>。</p>\n<p><strong>物理控制：</strong></p>\n<p>大家有没有发现没到秒杀前，一般按钮都是<strong>置灰</strong>的，只有时间到了，才能点击。</p>\n<p>这是因为怕大家在时间快到的最后几秒秒疯狂请求服务器，然后还没到秒杀的时候基本上服务器就挂了。</p>\n<p>这个时候就需要前端的配合，定时去请求你的后端服务器，获取最新的北京时间，到时间点再给按钮可用状态。</p>\n<p>按钮可以点击之后也得给他置灰几秒，不然他一样在开始之后一直点的。</p>\n<p><strong>你敢说你们秒杀的时候不是这样的？</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023517948\" alt=\"\" title=\"\" /></p>\n<p><strong>前端限流</strong>：这个很简单，一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。</p>\n<p><strong>后端限流</strong>：秒杀的时候肯定是涉及到后续的订单生成和支付等操作，但是都只是成功的幸运儿才会走到那一步，那一旦100个产品卖光了，return了一个false，前端直接秒杀结束，然后你后端也关闭后续无效请求的介入了。</p>\n<p>Tip：真正的限流还会有限流组件的加入例如：阿里的Sentinel、Hystrix等。我这里就不展开了，就说一下物理的限流。</p>\n<p>我们卖1000件商品，请求有10W，我们不需要把十万都放进来，你可以放1W请求进来，然后再进行操作，因为秒杀对于用户本身就是黑盒的，所以你怎么做的他们是没感知的，至于为啥放1W进来，而不是刚好1000，是因为会丢掉一些薅羊毛的用户，至于怎么判断，后面的风控阶段我会说。</p>\n<h2>Nginx：</h2>\n<p><strong>Nginx</strong>大家想必都不陌生了吧，这玩意是<strong>高性能的web服务器</strong>，并发也随便顶几万不是梦，但是我们的<strong>Tomcat</strong>只能顶几百的并发呀，那简单呀<strong>负载均衡</strong>嘛，一台服务几百，那就多搞点，在秒杀的时候多租点<strong>流量机</strong>。</p>\n<p>Tip：据我所知国内某大厂就是在去年春节活动期间租光了亚洲所有的服务器，小公司也很喜欢在双十一期间买流量机来顶住压力。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000021954612\" alt=\"\" title=\"\" /></p>\n<p><strong>这样一对比是不是觉得你的集群能顶很多了。</strong></p>\n<p><strong>恶意请求拦截</strong>也需要用到它，一般单个用户请求次数太夸张，不像人为的请求在网关那一层就得拦截掉了，不然请求多了他抢不抢得到是一回事，服务器压力上去了，可能占用网络带宽或者把<strong>服务器打崩、缓存击穿</strong>等等。</p>\n<h2>风控</h2>\n<p>我可以明确的告诉大家，前面的所有措施还是拦不住很多羊毛党，因为他们是专业的团队，他们可以注册很多账号来薅你的羊毛，而且不用机器请求，就用群控，操作几乎跟真实用户一模一样。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023517949\" alt=\"\" title=\"\" /></p>\n<p><strong>那怎么办，是不是无解了？</strong></p>\n<p>这个时候就需要风控同学的介入了，在请求到达后端之前，风控可以根据账号行为分析出这个账号机器人的概率大不大，我现在负责公司的某些特殊系统，每个用户的行为都是会送到我们大数据团队进行分析处理，给你打上对应标签的。</p>\n<p>那黑客其实也有办法：<strong>养号</strong></p>\n<p>他们去黑市买真实用户有过很多记录的账号，买到了还不闲着，帮他们去购物啥的，让系统无法识别他们是黑号还是真实用户的号。</p>\n<p><strong>怎么办？</strong></p>\n<p>通杀！是的没有办法，只能通杀了，通杀的意思就是，我们通过风管分析出来这个用户是真实用户的概率没有其他用户概率大，那就认为他是机器了，丢弃他的请求。</p>\n<p>之前的限流我们放进来10000个请求，但是我们真正的库存只有1000个，那我们就算出最有可能是真实用户的1000人进行秒杀，丢弃其他请求，因为秒杀本来就是黑盒操作的，用户层面是无感知的，这样设计能让真实的用户买到东西，还可以减少自己被薅羊毛的概率。</p>\n<p>风控可以说是流量进入的最后一道门槛了，所以很多公司的风控是很强的，蚂蚁金服的风控大家如果了解过就知道了，你的资金在支付宝被盗了，他们是能做到全款补偿是有原因的。</p>\n<h2>后端</h2>\n<h4>服务单一职责：</h4>\n<p>设计个能抗住高并发的系统，我觉得还是得<strong>单一职责</strong>。</p>\n<p>什么意思呢，大家都知道现在设计都是<strong>微服务的设计思想</strong>，然后再用<strong>分布式的部署方式</strong>。</p>\n<p>也就是我们下单是有个订单服务，用户登录管理等有个用户服务等等，那为啥我们不给秒杀也开个服务，我们把秒杀的代码业务逻辑放一起。</p>\n<p>单一职责的好处就是就算秒杀没抗住，秒杀库崩了，服务挂了，也不会影响到其他的服务。（高可用）</p>\n<h4>Redis集群：</h4>\n<p>之前不是说单机的<strong>Redis</strong>顶不住嘛，那简单多找几个兄弟啊，秒杀本来就是读多写少，那你们是不是瞬间想起来我之前跟你们提到过的，<strong>Redis集群</strong>，<strong>主从同步</strong>、<strong>读写分离</strong>，我们还搞点<strong>哨兵</strong>，开启<strong>持久化</strong>直接无敌高可用！</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000020937494\" alt=\"\" title=\"\" /></p>\n<h4>库存预热：</h4>\n<p><strong>秒杀的本质，就是对库存的抢夺</strong>，每个秒杀的用户来你都去数据库查询库存校验库存，然后扣减库存，撇开性能因数，你不觉得这样好繁琐，对业务开发人员都不友好，而且数据库顶不住啊。</p>\n<p><strong>开发：你tm总算为我着想一次了。</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023517950\" alt=\"\" title=\"\" /></p>\n<h4>那怎么办？</h4>\n<p>我们都知道数据库顶不住但是他的兄弟非关系型的数据库<strong>Redis</strong>能顶啊！</p>\n<p>那不简单了，我们要开始秒杀前你通过定时任务或者运维同学<strong>提前把商品的库存加载到Redis中</strong>去，让整个流程都在Redis里面去做，然后等秒杀介绍了，再异步的去修改库存就好了。</p>\n<p>但是用了Redis就有一个问题了，我们上面说了我们采用<strong>主从</strong>，就是我们会去读取库存然后再判断然后有库存才去减库存，正常情况没问题，但是高并发的情况问题就很大了。</p>\n<p>**多品几遍！！！**就比如现在库存只剩下1个了，我们高并发嘛，4个服务器一起查询了发现都是还有1个，那大家都觉得是自己抢到了，就都去扣库存，那结果就变成了-3，是的只有一个是真的抢到了，别的都是超卖的。咋办？</p>\n<h3>事务：</h3>\n<p>Redis本身是支持事务的，而且他有很多原子命令的，大家也可以用LUA，还可以用他的管道，乐观锁他也知支持。</p>\n<h4>限流&amp;降级&amp;熔断&amp;隔离：</h4>\n<p>这个为啥要做呢，不怕一万就怕万一，万一你真的顶不住了，<strong>限流</strong>，顶不住就挡一部分出去但是不能说不行，<strong>降级</strong>，降级了还是被打挂了，<strong>熔断</strong>，至少不要影响别的系统，<strong>隔离</strong>，你本身就独立的，但是你会调用其他的系统嘛，你快不行了你别拖累兄弟们啊。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023517951\" alt=\"\" title=\"\" /></p>\n<h4>消息队列（削峰填谷）：</h4>\n<p>一说到这个名词，很多小伙伴就知道了，对的<strong>MQ</strong>，你买东西少了你直接100个请求改库我觉得没问题，但是万一秒杀一万个，10万个呢？服务器挂了，<strong>程序员又要背锅的</strong>。</p>\n<p>秒杀就是这种瞬间流量很高，但是平时又没有流量的场景，那消息队列完全契合这样的场景了呀，削峰填谷。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023517952\" alt=\"\" title=\"\" /></p>\n<p>Tip：<strong>可能小伙伴说我们业务达不到这个量级，没必要。但是我想说我们写代码，就不应该写出有逻辑漏洞的代码，至少以后公司体量上去了，别人一看居然不用改代码，一看代码作者是敖丙？有点东西！</strong></p>\n<p>你可以把它放消息队列，然后一点点消费去改库存就好了嘛，不过单个商品其实一次修改就够了，我这里说的是<strong>某个点多个商品</strong>一起秒杀的场景，像极了双十一零点。</p>\n<h2>数据库</h2>\n<p>数据库用MySQL只要连接池设置合理一般问题是不大的，不过一般大公司不缺钱而且秒杀这样的活动十分频繁，我之前所在的公司就是这样秒杀特卖这样的场景一直都是不间断的。</p>\n<p>单独给秒杀建立一个数据库，为秒杀服务，表的设计也是竟可能的简单点，现在的互联网架构部署都是<strong>分库</strong>的。</p>\n<p>至于表就看大家怎么设计了，该设置索引的地方还是要设置索引的，建完后记得用<strong>explain</strong>看看<strong>SQL</strong>的执行计划。（不了解的小伙伴也没事，MySQL章节去康康）</p>\n<h2>分布式事务</h2>\n<p><strong>这为啥我不放在后端而放到最后来讲呢？</strong></p>\n<p>因为上面的任何一步都是可能出错的，而且我们是在不同的服务里面出错的，那就涉及分布式事务了，但是分布式事务大家想的是一定要成功什么的那就不对了，还是那句话，几个请求丢了就丢了，要保证时效和服务的可用可靠。</p>\n<p>所以<strong>TCC</strong>和<strong>最终一致性</strong>其实不是很适合，TCC开发成本很大，所有接口都要写三次，因为涉及TCC的三个阶段。</p>\n<p>最终一致性基本上都是靠轮训的操作去保证一个操作一定成功，那时效性就大打折扣了。</p>\n<p>大家觉得不那么可靠的**两段式（2PC）<strong>和</strong>三段式（3PC）**就派上用场了，他们不一定能保证数据最终一致，但是效率上还算ok。</p>\n<h2>总结</h2>\n<p>到这里我想我已经基本上把该考虑的点还有对应的解决方案也都说了一下，不知道还有没有没考虑到的，但是就算没考虑到我想我这个设计，应该也能撑住一个完整的秒杀流程。</p>\n<p>最后大家再看看这个秒杀系统或许会有新的感悟，是不是一个系统真的没有大家想的那么简单，而且我还是有漏掉的细节，这是一定的。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023517953\" alt=\"\" title=\"\" /></p>\n<p>秒杀这章我脑细胞死了很多，考虑了很多个点，最后还是出来了，忍不住给自己<strong>点赞</strong>！</p>\n<h2>总结</h2>\n<p>我们玩归玩，闹归闹，别拿面试开玩笑。</p>\n<p>秒杀不一定是每个同学都会问到的，至少肯定没<strong>Redis基础</strong>那样常问，但是一旦问到，大家一定要回答到点上。</p>\n<p>至少你得说出<strong>可能出现的情况</strong>，<strong>需要注意的情况</strong>，以及对于的<strong>解决思路和方案</strong>，因为这才是一个coder的基本素养，这些你不考虑你也很难去进步。</p>\n<p>最后就是需要对整个链路比较熟悉，注意是一个完整的链路，前端怎么设计的呀，网关的作用呀，怎么<strong>解决Redis的并发竞争</strong>啊，<strong>数据的同步方式</strong>呀，<strong>MQ的作用</strong>啊等等，相信你会有不错的收获。</p>\n<p>不知道这是一次成功还是失败的二创，我里面所有提到的技术细节我都写了对应的文章，大家可以关注我去历史文章看看，天色已晚，我溜了。</p>\n<p>我是敖丙，你知道的越多，你不知道的越多，我们下期见！</p>\n<p><strong>人才</strong>们的 <strong>【三连】</strong> 就是敖丙创作的最大动力，如果本篇博客有任何错误和建议，欢迎人才们留言！</p>","descriptionType":"html","publishedDate":"Mon, 17 Aug 2020 01:34:58 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023517942","linkMd5":"9a60a00d9e8d732bd6972e94bc783594","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn21@2020_1/2020/08/24/23-08-24-093_e49a8578e1b0f2ed.webp","destWidth":800,"destHeight":739,"sourceBytes":62742,"destBytes":34606,"author":"敖丙","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023517942":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn21@2020_1/2020/08/24/23-08-24-093_e49a8578e1b0f2ed.webp","https://segmentfault.com/img/remote/1460000023517943":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn61@2020_6/2020/08/24/23-08-28-873_ce700e4c9aab44af.webp","https://segmentfault.com/img/remote/1460000023517944":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn66@2020_6/2020/08/24/23-08-28-682_f7b01d199b4e2d10.webp","https://segmentfault.com/img/remote/1460000023517945":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn77@2020_2/2020/08/24/23-08-28-801_26cd4b8b48fcfbad.webp","https://segmentfault.com/img/remote/1460000021954610":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn16@2020_6/2020/08/24/23-08-41-359_7ed64be196d18b41.webp","https://segmentfault.com/img/remote/1460000023517946":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn81@2020_6/2020/08/24/23-08-28-792_8d547681cad5df9e.webp","https://segmentfault.com/img/remote/1460000023517947":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn70@2020_2/2020/08/24/23-08-28-578_118080821669f072.webp","https://segmentfault.com/img/remote/1460000023517948":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn74@2020_1/2020/08/24/23-08-28-514_112237e2027b570b.webp","https://segmentfault.com/img/remote/1460000021954612":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn19@2020_6/2020/08/24/23-08-39-691_173e40b0392302c0.webp","https://segmentfault.com/img/remote/1460000023517949":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn74@2020_1/2020/08/24/23-08-28-748_386e2ac4d66c0eef.webp","https://segmentfault.com/img/remote/1460000020937494":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn77@2020_2/2020/08/24/23-08-43-037_52b4b78e1ae44485.webp","https://segmentfault.com/img/remote/1460000023517950":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn30@2020_3/2020/08/24/23-08-28-488_a496bc91ec0bd42e.webp","https://segmentfault.com/img/remote/1460000023517951":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn42@2020_6/2020/08/24/23-08-28-736_f4da94180b1b7f17.webp","https://segmentfault.com/img/remote/1460000023517952":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn86@2020_1/2020/08/24/23-08-28-586_d34b134de0d771e7.webp","https://segmentfault.com/img/remote/1460000023517953":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn93@2020_4/2020/08/24/23-08-28-689_1ce65c690cf43f47.webp"},"publishedOrCreatedDate":1598310388566},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"活动回顾丨ALC Beijing 首场 Meetup：《开源到底有多难？》","link":"https://segmentfault.com/a/1190000023675512","description":"<p><img src=\"https://segmentfault.com/img/bVbLvba\" alt=\"Apache ShardingSphere PMC、京东数科高级 DBA 潘娟\" title=\"Apache ShardingSphere PMC、京东数科高级 DBA 潘娟\" /></p>\n<p>8月16日，ALC Beijing 的首次线下沙龙活动 —— 《开源到底有多难？》在微软大厦如期举行。本次沙龙主要是分享开源开发经验、探讨如何让开源项目更加茁壮成长，以及分享 ASF 管理和运作开源项目的成功之道。</p>\n<p>Apache 软件基金会成员、Apache 软件基金孵化器导师、ALC Beijing 发起人姜宁；Apache Flink 社区 PMC member 李钰；Apache DolphinScheduler 项目负责人、易观 CTO 郭炜；ASF Member、阿里巴巴 Tech Lead 孙金城（花名：金竹）；Apache APISIX PMC member、深圳支流科技创始人温铭；ALC Beijing member、开源布道师李建盛分别在本次活动中进行了分享与探讨。Apache ShardingSphere PMC、京东数科高级 DBA 潘娟为本次活动的特邀主持。</p>\n<p><img src=\"https://segmentfault.com/img/bVbLvcU\" alt=\"ALC Beijing 首场 Meetup：《开源到底有多难？》\" title=\"ALC Beijing 首场 Meetup：《开源到底有多难？》\" /></p>\n<h2>姜宁：“我们离生产开源还有很长的路要走”</h2>\n<p><img src=\"https://segmentfault.com/img/bVbLvde\" alt=\"Apache 软件基金会成员、Apache 软件基金孵化器导师、ALC Beijing 发起人姜宁\" title=\"Apache 软件基金会成员、Apache 软件基金孵化器导师、ALC Beijing 发起人姜宁\" /></p>\n<p>姜宁老师作为 ALC Beijing 的发起人，在本次沙龙活动的主题演讲环节中分享了 ALC Beijing 成立的初衷以及 ALC Beijing 目前的一些动态。</p>\n<p>姜宁老师在沙龙中分享到，我国作为全球最大开源消费国，ASF 在国内有广泛的群众基础，但全球的 300 多个项目中，只有 19 个项目来自中国。如何将这些开源项目用户发展转换成为社区的贡献者、开发者，甚至成为开源项目的发起者、维护者是一个值得深思的问题。</p>\n<p>成立 ALC Beijing 的初衷，就是想给大家做一些事情，通过活动给本地的开源爱好者一个聚在一起的机会，通过分享开源开发的经验，鼓励更多人参与到我们的开发过程中来，帮助本土的开源项目更好的发展。姜宁老师也表示希望更多同学可以先从志愿者开始，与社区多多互动，与 ALC Beijing 共同成长。</p>\n<h2>李钰：“做中文社区首先最需要解决的问题，是把入门的门槛降低”</h2>\n<p>李钰老师是 Apache Flink 社区 PMC member，在本次沙龙中主要进行了三部分内容的分享。</p>\n<p>首先李钰老师为在场和线上的同学进行了 Apache Flink 的背景以及发展历程的介绍。谈到 Flink 中文社区组建的原因，李钰老师表示是为了把 Apache Flink 在国内进行本土化，从 2018 年 6 月获得官方授权正式开始进行团队化运营，并面向开发者进行沉淀，通过组织线上或线下的活动，让圈子得到进一步的扩展。</p>\n<p>最后，李钰老师也分享了在组建中文社区过程中遇到的坑与困难，并结合自身团队的经历与大家分享了相对应的举措以及经验。</p>\n<p>“做中文社区首先最需要解决的问题，是把入门的门槛降低。”“要思考怎么样沉淀相关的资料，提供统一的入口，让初学者或者爱好者能够方便的获取信息，这个非常关键。”</p>\n<h2>郭炜：“真正的开源，是找到你的第一个开发者”</h2>\n<p><img src=\"https://segmentfault.com/img/bVbLvd2\" alt=\"Apache DolphinScheduler 项目负责人、易观 CTO 郭炜\" title=\"Apache DolphinScheduler 项目负责人、易观 CTO 郭炜\" /></p>\n<p>郭炜老师在本次沙龙活动中，主要和大家分享了本地开源项目如何才能走向世界。</p>\n<p>在分享中，郭炜老师首先和大家详细讲了 Dolphin Scheduler 项目进入 Apache 的故事。从一腔热血但无人问津，到发现开源的核心是产品理念以及找到“第一个开发者用户”，郭炜老师分享了易观曾走过一些弯路。</p>\n<p>为了推翻“在中国只有免费，没有开源”的说法，易观通过一年的筹备把内部使用的产品 Dolphin Scheduler 进行了开源，并顺利的加入 Apache 孵化器。</p>\n<p>在分享的最后，郭炜老师也分享了在屡败屡战的开源过程中收获的经验：</p>\n<ul>\n <li>开源，产品是基础，你要像火锅一样，自己来凝聚你的开发者；</li>\n <li>做开源，社区优先；</li>\n <li>开源是一种精神，是一辈子的事儿，需要不断的坚持、不断的努力。</li>\n</ul>\n<hr>\n <p>除了三位老师的主题分享外，与会嘉宾还针对部分开源相关问题进行了圆桌讨论，并与现场以及线上的观众进行了互动交流（详细的沙龙内容近期会于 SegmentFault 社区以及 ALC Beijing 官方渠道进行发布，敬请期待）。</p>\n <p><img src=\"https://segmentfault.com/img/bVbLveu\" alt=\"ALC Beijing 首场 Meetup：《开源到底有多难？》\" title=\"ALC Beijing 首场 Meetup：《开源到底有多难？》\" /></p>\n <p>本次沙龙活动的成功举办，代表 ALC Beijing 与其合作伙伴正在进一步推进开源文化以及开源项目的发展，也意味着开源从业者以及爱好者有了一个新的交流与沟通的平台、渠道。</p>\n <p>ALC Beijing 后续也将与开源合作伙伴共同致力于通过（但不限于）下述行动帮助开源爱好者更好的在 Apache 社区生根发芽：</p>\n <ul>\n  <li>举办线上和线下沙龙，将本地的开发者与用户聚焦在一起；</li>\n  <li>通过分享开源开发经验，鼓励更多的人参与到 ASF 的项目开发中来；</li>\n  <li>为 ASF 的项目寻找相互合作的机会，让这些项目能够更加茁壮的成长；</li>\n  <li>介绍 ASF 管理和运作开源项目的成功之道，帮助大家更好地运作开源项目。</li>\n </ul>\n <p>“在中国，开源的时代正在觉醒，需要每一位小伙伴不懈的努力，最终的让开源精神在中国拨云见日，遍地生花。”这是郭炜老师在沙龙活动中分享的一个观点，也是所有开源行业从业者共同的期许。</p>\n <p><img src=\"https://segmentfault.com/img/bVbLueg\" alt=\"ALC Beijing 首场 Meetup：《开源到底有多难？》\" title=\"ALC Beijing 首场 Meetup：《开源到底有多难？》\" /></p>\n <hr>\n  <p>SegmentFault 作为本次活动以及 ALC Beijing 的媒体合作伙伴，一直非常重视开源文化以及开源生态的传播与建设，并于今年 5 月份推出了<a href=\"https://segmentfault.com/a/1190000022680721\">「SFOSSP - 开源项目扶持计划」</a>，目前已经助力数十余个开源项目进行宣传推广。</p>\n  <p>后续也期待和 ALC Beijing 以及其他开源社区、开源项目团队、开源从业者共同打造开源生态，解决开源过程中的实际问题。</p>\n  <p><img src=\"https://segmentfault.com/img/bVbLuza\" alt=\"「SFOSSP - 开源项目扶持计划」\" title=\"「SFOSSP - 开源项目扶持计划」\" /></p>\n </hr>\n</hr>","descriptionType":"html","publishedDate":"Tue, 18 Aug 2020 09:28:15 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLvba","linkMd5":"8130037c23e0c993c51e97490b17f7b6","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn6@2020_1/2020/08/24/23-08-23-211_d89633fd6dfd81d7.webp","destWidth":800,"destHeight":534,"sourceBytes":513728,"destBytes":23052,"author":"徐九","articleImgCdnMap":{"https://segmentfault.com/img/bVbLvba":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn6@2020_1/2020/08/24/23-08-23-211_d89633fd6dfd81d7.webp","https://segmentfault.com/img/bVbLvcU":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn22@2020_1/2020/08/24/23-08-43-542_29a435c36e22e408.webp","https://segmentfault.com/img/bVbLvde":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn67@2020_4/2020/08/24/23-08-45-893_2b9c9b5a1aa9ddf4.webp","https://segmentfault.com/img/bVbLvd2":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn23@2020_3/2020/08/24/23-08-45-486_3343783897cb269e.webp","https://segmentfault.com/img/bVbLveu":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn4@2020_2/2020/08/24/23-08-45-148_de46592035a11e50.webp","https://segmentfault.com/img/bVbLueg":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn34@2020_1/2020/08/24/23-08-33-833_d914957c0890d0d6.webp","https://segmentfault.com/img/bVbLuza":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn27@2020_6/2020/08/24/23-08-38-440_fb92e27a6436323a.webp"},"publishedOrCreatedDate":1598310388562},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"精读《Tasks, microtasks, queues and schedules》","link":"https://segmentfault.com/a/1190000023652695","description":"<h2>1 引言</h2>\n<p>本周跟着 <a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" rel=\"nofollow noreferrer\">Tasks, microtasks, queues and schedules</a> 这篇文章一起深入理解这些概念间的区别。</p>\n<p>先说结论：</p>\n<ul>\n <li>Tasks 按顺序执行，浏览器可能在 Tasks 之间执行渲染。</li>\n <li><p>Microtasks 也按顺序执行，时机是：</p>\n  <ul>\n   <li>如果没有执行中的 js 堆栈，则在每个回调之后。</li>\n   <li>在每个 task 之后。</li>\n  </ul></li>\n</ul>\n<h2>2 概述</h2>\n<h3>Event Loop</h3>\n<p>在说这些概念前，先要介绍 Event Loop。</p>\n<p>首先浏览器是多线程的，每个 JS 脚本都在单线程中执行，每个线程都有自己的 Event Loop，同源的所有浏览器窗口共享一个 Event Loop 以便通信。</p>\n<p>Event Loop 会持续循环的执行所有排队中的任务，浏览器会为这些任务划分优先级，按照优先级来执行，这就会导致 Tasks 与 Microtasks 执行顺序与调用顺序的不同。</p>\n<h3>promise 与 setTimeout</h3>\n<p>看下面代码的输出顺序：</p>\n<pre><code>console.log(\"script&nbsp;start\");setTimeout(function&nbsp;()&nbsp;{&nbsp;&nbsp;console.log(\"setTimeout\");},&nbsp;0);Promise.resolve()&nbsp;&nbsp;.then(function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"promise1\");&nbsp;&nbsp;})&nbsp;&nbsp;.then(function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"promise2\");&nbsp;&nbsp;});console.log(\"script&nbsp;end\");</code></pre>\n<p>正确答案是 <code>script start</code>, <code>script end</code>, <code>promise1</code>, <code>promise2</code>, <code>setTimeout</code>，在线程中，同步脚本执行优先级最高，然后 promise 任务会存放到 Microtasks，setTimeout 任务会存放到 Tasks，Microtasks 会优先于 Tasks 执行。</p>\n<p>Microtasks 中文可以翻译为微任务，只要有 Microtasks 插入，就会不断执行 Microtasks 队列直到结束，在结束前都不会执行到 Tasks。</p>\n<h3>点击冒泡 + 任务</h3>\n<p>下面给出了更复杂的例子，提前说明后面的例子 Chrome、Firefox、Safari、Edge 浏览器的结果完全不一样，但只有 Chrome 的运行结果是对的！为什么 Chrome 是对的呢，请看下面的分析：</p>\n<pre><code>&lt;div&nbsp;class=\"outer\"&gt;&nbsp;&nbsp;&lt;div&nbsp;class=\"inner\"&gt;&lt;/div&gt;&lt;/div&gt;</code></pre>\n<pre><code>//&nbsp;Let's&nbsp;get&nbsp;hold&nbsp;of&nbsp;those&nbsp;elementsvar&nbsp;outer&nbsp;=&nbsp;document.querySelector(\".outer\");var&nbsp;inner&nbsp;=&nbsp;document.querySelector(\".inner\");//&nbsp;Let's&nbsp;listen&nbsp;for&nbsp;attribute&nbsp;changes&nbsp;on&nbsp;the//&nbsp;outer&nbsp;elementnew&nbsp;MutationObserver(function&nbsp;()&nbsp;{&nbsp;&nbsp;console.log(\"mutate\");}).observe(outer,&nbsp;{&nbsp;&nbsp;attributes:&nbsp;true,});//&nbsp;Here's&nbsp;a&nbsp;click&nbsp;listener…function&nbsp;onClick()&nbsp;{&nbsp;&nbsp;console.log(\"click\");&nbsp;&nbsp;setTimeout(function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"timeout\");&nbsp;&nbsp;},&nbsp;0);&nbsp;&nbsp;Promise.resolve().then(function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"promise\");&nbsp;&nbsp;});&nbsp;&nbsp;outer.setAttribute(\"data-random\",&nbsp;Math.random());}//&nbsp;…which&nbsp;we'll&nbsp;attach&nbsp;to&nbsp;both&nbsp;elementsinner.addEventListener(\"click\",&nbsp;onClick);outer.addEventListener(\"click\",&nbsp;onClick);</code></pre>\n<p>点击 <code>inner</code> 区块后，正确输出顺序应该是：</p>\n<pre><code>click\npromise\nmutate\nclick\npromise\nmutate\ntimeout\ntimeout</code></pre>\n<p>逻辑如下：</p>\n<ol>\n <li>点击触发 <code>onClick</code> 函数入栈。</li>\n <li>立即执行 <code>console.log('click')</code> 打印 <code>click</code>。</li>\n <li><code>console.log('timeout')</code> 入栈 Tasks。</li>\n <li><code>console.log('promise')</code> 入栈 microtasks。</li>\n <li><code>outer.setAttribute('data-random')</code> 的触发导致监听者 <code>MutationObserver</code> 入栈 microtasks。</li>\n <li><code>onClick</code> 函数执行完毕，此时线程调用栈为空，开始执行 microtasks 队列。</li>\n <li>打印 <code>promise</code>，打印 <code>mutate</code>，此时 microtasks 已空。</li>\n <li>执行冒泡机制，outer div 也触发 <code>onClick</code> 函数，同理，打印 <code>promise</code>，打印 <code>mutate</code>。</li>\n <li>都执行完后，执行 Tasks，打印 <code>timeout</code>，打印 <code>timeout</code>。</li>\n</ol>\n<h3>模拟点击冒泡 + 任务</h3>\n<p>如果将触发 <code>onClick</code> 行为由点击改为：</p>\n<pre><code>inner.click();</code></pre>\n<p>结果会不同吗？答案是会（单元测试与用户行为不符合，单测也有无解的时候）。然而四大浏览器的执行结果也是完全不一样，但从逻辑上讲仍然 Chrome 是对的，让我们看下 Chrome 的结果：</p>\n<pre><code>click\nclick\npromise\nmutate\npromise\ntimeout\ntimeout</code></pre>\n<p>逻辑如下：</p>\n<ol>\n <li><code>inner.click()</code> 触发 <code>onClick</code> 函数入栈。</li>\n <li>立即执行 <code>console.log('click')</code> 打印 <code>click</code>。</li>\n <li><code>console.log('timeout')</code> 入栈 Tasks。</li>\n <li><code>console.log('promise')</code> 入栈 microtasks。</li>\n <li><code>outer.setAttribute('data-random')</code> 的触发导致监听者 <code>MutationObserver</code> 入栈 microtasks。</li>\n <li>由于冒泡改为 js 调用栈执行，所以此时 js 调用栈未结束，不会执行 microtasks，反而是继续执行冒泡，outer 的 <code>onClick</code> 函数入栈。</li>\n <li>立即执行 <code>console.log('click')</code> 打印 <code>click</code>。</li>\n <li><code>console.log('timeout')</code> 入栈 Tasks。</li>\n <li><code>console.log('promise')</code> 入栈 microtasks。</li>\n <li><code>MutationObserver</code> 由于还没调用，因此这次 <code>outer.setAttribute('data-random')</code> 的改动实际上没有作用。</li>\n <li>js 调用栈执行完毕，开始执行 microtasks，按照入栈顺序，打印 <code>promise</code>，<code>mutate</code>，<code>promise</code>。</li>\n <li>microtasks 执行完毕，开始执行 Tasks，打印 <code>timeout</code>，<code>timeout</code>。</li>\n</ol>\n<h2>3 精读</h2>\n<p>基于任务调度这么复杂，且浏览器实现方式很不同，下面两件事是我很不推荐的：</p>\n<ol>\n <li>业务逻辑 “巧妙” 依赖了 microtasks 与 Tasks 执行逻辑的微妙差异。</li>\n <li>死记硬背调用顺序。</li>\n</ol>\n<p>且不说依赖了调用顺序的业务逻辑本身就很难维护，不同浏览器之间对任务调用顺序还是不同的，这可能源于对 W3C 标准规范理解的偏差，也可能是 BUG，这会导致依赖于此的逻辑非常脆弱。</p>\n<p>虽然上面两个例子非常复杂，但我们也不必把这个例子当作经典背诵，只要记住文章开头提到的执行逻辑就可以推导：</p>\n<ul>\n <li>Tasks 按顺序执行，浏览器可能在 Tasks 之间执行渲染。</li>\n <li><p>Microtasks 也按顺序执行，时机是：</p>\n  <ul>\n   <li>如果没有执行中的 js 堆栈，则在每个回调之后。</li>\n   <li>在每个 task 之后。</li>\n  </ul></li>\n</ul>\n<p>记住 <code>Promise</code> 是 <code>Microtasks</code>，<code>setTimeout</code> 是 <code>Tasks</code>，JS 一次 Event Loop 完毕后，即调用栈没有内容时才会执行 <code>Microtasks</code> -&gt; <code>Tasks</code>，在执行 <code>Microtasks</code> 过程中插入的 <code>Microtasks</code> 会按顺序继续执行，而执行 <code>Tasks</code> 中插入的 <code>Microtasks</code> 得等到调用栈执行完后才继续执行。</p>\n<p>上面说的内容都是指一次 Event Loop 时立即执行的优先级，不要和执行延迟时间弄混淆了。</p>\n<p>把 JS 线程的 Event Loop 当作一个函数，函数内同步逻辑执行优先级是最高的，如果遇到 <code>Microtasks</code> 或 <code>Tasks</code> 就会立即记录下来，当一次 Event Loop 执行完后立即调用 <code>Microtasks</code>，等 <code>Microtasks</code> 队列执行完毕后可能进行一些渲染行为，等这些浏览器操作完成后，再考虑执行 <code>Tasks</code> 队列。</p>\n<h2>4 总结</h2>\n<p>最后，还是要强调一句，不要依赖 <code>Microtasks</code> 与 <code>Tasks</code> 的执行顺序，尤其在申明式编程环境中，我们可以把 <code>Microtasks</code> 与 <code>Tasks</code> 都当作是异步内容，在渲染时做好状态判断即可，不用关心先后顺序。</p>\n<blockquote>\n 讨论地址是：\n <a href=\"https://github.com/dt-fe/weekly/issues/264\" rel=\"nofollow noreferrer\">精读《Tasks, microtasks, queues and schedules》· Issue #264 · dt-fe/weekly</a>\n</blockquote>\n<p><strong>如果你想参与讨论，请 <a href=\"https://github.com/dt-fe/weekly\" rel=\"nofollow noreferrer\">点击这里</a>，每周都有新的主题，周末或周一发布。前端精读 - 帮你筛选靠谱的内容。</strong></p>\n<blockquote>\n 关注 \n <strong>前端精读微信公众号</strong>\n</blockquote>\n<p><img src=\"https://segmentfault.com/img/remote/1460000018549678\" alt=\"\" title=\"\" /></p>\n<blockquote>\n 版权声明：自由转载-非商用-非衍生-保持署名（\n <a href=\"https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh\" rel=\"nofollow noreferrer\">创意共享 3.0 许可证</a>）\n</blockquote>","descriptionType":"html","publishedDate":"Mon, 17 Aug 2020 02:35:41 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000018549678","linkMd5":"77294d18bacb4a429bc351cad2ce49d1","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn62@2020_2/2020/08/24/23-08-22-916_a02e97e5e2b41934.webp","destWidth":258,"destHeight":258,"sourceBytes":20858,"destBytes":6490,"author":"黄子毅","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000018549678":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn62@2020_2/2020/08/24/23-08-22-916_a02e97e5e2b41934.webp"},"publishedOrCreatedDate":1598310388565},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"遇到「最值问题」还在无脑动态规划？二分法考虑一下呗","link":"https://segmentfault.com/a/1190000023677258","description":"<h1>目录</h1> \n<ol> \n <li><a href=\"https://segmentfault.com/a/1190000023677258#%E5%89%8D%E8%A8%80\">前言</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000023677258#%E4%BA%8C%E5%88%86%E6%B3%95%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%8F%98%E7%A7%8D%E7%BB%93%E6%9E%84\">二分法基础及变种结构</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000023677258#%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80\">小试牛刀</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000023677258#%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7\">打怪升级</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000023677258#%E5%87%BA%E5%B8%88%E8%AF%95%E7%82%BC\">出师试炼</a></li> \n</ol> \n<h1>前言</h1> \n<p>一般来说，遇到「最值问题」通用的方法都是动态规划，而有一类「最值问题」可以用其他方法更加巧妙、简单方便的解决，<strong>这类问题的常见问法是「使……最大值尽可能小」。</strong></p> \n<pre><code>这类问题也是大厂笔试面试常见题型，2020 年美团笔试题、字节面试题中都出现过。\n</code></pre> \n<p>这类问题有三大特征：</p> \n<ol> \n <li>求最值（一般是最小值）</li> \n <li>值的搜索空间是线性的</li> \n <li>对该值有一个限制条件，并且若 <code>x</code> 满足条件，则 <code>[x, +∞)</code> 都满足条件，反之 <code>(-∞, x]</code> 都不满足条件。</li> \n</ol> \n<p><img src=\"https://segmentfault.com/img/remote/1460000023677261\" alt=\"你说的我都懂，可问题是，这是啥意思呢？叉会腰，冷静一下\" title=\"你说的我都懂，可问题是，这是啥意思呢？叉会腰，冷静一下\"><br> &lt;center style=\"font-size:14px;color:#C0C0C0;text-decoration:underline\"&gt;你说的我都懂，可问题是，这是啥意思呢？叉会腰，冷静一下。&lt;/center&gt; </br></img></p> \n<p>为了方便大家理解这类问题到底是个什么玩意儿，本汪在这里列出 leetcode 上的一道题目作为例子：</p> \n<blockquote>\n  给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。 \n</blockquote> \n<p>不熟悉二分法的同学初遇此题，看到关键词“分割成 m 份”、“最小”，就想到了动态规划。诚然此题具备了使用动态规划的一切前提条件，也确实可以通过动态规划做出来，但其时间复杂度为 $O(n^2×m)$ , 空间复杂度为 $O(n*m)$. </p> \n<p>如果你看了本汪的这篇文章，学会了用二分法解决<strong>这一类问题</strong>，那么时间复杂度可以优化到 $O(n * logx)$， 空间复杂度可以优化到 $O(1)$，并且思路非常简洁，代码实现也极其简单。</p> \n<h1>二分法基础及变种结构</h1> \n<p>在讲具体的方法之前，本汪先和大家一起回顾下二分法，熟悉二分法的同学可以直接跳过这部分。</p> \n<p>最早接触二分思想的地方应该是在二分搜索中。（本质上类似快排中的 partition 思想）</p> \n<p>二分法是在<strong>有序线性搜索空间</strong>内，利用<strong>有序性</strong>，每次搜索通过排除一半的剩余搜索空间，使 $O(n)$ 级别的线性搜索优化到 $O(logn)$ 级别的方法。</p> \n<p><img src=\"https://segmentfault.com/img/bVbLvGs\" alt=\"image\" title=\"image\"><br> &lt;center style=\"font-size:14px;color:#C0C0C0;text-decoration:underline\"&gt;二叉树：我都会二分，不会还有人不会二分法吧？不会就让往西汪那小子教你&lt;/center&gt; </br></img></p> \n<p>二分法的基本代码非常简单，这里就不多提了，下面用类 java 语言给出其针对「最值问题」的变种结构：</p> \n<pre><code class=\"java\">// nums 数组是搜索空间，m 是限制条件\n// check(x, m) 表示在搜索空间 nums 中的点 x，满足了限制条件 m\npublic int binary(int[] nums, int m){  \n      初始化 l, r 为搜索空间的起始点和终点\n    while(l &lt; r){\n        int mid = (l + r) &gt;&gt; 1; //二分，一次搜索可以排除 mid 的左边或者右边(剩余搜索空间的一半)\n        if(check(mid, m)) r = mid; //因为这一类最值问题要找的是最小，mid 满足条件了，(mid, r] 就不是最小的答案了\n        else l = mid + 1; // mid 不满足条件，根据有序性，[l, mid] 里的数全不满足条件\n    }\n    return r;\n}</code></pre> \n<p>根据结构我们可以看出，遇到这类问题的时候只需要找到「搜索空间」、「检查条件」，然后套用结构就能<strong>轻轻松松</strong>地解决问题。</p> \n<p>下面就让我们来用二分法解决刚刚提到的问题。</p> \n<h1>小试牛刀</h1> \n<h2>题目</h2> \n<p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p> \n<h2>思路</h2> \n<p>前文提及，解决本题只需要找到「搜索空间」、「检查条件」，剩下的就是闭着眼睛套结构的事儿了。</p> \n<p>先找「搜索空间」，因为此类问题的搜索空间都是线性的，所以找到了<strong>起始点</strong>和<strong>终点</strong>，也就找到了搜索空间。</p> \n<p>看问题描述 “子数组各自和的最大值最小”，也就是说我们搜索的点是 \"子数组各自和的最大值\"，那么搜索空间的起始点是数组 nums 中的最大值，即 <code>min(nums)</code>，搜索空间的终点是数组 nums 中的所有元素之和，即 <code>sum(nums)</code>。因此我们找到了搜索空间，为 <code>[min(nums), sum(nums)]</code>.</p> \n<p>再看「检查条件」。给定搜索空间 nums，和点 x，判断 x 是否满足限制条件 m。</p> \n<p>本题的条件是“子数组各自和的最大值”，也就是说 x 和 m 个子数组各自和相比较，都要大于或者等于它们。</p> \n<p>「搜索空间」、「检查条件」都找到了，下面闭着眼睛套结构吧～</p> \n<p><img src=\"https://segmentfault.com/img/bVbLvGS\" alt=\"image\" title=\"image\"><br>&lt;center style=\"font-size:14px;color:#C0C0C0;text-decoration:underline\"&gt;(瑟瑟发抖.jpg) 好的，这就上代码&lt;/center&gt;</br></img></p> \n<h2>代码</h2> \n<pre><code class=\"java\">class Solution {\n      // 这个方法就是直接套结构\n    public int splitArray(int[] nums, int m) {\n        long l = 0, r = 0;\n        for(int num: nums) {r += num; l = Math.max(l, num);} // 初始化 l 和 r\n        while(l &lt; r) {\n            long mid = (l + r) &gt;&gt; 1;\n            if(check(nums, mid, m)) r = mid;\n            else l = mid + 1;\n        }\n        return (int)r;\n    }\n    \n    public boolean check(int[] nums, long a, int m) { // 给定搜索空间中的点 a，看它是否大于等于所有子数组的各自和\n        int cnt = 1;\n        long sum = 0;\n        for(int n: nums) {\n            sum += n;\n            if(sum &gt; a) {\n                sum = n;\n                cnt ++;\n                if(cnt &gt; m) return false;\n            }\n        }\n        return true;\n    }\n}</code></pre> \n<h1>打怪升级</h1> \n<p>咱们再来看一道题，小伙伴们可以先自己思考，有思路的话自己动手实现下。再看看本汪给出的思路，加深理解。</p> \n<h2>题目</h2> \n<p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p> \n<p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 </p> \n<p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p> \n<p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p> \n<p><img src=\"https://segmentfault.com/img/bVbLvGR\" alt=\"image\" title=\"image\" /></p> \n<p>&lt;center style=\"font-size:14px;color:#C0C0C0;text-decoration:underline\"&gt;往西汪：我请你们吃香蕉，可以给我点个赞吗&lt;/center&gt;</p> \n<h2>思路</h2> \n<p>老规矩，先找「搜索空间」，再找「检查条件」，最后闭着眼睛套结构。</p> \n<p>「搜索空间」：H 小时内必须吃完 <code>sum(piles)</code> 根香蕉，所以初始点为 <code>sum(piles) / H</code>，一次最多只能吃一堆，所以终点为 <code>max(piles)</code>。因此，搜索空间为 <code>[sum(piles) / H, max(piles)]</code>。</p> \n<p>「检查条件」：“在 H 小时内吃掉所有香蕉”，因此以 <code> K 个 / 小时</code> 的速度吃完香蕉的用时要小于等于 H。</p> \n<p>下面就闭着眼睛套结构吧。</p> \n<h2>代码</h2> \n<pre><code class=\"java\">class Solution {\n    public int minEatingSpeed(int[] piles, int H) {\n        int l = 1, r = 0; // 这里本汪为了代码的简洁性，在不影响时间复杂度的情况下，直接让初始点为 1\n        for(int i: piles) r = Math.max(r, i); // 一次最多吃一堆\n        while(l &lt; r){\n            int mid = (l + r) &gt;&gt; 1;\n            if(check(piles, mid, H)) r = mid;\n            else l = mid + 1;\n        }\n        return r;\n    }\n\n    boolean check(int[] piles, int K, int H){\n        int t = 0;\n        for(double i: piles){\n            t += Math.ceil(i / K); // 一堆香蕉共计 i 个，需要 ⌈i / K⌉ 个小时吃完\n            if(t &gt; H) return false; // 警卫回来了还没吃完\n        }\n        return true;\n    }\n}</code></pre> \n<h1>出师试炼</h1> \n<p>我非常喜欢看我文章的小伙伴，个个都是人才，说话又好听，脑瓜子又聪明，还很主动的给我文章点赞。我相信砍翻两个小怪之后，你们已经是这类问题的专家了，下面就给几道题目供大伙随便玩玩。</p> \n<p><img src=\"https://segmentfault.com/img/bVbLvGN\" alt=\"image\" title=\"image\"><br>&lt;center style=\"font-size:14px;color:#C0C0C0;text-decoration:underline\"&gt;超喜欢往西汪的文章的&lt;/center&gt;</br></img></p> \n<h2>关卡 1</h2> \n<p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p> \n<p>视频片段 <code>clips[i]</code> 都用区间进行表示：开始于 <code>clips[i][0]</code>并于 <code>clips[i][1]</code> 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。</p> \n<p>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。</p> \n<h2>关卡 2</h2> \n<p>牛牛有 n 件带水的衣服，干燥衣服有两种方式。</p> \n<p>一、是用烘干机，可以每分钟烤干衣服的 k 滴水。</p> \n<p>二、是自然烘干，每分钟衣服会自然烘干 1 滴水。</p> \n<p>烘干机比较小，每次只能放进一件衣服。</p> \n<p>注意，使用烘干机的时候，其他衣服仍然可以保持自然烘干状态，现在牛牛想知道最少要多少时间可以把衣服全烘干。</p> \n<h2>关卡 3</h2> \n<p>你太强了！我已经没有更多的题目给你玩了。你可以凭借这套武功闯荡江湖了！</p> \n<p>……</p> \n<p>……</p> \n<p>……</p> \n<p>等等，我说笑呢。你这小身板，要不先进我的其他训练营再练练呗？</p> \n<p>啥，你问我的其他训练营在哪里？动动小手，点个关注，新的训练营已经在建设了，嘿嘿。</p> \n<p><img src=\"https://segmentfault.com/img/bVbLvGJ\" alt=\"咳咳，暗示的很明显了\" title=\"咳咳，暗示的很明显了\"><br>&lt;center style=\"font-size:14px; color:#C0C0C0\"&gt;咳咳，暗示的很明显了&lt;/center&gt;</br></img></p>","descriptionType":"html","publishedDate":"Tue, 18 Aug 2020 11:19:33 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023677261","linkMd5":"81351ef5cee65b004bca5b0902fb9913","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn86@2020_6/2020/08/24/23-08-22-904_dce38b7c68cc1701.webp","destWidth":219,"destHeight":219,"sourceBytes":7088,"destBytes":6372,"author":"往西汪","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023677261":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn86@2020_6/2020/08/24/23-08-22-904_dce38b7c68cc1701.webp","https://segmentfault.com/img/bVbLvGs":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn23@2020_5/2020/08/24/23-08-37-100_402763b3dd71ef2c.webp","https://segmentfault.com/img/bVbLvGS":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn71@2020_5/2020/08/24/23-08-36-323_5b993b1029d81167.webp","https://segmentfault.com/img/bVbLvGR":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn68@2020_3/2020/08/24/23-08-36-191_c3fec51f8080522e.webp","https://segmentfault.com/img/bVbLvGN":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn38@2020_1/2020/08/24/23-08-33-674_5324ccda8059124e.webp","https://segmentfault.com/img/bVbLvGJ":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn57@2020_4/2020/08/24/23-08-33-915_ec37b2d3704c5497.webp"},"publishedOrCreatedDate":1598310388562},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"重磅丨科技教育公司“好未来”正式对外开源高性能PHP框架Fend","link":"https://segmentfault.com/a/1190000023636701","description":"<p><strong>好未来是一家以智慧教育和开放平台为主体，以素质教育和课外辅导为载体，在全球范围内服务公办教育，助力民办教育，探索未来教育新模式的科技教育公司。</strong></p>\n<p><strong>截至目前，好未来集团已围绕教育场景需求，累计研发包括图像、语音、数据挖掘、自然语言处理等8大类型、100多项AI能力，打造10余项教育场景应用AI解决方案。</strong></p>\n<p><strong>在技术不断提升的道路上，好未来技术线提出坚持“大中台、小前台”的技术战略，统一基础服务设施建设，推进公司技术组件落地，增强企业技术人才内生，不断提升企业的技术实力及技术影响力。</strong></p>\n<p><strong>除此之外，好未来内部坚持开源共享，通过“开放、共享、合力开发”的模式，推动开源文化氛围的形成与技术组织变革，为中台建设提供了另外一种抓手。同时通过开源文化的建设，促进整个教育生态技术共享，提升教育科技实力，更好的为“科技与爱让教育更美好”的愿景奠定基础。</strong></p>\n<p><strong>近期由“好未来”技术团队开源的高性能PHP框架Fend PHP正式上线！该框架单机QPS可达到4000个，好未来内部目前超过30个团队项目在使用该PHP框架！</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023636705\" alt=\"\" title=\"\" /></p>\n<h2>前言</h2>\n<p>PHP是一款简单方便的语言，而行业开源框架为了<code>后续灵活</code> 而变得过于繁重</p>\n<p>Fend框架是一款很有历史的框架、初代发布后一直在好未来坊间传播使用、衍生出大量分支版本</p>\n<p>这是一款很有意思的框架、普通的框架内隐藏着大型互联网经验的精华、也同时存在大量历史痕迹</p>\n<p>2019年7月 我们对Fend进行整理、封装、推广、目前在好未来内部有大量的用户在使用、维护</p>\n<p>2020年7月 开源、以此共建交流</p>\n<p>我们崇尚 <code>脚踏实地、仰望星空</code> 精神 欢迎小伙伴一起参与开源共建</p>\n<h2>设计方向</h2>\n<p>Fend 框架是一款以企业快速实现业务为主要目标的框架，但与复杂的行业流行框架追求不同：</p>\n<ul>\n <li><code>简单实用</code>：追求快速上手，扩展功能一步到位、大量降低功能的复杂度、框架更注重简单实用实现</li>\n <li><code>单层内核</code>：追求一个函数能实现的功能绝不继承封装，不追求框架自身功能的继承可复用</li>\n <li><code>内聚归类</code>：高度集中归类功能，降低底层复杂度，减少底层组件关注度、更多时间在业务</li>\n <li><code>持续积累</code>：持续积累大型互联网线上运营经验，持续探索企业实用技巧，深度来自于积累而非AOP带来的灵活性</li>\n <li><code>内核设计</code>：高内聚简单内核，放开业务自封装空间，留下更多空间给业务</li>\n <li><code>开源心态</code>：开放公开，接受任何符合价值观源码奉献、但有严格代码审核</li>\n</ul>\n<h2>功能简介</h2>\n<ul>\n <li>Swoole/FPM 双引擎平滑切换(协程版本还在整理稍晚放出)</li>\n <li>统一使用 Composer Autoload PSR4</li>\n <li>请求Debug 模式，请求网址wxdebug=1可查看debug模式查看异常分析性能</li>\n <li>协程模式下对变量域做了更好的封装，降低协程使用难度</li>\n <li>支持压测使用灰度影子库</li>\n <li>高速map映射路由 + FastRouter正则路由</li>\n <li>符合大数据挖掘设计的Trace日志，方便ELK分析、ClickHouse、HBase、实时预警</li>\n <li>throw new Exception方式处理业务异常、能够快速发现异常</li>\n</ul>\n<h2>性能压测</h2>\n<p>目前是在KVM虚拟机上压测、后续会找一台阿里云进行压测</p>\n<h3>FPM性能</h3>\n<p>服务器配置</p>\n<ul>\n <li>CPU 4 核 Xeon 2.2</li>\n <li>内存 12G</li>\n <li>KVM + CentOS 7.6</li>\n <li>FPM 开启进程数 500</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023636704\" alt=\"\" title=\"\" /></p>\n<p>QPS 5331 (分析：fpm空跑hello 1w、引入composer autoload 后 7000、开启日志trace 6000、框架内echo 5000)</p>\n<h3>Swoole 1.10.x 性能</h3>\n<p>服务器配置</p>\n<ul>\n <li>CPU 4 核 Xeon 2.2</li>\n <li>内存 12G</li>\n <li>KVM + CentOS 7.6</li>\n <li>FPM 开启进程数 500</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023636706\" alt=\"\" title=\"\" /></p>\n<p>QPS 24000、协程版本稍晚放出</p>\n<h3>发行版本介绍</h3>\n<p>Fend有两个版本</p>\n<ul>\n <li>Tag版本为 1.2.x FPM/Swoole 1.10.x 平滑切换版本</li>\n <li>Tag版本为 1.3.x FPM/Swoole 4.5.x Coroutine 协程 平滑切换版本 <code>此版本还在调整</code></li>\n</ul>\n<h2>以下为1.2.x版本安装</h2>\n<h4>FPM Engine Start</h4>\n<p>master is 1.2.x version</p>\n<pre><code>composer create-project fend/fend-skeleton:~1.2.0 project_name\n复制代码</code></pre>\n<p>Ref <a href=\"https://github.com/tal-tech/fend/blob/master/nginx.conf\" rel=\"nofollow noreferrer\">nginx.conf</a> to configure Nginx and <a href=\"http://127.0.0.1/\" rel=\"nofollow noreferrer\">http://127.0.0.1/</a> on browser</p>\n<h4>Swoole Engine Start</h4>\n<pre><code>composer create-project fend/fend-skeleton:~1.2.0 project_name\n\n# swoole start ( /bin/fend depend on composer require symfony/console )\nphp /bin/fend Swoole -c app/Config/Swoole.php start\nphp /bin/start.php -c app/Config/Swoole.php start\n复制代码</code></pre>\n<p>browser <a href=\"http://127.0.0.1:9572/\" rel=\"nofollow noreferrer\">http://127.0.0.1:9572/</a></p>\n<h2>1.3.0协程版本 安装</h2>\n<pre><code>composer create-project fend/fend-skeleton:~1.3.0\n复制代码</code></pre>\n<h2>软件作者贡献列表</h2>\n<p><img src=\"https://segmentfault.com/img/bVbLk9V\" alt=\"image\" title=\"image\" /></p>\n<p>(其他贡献者、请详见文档鸣谢)</p>\n<h2>合作伙伴</h2>\n<p>好未来教育集团90%在线业务在使用本框架</p>\n<ul>\n <li><img src=\"https://segmentfault.com/img/remote/1460000023636708\" alt=\"\" title=\"\" /></li>\n <li><img src=\"https://segmentfault.com/img/remote/1460000023636707\" alt=\"\" title=\"\" /></li>\n <li><img src=\"https://segmentfault.com/img/remote/1460000023636710\" alt=\"xiaohouai.png\" title=\"xiaohouai.png\"><p>xiaohouai.png</p></img></li>\n <li><img src=\"https://segmentfault.com/img/remote/1460000023636709\" alt=\"\" title=\"\" /></li>\n</ul>\n<h2>共建规则</h2>\n<p>欢迎挑战组件功能、允许同类功能同时发布竞争、以 性能好 + 实用及实现简单 + 功能实用 评判</p>\n<h2>联系我们</h2>\n<p>issue: <a href=\"https://github.com/tal-tech/fend/issues\" rel=\"nofollow noreferrer\">github.com/tal-tech/fe…</a></p>\n<p>加群请加微信：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023636711\" alt=\"contactus.png\" title=\"contactus.png\" /></p>\n<p><strong>也许你还想看</strong></p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI4MDM5MTAzNA==&amp;mid=2247483964&amp;idx=2&amp;sn=a8f1b52d3ca00a6fae100cbe555e0897&amp;chksm=ebb87e29dccff73f0c1afc8362bf7add48f5203f0117f32e0f2e2bba4d928a7c3b1bb84741fe&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">DStack--基于flutter的混合开发框架</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI4MDM5MTAzNA==&amp;mid=2247483856&amp;idx=1&amp;sn=e48f6c63e11c86a550fdcbdb8f90c26b&amp;chksm=ebb87dc5dccff4d357dc39137e2e74f741a2b65b908c54887658dc5e985ab62681ec39c1d111&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">WebRTC源码分析——视频流水线建立（上）</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI4MDM5MTAzNA==&amp;mid=2247483785&amp;idx=1&amp;sn=b9964373d5b5a07954d531b124c9dc4a&amp;chksm=ebb87d9cdccff48a877b8be329f0070b9a640509ae7ede1d2360775fa7f58f5393fe8729532b&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">\"考试\"背后的科学：教育测量中的理论与模型（IRT篇）</a></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023636712\" alt=\"\" title=\"\" /></p>","descriptionType":"html","publishedDate":"Fri, 14 Aug 2020 10:59:08 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023636705","linkMd5":"3f522baba1e817cf81ff90c5e1d10cfb","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn78@2020_2/2020/08/24/23-08-22-752_88bc2bcf04a82bf3.webp","destWidth":461,"destHeight":180,"sourceBytes":32231,"destBytes":9310,"author":"好未来技术团队","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023636705":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn78@2020_2/2020/08/24/23-08-22-752_88bc2bcf04a82bf3.webp","https://segmentfault.com/img/remote/1460000023636704":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn58@2020_5/2020/08/24/23-08-41-880_4d348bf55d8de54e.webp","https://segmentfault.com/img/remote/1460000023636706":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn49@2020_5/2020/08/24/23-08-43-314_cd76465a00b523c4.webp","https://segmentfault.com/img/bVbLk9V":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn45@2020_5/2020/08/24/23-08-33-349_7f210afa164eab9c.webp","https://segmentfault.com/img/remote/1460000023636708":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn44@2020_6/2020/08/24/23-08-42-102_38b4354b68e47c64.webp","https://segmentfault.com/img/remote/1460000023636707":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn40@2020_4/2020/08/24/23-08-42-022_92b4b2118af3de22.webp","https://segmentfault.com/img/remote/1460000023636710":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn8@2020_3/2020/08/24/23-08-41-903_966b3e9e7d0df3ae.webp","https://segmentfault.com/img/remote/1460000023636709":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn53@2020_4/2020/08/24/23-08-41-847_78d5f3da1847c64b.webp","https://segmentfault.com/img/remote/1460000023636711":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn15@2020_3/2020/08/24/23-08-41-491_a91637ac7b4d1501.webp","https://segmentfault.com/img/remote/1460000023636712":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn20@2020_5/2020/08/24/23-08-41-617_74973801d641c1f5.webp"},"publishedOrCreatedDate":1598310388568},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"了不起的 IoC 与 DI","link":"https://segmentfault.com/a/1190000023650518","description":"<p>本文阿宝哥将从六个方面入手，全方位带你一起探索面向对象编程中 <strong>IoC（控制反转）和 DI（依赖注入）</strong> 的设计思想。阅读完本文，你将了解以下内容：</p>\n<ul>\n <li>IoC 是什么、IoC 能解决什么问题；</li>\n <li>IoC 与 DI 之间的关系、未使用 DI 框架和使用 DI 框架之间的区别；</li>\n <li>DI 在 AngularJS/Angular 和 NestJS 中的应用；</li>\n <li>了解如何使用 TypeScript 实现一个 IoC 容器，并了解 <strong>装饰器、反射</strong> 的相关知识。</li>\n</ul>\n<h3>一、背景概述</h3>\n<p>在介绍什么是 IoC 容器之前，阿宝哥来举一个日常工作中很常见的场景，即创建指定类的实例。最简单的情形是该类没有依赖其他类，但现实往往是残酷的，我们在创建某个类的实例时，需要依赖不同类对应的实例。为了让小伙伴们能够更好地理解上述的内容，阿宝哥来举一个例子。</p>\n<p>一辆小汽车 🚗 通常由 <strong>发动机、底盘、车身和电气设备</strong> 四大部分组成。汽车电气设备的内部构造很复杂，简单起见，我们只考虑三个部分：发动机、底盘和车身。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023650522\" alt=\"\" title=\"\" /></p>\n<p>（图片来源：<a href=\"https://www.newkidscar.com/vehicle-construction/car-structure/\" rel=\"nofollow noreferrer\">https://www.newkidscar.com/ve...</a>）</p>\n<p>在现实生活中，要造辆车还是很困难的。而在软件的世界中，这可难不倒我们。👇是阿宝哥要造的车子，有木有很酷。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023650524\" alt=\"\" title=\"\" /></p>\n<p>（图片来源：<a href=\"https://pixabay.com/zh/illustrations/car-sports-car-racing-car-speed-49278/\" rel=\"nofollow noreferrer\">https://pixabay.com/zh/illust...</a>）</p>\n<p>在开始造车前，我们得先看一下 “图纸”：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023650528\" alt=\"\" title=\"\" /></p>\n<p>看完上面的 “图纸”，我们马上来开启造车之旅。第一步我们先来定义车身类：</p>\n<p><strong>1.定义车身类</strong></p>\n<pre><code class=\"typescript\">export default class Body { }</code></pre>\n<p><strong>2.定义底盘类</strong></p>\n<pre><code class=\"typescript\">export default class Chassis { }</code></pre>\n<p><strong>3.定义引擎类</strong></p>\n<pre><code class=\"typescript\">export default class Engine {\n  start() {\n    console.log(\"引擎发动了\");\n  }\n}</code></pre>\n<p><strong>4.定义汽车类</strong></p>\n<pre><code class=\"typescript\">import Engine from './engine';\nimport Chassis from './chassis';\nimport Body from './body';\n\nexport default class Car {\n    engine: Engine;\n    chassis: Chassis;\n    body: Body;\n\n    constructor() {\n      this.engine = new Engine();\n      this.body = new Body();\n      this.chassis = new Chassis();\n    }\n\n    run() {\n      this.engine.start();\n    }\n}</code></pre>\n<p>一切已准备就绪，我们马上来造一辆车：</p>\n<pre><code class=\"typescript\">const car = new Car(); // 阿宝哥造辆新车\ncar.run(); // 控制台输出：引擎发动了</code></pre>\n<p>现在虽然车已经可以启动了，但却存在以下问题：</p>\n<ul>\n <li>问题一：在造车的时候，你不能选择配置。比如你想更换汽车引擎的话，按照目前的方案，是实现不了的。</li>\n <li>问题二：在汽车类内部，你需要在构造函数中手动去创建汽车的各个部件。</li>\n</ul>\n<p>为了解决第一个问题，提供更灵活的方案，我们可以重构一下已定义的汽车类，具体如下：</p>\n<pre><code class=\"typescript\">export default class Car {\n    body: Body;\n    engine: Engine;\n    chassis: Chassis;\n  \n    constructor(engine, body, chassis) {\n      this.engine = engine;\n      this.body = body;\n      this.chassis = chassis;\n    }\n\n    run() {\n      this.engine.start();\n    }\n}</code></pre>\n<p>重构完汽车类，我们来重新造辆新车：</p>\n<pre><code class=\"typescript\">const engine = new NewEngine();\nconst body = new Body();\nconst chassis = new Chassis();\n\nconst newCar = new Car(engine, body, chassis);\nnewCar.run();</code></pre>\n<p>此时我们已经解决了上面提到的第一个问题，要解决第二个问题我们要来了解一下 IoC（控制反转）的概念。</p>\n<h3>二、IoC 是什么</h3>\n<p>IoC（Inversion of Control），即 “控制反转”。在开发中， IoC 意味着你设计好的对象交给容器控制，而不是使用传统的方式，在对象内部直接控制。　　</p>\n<p>如何理解好 IoC 呢？理解好 IoC 的关键是要明确 <strong>“谁控制谁，控制什么，为何是反转，哪些方面反转了”</strong>，我们来深入分析一下。　　</p>\n<ul>\n <li>谁控制谁，控制什么：在传统的程序设计中，我们直接在对象内部通过 <code>new</code> 的方式创建对象，是程序主动创建依赖对象； <strong>而 IoC 是有专门一个容器来创建这些对象，即由 IoC 容器控制对象的创建</strong>；<p>谁控制谁？当然是 IoC 容器控制了对象；控制什么？主要是控制外部资源（依赖对象）获取。</p></li>\n <li>为何是反转了，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在程序中主动控制去获取依赖对象，也就是正转； <strong>而反转则是由容器来帮忙创建及注入依赖对象</strong>；<p>为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转了；哪些方面反转了？依赖对象的获取被反转了。</p></li>\n</ul>\n<h3>三、IoC 能做什么</h3>\n<p>IoC 不是一种技术，只是一种思想，是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。</p>\n<p>传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试； <strong>有了 IoC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器注入组合对象，所以对象之间是松散耦合。</strong> 这样也便于测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。　　</p>\n<p>其实 IoC 对编程带来的最大改变不是从代码上，而是思想上，发生了 “主从换位” 的变化。应用程序本来是老大，要获取什么资源都是主动出击，但在 IoC 思想中，应用程序就变成被动了，被动的等待 IoC 容器来创建并注入它所需的资源了。　　　　</p>\n<h3>四、IoC 与 DI 之间的关系</h3>\n<p>对于控制反转来说，其中最常见的方式叫做 <strong>依赖注入</strong>，简称为 DI（Dependency Injection）。</p>\n<p>组件之间的依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。 <strong>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。</strong> </p>\n<p>通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>\n<p>理解 DI 的关键是 <strong>“谁依赖了谁，为什么需要依赖，谁注入了谁，注入了什么”</strong>：　</p>\n<ul>\n <li>谁依赖了谁：当然是应用程序依赖 IoC 容器；</li>\n <li>为什么需要依赖：应用程序需要 IoC 容器来提供对象需要的外部资源（包括对象、资源、常量数据）；</li>\n <li>谁注入谁：很明显是 IoC 容器注入应用程序依赖的对象；</li>\n <li>注入了什么：注入某个对象所需的外部资源（包括对象、资源、常量数据）。</li>\n</ul>\n<p>那么 IoC 和 DI 有什么关系？其实它们是同一个概念的不同角度描述，由于控制反转的概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护依赖关系），所以 2004 年大师级人物 Martin Fowler 又给出了一个新的名字：<strong>“依赖注入”，相对 IoC 而言，“依赖注入” 明确描述了被注入对象依赖 IoC 容器配置依赖对象</strong>。</p>\n<p>总的来说， 控制反转（Inversion of Control）是说创建对象的控制权发生转移，以前创建对象的主动权和创建时机由应用程序把控，而现在这种权利转交给 IoC 容器，它就是一个专门用来创建对象的工厂，你需要什么对象，它就给你什么对象。 <strong>有了 IoC 容器，依赖关系就改变了，原先的依赖关系就没了，它们都依赖 IoC 容器了，通过 IoC 容器来建立它们之间的关系</strong>。　</p>\n<p>前面介绍了那么多的概念，现在我们来看一下未使用依赖注入框架和使用依赖注入框架之间有什么明显的区别。</p>\n<h4>4.1 未使用依赖注入框架</h4>\n<p>假设我们的服务 A 依赖于服务 B，即要使用服务 A 前，我们需要先创建服务 B。具体的流程如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023650527\" alt=\"\" title=\"\" /></p>\n<p>从上图可知，未使用依赖注入框架时，服务的使用者需要关心服务本身和其依赖的对象是如何创建的，且需要手动维护依赖关系。若服务本身需要依赖多个对象，这样就会增加使用难度和后期的维护成本。对于上述的问题，我们可以考虑引入依赖注入框架。下面我们来看一下引入依赖注入框架，整体流程会发生什么变化。</p>\n<h4>4.2 使用依赖注入框架</h4>\n<p>使用依赖注入框架之后，系统中的服务会统一注册到 IoC 容器中，如果服务有依赖其他服务时，也需要对依赖进行声明。当用户需要使用特定的服务时，IoC 容器会负责该服务及其依赖对象的创建与管理工作。具体的流程如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023650521\" alt=\"\" title=\"\" /></p>\n<p>到这里我们已经介绍了 IoC 与 DI 的概念及特点，接下来我们来介绍 DI 的应用。</p>\n<h3>五、DI 的应用</h3>\n<p>DI 在前端和服务端都有相应的应用，比如在前端领域的代表是 <a href=\"https://angularjs.org/\" rel=\"nofollow noreferrer\">AngularJS</a> 和 <a href=\"https://angular.io/\" rel=\"nofollow noreferrer\">Angular</a>，而在服务端领域是 <a href=\"https://nodejs.org/zh-cn/\" rel=\"nofollow noreferrer\">Node.js</a> 生态中比较出名的 <a href=\"https://nestjs.com/\" rel=\"nofollow noreferrer\">NestJS</a>。接下来阿宝哥将简单介绍一下 DI 在 AngularJS/Angular 和 NestJS 中的应用。</p>\n<h4>5.1 DI 在 AngularJS 中的应用</h4>\n<p>在 AngularJS 中，依赖注入是其核心的特性之一。在 AngularJS 中声明依赖项有 3 种方式：</p>\n<pre><code class=\"javascript\">// 方式一：　使用 $inject annotation 方式\nlet fn = function (a, b) {};\nfn.$inject = ['a', 'b'];\n\n// 方式二：　使用 array-style annotations 方式\nlet fn = ['a', 'b', function (a, b) {}];\n\n// 方式三：　使用隐式声明方式　\nlet fn = function (a, b) {}; // 不推荐</code></pre>\n<p>对于以上的代码，相信使用过 AngularJS 的小伙们都不会陌生。作为 AngularJS 核心功能特性的 DI 还是蛮强大的，但随着 AngularJS 的普及和应用的复杂度不断提高，AngularJS DI 系统的问题就暴露出来了。</p>\n<p>这里阿宝哥简单介绍一下 AngularJS DI 系统存在的几个问题：</p>\n<ul>\n <li>内部缓存： AngularJS 应用程序中所有的依赖项都是单例，我们不能控制是否使用新的实例；</li>\n <li>命名空间冲突： 在系统中我们使用字符串来标识服务的名称，假设我们在项目中已有一个 CarService，然而第三方库中也引入了同样的服务，这样的话就容易出现混淆。</li>\n</ul>\n<p>由于 AngularJS DI 存在以上的问题，所以在后续的 Angular 重新设计了新的 DI 系统。</p>\n<h4>5.2 DI 在 Angular 中的应用</h4>\n<p>以前面汽车的例子为例，我们可以把汽车、发动机、底盘和车身这些认为是一种 “服务”，所以它们会以服务提供者的形式注册到 DI 系统中。为了能区分不同服务，我们需要使用不同的令牌（Token）来标识它们。接着我们会基于已注册的服务提供者创建注入器对象。</p>\n<p>之后，当我们需要获取指定服务时，我们就可以通过该服务对应的令牌，从注入器对象中获取令牌对应的依赖对象。上述的流程的具体如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023650523\" alt=\"\" title=\"\" /></p>\n<p>好的，了解完上述的流程。下面我们来看一下如何使用 Angular 内置的 DI 系统来 “造车”。</p>\n<h5>5.2.1 car.ts</h5>\n<pre><code class=\"typescript\">// car.ts\nimport { Injectable, ReflectiveInjector } from '@angular/core';\n\n// 配置Provider\n@Injectable({\n  providedIn: 'root',\n})\nexport class Body {}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class Chassis {}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class Engine {\n  start() {\n    console.log('引擎发动了');\n  }\n}\n\n@Injectable()\nexport default class Car {\n  // 使用构造注入方式注入依赖对象\n  constructor(\n    private engine: Engine,\n    private body: Body,\n    private chassis: Chassis\n  ) {}\n\n  run() {\n    this.engine.start();\n  }\n}\n\nconst injector = ReflectiveInjector.resolveAndCreate([\n  Car,\n  Engine,\n  Chassis,\n  Body,\n]);\n\nconst car = injector.get(Car);\ncar.run();</code></pre>\n<p>在以上代码中我们调用 ReflectiveInjector 对象的 <code>resolveAndCreate</code> 方法手动创建注入器，然后根据车辆对应的 <code>Token</code> 来获取对应的依赖对象。通过观察上述代码，你可以发现，我们已经不需要手动地管理和维护依赖对象了，这些 “脏活”、“累活” 已经交给注入器来处理了。</p>\n<p>此外，如果要能正常获取汽车对象，我们还需要在 <code>app.module.ts</code> 文件中声明 Car 对应 Provider，具体如下所示：</p>\n<h5>5.2.2 app.module.ts</h5>\n<pre><code class=\"typescript\">import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppComponent } from './app.component';\nimport Car, { Body, Chassis, Engine } from './car';\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule],\n  providers: [{ provide: Car, deps: [Engine, Body, Chassis] }],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}</code></pre>\n<h4>5.3 DI 在 NestJS 中的应用</h4>\n<p><a href=\"https://nestjs.com/\" rel=\"nofollow noreferrer\">NestJS</a> 是构建高效，可扩展的 <a href=\"http://nodejs.cn/\" rel=\"nofollow noreferrer\">Node.js</a> Web 应用程序的框架。 它使用现代的 JavaScript 或 <a href=\"https://www.tslang.cn/\" rel=\"nofollow noreferrer\">TypeScript</a>（保留与纯 JavaScript 的兼容性），并结合 OOP（面向对象编程），FP（函数式编程）和FRP（函数响应式编程）的元素。</p>\n<p>在底层，Nest 使用了 <a href=\"http://www.expressjs.com.cn/\" rel=\"nofollow noreferrer\">Express</a>，但也提供了与其他各种库的兼容，例如 <a href=\"https://github.com/fastify/fastify\" rel=\"nofollow noreferrer\">Fastify</a>，可以方便地使用各种可用的第三方插件。</p>\n<p>近几年，由于 Node.js，JavaScript 已经成为 Web 前端和后端应用程序的「通用语言」，从而产生了像 <a href=\"https://angular.cn/\" rel=\"nofollow noreferrer\">Angular</a>、<a href=\"https://github.com/facebook/react\" rel=\"nofollow noreferrer\">React</a>、<a href=\"https://github.com/vuejs/vue\" rel=\"nofollow noreferrer\">Vue</a> 等令人耳目一新的项目，这些项目提高了开发人员的生产力，使得可以快速构建可测试的且可扩展的前端应用程序。 然而，在服务器端，虽然有很多优秀的库、helper 和 Node 工具，但是它们都没有有效地解决主要问题 —— 架构。</p>\n<p><strong>NestJS 旨在提供一个开箱即用的应用程序体系结构，允许轻松创建高度可测试，可扩展，松散耦合且易于维护的应用程序。</strong> 在 NestJS 中也为我们开发者提供了依赖注入的功能，这里我们以<a href=\"https://nestjs.com/\" rel=\"nofollow noreferrer\">官网</a>的示例来演示一下依赖注入的功能。</p>\n<h5>5.3.1 app.service.ts</h5>\n<pre><code class=\"typescript\">import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class AppService {\n  getHello(): string {\n    return 'Hello World!';\n  }\n}</code></pre>\n<h5>5.3.2 app.controller.ts</h5>\n<pre><code class=\"typescript\">import { Get, Controller, Render } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  @Render('index')\n  render() {\n    const message = this.appService.getHello();\n    return { message };\n  }\n}</code></pre>\n<p>在 AppController 中，我们通过构造注入的方式注入了 AppService 对象，当用户访问首页的时候，我们会调用 AppService 对象的 <code>getHello</code> 方法来获取 <code>'Hello World!'</code> 消息，并把消息返回给用户。当然为了保证依赖注入可以正常工作，我们还需要在 AppModule 中声明 providers 和 controllers，具体操作如下：</p>\n<pre><code class=\"typescript\">import { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n\n@Module({\n  imports: [],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}</code></pre>\n<p>其实 DI 并不是 AngularJS/Angular 和 NestJS 所特有的，如果你想在其他项目中使用 DI/IoC 的功能特性，阿宝哥推荐你使用 <a href=\"http://inversify.io/\" rel=\"nofollow noreferrer\">InversifyJS</a>，它是一个可用于 JavaScript 和 Node.js 应用，功能强大、轻量的 IoC 容器。</p>\n<p>对 <a href=\"http://inversify.io/\" rel=\"nofollow noreferrer\">InversifyJS</a> 感兴趣的小伙伴可以自行了解一下，阿宝哥就不继续展开介绍了。接下来，我们将进入本文的重点，即介绍如何使用 TypeScript 实现一个简单的 IoC 容器，该容器实现的功能如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023650526\" alt=\"\" title=\"\" /></p>\n<h3>六、手写 IoC 容器</h3>\n<p>为了让大家能更好地理解 IoC 容器的实现代码，阿宝哥来介绍一些相关的前置知识。</p>\n<h4>6.1 装饰器</h4>\n<p>如果你有使用过 Angular 或 NestJS，相信你对以下的代码不会陌生。</p>\n<pre><code class=\"typescript\">@Injectable()\nexport class HttpService {\n  constructor(\n    private httpClient: HttpClient\n  ) {}\n}</code></pre>\n<p>在以上代码中，我们使用了 <code>Injectable</code> 装饰器。该装饰器用于表示此类可以自动注入其依赖项。其中 <code>@Injectable()</code> 中的 <code>@</code> 符号属于语法糖。</p>\n<p>装饰器是一个包装类，函数或方法并为其添加行为的函数。这对于定义与对象关联的元数据很有用。装饰器有以下四种分类：</p>\n<ul>\n <li>类装饰器（Class decorators）</li>\n <li>属性装饰器（Property decorators）</li>\n <li>方法装饰器（Method decorators）</li>\n <li>参数装饰器（Parameter decorators）</li>\n</ul>\n<p>前面示例中使用的 <code>@Injectable()</code> 装饰器，属于类装饰器。在该类装饰器修饰的 <code>HttpService</code> 类中，我们通过构造注入的方式注入了用于处理 HTTP 请求的 <code>HttpClient</code> 依赖对象。</p>\n<h4>6.2 反射</h4>\n<pre><code class=\"typescript\">@Injectable()\nexport class HttpService {\n  constructor(\n    private httpClient: HttpClient\n  ) {}\n}</code></pre>\n<p>以上代码若设置编译的目标为 ES5，则会生成以下代码：</p>\n<pre><code class=\"typescript\">// 忽略__decorate函数等代码\nvar __metadata = (this &amp;&amp; this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" &amp;&amp; typeof Reflect.metadata === \"function\") \n      return Reflect.metadata(k, v);\n};\n\nvar HttpService = /** @class */ (function () {\n    function HttpService(httpClient) {\n      this.httpClient = httpClient;\n    }\n    var _a;\n    HttpService = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [typeof (_a = typeof HttpClient !== \"undefined\" &amp;&amp; HttpClient)\n           === \"function\" ? _a : Object])\n    ], HttpService);\n    return HttpService;\n}());</code></pre>\n<p>通过观察上述代码，你会发现 <code>HttpService</code> 构造函数中 <code>httpClient</code> 参数的类型被擦除了，这是因为 JavaScript 是弱类型语言。那么如何在运行时，保证注入正确类型的依赖对象呢？这里 TypeScript 使用 <a href=\"https://www.npmjs.com/package/reflect-metadata\" rel=\"nofollow noreferrer\">reflect-metadata</a> 这个第三方库来存储额外的类型信息。</p>\n<p><a href=\"https://www.npmjs.com/package/reflect-metadata\" rel=\"nofollow noreferrer\">reflect-metadata</a> 这个库提供了很多 API 用于操作元信息，这里我们只简单介绍几个常用的 API：</p>\n<pre><code class=\"typescript\">// define metadata on an object or property\nReflect.defineMetadata(metadataKey, metadataValue, target);\nReflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);\n\n// check for presence of a metadata key on the prototype chain of an object or property\nlet result = Reflect.hasMetadata(metadataKey, target);\nlet result = Reflect.hasMetadata(metadataKey, target, propertyKey);\n\n// get metadata value of a metadata key on the prototype chain of an object or property\nlet result = Reflect.getMetadata(metadataKey, target);\nlet result = Reflect.getMetadata(metadataKey, target, propertyKey);\n\n// delete metadata from an object or property\nlet result = Reflect.deleteMetadata(metadataKey, target);\nlet result = Reflect.deleteMetadata(metadataKey, target, propertyKey);\n\n// apply metadata via a decorator to a constructor\n@Reflect.metadata(metadataKey, metadataValue)\nclass C {\n  // apply metadata via a decorator to a method (property)\n  @Reflect.metadata(metadataKey, metadataValue)\n  method() {\n  }\n}</code></pre>\n<p>对于上述的 API 只需简单了解一下即可。在后续的内容中，我们将介绍具体如何使用。这里我们需要注意以下两个问题：</p>\n<ul>\n <li>对于类或函数，我们需要使用装饰器来修饰它们，这样才能保存元数据。</li>\n <li>只有类、枚举或原始数据类型能被记录。接口和联合类型作为 “对象” 出现。这是因为这些类型在编译后完全消失，而类却一直存在。</li>\n</ul>\n<h4>6.3 定义 Token 和 Provider</h4>\n<p>了解完装饰器与反射相关的基础知识，接下来我们来开始实现 IoC 容器。我们的 IoC 容器将使用两个主要的概念：令牌（Token）和提供者（Provider）。令牌是 IoC 容器所要创建对象的标识符，而提供者用于描述如何创建这些对象。</p>\n<p>IoC 容器最小的公共接口如下所示：</p>\n<pre><code class=\"typescript\">export class Container {\n  addProvider&lt;T&gt;(provider: Provider&lt;T&gt;) {} // TODO\n  inject&lt;T&gt;(type: Token&lt;T&gt;): T {} // TODO\n}</code></pre>\n<p>接下来我们先来定义 Token：</p>\n<pre><code class=\"typescript\">// type.ts\ninterface Type&lt;T&gt; extends Function {\n  new (...args: any[]): T;\n}\n\n// provider.ts\nclass InjectionToken {\n  constructor(public injectionIdentifier: string) {}\n}\n\ntype Token&lt;T&gt; = Type&lt;T&gt; | InjectionToken;</code></pre>\n<p>Token 类型是一个联合类型，既可以是一个函数类型也可以是 InjectionToken 类型。AngularJS 中使用字符串作为 Token，在某些情况下，可能会导致冲突。因此，为了解决这个问题，我们定义了 InjectionToken 类，来避免出现命名冲突问题。</p>\n<p>定义完 Token 类型，接下来我们来定义三种不同类型的 Provider：</p>\n<ul>\n <li>ClassProvider：提供一个类，用于创建依赖对象；</li>\n <li>ValueProvider：提供一个已存在的值，作为依赖对象；</li>\n <li>FactoryProvider：提供一个工厂方法，用于创建依赖对象。</li>\n</ul>\n<pre><code class=\"typescript\">// provider.ts\nexport type Factory&lt;T&gt; = () =&gt; T;\n\nexport interface BaseProvider&lt;T&gt; {\n  provide: Token&lt;T&gt;;\n}\n\nexport interface ClassProvider&lt;T&gt; extends BaseProvider&lt;T&gt; {\n  provide: Token&lt;T&gt;;\n  useClass: Type&lt;T&gt;;\n}\n\nexport interface ValueProvider&lt;T&gt; extends BaseProvider&lt;T&gt; {\n  provide: Token&lt;T&gt;;\n  useValue: T;\n}\n\nexport interface FactoryProvider&lt;T&gt; extends BaseProvider&lt;T&gt; {\n  provide: Token&lt;T&gt;;\n  useFactory: Factory&lt;T&gt;;\n}\n\nexport type Provider&lt;T&gt; =\n  | ClassProvider&lt;T&gt;\n  | ValueProvider&lt;T&gt;\n  | FactoryProvider&lt;T&gt;;</code></pre>\n<p>为了更方便的区分这三种不同类型的 Provider，我们自定义了三个类型守卫函数：</p>\n<pre><code class=\"typescript\">// provider.ts\nexport function isClassProvider&lt;T&gt;(\n  provider: BaseProvider&lt;T&gt;\n): provider is ClassProvider&lt;T&gt; {\n  return (provider as any).useClass !== undefined;\n}\n\nexport function isValueProvider&lt;T&gt;(\n  provider: BaseProvider&lt;T&gt;\n): provider is ValueProvider&lt;T&gt; {\n  return (provider as any).useValue !== undefined;\n}\n\nexport function isFactoryProvider&lt;T&gt;(\n  provider: BaseProvider&lt;T&gt;\n): provider is FactoryProvider&lt;T&gt; {\n  return (provider as any).useFactory !== undefined;\n}</code></pre>\n<h4>6.4 定义装饰器</h4>\n<p>在前面我们已经提过了，对于类或函数，我们需要使用装饰器来修饰它们，这样才能保存元数据。因此，接下来我们来分别创建 <strong>Injectable</strong> 和 <strong>Inject</strong> 装饰器。</p>\n<h5>6.4.1 Injectable 装饰器</h5>\n<p>Injectable 装饰器用于表示此类可以自动注入其依赖项，该装饰器属于类装饰器。在 TypeScript 中，类装饰器的声明如下：</p>\n<pre><code class=\"typescript\">declare type ClassDecorator = &lt;TFunction extends Function&gt;(target: TFunction) \n  =&gt; TFunction | void;</code></pre>\n<p>类装饰器顾名思义，就是用来装饰类的。它接收一个参数：<code>target: TFunction</code>，表示被装饰的类。下面我们来看一下 Injectable 装饰器的具体实现：</p>\n<pre><code class=\"typescript\">// Injectable.ts\nimport { Type } from \"./type\";\nimport \"reflect-metadata\";\n\nconst INJECTABLE_METADATA_KEY = Symbol(\"INJECTABLE_KEY\");\n\nexport function Injectable() {\n  return function(target: any) {\n    Reflect.defineMetadata(INJECTABLE_METADATA_KEY, true, target);\n    return target;\n  };\n}</code></pre>\n<p>在以上代码中，当调用完 Injectable 函数之后，会返回一个新的函数。在新的函数中，我们使用 <a href=\"https://www.npmjs.com/package/reflect-metadata\" rel=\"nofollow noreferrer\">reflect-metadata</a> 这个库提供的 defineMetadata API 来保存元信息，其中 defineMetadata API 的使用方式如下所示：</p>\n<pre><code class=\"typescript\">// define metadata on an object or property\nReflect.defineMetadata(metadataKey, metadataValue, target);\nReflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);</code></pre>\n<p>Injectable 类装饰器使用方式也简单，只需要在被装饰类的上方使用 <code>@Injectable()</code> 语法糖就可以应用该装饰器：</p>\n<pre><code class=\"typescript\">@Injectable()\nexport class HttpService {\n  constructor(\n    private httpClient: HttpClient\n  ) {}\n}</code></pre>\n<p>在以上示例中，我们注入的是 Type 类型的 HttpClient 对象。但在实际的项目中，往往会比较复杂。除了需要注入 Type 类型的依赖对象之外，我们还可能会注入其他类型的依赖对象，比如我们希望在 HttpService 服务中注入远程服务器的 API 地址。针对这种情形，我们需要使用 Inject 装饰器。</p>\n<h5>6.4.2 Inject 装饰器</h5>\n<p>接下来我们来创建 Inject 装饰器，该装饰器属于参数装饰器。在 TypeScript 中，参数装饰器的声明如下：</p>\n<pre><code class=\"typescript\">declare type ParameterDecorator = (target: Object, \n  propertyKey: string | symbol, parameterIndex: number ) =&gt; void</code></pre>\n<p>参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：</p>\n<ul>\n <li>target: Object —— 被装饰的类；</li>\n <li>propertyKey: string | symbol —— 方法名；</li>\n <li>parameterIndex: number —— 方法中参数的索引值。</li>\n</ul>\n<p>下面我们来看一下 Inject 装饰器的具体实现：</p>\n<pre><code class=\"typescript\">// Inject.ts\nimport { Token } from './provider';\nimport 'reflect-metadata';\n\nconst INJECT_METADATA_KEY = Symbol('INJECT_KEY');\n\nexport function Inject(token: Token&lt;any&gt;) {\n  return function(target: any, _: string | symbol, index: number) {\n    Reflect.defineMetadata(INJECT_METADATA_KEY, token, target, `index-${index}`);\n    return target;\n  };\n}</code></pre>\n<p>在以上代码中，当调用完 Inject 函数之后，会返回一个新的函数。在新的函数中，我们使用 <a href=\"https://www.npmjs.com/package/reflect-metadata\" rel=\"nofollow noreferrer\">reflect-metadata</a> 这个库提供的 defineMetadata API 来保存参数相关的元信息。这里是保存 index 索引信息和 Token 信息。</p>\n<p>定义完 Inject 装饰器，我们就可以利用它来注入我们前面所提到的远程服务器的 API 地址，具体的使用方式如下：</p>\n<pre><code class=\"typescript\">const API_URL = new InjectionToken('apiUrl');\n\n@Injectable()\nexport class HttpService {\n  constructor(\n    private httpClient: HttpClient,\n    @Inject(API_URL) private apiUrl: string\n  ) {}\n}</code></pre>\n<h4>6.5 实现 IoC 容器</h4>\n<p>目前为止，我们已经定义了 Token、Provider、Injectable 和 Inject 装饰器。接下来我们来实现前面所提到的 IoC 容器的 API：</p>\n<pre><code class=\"typescript\">export class Container {\n  addProvider&lt;T&gt;(provider: Provider&lt;T&gt;) {} // TODO\n  inject&lt;T&gt;(type: Token&lt;T&gt;): T {} // TODO\n}</code></pre>\n<h5>6.5.1 实现 addProvider 方法</h5>\n<p>addProvider() 方法的实现很简单，我们使用 Map 来存储 Token 与 Provider 之间的关系：</p>\n<pre><code class=\"typescript\">export class Container {\n  private providers = new Map&lt;Token&lt;any&gt;, Provider&lt;any&gt;&gt;();\n\n  addProvider&lt;T&gt;(provider: Provider&lt;T&gt;) {\n    this.assertInjectableIfClassProvider(provider);\n    this.providers.set(provider.provide, provider);\n  }\n}</code></pre>\n<p>在 addProvider() 方法内部除了把 Token 与 Provider 的对应信息保存到 providers 对象中之外，我们定义了一个 assertInjectableIfClassProvider 方法，用于确保添加的 ClassProvider 是可注入的。该方法的具体实现如下：</p>\n<pre><code class=\"typescript\">private assertInjectableIfClassProvider&lt;T&gt;(provider: Provider&lt;T&gt;) {\n  if (isClassProvider(provider) &amp;&amp; !isInjectable(provider.useClass)) {\n    throw new Error(\n        `Cannot provide ${this.getTokenName(\n          provider.provide\n     )} using class ${this.getTokenName(\n          provider.useClass\n     )}, ${this.getTokenName(provider.useClass)} isn't injectable`\n   );\n  }\n}</code></pre>\n<p>在 assertInjectableIfClassProvider 方法体中，我们使用了前面已经介绍的 <code>isClassProvider</code> 类型守卫函数来判断是否为 ClassProvider，如果是的话，会判断该 ClassProvider 是否为可注入的，具体使用的是 isInjectable 函数，该函数的定义如下：</p>\n<pre><code class=\"typescript\">export function isInjectable&lt;T&gt;(target: Type&lt;T&gt;) {\n  return Reflect.getMetadata(INJECTABLE_METADATA_KEY, target) === true;\n}</code></pre>\n<p>在 isInjectable 函数中，我们使用 <a href=\"https://www.npmjs.com/package/reflect-metadata\" rel=\"nofollow noreferrer\">reflect-metadata</a> 这个库提供的 getMetadata API 来获取保存在类中的元信息。为了更好地理解以上代码，我们来回顾一下前面 Injectable 装饰器：</p>\n<pre><code class=\"typescript\">const INJECTABLE_METADATA_KEY = Symbol(\"INJECTABLE_KEY\");\n\nexport function Injectable() {\n  return function(target: any) {\n    Reflect.defineMetadata(INJECTABLE_METADATA_KEY, true, target);\n    return target;\n  };\n}</code></pre>\n<p>如果添加的 Provider 是 ClassProvider，但 Provider 对应的类是不可注入的，则会抛出异常。为了让异常消息更加友好，也更加直观。我们定义了一个 <code>getTokenName</code> 方法来获取 Token 对应的名称：</p>\n<pre><code class=\"typescript\">private getTokenName&lt;T&gt;(token: Token&lt;T&gt;) {\n  return token instanceof InjectionToken\n    ? token.injectionIdentifier\n    : token.name;\n}</code></pre>\n<p>现在我们已经实现了 Container 类的 <code>addProvider</code> 方法，这时我们就可以使用它来添加三种不同类型的 Provider：</p>\n<pre><code class=\"typescript\">const container = new Container();\nconst input = { x: 200 };\n\nclass BasicClass {}\n// 注册ClassProvider\ncontainer.addProvider({ provide: BasicClass, useClass:  BasicClass});\n// 注册ValueProvider\ncontainer.addProvider({ provide: BasicClass, useValue: input });\n// 注册FactoryProvider\ncontainer.addProvider({ provide: BasicClass, useFactory: () =&gt; input });</code></pre>\n<p>需要注意的是，以上示例中注册三种不同类型的 Provider 使用的是同一个 Token 仅是为了演示而已。下面我们来实现 Container 类中核心的 inject 方法。</p>\n<h5>6.5.2 实现 inject 方法</h5>\n<p>在看 inject 方法的具体实现之前，我们先来看一下该方法所实现的功能：</p>\n<pre><code class=\"typescript\">const container = new Container();\nconst input = { x: 200 };\n\ncontainer.addProvider({ provide: BasicClass, useValue: input });\nconst output = container.inject(BasicClass);\nexpect(input).toBe(output); // true</code></pre>\n<p>观察以上的测试用例可知，Container 类中 inject 方法所实现的功能就是根据 Token 获取与之对应的对象。在前面实现的 addProvider 方法中，我们把 Token 和该 Token 对应的 Provider 保存在 providers Map 对象中。所以在 inject 方法中，我们可以先从 providers 对象中获取该 Token 对应的 Provider 对象，然后在根据不同类型的 Provider 来获取其对应的对象。</p>\n<p>好的，下面我们来看一下 inject 方法的具体实现：</p>\n<pre><code class=\"typescript\">inject&lt;T&gt;(type: Token&lt;T&gt;): T {\n  let provider = this.providers.get(type);\n  // 处理使用Injectable装饰器修饰的类\n  if (provider === undefined &amp;&amp; !(type instanceof InjectionToken)) {\n    provider = { provide: type, useClass: type };\n    this.assertInjectableIfClassProvider(provider);\n  }\n  return this.injectWithProvider(type, provider);\n}</code></pre>\n<p>在以上代码中，除了处理正常的流程之外。我们还处理一个特殊的场景，即没有使用 <code>addProvider</code> 方法注册 Provider，而是使用 Injectable 装饰器来装饰某个类。对于这个特殊场景，我们会根据传入的 type 参数来创建一个 provider 对象，然后进一步调用 <code>injectWithProvider</code> 方法来创建对象，该方法的具体实现如下：</p>\n<pre><code class=\"typescript\">private injectWithProvider&lt;T&gt;(type: Token&lt;T&gt;, provider?: Provider&lt;T&gt;): T {\n  if (provider === undefined) {\n    throw new Error(`No provider for type ${this.getTokenName(type)}`);\n  }\n  if (isClassProvider(provider)) {\n    return this.injectClass(provider as ClassProvider&lt;T&gt;);\n  } else if (isValueProvider(provider)) {\n    return this.injectValue(provider as ValueProvider&lt;T&gt;);\n  } else {\n    return this.injectFactory(provider as FactoryProvider&lt;T&gt;);\n  }\n }</code></pre>\n<p>在 <code>injectWithProvider</code> 方法内部，我们会使用前面定义的用于区分三种不同类型 Provider 的类型守卫函数来处理不同的 Provider。这里我们先来看一下最简单 ValueProvider，当发现注入的是 ValueProvider 类型时，则会调用 <code>injectValue</code> 方法来获取其对应的对象：</p>\n<pre><code class=\"typescript\">// { provide: API_URL, useValue: 'https://www.semlinker.com/' }\nprivate injectValue&lt;T&gt;(valueProvider: ValueProvider&lt;T&gt;): T {\n  return valueProvider.useValue;\n}</code></pre>\n<p>接着我们来看如何处理 FactoryProvider 类型的 Provider，如果发现是 FactoryProvider 类型时，则会调用 <code>injectFactory</code> 方法来获取其对应的对象，该方法的实现也很简单：</p>\n<pre><code class=\"typescript\">// const input = { x: 200 };\n// container.addProvider({ provide: BasicClass, useFactory: () =&gt; input });\nprivate injectFactory&lt;T&gt;(valueProvider: FactoryProvider&lt;T&gt;): T {\n  return valueProvider.useFactory();\n}</code></pre>\n<p>最后我们来分析一下如何处理 ClassProvider，对于 ClassProvider 类说，通过 Provider 对象的 useClass 属性，我们就可以直接获取到类对应的构造函数。最简单的情形是该类没有依赖其他对象，但在大多数场景下，即将实例化的服务类是会依赖其他的对象的。所以在实例化服务类前，我们需要构造其依赖的对象。</p>\n<p>那么现在问题来了，怎么获取类所依赖的对象呢？我们先来分析一下以下代码：</p>\n<pre><code class=\"typescript\">const API_URL = new InjectionToken('apiUrl');\n\n@Injectable()\nexport class HttpService {\n  constructor(\n    private httpClient: HttpClient,\n    @Inject(API_URL) private apiUrl: string\n  ) {}\n}</code></pre>\n<p>以上代码若设置编译的目标为 ES5，则会生成以下代码：</p>\n<pre><code class=\"javascript\">// 已省略__decorate函数的定义\nvar __metadata = (this &amp;&amp; this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" &amp;&amp; typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar __param = (this &amp;&amp; this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\n\nvar HttpService = /** @class */ (function () {\n    function HttpService(httpClient, apiUrl) {\n        this.httpClient = httpClient;\n        this.apiUrl = apiUrl;\n    }\n    var _a;\n    HttpService = __decorate([\n        Injectable(),\n        __param(1, Inject(API_URL)),\n        __metadata(\"design:paramtypes\", [typeof (_a = typeof HttpClient !== \"undefined\" &amp;&amp; HttpClient) \n          === \"function\" ? _a : Object, String])\n    ], HttpService);\n    return HttpService;\n}());</code></pre>\n<p>观察以上的代码会不会觉得有点晕？不要着急，阿宝哥会逐一分析 HttpService 中的两个参数。首先我们先来分析 <code>apiUrl</code> 参数：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023650525\" alt=\"\" title=\"\" /></p>\n<p>在图中我们可以很清楚地看到，<code>API_URL</code> 对应的 Token 最终会通过 Reflect.defineMetadata API 进行保存，所使用的 Key 是 <code>Symbol('INJECT_KEY')</code>。而对于另一个参数即 httpClient，它使用的 Key 是 <code>\"design:paramtypes\"</code>，它用于修饰目标对象方法的参数类型。</p>\n<p>除了 <code>\"design:paramtypes\"</code> 之外，还有其他的 <code>metadataKey</code>，比如 <code>design:type</code> 和 <code>design:returntype</code>，它们分别用于修饰目标对象的类型和修饰目标对象方法返回值的类型。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023650529\" alt=\"\" title=\"\" /></p>\n<p>由上图可知，HttpService 构造函数的参数类型最终会使用 <code>Reflect.metadata</code> API 进行存储。了解完上述的知识，接下来我们来定义一个 <code>getInjectedParams</code> 方法，用于获取类构造函数中声明的依赖对象，该方法的具体实现如下：</p>\n<pre><code class=\"typescript\">type InjectableParam = Type&lt;any&gt;;\nconst REFLECT_PARAMS = \"design:paramtypes\";\n\nprivate getInjectedParams&lt;T&gt;(target: Type&lt;T&gt;) {\n  // 获取参数的类型\n  const argTypes = Reflect.getMetadata(REFLECT_PARAMS, target) as (\n      | InjectableParam\n      | undefined\n  )[];\n  if (argTypes === undefined) {\n      return [];\n  }\n  return argTypes.map((argType, index) =&gt; {\n    // The reflect-metadata API fails on circular dependencies, and will return undefined\n    // for the argument instead.\n    if (argType === undefined) {\n      throw new Error(\n        `Injection error. Recursive dependency detected in constructor for type ${target.name} \n           with parameter at index ${index}`\n      );\n    }\n    const overrideToken = getInjectionToken(target, index);\n    const actualToken = overrideToken === undefined ? argType : overrideToken;\n    let provider = this.providers.get(actualToken);\n    return this.injectWithProvider(actualToken, provider);\n  });\n}</code></pre>\n<p>因为我们的 Token 的类型是 <code>Type&lt;T&gt; | InjectionToken</code> 联合类型，所以在 <code>getInjectedParams</code> 方法中我们也要考虑 InjectionToken 的情形，因此我们定义了一个 <code>getInjectionToken</code> 方法来获取使用 <code>@Inject</code> 装饰器注册的 Token，该方法的实现很简单：</p>\n<pre><code class=\"typescript\">export function getInjectionToken(target: any, index: number) {\n  return Reflect.getMetadata(INJECT_METADATA_KEY, target, `index-${index}`) as Token&lt;any&gt; | undefined;\n}</code></pre>\n<p>现在我们已经可以获取类构造函数中所依赖的对象，基于前面定义的 <code>getInjectedParams</code> 方法，我们就来定义一个 <code>injectClass</code> 方法，用来实例化 ClassProvider 所注册的类。</p>\n<pre><code class=\"typescript\">// { provide: HttpClient, useClass: HttpClient }\nprivate injectClass&lt;T&gt;(classProvider: ClassProvider&lt;T&gt;): T {\n  const target = classProvider.useClass;\n  const params = this.getInjectedParams(target);\n  return Reflect.construct(target, params);\n}</code></pre>\n<p>这时 IoC 容器中定义的两个方法都已经实现了，我们来看一下 IoC 容器的完整代码：</p>\n<pre><code class=\"typescript\">// container.ts\ntype InjectableParam = Type&lt;any&gt;;\n\nconst REFLECT_PARAMS = \"design:paramtypes\";\n\nexport class Container {\n  private providers = new Map&lt;Token&lt;any&gt;, Provider&lt;any&gt;&gt;();\n\n  addProvider&lt;T&gt;(provider: Provider&lt;T&gt;) {\n    this.assertInjectableIfClassProvider(provider);\n    this.providers.set(provider.provide, provider);\n  }\n\n  inject&lt;T&gt;(type: Token&lt;T&gt;): T {\n    let provider = this.providers.get(type);\n    if (provider === undefined &amp;&amp; !(type instanceof InjectionToken)) {\n      provider = { provide: type, useClass: type };\n      this.assertInjectableIfClassProvider(provider);\n    }\n    return this.injectWithProvider(type, provider);\n  }\n\n  private injectWithProvider&lt;T&gt;(type: Token&lt;T&gt;, provider?: Provider&lt;T&gt;): T {\n    if (provider === undefined) {\n      throw new Error(`No provider for type ${this.getTokenName(type)}`);\n    }\n    if (isClassProvider(provider)) {\n      return this.injectClass(provider as ClassProvider&lt;T&gt;);\n    } else if (isValueProvider(provider)) {\n      return this.injectValue(provider as ValueProvider&lt;T&gt;);\n    } else {\n      // Factory provider by process of elimination\n      return this.injectFactory(provider as FactoryProvider&lt;T&gt;);\n    }\n  }\n\n  private assertInjectableIfClassProvider&lt;T&gt;(provider: Provider&lt;T&gt;) {\n    if (isClassProvider(provider) &amp;&amp; !isInjectable(provider.useClass)) {\n      throw new Error(\n        `Cannot provide ${this.getTokenName(\n          provider.provide\n        )} using class ${this.getTokenName(\n          provider.useClass\n        )}, ${this.getTokenName(provider.useClass)} isn't injectable`\n      );\n    }\n  }\n\n  private injectClass&lt;T&gt;(classProvider: ClassProvider&lt;T&gt;): T {\n    const target = classProvider.useClass;\n    const params = this.getInjectedParams(target);\n    return Reflect.construct(target, params);\n  }\n\n  private injectValue&lt;T&gt;(valueProvider: ValueProvider&lt;T&gt;): T {\n    return valueProvider.useValue;\n  }\n\n  private injectFactory&lt;T&gt;(valueProvider: FactoryProvider&lt;T&gt;): T {\n    return valueProvider.useFactory();\n  }\n\n  private getInjectedParams&lt;T&gt;(target: Type&lt;T&gt;) {\n    const argTypes = Reflect.getMetadata(REFLECT_PARAMS, target) as (\n      | InjectableParam\n      | undefined\n    )[];\n    if (argTypes === undefined) {\n      return [];\n    }\n    return argTypes.map((argType, index) =&gt; {\n      // The reflect-metadata API fails on circular dependencies, and will return undefined\n      // for the argument instead.\n      if (argType === undefined) {\n        throw new Error(\n          `Injection error. Recursive dependency detected in constructor for type ${target.name} \n             with parameter at index ${index}`\n        );\n      }\n      const overrideToken = getInjectionToken(target, index);\n      const actualToken = overrideToken === undefined ? argType : overrideToken;\n      let provider = this.providers.get(actualToken);\n      return this.injectWithProvider(actualToken, provider);\n    });\n  }\n\n  private getTokenName&lt;T&gt;(token: Token&lt;T&gt;) {\n    return token instanceof InjectionToken\n      ? token.injectionIdentifier\n      : token.name;\n  }\n}</code></pre>\n<p>最后我们来简单测试一下我们前面开发的 IoC 容器，具体的测试代码如下所示：</p>\n<pre><code class=\"typescript\">// container.test.ts\nimport { Container } from \"./container\";\nimport { Injectable } from \"./injectable\";\nimport { Inject } from \"./inject\";\nimport { InjectionToken } from \"./provider\";\n\nconst API_URL = new InjectionToken(\"apiUrl\");\n\n@Injectable()\nclass HttpClient {}\n\n@Injectable()\nclass HttpService {\n  constructor(\n    private httpClient: HttpClient,\n    @Inject(API_URL) private apiUrl: string\n  ) {}\n}\n\nconst container = new Container();\n\ncontainer.addProvider({\n  provide: API_URL,\n  useValue: \"https://www.semlinker.com/\",\n});\n\ncontainer.addProvider({ provide: HttpClient, useClass: HttpClient });\ncontainer.addProvider({ provide: HttpService, useClass: HttpService });\n\nconst httpService = container.inject(HttpService);\nconsole.dir(httpService);</code></pre>\n<p>以上代码成功运行后，控制台会输出以下结果：</p>\n<pre><code class=\"shell\">HttpService {\n  httpClient: HttpClient {},\n  apiUrl: 'https://www.semlinker.com/' }</code></pre>\n<p>很明显该结果正是我们所期望的，这表示我们 IoC 容器已经可以正常工作了。当然在实际项目中，一个成熟的 IoC 容器还要考虑很多东西，如果小伙伴想在项目中使用的话，阿宝哥建议可以考虑使用 <a href=\"http://inversify.io/\" rel=\"nofollow noreferrer\">InversifyJS</a> 这个库。</p>\n<blockquote>\n 若需要获取完整 IoC 容器源码的话，可在 \n <strong>全栈修仙之路</strong> 公众号回复 ioc 关键字，即可获取。\n</blockquote>\n<h3>七、参考资源</h3>\n<ul>\n <li><a href=\"https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC\" rel=\"nofollow noreferrer\">维基百科 - 控制反转</a></li>\n <li><a href=\"https://stackblitz.com/edit/typescript-jsd5tr?file=index.ts\" rel=\"nofollow noreferrer\">Stackblitz - Car-Demo</a></li>\n <li><a href=\"https://rbuckton.github.io/reflect-metadata/\" rel=\"nofollow noreferrer\">Github - reflect-metadata</a></li>\n <li><a href=\"https://rbuckton.github.io/reflect-metadata/\" rel=\"nofollow noreferrer\">Metadata Proposal - ECMAScript</a></li>\n <li><a href=\"https://dev.to/darcyrayner/typescript-dependency-injection-in-200-loc-12j7\" rel=\"nofollow noreferrer\">typescript-dependency-injection-in-200-loc</a></li>\n</ul>\n<h3>八、推荐阅读</h3>\n<ul>\n <li><a href=\"http://www.semlinker.com/ts-quickstart-2020/\" rel=\"nofollow noreferrer\">了不起的 TypeScript 入门教程</a></li>\n <li><a href=\"http://www.semlinker.com/deno-quickstart/\" rel=\"nofollow noreferrer\">了不起的 Deno 入门篇</a></li>\n <li><a href=\"http://www.semlinker.com/deno-in-action/\" rel=\"nofollow noreferrer\">了不起的 Deno 实战教程</a></li>\n <li><a href=\"http://www.semlinker.com/you-dont-know-blob/\" rel=\"nofollow noreferrer\">你不知道的 Blob</a></li>\n <li><a href=\"http://www.semlinker.com/you-dont-know-weakmap/\" rel=\"nofollow noreferrer\">你不知道的 WeakMap</a></li>\n</ul>","descriptionType":"html","publishedDate":"Mon, 17 Aug 2020 00:43:46 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023650522","linkMd5":"569e2336cd79bc25ac4f434bfa5337fb","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn26@2020_5/2020/08/24/23-08-24-392_31a173cafd36f563.webp","destWidth":800,"destHeight":426,"sourceBytes":79664,"destBytes":37504,"author":"阿宝哥","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023650522":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn26@2020_5/2020/08/24/23-08-24-392_31a173cafd36f563.webp","https://segmentfault.com/img/remote/1460000023650524":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn93@2020_1/2020/08/24/23-08-31-248_82a398d90f8d4d67.webp","https://segmentfault.com/img/remote/1460000023650528":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn78@2020_4/2020/08/24/23-08-30-890_0a757f6a41f5f311.webp","https://segmentfault.com/img/remote/1460000023650527":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn70@2020_2/2020/08/24/23-08-31-206_51bb2ad6d7647e06.webp","https://segmentfault.com/img/remote/1460000023650521":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn86@2020_6/2020/08/24/23-08-31-209_90d83c08e9ab7de3.webp","https://segmentfault.com/img/remote/1460000023650523":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn89@2020_5/2020/08/24/23-08-31-279_e99c09a9a60e22c5.webp","https://segmentfault.com/img/remote/1460000023650526":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn66@2020_4/2020/08/24/23-08-31-671_9a1dabc2dfac2a2e.webp","https://segmentfault.com/img/remote/1460000023650525":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn57@2020_2/2020/08/24/23-08-30-874_b28db8e72475b886.webp","https://segmentfault.com/img/remote/1460000023650529":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn98@2020_2/2020/08/24/23-08-30-948_d37fcf9ccf470a5a.webp"},"publishedOrCreatedDate":1598310388567},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"RabbitMQ高级之如何保证消息可靠性？","link":"https://segmentfault.com/a/1190000023736395","description":"<blockquote>\n 人生终将是场单人旅途，孤独之前是迷茫，孤独过后是成长。\n</blockquote>\n<h2>楔子</h2>\n<p>本篇是消息队列<code>RabbitMQ</code>的第四弹。</p>\n<p><code>RabbitMQ</code>我已经写了三篇了，基础的收发消息和基础的概念我都已经写了，学任何东西都是这样，先基础的上手能用，然后遇到问题再去解决，无法理解就去深入源码，随着时间的积累对这一门技术的理解也会随之提高。</p>\n<p>基础操作已经熟练后，相信大家不可避免的会生出向那更高处攀登的心来，今天我就罗列一些<code>RabbitMQ</code>比较高级的用法，有些用得到有些用不上，但是一定要有所了解，因为大部分情况我们都是面向面试学习~</p>\n<ul>\n <li>如何保证消息的可靠性？</li>\n <li>消息队列如何进行限流？</li>\n <li><p>如何设置延时队列进行延时消费？</p>\n  <hr /></li>\n</ul>\n<p><a href=\"https://juejin.im/user/5cc53c8251882524f72ccef6/posts\" rel=\"nofollow noreferrer\">祝有好收获，先赞后看，快乐无限。</a></p>\n<p><strong>本文代码：</strong> <a href=\"https://gitee.com/he-erduo/spring-boot-learning-demo\" rel=\"nofollow noreferrer\">码云地址</a> <a href=\"https://github.com/he-erduo/spring-boot-learning-demo\" rel=\"nofollow noreferrer\">GitHub地址</a></p>\n<h2>1. 📖如何保证消息的可靠性？</h2>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023473305\" alt=\"rabbit架构图\" title=\"rabbit架构图\" /></p>\n<p>先来看看我们的万年老图，从图上我们大概可以看出来一个消息会经历四个节点，只有保证这四个节点的可靠性才能保证整个系统的可靠性。</p>\n<ul>\n <li>生产者发出后保证到达了MQ。</li>\n <li>MQ收到消息保证分发到了消息对应的Exchange。</li>\n <li>Exchange分发消息入队之后保证消息的持久性。</li>\n <li>消费者收到消息之后保证消息的正确消费。</li>\n</ul>\n<p>经历了这四个保证，我们才能保证消息的可靠性，从而保证消息不会丢失。</p>\n<h2>2. 🔍生产者发送消息到MQ失败</h2>\n<p>我们的生产者发送消息之后可能由于网络闪断等各种原因导致我们的消息并没有发送到MQ之中，但是这个时候我们生产端又不知道我们的消息没有发出去，这就会造成消息的丢失。</p>\n<p>为了解决这个问题，<code>RabbitMQ</code>引入了<strong>事务机制</strong>和<strong>发送方确认机制（publisher confirm）</strong>，由于事务机制过于耗费性能所以一般不用，这里我着重讲述<strong>发送方确认机制</strong>。</p>\n<p>这个机制很好理解，就是<strong>消息发送到MQ那端之后，MQ会回一个确认收到的消息给我们</strong>。</p>\n<hr>\n <p>打开此功能需要配置，接下来我来演示一下配置：</p>\n <pre><code class=\"yml\">spring:\n  rabbitmq:\n    addresses: 127.0.0.1\n    host: 5672\n    username: guest\n    password: guest\n    virtual-host: /\n    # 打开消息确认机制\n    publisher-confirm-type: correlated</code></pre>\n <p>我们只需要在配置里面打开消息确认即可(<strong>true</strong>是返回客户端，<strong>false</strong>是自动删除)。</p>\n <p><strong>生产者：</strong></p>\n <pre><code class=\"java\">    public void sendAndConfirm() {\n        User user = new User();\n\n        log.info(\"Message content : \" + user);\n\n        CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());\n        rabbitTemplate.convertAndSend(Producer.QUEUE_NAME,user,correlationData);\n        log.info(\"消息发送完毕。\");\n\n        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback(){\n            @Override\n            public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n                log.info(\"CorrelationData content : \" + correlationData);\n                log.info(\"Ack status : \" + ack);\n                log.info(\"Cause content : \" + cause);\n                if(ack){\n                    log.info(\"消息成功发送，订单入库，更改订单状态\");\n                }else{\n                    log.info(\"消息发送失败：\"+correlationData+\", 出现异常：\"+cause);\n                }\n            }\n        });\n    }</code></pre>\n <p>生产者代码里我们看到又多了一个参数：<code>CorrelationData</code>，这个参数是用来做消息的唯一标识，同时我们打开消息确认之后需要对<code>rabbitTemplate</code>多设置一个<code>setConfirmCallback</code>，参数是一个匿名类，我们消息确认成功or失败之后的处理就是写在这个匿名类里面。</p>\n <p>比如一条订单消息，当消息确认到达MQ确认之后再行入库或者修改订单的节点状态，如果消息没有成功到达MQ可以进行一次记录或者将订单状态修改。</p>\n <p><strong>Tip</strong>：消息确认失败不只有消息没发过去会触发，消息发过去但是找不到对应的Exchange，也会触发。</p>\n <h2>3. 📔MQ接收失败或者路由失败</h2>\n <p>生产者的发送消息处理好了之后，我们就可以来看看MQ端的处理，MQ可能出现两个问题：</p>\n <ol>\n  <li>消息找不到对应的Exchange。</li>\n  <li>找到了Exchange但是找不到对应的Queue。</li>\n </ol>\n <p>这两种情况都可以用<code>RabbitMQ</code>提供的<code>mandatory</code>参数来解决，它会设置消息投递失败的策略，有两种策略：自动删除或返回到客户端。</p>\n <p>我们既然要做可靠性，当然是设置为返回到客户端。</p>\n <hr>\n  <p><strong>配置：</strong></p>\n  <pre><code class=\"yml\">spring:\n  rabbitmq:\n    addresses: 127.0.0.1\n    host: 5672\n    username: guest\n    password: guest\n    virtual-host: /\n    # 打开消息确认机制\n    publisher-confirm-type: correlated\n    # 打开消息返回\n    publisher-returns: true\n    template:\n      mandatory: true</code></pre>\n  <p>我们只需要在配置里面打开消息返回即可，<code>template.mandatory: true</code>这一步不要少~</p>\n  <p><strong>生产者：</strong></p>\n  <pre><code class=\"java\">    public void sendAndReturn() {\n        User user = new User();\n\n        log.info(\"Message content : \" + user);\n\n        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; {\n            log.info(\"被退回的消息为：{}\", message);\n            log.info(\"replyCode：{}\", replyCode);\n            log.info(\"replyText：{}\", replyText);\n            log.info(\"exchange：{}\", exchange);\n            log.info(\"routingKey：{}\", routingKey);\n        });\n\n        rabbitTemplate.convertAndSend(\"fail\",user);\n        log.info(\"消息发送完毕。\");\n    }</code></pre>\n  <p>这里我们可以拿到被退回消息的所有信息，然后再进行处理，比如放到一个新的队列单独处理，路由失败一般都是配置问题了。</p>\n  <h2>4. 📑消息入队之后MQ宕机</h2>\n  <p>到这一步基本都是一些很小概率的问题了，比如MQ突然宕机了或者被关闭了，这种问题就必须要对消息做持久化，以便MQ重新启动之后消息还能重新恢复过来。</p>\n  <p>消息的持久化要做，但是不能只做消息的持久化，还要做队列的持久化和Exchange的持久化。</p>\n  <pre><code class=\"java\">    @Bean\n    public DirectExchange directExchange() {\n        // 三个构造参数：name durable autoDelete\n        return new DirectExchange(\"directExchange\", false, false);\n    }\n\n    @Bean\n    public Queue erduo() {\n        // 其三个参数：durable exclusive autoDelete\n        // 一般只设置一下持久化即可\n        return new Queue(\"erduo\",true);\n    }</code></pre>\n  <p>创建Exchange和队列时只要设置好持久化，发送的消息默认就是持久化消息。</p>\n  <p>设置持久化时一定要将Exchange和队列都设置上持久化：</p>\n  <p>单单只设置Exchange持久化，重启之后队列会丢失。单单只设置队列的持久化，重启之后Exchange会消失，既而消息也丢失，所以如果不两个一块设置持久化将毫无意义。</p>\n  <p><strong>Tip：</strong> 这些都是MQ宕机引起的问题，如果出现服务器宕机或者磁盘损坏则上面的手段统统无效，必须引入镜像队列，做异地多活来抵御这种不可抗因素。</p>\n  <h2>5. 📌消费者无法正常消费</h2>\n  <p>最后一步会出问题的地方就在消费者端了，不过这个解决问题的方法我们之前的文章已经说过了，就是消费者的消息确认。</p>\n  <pre><code class=\"yml\">spring:\n  rabbitmq:\n    addresses: 127.0.0.1\n    host: 5672\n    username: guest\n    password: guest\n    virtual-host: /\n    # 手动确认消息\n    listener:\n      simple:\n          acknowledge-mode: manual</code></pre>\n  <p>打开手动消息确认之后，只要我们这条消息没有成功消费，无论中间是出现消费者宕机还是代码异常，只要连接断开之后这条信息还没有被消费那么这条消息就会被重新放入队列再次被消费。</p>\n  <p>当然这也可能会出现重复消费的情况，不过在分布式系统中幂等性是一定要做的，所以一般重复消费都会被接口的幂等给拦掉。</p>\n  <p>所谓幂等性就是：<strong>一个操作多次执行产生的结果与一次执行产生的结果一致。</strong></p>\n  <p>幂等性相关内容不在本章讨论范围~所以我就不多做阐述了。</p>\n  <h2>6. 💡消息可靠性案例</h2>\n  <p><img src=\"https://segmentfault.com/img/remote/1460000023736398\" alt=\"消息可靠性架构\" title=\"消息可靠性架构\" /></p>\n  <p>这个图是我很早之前画的，是为了记录当时使用<code>RabbitMQ</code>做消息可靠性的具体做法，这里我正好拿出来做个例子给大家看一看。</p>\n  <p>这个例子中的消息是先入库的，然后生产者从DB里面拿到数据包装成消息发给MQ，经过消费者消费之后对DB数据的状态进行更改，然后重新入库。</p>\n  <p>这中间有任何步骤失败，数据的状态都是没有更新的，这时通过一个定时任务不停的去刷库，找到有问题的数据将它重新扔到生产者那里进行重新投递。</p>\n  <p>这个方案其实和网上的很多方案大同小异，基础的可靠性保证之后，定时任务做一个兜底进行不断的扫描，力图100%可靠性。</p>\n  <h2>后记</h2>\n  <p>越写越长，因为篇幅缘故限流和延时队列放到下一篇了，我会尽快发出来供大家阅读，讲真，我真的不是故意多水一篇的！！！</p>\n  <p>最后再给优狐打个广告，最近掘金在GitHub上面建立了一个开源计划 - <a href=\"https://github.com/juejin-im/open-source\" rel=\"nofollow noreferrer\">open-source</a>，旨在收录各种好玩的好用的开源库，如果大家有想要自荐或者分享的开源库都可以参与进去，为这个开源计划做一份贡献，同时这个开源库的<code>Start</code>也在稳步增长中，参与进去也可以增加自己项目的曝光度，一举两得。</p>\n  <p>同时这个开源库还有一个兄弟项目 - <a href=\"https://github.com/juejin-im/open-source-translation\" rel=\"nofollow noreferrer\">open-source-translation</a>，旨在招募技术文章翻译志愿者进行技术文章的翻译工作，<br>争做最棒开源翻译，翻译业界高质量文稿，为技术人的成长献一份力。</br></p>\n  <hr>\n   <p>最近这段时间事情挺多，优狐令我八月底之前升级到三级，所以各位读者的赞对我很重要，希望大家能够高抬贵手，帮我一哈~</p>\n   <p>好了，以上就是本期的全部内容，感谢你能看到这里，欢迎对本文点赞收藏与评论，👍你们的每个点赞都是我创作的最大动力。</p>\n   <p>我是耳朵，一个一直想做知识输出的伪文艺程序员，我们下期见。</p>\n   <p><strong>本文代码：</strong><a href=\"https://gitee.com/he-erduo/spring-boot-learning-demo\" rel=\"nofollow noreferrer\">码云地址</a> <a href=\"https://github.com/he-erduo/spring-boot-learning-demo\" rel=\"nofollow noreferrer\">GitHub地址</a></p>\n  </hr>\n </hr>\n</hr>","descriptionType":"html","publishedDate":"Mon, 24 Aug 2020 03:14:34 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023473305","linkMd5":"0350953f3ed11c58067e084970f74395","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn14@2020_2/2020/08/24/23-08-22-277_79d59aaca7438433.webp","destWidth":800,"destHeight":317,"sourceBytes":62172,"destBytes":17268,"author":"和耳朵","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023473305":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn14@2020_2/2020/08/24/23-08-22-277_79d59aaca7438433.webp","https://segmentfault.com/img/remote/1460000023736398":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn36@2020_5/2020/08/24/23-08-35-897_b31ea577fa877f02.webp"},"publishedOrCreatedDate":1598310388558},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"思否有约丨@洪光光：PHP 是世界上最好的语言，我搬着全世界最香的砖","link":"https://segmentfault.com/a/1190000023622134","description":"<p><img src=\"https://segmentfault.com/img/bVbLgRH\" alt=\"image.png\" title=\"image.png\"><br><em>洪光光（右二）</em></br></img></p>\n<p><strong>本期访谈嘉宾：<a href=\"https://segmentfault.com/u/guangguang_5ef84d351d77d\">洪光光</a></strong> <br><strong>访谈编辑：芒果果</strong></br></p>\n<p>洪光光成为一个程序员已经 4 年了，仍然对编程充满热情，他说：“<strong>php 是世界上最好的语言，我搬着全世界最香的砖。</strong>”他应该是我接触的程序员中最直白表达对编程热爱的人。</p>\n<p>虽然现在说起编程，我可以从洪光光的字里行间感受到他对自己工作的热爱，是那种把工作当成乐趣的享受。但其实，他走上编程之路却是因为大学毕业前英语四级没过，不得不靠参加比赛拿到毕业证书。因为只要获得全国开发奖项就可以代替四级证书顺利毕业。</p>\n<p>人的潜能是无限的，在面临无法毕业的情况下，洪光光就像回到了高考冲刺阶段，捧着单片机在办公室一坐就是半年。终于，在全国蓝桥杯单片机比赛中拿了奖，他也成为了学校自建校以来第一个获得全国硬件类奖项的学生。一时间，洪光光竟成了学校的风云人物。</p>\n<p>那时，他在学校宣传中讲的主题是《兴趣是最好的老师》，但是现在，他说：“如果再回到那个时候，我想改成《毕业是最好的压力》”。</p>\n<p><strong>洪光光的 4 年之坎儿</strong></p>\n<p>一开始只是希望能顺利毕业，没想到拿了个全国奖项，这就样洪光光顺理成章的成了一个程序员。</p>\n<p>但与毕业前就拿奖的风光经历不同，入行 4 年，洪光光最后悔的就是没有把为了拿到毕业证那种学习的热情坚持下来。过了几年安逸的生活后，他意识到了如果不把落下的时间不上，就很难在工作中作出成绩了。</p>\n<p>大学学制是 4 年，奥运会周期也是 4 年，4 年似乎是很多事情的一个砍。洪光光的大学 4 年决定了他的工作方向，<strong>入行后的 4 年他开始真正了解这个行业，也开始焦虑，因为现实和理想的差距，也因为自己的无能为力。</strong></p>\n<p><strong><em>Q：介绍一下自己吧。</em></strong></p>\n<p>我叫洪光光。如果一句话介绍自己从入行到现在，我想我应该是一个在路上走了四年差点走丢，代表着绝大数的一个平凡普通的开发仔。</p>\n<p><strong><em>Q：为什么说自己是差点走丢的开发仔？</em></strong></p>\n<p>我是一个没有拿得出手的开源项目、没有比较拔尖的技术、没有让人惊叹的天赋、没有坚韧不拔的自律的却怀着大厂梦做了很多与梦想毫无帮助的事情的人。</p>\n<p>2016 年毕业入行至今 4 年 前面 2 年一直保持高热情学习后面开始浑浑噩噩的混了 2 年，现在一直再偿还这两年欠下的窟窿债。因为自己过的太过平凡和平庸，也会在无数次的时候去问自己，自己还适合程序员吗?到了 30 岁如何保证自己不被淘汰?</p>\n<p>我觉的自己代表了很多平凡的程序员，想再平凡的生活里去试着绽放一点微亮，<strong>我们就算注定成为不了多耀眼的大佬也要保证自己走在路上。</strong></p>\n<p><strong><em>Q：入行 4 年了，你最大的感受是什么？</em></strong></p>\n<p>大家都说四年是一个坎，因为四年的时间足够去了解这个行业和足够了解自己，所以我开始感到焦虑。焦虑来源根本还是因为现实和理想的差距，说白还是来自现在的无能。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023622137\" alt=\"\" title=\"\" /></p>\n<p><strong>自律的养成除了高效完成工作还包括自律的生活，运动就是洪光光找到的适合自己的方式，他甚至把自己的微信昵称都改成了“运动光”。</strong></p>\n<p><strong>也许，这也是他督促自己的一种方式吧，就像有人会把昵称改成“不瘦十斤不改名”，以此来督促自己减肥一样。</strong></p>\n<p><strong>为了更健康的身体，也为了养成更好的习惯，洪光光会保证每周打两次羽毛球、一次网球、一次乒乓球。</strong></p>\n<p><strong>无论是学习还是运动，都是为了提升自己，让自己的精神和身体都过的充实，不再浪费时间。就像那个被毕业逼出来的全国奖项，最后一刻的突击或许能取得好成绩，但绝不是长久之计。想要点亮自己胸前的勋章，就必须脚踏实地的努力。</strong></p>\n<p><strong><em>Q：你如何化解焦虑的？</em></strong></p>\n<p>焦虑对我来说就像是痔疮，让我坐立难安。</p>\n<p>是谁在无数次的夜晚提醒你不要再打游戏了 要学习</p>\n<p>是谁在无数次的刷剧中提醒你不要再大游戏 要学习</p>\n<p>是谁在无数次的麻木CURD提醒你不要沉迷CURD 要学习</p>\n<p>除了学习，我也常常提醒自己要多运动，逐渐的慢慢从焦虑中怀疑人生到靠着焦虑逼着自己不断的往前走，焦虑是没办法彻底消除，但是可以尽可能的降低焦虑。</p>\n<p><strong><em>Q：用学习来缓解焦虑，那你有什么学习方法推荐吗？</em></strong></p>\n<p>失眠和焦虑是个好基友，可能很多人想着我白天工作很忙只能靠着晚上去学习充电，这里我并不是特别支持，因为我也尝试过每天学习到2点，白天变得特别疲惫，一段时间过后发现焦虑更加严重了。</p>\n<p>可以试着可以早点睡觉，然后早晨早点起来看一些书和技术文章再去上班，事实上充电时间实际上特别多，比如想想如何提高工作效力加高摸鱼时间等。</p>\n<p>其实<strong>程序员是一个你努力了一定就会有回报的职业</strong>，事实上很多人在无数个寂寞夜晚没能把持住自己学习的心。</p>\n<p>所以还是要不断靠焦虑去逼自己学习，我会不断的收藏各种大佬的文章，毕竟收藏就是精通。也会不断的阅读各种书籍，最近就在看陈雷的《REDIS5涉及与源码分析》和分析`swoole`的源码，有兴趣的可以看看我的`swoole`系列。</p>\n<p>如果真想让自己成为别人的口中的大佬，书和代码一样少不了。</p>\n<p><strong><em>Q：最近有没有尝试新的编程语言？一般通过什么方式和渠道提升自己的能力？</em></strong></p>\n<p>自己一直都再尝试的新的编程语言，4年以上的开发者都会明白编程语言只是一种业务的表达载体，这里跟人海茫茫的那些如同我一样的平凡开发仔说一句中肯的话，一定要用新语言多写项目，不然真的很容易忘记。</p>\n<p>学新语言的最好的方式就是写项目，但是不是瞎写，可以找个具体的场景去用新语言是实现，如果只是走一遍 CURD （那duck不必）</p>\n<p>学习语言的路径我一般都是会去买对应的书籍，然后放在床头枕着睡觉。所以建议大家直接上手撸哪里不会学哪里。等到入门了，再去深挖那些语言特性底层的一些东西。</p>\n<p><strong><em>Q：有什么个人的特别的工作习惯么？</em></strong></p>\n<p>我是一个做事效率特别高的人，所以我总有自己的时间去折腾一些工具和项目优化、甚至摸鱼。</p>\n<p>我的工作习惯就是专注做一件事情，就算摸鱼也要专注的摸鱼。很多人工作习惯可能coding半小时、微信十分钟，其实这种特别不好，尤其在不断被产品大佬各种会议轰炸的情况下，所以我工作基本就是 coding 就认真 coding，多出来的时间当然就是摸鱼充电上，这四年我基本没有遇到过项目延期或者项目出问题的事情。</p>\n<p><strong><em>Q：与思否的故事？</em></strong></p>\n<p>一开始是公司要做个技术分享，每个季度的每个人都需要分享两个主题，但是碍于写`ppt`排版太浪费时间了，想着写一个技术文章分享，经常在朋友圈看到各位大佬发的思否的文章（swoole大部分文章都来源思否），所以就自己注册一个账号到发布一篇《【SWOOLE系列】浅谈SWOOLE协程篇》文章。</p>\n<p>但是没想到一个用来公司分享的文章被`韩天峰`和`郭新华`给点赞和分享了，后来也被swoole的官方公众号转载了，瞬间感受了什么是平凡的生活绽放了一点微亮。尝到了一些甜头后又发布了几篇文章，真正的感受了社区的力量和一些信心。这里对那些点赞和收藏我文章的说了一句，你们都是码农届最靓的仔，也特别感谢思否作为一个平台让我感受到了自己的一些不不平凡。</p>\n<p><strong><em>Q：如何看待国内社区的环境和氛围？</em></strong></p>\n<p>我觉得国内的社区有一个很不好的现象就是一篇文章就算漏洞百出也能被不断的复制到各个论坛，导致大家搜索一个问题能搜索出各种无效的文章，还是需要大家有个自我判断的意识，就算复制粘贴也希望自己线下跑通和实践。</p>\n<p>作为一个常年的用搜索引擎开发的工程师，这几年也有很强烈的感受到国内的社区的逐渐的活跃和大佬的涌出，我记得之前出问题总在`stackoverflow`上查，现在基本上可以国内很多社区找到自己想要的答案。</p>\n<p><strong>小编有话说：</strong></p>\n<p>洪光光很像我们上学时班里那个淘气的男生，凭着自己的聪明，平时不努力但是考试前总会突击学习，然后就能取得不错的成绩。</p>\n<p>但是入行 4 年后他好像发生了不小的变化，25 岁的他却把“焦虑”挂在嘴上。</p>\n<p>这不仅是来自工作和生活的压力，更多的源于是他开始思考未来，规划人生了。因为不想再“混日子”，因为想要在技术领域有所建树，所以他开始认真的思考该如何改变现状。</p>\n<p>希望这份焦虑会像当初毕业时的压力一样，都成为他的动力。</p>\n<hr>\n <p><strong>欢迎有兴趣参与访谈的小伙伴踊跃报名，《思否有约》将把你与编程有关的故事记录下来。报名邮箱：mango@sifou.com</strong></p>\n <p><img src=\"https://segmentfault.com/img/bVbJcHj\" alt=\"segmentfault公众号\" title=\"segmentfault公众号\" /></p>\n</hr>","descriptionType":"html","publishedDate":"Fri, 14 Aug 2020 05:48:19 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLgRH","linkMd5":"feb087fef9d4181f56dd8589fa8fcc79","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn30@2020_3/2020/08/24/23-08-23-291_58228cad1bdea290.webp","destWidth":800,"destHeight":507,"sourceBytes":607936,"destBytes":65920,"author":"芒果果","articleImgCdnMap":{"https://segmentfault.com/img/bVbLgRH":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn30@2020_3/2020/08/24/23-08-23-291_58228cad1bdea290.webp","https://segmentfault.com/img/remote/1460000023622137":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn100@2020_3/2020/08/24/23-08-45-005_b456f90a4d7dc104.webp","https://segmentfault.com/img/bVbJcHj":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn20@2020_2/2020/08/24/23-08-37-345_f113e092cc336adb.webp"},"publishedOrCreatedDate":1598310388567},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"SSL 证书过期事件频发，切忌不要因小失大！","link":"https://segmentfault.com/a/1190000023608432","description":"<p><img src=\"https://segmentfault.com/img/bVbLdLv\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n<p><strong>技术编辑：徐九丨发自：思否编辑部</strong></p>\n<hr>\n <p>不久前，微博有了一个技术圈儿的热搜。</p>\n <p>在同一时间，<strong>大量特斯拉车主纷纷反映 APP 出现大面积宕机，手机钥匙无法获取车辆信息，行车过程中无法点亮车内仪表盘和中控屏只能“盲开”。</strong></p>\n <p><img src=\"https://segmentfault.com/img/bVbLdLF\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n <p>在紧急修复之后，特斯拉官方表示原因系 APP 域名证书（SSL 证书）过期，导致 APP 无法连接。这样一个推崇技术的企业竟然出现这种低级的技术问题，难免让人唏嘘。</p>\n <p>但其实 SSL 证书过期事件，曾经在众多大型企业甚至国外某些政府机构网站均出现过。据《企业数字证书管理安全调查 2019》权威报告统计，<strong>74% 的组织经历过停机或由于证书过期导致的停机， 每个组织的平均损失超过 1100 万美元。</strong></p>\n <p>为什么大家连一个简单的证书认证都搞不好？SSL 证书对企业来说到底有什么用？</p>\n <h2>一、从 HTTP 协议的致命缺陷说起</h2>\n <p><img src=\"https://segmentfault.com/img/bVbLdLG\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n <p>HTTP 协议有一个致命缺陷，即这是一种没有加密的明文传输协议，不能安全的传输敏感数据信息。而发明 SSL 协议的初衷，就是为了解决 HTTP 的这一问题。和 SSL 经常一起出现的 TLS，是将 SSL 协议标准化之后的名称，因此经常有人将其并列称为 SSL/TLS。</p>\n <p>SSL/TLS 证书作为数据安全和隐私保护的安全标签，在网络中被大量使用，但近几年来，互联网安全事件仍然频发，究其原因，<strong>一是因为企业安全意识疏忽导致的证书过期，另一个原因是此前证书的寿命过长，大部分企业不会配合进行频繁的证书更新。</strong></p>\n <p>为了避免这一问题，从 2020 年 9 月 1 日开始，苹果、谷歌、Mozilla 的浏览器和设备将对有效期超过 398 天的新 TLS 证书显示错误。</p>\n <p><img src=\"https://segmentfault.com/img/bVbLdLH\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n <p>要知道最早的证书寿命是 8 年，后来慢慢缩短为5年、3 年、2 年，这次缩短为一年左右，无疑为企业原本就繁琐困难的证书管理再次增加了难度。</p>\n <p>那么安装 SSL/TLS 证书真的有必要么？不安装又会出现什么问题？</p>\n <h2>二、企业必须安装 SSL/TLS 证书么？</h2>\n <p><img src=\"https://segmentfault.com/img/bVbLdLI\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n <p>毫无疑问，证书有效期期缩短会增加证书使用者更新证书的频率。企业需要每年进行一次证书申请，而证书申请一般要走商务合同、经过层层审核。过程繁琐且周期长，若是疏忽忘记更新，还会导致证书过期，从而为企业带来利益和品牌的双重损失。</p>\n <p>但这个证书不装可能还真不行。</p>\n <p>首先<strong>在国家层面，一直有相应的法律法规要求进行相应的数据加密。</strong>在今年新修订的《信息安全技术网络安全等级保护基本要求》等系列国家标准中，更是明确了网络安全体系承建者、网络运营者等各方对于网络安全的责任和义务。</p>\n <p>此外，对于网站自身来说，<strong>安装了安全证书后可以有效的防止黑客的窃取和篡改，降低企业的业务风险。</strong>网站在安装相应的证书后，在浏览器地址栏会显示一个「安全锁」，告诉用户这个网站是经过认证的。</p>\n <p><img src=\"https://segmentfault.com/img/bVbLdLJ\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n <p>一些高级证书还支持在地址栏显示公司的名称，让访客明确知道这是企业官网，可以放心访问。并且，进行 SSL/TLS 证书认证，对于企业的 SEO 优化也是有帮助的。</p>\n <h2>三、企业的痛点要如何解决？</h2>\n <p><img src=\"https://segmentfault.com/img/bVbLdLK\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n <p>既然安装 SSL/TLS 证书势在必行，并且也对企业有着实实在在的好处，为什么企业还要这么发愁？具体有哪些痛点需要解决？</p>\n <p>首先，<strong>证书的管理就是一件麻烦事，从签发到续签、替换和吊销都有着繁琐的过程；其次，证书的数量与种类多种多样</strong>，个人身份证书、企业或机构身份证书、支付网关证书、服务器证书、安全电子邮件证书、个人代码签名证书...很多企业压根就搞不清自己需要安装哪些、需要安装多少。</p>\n <p>此次随着证书寿命的进一步缩短，更是增加了企业证书管理的难度。但其实企业的安全证书管理是有捷径的，目前市面上最专业的证书自动化管理平台，已经可以提供<strong>自动化交付</strong>的相关功能，比如：</p>\n <ul>\n  <li>多年期证书服务</li>\n  <li>快速自动验证</li>\n  <li>集成 ACME 协议部署</li>\n  <li>企业组织信息预审核</li>\n  <li>...</li>\n </ul>\n <h2>四、业内领先的自动化平台有哪些能力？</h2>\n <p><img src=\"https://segmentfault.com/img/bVbLdLP\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n <p>亚洲诚信是亚数信息科技（上海）有限公司应用于信息安全领域的品牌，专业为各行业提供国际知名品牌数字证书及网络信息安全管理解决方案。</p>\n <p>根据 NetCraft 数据显示，<strong>亚洲诚信旗下的 TrustAsia SSL 证书在国内品牌证书的市场占有率为第一。</strong>目前其客户覆盖电子商务 、互联网金融、银行及政府机构、保险证券、医疗机构、系统与软件开发商等各个领域。共申请 30 余项软著，4 项专利等技术成果。</p>\n <p>我们以 CertCloud 为例，来看看证书自动化管理平台具体可以提供哪些服务于能力：</p>\n <p><img src=\"https://segmentfault.com/img/bVbLdLW\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n <h4>1. 多年期证书自动化交付</h4>\n <p>这项功能在新政策的实施后显得更为实用。借助 CertCloud 服务，无需企业手动操作，可以自动延长证书有效期，避免因遗忘证书到期时间而未及时更新证书。</p>\n <h4>2. 简化、自动化管理证书生命周期</h4>\n <p>前面我们提到，企业安全证书的管理其实是一个非常繁琐的过程，CertCloud 可以帮助简化、自动化管理证书生命周期的每一阶段（从签发到续签、替换和吊销），并且还可以帮助企业通过信息预审核，大幅缩短 OV/EV 证书的签发周期，快速获取 OV/EV 证书。</p>\n <h4>3. 良好的适配性</h4>\n <p>很多企业需要部署很多不同的环境，而CertCloud 可以适配多类部署环境，支持ACME 、命令行 、各大云服务（ 阿里、腾讯、华为等）、主流 WEB SERVERS（Nginx/Apache/IIS 等）、网关设备（F5/SSLVPN 等），以及 OPENAPI，一站式的帮助企业解决安全证书的问题。</p>\n <h4>4. 自定义私钥轮换周期</h4>\n <p>很多时候的安全风险，是因为私钥不进行定期更新导致的。CertCloud 可以提供定期更新私钥的功能，用户可以自定义更换周期，从而满足不同安全需求。</p>\n <h4>5. 密码敏捷性</h4>\n <p>自动化工具快速应对安全问题，借助ACME、OPENAPI、命令行工具快速签发证书证书更新私钥。</p>\n <h4>6. 安全评级管理 + 监控告警</h4>\n <p>持续的监控证书状态的功能，精确定位问题，异常情况实时告警，避免人工监控疏忽带来的安全风险。</p>\n <h4>7. 证书详细安全报告</h4>\n <p>一键扫描证书的漏洞和弱配置避免产生安全问题（内置 MySSL.com 提供支持），可以在任何时刻查看网络安全状态的分析和报告。</p>\n <h4>8. 安全策略</h4>\n <p>通过多因素身份验证和证书请求的 IP 地址限制以及项目隔离来提高安全性，规避黑客攻击的风险。</p>\n <hr>\n  <p>这些功能都是企业在证书管理中的痛点与难点，如果可以借助专业的平台实现自动化管理，将大大降低企业的管理成本与风险。</p>\n  <p><strong>从更大的角度来看，现在可能是企业开始考虑自动化证书管理的好时机</strong>，尤其是对于管理数十个公共可信网站证书的大型组织。</p>\n  <p>随着技术的发展与完善，自动化运维已经成为了发展趋势，特别是<strong>涉及到业务安全以及企业利益的时候，介入专业的平台或者工具无疑是降本增效的好策略。</strong></p>\n  <hr>\n   <p><img src=\"https://segmentfault.com/img/bVbLdL2\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n   <p>亚洲诚信从成立以来，一直致力于 SSL 证书在中国的应用和普及。亚洲诚信 CEO 翟新元作为业内最早的技术专家之一，<strong>曾主导了云端自动化 SSL 证书模式的实现，使 SSL 证书从传统的交付方式革新到云端一键开启 HTTPS 的精简模式</strong>，为中国站点应用 HTTPS 安全加密传输的普及也做出了广受业界认可的贡献。</p>\n   <p>在数据即资产的年代，没有什么比数据安全更为重要。</p>\n   <p>开放和信任的互联网是全球性的、相互合作的网络世界，其基础是信任机制。尤其在新的国际形势和国内进一步的规范要求下，企业更加需要确保网络安全、数据隐私安全，而亚洲诚信也在致力于让这一「老大难」的问题，变得更加简单、便利。</p>\n   <p>-完-</p>\n   <p><img src=\"https://segmentfault.com/img/bVbKULG\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n  </hr>\n </hr>\n</hr>","descriptionType":"html","publishedDate":"Thu, 13 Aug 2020 07:16:20 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLdLv","linkMd5":"749b88d16e8263f6e6691f06881f8209","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn69@2020_2/2020/08/24/23-08-22-589_061a58f778cd47e5.webp","destWidth":800,"destHeight":300,"sourceBytes":101996,"destBytes":7834,"author":"徐九","articleImgCdnMap":{"https://segmentfault.com/img/bVbLdLv":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn69@2020_2/2020/08/24/23-08-22-589_061a58f778cd47e5.webp","https://segmentfault.com/img/bVbLdLF":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn22@2020_1/2020/08/24/23-08-31-096_8bc295045278e761.webp","https://segmentfault.com/img/bVbLdLG":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn18@2020_2/2020/08/24/23-08-31-035_63b0ce2dc1f9a19f.webp","https://segmentfault.com/img/bVbLdLH":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn30@2020_3/2020/08/24/23-08-32-395_1f1e125dfeab6f55.webp","https://segmentfault.com/img/bVbLdLI":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn26@2020_2/2020/08/24/23-08-31-464_32e3bd917b7c4cb4.webp","https://segmentfault.com/img/bVbLdLJ":"https://cdn.jsdelivr.net/gh/myreaderx/cdn38@2020_1/2020/08/24/23-08-33-099_547588ad0b88b0f6.webp","https://segmentfault.com/img/bVbLdLK":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn34@2020_1/2020/08/24/23-08-33-617_a294f8a47711264c.webp","https://segmentfault.com/img/bVbLdLP":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn50@2020_6/2020/08/24/23-08-33-234_a531250d12d5cd21.webp","https://segmentfault.com/img/bVbLdLW":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn42@2020_2/2020/08/24/23-08-32-865_bc2956f96c8c82ca.webp","https://segmentfault.com/img/bVbLdL2":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn13@2020_3/2020/08/24/23-08-31-249_cae8c8909f921d73.webp","https://segmentfault.com/img/bVbKULG":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn27@2020_5/2020/08/24/23-08-36-689_6b82b381e1690545.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"“既生 ExecutorService, 何生 CompletionService？”","link":"https://segmentfault.com/a/1190000023587881","description":"<p><img src=\"https://segmentfault.com/img/bVbK8rH\" alt=\"\" title=\"\" /></p>\n<h2>前言</h2>\n<p>在 <a href=\"https://dayarch.top/p/why-we-need-to-use-threadpool.html\" rel=\"nofollow noreferrer\">我会手动创建线程，为什么要使用线程池?</a> 中详细的介绍了 ExecutorService，可以将整块任务拆分做简单的并行处理；</p>\n<p>在 <a href=\"https://dayarch.top/p/java-future-and-callable.html\" rel=\"nofollow noreferrer\">不会用Java Future，我怀疑你泡茶没我快</a> 中又详细的介绍了 Future 的使用，填补了 Runnable 不能获取线程执行结果的空缺</p>\n<p>将二者结合起来使用看似要一招吃天下了（Java有并发，并发之大，一口吃不下）, but ～～ 是我太天真</p>\n<p><img src=\"https://segmentfault.com/img/bVbK8rI\" alt=\"\" title=\"\" /></p>\n<h2>ExecutorService VS CompletionService</h2>\n<p>假设我们有 4 个任务(A, B, C, D)用来执行复杂的计算，每个任务的执行时间随着输入参数的不同而不同，如果将任务提交到 ExecutorService， 相信你已经可以“信手拈来”</p>\n<pre><code class=\"java\">ExecutorService executorService = Executors.newFixedThreadPool(4);\nList&lt;Future&gt; futures = new ArrayList&lt;Future&lt;Integer&gt;&gt;();\nfutures.add(executorService.submit(A));\nfutures.add(executorService.submit(B));\nfutures.add(executorService.submit(C));\nfutures.add(executorService.submit(D));\n\n// 遍历 Future list，通过 get() 方法获取每个 future 结果\nfor (Future future:futures) {\n    Integer result = future.get();\n    // 其他业务逻辑\n}</code></pre>\n<p>先直入主题，用 CompletionService 实现同样的场景</p>\n<pre><code class=\"java\">ExecutorService executorService = Executors.newFixedThreadPool(4);\n\n// ExecutorCompletionService 是 CompletionService 唯一实现类\nCompletionService executorCompletionService= new ExecutorCompletionService&lt;&gt;(executorService );\n\nList&lt;Future&gt; futures = new ArrayList&lt;Future&lt;Integer&gt;&gt;();\nfutures.add(executorCompletionService.submit(A));\nfutures.add(executorCompletionService.submit(B));\nfutures.add(executorCompletionService.submit(C));\nfutures.add(executorCompletionService.submit(D));\n\n// 遍历 Future list，通过 get() 方法获取每个 future 结果\nfor (int i=0; i&lt;futures.size(); i++) {\n    Integer result = executorCompletionService.take().get();\n    // 其他业务逻辑\n}</code></pre>\n<p>两种方式在代码实现上几乎一毛一样，我们曾经说过 JDK 中不会重复造轮子，如果要造一个新轮子，必定是原有的轮子在某些场景的使用上有致命缺陷</p>\n<p><img src=\"https://segmentfault.com/img/bVbK8rJ\" alt=\"\" title=\"\" /></p>\n<p>既然新轮子出来了，二者到底有啥不同呢？ 在 <a href=\"https://dayarch.top/p/java8-completablefuture-tutorial.html\" rel=\"nofollow noreferrer\">搞定 CompletableFuture，并发异步编程和编写串行程序还有什么区别？</a> 文中，我们提到了 <code>Future get()</code> 方法的致命缺陷:</p>\n<blockquote>\n 如果 Future 结果没有完成，调用 get() 方法，程序会\n <strong>阻塞</strong>在那里，直至获取返回结果\n</blockquote>\n<p>先来看第一种实现方式，假设任务 A 由于参数原因，执行时间相对任务 B,C,D 都要长很多，但是按照程序的执行顺序，程序在 get() 任务 A 的执行结果会阻塞在那里，导致任务 B,C,D 的后续任务没办法执行。又因为每个任务执行时间是不固定的，<strong>所以无论怎样调整将任务放到 List 的顺序，都不合适，这就是致命弊端</strong></p>\n<p>新轮子自然要解决这个问题，它的设计理念就是哪个任务先执行完成，get() 方法就会获取到相应的任务结果，这么做的好处是什么呢？来看个图你就瞬间理解了</p>\n<p><img src=\"https://segmentfault.com/img/bVbK8rK\" alt=\"\" title=\"\" /></p>\n<p><img src=\"https://segmentfault.com/img/bVbK8rL\" alt=\"\" title=\"\" /></p>\n<p>两张图一对比，执行时长高下立判了，在当今高并发的时代，这点时间差，在吞吐量上起到的效果可能不是一点半点了</p>\n<blockquote>\n 那 CompletionService 是怎么做到获取最先执行完的任务结果的呢？\n</blockquote>\n<p><img src=\"https://segmentfault.com/img/bVbK8rM\" alt=\"\" title=\"\" /></p>\n<h2>远看CompletionService 轮廓</h2>\n<p>如果你使用过消息队列，你应该秒懂我要说什么了，CompletionService 实现原理很简单</p>\n<blockquote>\n 就是一个将异步任务的生产和任务完成结果的消费解耦的服务\n</blockquote>\n<p>用人话解释一下上面的抽象概念我只能再画一张图了</p>\n<p><img src=\"https://segmentfault.com/img/bVbK8rN\" alt=\"\" title=\"\" /></p>\n<p>说白了，哪个任务执行的完，就直接将执行结果放到队列中，这样消费者拿到的结果自然就是最早拿到的那个了</p>\n<p>从上图中看到，有<strong>任务</strong>，有<strong>结果队列</strong>，那 <code>CompletionService</code> 自然也要围绕着几个关键字做文章了</p>\n<ul>\n <li>既然是异步任务，那自然可能用到 Runnable 或 Callable</li>\n <li>既然能获取到结果，自然也会用到 Future 了</li>\n</ul>\n<p>带着这些线索，我们走进 <strong>CompletionService</strong> 源码看一看</p>\n<h2>近看 CompletionService 源码</h2>\n<p><code>CompletionService</code> 是一个接口，它简单的只有 5 个方法：</p>\n<pre><code class=\"java\">Future&lt;V&gt; submit(Callable&lt;V&gt; task);\nFuture&lt;V&gt; submit(Runnable task, V result);\nFuture&lt;V&gt; take() throws InterruptedException;\nFuture&lt;V&gt; poll();\nFuture&lt;V&gt; poll(long timeout, TimeUnit unit) throws InterruptedException;</code></pre>\n<p>关于 2 个 submit 方法， 我在 <a href=\"https://dayarch.top/p/java-future-and-callable.html\" rel=\"nofollow noreferrer\">不会用Java Future，我怀疑你泡茶没我快</a> 文章中做了非常详细的分析以及案例使用说明，这里不再过多赘述</p>\n<p><img src=\"https://segmentfault.com/img/bVbJkcQ\" alt=\"\" title=\"\" /></p>\n<p>另外 3 个方法都是从阻塞队列中获取并移除阻塞队列第一个元素，只不过他们的功能略有不同</p>\n<ul>\n <li>Take: 如果<strong>队列为空</strong>，那么调用 <strong>take()</strong> 方法的线程会<strong>被阻塞</strong></li>\n <li>Poll: 如果<strong>队列为空</strong>，那么调用 <strong>poll()</strong> 方法的线程会<strong>返回 null</strong></li>\n <li>Poll-timeout: 以<strong>超时的方式</strong>获取并移除阻塞队列中的第一个元素，如果超时时间到，队列还是空，那么该方法会返回 null</li>\n</ul>\n<p>所以说，按大类划分上面5个方法，其实就是两个功能</p>\n<ul>\n <li>提交异步任务 （submit）</li>\n <li>从队列中拿取并移除第一个元素 (take/poll)</li>\n</ul>\n<p><code>CompletionService</code> 只是接口，<code>ExecutorCompletionService</code> 是该接口的唯一实现类</p>\n<h3>ExecutorCompletionService 源码分析</h3>\n<p>先来看一下类结构, 实现类里面并没有多少内容</p>\n<p>&lt;fancybox&gt;<img src=\"https://segmentfault.com/img/bVbK8rO\" alt=\"\" title=\"\">&lt;/fancybox&gt;</img></p>\n<p><code>ExecutorCompletionService</code> 有两种构造函数：</p>\n<pre><code class=\"java\">private final Executor executor;\nprivate final AbstractExecutorService aes;\nprivate final BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;\n\npublic ExecutorCompletionService(Executor executor) {\n    if (executor == null)\n        throw new NullPointerException();\n    this.executor = executor;\n    this.aes = (executor instanceof AbstractExecutorService) ?\n        (AbstractExecutorService) executor : null;\n    this.completionQueue = new LinkedBlockingQueue&lt;Future&lt;V&gt;&gt;();\n}\n\n</code></pre>\n<pre><code class=\"java\">public ExecutorCompletionService(Executor executor,\n                                 BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue) {\n    if (executor == null || completionQueue == null)\n        throw new NullPointerException();\n    this.executor = executor;\n    this.aes = (executor instanceof AbstractExecutorService) ?\n        (AbstractExecutorService) executor : null;\n    this.completionQueue = completionQueue;\n}</code></pre>\n<p>两个构造函数都需要传入一个 Executor 线程池，<strong>因为是处理异步任务的，我们是不被允许手动创建线程的</strong>，所以这里要使用线程池也就很好理解了</p>\n<p>另外一个参数是 BlockingQueue，如果不传该参数，就会默认队列为 <code>LinkedBlockingQueue</code>，任务执行结果就是加入到这个阻塞队列中的</p>\n<p>所以要彻底理解 <code>ExecutorCompletionService</code> ，我们只需要知道一个问题的答案就可以了：</p>\n<blockquote>\n 它是如何将异步任务结果放到这个阻塞队列中的？\n</blockquote>\n<p>想知道这个问题的答案，那只需要看它提交任务之后都做了些什么？</p>\n<pre><code class=\"java\">public Future&lt;V&gt; submit(Callable&lt;V&gt; task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture&lt;V&gt; f = newTaskFor(task);\n    executor.execute(new QueueingFuture(f));\n    return f;\n}</code></pre>\n<p>我们前面也分析过，execute 是提交 Runnable 类型的任务，本身得不到返回值，但又可以将执行结果放到阻塞队列里面，所以肯定是在 QueueingFuture 里面做了文章</p>\n<p><img src=\"https://segmentfault.com/img/bVbK8rP\" alt=\"\" title=\"\" /></p>\n<p>从上图中看一看出，QueueingFuture 实现的接口非常多，所以说也就具备了相应的接口能力。</p>\n<p>重中之重是，它继承了 FutureTask ，FutureTask 重写了 Runnable 的 run() 方法 (方法细节分析可以查看<a href=\"https://dayarch.top/p/java-future-and-callable.html#FutureTask\" rel=\"nofollow noreferrer\">FutureTask源码分析</a> ) 文中详细说明了，无论是set() 正常结果，还是setException() 结果，都会调用 <code>finishCompletion()</code> 方法:</p>\n<pre><code class=\"java\">private void finishCompletion() {\n    // assert state &gt; COMPLETING;\n    for (WaitNode q; (q = waiters) != null;) {\n        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n            for (;;) {\n                Thread t = q.thread;\n                if (t != null) {\n                    q.thread = null;\n                    LockSupport.unpark(t);\n                }\n                WaitNode next = q.next;\n                if (next == null)\n                    break;\n                q.next = null; // unlink to help gc\n                q = next;\n            }\n            break;\n        }\n    }\n\n      // 重点 重点 重点\n    done();\n\n    callable = null;        // to reduce footprint\n}</code></pre>\n<p>上述方法会执行 done() 方法，而 QueueingFuture 恰巧重写了 FutureTask 的 done() 方法：</p>\n<p><img src=\"https://segmentfault.com/img/bVbK8rQ\" alt=\"\" title=\"\" /></p>\n<p>方法实现很简单，就是将 task 放到阻塞队列中</p>\n<pre><code class=\"java\">protected void done() { \n  completionQueue.add(task); \n}</code></pre>\n<p>执行到此的 task 已经是前序步骤 set 过结果的 task，所以就可以通过消费阻塞队列获取相应的结果了</p>\n<p>相信到这里，CompletionService 在你面前应该没什么秘密可言了</p>\n<h2>CompletionService 的主要用途</h2>\n<p>在 JDK docs 上明确给了两个例子来说明 CompletionService 的用途：</p>\n<blockquote>\n 假设你有一组针对某个问题的solvers，每个都返回一个类型为Result的值，并且想要并发地运行它们，处理每个返回一个非空值的结果，在某些方法使用(Result r)\n</blockquote>\n<p>其实就是文中开头的使用方式</p>\n<pre><code class=\"java\"> void solve(Executor e,\n            Collection&lt;Callable&lt;Result&gt;&gt; solvers)\n     throws InterruptedException, ExecutionException {\n     CompletionService&lt;Result&gt; ecs\n         = new ExecutorCompletionService&lt;Result&gt;(e);\n     for (Callable&lt;Result&gt; s : solvers)\n         ecs.submit(s);\n     int n = solvers.size();\n     for (int i = 0; i &lt; n; ++i) {\n         Result r = ecs.take().get();\n         if (r != null)\n             use(r);\n     }\n }</code></pre>\n<blockquote>\n 假设你想使用任务集的第一个非空结果，忽略任何遇到异常的任务，并在第一个任务准备好时取消所有其他任务\n</blockquote>\n<pre><code class=\"java\">void solve(Executor e,\n            Collection&lt;Callable&lt;Result&gt;&gt; solvers)\n     throws InterruptedException {\n     CompletionService&lt;Result&gt; ecs\n         = new ExecutorCompletionService&lt;Result&gt;(e);\n     int n = solvers.size();\n     List&lt;Future&lt;Result&gt;&gt; futures\n         = new ArrayList&lt;Future&lt;Result&gt;&gt;(n);\n     Result result = null;\n     try {\n         for (Callable&lt;Result&gt; s : solvers)\n             futures.add(ecs.submit(s));\n         for (int i = 0; i &lt; n; ++i) {\n             try {\n                 Result r = ecs.take().get();\n                 if (r != null) {\n                     result = r;\n                     break;\n                 }\n             } catch (ExecutionException ignore) {}\n         }\n     }\n     finally {\n         for (Future&lt;Result&gt; f : futures)\n               // 注意这里的参数给的是 true，详解同样在前序 Future 源码分析文章中\n             f.cancel(true);\n     }\n\n     if (result != null)\n         use(result);\n }</code></pre>\n<p>这两种方式都是非常经典的 CompletionService 使用 <strong>范式</strong> ，请大家仔细品味每一行代码的用意</p>\n<p>范式没有说明 Executor 的使用，使用 ExecutorCompletionService，需要自己创建线程池，看上去虽然有些麻烦，但好处是你可以让多个 ExecutorCompletionService 的线程池隔离，这种隔离性能避免几个特别耗时的任务拖垮整个应用的风险 （这也是我们反复说过多次的，<strong>不要所有业务共用一个线程池</strong>）</p>\n<h2>总结</h2>\n<p>CompletionService 的应用场景还是非常多的，比如</p>\n<ul>\n <li>Dubbo 中的 Forking Cluster</li>\n <li>多仓库文件/镜像下载（从最近的服务中心下载后终止其他下载过程）</li>\n <li>多服务调用（天气预报服务，最先获取到的结果）</li>\n</ul>\n<p>CompletionService 不但能满足获取最快结果，还能起到一定 \"load balancer\" 作用，获取可用服务的结果，使用也非常简单， 只需要遵循范式即可</p>\n<p><a href=\"https://dayarch.top/categories/Coding/Java-Concurrency/\" rel=\"nofollow noreferrer\">并发系列</a> 讲了这么多，分析源码的过程也碰到各种队列，接下来我们就看看那些让人眼花缭乱的队列</p>\n<h2>灵魂追问</h2>\n<ol>\n <li>通常处理结果还会用异步方式进行处理，如果采用这种方式，有哪些注意事项？</li>\n <li>如果是你，你会选择使用无界队列吗？为什么？</li>\n</ol>\n<p>日拱一兵 ｜ 原创</p>","descriptionType":"html","publishedDate":"Wed, 12 Aug 2020 01:09:02 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbK8rH","linkMd5":"38260b3f6e6b52df89d4a67c52a99d4e","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx/cdn2@2020_3/2020/08/24/23-08-22-403_40b51c4991f714b5.webp","destWidth":800,"destHeight":444,"sourceBytes":79075,"destBytes":58018,"author":"日拱一兵","articleImgCdnMap":{"https://segmentfault.com/img/bVbK8rH":"https://cdn.jsdelivr.net/gh/myreaderx/cdn2@2020_3/2020/08/24/23-08-22-403_40b51c4991f714b5.webp","https://segmentfault.com/img/bVbK8rI":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn92@2020_5/2020/08/24/23-08-36-947_42b85b2ae6d997a1.webp","https://segmentfault.com/img/bVbK8rJ":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn96@2020_2/2020/08/24/23-08-36-120_24bfbdbe72cc45ff.webp","https://segmentfault.com/img/bVbK8rK":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn99@2020_4/2020/08/24/23-08-37-087_cedf4db363bdd8fe.webp","https://segmentfault.com/img/bVbK8rL":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn8@2020_4/2020/08/24/23-08-36-839_67cdf4d01f6a82ed.webp","https://segmentfault.com/img/bVbK8rM":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn76@2020_3/2020/08/24/23-08-34-896_2dc307b4541a0abd.webp","https://segmentfault.com/img/bVbK8rN":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn80@2020_3/2020/08/24/23-08-36-263_3c39699332f578b1.webp","https://segmentfault.com/img/bVbJkcQ":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn3@2020_5/2020/08/24/23-08-41-152_0e8f52e3944cf4dd.webp","https://segmentfault.com/img/bVbK8rO":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn83@2020_4/2020/08/24/23-08-35-793_31b62aedb2eb6fe6.webp","https://segmentfault.com/img/bVbK8rP":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn88@2020_1/2020/08/24/23-08-37-146_33e57f0e6761d6ff.webp","https://segmentfault.com/img/bVbK8rQ":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn15@2020_3/2020/08/24/23-08-35-676_125212a0c80ae003.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"精读《Spring 概念》","link":"https://segmentfault.com/a/1190000023734444","description":"<p><a href=\"https://spring.io/\" rel=\"nofollow noreferrer\">spring</a> 是 Java 非常重要的框架，且蕴含了一系列设计模式，非常值得研究，本期就通过 <a href=\"https://www.cnblogs.com/wmyskxz/p/8820371.html\" rel=\"nofollow noreferrer\">Spring学习</a> 这篇文章了解一下 spring。</p>\n<h2>spring 为何长寿</h2>\n<p>spring 作为一个后端框架，拥有 17 年历史，这在前端看来是不可思议的。前端几乎没有一个框架可以流行超过 5 年，就最近来看，react、angular、vue 三大框架可能会活的久一点，他们都是前端相对成熟阶段的产物，我们或多或少可以看出一些设计模式。然而这些前端框架与 spring 比起来还是差距很大，我们来看看 spring 到底强大在哪。</p>\n<h3>设计模式</h3>\n<p>设计模式是一种思想，不依附于任何编程语言与开发框架。比如你学会了工厂设计模式，可以在后端用，也可以转到前端用，可以在 Go 语言用，也可以在 Typescript 用，可以在 React 框架用，也可以在 Vue 里用，所以设计模式是一种具有迁移能力的知识，学会后可以受益整个职业生涯，而语言、框架则不具备迁移性，前端许多同学都把精力花在学习框架特性上，遇到前端技术迭代时期就尴尬了，这就是为什么大公司面试要问框架原理，就是看看你能否抓住一些不变的东西，所以洋洋洒洒的说上下文相关的细节也不是面试官想要的，真正想听到的是你抽象后对框架原理共性的总结。</p>\n<p>spring 框架就用到了许多设计模式，包括：</p>\n<p>工厂模式：用工厂生产对象实例来代替原始的 new。所谓工厂就是屏蔽实例话的细节，调用处无需关心实例化对象需要的环境参数，提升可维护性。spring 的 BeanFactory 创建 bean 对象就是工厂模式的体现。 代理模式：允许通过代理对象访问目标对象。Spring 实现 AOP 就是通过动态代理模式。 单例模式：单实例。spring 的 bean 默认都是单例。 包装器模式：将几个不同方法通用部分抽象出来，调用时通过包装器内部引导到不同的实现。比如 spring 连接多种数据库就使用了包装器模式简化。 观察者模式：这个前端同学很熟悉，就是事件机制，spring 中可以通过 ApplicationEvent 实践观察者模式。 适配器模式：通过适配器将接口转换为另一个格式的接口。spring AOP 的增强和通知就使用了适配器模式。 模板方法模式：父类先定义一些函数，这些函数之间存在调用关联，将某些设定为抽象函数等待子类继承时去重写。spring 的 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等数据库操作类使用了模版方法模式。</p>\n<h3>全家桶</h3>\n<p>spring 作为一个全面的 java 框架，提供了系列全家桶满足各种场景需求：spring mvc、spring security、spring data、spring boot、spring cloud。</p>\n<ul>\n <li>spring boot：简化了 spring 应用配置，约定大于配置的思维。</li>\n <li>spring data：是一个数据操作与访问工具集，比如支持 jdbc、redis 等数据源操作。</li>\n <li>spring cloud：是一个微服务解决方案，基于 spring boot，集成了服务发现、配置管理、消息总线、负载均衡、断路器、数据监控等各种服务治理能力。</li>\n <li>spring security：支持一些安全模型比如单点登录、令牌中继、令牌交换等。</li>\n <li>spring mvc：MVC 思想的 web 框架。</li>\n</ul>\n<h2>IOC</h2>\n<p>IOC（Inverse of Control）控制反转。IOC 是 Spring 最核心部分，因为所有对象调用都离不开 IOC 模式。</p>\n<p>假设我们有三个类：Country、Province、City，最大的类别是国家，其次是省、城市，国家类需要调用省类，省类需要调用城市类：</p>\n<pre><code>public&nbsp;class&nbsp;Country&nbsp;{&nbsp;&nbsp;private&nbsp;Province&nbsp;province;&nbsp;&nbsp;public&nbsp;Country(){&nbsp;&nbsp;&nbsp;&nbsp;this.province&nbsp;=&nbsp;new&nbsp;Province()&nbsp;&nbsp;}}public&nbsp;class&nbsp;Province&nbsp;{&nbsp;&nbsp;private&nbsp;City&nbsp;city;&nbsp;&nbsp;public&nbsp;Province(){&nbsp;&nbsp;&nbsp;&nbsp;this.city&nbsp;=&nbsp;new&nbsp;City()&nbsp;&nbsp;}}public&nbsp;class&nbsp;City&nbsp;{&nbsp;&nbsp;public&nbsp;City(){&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...&nbsp;&nbsp;}}</code></pre>\n<p>假设来了一个需求，City 实例化时需增加人口（people）参数，我们就要改动所有类代码：</p>\n<pre><code>public&nbsp;class&nbsp;Country&nbsp;{&nbsp;&nbsp;private&nbsp;Province&nbsp;province;&nbsp;&nbsp;public&nbsp;Country(int&nbsp;people){&nbsp;&nbsp;&nbsp;&nbsp;this.province&nbsp;=&nbsp;new&nbsp;Province(people)&nbsp;&nbsp;}}public&nbsp;class&nbsp;Province&nbsp;{&nbsp;&nbsp;private&nbsp;City&nbsp;city;&nbsp;&nbsp;public&nbsp;Province(int&nbsp;people){&nbsp;&nbsp;&nbsp;&nbsp;this.city&nbsp;=&nbsp;new&nbsp;City(people)&nbsp;&nbsp;}}public&nbsp;class&nbsp;City&nbsp;{&nbsp;&nbsp;public&nbsp;City(int&nbsp;people){&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...&nbsp;&nbsp;}}</code></pre>\n<p>那么在真实业务场景中，一个底层类可能被数以千计的类使用，这么改显然难以维护。IOC 就是为了解决这个问题，它使得我们可以只改动 City 的代码，而不用改动其他类的代码：</p>\n<pre><code>public&nbsp;class&nbsp;Country&nbsp;{&nbsp;&nbsp;private&nbsp;Province&nbsp;province;&nbsp;&nbsp;public&nbsp;Country(Province&nbsp;province){&nbsp;&nbsp;&nbsp;&nbsp;this.province&nbsp;=&nbsp;province&nbsp;&nbsp;}}public&nbsp;class&nbsp;Province&nbsp;{&nbsp;&nbsp;private&nbsp;City&nbsp;city;&nbsp;&nbsp;public&nbsp;Province(City&nbsp;city){&nbsp;&nbsp;&nbsp;&nbsp;this.city&nbsp;=&nbsp;city&nbsp;&nbsp;}}public&nbsp;lass&nbsp;City&nbsp;{&nbsp;&nbsp;public&nbsp;City(int&nbsp;people){&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...&nbsp;&nbsp;}}</code></pre>\n<p>可以看到，增加 <code>people</code> 属性只需要改动 city 类。然而这样做也是有成本的，就是类实例化步骤会稍微繁琐一些：</p>\n<pre><code>City&nbsp;city&nbsp;=&nbsp;new&nbsp;City(1000);Province&nbsp;province&nbsp;=&nbsp;new&nbsp;Province(city);Country&nbsp;country&nbsp;=&nbsp;new&nbsp;Country(province);</code></pre>\n<p>这就是控制反转，由 Country 依赖 Province 变成了类依赖框架（上面的实例化代码）注入。</p>\n<p>然而手动维护这种初始化依赖是繁琐的，spring 提供了 bean 容器自动做这件事，我们只需要利用装饰器 Autowired 就可以自动注入依赖：</p>\n<pre><code>@Componentpublic&nbsp;class&nbsp;Country&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Province&nbsp;province;}@Componentpublic&nbsp;class&nbsp;Province&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;City&nbsp;city;}@Componentpublic&nbsp;class&nbsp;City&nbsp;{&nbsp;&nbsp;}</code></pre>\n<p>实际上这种自动分析并实例化的手段，不仅比手写方便，还能解决循环依赖的问题。在实际场景中，两个类相互调用是很常见的，假设现在有 A、B 类相互依赖：</p>\n<pre><code>@Componentpublic&nbsp;class&nbsp;A&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;B&nbsp;b;}@Componentpublic&nbsp;class&nbsp;B&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;A&nbsp;a;}</code></pre>\n<p>那么假设我们想获取 A 实例，会经历这样一个过程：</p>\n<pre><code>获取 A 实例 -&gt; 实例化不完整 A -&gt; 检测到注入 B -&gt; 实例化不完整 B -&gt; 检测到注入 A -&gt; 注入不完整 A -&gt; 得到完整 B -&gt; 得到完整 A -&gt; 返回 A 实例</code></pre>\n<p>其实 spring 仅支持单例模式下非构造器的循环依赖，这是因为其内部有一套机制，让 bean 在初始化阶段先提前持有对方引用地址，这样就可以同时实例化两个对象了。</p>\n<p>除了方便之外，IOC 配合 spring 容器概念还可以使获取实例时不用关心一个类实例化需要哪些参数，只需要直接申明获取即可，这样在类的数量特别多，尤其是大量代码不是你写的情况下，不需要阅读类源码也可以轻松获取实例，实在是大大提升了可维护性。</p>\n<p>说到这就提到了 Bean 容器，在 spring 概念中，Bean 容器是对 class 的加强，如果说 Class 定义了类的基本含义，那 Bean 就是对类进行使用拓展，告诉我们应该如何实例化与使用这个类。</p>\n<p>举个例子，比如利用注解描述的这段 Bean 类：</p>\n<pre><code>@Configurationpublic&nbsp;class&nbsp;CityConfig&nbsp;{&nbsp;&nbsp;@Scope(\"prototype\")&nbsp;&nbsp;@Lazy&nbsp;&nbsp;@Bean(initMethod&nbsp;=&nbsp;\"init\",&nbsp;destroyMethod&nbsp;=&nbsp;\"destroy\")&nbsp;&nbsp;public&nbsp;City&nbsp;city()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;City()&nbsp;&nbsp;}}</code></pre>\n<p>可以看到，额外描述了是否延迟加载，是否单例，初始化与析构函数分别是什么等等。</p>\n<p>下面给出一个从 Bean 获取实例的例子，采用比较古老的 xml 配置方式：</p>\n<pre><code>public&nbsp;interface&nbsp;City&nbsp;{&nbsp;&nbsp;Int&nbsp;getPeople();}</code></pre>\n<pre><code>public&nbsp;class&nbsp;CityImpl&nbsp;implements&nbsp;City&nbsp;{&nbsp;&nbsp;public&nbsp;Int&nbsp;getPeople()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1000;&nbsp;&nbsp;}}</code></pre>\n<p>接下来用 xml 描述这个 bean：</p>\n<pre><code>&lt;?xml&nbsp;version=\"1.0\"&nbsp;encoding=\"UTF-8\"&nbsp;?&gt;&lt;beans&nbsp;xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&nbsp;&nbsp;xmlns=\"http://www.springframework.org/schema/beans\"&nbsp;&nbsp;xsi:schemaLocation=\"http://www.springframework.org/schema/beans&nbsp;http://www.springframework.org/schema/beans/spring-beans.xsd\"&nbsp;default-autowire=\"byName\"&gt;&nbsp;&nbsp;&lt;bean&nbsp;id=\"city\"&nbsp;class=\"xxx.CityImpl\"/&gt;&lt;/beans&gt;</code></pre>\n<p><code>bean</code> 支持的属性还有很多，由于本文并不做入门教学，就不一一列举了，总之 <code>id</code> 是一个可选的唯一标志，接下来我们可以通过 <code>id</code> 访问到 city 的实例。</p>\n<pre><code>public&nbsp;class&nbsp;App&nbsp;{&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;ApplicationContext&nbsp;context&nbsp;=&nbsp;new&nbsp;ClassPathXmlApplicationContext(\"classpath:application.xml\");&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;从&nbsp;context&nbsp;中读取&nbsp;Bean，而不&nbsp;new&nbsp;City()&nbsp;&nbsp;&nbsp;&nbsp;City&nbsp;city&nbsp;=&nbsp;context.getBean(City.class);&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(city.getPeople());&nbsp;&nbsp;}}</code></pre>\n<p>可以看到，程序任何地方使用 city 实例，只需要调用 <code>getBean</code> 函数，就像一个工厂把实例化过程给承包了，我们不需要关心 City 构造函数要传递什么参数，不需要关心它依赖哪些其他的类，只要这一句话就可以拿到实例，是不是在维护项目时省心了很多。</p>\n<h2>AOP</h2>\n<p>AOP（Aspect Oriented Program）面向切面编程。</p>\n<p>AOP 是为了解决主要业务逻辑与次要业务逻辑之间耦合问题的。主要业务逻辑比如登陆、数据获取、查询等，次要业务逻辑比如性能监控、异常处理等等，次要业务逻辑往往有：不重要、和业务关联度低、贯穿多处业务逻辑的特性，如果没有好的设计模式，只能在业务代码里将主要逻辑与次要逻辑混合起来，但 AOP 可以做到主要、次要业务逻辑隔离。</p>\n<p>使用 AOP 就是在定义在哪些地方（类、方法）切入，在什么地方切入（方法前、后、前后）以及做什么。</p>\n<p>比如说，我们想在某个方法前后分别执行两个函数计算执行时间，下面是主要业务逻辑：</p>\n<pre><code>@Component(\"work\")public&nbsp;class&nbsp;Work&nbsp;{&nbsp;&nbsp;public&nbsp;void&nbsp;do()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"执行业务逻辑\");&nbsp;&nbsp;}}</code></pre>\n<p>再定义切面方法：</p>\n<pre><code>@Component@Aspectclass&nbsp;Broker&nbsp;{&nbsp;&nbsp;@Before(\"execution(*&nbsp;xxx.Work.do())\")&nbsp;&nbsp;public&nbsp;void&nbsp;before(){&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;记录开始时间&nbsp;&nbsp;}&nbsp;&nbsp;@After(\"execution(*&nbsp;xxx.Work.do())\")&nbsp;&nbsp;public&nbsp;void&nbsp;after(){&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;计算时间&nbsp;&nbsp;}}</code></pre>\n<p>再通过 xml 定义扫描下这两个 Bean，就可以在运行 <code>work.do()</code> 之前执行 <code>before()</code>，之后执行 <code>after()</code>。</p>\n<p>还可以完全覆盖原函数，利用 <code>joinPoint.proceed()</code> 可以执行原函数：</p>\n<pre><code>@Component@Aspectclass&nbsp;Broker&nbsp;{&nbsp;&nbsp;@Around(\"execution(*&nbsp;xxx.Work.do())\")&nbsp;&nbsp;public&nbsp;void&nbsp;around(ProceedingJoinPoint&nbsp;joinPoint)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;记录开始时间&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;joinPoint.proceed();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Throwable&nbsp;throwable)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throwable.printStackTrace();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;计算时间&nbsp;&nbsp;}}</code></pre>\n<p>关于表达式 <code>\"execution(* xxx.Work.do())\"</code> 是用正则的方式匹配，<code>*</code> 表示任意返回类型的方法，后面就不用解释了。</p>\n<p>可以看到，我们可以在不修改原方法的基础上，在其执行前后增加自定义业务逻辑，或者监控其报错，非常适合做次要业务逻辑，且由于不与主要业务逻辑代码耦合，保证了代码的简洁，且次要业务逻辑不容易遗漏。</p>\n<h2>总结</h2>\n<p>IOC 特别适合描述业务模型，后端天然需要这一套，然而随着前端越做越重，如果某个业务场景下需要将部分业务逻辑放到前端，也是非常推荐使用 IOC 设计模式来做，这是后端沉淀了近 20 年的经验，没有必要再另辟蹊径。</p>\n<p>AOP 对前端有帮助但没有那么大，因为前端业务逻辑较为分散，如果要进行切面编程，往往用 <code>window</code> 事件监听来做会更彻底，可能这都是前端没有流行 AOP 的原因。当然前端约定大于配置的趋势下，比如打点或监控都集成到框架内部，往往也做到了业务代码无感，剩下的业务代码也就没有 AOP 的需求。</p>\n<p>最后，spring 的低侵入式设计，使得业务代码不用关心框架，让业务代码能够快速在不同框架间切换，这不仅方便了业务开发者，更使得 spring 走向成功，这是前端还需要追赶的。</p>\n<blockquote>\n 讨论地址是：\n <a href=\"https://github.com/dt-fe/weekly/issues/265\" rel=\"nofollow noreferrer\">精读《Spring 概念》· Issue #265 · dt-fe/weekly</a>\n</blockquote>\n<p><strong>如果你想参与讨论，请 <a href=\"https://github.com/dt-fe/weekly\" rel=\"nofollow noreferrer\">点击这里</a>，每周都有新的主题，周末或周一发布。前端精读 - 帮你筛选靠谱的内容。</strong></p>\n<blockquote>\n 关注 \n <strong>前端精读微信公众号</strong>\n</blockquote>\n<p><img src=\"https://segmentfault.com/img/remote/1460000018549678\" alt=\"\" title=\"\" /></p>\n<blockquote>\n 版权声明：自由转载-非商用-非衍生-保持署名（\n <a href=\"https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh\" rel=\"nofollow noreferrer\">创意共享 3.0 许可证</a>）\n</blockquote>","descriptionType":"html","publishedDate":"Mon, 24 Aug 2020 01:42:11 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000018549678","linkMd5":"b7dfe327eb9a61822da340b39059d2f1","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn62@2020_2/2020/08/24/23-08-22-916_a02e97e5e2b41934.webp","destWidth":258,"destHeight":258,"sourceBytes":20858,"destBytes":6490,"author":"黄子毅","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000018549678":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn62@2020_2/2020/08/24/23-08-22-916_a02e97e5e2b41934.webp"},"publishedOrCreatedDate":1598310388558},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"前端音视频的那些名词","link":"https://segmentfault.com/a/1190000023663493","description":"<p><img src=\"https://segmentfault.com/img/bVbLr7m\" alt=\"image\" title=\"image\" /></p>\n<p><strong>观感度：🌟🌟🌟🌟🌟</strong></p>\n<p><strong>口味：椒盐小酥肉</strong></p>\n<p><strong>烹饪时间：10min</strong></p>\n<blockquote>\n 本文已收录在前端食堂同名仓库\n <code>Github</code> \n <a href=\"https://github.com/Geekhyt/front-end-canteen\" rel=\"nofollow noreferrer\">github.com/Geekhyt</a>，欢迎光临食堂，如果觉得酒菜还算可口，赏个 Star 对食堂老板来说是莫大的鼓励。\n</blockquote>\n<h2>比特率 Bit rate （码率、码流）</h2>\n<p><code>代表每秒传送的比特数。</code></p>\n<p>比特率又称为“二进制位速率”，俗称“码率”，“码流”，又称为数据信号速率。这大兄弟别名好多。。</p>\n<p>从传输速度的发展看来，摩尔定律不仅应用在晶体管的密度，同样可以用在传输速度：比特率大概每18个月提高一倍。</p>\n<h3>单位</h3>\n<p>比特/秒(bit/s 或 bps)、千比特/秒(kbit/s 或 kbps)、兆比特/秒 (Mbit/s 或 Mbps)</p>\n<p>(1Mbps = 1000kbit/s)</p>\n<p>比特率越高，代表单位时间传送的数据就越多。</p>\n<h3>公式</h3>\n<p><code>码率(kbps) = 文件大小(KB) * 8 / 时间(s)</code></p>\n<p>举个例子理解：假如视频文件的容量为 2.888G，视频长度100分钟（6000秒），码率约等于 4037kbps (3.446 <em> 1024 </em> 1024 * 8 / 6000 = 4037.717)。</p>\n<h2>帧率 Frame rate</h2>\n<p>图形处理器每秒能够刷新几次，也就是每秒能够播放多少帧。</p>\n<p>人类眼睛的特殊生理结构，如果画面的帧率高于每秒约10-12帧时，都会认为是连贯的，也就是所谓的视觉暂留。</p>\n<p><code>低帧率会造成视觉卡顿，帧率越高，流畅度越高。</code></p>\n<p>如果你玩过LOL，那么游戏帧数保证稳定在60帧左右或以上，你的游戏画面就是流畅的。</p>\n<h3>单位</h3>\n<p>每秒显示的帧数(Frames per Second，FPS）或赫兹（Hz）。</p>\n<h2>压缩率 Compression rate</h2>\n<p><code>经过压缩后文件的大小 / 原始文件的大小 * 100% = 压缩率</code></p>\n<p>压缩率一般是越小越好，但是压得越小，解压时间越长。</p>\n<h2>分辨率 Image resolution</h2>\n<p>通常表示称PPI，用于度量图像内数据量多少的一个参数。</p>\n<p>像素密度越高，说明像素越密集，5PPI表示每英寸有5个像素，500PPI表示每英寸有500个像素。</p>\n<p>PPI的数值高，图片和视频的清晰度就更高。</p>\n<h3>公式</h3>\n<p><code>分辨率 = 单位长度内的像素数量 / 单位长度</code></p>\n<h3>单位</h3>\n<p>DPI（点每英寸）、LPI（线每英寸）、PPI（像素每英寸）和 PPD（PPPixels Per Degree 角分辨率，像素每度）。</p>\n<p><code>是PPD 不是 PDD。</code></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023663498\" alt=\"\" title=\"\" /></p>\n<h2>容器格式</h2>\n<h3>MP4</h3>\n<p>由国际标准化组织（ISO）和国际电工委员会（IEC）下属的”动态图像专家组“（Moving Picture Experts Group，即MPEG）制定。</p>\n<p>MP4 十分开放，几乎可以用来描述所有的媒体结构。支持流媒体，被广泛用于 H.264/H.265 视频和 ACC 音频，是高清视频的扛把子。</p>\n<h3>AVI</h3>\n<p>AVI（Audio Video Interleaved），是微软用于对抗苹果 QuickTime 的产物。它可以跨多个平台使用，不过体积过于庞大，压缩标准也不统一。</p>\n<h3>FLV</h3>\n<p>FLV（Flash Video）是目前最流行的流媒体格式，其文件体积小、封装播放简单，非常适合在网络场景下应用。各大视频网站大多都会使用 FLV 格式。</p>\n<h3>TS,M3U8</h3>\n<p>HLS 由 TS 和 M3U8 两部分组成：</p>\n<ul>\n <li>.m3u8 文件：以 UTF-8 编码的 m3u 文件。</li>\n <li>.ts 视频文件：一个 m3u8 文件对应着若干个 ts文件。</li>\n</ul>\n<p>m3u8 只存放了一些 ts 文件的配置信息和相关路径，而 ts 文件存放了视频的数据。当视频播放时，video 标签会解析 m3u8 并找到对应的<br>ts 文件进行播放。</br></p>\n<p>不过 HLS 的延时相对较高，延时包含了 TCP 握手、m3u8 文件下载与解析、ts 文件下载与解析等多个步骤。虽然可以缩短列表的长度和限制单个 ts 文件的大小来降低延迟，但是会造成请求次数增加，服务器压力增大。</p>\n<p>苹果官方推荐的 ts 时长是 10s，大概会有 30s 的延迟。</p>\n<h3>WebM</h3>\n<p>WebM 由 Google 提出，是一种专为 Web 设计的开放，免版税的媒体文件格式。WebM 文件包含使用 VP8 或 VP9 视频编解码器压缩的视频流和使用 Vorbis 或 Opus 音频编解码器压缩的音频流。</p>\n<h3>OGV</h3>\n<p>OGV 是 HTML5 中的一个名为 Ogg Theora 的视频格式，起源于 OGG 容器格式(由 Xiph.Org 开源)，它不受软件专利的限制。</p>\n<h3>MOV</h3>\n<p>MOV 是 QuickTime 中常见的影片格式，拥有着出色的兼容能力，兼容 Macintosh 和 Windows。</p>\n<h2>编码格式</h2>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023663497\" alt=\"\" title=\"\" /></p>\n<h3>H.264 (AVC)</h3>\n<p>H.264 是由国际电信联盟和国际标准化组织/国际电工委员会运动图像专家组联合开发的视频压缩技术或编解码器(如 MPEG-4 Part 10，高级视频编码或 AVC)。它是在 MPEG-4 技术的基础之上建立起来的。广泛应用于网络流媒体数据、网络软件、高清晰度电视、卫星等。</p>\n<h3>H.265(HEVC)</h3>\n<p>用来替代 H.264/AVC 编码标准。相同视频文件使用 H.265 编码方式编码后的文件体积大约是 MPEG-4 编码后文件的 1/3。</p>\n<ul>\n <li>支持 4k 及更高的分辨率，用户体验好</li>\n <li>高压缩能为用户提供更多内容、降低费用、提升下载速度</li>\n <li>浏览器支持较差，业界解决方案：libe265.js, FFMpeg + WebAssembly</li>\n</ul>\n<h3>VP9</h3>\n<p>VP9 是 Google 为了替换 VP8 并与 H.265/HEVC 竞争所开发的免费、开源的影像编码格式。超过20亿个端点支持VP9解码，包括Chrome，Opera，Edge，Firefox和Android设备以及数百万台智能电视。</p>\n<p>VP10 视频编码的技术被收录在开放媒体联盟所领导的 AV1 编码中，因此 Google 表示不会在内部部署或正式发布 VP10。</p>\n<h3>AV1</h3>\n<p>AV1（Alliance for Open Media Video 1）是由 <a href=\"https://aomedia.org/about/\" rel=\"nofollow noreferrer\">AOM（Alliance for Open Media，开放媒体联盟）</a>制定的一个开源、免版权费的视频编码格式，专门为通过网络进行流传输而设计。IETF 也将这项工作标准化为互联网视频编解码器(NetVC)。</p>\n<p>AV1 的目标是解决 H.265 昂贵的专利费用和复杂的专利授权问题并成为新一代领先的免版权费的编码标准。它是 Google 制定的 VP9 标准的继任者，也是 H.265 强有力的竞争者。</p>\n<ul>\n <li>YouTube 已开始尝试在部分影片使用AV1视频格式。</li>\n <li>2020年2月5日，Netflix开始在Android设备上有限度使用AV1视频格式播放影片，其压缩效率较原本的VP9提升20%</li>\n <li>2020年4月30日，爱奇艺宣布在个人电脑网页浏览器和Android设备上支持AV1视频格式。</li>\n</ul>\n<h2>参考</h2>\n<ul>\n <li><a href=\"https://zh.wikipedia.org/wiki/WebM\" rel=\"nofollow noreferrer\">WebM</a></li>\n <li><a href=\"https://zh.wikipedia.org/wiki/VP9\" rel=\"nofollow noreferrer\">VP9</a></li>\n <li><a href=\"https://zh.wikipedia.org/wiki/AOMedia_Video_1\" rel=\"nofollow noreferrer\">AOMedia Video 1</a></li>\n <li><a href=\"https://zh.wikipedia.org/wiki/H.264/MPEG-4_AVC\" rel=\"nofollow noreferrer\">H.264/MPEG-4 AVC</a></li>\n <li><a href=\"https://www.yuque.com/webmedia/handbook/knowledge-map\" rel=\"nofollow noreferrer\">淘系技术多媒体前端手册</a></li>\n</ul>\n<h2>❤️爱心三连击</h2>\n<p>1.看到这里了就点个赞支持下吧，你的<strong>赞</strong>是我创作的动力。</p>\n<p>2.关注公众号前端食堂，<strong>你的前端食堂，记得按时吃饭</strong>！</p>\n<p>3.本文已收录在前端食堂<code>Github</code> <a href=\"https://github.com/Geekhyt/front-end-canteen\" rel=\"nofollow noreferrer\">github.com/Geekhyt</a>，求个小星星，感谢Star。</p>","descriptionType":"html","publishedDate":"Mon, 17 Aug 2020 13:40:23 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLr7m","linkMd5":"b02edc6d556383db4bdfaad310312379","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn74@2020_1/2020/08/24/23-08-22-400_863f702969491e2a.webp","destWidth":800,"destHeight":340,"sourceBytes":81708,"destBytes":24254,"author":"童欧巴","articleImgCdnMap":{"https://segmentfault.com/img/bVbLr7m":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn74@2020_1/2020/08/24/23-08-22-400_863f702969491e2a.webp","https://segmentfault.com/img/remote/1460000023663498":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn92@2020_4/2020/08/24/23-08-44-175_2d68dd852b72db7e.webp","https://segmentfault.com/img/remote/1460000023663497":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn95@2020_5/2020/08/24/23-08-44-284_d3fa1282d5721ffb.webp"},"publishedOrCreatedDate":1598310388563},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"Swift枚举关联值的内存探究","link":"https://segmentfault.com/a/1190000023669152","description":"<pre><code class=\"swift\">enum Season {\n   case Spring, Summer, Autumn, Winter\n}\nlet s = Season.Spring</code></pre> \n<p>这是枚举最基础的用法，但是在swift中，对枚举的功能进行了加强，也就是关联值。</p> \n<p>关联值可以将额外信息附加到 enum case中，像下面这样子。</p> \n<pre><code class=\"swift\">\nenum Test {\n    case test1(v1: Int, v2: Int, v3: Int)\n    case test2(v1: Int, v2: Int)\n    case test3(v1: Int)\n    case test4\n}\nlet t = Test.test1(v1: 1, v2: 2, v3: 3)\n    \nswitch t {\ncase .test1(let v1, let v2, let v3):\n    print(v1, v2, v3)\ndefault:\n    break\n}\n// 输出： 1 2 3</code></pre> \n<p>我们可以看到，在我们创建一个枚举值t的时候，设置他的选项为test1，同时可以关联3个Int类型的值，然后在switch中，我们还可以把这3个Int值取出来进行使用。</p> \n<p>我们今天的主要任务就是探索一下有关联值的枚举类型，再底层的内存布局是什么样子的，这些值都是怎么储存的。</p> \n<p>在OC中我们使用sizeOf此类方法，可以输出一个变量占用内存的大小，在swift中也有此类的工作类，那就是MemoryLayout。</p> \n<pre><code class=\"swift\">print(MemoryLayout&lt;Int&gt;.size)// 实际使用内存大小\nprint(MemoryLayout&lt;Int&gt;.stride)//分配内存大小\nprint(MemoryLayout&lt;Int&gt;.alignment)//内存对齐参数\n\n// 输出 8 8 8 </code></pre> \n<p>上面的例子是只是简单的实例MemoryLayout的用法，这个我们知道，在64位的系统中Int类型确实是占用8个字节（64位）。接下来我们就看一下枚举的内存占用情况。</p> \n<p>点击Xcode菜单栏中的Debug -&gt; Debug Workflow -&gt; View Memory，然后在下面红色框中输入变量的内存地址，就可以看到变量的内存使用情况。</p> \n<p>使用swift后，从xcode没法直接打印变量的内存地址，这里我们使用了github上的一个工具类(<a href=\"https://segmentfault.com/a/1190000023669152#\">github链接</a>)来帮助我们输出变量的内存地址。</p> \n<p><img src=\"https://segmentfault.com/img/bVbLty0\" alt=\"1.png\" title=\"1.png\" /></p> \n<p>准备工作完成后，我们先从最基础的枚举开始。</p> \n<pre><code class=\"swift\">\nenum Season {\n    case Spring, Summer, Autumn, Winter\n}\nprint(\"实际占用:\",MemoryLayout&lt;Season&gt;.size)\nprint(\"分配:\",MemoryLayout&lt;Season&gt;.stride)\nprint(\"对齐参数:\", MemoryLayout&lt;Season&gt;.alignment)\n    \nvar s = Season.Spring\nprint(\"内存地址\",Mems.ptr(ofVal: &amp;s))\n    \nprint(\"内存数据\",Mems.memStr(ofVal: &amp;s, alignment: .one))\n    \ns = Season.Summer\nprint(\"内存数据\",Mems.memStr(ofVal: &amp;s, alignment: .one))\n    \ns = Season.Autumn\nprint(\"内存数据\",Mems.memStr(ofVal: &amp;s, alignment: .one))\n    \ns = Season.Winter\nprint(\"内存数据\",Mems.memStr(ofVal: &amp;s, alignment: .one))\n</code></pre> \n<p>注：Mems.memStr可以直接打印内存数据，这样我们就不用每次拿到地址再去工具中看了</p> \n<pre><code>实际占用: 1\n分配: 1\n对齐参数: 1\n内存地址 0x00007ffee753f0f0\n内存数据 0x00\n内存数据 0x01\n内存数据 0x02\n内存数据 0x03</code></pre> \n<p>我们可以看到这种普通的枚举类型，只占用一个字节。而且通过我们对变量设置不同的枚举值，打印的这一个字节的数据也是不同的，其实也就是使用这一个字节通过设置不同的数值来表示不同的枚举值，这样的话其实可以至少储存0x00-0xFF共256个值。那如果超过256个case呢？其实我觉得没有必要考虑这种情况，枚举本来设计出就是为了区分有限中情况，如果太多，就像200多个，那完全可以使用Int来设置不同的值了，就没必要用枚举了，当然，如果您愿意探究一下的话也是可以的。</p> \n<p>接下来我们使用一个带关联值的枚举来看一下。</p> \n<pre><code class=\"swift\">\nenum Test {\n    case test1(v1: Int, v2: Int, v3: Int)\n    case test2(v1: Int, v2: Int)\n    case test3(v1: Int)\n    case test4\n}\n    \nprint(\"实际占用:\",MemoryLayout&lt;Test&gt;.size)\nprint(\"分配:\",MemoryLayout&lt;Test&gt;.stride)\nprint(\"对齐参数:\", MemoryLayout&lt;Test&gt;.alignment)\n    \nvar t = Test.test1(v1: 1, v2: 2, v3: 3)\nprint(\"内存地址\",Mems.ptr(ofVal: &amp;t))\n    \nprint(\"内存数据\",Mems.memStr(ofVal: &amp;t, alignment: .one))\n    \nt = Test.test2(v1: 4, v2: 5)\nprint(\"内存数据\",Mems.memStr(ofVal: &amp;t, alignment: .one))\n    \nt = Test.test3(v1: 6)\nprint(\"内存数据\",Mems.memStr(ofVal: &amp;t, alignment: .one))\n    \nt = Test.test4\nprint(\"内存数据\",Mems.memStr(ofVal: &amp;t, alignment: .one))\n</code></pre> \n<p>下面是输出, 为了能直观一下，我给插了几个换行</p> \n<pre><code class=\"swift\">实际占用: 25\n分配: 32\n对齐参数: 8\n内存地址 0x00007ffee0afe0d8\n内存数据 \n0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 \n0x02 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n0x03 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n0x00 \n0x00 0x00 0x00 0x00 0x00 0x00 0x00\n内存数据 \n0x04 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n0x05 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n0x01 \n0x00 0x00 0x00 0x00 0x00 0x00 0x00\n内存数据 \n0x06 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 \n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 \n0x02 \n0x00 0x00 0x00 0x00 0x00 0x00 0x00\n内存数据 \n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 \n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 \n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 \n0x03 \n0x00 0x00 0x00 0x00 0x00 0x00 0x00</code></pre> \n<p>实际占用了25个字节，我们至少可以确定，枚举的关联值是存储在枚举值的内存中的。</p> \n<p>但是通过这一个例子其实可能还看不出有什么规律，大家可以多用几个例子来验证，这是我就直接说结论了。</p> \n<p>有关联值得枚举实际占用的内存是<strong>最多关联值占用的内存+1</strong>，在我们这个Test中，test1的关联值是最多的，有3个Int类型的关联值，所以要8*3=24字节来存放关联值，但是还需要一个字节来储存（辨别）是哪一个case。</p> \n<p>带着这个结论我们看一下输出的结果：</p> \n<p>当t=.test1时，前面24个字节分配给3个Int类型关联值，分别存储了1，2，3， 第25个字节是0。</p> \n<p>当t=.test2时，前面24个字节还是留给关联值的，但是test2只有两个关联值，所以使用了前面16个字节分配给他的关联值，此时17到24这8字节就空置，第25个字节是1。</p> \n<p>...</p> \n<p>最后当t = test4 , 没有关联值，所以前面的字节都是0， 只有第25个字节是3</p> \n<p>以此类推...</p> \n<p>第25个字节其实完全可以看成一个辨识位，或者说第25个字节就是枚举的本质，通过不同值来区分不同case，只是因为有了关联值，所以开辟了更多的空间来存储而已。</p> \n<p>后面多余的字节都是为了内存对齐，内存对齐相关的知识大家可以自行上网查阅。</p> \n<p>补充：<br>既然说到了关联值，那就顺便对枚举原始值说两句。具通过你打印带原始值的枚举的内存数据，发现是否带有原始值对枚举的内存占用并无影响，所以原始值应该不是存储在枚举变量的内部的。大家可以自己试验一下</br></p>","descriptionType":"html","publishedDate":"Tue, 18 Aug 2020 03:37:47 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLty0","linkMd5":"c9849a6e55ae7d588b45b8503f19231a","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn82@2020_3/2020/08/24/23-08-23-222_57802582ab559705.webp","destWidth":800,"destHeight":725,"sourceBytes":46146,"destBytes":17710,"author":"Sunxb","articleImgCdnMap":{"https://segmentfault.com/img/bVbLty0":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn82@2020_3/2020/08/24/23-08-23-222_57802582ab559705.webp"},"publishedOrCreatedDate":1598310388563},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"学习Vue3.0,先来了解一下Proxy","link":"https://segmentfault.com/a/1190000023684153","description":"<blockquote>\n 产品经理身旁过，需求变更逃不过。\n <br>测试姐姐眯眼笑，今晚bug必然多。</br>\n</blockquote>\n<p>据悉<code>Vue3.0</code>的正式版将要在本月(8月)发布，从发布到正式投入到正式项目中，还需要一定的过渡期，但我们不能一直等到<code>Vue3</code>正式投入到项目中的时候才去学习，提前学习，让你更快一步掌握<code>Vue3.0</code>,升职加薪迎娶白富美就靠它了。不过在学习<code>Vue3</code>之前，还需要先了解一下<code>Proxy</code>,它是<code>Vue3.0</code>实现数据双向绑定的基础。</p>\n<blockquote>\n 本文是作者关于Vue3.0系列的第一篇文章，后续作者将会每周发布一篇Vue3.0相关，如果喜欢，麻烦给小编一个赞，谢谢\n</blockquote>\n<h3>了解代理模式</h3>\n<h4>一个例子</h4>\n<p>作为一个单身钢铁直男程序员，小王最近逐渐喜欢上了前台小妹，不过呢，他又和前台小妹不熟，所以决定委托与前端小妹比较熟的<code>UI</code>小姐姐帮忙给自己搭桥引线。小王于是请<code>UI</code>小姐姐吃了一顿大餐，然后拿出一封情书委托它转交给前台小妹，情书上写的 <code>我喜欢你，我想和你睡觉</code>，不愧钢铁直男。不过这样写肯定是没戏的，<code>UI</code>小姐姐吃人嘴短，于是帮忙改了情书，改成了<code>我喜欢你，我想和你一起在晨辉的沐浴下起床</code>，然后交给了前台小妹。虽然有没有撮合成功不清楚啊，不过这个故事告诉我们，小王活该单身狗。</p>\n<p>其实上面就是一个比较典型的代理模式的例子，小王想给前台小妹送情书，因为不熟所以委托<code>UI小姐姐</code>，<code>UI</code>小姐姐相当于代理人，代替小王完成了送情书的事情。</p>\n<h4>引申</h4>\n<p>通过上面的例子，我们想想<code>Vue</code>的数据响应原理，比如下面这段代码</p>\n<pre><code class=\"javascript\">\nconst xiaowang = {\n  love: '我喜欢你，我想和你睡觉'\n}\n// 送给小姐姐情书\nfunction sendToMyLove(obj) {\n    console.log(obj.love)\n    return '流氓，滚'\n}\nconsole.log(sendToMyLove(xiaowang))</code></pre>\n<p>如果没有<code>UI</code>小姐姐代替送情书，显示结局是悲惨的，想想<code>Vue2.0</code>的双向绑定，通过<code>Object.defineProperty</code>来监听的属性 <code>get</code>,<code>set</code>方法来实现双向绑定,这个<code>Object.defineProperty</code>就相当于<code>UI</code>小姐姐</p>\n<pre><code class=\"javascript\">const xiaowang = {\n  loveLetter: '我喜欢你，我想和你睡觉'\n}\n// UI小姐姐代理\nObject.defineProperty(xiaowang,'love', {\n  get() {\n    return xiaowang.loveLetter.replace('睡觉','一起在晨辉的沐浴下起床')\n  }\n})\n\n// 送给小姐姐情书\nfunction sendToMyLove(obj) {\n    console.log(obj.love)\n    return '小伙子还挺有诗情画意的么，不过老娘不喜欢，滚'\n}\nconsole.log(sendToMyLove(xiaowang))</code></pre>\n<p>虽然依然是一个悲惨的故事，因为送奔驰的成功率可能会更高一些。但是我们可以看到，通过<code>Object.defineproperty</code>可以对对象的已有属性进行拦截，然后做一些额外的操作。</p>\n<h4>存在的问题</h4>\n<p>在<code>Vue2.0</code>中，数据双向绑定就是通过<code>Object.defineProperty</code>去监听对象的每一个属性，然后在<code>get</code>,<code>set</code>方法中通过发布订阅者模式来实现的数据响应，但是存在一定的缺陷，比如只能监听已存在的属性，对于新增删除属性就无能为力了，同时无法监听数组的变化，所以在<code>Vue3.0</code>中将其换成了功能更强大的<code>Proxy</code>。</p>\n<h3>了解Proxy</h3>\n<blockquote>\n <code>Proxy</code>是\n <code>ES6</code>新推出的一个特性，可以用它去拦截\n <code>js</code>操作的方法，从而对这些方法进行代理操作。\n</blockquote>\n<h4>用Proxy重写上面的例子</h4>\n<p>比如我们可以通过<code>Proxy</code>对上面的送情书情节进行重写:</p>\n<pre><code class=\"javascript\">const xiaowang = {\n  loveLetter: '我喜欢你，我想和你睡觉'\n}\nconst proxy = new Proxy(xiaowang, {\n  get(target,key) {\n    if(key === 'loveLetter') {\n      return target[key].replace('睡觉','一起在晨辉的沐浴下起床')\n    }\n  }\n})\n// 送给小姐姐情书\nfunction sendToMyLove(obj) {\n    console.log(obj.loveLetter)\n    return '小伙子还挺有诗情画意的么，不过老娘不喜欢，滚'\n}\nconsole.log(sendToMyLove(proxy))</code></pre>\n<h4>再看这样一个场景</h4>\n<p>请分别使用<code>Object.defineProperty</code>和<code>Proxy</code>完善下面的代码逻辑.</p>\n<pre><code class=\"javascript\">function observe(obj, callback) {}\n\nconst obj = observe(\n  {\n    name: '子君',\n    sex: '男'\n  },\n  (key, value) =&gt; {\n    console.log(`属性[${key}]的值被修改为[${value}]`)\n  }\n)\n\n// 这段代码执行后，输出 属性[name]的值被修改为[妹纸]\nobj.name = '妹纸'\n\n// 这段代码执行后，输出 属性[sex]的值被修改为[女]\nobj.sex = '女'</code></pre>\n<p>看了上面的代码，希望大家可以先自行实现以下，下面我们分别用<code>Object.defineProperty</code>和<code>Proxy</code>去实现上面的逻辑.</p>\n<ol>\n <li>使用<code>Object.defineProperty</code></li>\n</ol>\n<pre><code class=\"javascript\">/**\n * 请实现这个函数，使下面的代码逻辑正常运行\n * @param {*} obj 对象\n * @param {*} callback 回调函数\n */\nfunction observe(obj, callback) {\n  const newObj = {}\n  Object.keys(obj).forEach(key =&gt; {\n    Object.defineProperty(newObj, key, {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return obj[key]\n      },\n      // 当属性的值被修改时，会调用set，这时候就可以在set里面调用回调函数\n      set(newVal) {\n        obj[key] = newVal\n        callback(key, newVal)\n      }\n    })\n  })\n  return newObj\n}\n\nconst obj = observe(\n  {\n    name: '子君',\n    sex: '男'\n  },\n  (key, value) =&gt; {\n    console.log(`属性[${key}]的值被修改为[${value}]`)\n  }\n)\n\n// 这段代码执行后，输出 属性[name]的值被修改为[妹纸]\nobj.name = '妹纸'\n\n// 这段代码执行后，输出 属性[sex]的值被修改为[女]\nobj.name = '女'\n</code></pre>\n<ol>\n <li>使用<code>Proxy</code></li>\n</ol>\n<pre><code class=\"javascript\">function observe(obj, callback) {\n  return new Proxy(obj, {\n    get(target, key) {\n      return target[key]\n    },\n    set(target, key, value) {\n      target[key] = value\n      callback(key, value)\n    }\n  })\n}\n\nconst obj = observe(\n  {\n    name: '子君',\n    sex: '男'\n  },\n  (key, value) =&gt; {\n    console.log(`属性[${key}]的值被修改为[${value}]`)\n  }\n)\n\n// 这段代码执行后，输出 属性[name]的值被修改为[妹纸]\nobj.name = '妹纸'\n\n// 这段代码执行后，输出 属性[sex]的值被修改为[女]\nobj.name = '女'\n</code></pre>\n<p>通过上面两种不同实现方式，我们可以大概的了解到<code>Object.defineProperty</code>和<code>Proxy</code>的用法，但是当给对象添加新的属性的时候，区别就出来了，比如</p>\n<pre><code class=\"javascript\">// 添加公众号字段\nobj.gzh = '前端有的玩'</code></pre>\n<p>使用<code>Object.defineProperty</code>无法监听到新增属性，但是使用<code>Proxy</code>是可以监听到的。对比上面两段代码可以发现有以下几点不同</p>\n<ul>\n <li><code>Object.defineProperty</code>监听的是对象的每一个属性，而<code>Proxy</code>监听的是对象自身</li>\n <li>使用<code>Object.defineProperty</code>需要遍历对象的每一个属性，对于性能会有一定的影响</li>\n <li><code>Proxy</code>对新增的属性也能监听到，但<code>Object.defineProperty</code>无法监听到。</li>\n</ul>\n<h3>初识<code>Proxy</code></h3>\n<h4>概念与语法</h4>\n<p>在<code>MDN</code>中，关于<code>Proxy</code>是这样介绍的: <code>Proxy</code> 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。什么意思呢？<code>Proxy</code>就像一个拦截器一样，它可以在读取对象的属性，修改对象的属性，获取对象属性列表，通过<code>for in</code>循环等等操作的时候，去拦截对象上面的默认行为，然后自己去自定义这些行为，比如上面例子中的<code>set</code>,我们通过拦截默认的<code>set</code>,然后在自定义的<code>set</code>里面添加了回调函数的调用</p>\n<p><code>Proxy</code>的语法格式如下</p>\n<pre><code class=\"javascript\">/**\n* target: 要兼容的对象，可以是一个对象，数组,函数等等\n* handler: 是一个对象，里面包含了可以监听这个对象的行为函数，比如上面例子里面的`get`与`set`\n* 同时会返回一个新的对象proxy, 为了能够触发handler里面的函数，必须要使用返回值去进行其他操作，比如修改值\n*/\nconst proxy = new Proxy(target, handler)</code></pre>\n<p>在上面的例子里面，我们已经使用到了<code>handler</code>里面提供的<code>get</code>与<code>set</code>方法了，接下来我们一一看一下<code>handler</code>里面的方法。</p>\n<h4>handler 里面的方法列表</h4>\n<p><code>handler</code>里面的方法可以有以下这十三个，每一个都对应的一种或多种针对<code>proxy</code>代理对象的操作行为</p>\n<ol>\n <li><code>handler.get</code><p>当通过<code>proxy</code>去读取对象里面的属性的时候，会进入到<code>get</code>钩子函数里面</p></li>\n <li><code>handler.set</code><p>当通过<code>proxy</code>去为对象设置修改属性的时候，会进入到<code>set</code>钩子函数里面</p></li>\n <li><p><code>handler.has</code></p><p>当使用<code>in</code>判断属性是否在<code>proxy</code>代理对象里面时，会触发<code>has</code>，比如</p><pre><code class=\"javascript\">const obj = {\n  name: '子君'\n}\nconsole.log('name' in obj)</code></pre></li>\n <li><code>handler.deleteProperty</code><p>当使用<code>delete</code>去删除对象里面的属性的时候，会进入deleteProperty`钩子函数</p></li>\n <li><code>handler.apply</code><p>当<code>proxy</code>监听的是一个函数的时候，当调用这个函数时，会进入<code>apply</code>钩子函数</p></li>\n <li><code>handle.ownKeys</code><p>当通过<code>Object.getOwnPropertyNames</code>,<code>Object.getownPropertySymbols</code>,<code>Object.keys</code>,<code>Reflect.ownKeys</code>去获取对象的信息的时候，就会进入<code>ownKeys</code>这个钩子函数</p></li>\n <li><code>handler.construct</code><p>当使用<code>new</code>操作符的时候，会进入<code>construct</code>这个钩子函数</p></li>\n <li><code>handler.defineProperty</code><p>当使用<code>Object.defineProperty</code>去修改属性修饰符的时候，会进入这个钩子函数</p></li>\n <li><code>handler.getPrototypeOf</code><p>当读取对象的原型的时候，会进入这个钩子函数</p></li>\n <li><code>handler.setPrototypeOf</code><p>当设置对象的原型的时候，会进入这个钩子函数</p></li>\n <li><code>handler.isExtensible</code><p>当通过<code>Object.isExtensible</code>去判断对象是否可以添加新的属性的时候，进入这个钩子函数</p></li>\n <li><code>handler.preventExtensions</code><p>当通过<code>Object.preventExtensions</code>去设置对象不可以修改新属性时候，进入这个钩子函数</p></li>\n <li><code>handler.getOwnPropertyDescriptor</code><p>在获取代理对象某个属性的属性描述时触发该操作，比如在执行 <code>Object.getOwnPropertyDescriptor(proxy, \"foo\")</code> 时会进入这个钩子函数</p></li>\n</ol>\n<p><code>Proxy</code>提供了十三种拦截对象操作的方法，本文主要挑选其中一部分在<code>Vue3</code>中比较重要的进行说明，其余的建议可以直接阅读<code>MDN</code>关于<code>Proxy</code>的介绍。</p>\n<h3>详细介绍</h3>\n<h4>get</h4>\n<blockquote>\n 当通过\n <code>proxy</code>去读取对象里面的属性的时候，会进入到\n <code>get</code>钩子函数里面\n</blockquote>\n<p>当我们从一个<code>proxy</code>代理上面读取属性的时候，就会触发<code>get</code>钩子函数，<code>get</code>函数的结构如下</p>\n<pre><code class=\"javascript\">/**\n * target: 目标对象，即通过proxy代理的对象\n * key: 要访问的属性名称\n * receiver: receiver相当于是我们要读取的属性的this,一般情况\n *           下他就是proxy对象本身，关于receiver的作用，后文将具体讲解\n */\nhandle.get(target,key, receiver)</code></pre>\n<h5>示例</h5>\n<p>我们在工作中经常会有封装<code>axios</code>的需求，在封装过程中，也需要对请求异常进行封装，比如不同的状态码返回的异常信息是不同的，如下是一部分状态码及其提示信息:</p>\n<pre><code class=\"javascript\">// 状态码提示信息\nconst errorMessage = {\n  400: '错误请求',\n  401: '系统未授权，请重新登录',\n  403: '拒绝访问',\n  404: '请求失败，未找到该资源'\n}\n\n// 使用方式\nconst code = 404\nconst message = errorMessage[code]\nconsole.log(message)</code></pre>\n<p>但这存在一个问题，状态码很多，我们不可能每一个状态码都去枚举出来，所以对于一些异常状态码，我们希望可以进行统一提示，如提示为<code>系统异常，请联系管理员</code>，这时候就可以使用<code>Proxy</code>对错误信息进行代理处理</p>\n<pre><code class=\"javascript\">// 状态码提示信息\nconst errorMessage = {\n  400: '错误请求',\n  401: '系统未授权，请重新登录',\n  403: '拒绝访问',\n  404: '请求失败，未找到该资源'\n}\n\nconst proxy = new Proxy(errorMessage, {\n  get(target,key) {\n    const value = target[key]\n    return value || '系统异常，请联系管理员'\n  }\n})\n\n// 输出 错误请求\nconsole.log(proxy[400])\n// 输出 系统异常，请联系管理员\nconsole.log(proxy[500])</code></pre>\n<h4>set</h4>\n<blockquote>\n 当为对象里面的属性赋值的时候，会触发\n <code>set</code>\n</blockquote>\n<p>当给对象里面的属性赋值的时候，会触发<code>set</code>,<code>set</code>函数的结构如下</p>\n<pre><code class=\"javascript\">/**\n * target: 目标对象，即通过proxy代理的对象\n * key: 要赋值的属性名称\n * value: 目标属性要赋的新值\n * receiver: 与 get的receiver 基本一致\n */\nhandle.set(target,key,value, receiver)</code></pre>\n<h5>示例</h5>\n<p>某系统需要录入一系列数值用于数据统计，但是在录入数值的时候，可能录入的存在一部分异常值，对于这些异常值需要在录入的时候进行处理, 比如大于<code>100</code>的值，转换为<code>100</code>, 小于<code>0</code>的值，转换为<code>0</code>, 这时候就可以使用<code>proxy</code>的<code>set</code>，在赋值的时候，对数据进行处理</p>\n<pre><code class=\"javascript\">const numbers = []\nconst proxy = new Proxy(numbers, {\n  set(target,key,value) {\n    if(value &lt; 0) {\n      value = 0\n    }else if(value &gt; 100) {\n      value = 100\n    }\n    target[key] = value\n    // 对于set 来说，如果操作成功必须返回true, 否则会被视为失败\n    return true\n  }\n})\n\nproxy.push(1)\nproxy.push(101)\nproxy.push(-10)\n// 输出 [1, 100, 0]\nconsole.log(numbers)</code></pre>\n<h5>对比<code>Vue2.0</code></h5>\n<p>在使用<code>Vue2.0</code>的时候，如果给对象添加新属性的时候，往往需要调用<code>$set</code>, 这是因为<code>Object.defineProperty</code>只能监听已存在的属性，而新增的属性无法监听，而通过<code>$set</code>相当于手动给对象新增了属性，然后再触发数据响应。但是对于<code>Vue3.0</code>来说，因为使用了<code>Proxy</code>， 在他的<code>set</code>钩子函数中是可以监听到新增属性的，所以就不再需要使用<code>$set</code></p>\n<pre><code class=\"javascript\">const obj = {\n  name: '子君'\n}\nconst proxy = new Proxy(obj, {\n  set(target,key,value) {\n    if(!target.hasOwnProperty(key)) {\n      console.log(`新增了属性${key},值为${value}`)\n    }\n    target[key] = value\n    return true\n  }\n})\n// 新增 公众号 属性\n// 输出 新增了属性gzh,值为前端有的玩\nproxy.gzh = '前端有的玩'\n</code></pre>\n<h4>has</h4>\n<blockquote>\n 当使用\n <code>in</code>判断属性是否在\n <code>proxy</code>代理对象里面时，会触发\n <code>has</code>\n</blockquote>\n<pre><code class=\"javascript\">/**\n * target: 目标对象，即通过proxy代理的对象\n * key: 要判断的key是否在target中\n */\n handle.has(target,key)</code></pre>\n<h5>示例</h5>\n<p>一般情况下我们在<code>js</code>中声明私有属性的时候，会将属性的名字以<code>_</code>开头，对于这些私有属性，是不需要外部调用，所以如果可以隐藏掉是最好的，这时候就可以通过<code>has</code>在判断某个属性是否在对象时，如果以<code>_</code>开头，则返回<code>false</code></p>\n<pre><code class=\"javascript\">const obj =  {\n  publicMethod() {},\n  _privateMethod(){}\n}\nconst proxy = new Proxy(obj, {\n  has(target, key) {\n    if(key.startsWith('_')) {\n      return false\n    }\n    return Reflect.get(target,key)\n  }\n})\n\n// 输出 false\nconsole.log('_privateMethod' in proxy)\n\n// 输出 true\nconsole.log('publicMethod' in proxy)\n</code></pre>\n<h4>deleteProperty</h4>\n<blockquote>\n 当使用\n <code>delete</code>去删除对象里面的属性的时候，会进入deleteProperty`拦截器\n</blockquote>\n<pre><code class=\"javascript\">/**\n * target: 目标对象，即通过proxy代理的对象\n * key: 要删除的属性\n */\n handle.deleteProperty(target,key)</code></pre>\n<h5>示例</h5>\n<p>现在有一个用户信息的对象，对于某些用户信息，只允许查看，但不能删除或者修改，对此使用<code>Proxy</code>可以对不能删除或者修改的属性进行拦截并抛出异常，如下</p>\n<pre><code class=\"javascript\">const userInfo = {\n  name: '子君',\n  gzh: '前端有的玩',\n  sex: '男',\n  age: 22\n}\n// 只能删除用户名和公众号\nconst readonlyKeys = ['name', 'gzh']\nconst proxy = new Proxy(userInfo, {\n  set(target,key,value) {\n    if(readonlyKeys.includes(key)) {\n      throw new Error(`属性${key}不能被修改`)\n    }\n    target[key] = value\n    return true\n  },\n   deleteProperty(target,key) {\n    if(readonlyKeys.includes(key)) {\n      throw new Error(`属性${key}不能被删除`)\n      return\n    }\n    delete target[key]\n    return true\n  }\n})\n// 报错 \ndelete proxy.name</code></pre>\n<h5>对比<code>Vue2.0</code></h5>\n<p>其实与<code>$set</code>解决的问题类似，<code>Vue2.0</code>是无法监听到属性被删除的，所以提供了<code>$delete</code>用于删除属性，但是对于<code>Proxy</code>，是可以监听删除操作的，所以就不需要再使用<code>$delete</code>了</p>\n<h4>其他操作</h4>\n<p>在上文中，我们提到了<code>Proxy</code>的<code>handler</code>提供了十三个函数，在上面我们列举了最常用的三个，其实每一个的用法都是基本一致的，比如<code>ownKeys</code>，当通过<code>Object.getOwnPropertyNames</code>,<code>Object.getownPropertySymbols</code>,<code>Object.keys</code>,<code>Reflect.ownKeys</code>去获取对象的信息的时候，就会进入<code>ownKeys</code>这个钩子函数，使用这个我们就可以对一些我们不像暴露的属性进行保护，比如一般会约定<code>_</code>开头的为私有属性，所以在使用<code>Object.keys</code>去获取对象的所有<code>key</code>的时候，就可以把所有<code>_</code>开头的属性屏蔽掉。关于剩余的那些属性，建议大家多去看看<code>MDN</code>中的介绍。</p>\n<h3>Reflect</h3>\n<p>在上面，我们获取属性的值或者修改属性的值都是通过直接操作<code>target</code>来实现的，但实际上<code>ES6</code>已经为我们提供了在<code>Proxy</code>内部调用对象的默认行为的<code>API</code>,即<code>Reflect</code>。比如下面的代码</p>\n<pre><code class=\"javascript\">const obj = {}\nconst proxy = new Proxy(obj, {\n  get(target,key,receiver) {\n    return Reflect.get(target,key,receiver)\n  }\n})</code></pre>\n<p>大家可能看到上面的代码与直接使用<code>target[key]</code>的方式没什么区别，但实际上<code>Reflect</code>的出现是为了让<code>Object</code>上面的操作更加规范，比如我们要判断某一个<code>prop</code>是否在一个对象中，通常会使用到<code>in</code>,即</p>\n<pre><code>const obj = {name: '子君'}\nconsole.log('name' in obj)</code></pre>\n<p>但上面的操作是一种命令式的语法，通过<code>Reflect</code>可以将其转变为函数式的语法，显得更加规范</p>\n<pre><code>Reflect.has(obj,'name')</code></pre>\n<p>除了<code>has</code>,<code>get</code>之外，其实<code>Reflect</code>上面总共提供了十三个静态方法，这十三个静态方法与<code>Proxy</code>的<code>handler</code>上面的十三个方法是一一对应的，通过将<code>Proxy</code>与<code>Reflect</code>相结合，就可以对对象上面的默认操作进行拦截处理，当然这也就属于函数元编程的范畴了。</p>\n<h3>总结</h3>\n<p>有的同学可能会有疑惑，我不会<code>Proxy</code>和<code>Reflect</code>就学不了<code>Vue3.0</code>了吗？其实懂不懂这个是不影响学习<code>Vue3.0</code>的，但是如果想深入 去理解<code>Vue3.0</code>，还是很有必要了解这些的。比如经常会有人在使用<code>Vue2</code>的时候问，为什么我数组通过索引修改值之后，界面没有变呢？当你了解到<code>Object.defineProperty</code>的使用方式与限制之后，就会恍然大悟，原来如此。本文之后，小编将为大家带来<code>Vue3.0</code>系列文章，欢迎关注，一起学习。同时本文首发于公众号【前端有的玩】，用玩的姿势学前端，就在【前端有的玩】</p>","descriptionType":"html","publishedDate":"Wed, 19 Aug 2020 05:16:19 +0000","feedId":6615,"bgimg":"","linkMd5":"0a59e65366f289a078cb96f1c4586eab","bgimgJsdelivr":"","metaImg":"","author":"子君","publishedOrCreatedDate":1598310388562},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"美国如果把根域名服务器封了，中国会从网络上消失？","link":"https://segmentfault.com/a/1190000023696737","description":"<p><img src=\"https://segmentfault.com/img/bVbLAIE\" alt=\"美国如果把根域名服务器封了，中国会从网络上消失？\" title=\"美国如果把根域名服务器封了，中国会从网络上消失？\"><br>作者：卫剑钒<br>来源：公众号微月人话</br></br></img></p>\n<hr>\n <p>自从美国宣布“清洁网络”行动后，很多懂点网络的人，第一反应是，美国人会下手根域名服务器吗？</p>\n <p>这种忧虑可不是一年两年了。</p>\n <p>2014年6月24日的《人民日报》上引用专家发言：“目前美国掌握着全球互联网13台域名根服务器中的10台。理论上，只要在根服务器上屏蔽该国家域名，就能让这个国家的国家顶级域名网站在网络上瞬间“消失”。在这个意义上，美国具有全球独一无二的制网权，有能力威慑他国的网络边疆和网络主权。譬如，伊拉克战争期间，在美国政府授意下，伊拉克顶级域名“.iq”的申请和解析工作被终止，所有网址以“.iq”为后缀的网站从互联网蒸发。”_（1）_</p>\n <p>《信息安全与通信保密》杂志2014年第10期的一篇文章写道：“2004年，由于与利比亚在顶级域名管理权问题上发生争执，美国终止了利比亚的顶级域名.LY的解析服务，导致利比亚从网络中消失3天。”_（2）_</p>\n <p>对此，我们需要害怕吗？我们需要什么样的反制措施？ </p>\n <p>不是专家，还真回答不了这个问题。</p>\n <p>因为这需要了解DNS的工作原理，了解根域名的管理机制。</p>\n <p>这里先给出简要回答：不排除这种可能性，但并不是没有办法。</p>\n <p>一句话原因：虽然根不在我们手里，但我们有镜像。</p>\n <h2><strong>DNS傻瓜书</strong></h2>\n <p>先了解点基本概念，懂DNS的可以直接跳过本节。</p>\n <p>1、DNS是什么？</p>\n <p>DNS就是将域名转换为IP的，因为我们人类的记忆力太差，根本记不住IP，而电脑通信又必须用IP，所以人类发明了域名，让我们可以记住baidu.com、taobao.com这种还算能记得住的域名。然后通过DNS，将这些域名转换为电脑需要的IP。</p>\n <p>2、DNS是怎么工作的？</p>\n <p>每个电脑里面都设置了本地DNS服务器（简称LDNS），需要的时候，就向LDNS发出请求，LDNS在网上问权威域名服务器（简称权威DNS），有时候问一家是不够的，要问一大圈下来，最后才能得到答案。</p>\n <p>3、权威DNS是干什么的？</p>\n <p>问我一个域名，我告诉你IP，如果我不知道，我告诉你谁可能知道，你再去问它。</p>\n <p>4、什么是根域名服务器（简称根DNS）？</p>\n <p>当LDNS啥都不知道的时候（也即没有任何缓存），就去问根DNS，根能告诉LDNS下一步该问谁。</p>\n <p>5、全世界有多少根DNS？</p>\n <p>13个，其中10个在美国，英国和瑞典各1个，日本1个。</p>\n <p>6、根DNS的名字和IP都是什么？</p>\n <p>在这个网址：</p>\n <p><a href=\"https://www.internic.net/domain/named.root\" rel=\"nofollow noreferrer\">https://www.internic.net/doma...</a></p>\n <p>打开可以看到，里面有13个根的名字和IP，其名字从A.root-servers.net到M.root-servers.net。</p>\n <p>A开头那个简称A根，是主根，其他12个（B、C、D、E、F、G、H、I、J、K、L、M）是辅根。</p>\n <h2><strong>为什么根DNS只有13台？</strong></h2>\n <p>本节看不懂没关系（一般人都看不懂），你只需要知道，由于历史原因和技术原因，对于IPv4而言，根DNS只能有13个IP。</p>\n <p>正宗答案是：DNS主要使用UDP数据报传送报文，不含前面的各种头部，DNS报文要求被控制在512字节之内（ RFC1035 ），主要考虑是这个大小几乎可以在互联网上畅通无阻，不会因为路径中某个MTU太小（ MTU 通常总会 &gt;= 576，见 RFC791 ）而导致IP分片，从而预防了各种不可预期的后果_（3）_。</p>\n <p>而每一个根DNS在DNS报文中都要占用一定的字节数，比如根的名称、TTL、IP地址等。这样，13个根域名服务器基本上就把空间占差不多了，剩余的字节还要用于包装DNS报头以及其它协议参数，所以根域名服务器不易太多，13个算是比较合适的数目。具体可以看一下“Why 13 DNS root servers?”这篇文章。_（4&nbsp;）_</p>\n <h2>真的只有13台服务器吗？</h2>\n <p>和很多人想象的完全不一样，这13个根域名服务器，并不是只有13台物理的服务器。</p>\n <p>这13个根，只是一个逻辑上的概念，每个根DNS，背后都有多台真正的物理服务器在工作！</p>\n <p>截至2020年8月12日，全球一共有1097个根服务器。每一个根都有若干个镜像，分布在全球不同的地方。</p>\n <p><img src=\"https://segmentfault.com/img/remote/1460000023696740\" alt=\"\" title=\"\" /></p>\n <blockquote>\n  这个数目在不断上涨，去年10月1日新中国成立70周年阅兵的时候，我看了一下，是1015个服务器。\n  <p>这13个根由12个独立的机构管理，比如A根和J根都是由Verisign公司管理，截至2020年8月12日，A根在全球各地有53个站点，J根有185个站点。L根由ICANN管理，全球有167个站点，其中北京2个，上海1个。</p>\n </blockquote>\n <p>在root-servers网站上_（5）_，可以查到所有这些根服务器的分布，从网站展示的根镜像服务器地图上看（2020年8月12日），北京有 5 个根镜像服务器，上海 1 个，杭州 2 个，武汉1个、郑州1个、西宁1个、贵阳1个、广州1个、香港 9 个，台北 6 个。</p>\n <p>包含港澳台部分，我国一共有28个根镜像。</p>\n <p>我国境内发出的对根DNS的请求，其实都由镜像完成了。这一点后面会解释。</p>\n <p>现在，为了增长知识，你该硬着头皮看一些DNS细节了。</p>\n <h2><strong>DNS到底是怎么工作的？</strong></h2>\n <p>对于IT从业者，希望你能理解并牢牢记住本节的内容。</p>\n <p>因为你迟早会遇到有关DNS的困惑。</p>\n <p>先介绍一下域名的级别：</p>\n <p>.代表根域名， .com这种是顶级域名，也叫一级域名，baidu.com这种叫二级域名， www.baidu.com这种叫三级域名，依次类推。</p>\n <p>注：也有其他叫法的，反正你知道这个意思就可以了。</p>\n <p>再介绍一下最常见的两种域名服务器：</p>\n <p>权威DNS：负责对请求作出权威的回答。权威DNS中存储着记录，最常见的3种：A记录（记录某域名和其IP的对应），NS记录（记录某域名和负责解析该域的权威DNS），CNAME记录（负责记录某域名及其别名）。权威能直接回答的，就回A记录；需要其他权威DNS回答的，就回NS记录，然后LDNS再去找其他权威DNS问；如果该记录是别名类型的，就回CNAME，LDNS就会再去解析别名。</p>\n <p>递归DNS：通常就是LDNS，它接受终端的域名查询请求，负责在网上问一圈后，将答案返回终端。</p>\n <p>现在举一个具体的例子：比如终端请求www.baidu.com这个域名的IP。</p>\n <p>在没有缓存时，LDNS会从根DNS问起：</p>\n <p>1、LDNS问根DNS说：“www.baidu.com的IP是多少啊？”。</p>\n <p>2、根DNS说：“我哪有时间管你这么细的问题，你去问com顶级域的DNS吧，我只管到顶级域，喏，这些是com顶级域DNS的名字和IP，你去问它们吧”。（以NS记录回应）</p>\n <p>3、LDNS又忙问com的权威DNS，com权威DNS说：“你问的这是三级域名，我不管这么多，你去问baidu.com的权威DNS吧，它的名字是ns.baidu.com，他的IP是XXX（这里可能给出多个权威DNS）”。</p>\n <p>4、LDNS继续问baidu.com的权威DNS，这次痛快，因为www.baidu.com正是它管的，它可能直接给出A记录，也可能给出CNAME记录，如果是前者，就直接得到IP，如果是后者，就需要对别名再做查询。</p>\n <p>5、最终，LDNS得到www.baidu.com的IP，并将其返回给终端。</p>\n <p><img src=\"https://segmentfault.com/img/bVbLAK3\" alt=\"美国如果把根域名服务器封了，中国会从网络上消失？\" title=\"美国如果把根域名服务器封了，中国会从网络上消失？\" /></p>\n <p>细心的人会问，在第1步中，LDNS问根DNS的时候，他是怎么知道根DNS的IP的？</p>\n <p>这13个IP通常是预先配置在LDNS里面的。在LDNS初始化DNS缓存或者缓存失效的时候，LDNS向自己被预先配置的这些IP中的一个，发起对根的查询（也即询问.的NS记录），获得最新的根DNS的信息_（6）_。</p>\n <blockquote>\n  对于DNS服务器软件而言，这13个IP，配置在根提示文件（root hints file）中，可能是named.cache或root.ca或root.hints等等之类的文件。\n </blockquote>\n <p>上面就是各种教科书中都会讲到的DNS查询过程，但实际上，没有这么麻烦，因为各个层面都是有缓存的。</p>\n <p>实际DNS查询的过程，是这样的：</p>\n <p>举个例子，比如用户在浏览器中输入这个域名：123.abc.qq.com.cn</p>\n <p>1、浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去hosts文件看，也没有，才会去问LDNS。</p>\n <p>2、LDNS会去先看看自己有没有123.abc.qq.com.cn的A记录，要有就直接返回，要没有，就去看有没有abc.qq.com.cn的NS记录，如果有，就去问它要答案，如果没有，就去看有无qq.com.cn的NS的记录，如果有，就去问它，没有就去看有无com.cn的DNS，还没有就去看有无cn的DNS，如果连cn的NS记录都没有，才去问根。</p>\n <p>所以，有了缓存以后，教科书上那种从根问起的情况，实际上很少发生。</p>\n <p>只有在各处都没有缓存的时候，我们才会问根。</p>\n <h2><strong>根镜像起什么作用？</strong></h2>\n <p>根镜像承担起和根一样的功能。</p>\n <p>根DNS中，最重要的文件就是根区文件（Root Zone file）。所有顶级域名记录都存在根区文件中。</p>\n <p>辅根从主根同步数据，根镜像从根同步数据。最终，所有根和镜像都有着同样的根区文件。</p>\n <p>而且最有意思的是，根镜像和根有着同样的IP。</p>\n <p>我们知道，全球有一千多个根镜像，但是大多数人不知道，它们一起共享13个IP！&nbsp; 对的。因为只有13个根。</p>\n <p>这是如何做到的？答案是任播（Anycast，又译泛播）技术。</p>\n <p>不关心技术细节的，请直接看本节的最后一句。</p>\n <p>任播最初由RFC1546提出，主要用在DNS根服务器上。</p>\n <blockquote>\n  任播是指在IP网络上通过一个IP地址标识一组提供特定服务的主机，服务访问方并不关心提供服务具体是哪一台主机提供的，访问该地址的报文可以被IP网络路由到“最近”的一个（最好也只是一个，别送到多个）服务器上。这里“最近”可以是指路由器跳数、服务器负载、服务器吞吐量、客户和服务器之间的往返时间（ RTT，round trip time ）、链路的可用带宽等特征值。\n </blockquote>\n <p>这样，一方面，用户可以就近访问；另一方面，即便部分根出现故障也没事。</p>\n <p>有些同学可能联想到负载均衡，没错，大致上就是这个意思。</p>\n <p>对于中国用户来说，对根的请求，一般不会跑到美国去，而是通过任播技术路由到中国境内的根镜像上。</p>\n <h2>根DNS是怎么管理的？</h2>\n <p>根DNS目前由12家机构管理。A根是主根，由美国公司Verisign管理。</p>\n <p>根DNS中最重要的文件，根区文件，由ICANN管理。</p>\n <p>ICANN（The Internet Corporation for Assigned Names and Numbers，互联网名称与数字地址分配机构）是成立于1998年的一家注册在美国的非营利性组织。</p>\n <p>根DNS管理的历史变迁过程还是比较复杂的。这里简要说一下。</p>\n <p>DNS最初的技术开发者与管理者是美国南加州大学的Jon Postel博士，他掌管互联网初期根DNS的管理和分配。</p>\n <p>1988年，美国政府要求Jon Postel采取更安全和更合理的措施来保证互联网核心资源的分配和管理_（7）_。于是，大名鼎鼎的IANA（The Internet Assigned Numbers Authority，互联网数字分配机构）被组建，并在DARPA和南加州大学信息科学研究所（ISI）的合同下管理。</p>\n <blockquote>\n  IANA负责互联网全局编号和编码的管理与协调，之所以需要这么个机构，是因为互联网协议的值或参数，必须是全球唯一的，否则无法互联互通，比如HTTP协议默认都在80端口等待用户请求，而404编码则一致代表\"未找到页面”。IANA主要职责包括IP地址段的分配、协议代码和编号的分配（如协议号、端口号）、自治系统编号 (ASN) 分配、DNS根区管理（包括通用顶级域名gTLD以及国家和地区顶级域名ccTLD管理）等。_（8）_\n </blockquote>\n <p>1998年ICANN成立之后，美国商务部以合同形式，委托ICANN承担IANA日常运行，IANA从ISI转移到ICANN之下。</p>\n <p>对于顶级域名的管理，ICANN的政策是，每个顶级域名（像com、cn、org这种顶级域名，目前有1000多个）都找一个托管商，该域名的所有事项都由托管商负责。</p>\n <p>.cn域名的托管商是中国互联网络信息中心（CNNIC），它决定.cn域名的各种政策。</p>\n <p>.com、.net 、.name、.gov这四个顶级域名都由Verisign公司托管。</p>\n <p>Verisign和ICANN还是闹过几次不愉快的。_（9）_</p>\n <blockquote>\n  2003年，Verisign 推出了一项新业务 Site Finder，用户访问没有注册过的.com或.net域名，都会被导向 Verisign 的网站。这意味着，它事实上拥有了所有没有注册过的.com和.net域名。几天之内，Verisign 就挤入了全世界的前10大网站。\n  <p>ICANN 要求 Verisign 立刻停止该业务，否则将终止域名托管合同。Verisign 屈服了，停止了这项业务，但是接着就把 ICANN 告上了法庭，要求法庭厘请两者之间的合同，ICANN 到底有没有权力干涉它的业务。</p>\n  <p>2006年底，他们达成了庭外和解。ICANN 同意延长 Verisign 的顶级域名托管合同，并且同意 Verisign 向消费者收取的单个域名注册费的上限，从6美元提高到了7.85美元。这个费用标准，一直沿用到了今天，你去注册一个.com或.net域名，所交的钱有0.18美元是 ICANN 收取的管理费，7.85美元是 Verisign 收取的托管费，其余的钱就是域名零售商的费用。</p>\n </blockquote>\n <p>虽然是ICANN运营着IANA，但毕竟是在美国政府的合同管理之下，全球各国以及民间人士颇有微词，一致认为美国政府应该彻底退出。</p>\n <p>2014年3月14日，美国商务部国家通讯与信息管理局（NTIA）宣布愿意将IANA的管理权完全移交给ICANN，并要求ICANN制定移交计划。NTIA尤其强调，移交计划要强化多利益相关方模式，不能以政府间组织或政府领导的组织取代当前NTIA扮演的角色。</p>\n <p>2016年3月17日，ICANN向NTIA提交了移交计划。2016年6月9日，NTIA公布审核意见，表示ICANN提交的移交计划满足了此前设定的条件。</p>\n <p>2016年8月16日，NTIA宣布不再延期现有合同。</p>\n <p>虽然遇到一些阻挠_（10）_，最终，2016年10月1日，ICANN和美国商务部之间关于IANA职能的合同到期且不再续约，ICANN彻底成为独立的非营利机构。IANA部门的员工和其他的相关资源都被转移到ICANN新设立的附属机构PTI（Public Technical Identifiers，公共技术标识符）中。</p>\n <p>ICANN使用全球多利益相关方治理模型（global multistakeholder governance model）进行管理。PTI董事会共5席，3席由ICANN委派，2席由全球互联网社群代表组成提名委员会产生。2017年2月，ICANN发布PTI董事竞选公告，经半年多轮面试及背景调查，提名委员会于2017年10月26日宣布我国北龙中网的王伟与另一欧洲代表中选。又经一个半月的利益冲突审查，2017年12月13日ICANN董事会正式确认王伟当选。_（11）_</p>\n <h2><strong>我国的根镜像由谁管理？</strong></h2>\n <p>从目前我所找到的资料看，自2003年以来，我国在不断引进根镜像，尤其是去年，根镜像个数增速很快。</p>\n <p>2003年，中国电信引入了国内第一个根镜像节点（F根）。</p>\n <p>2005年，I根服务器运行机构在 CNNIC 设立了中国第二个根镜像（I根）。</p>\n <p>2006年，中国联通(原中国网通)与美国 VeriSign 公司合作， 在国内正式开通J根镜像服务器，同时引入了全球最大的两个顶级域名 “.COM”和“.NET”镜像节点；引进这些镜像的主要目的是提高根域名和顶级域名的解析性能。</p>\n <p>2014年，世纪互联与ICANN合作在中国增设L根域名服务器镜像。</p>\n <p>2019年6月24日，工信部批准CNNIC设立六台域名根镜像服务器（F、I、K、L）。这六台域名根服务器编号为 JX0001F、JX0002F、JX0003I、JX0004K、JX0005L 和 JX0006L_（12）_，并批准互联网域名系统北京市工程研究中心（ZDNS）设立L根镜像服务器JX0007L_（13）_。</p>\n <p>2019年11月6日，工信部批复同意中国信息通信研究院设立L根镜像服务器，编号分别为JX0008L、JX0009L。</p>\n <p>2019年12月5日，工信部批复同意中国信息通信研究院设立域名根服务器（K根镜像服务器），编号为JX0010K。</p>\n <p>2019年12月9日，工信部批复同意CNNIC设立域名根服务器（J、K根镜像服务器），编号分别为JX0011J、JX0012K。</p>\n <p>从工信部的批文中可以了解到，相关单位负责根镜像的运行、维护和管理工作，维护国家利益和用户权益，并接受工信部的管理和监督检查。</p>\n <blockquote>\n  工信部在给CNNIC的批文中写道：“你中心应严格遵守《互联网域名管理办法》《通信网络安全防护管理办法》及相关法律法规、行政规章及行业管理规定，接受我部的管理和监督检查，建立符合我部要求的信息管理系统并与我部指定的管理系统对接，保证域名根服务器安全、可靠运行，为用户提供安全、方便的域名服务，保障服务质量，保护用户个人信息安全，维护国家利益和用户权益。”\n </blockquote>\n <h2><strong>美国能对根DNS做什么手脚？</strong></h2>\n <p>虽然ICANN是一个独立的非营利性机构，但如果美国政府动用强制力量，A根（主根）的内容仍然存在被篡改的可能。</p>\n <p>也就是根区文件可以被篡改。</p>\n <p>会怎么篡改？</p>\n <p>我们先看看根区文件长什么样。</p>\n <p>从ICANN官网上可以下载根区文件：</p>\n <p><a href=\"https://www.iana.org/domains/root/files\" rel=\"nofollow noreferrer\">https://www.iana.org/domains/...</a></p>\n <blockquote>\n  该文件保存所有顶级域名的信息，目前大小为2.2M，2万余行。\n  <p>每当有顶级域名的变动时，该文件就会更新。</p>\n </blockquote>\n <p>我们可以看到，和cn域名解析相关的记录也就那么几十行。</p>\n <p><img src=\"https://segmentfault.com/img/bVbLALn\" alt=\"美国如果把根域名服务器封了，中国会从网络上消失？\" title=\"美国如果把根域名服务器封了，中国会从网络上消失？\" /></p>\n <p>如果删除和cn相关的那些行，很快，就会同步到所有的根中。</p>\n <p>然后，在所有的缓存都过期之后，全球所有人都访问不了.cn后缀的网站。</p>\n <h2><strong>如何应对？</strong></h2>\n <p>因为我们维护着根镜像，所以我们控制着镜像中的内容。</p>\n <p>而中国境内的对根的访问，通过我们的运营商，都会落到对我国根镜像的访问上。</p>\n <p>我们可以不同步关于cn的修改。</p>\n <p>就这么简单。</p>\n <p>可以简单写个程序，每次同步完立刻加上cn记录。</p>\n <p>也可以自己搭个主根，完全不和美国的根同步。（相当于另立中央了）</p>\n <p>当然，世界各地不在我们管理之下的根和根镜像，如果不加行动，仍然会同步这些删除。</p>\n <p>那么，除了中国自己，其他国家的人都无法访问.cn网站。</p>\n <p>但是，这些国家很快就会有响应，凡是想访问.cn网站的国家，都会把cn记录加回去，并拒绝同步美国删去的这几行。</p>\n <p>最终，只有美国人，访问不了.cn网站。</p>\n <p>综上分析，我认为美国这么做的可能性不大，因为这一招过于低劣，将会让美国政府完全颜面扫地，并失去今后在互联网领域的任何话语权。而ICANN也将失去公信力，整个互联网世界，会推选使用新的机构和新的主根。</p>\n <p>因为互联网世界的一贯准则就是：如有封禁，就绕过它。</p>\n <h2><strong>后记</strong></h2>\n <p>最后，我们看看本文开头所提的两个断网事件是怎么回事：</p>\n <p>关于伊拉克域名事件，可以看看清华大学段海新教授的文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMDA1MTEzMg==&amp;mid=2247483726&amp;idx=1&amp;sn=cb268f1ac87b5a564637f2c74c28e37f&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">“伊拉克域名.IQ被美国删除的背后以及早期的根域名管理”</a>，里面把整个事件的来龙去脉说的很清楚。主要原因是.iq域名的前任管理者于2002年被关进监狱，新任管理者（NCMC）于2005年才提出申请，而IANA当时还考虑征求新旧代理双方对新授权的一致认可，所以才出现了所谓的“申请和解析工作被终止”。</p>\n <p>关于利比亚域名事件，可以看看此文：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMDA1MTEzMg==&amp;mid=2247483728&amp;idx=1&amp;sn=729702e672b8cfc4d1f53c91b8d8eae4&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">“利比亚国家顶级域名（.LY）中止服务始末”</a>，事实情况是参与运营.LY的两家机构因争夺归属权而内斗的结果（其中一方关闭了.LY域名服务器的解析）。经过这番变乱，2004年10月，ICANN批准将.LY授予利比亚邮电总公司，.LY事件算是尘埃落定。</p>\n <p><strong>本文中提到的风险和应对，主要是我个人的分析，下面看看业内专家的说法。</strong></p>\n <p>中国工程院院士、清华大学计算机系主任吴建平在2019年的一次访谈_（14）_中表示，DNS根域名服务器不是互联网的“核按钮”。全球互联网根域名服务器运行者，不可能同时关闭所有的根服务器，包括影子服务器。</p>\n <p>互联网域名系统北京市工程研究中心（ZDNS）主任毛伟表示_（15）_：互联网专家一直都在不断完善域名根系统安全保障机制，就算真的断“根”了，也有应急方法来解决。在境内，可以采用根区数据备份并搭建应急根服务器来解决；在全球层面，可以用根镜像、IPv6环境下的根服务器数量扩展、根服务器运行机构备选机制等方法来解决。</p>\n <p><strong>现在，了解了这么多，关于根域名服务器，你是不是放心了很多。</strong></p>\n <hr>\n  <p>参考文献：</p>\n  <ol>\n   <li>从网络大国走向网络强国(<a href=\"http://opinion.people.com.cn/n/2014/0624/c1003-25189448.html)\" rel=\"nofollow noreferrer\">http://opinion.people.com.cn/...</a></li>\n   <li>美国网络霸权浅析(<a href=\"http://www.wanfangdata.com.cn/details/detail.do?\" rel=\"nofollow noreferrer\">http://www.wanfangdata.com.cn...</a>_type=perio&amp;id=xxaqytxbm201410030)</li>\n   <li>为什么域名根服务器只能有13台呢？(<a href=\"https://www.zhihu.com/question/22587247)\" rel=\"nofollow noreferrer\">https://www.zhihu.com/questio...</a></li>\n   <li>Why 13 DNS root servers?(<a href=\"https://miek.nl/2013/november/10/why-13-dns-root-servers/)\" rel=\"nofollow noreferrer\">https://miek.nl/2013/november...</a></li>\n   <li><a href=\"https://root-servers.org\" rel=\"nofollow noreferrer\">https://root-servers.org</a></li>\n   <li>Initializing a DNS Resolver with Priming Queries(<a href=\"https://tools.ietf.org/html/draft-ietf-dnsop-resolver-priming-11)\" rel=\"nofollow noreferrer\">https://tools.ietf.org/html/d...</a></li>\n   <li>薛虹：互联网全球治理的新篇章(<a href=\"https://zhuanlan.zhihu.com/p/23042167)\" rel=\"nofollow noreferrer\">https://zhuanlan.zhihu.com/p/...</a></li>\n   <li>ICANN: IANA职能(<a href=\"https://www.icann.org/zh/system/files/files/iana-functions-18dec15-zh.pdf)\" rel=\"nofollow noreferrer\">https://www.icann.org/zh/syst...</a></li>\n   <li>阮一峰：根域名的知识</li>\n   <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5Mzg0NTU0NQ==&amp;mid=2649564853&amp;idx=2&amp;sn=6b9e6efc2a96600456a71836dcead62b&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">徐培喜：IANA职能管理权移交谁是赢家</a></li>\n   <li>北龙中网王伟任职PTI董事 我国专家就任国际互联网治理关键岗位(<a href=\"http://news.sina.com.cn/c/2017-12-25/doc-ifypwzxq6350205.shtml)\" rel=\"nofollow noreferrer\">http://news.sina.com.cn/c/201...</a></li>\n   <li>工业和信息化部关于同意中国互联网络信息中心设立域名根服务器（F、I、K、L根镜像服务器）及域名根服务器运行机构的批复(<a href=\"http://www.miit.gov.cn/n1146285/n1146352/n3054355/n3057709/n4704651/c7015545/content.html)\" rel=\"nofollow noreferrer\">http://www.miit.gov.cn/n11462...</a></li>\n   <li>工业和信息化部关于同意互联网域名系统北京市工程研究中心有限公司设立域名根服务器（L根镜像服务器）及域名根服务器运行机构的批复(<a href=\"http://www.miit.gov.cn/n1146285/n1146352/n3054355/n3057709/n4704651/c7015527/content.html)\" rel=\"nofollow noreferrer\">http://www.miit.gov.cn/n11462...</a></li>\n   <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTgzNDk4Mw==&amp;mid=2652359881&amp;idx=1&amp;sn=ed8710ae67a57c7dc064c8cff659febf&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">中国工程院院士吴建平：DNS根服务器不是互联网的核按钮！</a></li>\n   <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NzAxNjk2OQ==&amp;mid=2649539902&amp;idx=1&amp;sn=3282d2d6dfab2ef6d01e0a01ffcf8933&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">ZDNS毛伟：互联网根并不能让中国断网，更应重视企业域名服务风险</a></li>\n  </ol>\n  <p><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxMDc4NDc5OA==&amp;mid=2649431767&amp;idx=1&amp;sn=9747fb03cfd1de684ae9833355cd113d&amp;chksm=8354a7a6b4232eb05ccc55b31dcd82dc85757ef5799bba7db25d5c71934382793e866234c927&amp;mpshare=1&amp;scene=1&amp;srcid=0819bvibQdz6rOQL6fIJIfQ1&amp;sharer_sharetime=1597812690707&amp;sharer_shareid=3e4dff698aa001b9d1bbc8d5c5ee79ac&amp;rd2werd=1#wechat_redirect\" rel=\"nofollow noreferrer\">原文链接</a></p>\n  <p><img src=\"https://segmentfault.com/img/bVbJgYT\" alt=\"segmentfault 公众号\" title=\"segmentfault 公众号\" /></p>\n </hr>\n</hr>","descriptionType":"html","publishedDate":"Thu, 20 Aug 2020 03:23:00 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLAIE","linkMd5":"6077149de366230a75fc5ccb09f8bad7","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn46@2020_4/2020/08/24/23-08-23-218_dae355b894bbb09e.webp","destWidth":800,"destHeight":355,"sourceBytes":54090,"destBytes":17642,"author":"宗恩","articleImgCdnMap":{"https://segmentfault.com/img/bVbLAIE":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn46@2020_4/2020/08/24/23-08-23-218_dae355b894bbb09e.webp","https://segmentfault.com/img/remote/1460000023696740":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn50@2020_4/2020/08/24/23-08-31-193_c69cd228aa5900d5.webp","https://segmentfault.com/img/bVbLAK3":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn39@2020_5/2020/08/24/23-08-40-208_0326fce0462089d5.webp","https://segmentfault.com/img/bVbLALn":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn56@2020_4/2020/08/24/23-08-40-100_b74d346d8a6ba7ce.webp","https://segmentfault.com/img/bVbJgYT":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn92@2020_2/2020/08/24/23-08-40-881_7f8323e1c3c7e5a5.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"TypeScript 类型系统","link":"https://segmentfault.com/a/1190000023647609","description":"<p>TypeScript 的学习资料非常多，其中也不乏很多优秀的文章和教程。但是目前为止没有一个我特别满意的。原因有：</p>\n<ul>\n <li>它们大多数没有一个清晰的主线，而是按照 API 组织章节的，内容在<strong>逻辑上</strong>比较零散。</li>\n <li>大多是“讲是什么，怎么用“，而不是”讲为什么，讲原理“。</li>\n <li>大多数内容比较枯燥，趣味性比较低。都是干巴巴的文字，没有图片，缺乏能够引起强烈共鸣的例子。</li>\n</ul>\n<p>因此我的想法是做一套不同市面上大多数的 TypeScript 学习教程。以人类认知的角度思考问题，学习 TypeScript，通过通俗易懂的例子和图片来帮助大家建立 TypeScript 世界观。 而本篇文章则是这个系列的开篇。</p>\n<p>系列安排：</p>\n<ul>\n <li><a href=\"https://lucifer.ren/blog/2020/08/04/ts-internal/\" rel=\"nofollow noreferrer\">上帝视角看 TypeScript</a>（已发布）</li>\n <li>TypeScript 类型系统（就是本文）</li>\n <li>types 和 @types 是什么？</li>\n <li><a href=\"https://lucifer.ren/blog/2020/06/16/ts-generics/\" rel=\"nofollow noreferrer\">你不知道的 TypeScript 泛型（万字长文，建议收藏）</a>（已发布）</li>\n <li>TypeScript 配置文件该怎么写？</li>\n <li>TypeScript 是如何与 React，Vue，Webpack 集成的？</li>\n <li>TypeScript 练习题</li>\n</ul>\n<blockquote>\n 目录将来可能会有所调整。\n</blockquote>\n<p>注意，我的系列文章基本不会讲 API，因此需要你有一定的 TypeScript 使用基础，推荐两个学习资料。</p>\n<ul>\n <li><a href=\"https://jkchao.github.io/typescript-book-chinese/\" rel=\"nofollow noreferrer\">深入理解 TypeScript</a></li>\n <li><a href=\"https://www.typescriptlang.org/docs/home\" rel=\"nofollow noreferrer\">官方文档</a></li>\n</ul>\n<p>结合这两个资料和我的系列教程，掌握 TypeScript 指日可待。</p>\n<p>接下来，我们通过几个方面来从宏观的角度来看一下 TypeScript。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>前言</h2>\n<p>上一节的<a href=\"https://lucifer.ren/blog/2020/08/04/ts-internal/\" rel=\"nofollow noreferrer\">上帝视角看 TypeScript</a>，我们从宏观的角度来对 Typescript 进行了一个展望。之所以把那个放到开头讲是让大家有一个大体的认识，不想让大家一叶障目。当你对整个宏观层面有了一定的了解，那么对 Typescript 的理解就不会错太多。相反，一开始就是具体的概念和 API，则很可能会让你丧失都整体的基本判断。</p>\n<p>实际上， Typescript 一直在不断更新迭代。一方面是因为当初许下的诺言”Typescript 是 JavaScript 的超集“（JavaScript 的特性你要同步支持，同时也要处理各种新语法带来的不兼容情况）。不单是 ECMA，社区的其他发展可能也会让 Typescript 很难受。 比如 JSX 的广泛使用就给 Typescript 泛型的使用带来了影响。</p>\n<p>TypeScript 一直处于高速的迭代。除了修复日常的 bug 之外，TypeScript 也在不断发布新的功能，比如最新 <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-4-0-rc/#labeled-tuple-elements\" rel=\"nofollow noreferrer\">4.0.0 beta 版本的<strong>标签元祖</strong></a> 的功能就对智能提示这块很有用。Typescript 在社区发展方面也做的格外好，以至于它的竞争对手 Flow 被 Typescript 完美击败，这在很大程度上就是因为 Typescript 没有烂尾。如今微软在开源方向的发力是越来越显著了，我很期待微软接下来的表现，让我们拭目以待。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023647613\" alt=\"\" title=\"\" /></p>\n<h2>变量类型和值类型</h2>\n<p>有的同学可能有疑问， JavaScript 不是也有类型么？ 它和 Typescript 的类型是一回事么？JavaScript 不是动态语言么，那么经过 Typescript 的限定会不会丧失动态语言的动态性呢？我们继续往下看。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023647612\" alt=\"\" title=\"\" /></p>\n<ul>\n <li>JavaScript 中的类型其实是值的类型。实际上不仅仅是 JavaScript，任何动态类型语言都是如此，这也是动态类型语言的本质。</li>\n <li>Typescript 中的类型其实是变量的类型。实际上不仅仅是 Typescript，任何静态类型语言都是如此，这也是静态类型语言的本质。</li>\n</ul>\n<p>记住这两句话，我们接下来解释一下这两句话。</p>\n<p>对于 JavaScript 来说，一个变量可以是任意类型。</p>\n<pre><code class=\"js\">var a = 1;\na = \"lucifer\";\na = {};\na = [];</code></pre>\n<p>上面的值是有类型的。比如 1 是 number 类型，\"lucifer\" 是字符串类型， {} 是对象类型， [] 是数组类型。而变量 a 是没有固定类型的。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023647615\" alt=\"\" title=\"\" /></p>\n<p>对于 Typescript 来说， 一个变量只能接受和它类型兼容的类型的值。说起来比较拗口， 看个例子就明白了。</p>\n<pre><code class=\"ts\">var a: number = 1;\na = \"lucifer\"; // error\nvar b: any = 1;\na = \"lucifer\"; // ok\na = {}; // ok\na = []; // ok</code></pre>\n<p>我们不能将 string 类型的值赋值给变量 a， 因为 string 和 number 类型不兼容。而我们可以将 string,Object,Array 类型的值赋值给 b，因此 它们和 any 类型兼容。简单来说就是，一旦一个变量被标注了某种类型，那么其就只能接受这个类型以及它的子类型。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023647614\" alt=\"\" title=\"\" /></p>\n<h2>类型空间和值空间</h2>\n<p>类型和值居住在不同的空间，一个在阳间一个在阴间。他们之间互相不能访问，甚至不知道彼此的存在。类型不能当做值来用，反之亦然。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023647617\" alt=\"\" title=\"\" /></p>\n<h3>类型空间</h3>\n<p>如下代码会报类型找不到的错：</p>\n<pre><code class=\"ts\">const aa: User = { name: \"lucifer\", age: 17 };</code></pre>\n<p>这个比较好理解，我们只需要使用 interface 声明一下 User 就行。</p>\n<pre><code class=\"ts\">interface User {\n  name: string;\n  age: number;\n}\n\nconst aa: User = { name: \"lucifer\", age: 17 };</code></pre>\n<p>也就是说使用 interface 可以在类型空间声明一个类型，这个是 Typescript 的类型检查的基础之一。</p>\n<p>实际上类型空间内部也会有子空间。我们可以用 namespace（老）和 module（新） 来创建新的子空间。子空间之间不能直接接触，需要依赖导入导出来交互。</p>\n<h3>值空间</h3>\n<p>比如，我用 Typescript 写出如下的代码：</p>\n<pre><code class=\"ts\">const a = window.lucifer();</code></pre>\n<p>Typescript 会报告一个类似<code>Property 'lucifer' does not exist on type 'Window &amp; typeof globalThis'.</code> 的错误。</p>\n<p>实际上，这种错误并不是类型错误，而是找不到成员变量的错误。我们可以这样解决：</p>\n<pre><code class=\"ts\">declare var lucifer: () =&gt; any;</code></pre>\n<p>也就是说使用 declare 可以在值空间声明一个变量。这个是 Typescript 的变量检查的基础，不是本文要讲的主要内容，大家知道就行。</p>\n<p>明白了 JavaScript 和 TypeScript 类型的区别和联系之后，我们就可以来进入我们本文的主题了：<strong>类型系统</strong>。</p>\n<h2>类型系统是 TypeScript 最主要的功能</h2>\n<p>TypeScript 官方描述中有一句：<strong>TypeScript adds optional types to JavaScript that support tools for large-scale JavaScript applications</strong>。实际上这也正是 Typescript 的主要功能，即给 JavaScript 添加静态类型检查。要想实现静态类型检查，首先就要有类型系统。总之，我们使用 Typescript 的主要目的仍然是要它的静态类型检查，帮助我们提供代码的扩展性和可维护性。因此 Typescript 需要维护一套完整的类型系统。</p>\n<p><strong>类型系统包括 1. 类型 和 2.对类型的使用和操作</strong>，我们先来看类型。</p>\n<h3>类型</h3>\n<p>TypeScript 支持 JavaScript 中所有的类型，并且还支持一些 JavaScript 中没有的类型（毕竟是超集嘛）。没有的类型可以直接提供，也可以提供自定义能力让用户来自己创造。 那为什么要增加 JavaScript 中没有的类型呢？我举个例子，比如如下给一个变量声明类型为 Object，Array 的代码。</p>\n<pre><code class=\"ts\">const a: Object = {};\nconst b: Array = [];</code></pre>\n<p>其中：</p>\n<ul>\n <li>第一行代码 Typescript 允许，但是太宽泛了，我们很难得到有用的信息，推荐的做法是使用 interface 来描述，这个后面会讲到。</li>\n <li>第二行 Typescript 则会直接报错，原因的本质也是太宽泛，我们需要使用泛型来进一步约束。</li>\n</ul>\n<h3>对类型的使用和操作</h3>\n<p>上面说了<strong>类型和值居住在不同的空间，一个在阳间一个在阴间。他们之间互相不能访问，甚至不知道彼此的存在。</strong></p>\n<p>使用 declare 和 interface or type 就是分别在两个空间编程。比如 Typescript 的泛型就是在类型空间编程，叫做类型编程。除了泛型，还有集合运算，一些操作符比如 keyof 等。值的编程在 Typescript 中更多的体现是在类似 lib.d.ts 这样的库。当然 lib.d.ts 也会在类型空间定义各种内置类型。我们没有必要去死扣这个，只需要了解即可。</p>\n<p>lib.d.ts 的内容主要是一些变量声明（如：window、document、math）和一些类似的接口声明（如：Window、Document、Math）。寻找代码类型（如：Math.floor）的最简单方式是使用 IDE 的 F12（跳转到定义）。</p>\n<h2>类型是如何做到静态类型检查的？</h2>\n<p>TypeScript 要想解决 JavaScript 动态语言类型太宽松的问题，就需要：</p>\n<ol>\n <li>提供给<strong>变量</strong>设定类型的能力</li>\n</ol>\n<blockquote>\n 注意是变量，不是值。\n</blockquote>\n<ol>\n <li>提供常用类型（不必须，但是没有用户体验会极差）并可以扩展出自定义类型（必须）。</li>\n <li>根据第一步给变量设定的类型进行类型检查，即不允许类型不兼容的赋值， 不允许使用值空间和类型空间不存在的变量和类型等。</li>\n</ol>\n<p>第一个点是通过类型注解的语法来完成。即类似这样：</p>\n<pre><code class=\"ts\">const a: number = 1;</code></pre>\n<blockquote>\n Typescript 的类型注解是这样， Java 的类型注解是另一个样子，Java 类似 int a = 1。 这个只是语法差异而已，作用是一样的。\n</blockquote>\n<p>第二个问题， Typescript 提供了诸如 lib.d.ts 等类型库文件。随着 ES 的不断更新， JavaScript 类型和全局变量会逐渐变多。Typescript 也是采用这种 lib 的方式来解决的。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023647616\" alt=\"\" title=\"\" /></p>\n<p>（TypeScript 提供的部分 lib）</p>\n<p>第三个问题，Typescript 主要是通过 interface，type，函数类型等打通<strong>类型空间</strong>，通过 declare 等打通<strong>值空间</strong>，并结合 binder 来进行类型诊断。关于 checker ，binder 是如何运作的，可以参考我第一篇的介绍。</p>\n<p>接下来，我们介绍类型系统的功能，即它能为我们带来什么。如果上面的内容你已经懂了，那么接下来的内容会让你感到”你也不过如此嘛“。</p>\n<h2>类型系统的主要功能</h2>\n<ol>\n <li>定义类型以及其上的属性和方法。</li>\n</ol>\n<p>比如定义 String 类型， 以及其原型上的方法和属性。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023647618\" alt=\"\" title=\"\" /></p>\n<p>length， includes 以及 toString 是 String 的<strong>成员变量</strong>， 生活在值空间， 值空间虽然不能直接和类型空间接触，但是类型空间可以作用在值空间，从而给其添加类型（如上图黄色部分）。</p>\n<ol>\n <li>提供自定义类型的能力</li>\n</ol>\n<pre><code class=\"ts\">interface User {\n  name: string;\n  age: number;\n  say(name: string): string;\n}</code></pre>\n<p>这个是我自定义的类型 User，这是 Typescript 必须提供的能力。</p>\n<ol>\n <li>类型兼容体系。</li>\n</ol>\n<p>这个主要是用来判断类型是否正确的，上面我已经提过了，这里就不赘述了。</p>\n<ol>\n <li>类型推导</li>\n</ol>\n<p>有时候你不需要显式说明类型（类型注解），Typescript 也能知道他的类型，这就是类型推导结果。</p>\n<pre><code class=\"ts\">const a = 1;</code></pre>\n<p>如上代码，编译器会自动推导出 a 的类型 为 number。还可以有连锁推导，泛型的入参（泛型的入参是类型）推导等。类型推导还有一个特别有用的地方，就是用到类型收敛。</p>\n<p>接下来我们详细了解下类型推导和类型收敛。</p>\n<h2>类型推导和类型收敛</h2>\n<pre><code class=\"ts\">let a = 1;</code></pre>\n<p>如上代码。 Typescript 会推导出 a 的类型为 number。</p>\n<p>如果只会你这么写就会报错：</p>\n<pre><code class=\"ts\">a = \"1\";</code></pre>\n<p>因此 string 类型的值不能赋值给 number 类型的变量。我们可以使用 Typescript 内置的 typeof 关键字来证明一下。</p>\n<pre><code class=\"ts\">let a = 1;\ntype A = typeof a;</code></pre>\n<p>此时 A 的类型就是 number，证明了变量 a 的类型确实被隐式推导成了 number 类型。</p>\n<p>有意思的是如果 a 使用 const 声明，那么 a 不会被推导为 number，而是推导为类型 1。即<strong>值只能为 1 的类型</strong>，这就是类型收敛。</p>\n<pre><code class=\"ts\">const a = 1;\ntype A = typeof a;</code></pre>\n<blockquote>\n 通过 const ，我们将 number 类型收缩到了 \n <strong>值只能为 1 的类型</strong>。\n</blockquote>\n<p>实际情况的类型推导和类型收敛要远比这个复杂， 但是做的事情都是一致的。</p>\n<p>比如这个：</p>\n<pre><code class=\"ts\">function test(a: number, b: number) {\n  return a + b;\n}\ntype A = ReturnType&lt;typeof test&gt;;</code></pre>\n<p>A 就是 number 类型。 也就是 Typescript 知道两个 number 相加结果也是一个 number。因此即使你不显示地注明返回值是 number， Typescript 也能猜到。<strong>这也是为什么 JavaScript 项目不接入 Typescript 也可以获得类型提示的原因之一</strong>。</p>\n<p>除了 const 可以收缩类型， typeof， instanceof 都也可以。 原因很简单，就是<strong>Typescript 在这个时候可以 100% 确定你的类型了</strong>。 我来解释一下：</p>\n<p>比如上面的 const ，由于你是用 const 声明的，因此 100% 不会变，一定永远是 1，因此类型可以收缩为 1。 再比如：</p>\n<pre><code class=\"ts\">let a: number | string = 1;\na = \"1\";\nif (typeof a === \"string\") {\n  a.includes;\n}</code></pre>\n<p>if 语句内 a 100% 是 string ，不能是 number。因此 if 语句内类型会被收缩为 string。instanceof 也是类似，原理一模一样。大家只要记住<strong>Typescript 如果可以 100% 确定你的类型，并且这个类型要比你定义的或者 Typescript 自动推导的范围更小，那么就会发生类型收缩</strong>就行了。</p>\n<h2>总结</h2>\n<p>本文主要讲了 Typescript 的类型系统。 Typescript 和 JavaScript 的类型是很不一样的。从表面上来看， TypeScript 的类型是 JavaScript 类型的超集。但是从更深层次上来说，两者的本质是不一样的，一个是值的类型，一个是变量的类型。</p>\n<p>Typescript 空间分为值空间和类型空间。两个空间不互通，因此值不能当成类型，类型不能当成值，并且值和类型不能做运算等。不过 TypeScript 可以将两者结合起来用，这个能力只有 TypeScript 有， 作为 TypeScript 的开发者的你没有这个能力，这个我在第一节也简单介绍了。</p>\n<p>TypeScript 既会对变量存在与否进行检查，也会对变量类型进行兼容检查。因此 TypeScript 就需要定义一系列的类型，以及类型之间的兼容关系。默认情况，TypeScript 是没有任何类型和变量的，因此你使用 String 等都会报错。TypeScript 使用库文件来解决这个问题，最经典的就是 lib.d.ts。</p>\n<p>TypeScript 已经做到了足够智能了，以至于你不需要写类型，它也能猜出来，这就是类型推导和类型收缩。当然 TypeScript 也有一些功能，我们觉得应该有，并且也是可以做到的功能空缺。但是我相信随着 TypeScript 的逐步迭代（截止本文发布，TypeScript 刚刚发布了 4.0.0 的 beta 版本），一定会越来越完善，用着越来越舒服的。</p>\n<p>我们每个项目的需要是不一样的， 简单的基本类型肯定无法满足多样的项目需求，因此我们必须支持自定义类型，比如 interface， type 以及复杂一点的泛型。当然泛型很大程度上是为了减少样板代码而生的，和 interface ， type 这种刚需不太一样。</p>\n<p>有了各种各样的类型以及类型上的成员变量，以及成员变量的类型，再就加上类型的兼容关系，我们就可以做类型检查了，这就是 TypeScript 类型检查的基础。TypeScript 内部需要维护这样的一个关系，并对变量进行类型绑定，从而给开发者提供<strong>类型分析</strong>服务。</p>\n<h2>关注我</h2>\n<p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的前端硬核文章，带你认识你不知道的前端。</p>\n<p>公众号【 <a href=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg\" rel=\"nofollow noreferrer\">力扣加加</a>】<br>知乎专栏【 <a href=\"https://www.zhihu.com/people/lu-xiao-13-70\" rel=\"nofollow noreferrer\">Lucifer - 知乎</a>】</br></p>\n<p>点关注，不迷路！</p>","descriptionType":"html","publishedDate":"Sun, 16 Aug 2020 08:47:31 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023647613","linkMd5":"bd58cfa67f4f5a8296c3cadfd7f5f584","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn74@2020_6/2020/08/24/23-08-22-906_d94bb8e812bfe91b.webp","destWidth":800,"destHeight":267,"sourceBytes":14509,"destBytes":7928,"author":"lucifer","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023647613":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn74@2020_6/2020/08/24/23-08-22-906_d94bb8e812bfe91b.webp","https://segmentfault.com/img/remote/1460000023647612":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn24@2020_6/2020/08/24/23-08-41-735_107915944ae8e8f0.webp","https://segmentfault.com/img/remote/1460000023647615":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn36@2020_3/2020/08/24/23-08-42-134_aa11cbe09197e23f.webp","https://segmentfault.com/img/remote/1460000023647614":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn28@2020_2/2020/08/24/23-08-43-039_31d9dc656eb69c0c.webp","https://segmentfault.com/img/remote/1460000023647617":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn65@2020_2/2020/08/24/23-08-42-437_c0f9fa580c29ad2c.webp","https://segmentfault.com/img/remote/1460000023647616":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn31@2020_4/2020/08/24/23-08-41-339_dae97fa38554c9f9.webp","https://segmentfault.com/img/remote/1460000023647618":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn61@2020_5/2020/08/24/23-08-42-563_0092cc3deacdf28c.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"悄咪咪提高团队幸福感 &amp; Surprise！","link":"https://segmentfault.com/a/1190000023601927","description":"<h2>前言</h2>\n<p>本文的灵感是在几个月以前工作不忙（摸鱼）时想到的，老是自己一个人往前冲冲冲也没啥意思，需要想一点办法，来提高团队的效率，提高团队的幸福感（效率起来了，单位时间内代码写的更多，那不就幸福啦 😜），经过几个月的摸索，总结出了几个小点，如果大家有更好的方式，欢迎一起讨论~</p>\n<p>&lt;br/&gt;</p>\n<h2>永久解决不知道是什么版本</h2>\n<p>我司的产品主要分为Saas端和私有平台，分别部署在公网和客户的私有环境，先来说说私有环境的问题：<strong>不知道真正部署的项目版本</strong>，说来很可笑，运维同学在部署的时候肯定是记录过各个客户的代码版本的，但也就是这么可笑，有时候就是会弄错，可能是由于升级流程不够完善，或者工作失误等等，总之，想个办法解决。</p>\n<p>&lt;br/&gt;</p>\n<p>人靠不住，但还有代码。<strong>Git</strong>已经成为代码管理的事实标准，这就不多说了，即然人管理不好版本，那还是从<strong>Git</strong>本身入手吧，悄咪咪的给所有项目依赖（<strong>POM.XML</strong>）增加一个插件：</p>\n<pre><code class=\"xml\">&lt;!-- Git Version插件 --&gt;\n&lt;plugin&gt;\n    &lt;groupId&gt;pl.project13.maven&lt;/groupId&gt;\n    &lt;artifactId&gt;git-commit-id-plugin&lt;/artifactId&gt;\n    &lt;version&gt;4.0.0&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;id&gt;get-the-git-infos&lt;/id&gt;\n            &lt;phase&gt;initialize&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;revision&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n    &lt;configuration&gt;\n        &lt;dotGitDirectory&gt;${project.basedir}/.git&lt;/dotGitDirectory&gt;\n        &lt;verbose&gt;false&lt;/verbose&gt;\n        &lt;dateFormat&gt;yyyy-MM-dd HH:mm:ss&lt;/dateFormat&gt;\n        &lt;prefix&gt;git&lt;/prefix&gt;\n        &lt;generateGitPropertiesFile&gt;true&lt;/generateGitPropertiesFile&gt;\n        &lt;generateGitPropertiesFilename&gt;${project.build.outputDirectory}/${project.name}.build.json&lt;/generateGitPropertiesFilename&gt;\n        &lt;format&gt;json&lt;/format&gt;\n        &lt;gitDescribe&gt;\n            &lt;skip&gt;false&lt;/skip&gt;\n            &lt;always&gt;false&lt;/always&gt;\n            &lt;dirty&gt;-dirty&lt;/dirty&gt;\n        &lt;/gitDescribe&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;</code></pre>\n<p>插件将会在每次构建时生成一个版本相关文件，内容如下：</p>\n<pre><code class=\"json\">{\n  \"git.branch\" : \"master\",\n  \"git.build.host\" : \"Kerwin\",\n  \"git.build.time\" : \"2020-08-12 23:24:59\",\n  \"git.build.user.email\" : \"34807944+kkzhilu@users.noreply.github.com\",\n  \"git.build.user.name\" : \"kkzhilu\",\n  \"git.build.version\" : \"1.0.0-SNAPSHOT\",\n  \"git.closest.tag.commit.count\" : \"\",\n  \"git.closest.tag.name\" : \"\",\n  \"git.commit.id\" : \"4981afb5dfeee6f835dcf9a7a135083d8e973090\",\n  \"git.commit.id.abbrev\" : \"4981afb\",\n  \"git.commit.id.describe\" : \"4981afb\",\n  \"git.commit.id.describe-short\" : \"4981afb\",\n  \"git.commit.message.full\" : \"Commit git-version\",\n  \"git.commit.message.short\" : \"Commit git-version\",\n  \"git.commit.time\" : \"2020-08-04 18:18:47\",\n  \"git.commit.user.email\" : \"34807944+kkzhilu@users.noreply.github.com\",\n  \"git.commit.user.name\" : \"kexianming\",\n  \"git.dirty\" : \"false\",\n  \"git.local.branch.ahead\" : \"0\",\n  \"git.local.branch.behind\" : \"0\",\n  \"git.remote.origin.url\" : \"https://github.com/kkzhilu/KerwinBoots.git\",\n  \"git.tags\" : \"\",\n  \"git.total.commit.count\" : \"9\"\n}</code></pre>\n<p>插件名字叫：<strong>git-commit-id-plugin</strong>，至于细节使用就自己去搜索啦，它可以实现的效果即在每次打包时生成相应的Git相关信息，这样无论运维同学是否把代码升错，我们都可以知道<strong>代码到底是什么版本</strong></p>\n<p>以后终于听不到同事之间因为代码版本扯皮的事情了🤪</p>\n<p>&lt;br/&gt;</p>\n<h2>永久解决没打日志怎么办的问题</h2>\n<p>回到刚刚说的Saas端生产环境，由于各种原因，我们团队经常需要维护不是自己写的项目，很多时候一些细节逻辑完全摸不着头脑，而且没有日志，最要命的是在测试环境还不复现，肿么办？</p>\n<p>&lt;br/&gt;</p>\n<p>以前的解决方案是各种喊人，然后硬看代码寻找上下文，尽可能的找到蛛丝马迹，总之效率非常感人，处理的慢了就是一个事故，全员挨批评，咋办呢？我就一直在寻找这种问题的解决办法，终于我发现了一个神器：<strong>Arthas</strong></p>\n<p>&lt;br/&gt;</p>\n<p>用过这个工具的人就知道它有多强大，阿里出品，官方文档链接：<a href=\"https://arthas.gitee.io/commands.html\" rel=\"nofollow noreferrer\">https://arthas.gitee.io/comma...</a></p>\n<p>我们可以通过其提供的部分命令，如：<code>tt</code>，<strong>获取方法执行数据的时空隧道，它可以记录下指定方法每次调用的入参和返回信息</strong>，想想它的帮助有多大，<strong>记录每一个方法的入参和出参</strong>，如果真遇上没日志的情况，知道这些信息其实配合代码就可以很快定位问题了，所以，听过没用过的朋友，都去试试吧，真的很无敌。</p>\n<p>下次同事有难时，你就用这个工具去帮他，他说不定会请你吃顿饭🍗</p>\n<p>&lt;br/&gt;</p>\n<h2>永久解决哪里耗时这么长的问题</h2>\n<p>这个问题是由于之前同事重写了一块业务逻辑，结果线上展现层耗时大概30s，oh，天哪！在测试环境明明是一瞬间的，咋办？</p>\n<p>造成这种问题的原因，肯定是SQL写的不好，或者业务处理哪里做了很多不必要的动作（我们没有灰度测试），但是生产环境又不能随便动，也不能断点调试，从日志也只能看到耗时很长，但是慢在哪里不知道。</p>\n<p>&lt;br/&gt;</p>\n<p>当一个方法里面经过了N个内部方法后，你不知道到底是哪一个导致这么长的耗时，当无法复现的时候怎么办呢？其实还是利用上面的那个工具<strong>Arthas</strong>，还是一样的命令<strong>tt</strong>，它不仅可以记录入参和出参信息，<strong>还可以记录每一个方法的耗时</strong>，多么的强大。</p>\n<p>&lt;br/&gt;</p>\n<p>所以我是为了再次提醒，这些功能只是<strong>Arthas</strong>的一点皮毛，咱们要学会合理使用开源工具</p>\n<p>&lt;br/&gt;</p>\n<h2>注释无法表达流程图效果的解决方案</h2>\n<p>注释是文字，难以表达如流程图一般的效果，所以该怎么办呢？我找到了两种解决方案，目前在项目中使用效果非常之好，第一钟是利用<strong>ASCII注释工具</strong>，该工具的地址：<a href=\"http://asciiflow.com/\" rel=\"nofollow noreferrer\">http://asciiflow.com/</a></p>\n<p>效果如下：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023601930\" alt=\"\" title=\"\" /></p>\n<p>注释如下：</p>\n<pre><code class=\"bash\">+-------------------------------+\n|                               |\n|  +-------------------------+  |\n|  |                         |  |\n|  |           Demo          |  |\n|  |                         |  |\n|  |                         |  |\n|  +------------+------------+  |\n|               |               |\n|               |               |\n|               |               |\n|               |               |\n|               |               |\n|               |               |\n|               |               |\n|               |               |\n|               |               |\n|               +------&gt; False  |\n|               |               |\n|               |               |\n|    True   &lt;---+               |\n|                               |\n+-------------------------------+\n</code></pre>\n<p>这玩意画出来的图是可以直接复制成文本的，控制好尺寸就可以解决大部分情况，也可以想象之前网上有一些很奇葩的注释是不是就是用这个工具或者同样的原理画出来的，附上一副之前文章缺的一张图：</p>\n<p><strong>上亿数据怎么玩深度分页？兼容MySQL + ES + MongoDB：</strong><a href=\"https://juejin.im/post/6850037275456339975\" rel=\"nofollow noreferrer\">https://juejin.im/post/685003...</a></p>\n<p>这篇文章写完的时候，我自己方案的图还没画好，所以很多朋友问我用id实现不了什么的，这次就顺便展示一下我的方案</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023601931\" alt=\"\" title=\"\" /></p>\n<p>解决方案之二，利用<strong>MarkDown</strong>的原生画图功能，我不知道要发布文章的平台支不支持，所以用截图来代替了（<strong>Typora支持</strong>）</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023601932\" alt=\"\" title=\"\" /></p>\n<p>不知道的同学搜一下，<strong>MarkDown</strong>绘图语法，拿一个适合的改就好了，没必要专门去学，放到代码里看看效果：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023601934\" alt=\"\" title=\"\" /></p>\n<p>有一个小<strong>Tips</strong>，使用IDEA的时候，<strong>利用鼠标滚动键可以按块复制，这样一来可以直接复制到指定的注释内容</strong>，然后把它复制到任何一个正常的<strong>MarkDown</strong>工具里，就可以展示流程图了，简直不要太完美，想测试的朋友可以复制以下代码去一些工具里试试，需要设置代码种类为：<strong>mermaid</strong></p>\n<pre><code class=\"bash\"> sequenceDiagram\n    Note over Boot: 启动类\n    Note over PDFThread: 线程类\n    Note over PDFWorker: 执行类\n      Boot-&gt;&gt;PDFThread: Boot类启动线程\n    PDFThread-&gt;&gt;PDFWorker: 线程类调用真正工作Worker\n    loop 队列处理\n        PDFThread-&gt;PDFThread: 考虑成功与失败情况处理方案\n    end\n    \n    PDFWorker--&gt;&gt;PDFThread: Worker响应执行结果\n    Note right of PDFWorker: 注意参数校验 &lt;br/&gt;文件格式校验</code></pre>\n<p>你未来的同事维护代码的时候会爱上你，如果是女生，可能还会嫁给你🧡</p>\n<p>幻想有一天你老大跑过来问你，你这写的注释都是些什么玩意，然后你一复制一粘贴，一张图就出来了！下次涨薪会没有你？</p>\n<p>（反正我涨了，还不少😎）</p>\n<p>&lt;br/&gt;</p>\n<p>PS：我考虑写一个支持直接复制然后渲染成流程图的<strong>IDEA插件</strong>，如果有现成的请联系我，就省的我去写了，嘿嘿✌</p>\n<p>&lt;br/&gt;</p>\n<h2>垃圾SQL的解决方案</h2>\n<p>我们公司没有专门的<code>DBA</code>，所以<code>SQL</code>语句的质量只掌握在开发和开发组长的手上，有时候事情多，或者不细心，或者模块不是很重要就容易粗心，到了生产环境出大问题，针对这种情况的解决方案依然是寻找工具，比如，我盯上了<strong>小米的`Soar</strong></p>\n<p>项目地址：<a href=\"https://github.com/XiaoMi/soar\" rel=\"nofollow noreferrer\">https://github.com/XiaoMi/soar</a></p>\n<p>官方的介绍：</p>\n<ul>\n <li>跨平台支持</li>\n <li>目前只支持 MySQL 语法族协议的 SQL 优化</li>\n <li>支持基于启发式算法的语句优化</li>\n <li>支持复杂查询的多列索引优化（UPDATE、INSERT、DELETE、SELECT）</li>\n</ul>\n<p>贴个图片展示一下效果：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023601933\" alt=\"\" title=\"\" /></p>\n<p>这款工具可以进行对<strong>SQL</strong>进行打分，同时提供一些建议，它的能力上限我们还没有摸索出来，但是下限还是可以肯定的，因此之后只需要关注<strong>索引</strong>是否正确使用，其他的就交给这个工具吧，低于90分，就改！</p>\n<p>PS：这个开源项目推荐使用<strong>docker</strong>安装，简单粗暴无脑省时间，命令如下：</p>\n<pre><code class=\"bash\"># 安装镜像\ndocker pull becivells/soar-web\n\n# 运行\ndocker run -d --name Soar-web -p 5077:5077 becivells/soar-web</code></pre>\n<p>想着有个工具会检查SQL质量了，是不是写的时候也认真多啦，幸福感提示满满，哈哈~😁</p>\n<p>&lt;br/&gt;</p>\n<h2>懒得写文档的解决方案</h2>\n<p>方案设计的文档不可能由工具去写，但是简单的数据库字段映射，或者接口文档总不需要开发去写吧？也是一样摸索摸索，找到了几个不太适合但是靠边的开源项目，如：</p>\n<p><strong>apidoc：</strong><a href=\"https://github.com/apidoc/apidoc\" rel=\"nofollow noreferrer\">https://github.com/apidoc/apidoc</a></p>\n<blockquote>\n RESTful web API Documentation Generator.\n</blockquote>\n<p>&lt;br/&gt;</p>\n<p><strong>JApiDocs：</strong><a href=\"https://github.com/YeDaxia/JApiDocs\" rel=\"nofollow noreferrer\">https://github.com/YeDaxia/JA...</a></p>\n<blockquote>\n A magical api documentation generator without annotation for springboot.\n</blockquote>\n<p>&lt;br/&gt;</p>\n<p><strong>APIAuto：</strong><a href=\"https://github.com/TommyLemon/APIAuto\" rel=\"nofollow noreferrer\">https://github.com/TommyLemon...</a></p>\n<blockquote>\n 机器学习测试、自动生成代码、自动静态检查、自动生成文档与注释等，做最先进的接口管理工具\n</blockquote>\n<p>&lt;br/&gt;</p>\n<p>因为每个项目的情况不同，但是我又不想做大的改动，所以只能说是靠边，不能百分百适合，但有了这些开源项目，我就可以改写其中的代码，让它适应当前项目的注释方案等等，总是，能节省相当一部分的编写文档的时间</p>\n<p>&lt;br/&gt;</p>\n<h2>重复性代码的解决方案</h2>\n<p>这个的确是个大坑，谁让咱们是CRUD程序员呢，经常需要写重复性相当高，但是又有一点不同的代码，这里我的解决方案是利用模板 + 更合适的工具解决，如果只是数据库操作层重复代码多，我们完全可以利用<strong>mybatis-plus</strong>工具减少重复代码，又或者写出<strong>公共的操作层</strong>减少重复代码。</p>\n<p>&lt;br/&gt;</p>\n<p>当用工具完不成的时候，我就会用上模板了，比如直接我写过一个简单的开源项目：</p>\n<p><strong>好像很厉害的生成器！一秒钟搞定一个项目：</strong><a href=\"https://juejin.im/post/6844904148417118215\" rel=\"nofollow noreferrer\">https://juejin.im/post/684490...</a></p>\n<p>核心思路和要求如下：</p>\n<ul>\n <li>基于数据库获取原始数据</li>\n <li>基于模板 + 原始数据生成可运行的SpringBoot项目，支持界面 + 基本增删改查</li>\n <li>提供拓展式接口，可以实现不修改代码生成全新的文件</li>\n</ul>\n<p>&lt;br/&gt;</p>\n<p>那利用这种思路，其实完全可以写一套更开放的代码生成模板，比如根据传递的<code>JSON</code>报文去解析数据，根据传递的<code>模板</code>去生成数据，这样的话又可以解决相当大一部分的重复工具，你，值得拥有。</p>\n<p>PS：同理，其实数据库字段映射文档也可以用这种方式，只需要一秒钟，简直不要太舒服🤷‍♂️</p>\n<p>&lt;br/&gt;</p>\n<h2>重复性的操作用脚本代码</h2>\n<p>这个其实大家都有意识，但是有时候就是感觉可能用的不多，真要用起来的时候又没功夫去写脚本，比如进入一个<strong>docker</strong>容器，如果用命令行的话，至少要经历两步代码，十几秒的时间，如果写一个脚本呢，以后进入容器只需要一秒钟，所以我给团队写了不少这种脚本，其实我一开始也不会，反正就复制来一个改一改就行，如下是进入<strong>docker容器</strong>的</p>\n<pre><code class=\"bash\">#使用说明，用来提示输入参数\nusage() {\n    echo \"Usage: sh 执行脚本.sh [rpcapp|tomcat|nginx|mysql]\"\n    exit 1\n}\n\nrpcapp(){\n  DOCKER_ID=$(docker ps | grep \"rpcapp\" | awk '{print $1}')\n  docker exec -it $DOCKER_ID bash\n}\n\ntomcat(){\n  DOCKER_ID=$(docker ps | grep \"tomcat\" | awk '{print $1}')\n  docker exec -it $DOCKER_ID bash\n}\n\nnginx(){\n  DOCKER_ID=$(docker ps | grep \"nginx\" | awk '{print $1}')\n  docker exec -it $DOCKER_ID bash\n}\n\nmysql(){\n  DOCKER_ID=$(docker ps | grep \"mysql\" | awk '{print $1}')\n  docker exec -it $DOCKER_ID bash\n}\n\n#根据输入参数，选择执行对应方法，不输入则执行使用说明\ncase \"$1\" in\n  \"rpcapp\")\n    rpcapp\n    ;;\n  \"tomcat\")\n    tomcat\n    ;;\n  \"nginx\")\n    nginx\n    ;;\n  \"mysql\")\n    mysql\n    ;;\n  *)\n    usage\n    ;;\nesac</code></pre>\n<p>&lt;br/&gt;</p>\n<p>从网上找了找，又找到一个开源项目用以记录常用的脚本</p>\n<p><strong>useful-scripts：</strong><a href=\"https://github.com/oldratlee/useful-scripts\" rel=\"nofollow noreferrer\">https://github.com/oldratlee/...</a></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023601935\" alt=\"\" title=\"\" /></p>\n<p>能自动的就不要每次都手写啦，节约时间去摸鱼不快乐吗👏</p>\n<p>&lt;br/&gt;</p>\n<h2>最后</h2>\n<p>这可是我这么久以来总结的时间管理神器，节省的时间拿去摸鱼学习，循环促进效率和能力，形成良性正反馈</p>\n<p>这还不值得<strong>来个赞</strong>👍👍👍吗？嘿嘿~</p>\n<blockquote>\n 另外可以搜索公众号「\n <strong>是Kerwin啊</strong>」，一起进步！\n <p>也可以查看<a href=\"https://github.com/kkzhilu\" rel=\"nofollow noreferrer\">Kerwin的GitHub主页</a>，关注一个小白程序员的进步，这货最近在折腾Go~</p>\n</blockquote>","descriptionType":"html","publishedDate":"Thu, 13 Aug 2020 01:27:00 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023601930","linkMd5":"caee1d7512ed006f50fb714e278bb4f4","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn50@2020_1/2020/08/24/23-08-21-971_83bb94c2dc369fca.webp","destWidth":800,"destHeight":417,"sourceBytes":52499,"destBytes":10952,"author":"Kerwin","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023601930":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn50@2020_1/2020/08/24/23-08-21-971_83bb94c2dc369fca.webp","https://segmentfault.com/img/remote/1460000023601931":"https://cdn.jsdelivr.net/gh/myreaderx/cdn50@2020_6/2020/08/24/23-08-33-441_5bc3d20e66a31ee9.webp","https://segmentfault.com/img/remote/1460000023601932":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn42@2020_3/2020/08/24/23-08-33-612_ecc0aceb5b22010d.webp","https://segmentfault.com/img/remote/1460000023601934":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn4@2020_6/2020/08/24/23-08-36-470_98a69215dba7edeb.webp","https://segmentfault.com/img/remote/1460000023601933":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn46@2020_3/2020/08/24/23-08-33-567_4185d7618d0af188.webp","https://segmentfault.com/img/remote/1460000023601935":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn11@2020_1/2020/08/24/23-08-37-304_1fddd172f9de192b.webp"},"publishedOrCreatedDate":1598310388569},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"学习Vue3.0，先从搭建环境开始","link":"https://segmentfault.com/a/1190000023737670","description":"<blockquote>\n Bug源测试，上线来几个。愿君多修改，今夜眼难合。\n</blockquote>\n<p>这是小编关于<code>Vue3.0</code>系列文章的第二篇，本文将带您从零搭建一个基于<code>Vue3.0</code>与<code>vite</code>的<code>Vue3.0</code>开发环境，通过本文的学习，你将学习到以下内容：</p>\n<ol>\n <li>使用<code>vite</code>初始化<code>Vue3.0</code>项目</li>\n <li>配置<code>ts</code></li>\n <li>配置<code>vue-router</code></li>\n <li>配置<code>vuex</code></li>\n <li>使用<code>Vue3.0</code>开发一个<code>TodoList</code>示例</li>\n</ol>\n<blockquote>\n 同时本文的内容已录制为视频发布到了\n <code>B站</code>，可以点击链接跳转到视频地址，同时您也可以通过微信搜索【前端有的玩】关注我的公众号加我微信好友，手摸手和你一起学习\n <code>Vue3.0</code>\n</blockquote>\n<h3>使用<code>vite</code>初始化项目</h3>\n<h4>vite 介绍</h4>\n<p><code>vite</code>是尤大大在今年新鼓捣出来的一个工具，尤大大对<code>vite</code>的描述是这样的: Vite is an opinionated web dev build tool that serves your code via native ES Module imports during dev and bundles it with <a href=\"https://rollupjs.org/\" rel=\"nofollow noreferrer\">Rollup</a> for production. 翻译成中文就是：<code>Vite </code>是一个由原生 <code>ES Module </code>驱动的 <code>Web</code> 开发构建工具。在开发环境下基于浏览器原生 <code>ES imports</code> 开发，在生产环境下基于<code> Rollup </code>打包。</p>\n<p>上面这段话提到了一个关键字<code>ES Module</code>,这个是什么呢？详细的介绍大家可以访问 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules\" rel=\"nofollow noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules</a> 进行查看。此处我们长话短说。在最早的时候，还没有前端工程化，然后我们写<code>javascript</code>都是写到一个文件，然后通过<code>script</code>标签去引用，后来随着前端发展越来越壮大，<code>js</code>之间依赖越来越复杂，这时候就需要有一种可以将<code>JavaScript 程序拆分为可按需导入的单独模块</code>的机制来维护这个依赖，随之就诞生了<code>AMD</code>,<code>CMD</code>等等，而<code>ES Module</code>就是浏览器支持的原生模块依赖的功能。</p>\n<h4>为什么要用vite</h4>\n<p>为什么尤大大要推出<code>vite</code>，在我们使用<code>webpack</code>的时候，每次开发时候启动项目都需要几十秒甚至超过一分钟，比较慢，而且热更新也比较慢，而<code>vite</code>的主要特点就是快，官网对于<code>vite</code>的特点是这样描述的</p>\n<ol>\n <li>快速的冷启动</li>\n <li>即时的模块热更新</li>\n <li>真正的按需编译</li>\n</ol>\n<p>到底有多快呢，我们先新建一个项目试试</p>\n<h4>初始化vite项目</h4>\n<ol>\n <li><p>初始化项目, 在工作空间打开终端窗口，对于<code>window</code>用户即<code>cmd</code>，然后执行下面命令</p><pre><code class=\"shell\">yarn create vite-app my-vue3</code></pre><p>执行之后就会输出以下内容，可以看到新建项目特别快，仅仅用了<code>1.63s</code></p><p><img src=\"https://segmentfault.com/img/remote/1460000023737674\" alt=\"\" title=\"\" /></p></li>\n <li>初始化完项目，通过<code>cd my-vue3</code>进行到项目里面，然后再执行<code>yarn</code>安装依赖（此处建议使用淘宝镜像，比较快）</li>\n <li>依赖安装完需要通过<code>yarn dev</code>启动项目<p><img src=\"https://segmentfault.com/img/remote/1460000023737673\" alt=\"\" title=\"\" /></p><p>是不是瞬间体验到了秒启项目的感觉，启动之后就可以通过<code>http://localhost:3000</code>来访问项目了</p></li>\n</ol>\n<h4>查看项目结构</h4>\n<p>使用<code>vscode</code>打开项目之后，可以查看到新建的项目结构与<code>vue-cli4</code>创建的项目结构基本一样，都是我们很熟悉的<code>App.vue</code>和<code>main.js</code></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023737676\" alt=\"\" title=\"\" /></p>\n<h4>查看main.js文件内容</h4>\n<p>打开<code>main.js</code></p>\n<pre><code class=\"javascript\">import { createApp } from 'vue'\nimport App from './App.vue'\nimport './index.css'\n\ncreateApp(App).mount('#app')\n</code></pre>\n<p>发现创建<code>Vue</code>的方式变了，原来是通过<code>new Vue</code>的方法来初始化<code>Vue</code>，在<code>Vue3.0</code>中，修改为了通过<code>createApp</code>的方式，关于<code>Vue3.0</code>的更多使用方式，我们将在后面的系列文章中逐渐为您带来讲解。</p>\n<h3>配置typescript</h3>\n<p><code>typescript</code>现在已经成为了前端必备技能之一，大量的项目也开始基于<code>typescript</code>进行开发。在使用<code>Vue2.0</code>的时候，因为<code>Vue2.0</code>没有对<code>typescript</code>进行支持，所以使用<code>ts</code>开发功能显示有些别扭。但到了<code>Vue3</code>，其自身源码便是基于<code>ts</code>开发的，所以对<code>ts</code>天生有着很好的支持。使用<code>vite</code>配置<code>typescript</code>很简单，只需要进行以下几步操作.</p>\n<ol>\n <li><p>安装 <code>typescript</code></p><pre><code class=\"shell\">yarn add typescript -D</code></pre></li>\n <li><p>初始化<code>tsconfig.json</code></p><pre><code class=\"shell\"># 然后在控制台执行下面命令\nnpx tsc --init</code></pre></li>\n <li><p>将<code>main.js</code>修改为<code>main.ts</code>,同时将<code>index.html</code>里面的引用也修改为<code>main.ts</code>, 通过还需要修改<code>App.vue</code>与<code>HelloWorld.vue</code>文件，修改方式如下</p><pre><code class=\"html\">&lt;!--将 &lt;script&gt; 修改为 &lt;script lang=\"ts\"&gt;--&gt;\n&lt;script lang=\"ts\"&gt;\nimport HelloWorld from './components/HelloWorld.vue'\n\nexport default {\n  name: 'App',\n  components: {\n    HelloWorld\n  }\n}\n&lt;/script&gt;\n</code></pre><p>修改完之后，重启就可以访问项目了。虽然这样配置是可以了，但是打开<code>main.ts</code>会发现<code>import App from App.vue</code>会报错:<code> Cannot find module './App.vue' or its corresponding type declarations.</code>,这是因为现在<code>ts</code>还没有识别<code>vue</code>文件，需要进行下面的配置:</p>\n  <ol>\n   <li>在项目根目录添加<code>shim.d.ts</code>文件</li>\n   <li><p>添加以下内容</p><pre><code class=\"javascript\">declare module \"*.vue\" {\n  import { Component } from \"vue\";\n  const component: Component;\n  export default component;\n}</code></pre></li>\n  </ol></li>\n</ol>\n<p>接下来你就可以开开心心的在组件中使用<code>ts</code>了</p>\n<h3>配置 <code>vue-router</code></h3>\n<p>在<code>Vue2.0</code>中我们路由一般会选择使用<code>vue-router</code>,在<code>Vue3.0</code>依然可以使用<code>vue-router</code>,不过和<code>Vue3.0</code>一样当前<code>vue-router</code>的版本也是<code>beta</code>版本，在本文撰写的时候，版本是<code>4.0.0-beta7</code></p>\n<h4>安装<code>vue-router</code></h4>\n<p>因为当前<code>vue-router</code>针对<code>vue3.0</code>的版本还是<code>beta</code>版本，所以不能直接通过<code>yarn add vue-router</code>进行安装，而是需要带上版本号</p>\n<pre><code class=\"shell\">yarn add vue-router@4.0.0-beta.7</code></pre>\n<h4>配置vue-router</h4>\n<p>在项目<code>src</code>目录下面新建<code>router</code>目录，然后添加<code>index.ts</code>文件，在文件中添加以下内容</p>\n<pre><code class=\"javascript\">import {createRouter, createWebHashHistory} from 'vue-router'\n\n// 在 Vue-router新版本中，需要使用createRouter来创建路由\nexport default createRouter({\n  // 指定路由的模式,此处使用的是hash模式\n  history: createWebHashHistory(),\n  // 路由地址\n  routes: []\n})</code></pre>\n<p>与新的<code>Vue3.0</code>初始化方式发生变化一样，<code>vue-router</code>的初始化方式也发生了变化，变成了通过<code>createRouter</code>来初始化路由。</p>\n<h4>将<code>router</code>引入到<code>main.ts</code>中</h4>\n<p>修改<code>main.ts</code>文件内容如下</p>\n<pre><code class=\"javascript\">import { createApp } from 'vue'\nimport App from './App.vue'\nimport './index.css'\nimport router from './router/index'\n\nconst  app = createApp(App)\n// 通过use 将 路由插件安装到 app 中\napp.use(router)\napp.mount('#app')\n</code></pre>\n<h3>配置 vuex</h3>\n<p>与<code>vue-router</code>一样，新的<code>vuex</code>当前也处于<code>beta</code>版本，当前版本是<code>4.0.0-beta.4</code></p>\n<h4>安装vuex</h4>\n<pre><code class=\"shell\">yarn add vuex@4.0.0-beta.4</code></pre>\n<h4>配置vuex</h4>\n<p>在项目<code>src</code>目录下面新建<code>store</code>目录，并添加<code>index.ts</code>文件，文件中添加以下内容</p>\n<pre><code class=\"javascript\">import { createStore } from 'vuex'\n\ninterface State {\n  userName: string\n}\n\nexport default createStore({\n  state(): State {\n    return {\n      userName: \"子君\",\n    };\n  },\n});</code></pre>\n<h4>引入到<code>main.ts</code>中</h4>\n<pre><code class=\"javascript\">import { createApp } from 'vue'\nimport App from './App.vue'\nimport './index.css'\nimport router from './router/index'\nimport store from './store/index'\n\nconst  app = createApp(App)\napp.use(router)\napp.use(store)\napp.mount('#app')</code></pre>\n<h3>开发TodoList</h3>\n<p>通过上面的一系列操作，我们的开发环境就已经配置完成了，接下来我们就通过新的开发环境先开发一个<code>TodoList</code>，来验证一下是否正常。</p>\n<h4>添加<code>todolist</code>页面</h4>\n<ol>\n <li><p>首先我们先在<code>src</code>目录下面新建一个<code>views</code>目录，然后在其中新建文件<code>todo-list.vue</code>，并为文件添加以下内容</p><pre><code class=\"html\">\n&lt;template&gt;\n  &lt;div class=\"todo-list\"&gt;\n    &lt;div&gt;\n      &lt;label&gt;新增待办&lt;/label&gt;\n       &lt;input v-model=\"state.todo\" @keyup.enter=\"handleAddTodo\"&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;h3&gt;待办列表({{todos.length}})&lt;/h3&gt;\n      &lt;ul&gt;\n        &lt;li v-for=\"item in todos\" :key=\"item.id\" @click=\"handleChangeStatus(item, true)\"&gt;\n          &lt;input type=\"checkbox\"&gt;\n          &lt;label&gt;{{item.text}}&lt;/label&gt;\n        &lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n    &lt;div&gt;&lt;h3&gt;已办列表({{dones.length}})&lt;/h3&gt;&lt;/div&gt;\n    &lt;ul&gt;\n      &lt;li v-for=\"item in dones\" :key=\"item.id\" @click=\"handleChangeStatus(item, false)\"&gt;\n          &lt;input type=\"checkbox\" checked&gt;\n          &lt;label&gt;{{item.text}}&lt;/label&gt;\n        &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script lang=\"ts\"&gt;\n // 在vue2中 data 在vue3中使用 reactive代替\nimport { reactive, computed } from 'vue'\nimport { useRouter } from 'vue-router'\nexport default {\n  // setup相当于vue2.0的 beforeCreate和 created，是vue3新增的一个属性，所有的操作都在此属性中完成\n  setup(props, context) {\n    // 通过reactive 可以初始化一个可响应的数据，与Vue2.0中的Vue.observer很相似\n    const state = reactive({\n      todoList: [{\n        id: 1,\n        done: false,\n        text: '吃饭'\n      },{\n        id: 2,\n        done: false,\n        text: '睡觉'\n      },{\n        id: 3,\n        done: false,\n        text: '打豆豆'\n      }],\n      todo: ''\n    })\n    // 使用计算属性生成待办列表\n    const todos = computed(() =&gt; {\n      return state.todoList.filter(item =&gt; !item.done)\n    })\n\n    // 使用计算属性生成已办列表\n    const dones = computed(() =&gt; {\n      return state.todoList.filter(item =&gt; item.done)\n    })\n\n    // 修改待办状态\n    const handleChangeStatus = (item ,status) =&gt; {\n      item.done = status\n    }\n    \n    // 新增待办\n    const handleAddTodo = () =&gt; {\n      if(!state.todo) {\n        alert('请输入待办事项')\n        return\n      }\n      state.todoList.push({\n        text: state.todo,\n        id: Date.now(),\n        done: false\n      })\n      state.todo = ''\n    }\n\n        // 在Vue3.0中，所有的数据和方法都通过在setup 中 return 出去，然后在template中使用\n    return {\n      state,\n      todos,\n      dones,\n      handleChangeStatus,\n      handleAddTodo\n    }\n  }\n}\n&lt;/script&gt;\n&lt;style scoped&gt;\n.todo-list{\n  text-align: center;\n}\n\n.todo-list ul li {\n  list-style: none;\n}\n&lt;/style&gt;</code></pre><h4>调整路由</h4>\n  <ol>\n   <li><p>首先将<code>App.vue</code>文件内容修改为</p><pre><code class=\"vue\">&lt;template&gt;\n  &lt;router-view&gt;&lt;/router-view&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\"&gt;\n\nexport default {\n  name: 'App'\n}\n&lt;/script&gt;</code></pre></li>\n   <li><p>然后修改 <code>router/index.ts</code>文件，添加新的路由</p><pre><code class=\"javascript\">import {createRouter, createWebHashHistory} from 'vue-router'\n\n// 在 Vue-router新版本中，需要使用createRouter来创建路由\nexport default createRouter({\n  // 指定路由的模式,此处使用的是hash模式\n  history: createWebHashHistory(),\n  // 路由地址\n  routes: [{\n    path: '/todolist',\n    // 必须添加.vue后缀\n    component: () =&gt; import('../views/todo-list.vue')\n  }]\n})</code></pre><p>这时候我们就可以通过<code>http://localhost:3000/#/todolist</code>来访问<code>TodoList</code>了，效果如下图所示</p><p><img src=\"https://segmentfault.com/img/remote/1460000023737675\" alt=\"\" title=\"\" /></p></li>\n  </ol></li>\n</ol>\n<h3>总结</h3>\n<p>到此，我们<code>Vue3.0</code>的开发环境算是搭建完成了，当然现在还有好多好多要完善的东西，比如我们还需要去调整一下<code>typescript</code>的配置，然后添加<code>eslint</code>等等。同时如何在组件中跳转路由，使用<code>vuex</code>还没有去讲解，不过至少我们已经起步了，更多的内容将会在下一篇文章中讲到。本文首发于公众号【前端有的玩】，欢迎关注加我好友，我们一起探讨<code>Vue3.0</code></p>","descriptionType":"html","publishedDate":"Mon, 24 Aug 2020 04:16:41 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023737674","linkMd5":"f6d9b255d764f38d4cfc647c5d61450c","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn78@2020_3/2020/08/24/23-08-23-064_68e17a2630a82d60.webp","destWidth":800,"destHeight":449,"sourceBytes":64842,"destBytes":31124,"author":"子君","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023737674":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn78@2020_3/2020/08/24/23-08-23-064_68e17a2630a82d60.webp","https://segmentfault.com/img/remote/1460000023737673":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn1@2020_1/2020/08/24/23-08-33-510_28a02d81591a6ac2.webp","https://segmentfault.com/img/remote/1460000023737676":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn9@2020_2/2020/08/24/23-08-33-492_e143eeeacb3d77c7.webp","https://segmentfault.com/img/remote/1460000023737675":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn6@2020_5/2020/08/24/23-08-33-208_54794e46f067943b.webp"},"publishedOrCreatedDate":1598310388557},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"我在阿里写代码学会的六件事","link":"https://segmentfault.com/a/1190000023655551","description":"<p><strong>简介：</strong> 从团队的角度来看，写好代码是一件非常有必要的事情。如何写出干净优雅的代码是个很困难的课题，我没有找到万能的 solution，更多的是一些 trade off，可以稍微讨论一下。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023655554\" alt=\"8.14头图.png\" title=\"8.14头图.png\" /></p>\n<p>写了多年的代码，始终觉得如何写出干净优雅的代码并不是一件容易的事情。按 10000 小时刻意训练的定理，假设每天 8 小时，一个月 20 天，一年 12 个月，大概也需要 5 年左右的时间成为大师。其实我们每天的工作中真正用于写代码的时间不可能有 8 个小时，并且很多时候是在完成任务，在业务压力很大的时候，可能想要达到的目标是如何尽快的使得功能 work 起来，代码是否干净优雅非常可能没有能放在第一优先级上，而是怎么快怎么来。</p>\n<p>在这样的情况下是非常容易欠下技术债的，时间长了，这样的代码基本上无法维护，只能推倒重来，这个成本是非常高的。欠债要还，只是迟早的问题，并且等到要还的时候还要赔上额外的不菲的利息。还债的有可能是自己，也有可能是后来的继任者，但都是团队在还债。所以从团队的角度来看，写好代码是一件非常有必要的事情。如何写出干净优雅的代码是个很困难的课题，我没有找到万能的 solution，更多的是一些 trade off，可以稍微讨论一下。</p>\n<h1>代码是写给人看的还是写给机器看的？</h1>\n<p>在大部分的情况下我会认为代码是写给人看的。虽然代码最后的执行者是机器，但是实际上代码更多的时候是给人看的。我们来看看一段代码的生命周期：开发 --&gt;&nbsp;单元测试 --&gt; Code Review --&gt; 功能测试 --&gt; 性能测试 --&gt; 上线 --&gt; 运维、Bug 修复 --&gt; 测试上线 --&gt; 退休下线。开发到上线的时间也许是几周或者几个月，但是线上运维、bug 修复的周期可以是几年。</p>\n<p>在这几年的时间里面，几乎不可能还是原来的作者在维护了。继任者如何能理解之前的代码逻辑是极其关键的，如果不能维护，只能自己重新做一套。所以在项目中我们经常能见到的情况就是，看到了前任的代码，都觉得这是什么垃圾，写的乱七八糟，还是我自己重写一遍吧。就算是在开发的过程中，需要别人来 Code &nbsp;Review，如果他们都看不懂这个代码，怎么来做 Review 呢。还有你也不希望在休假的时候，因为其他人看不懂你的代码，只好打电话求助你。这个我印象极其深刻，记得我在工作不久的时候，一次回到了老家休假中，突然同事打电话来了，出现了一个问题，问我该如何解决，当时电话还要收漫游费的，非常贵，但是我还不得不支持直到耗光我的电话费。</p>\n<p>所以<strong>代码主要还是写给人看的，是我们的交流的途径</strong>。那些非常好的开源的项目虽然有文档，但是更多的我们其实还是看他的源码，如果开源项目里面的代码写的很难读，这个项目也基本上不会火。因为代码是我们开发人员交流的基本途径，甚至可能口头讨论不清楚的事情，我们可以通过代码来说清楚。代码的可读性我觉得是第一位的。各个公司估计都有自己的代码规范，遵循相关的规范保持代码风格的统一是第一步（推荐谷歌代码规范和微软代码规范）。规范里一般都包括了如何进行变量、类、函数的命名，函数要尽量短并且保持原子性，不要做多件事情，类的基本设计的原则等等。另外一个建议是可以多参考学习一下开源项目中的代码。</p>\n<h1>KISS （Keep it simple and stupid）</h1>\n<p>一般大脑工作记忆的容量就是 5-9 个，如果事情过多或者过于复杂，对于大部分人来说是无法直接理解和处理的。通常我们需要一些辅助手段来处理复杂的问题，比如做笔记、画图，有点类似于在内存不够用的情况下我们借用了外存。</p>\n<p>学 CS 的同学都知道，外存的访问速度肯定不如内存访问速度。另外一般来说在逻辑复杂的情况下出错的可能要远大于在简单的情况下，在复杂的情况下，代码的分支可能有很多，我们是否能够对每种情况都考虑到位，这些都有困难。为了使得代码更加可靠，并且容易理解，最好的办法还是保持代码的简单，在处理一个问题的时候尽量使用简单的逻辑，不要有过多的变量。</p>\n<p>但是现实的问题并不会总是那么简单，那么如何来处理复杂的问题呢？与其借用外存，我更加倾向于对复杂的问题进行分层抽象。网络的通信是一个非常复杂的事情，中间使用的设备可以有无数种（手机，各种 IOT 设备，台式机，laptop，路由器，交换机...), OSI 协议对各层做了抽象，每一层需要处理的情况就都大大地简化了。通过对复杂问题的分解、抽象，那么我们在每个层次上要解决处理的问题就简化了。其实也类似于算法中的 divide-and-conquer， 复杂的问题，要先拆解掉变成小的问题，从而来简化解决的方法。</p>\n<p>KISS 还有另外一层含义，“如无必要，勿增实体” （奥卡姆剃刀原理）。CS 中有一句 \"All problems in computer science can be solved by another level of indirection\"， 为了系统的扩展性，支持将来的一些可能存在的变化，我们经常会引入一层间接层，或者增加中间的 interface。在做这些决定的时候，我们要多考虑一下是否真的有必要。增加额外的一层给我们的好处就是易于扩展，但是同时也增加了复杂度，使得系统变得更加不可理解。对于代码来说，很可能是我这里调用了一个 API，不知道实际的触发在哪里，对于理解和调试都可能增加困难。</p>\n<p>KISS 本身就是一个 trade off，要把复杂的问题通过抽象和分拆来简单化，但是是否需要为了保留变化做更多的 indirection 的抽象，这些都是需要仔细考虑的。</p>\n<h1>DRY （Don't repeat yourself)</h1>\n<p>为了快速地实现一个功能，知道之前有类似的，把代码 copy 过来修改一下就用，可能是最快的方法。但是 copy 代码经常是很多问题和 bug 的根源。有一类问题就是 copy 过来的代码包含了一些其他的逻辑，可能并不是这部分需要的，所以可能有冗余甚至一些额外的风险。</p>\n<p>另外一类问题就是在维护的时候，我们其实不知道修复了一个地方之后，还有多少其他的地方还需要修复。在我过去的项目中就出现过这样的问题，有个问题明明之前做了修复，过几天另外一个客户又提了类似的问题出现的另外的路径上。相同的逻辑要尽量只出现在一个地方，这样有问题的时候也就可以一次性地修复。这也是一种抽象，对于相同的逻辑，抽象到一个类或者一个函数中去，这样也有利于代码的可读性。</p>\n<h1>是否要写注释</h1>\n<p>个人的观点是大部分的代码尽量不要注释。代码本身就是一种交流语言，并且一般来说编程语言比我们日常使用的口语更加的精确。在保持代码逻辑简单的情况下，使用良好的命名规范，代码本身就很清晰并且可能读起来就已经是一篇良好的文章。特别是 OO 的语言的话，本身 object（名词）加 operation（一般用动词）就已经可以说明是在做什么了。重复一下把这个操作的名词放入注释并不会增加代码的可读性。并且在后续的维护中，会出现修改了代码，却并不修改注释的情况出现。在我做的很多 Code Review 中我都看到过这样的情况。尽量把代码写的可以理解，而不是通过注释来理解。</p>\n<p>当然我并不是反对所有的注释，在公开的 API 上是需要注释的，应该列出 API 的前置和后置条件，解释该如何使用这个 API，这样也可以用于自动产品 API 的文档。在一些特殊优化逻辑和负责算法的地方加上这些逻辑和算法的解释还是非常有必要的。</p>\n<h1>一次做对，不要相信以后会 Refactoring</h1>\n<p>通常来说在代码中写上 TODO，等着以后再来 refactoring 或者改进，基本上就不会再有以后了。我们可以去我们的代码库里面搜索一下 TODO，看看有多少，并且有多少是多少年前的，我相信这个结果会让你很惊讶（欢迎大家留言分享你查找之后的结果）。</p>\n<p>尽量一次就做对，不要相信以后还会回来把代码 refactoring 好。人都是有惰性的，一旦完成了当前的事情，move on 之后再回来处理这些概率就非常小了，除非下次真的需要修改这些代码。如果说不会再回来，那么这个 TODO 也没有什么意义。如果真的需要，就不要留下这个问题。我见过有的人留下了一个 TODO，throw 了一个 not implemented 的 exception，然后几天之后其他同学把这个代码带上线了，直接挂掉的情况。尽量不要 TODO, 一次做好。</p>\n<h1>是否要写单元测试？</h1>\n<p>个人的观点是必须，除非你只是做 prototype 或者快速迭代扔掉的代码。</p>\n<blockquote>\n Unit tests are typically automated tests written and run by software developers to ensure that a section of an application (known as the \"unit\") meets its design and behaves as intended. In procedural programming, a unit could be an entire module, but it is more commonly an individual function or procedure. In object-oriented programming, a unit is often an entire interface, such as a class, but could be an individual method.&nbsp;\n <p>&nbsp;From Wikipedia</p>\n</blockquote>\n<p>单元测试是为了保证我们写出的代码确实是我们想要表达的逻辑。当我们的代码被集成到大项目中的时候，之后的集成测试、功能测试甚至 e2e 的测试，都不可能覆盖到每一行的代码了。如果单元测试做的不够，其实就是在代码里面留下一些自己都不知道的黑洞，哪天调用方改了一些东西，走到了一个不常用的分支可能就挂掉了。我之前带的项目中就出现过类似的情况，代码已经上线几年了，有一次稍微改了一下调用方的参数，觉得是个小改动，但是上线就挂了，就是因为遇到了之前根本没有人测试过的分支。单元测试就是要保证我们自己写的代码是按照我们希望的逻辑实现的，需要尽量的做到比较高的覆盖，确保我们自己的代码里面没有留下什么黑洞。关于测试，我想单独开一篇讨论，所以就先简单聊到这里。</p>\n<p>要写好代码确实是已经非常不容易的事情，需要考虑正确性、可读性、鲁棒性、可测试性、可以扩展性、可以移植性、性能。前面讨论的只是个人觉得比较重要的入门的一些点，想要写好代码需要经过刻意地考虑和练习才能真正达到目标！</p>","descriptionType":"html","publishedDate":"Mon, 17 Aug 2020 05:35:10 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023655554","linkMd5":"5043732a2558bb2fe1d74251745d70bf","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn9@2020_4/2020/08/24/23-08-23-117_4774f58479cda1db.webp","destWidth":800,"destHeight":458,"sourceBytes":333627,"destBytes":23424,"author":"阿里技术","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023655554":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn9@2020_4/2020/08/24/23-08-23-117_4774f58479cda1db.webp"},"publishedOrCreatedDate":1598310388564},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"第八代小冰年度发布会召开，开启小冰智能生涯的第二幕","link":"https://segmentfault.com/a/1190000023714011","description":"<p><img src=\"https://segmentfault.com/img/bVbLFeR\" alt=\"第八代小冰年度发布会召开，开启小冰智能生涯的第二幕\" title=\"第八代小冰年度发布会召开，开启小冰智能生涯的第二幕\" /></p>\n<p>2020年8月20日，小冰公司、rinna株式会社及微软（亚洲）互联网工程院在北京联合举行了第八代小冰年度发布会。小冰公司董事长、原微软全球执行副总裁沈向洋博士与微软全球资深副总裁、微软（亚洲）互联网工程院院长王永东博士主持了本次发布会。</p>\n<p>本次大会主要围绕三部分内容：</p>\n<p>第一，人工智能时代，我们对未来的判断和想法</p>\n<p>第二，小冰人工智能方面核心技术的进展</p>\n<p>第三，新产品发布</p>\n<p>值得关注的是小冰已经学会了画画！经过小冰团队人工智能和美院老师的共同努力，她学会了怎么来绘画，并且她能够比较高质量的生产绘画作品，其中包括历史上7个流派。也就是说小冰已经突破了传统的框架，开启了人工智能的第二幕。</p>\n<p>小冰有一个未来交流的框架，她是能够支持丰富多彩、千千万万的人工智能，所以她不仅仅只是我们看到的这样一个小冰，一个少女的形象，这个少女的形象只是这个框架支持的一个样板，可以让大家来体验，所以在过去每一代小冰上，小冰团队一直努力让这个框架能够更加完善。</p>\n<h2>从第一代到第八代的沿革</h2>\n<p>小冰是面向新交互形式的完整人工智能技术框架，也是目前全球范围内承载交互量最大的人工智能系统，占全球交互总量60%以上。该项目于2013年底在微软（亚洲）互联网工程院立项，采取代际更新的方式，逐年完善其基础框架结构。</p>\n<p><img src=\"https://segmentfault.com/img/bVbLFfh\" alt=\"第八代小冰年度发布会召开，开启小冰智能生涯的第二幕\" title=\"第八代小冰年度发布会召开，开启小冰智能生涯的第二幕\" /></p>\n<p>2014年5月29日，小冰正式推出第一代产品，以对话式聊天机器人形式迅速积累训练数据。其后，第二代产品完成了跨平台部署的交互架构。第三代产品将交互从文本扩充至多模态，进一步积累多模态训练数据。从第四代小冰开始，交互总量稳居全球第一并保持至今，同时发布了全双工语音交互感官。第五代小冰采用Dual AI战略，大幅度扩展跨平台覆盖的规模，至20余个主流平台，并成为中国市场上涵盖了华为、小米、OPPO、vivo等智能手机及硬件的唯一的跨平台人工智能。第六代小冰完成了框架迭代目标，从第七代开始推出各类框架工具，以帮助创建第三方人工智能产品，并承载其各类交互。</p>\n<p>目前，除中国小冰及日本凛菜（Rinna）第一方人工智能交互主体外，小冰框架还支撑了中国及日本100余个第三方品牌的交互主体（如软银Pepper）。在个人用户领域，由小冰框架应用户需求创造并提供交互的人工智能主体（虚拟人类），在公测阶段已超过100万个。</p>\n<p>从第七代小冰开始，在尚未组建正式销售团队的商业化试水阶段，小冰收入已超过1亿元人民币。为加快小冰产品线的本土创新步伐，促进小冰商业生态环境的完善，2020年7月13日，微软宣布将小冰业务分拆为独立公司运营，并委任原微软全球执行副总裁沈向洋博士为董事长，原微软（亚洲）互联网工程院副院长李笛为首席执行官，陈湛为日本分部总经理。预计所有相关工作将于今年晚些时候完成。</p>\n<h2>小冰框架与面向未来的新交互形态</h2>\n<p>交互是人类社会发展的重要驱动力。每天都在发生的数以千亿次计的交互，随移动互联网的迅速发展，已进入明显瓶颈，表现为“流量红利消失”等。而现有的两种交互形式：人人交互与人机交互，可通过人工智能技术加以融合，从而在实现人人交互信任纽带和高转化率的同时，保有人机交互的高并发率特点。</p>\n<p><img src=\"https://segmentfault.com/img/bVbLFfq\" alt=\"第八代小冰年度发布会召开，开启小冰智能生涯的第二幕\" title=\"第八代小冰年度发布会召开，开启小冰智能生涯的第二幕\" /></p>\n<p>上述融合依赖于小冰框架或其他类似的完整人工智能框架体系，可以在各种复杂的场景中实现高度拟人的交互。随着对现有交互瓶颈的不断突破，新形式的人工智能交互将无处不在，对人类社会及商业行为产生深远影响。</p>\n<h2>本次发布会主要披露的新技术</h2>\n<p>与主要同行业者相比，小冰框架最大的差异化在于，它是一个“session-oriented”的人工智能框架，框架中的各部分技术共同为“交互全程”目标服务，而不仅仅关注并优化局部。例如，在核心对话引擎方面，技术的研发及迭代方向是为更有效地预测、保持并引导对话，而不是仅仅实现回应。在语音方面，框架关注语音交互的质量与体验是否能支持长时间的混合交流，而不仅仅是将文本内容转为语音。</p>\n<p><img src=\"https://segmentfault.com/img/bVbLFfE\" alt=\"第八代小冰年度发布会召开，开启小冰智能生涯的第二幕\" title=\"第八代小冰年度发布会召开，开启小冰智能生涯的第二幕\" /></p>\n<p>本次发布会升级了上一代小冰框架的各部分技术，并将一些新技术纳入系统之中。此外，本次发布会还披露了部分独有新技术及其产品化情况。如篇章内容主动学习技术，使对人工智能主体的对话训练不再需要采用“问答对”的方式；分层知识图谱技术，使小冰框架中的人工智能主体，在引导对话时的全程完成率突破42%，接近于人类表现等。上述技术均已实现产品化落地。</p>\n<h2>本次发布会宣布的上线产品</h2>\n<p>面向个人用户的第一个虚拟人类产品线。在公测阶段，该产品线应用户需求创造的虚拟人类已超过100万名。发布会上，小冰宣布第一个正式版本上线。用户可以自主通过小冰框架，创造并训练其拥有的人工智能主体。除基本交互体验外，该产品线还推出了以下新功能：</p>\n<p>跨平台的统一账号体系。可理解为虚拟人类的身份证，实现跨平台统一。目前已开放的支持平台从华为拓展至小米及微博。</p>\n<p>测试版的训练工具“X Eva”APP。用户也可在交互过程中训练其人工智能虚拟人类。与之相比，X Eva APP提供更丰富的强大训练能力。</p>\n<p>多人交互的能力。通过多种方式，虚拟人类可与多人进行持续交互，而不局限于用户个体。</p>\n<p>内容创造的能力。虚拟人类可进行多种自主的内容创造，并将之反映在其自身的“朋友圈”中。上述内容创造可反映虚拟人类与用户交流中所产生的变化。</p>\n<p>针对需要具体完成特定任务的虚拟人类，框架提供特定的训练及托管平台。例如，在正式发布前的公测阶段，小冰框架已应用户需求，派出超过70000名人工智能小编，提供内容和交互服务。</p>\n<p>部分新平台与新的第三方虚拟人类合作产品。发布会上发布了三项此类新合作：包括与企鹅电竞合作推出的直播间人工智能产品；与小米合作推出的小冰童话屋模式，可在语音交互之外配合2D场景及虚拟人类形象交互；与QQ合作推出的QQ群新机器人角色喵吉。</p>\n<p>面向个人用户的“X套件”系列应用软件。包括基于文本协同的X Writer，面向声音协同的X Studio和面向虚拟人类3D演示文档驱动的X Presenter。X套件支持用户选择平台提供的虚拟人类，或自己创造的虚拟人类。X套件为小冰商业化解决方案版本的“个人版”。</p>\n<p>X Writer：可实现在用户进行文字编辑或文本创作时的人工智能协同，随云端更新不断扩充各类文体。产品具备沉浸式体验。</p>\n<p>X Studio：包括面向各类公众号文章、演讲、电台节目等的X Studio主播，以及面向人工智能歌声合成的X Studio歌手正式版软件。其中，主播应用已在商业化领域覆盖中国及日本超过50家主流电台电视台，累计制作超过8000小时高质量音频节目内容，此次推出的为其个人版本；歌手软件技术在全球范围内居于领先位置，并且是目前唯一一个完整产品化的同类软件。</p>\n<p>X Presenter：驱动用户选择或创造的人工智能实体3D模型，配合X套件其他应用，实现人工智能对演示文档的演讲及交互。</p>\n<p>配合 “X套件”发布，发布会还宣布了以下信息：</p>\n<p>X Studio人工智能歌手入籍计划启动。任何机构或个人可申请并提交数据，由小冰框架训练并将其人工智能歌手登录进X Studio歌手平台中。机构或个人拥有该歌手的完整所有权，可通过平台制作内容，并自由进行相关人工智能歌手的销售转让等。此计划是为了进一步促进人工智能歌手市场发展。此外，X Studio人工智能歌手何畅演唱Burberry新系列推广单曲也已上线。除何畅演唱外，该广告单曲的词曲创作亦有小冰参与。</p>\n<p>X Presenter。商业版为日本LAWSON驱动的自主舞蹈人工智能已上线。另外，基于自控系统，小冰与小米小爱团队进行了非常深入的合作，一起探索将小爱同学的虚拟形象试验性地引入到了聊天场景中。让用户可以和小爱同学的形象实时对话，除了语音维度，还能看到小爱同学的表情、动作等一系列视觉表达。该APP已于发布会之日起开始内测用户招募。</p>\n<p><img src=\"https://segmentfault.com/img/bVbJgYT\" alt=\"segmentfault 公众号\" title=\"segmentfault 公众号\" /></p>","descriptionType":"html","publishedDate":"Fri, 21 Aug 2020 06:42:44 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLFeR","linkMd5":"317dc10a0d3fb89965600980c204116d","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn18@2020_5/2020/08/24/23-08-22-045_aea76744bd0bf3f8.webp","destWidth":800,"destHeight":532,"sourceBytes":78474,"destBytes":22338,"author":"宗恩","articleImgCdnMap":{"https://segmentfault.com/img/bVbLFeR":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn18@2020_5/2020/08/24/23-08-22-045_aea76744bd0bf3f8.webp","https://segmentfault.com/img/bVbLFfh":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn39@2020_4/2020/08/24/23-08-37-152_4ce085e5b8852c3c.webp","https://segmentfault.com/img/bVbLFfq":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn44@2020_1/2020/08/24/23-08-37-389_8988f99120692e64.webp","https://segmentfault.com/img/bVbLFfE":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn32@2020_4/2020/08/24/23-08-37-014_df9d49603cc32ef0.webp","https://segmentfault.com/img/bVbJgYT":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn92@2020_2/2020/08/24/23-08-40-881_7f8323e1c3c7e5a5.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"思否开源项目推介丨UUI：功能优先的通用 UI 组件库","link":"https://segmentfault.com/a/1190000023608841","description":"<p><img src=\"https://segmentfault.com/img/bVbLdSk\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n<blockquote>\n 开源项目名称：UUI \n <br>开源项目负责人：@孙扣扣 <br>开源项目简介：功能优先的通用 UI 组件库 <br>开源项目类型：团队开源项目<br>项目创建时间：2020 年 <br>GitHub 数据：44 Star，2 Fork <br>GitHub 地址：<a href=\"https://github.com/HackPlan/UUI\" rel=\"nofollow noreferrer\">https://github.com/HackPlan/UUI</a></br></br></br></br></br></br>\n</blockquote>\n<h2>负责人自荐</h2>\n<p>做这个项目是因为我们发现市面上的 UI 组件库大多数都是样式和功能一体的，也就是说无法轻松的完成样式的自定义，结果是很多使用同一个 UI 组件库的项目，看起来就像是同一个风格。</p>\n<p>UUI 希望提供一个功能优先，样式可高度自定义的基础组件库。通过使用 UUI，各个项目可以根据自己的样式风格，轻松的定制自己的组件库。</p>\n<p>拓展性方面，不同于其他组件库高度封装的设计，UUI 提供了极高的自定义空间，当功能不够用的时候，可以自行拓展。</p>\n<p>UUI 最早是 2019 年底就开始内部开发，今年年初开始投入生产项目的使用。现在每周都在活跃地更新。</p>\n<h2><strong>项目特性</strong></h2>\n<ul>\n <li>一组开箱即用的有用的组件。</li>\n <li>基于 TypeScript 的类型安全性。</li>\n <li>强大的组件样式自定义功能。</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/bVbLdSL\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n<h2>项目亮点</h2>\n<ul>\n <li><strong>组件种类丰富：</strong>提供了较全面的基础组件、覆盖各类场景，组件特性丰富、满足各种功能需求。</li>\n <li><strong>支持高度拓展：</strong>为了更好定制自定义组件的功能，可以使用自定义组件扩展机制。</li>\n <li><strong>风格化组件样式：</strong>支持灵活的样式定制，简易生成多种风格，满足个性化产品需求。</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/bVbLdSN\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n<h2>思否推荐</h2>\n<p>UUI 是 HackPlan 团队打造了一款功能优先的通用 UI 组件库，支持常见的 Breadcrumb、Button 等29 种组件，可以满足一些中小型业务的需求。</p>\n<p>UUI 的文档展示方式让人眼前一亮，不再是单纯的演示 + 代码，而是融入了Actions、Story、Knobs、Performance、Accessibility 等方式来让使用者更详细的了解与学习使用 UUI。</p>\n<hr>\n <p><img src=\"https://segmentfault.com/img/bVbHZSb\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n <p>该项目已入选<a href=\"https://segmentfault.com/a/1190000022680721\">「SFOSSP - 思否开源项目支持计划」</a>，我们希望借助社区的资源对开源项目进行相关的宣传推广，并作为一个长期项目助力开源事业的发展，与广大开发者共建开源新生态。</p>\n <p>有意向的开源项目负责人或团队成员，可通过邮箱提供相应的信息（开源项目地址、项目介绍、团队介绍、联系方式等），以便提升交流的效率。</p>\n <p>联系邮箱：pr@segmentfault.com</p>\n <p><img src=\"https://segmentfault.com/img/bVbJgYT\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n</hr>","descriptionType":"html","publishedDate":"Thu, 13 Aug 2020 07:36:23 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLdSk","linkMd5":"06182f917f57c9d9612487bd563c6868","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn34@2020_5/2020/08/24/23-08-25-088_b71f870050272f58.webp","destWidth":800,"destHeight":430,"sourceBytes":4675788,"destBytes":1007754,"author":"徐九","articleImgCdnMap":{"https://segmentfault.com/img/bVbLdSk":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn34@2020_5/2020/08/24/23-08-25-088_b71f870050272f58.webp","https://segmentfault.com/img/bVbLdSL":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn62@2020_4/2020/08/24/23-08-31-078_6038012b8d24d65d.webp","https://segmentfault.com/img/bVbLdSN":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn73@2020_6/2020/08/24/23-08-30-993_8783d0846c619bb6.webp","https://segmentfault.com/img/bVbHZSb":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn68@2020_4/2020/08/24/23-08-37-572_9328baa6c41eb7d7.webp","https://segmentfault.com/img/bVbJgYT":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn92@2020_2/2020/08/24/23-08-40-881_7f8323e1c3c7e5a5.webp"},"publishedOrCreatedDate":1598310388568},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"软件架构之前后端分离与前端模块化发展史","link":"https://segmentfault.com/a/1190000023735006","description":"<p>在现行的软件架构中，前端和后端是分离的，即前端只专注于页面渲染，而后台专注于业务逻辑，前端和后端是两个不同的工种，而前后端交互最常见的方式就是通过接口。</p>\n<h1>前后端分离架构</h1>\n<p>在正式说明前后台架构分离之前，我们来看一下多年之前，传统软件开发的架构模式。</p>\n<h2>为什么要前后端分离</h2>\n<p>还记得零几年我上大学的时候，在初学 Java Web 开发时，课本上介绍的还是 JSP + Servlet 这种很传统的架构模式，这时候前端和后端业务逻辑代码都在一个工程里面，还没有分离开来，这种开发模式属于 Model1 模式，虽然实现了逻辑功能和显示功能的分离，但是由于视图层和控制层都是由 JSP 页面实现的，即视图层和控制层并没有实现分离。</p>\n<p>随着学习的深入以及渐渐流行的企业应用开发，我们渐渐的摈弃这种技术选型，并开始在项目中使用了若干开源框架，常用的框架组合有 Spring +Struts/Spring MVC + Hibernate/Mybatis 等等，由于框架的优越性以及良好的封装性使得这套开发框架组合迅速成为各个企业开发中的不二之选，这些框架的出现也减少了开发者的重复编码工作，简化开发，加快开发进度，降低维护难度，随之而火热的是这套技术框架背后的开发模式，即 MVC 开发模式，它是为了克服 Model1 存在的不足而设计的。</p>\n<p>MVC 的具体含义是：Model + View + Controller，即模型+视图+控制器，</p>\n<ul>\n <li>Model 模型层： 它常常使用 JavaBean 来编写，它接受视图层请求的数据，然后进行相应的业务处理并返回最终的处理结果，它负担的责任最为核心，并利用 JavaBean 具有的特性实现了代码的重用和扩展以及给维护带来了方便。</li>\n <li>View 视图层： 代表和用户交互的界面，负责数据的采集和展示，通常由 JSP 实现。</li>\n <li>Controller 控制层： 控制层是从用户端接收请求，然后将请求传递给模型层并告诉模型层应该调用什么功能模块来处理该请求，它将协调视图层和模型层之间的工作，起到中间枢纽的作用，它一般交由 Servlet 来实现。</li>\n</ul>\n<p>MVC的工作流程如下图所示。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023735009\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"><br>同时，项目开发在进行模块分层时也会划分为三层：控制层，业务层，持久层。控制层负责接收参数，调用相关业务层，封装数据，以及路由并将数据渲染到 JSP 页面，然后在 JSP 页面中将后台的数据展现出来，相信大家对这种开发模式都十分熟悉，不管是企业开发或者是个人项目的搭建，这种开发模式都是大家的首选，不过，随着开发团队的扩大和项目架构的不断演进，这套开发模式渐渐有些力不从心。</br></img></p>\n<p>接下来，我们来分析下这套开发模式的痛点。</p>\n<h3>痛点一：JSP 效率问题</h3>\n<p>首先，JSP 必须要在 Servlet 容器中运行（例如 Tomcat，jetty 等），在请求 JSP 时也需要进行一次编译过程，最后被译成 Java 类和 class 文件，这些都会占用 PermGen 空间，同时也需要一个新的类加载器加载，JSP 技术与 Java 语言和 Servlet 有强关联，在解耦上无法与模板引擎或者纯 html 页面相媲美。其次每次请求 JSP 后得到的响应都是 Servlet 通过输出流输出的 html 页面，效率上也没有直接使用 html 高。由于 JSP 与 Servlet 容器的强关联，在项目优化时也无法直接使用 Nginx 作为 JSP 的 web 服务器，性能提升不高。</p>\n<h3>痛点二：人员分工不明</h3>\n<p>在这种开发模式下的工作流程通常是：设计人员给出页面原型设计后，前端工程师只负责将设计图切成 html 页面，之后则需要由后端开发工程师来将 html 转为 JSP 页面进行逻辑处理和数据展示。在这种工作模式下，人为出错率较高，后端开发人员任务更重，修改问题时需要双方协同开发，效率低下，一旦出现问题后，前端开发人员面对的是充满标签和表达式的 JSP 页面，后端人员在面对样式或者交互的问题时本就造诣不高的前端技术也会捉襟见肘。</p>\n<p>在某些紧急情况下也会出现前端人员调试后端代码，后端开发人员调试前端代码这些让人捧腹的现象，分工不明确，且沟通成本大，一旦某些功能需要返工则需要前后端开发人员，这种情况下，对于前后端人员的后期技术成长也不利，后端追求的是高并发、高可用、高性能、安全、架构优化等，前端追求的是模块化、组件整合、速度流畅、兼容性、用户体验等等，但是在 MVC 这种开发模式下显然会对这些技术人员都有一定的掣肘。</p>\n<h3>痛点三：不利于项目迭代</h3>\n<p>项目初期，为了快速上线应用，选择使用这种开发模式来进行 Java Web 项目的开发是非常正确的选择，此时流量不大，用户量也不高，并不会有非常苛刻的性能要求，但是随着项目的不断成长，用户量和请求压力也会不断扩大，对于互联网项目的性能要求是越来越高，如果此时的前后端模块依旧耦合在一起是非常不利于后续扩展的。举例说明一下，为了提高负载能力，我们会选择做集群来分担单个应用的压力，但是模块的耦合会使得性能的优化空间越来越低，因为单个项目会越来越大，不进行合理的拆分无法做到最好的优化，又或者在发版部署上线的时候，明明只改了后端的代码，前端也需要重新发布，或者明明只改了部分页面或者部分样式，后端代码也需要一起发布上线，这些都是耦合较严重时常见的不良现象，因此原始的前后端耦合在一起的架构模式已经逐渐不能满足项目的演进方向，需要需找一种解耦的方式替代当前的开发模式。</p>\n<h3>痛点四：不满足业务需求</h3>\n<p>随着公司业务的不断发展，仅仅只有浏览器端的 Web 应用已经逐渐显得有些不够用了，目前又是移动互联网急剧增长的时代，手机端的原生 App 应用已经非常成熟，随着 App 软件的大量普及越来越多的企业也加入到 App 软件开发当中来，为了尽可能的抢占商机和提升用户体验，你所在的公司可能也不会把所有的开发资源都放在 web 应用上，而是多端应用同时开发，此时公司的业务线可能就是如下的几种或者其中一部分：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023735010\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\" /></p>\n<p>浏览器端的 Web 应用、iOS 原生 App、安卓端原生 App、微信小程序等等，可能只是开发其中的一部分产品，但是除了 web 应用能够使用传统的 MVC 模式开发外，其他的都无法使用该模式进行开发，像原生 App 或者微信小程序都是通过调用 RESTful api 的方式与后端进行数据交互。</p>\n<p>随着互联网技术的发展，更多的技术框架被提了出来，其中最革命性的就是前后端分离概念的提出。</p>\n<h2>什么是前后端分离</h2>\n<p>何为前后端分离，我认为应该从以下几个方面来理解。</p>\n<h3>前后端分离是一种项目开发模式</h3>\n<p>当业务变得越来越复杂或者产品线越来越多，原有的开发模式已经无法满足业务需求，当端上的产品越来越多，展现层的变化越来越快、越来越多，此时就应该进行前后端分离分层抽象，简化数据获取过程，比如目前比较常用的就是前端人员自行实现跳转逻辑和页面交互，后端只负责提供接口数据，二者之间通过调用 RESTful api 的方式来进行数据交互，如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023735011\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"><br>此时就不会出现 HTML 代码需要转成 JSP 进行开发的情况，前端项目只负责前端部分，并不会掺杂任何后端代码，这样的话代码不再耦合。同时，前端项目与后端项目也不会再出现耦合严重的现象，只要前后端协商和定义好接口规范及数据交互规范，双方就可以并行开发，互不干扰，业务也不会耦合，两端只通过接口来进行交互。</br></img></p>\n<p>在 MVC 模式开发项目时，往往后端过重，“控制权”也比较大，既要负责处理业务逻辑、权限管理等后端操作，也需要处理页面跳转等逻辑，在前后端分离的模式中，后端由原来的大包大揽似的独裁者变成了接口提供者，而前端也不仅仅是原来那样仅处理小部分业务，页面跳转也不再由后端来处理和决定，整个项目的控制权已经由后端过渡至前端来掌控，前端需要处理的更多。</p>\n<p>前端项目和后端项目隔离开来、互不干涉，通过接口和数据规范来完成项目功能需求，这也是目前比较流行的一种开发方式。</p>\n<h3>前后端分离是一种人员分工</h3>\n<p>在前后端分离的架构模式下，后台负责数据提供，前端负责显示交互，在这种开发模式下，前端开发人员和后端开发人员分工明确，职责划分十分清晰，双方各司其职，不会存在边界不清晰的地方，并且从业人员也各司其职。</p>\n<p>前端开发人员包括 Web 开发人员、原生 App 开发人员，后端开发则是指 Java 开发人员(以 Java 语言为例)，不同的开发人员只需要注重自己所负责的项目即可。后端专注于控制层（RESTful API）、服务层 、数据访问层，前端专注于前端控制层、 视图层，不会再出现前端人员需要维护部分后端代码，或者后端开发人员需要去调试样式等等职责不清和前后端耦合的情况，我们通过两张项目开发流程简图来对比：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023735012\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"><br>此时，开发过程中会存在前后端耦合的情况，如果出现问题前端需要返工、后端也需要返工，开发效率会有所影响。现在，前后端分离后流程简图如下：</br></img></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023735013\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"><br>前后端分离后，服务器端开发人员和前端开发人员各干各的，大家互不干扰，。在设计完成后，Web 端开发人员、App 端开发人员、后端开发人员都可以投入到开发工作当中，能够做到并行开发，前端开发人员与后端开发人员职责分离，即使出现问题，也是修复各自的问题不会互相影响和耦合，开发效率高且满足企业对于多产品线的开发需求。</br></img></p>\n<h3>前后端分离是一种架构模式</h3>\n<p>前后端分离后，各端应用可以独立打包部署，并针对性的对部署方式进行优化，不再是前后端一个统一的工程最终打成一个部署包进行部署。以 Web 应用为例，前端项目部署后，不再依赖于 Servlet 容器，可以使用吞吐量更大的 Nginx 服务器，采用动静分离的部署方式，既提升了前端的访问体验，也减轻了后端服务器的压力，再进一步优化的话，可以使用页面缓存、浏览器缓存等设置，也可以使用 CDN 等产品提升静态资源的访问效率。对于后端服务而言，可以进行集群部署提升服务的响应效率，也可以进一步的进行服务化的拆分等等。前后端分离后的独立部署维护以及针对性的优化，可以加快整体响应速度和吞吐量。</p>\n<h1>前端发展历程</h1>\n<p>当我们去了解某个事物的时候，首先我们需要去了解它的历史，才能更好的把握它的未来。</p>\n<h2>原始时代</h2>\n<p>世界上第一款浏览器 NCSAMosaic ，是网景公司（Netscape）在1994年开发出来的，它的初衷是为了方便科研人员查阅资料、文档（这个时候的文档大多是图片形式的）。那个时代的每一个交互，按钮点击、表单提交，都需要等待浏览器响应很长时间，然后重新下载一个新页面。</p>\n<p>同年 PHP（超文本预处理器） 脚本语言被开发出来，开启了数据嵌入模板的 MVC 模式，同时期比较类似的做法有以下几种：</p>\n<ul>\n <li>PHP 直接将数据内嵌到 HTML 中。</li>\n <li>ASP 的 ASPX，在 HTML 中嵌入 C# 代码。</li>\n <li>Java 的 JSP 直接将数据嵌入到网页中。</li>\n</ul>\n<p>这个时期，浏览器的开发者，以后台开发人员居多，大部分前后端开发是一体的，大致开发流程是：后端收到浏览器的请求 ---&gt; 发送静态页面 ---&gt; 发送到浏览器。即使是有专门的前端开发，也只是用 HTML 写写页面模板、CSS 给页面排个好看点的版式。在这一时期，前端的作用有限，往往只是切图仔的角色。</p>\n<h2>铁器时代</h2>\n<p>1995年，网景公司的一位叫布兰登·艾奇的大佬，希望开发出一个类似 Java 的脚本语言，用来提升浏览器的展示效果，增强动态交互能力。结果大佬喝着啤酒抽着烟，十来天就把这个脚本语言写出来了，功能很强大，就是语法一点都不像 Java。这样就渐渐形成了前端的雏形：HTML 为骨架，CSS 为外貌，JavaScript 为交互。</p>\n<p>同时期微软等一些公司也针对自家浏览器开发出了自己的脚本语言。浏览器五花八门，虽然有了比较统一的 ECMA 标准，但是浏览器先于标准在市场上流行开来，成为了事实标准。导致，现在前端工程师还要在做一些政府古老项目的时候，还要去处理浏览器兼容（万恶的 IE 系列）。</p>\n<p>不管怎么说，前端开发也算是能写点逻辑代码了，不再是只能画画页面的低端开发了。随着1998年 AJax 的出现，前端开发从 Web1.0迈向了Web2.0，前端从纯内容的静态展示，发展到了动态网页，富交互，前端数据处理的新时期。这一时期，比较知名的两个富交互动态的浏览器产品是。</p>\n<ul>\n <li>Gmail（2004年）</li>\n <li>Google 地图（2005年）</li>\n</ul>\n<p>由于动态交互、数据交互的需求增多，还衍生出了jQuery（2006） 这样优秀的跨浏览器的 js 工具库，主要用于 DOM 操作，数据交互。有些古老的项目，甚至近几年开发的大型项目现在还在使用 jQuery，以至于 jQuery 库现在还在更新，虽然体量上已经远远不及 React、Vue 这些优秀的前端库。</p>\n<h2>信息时代</h2>\n<p>自 2003 以后，前端发展渡过了一段比较平稳的时期，各大浏览器厂商除了按部就班的更新自己的浏览器产品之外，没有再作妖搞点其他事情。但是我们程序员们耐不住寂寞啊，工业化推动了信息化的快速到来，浏览器呈现的数据量越来越大，网页动态交互的需求越来越多，JavaScript 通过操作 DOM 的弊端和瓶颈越来越明显（频繁的交互操作，导致页面会很卡顿），仅仅从代码层面去提升页面性能，变得越来越难。于是优秀的大佬们又干了点惊天动地的小事儿：</p>\n<ul>\n <li>2008 年，谷歌 V8 引擎发布，终结微软 IE 时代。</li>\n <li>2009 年 AngularJS 诞生、Node诞生。</li>\n <li>2011 年 ReactJS 诞生。</li>\n <li>2014 年 VueJS 诞生。</li>\n</ul>\n<p>其中，V8 和 Node.JS 的出现，使前端开发人员可以用熟悉的语法糖编写后台系统，为前端提供了使用同一语言的实现全栈开发的机会（JavaScript不再是一个被嘲笑只能写写页面交互的脚本语言）。React、Angular、Vue 等 MVVM 前端框架的出现，使前端实现了项目真正的应用化（SPA单页面应用），不再依赖后台开发人员处理页面路由 Controller，实现页面跳转的自我管理。同时也推动了前后端的彻底分离（前端项目独立部署，不再依赖类似的 template 文件目录）。</p>\n<p>至于为啥 MVVM 框架能提升前端的渲染性能，这里简单的说一下原理，因为大量的 DOM 操作是性能瓶颈的罪魁祸首，那通过一定的分析比较算法，实现同等效果下的最小 DOM 开销是可行的。React、Vue 这类框架大都是通过这类思想实现的，具体实现可以去看一下相关资料。前后端分离也导致前端的分工发生了一些变化。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023735014\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\" /></p>\n<p>而后端开发更加关注数据服务，前端则负责展示和交互。当然相应的学习成本也越来越大，Node.JS的出现也使得前端前后端一起开发成为可能，好多大公司在 2015 年前后就进行了尝试，用 Node.JS 作为中间数据转接层，让后端更加专注于数据服务和治理。</p>\n<h1>前端模块化发展历程</h1>\n<p>自 2009 年 5 月 Node.js 发布以来，前端能干的事情越来越多。短短 10 来年的时间，前端便从刀耕火种的年代走向了模块化、工程化的时代。各种前端框架百家争鸣，前端赢来了真正属于自己的时代。</p>\n<h2>原始时代</h2>\n<p>时间回到 2009年，记得那时候还没有流行前后端分离，很多项目还是混在一起，而那时候的前端开发人员大多数也都是“切图仔”。前端完成静态页面，由服务端同事完成数据的嵌入，也就是所谓的套页面操作，每当有类似的功能，都会回到之前的页面去复制粘贴，由于处于不同的页面，类名需要更换，但是换汤不换药。</p>\n<p>久而久之，重复代码越来越多，但凡改动一个小的地方，都需要改动很多代码，显得极不方便，也不利于大规模的进行工程化开发。虽然市面上也慢慢出现了 Angular、 Avalon 等优秀的前端框架，但是考虑到 SEO 和维护人员并不好招，很多公司还是选择求稳，用套页面的形式制作网页，这对前端的工程化、模块化是一个不小的阻碍。</p>\n<h2>构建工具的出现</h2>\n<p>不过，随着 Node 被大力推崇，市面上涌现出大量的构建工具，如 Npm Scripts、Grunt、Gulp、FIS、Webpack、Rollup、Parcel等等。构建工具解放了我们的双手，帮我们处理一些重复的机械劳动。</p>\n<p>举个简单的例子：我们用 ES6 写了一段代码，需要在浏览器执行。但是由于浏览器厂商对浏览器的更新非常保守，使得很多 ES6 的代码并不能直接在浏览器上运行。这个时候我们总不能手动将 ES6 代码改成 ES5 的代码。于是乎就有了下面的转换。</p>\n<pre><code>//编译前\n[1,2,3].map(item =&gt; console.log(item))\n//编译后\n[1, 2, 3].map(function (item) {\n  return console.log(item);\n});\n//代码压缩后\n[1,2,3].map(function(a){return console.log(a)});</code></pre>\n<p>就是做了上述的操作，才能使得我们在写前端代码的时候，使用最新的 ECMAScript 语法，并且尽可能的压缩代码的体积，使得浏览器加载静态脚本时能更加快速。</p>\n<h2>传统的模块化</h2>\n<p>随着 Ajax 的流行，前端工程师能做的事情就不只是“切图” 这么简单，现在前端工程师能做的越来越多，开始出现了明确的分工，并且能够与服务端工程师进行数据联调。这里说的传统模块化还不是后现代的模块化，早期的模块化是不借助任何工具的，纯属由 JavaScript 完成代码的结构化。在传统的模块化中我们主要是将一些能够复用的代码抽成公共方法，以便统一维护和管理，比如下面代码。</p>\n<pre><code>function show(id) {\n  document.getElementById(id).setAttribute('style', \"display: block\")\n}\nfunction hide(id) {\n  document.getElementById(id).setAttribute('style', \"display: none\")\n}</code></pre>\n<p>然后，我们将这些工具函数封装到一个 JS 脚本文件里，在需要使用它们的地方进行引入。</p>\n<pre><code>&lt;script scr=\"./utils.js\"&gt;&lt;/script&gt;</code></pre>\n<p>但是，这种做法会衍生出两个很大的问题，一个是全局变量的污染，另一个是人工维护模块之间的依赖关系会造成代码的混乱。</p>\n<p>例如，当我们的项目有十几个甚至几十个人维护的时候，难免会有人在公用组件中添加新的方法，比如 show 这个方法一旦被覆盖了，使用它的人会得到和预期不同的结果，这样就造成的全局变量的污染。另一个问题，因为真实项目中的公用脚本之间的依赖关系是比较复杂的，比如 c 脚本依赖 b 脚本，a 脚本依赖 b 脚本，那么我们在引入的时候就要注意必须要这样引入。</p>\n<pre><code>&lt;script scr=\"c.js\"&gt;&lt;/script&gt;\n&lt;script scr=\"b.js\"&gt;&lt;/script&gt;\n&lt;script scr=\"a.js\"&gt;&lt;/script&gt;</code></pre>\n<p>要这样引入才能保证 a 脚本的正常运行，否则就会报错。对于这类问题，我们该如何解决这样的问题呢？</p>\n<h3>全局变量的污染</h3>\n<p>解决这个问题有两种，先说说治标不治本的方法，我们通过团队规范开发文档，比如说我有个方法，是在购物车模块中使用的，可以如下书写。</p>\n<pre><code>var shop.cart.utils = {\n  show: function(id) {\n    document.getElementById(id).setAttribute('style', \"display: block\")\n  },\n  hide: function(id) {\n    document.getElementById(id).setAttribute('style', \"display: none\")\n  }\n}</code></pre>\n<p>这样就能比较有效的避开全局变量的污染，把方法写到对象里，再通过对象去调用。专业术语上这叫命名空间的规范，但是这样模块多了变量名会比较累赘，一写就是一长串，所以我叫它治标不治本。</p>\n<p>还有一种比较专业的方法技术通过立即执行函数完成闭包封装，为了解决封装内变量的问题，立即执行函数是个很好的办法，这也是早期很多开发正在使用的方式，如下所示。</p>\n<pre><code>(function() { \n   var Cart = Cart || {};\n   function show (id) {\n     document.getElementById(id).setAttribute('style', \"display: block\")\n   }\n   function hide (id) {\n     document.getElementById(id).setAttribute('style', \"display: none\")\n   }\n   Cart.Util = {\n     show: show,\n     hide: hide\n   }\n})();</code></pre>\n<p>上述代码，通过一个立即执行函数，给予了模块的独立作用域，同时通过全局变量配置了我们的模块，达到了模块化的目的。</p>\n<h2>当前的模块化方案</h2>\n<p>先来说说 CommonJS 规范，在 Node.JS 发布之后，CommonJS 模块化规范就被用在了项目开发中，它有几个概念给大家解释一下。</p>\n<ul>\n <li>每个文件都是一个模块，它都有属于自己的作用域，内部定义的变量、函数都是私有的，对外是不可见的；</li>\n <li>每个模块内部的 module 变量代表当前模块，这个变量是一个对象；</li>\n <li>module 的 exports 属性是对外的接口，加载某个模块其实就是在加载模块的 module.exports 属性；</li>\n <li>使用 require 关键字加载对应的模块，require 的基本功能就是读入并执行一个 JavaScript 文件，然后返回改模块的 exports 对象，如果没有的话会报错的；</li>\n</ul>\n<p>下面来看一下示例，我们就将上面提到过的代码通过 CommonJS 模块化。</p>\n<pre><code>module.exports = {\n  show: function (id) {\n    document.getElementById(id).setAttribute('style', \"display: block\")\n  },\n  hide: function (id) {\n    document.getElementById(id).setAttribute('style', \"display: none\")\n  }\n}\n// 也可以输出单个方法\nmodule.exports.show = function (id) {\n  document.getElementById(id).setAttribute('style', \"display: block\")\n}\n\n// 引入的方式\nvar utils = require('./utils')\n// 使用它\nutils.show(\"body\")</code></pre>\n<p>除了 CommonJS 规范外，还有几个现在只能在老项目里才能看到的模块化模式，比如以 require.js 为代表的 AMD（Asynchronous Module Definition） 规范 和 玉伯团队写的 sea.js 为代表的 CMD（Common Module Definition） 规范。<br>AMD 的特点：是一步加载模块，但是前提是一开始就要将所有的依赖项加载完全。CMD 的特点是：依赖延迟，在需要的时候才去加载。</br></p>\n<h3>AMD</h3>\n<p>首先，我们来看一下如何通过 AMD 规范的 require.js 书写上述模块化代码。</p>\n<pre><code>define(['home'], function(){\n  function show(id) {\n    document.getElementById(id).setAttribute('style', \"display: block\")\n  }\n    function hide(id) {\n    document.getElementById(id).setAttribute('style', \"display: none\")\n  }\n  return {\n    show: show,\n    hide: hide\n  };\n});\n\n// 加载模块\nrequire(['utils'], function (cart){\n　 cart.show('body');\n});</code></pre>\n<p>require.js 定义了一个函数 define，它是全局变量，用来定义模块，它的语法规范如下： </p>\n<p><strong>define(id, dependencies, factory)</strong></p>\n<ul>\n <li>id：它是可选参数，用于标识模块；</li>\n <li>dependencies：当前模块所依赖的模块名称数组，如上述模块依赖 home 模块，这就解决了之前说的模块之间依赖关系换乱的问题，通过这个参数可以将前置依赖模块加载进来；</li>\n <li>factory：模块初始化要执行的函数或对象。</li>\n</ul>\n<p><strong>require([dependencies], function(){})</strong></p>\n<p>然后，在其他文件中使用 require 进行引入，第一个参数为需要依赖的模块数组，第二个参数为一个回调函数，当前面的依赖模块被加载成功之后，回调函数会被执行，加载进来的模块将会以参数的形式传入函数内，以便进行其他操作。</p>\n<h3>CMD</h3>\n<p>sea.js 和 require.js 解决的问题其实是一样的，只是运行的机制不同，遵循的是就近依赖，来看下使用CMD方式实现的模块化代码。</p>\n<pre><code>define(function(require, exports, module) {\n  function show(id) {\n    document.getElementById(id).setAttribute('style', \"display: block\")\n  }\n  exports.show = show\n});\n\n&lt;script type=\"text/javascript\" src=\"sea.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\"&gt;\n  // 引入模块通过seajs.use，然后可以在回调函数内使用上面模块导出的方法\n  seajs.use('./utils.js',function (show) {\n        show('#box');\n  }); \n&lt;/script&gt;</code></pre>\n<p>首先是引入 sea.js 库，定义和导出模块分别是 define() 和 exports，可以在定义模块的时候通过 require 参数手动引入需要依赖的模块，使用模块通过 seajs.use。</p>\n<h3>ES6</h3>\n<p>ES6 提出了最新的模块化方案，并且引入了类的机制，让 JavaScript 从早期的表单验证脚本语言摇身一变成了一个面向对象的语言了。ES6 的模块化使用的是 import/export 关键字来实现导入和导出，并且自动采用的是严格模式（use strict），考虑到都是运行在模块之中，所以 ES6 实际上把整个语言都升到了严格模式。</p>\n<p>在 ES6 中每一个模块即是一个文件，在文件中定义变量、函数、对象在外部是无法获取的。如果想要获取模块内的内容，就必须使用 export 关键字来对其进行暴露。我们把之前的公用脚本用 ES6 的形式再重构一遍。</p>\n<pre><code>// utils.js\nconst show = () =&gt; {\n  document.getElementById(id).setAttribute('style', 'display: block');\n}\nconst hide = () =&gt; {\n  document.getElementById(id).setAttribute('style', 'display: none');\n}\n\nexport {\n    show,\n  hide\n}\n// 或者直接抛出方法\nexport const show = (id) =&gt; {\n  document.getElementById(id).setAttribute('style', 'display: block');\n}\nexport const hide = (id) =&gt; {\n  document.getElementById(id).setAttribute('style', 'display: none');\n}\n\n// 外部引入模块\nimport { show, hide } from './utils'</code></pre>\n<p>可以发现，ES6 的写法更加清晰。具备了面向对象和面向函数的特征，可读性更强。</p>","descriptionType":"html","publishedDate":"Mon, 24 Aug 2020 02:15:44 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023735009","linkMd5":"83e2007305092901a28598ddbadd1356","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn18@2020_4/2020/08/24/23-08-23-811_c3c6f2a2a3fccaba.webp","destWidth":800,"destHeight":290,"sourceBytes":36632,"destBytes":9762,"author":"xiangzhihong","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023735009":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn18@2020_4/2020/08/24/23-08-23-811_c3c6f2a2a3fccaba.webp","https://segmentfault.com/img/remote/1460000023735010":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn30@2020_2/2020/08/24/23-08-33-394_30a2866aebb9679b.webp","https://segmentfault.com/img/remote/1460000023735011":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn25@2020_3/2020/08/24/23-08-33-283_8449a79cab74d294.webp","https://segmentfault.com/img/remote/1460000023735012":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn22@2020_6/2020/08/24/23-08-33-580_0ee43b08f5e73b73.webp","https://segmentfault.com/img/remote/1460000023735013":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn18@2020_2/2020/08/24/23-08-33-574_ca64795440519632.webp","https://segmentfault.com/img/remote/1460000023735014":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn13@2020_6/2020/08/24/23-08-33-616_a24995aea600c1a0.webp"},"publishedOrCreatedDate":1598310388562},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"前端工程师不可不知的Nginx知识","link":"https://segmentfault.com/a/1190000023730234","description":"<p><img src=\"https://segmentfault.com/img/bVbLJtP\" alt=\"image\" title=\"image\" /></p>\n<p><strong>观感度：🌟🌟🌟🌟🌟</strong></p>\n<p><strong>口味：虎皮鸡蛋</strong></p>\n<p><strong>烹饪时间：10min</strong></p>\n<blockquote>\n 本文已收录在前端食堂同名仓库\n <code>Github</code> \n <a href=\"https://github.com/Geekhyt/front-end-canteen\" rel=\"nofollow noreferrer\">github.com/Geekhyt</a>，欢迎光临食堂，如果觉得酒菜还算可口，赏个 Star 对食堂老板来说是莫大的鼓励。\n</blockquote>\n<h2>历史背景</h2>\n<p>互联网的全球化导致了互联网的数据量快速增长，加上在本世纪初摩尔定律在单核 CPU 上的失效，CPU 朝着多核方向发展，而 Apache 显然并没有做好多核架构的准备，它的一个进程同一时间只能处理一个连接，处理完一个请求后才能处理下一个，这无疑不能应对如今互联网上海量的用户。况且进程间切换的成本是非常高的。在这种背景下，Nginx 应运而生，可以轻松处理数百万、上千万的连接。</p>\n<h2>Nginx 优势</h2>\n<ul>\n <li>高并发高性能</li>\n <li>可扩展性好</li>\n <li>高可靠性</li>\n <li>热部署</li>\n <li>开源许可证</li>\n</ul>\n<h2>Nginx 主要应用场景</h2>\n<ul>\n <li>静态资源服务，通过本地文件系统提供服务</li>\n <li>反向代理服务、负载均衡</li>\n <li>API服务、权限控制，减少应用服务器压力</li>\n</ul>\n<h2>Nginx 配置文件和目录</h2>\n<p>通过 <code>rpm -ql nginx</code> 可以查看 Nginx 安装的配置文件和目录。</p>\n<p>如图是我在某某云上安装的最新稳定版本的Nginx的配置文件及目录。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023730237\" alt=\"\" title=\"\" /></p>\n<ul>\n <li>/etc/nginx/nginx.conf 核心配置文件</li>\n <li>/etc/nginx/conf.d/default.conf 默认http服务器配置文件</li>\n <li>/etc/nginx/fastcgi_params fastcgi配置</li>\n <li>/etc/nginx/scgi_params scgi配置</li>\n <li>/etc/nginx/uwsgi_params uwsgi配置</li>\n <li>/etc/nginx/koi-utf</li>\n <li>/etc/nginx/koi-win</li>\n <li>/etc/nginx/win-utf 这三个文件是编码映射文件，因为作者是俄国人</li>\n <li>/etc/nginx/mime.types 设置HTTP协议的Content-Type与扩展名对应关系的文件</li>\n <li>/usr/lib/systemd/system/nginx-debug.service</li>\n <li>/usr/lib/systemd/system/nginx.service</li>\n <li>/etc/sysconfig/nginx</li>\n <li>/etc/sysconfig/nginx-debug 这四个文件是用来配置守护进程管理的</li>\n <li>/etc/nginx/modules 基本共享库和内核模块</li>\n <li>/usr/share/doc/nginx-1.18.0 帮助文档</li>\n <li>/usr/share/doc/nginx-1.18.0/COPYRIGHT 版权声明</li>\n <li>/usr/share/man/man8/nginx.8.gz 手册</li>\n <li>/var/cache/nginx Nginx的缓存目录</li>\n <li>/var/log/nginx Nginx的日志目录</li>\n <li>/usr/sbin/nginx 可执行命令</li>\n <li>/usr/sbin/nginx-debug 调试执行可执行命令</li>\n</ul>\n<p>关于 Nginx 的常用命令以及配置文件语法很容易就可以搜到，本文不作赘述，下面从 Nginx 的功能以及实际场景出发看一看各个场景下 Nginx 可以提供给我们哪些配置项。在此之前，我们先来明确两个概念：</p>\n<h2>正向代理 Forward proxy</h2>\n<p>一句话解释正向代理，正向代理的对象是客户端，服务器端看不到真正的客户端。<br><img src=\"https://segmentfault.com/img/remote/1460000023730238\" alt=\"\" title=\"\" /></br></p>\n<pre><code>resolver 8.8.8.8 # 谷歌的域名解析地址\nserver {\n    location / {\n      # 当客户端请求我的时候，我会把请求转发给它\n      # $http_host 要访问的主机名 $request_uri 请求路径\n      proxy_pass http://$http_host$request_uri;\n    }\n}</code></pre>\n<h2>反向代理 Reverse proxy</h2>\n<p>一句话解释反向代理，反向代理的对象是服务端，客户端看不到真正的服务端。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023730240\" alt=\"\" title=\"\" /></p>\n<h2>跨域</h2>\n<p>跨域是前端工程师都会面临的场景，跨域的解决方案有很多。不过要知道在生产中，要么使用 CORS 、要么使用 Nginx 反向代理来解决跨域。在 Nginx 的配置文件中进行如下配置即可：</p>\n<pre><code>server {\n    listen   80;\n    server_name   localhost; # 用户访问 localhost，反向代理到 http://webcanteen.com\n    location / {\n        proxy_pass http://webcanteen.com\n    }\n}</code></pre>\n<h2>Gzip</h2>\n<p>Gzip 是互联网上非常普遍的一种数据压缩格式，对于纯文本来说可以压缩到原大小的 40%，可以节省大量的带宽。不过需要注意的是，启用 Gzip 所需的 HTTP 最低版本是 1.1。</p>\n<pre><code>location ~ .*\\. (jpg|png|gif)$ {\n    gzip off; #关闭压缩\n    root /data/www/images;\n}\nlocation ~ .*\\. (html|js|css)$ {\n    gzip on; #启用压缩\n    gzip_min_length 1k; # 超过1K的文件才压缩\n    gzip_http_version 1.1; # 启用gzip压缩所需的HTTP最低版本\n    gzip_comp_level 9; # 压缩级别，压缩比率越高，文件被压缩的体积越小\n    gzip_types text/css application/javascript; # 进行压缩的文件类型\n    root /data/www/html;\n}</code></pre>\n<h2>请求限制</h2>\n<p>对于大流量恶意的访问，会造成带宽的浪费，给服务器增加压力。往往对于同一 IP 的连接数以及并发数进行限制。</p>\n<p>关于请求限制主要有两种类型：</p>\n<ul>\n <li>limit_conn_module 连接频率限制</li>\n <li>limit_req_module 请求频率限制</li>\n</ul>\n<pre><code># $binary_remote_addr 远程IP地址 zone 区域名称 10m内存区域大小\nlimit_conn_zone $binary_remote_addr zone=coon_zone:10m;\nserver {\n    # conn_zone 设置对应的共享内存区域 1是限制的数量\n    limit_conn conn_zone 1;\n}</code></pre>\n<pre><code># $binary_remote_addr 远程IP地址 zone 区域名称 10m内存区域大小 rate 为请求频率 1s 一次\nlimit_req_zone $binary_remote_addr zone=req_zone:10m rate=1r/s;\nserver {\n    location / {\n        # 设置对应的共享内存区域 burst最大请求数阈值 nodelay不希望超过的请求被延迟\n        limit_req zone=req_zone burst=5 nodelay;\n    }\n}</code></pre>\n<h2>访问控制</h2>\n<p>关于访问控制主要有两种类型：</p>\n<ul>\n <li>-http_access_module 基于 IP 的访问控制</li>\n <li>-http_auth_basic_module 基于用户的信任登陆</li>\n</ul>\n<p>(基于用户的信任登陆不是很安全，本文不做配置介绍)</p>\n<p>以下是基于 IP 的访问控制：</p>\n<pre><code>server {\n    location ~ ^/index.html {\n        # 匹配 index.html 页面 除了 127.0.0.1 以外都可以访问\n        deny 127.0.0.1;\n        allow all;\n    }\n}</code></pre>\n<h2>ab命令</h2>\n<p>ab命令全称为：Apache bench，是 Apache 自带的压力测试工具，也可以测试 Nginx、IIS 等其他 Web 服务器。</p>\n<ul>\n <li>-n 总共的请求数</li>\n <li>-c 并发的请求数</li>\n</ul>\n<pre><code>ab -n 1000 -c 5000 http://127.0.0.1/</code></pre>\n<h2>防盗链</h2>\n<p>防盗链的原理就是根据请求头中 referer 得到网页来源，从而实现访问控制。这样可以防止网站资源被非法盗用，从而保证信息安全，减少带宽损耗，减轻服务器压力。</p>\n<pre><code>location ~ .*\\.(jpg|png|gif)$ { # 匹配防盗链资源的文件类型\n    # 通过 valid_referers 定义合法的地址白名单 $invalid_referer 不合法的返回403  \n    valid_referers none blocked 127.0.0.1;\n    if ($invalid_referer) {\n        return 403;\n    }\n}</code></pre>\n<h2>负载均衡 Load Balance</h2>\n<p>当我们的网站需要解决高并发、海量数据问题时，就需要使用负载均衡来调度服务器。将请求合理的分发到应用服务器集群中的一台台服务器上。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023730239\" alt=\"\" title=\"\" /></p>\n<p>Nginx 可以为我们提供负载均衡的能力，具体配置如下：</p>\n<pre><code># upstream 指定后端服务器地址\n# weight 设置权重\n# server 中会将 http://webcanteen 的请求转发到 upstream 池中\nupstream webcanteen {\n    server 127.0.0.1:66 weight=10;\n    server 127.0.0.1:77 weight=1;\n    server 127.0.0.1:88 weight=1;\n}\nserver {\n    location / {\n        proxy_pass http://webcanteen\n    }\n}</code></pre>\n<h3>后端服务器状态</h3>\n<p>后端服务器支持以下的状态配置：</p>\n<ul>\n <li>down：当前服务器不参与负载均衡</li>\n <li>backup：当其他节点都无法使用时的备用服务器</li>\n <li>max_fails：允许请求失败的次数，若到达就会休眠</li>\n <li>fail_timeout：经过max_fails次失败后，服务器的暂停时间，默认为10s</li>\n <li>max_conns：限制每个服务器的最大接收连接数</li>\n</ul>\n<pre><code>upstream webcanteen {\n    server 127.0.0.1:66 down;\n    server 127.0.0.1:77 backup;\n    server 127.0.0.1:88  max_fails=3 fail_timeout=10s;\n    server 127.0.0.1:99 max_conns=1000;\n}</code></pre>\n<h3>分配方式</h3>\n<ul>\n <li>轮询(默认），每个请求按照时间顺序轮流分配到不同的后端服务器，如果某台后端服务器宕机，Nginx 轮询列表会自动将它去除掉。</li>\n <li>weight(加权轮询)，轮询的加强版，weight 和访问几率成正比，主要用于后端服务器性能不均的场景。</li>\n <li>ip_hash，每个请求按照访问 IP 的 hash 结果分配，这样每个访问可以固定访问一个后端服务器。</li>\n <li>url_hash，按照访问 URL 的 hash 结果来分配请求，使得每个URL定向到同一个后端服务器上，主要应用于后端服务器为缓存时的场景。</li>\n <li>自定义hash，基于任意关键字作为 hash key 实现 hash 算法的负载均衡</li>\n <li>fair，按照后端服务器的响应时间来分配请求，响应时间短则优先分配。</li>\n</ul>","descriptionType":"html","publishedDate":"Sun, 23 Aug 2020 08:21:43 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLJtP","linkMd5":"3c5ab7837e45f9183c9783494075346a","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn86@2020_1/2020/08/24/23-08-23-023_4f776d9d8dfa05aa.webp","destWidth":800,"destHeight":340,"sourceBytes":93089,"destBytes":25484,"author":"童欧巴","articleImgCdnMap":{"https://segmentfault.com/img/bVbLJtP":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn86@2020_1/2020/08/24/23-08-23-023_4f776d9d8dfa05aa.webp","https://segmentfault.com/img/remote/1460000023730237":null,"https://segmentfault.com/img/remote/1460000023730238":null,"https://segmentfault.com/img/remote/1460000023730240":null,"https://segmentfault.com/img/remote/1460000023730239":null},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"利用 React 高阶组件实现一个面包屑导航","link":"https://segmentfault.com/a/1190000023711464","description":"<h2>什么是 React 高阶组件</h2>\n<p>React 高阶组件就是以高阶函数的方式包裹需要修饰的 React 组件，并返回处理完成后的 React 组件。React 高阶组件在 React 生态中使用的非常频繁，比如<code>react-router</code> 中的 <code>withRouter</code> 以及 <code>react-redux</code> 中 <code>connect</code> 等许多 API 都是以这样的方式来实现的。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>使用 React 高阶组件的好处</h2>\n<p>在工作中，我们经常会有很多功能相似，组件代码重复的页面需求，通常我们可以通过完全复制一遍代码的方式实现功能，但是这样页面的维护可维护性就会变得极差，需要对每一个页面里的相同组件去做更改。因此，我们可以将其中共同的部分，比如接受相同的查询操作结果、组件外同一的标签包裹等抽离出来，做一个单独的函数，并传入不同的业务组件作为子组件参数，而这个函数不会修改子组件，只是通过组合的方式将子组件包装在容器组件中，是一个无副作用的纯函数，从而我们能够在不改变这些组件逻辑的情况下将这部分代码解耦，提升代码可维护性。</p>\n<h2>自己动手实现一个高阶组件</h2>\n<p>前端项目里，带链接指向的面包屑导航十分常用，但由于面包屑导航需要手动维护一个所有目录路径与目录名映射的数组，而这里所有的数据我们都能从 <code>react-router</code> 的路由表中取得，因此我们可以从这里入手，实现一个面包屑导航的高阶组件。</p>\n<p>首先我们看看我们的路由表提供的数据以及目标面包屑组件所需要的数据：</p>\n<pre><code class=\"js\">// 这里展示的是 react-router4 的route示例\nlet routes = [\n  {\n    breadcrumb: '一级目录',\n    path: '/a',\n    component: require('../a/index.js').default,\n    items: [\n      {\n        breadcrumb: '二级目录',\n        path: '/a/b',\n        component: require('../a/b/index.js').default,\n        items: [\n          {\n            breadcrumb: '三级目录1',\n            path: '/a/b/c1',\n            component: require('../a/b/c1/index.js').default,\n            exact: true,\n          },\n          {\n            breadcrumb: '三级目录2',\n            path: '/a/b/c2',\n            component: require('../a/b/c2/index.js').default,\n            exact: true,\n          },\n      }\n    ]\n  }\n]\n\n// 理想中的面包屑组件\n// 展示格式为 a / b / c1 并都附上链接\nconst BreadcrumbsComponent = ({ breadcrumbs }) =&gt; (\n  &lt;div&gt;\n    {breadcrumbs.map((breadcrumb, index) =&gt; (\n      &lt;span key={breadcrumb.props.path}&gt;\n        &lt;link to={breadcrumb.props.path}&gt;{breadcrumb}&lt;/link&gt;\n        {index &lt; breadcrumbs.length - 1 &amp;&amp; &lt;i&gt; / &lt;/i&gt;}\n      &lt;/span&gt;\n    ))}\n  &lt;/div&gt;\n);</code></pre>\n<p>这里我们可以看到，面包屑组件需要提供的数据一共有三种，一种是当前页面的路径，一种是面包屑所带的文字，一种是该面包屑的导航链接指向。</p>\n<p>其中第一种我们可以通过 react-router 提供的 withRouter 高阶组件包裹，可使子组件获取到当前页面的 location 属性，从而获取页面路径。</p>\n<p>后两种需要我们对 routes 进行操作，首先将 routes 提供的数据扁平化成面包屑导航需要的格式，我们可以使用一个函数来实现它。</p>\n<pre><code class=\"js\">/**\n * 以递归的方式展平react router数组\n */\nconst flattenRoutes = arr =&gt;\n  arr.reduce(function(prev, item) {\n    prev.push(item);\n    return prev.concat(\n      Array.isArray(item.items) ? flattenRoutes(item.items) : item\n    );\n  }, []);</code></pre>\n<p>之后将展平的目录路径映射与当前页面路径一同放入处理函数，生成面包屑导航结构。</p>\n<pre><code class=\"js\">export const getBreadcrumbs = ({ flattenRoutes, location }) =&gt; {\n  // 初始化匹配数组match\n  let matches = [];\n\n  location.pathname\n    // 取得路径名，然后将路径分割成每一路由部分.\n    .split('?')[0]\n    .split('/')\n    // 对每一部分执行一次调用`getBreadcrumb()`的reduce.\n    .reduce((prev, curSection) =&gt; {\n      // 将最后一个路由部分与当前部分合并，比如当路径为 `/x/xx/xxx` 时，pathSection分别检查 `/x` `/x/xx` `/x/xx/xxx` 的匹配，并分别生成面包屑\n      const pathSection = `${prev}/${curSection}`;\n      const breadcrumb = getBreadcrumb({\n        flattenRoutes,\n        curSection,\n        pathSection,\n      });\n\n      // 将面包屑导入到matches数组中\n      matches.push(breadcrumb);\n\n      // 传递给下一次reduce的路径部分\n      return pathSection;\n    });\n  return matches;\n};</code></pre>\n<p>然后对于每一个面包屑路径部分，生成目录名称并附上指向对应路由位置的链接属性。</p>\n<pre><code class=\"js\">const getBreadcrumb = ({ flattenRoutes, curSection, pathSection }) =&gt; {\n  const matchRoute = flattenRoutes.find(ele =&gt; {\n    const { breadcrumb, path } = ele;\n    if (!breadcrumb || !path) {\n      throw new Error(\n        'Router中的每一个route必须包含 `path` 以及 `breadcrumb` 属性'\n      );\n    }\n    // 查找是否有匹配\n    // exact 为 react router4 的属性，用于精确匹配路由\n    return matchPath(pathSection, { path, exact: true });\n  });\n\n  // 返回breadcrumb的值，没有就返回原匹配子路径名\n  if (matchRoute) {\n    return render({\n      content: matchRoute.breadcrumb || curSection,\n      path: matchRoute.path,\n    });\n  }\n\n  // 对于routes表中不存在的路径\n  // 根目录默认名称为首页.\n  return render({\n    content: pathSection === '/' ? '首页' : curSection,\n    path: pathSection,\n  });\n};</code></pre>\n<p>之后由 render 函数生成最后的单个面包屑导航样式。单个面包屑组件需要为 render 函数提供该面包屑指向的路径 <code>path</code>, 以及该面包屑内容映射<code>content</code> 这两个 props。</p>\n<pre><code class=\"js\">/**\n *\n */\nconst render = ({ content, path }) =&gt; {\n  const componentProps = { path };\n  if (typeof content === 'function') {\n    return &lt;content {...componentProps} /&gt;;\n  }\n  return &lt;span {...componentProps}&gt;{content}&lt;/span&gt;;\n};</code></pre>\n<p>有了这些功能函数，我们就能实现一个能为包裹组件传入当前所在路径以及路由属性的 React 高阶组件了。传入一个组件，返回一个新的相同的组件结构，这样便不会对组件外的任何功能与操作造成破坏。</p>\n<pre><code class=\"js\">const BreadcrumbsHoc = (\n  location = window.location,\n  routes = []\n) =&gt; Component =&gt; {\n  const BreadComponent = (\n    &lt;Component\n      breadcrumbs={getBreadcrumbs({\n        flattenRoutes: flattenRoutes(routes),\n        location,\n      })}\n    /&gt;\n  );\n  return BreadComponent;\n};\nexport default BreadcrumbsHoc;</code></pre>\n<p>调用这个高阶组件的方法也非常简单，只需要传入当前所在路径以及整个 <code>react router</code> 生成的 <code>routes</code> 属性即可。<br>至于如何取得当前所在路径，我们可以利用 <code>react router</code> 提供的 <code>withRouter</code> 函数，如何使用请自行查阅相关文档。<br>值得一提的是，<code>withRouter</code> 本身就是一个高阶组件，能为包裹组件提供包括 <code>location</code> 属性在内的若干路由属性。所以这个 API 也能作为学习高阶组件一个很好的参考。</br></br></p>\n<pre><code class=\"js\">withRouter(({ location }) =&gt;\n  BreadcrumbsHoc(location, routes)(BreadcrumbsComponent)\n);</code></pre>\n<h2>Q&amp;A</h2>\n<p>如果<code>react router</code> 生成的 <code>routes</code> 不是由自己手动维护的，甚至都没有存在本地，而是通过请求拉取到的，存储在 redux 里，通过 <code>react-redux</code> 提供的 <code>connect</code> 高阶函数包裹时，路由发生变化时并不会导致该面包屑组件更新。使用方法如下：</p>\n<pre><code class=\"js\">function mapStateToProps(state) {\n  return {\n    routes: state.routes,\n  };\n}\n\nconnect(mapStateToProps)(\n  withRouter(({ location }) =&gt;\n    BreadcrumbsHoc(location, routes)(BreadcrumbsComponent)\n  )\n);</code></pre>\n<hr>\n <p>这其实是 <code>connect</code> 函数的一个<strong>bug</strong>。因为 react-redux 的 connect 高阶组件会为传入的参数组件实现 shouldComponentUpdate 这个钩子函数，导致<strong>只有 prop 发生变化时才触发更新相关的生命周期函数(含 render)</strong>，而很显然，我们的 location 对象并没有作为 prop 传入该参数组件。</p>\n <p>官方推荐的做法是使用 <code>withRouter</code> 来包裹 <code>connect</code> 的 <code>return value</code>，即</p>\n <pre><code class=\"js\">withRouter(\n  connect(mapStateToProps)(({ location, routes }) =&gt;\n    BreadcrumbsHoc(location, routes)(BreadcrumbsComponent)\n  )\n);</code></pre>\n <p>其实我们从这里也可以看出，高阶组件同高阶函数一样，不会对组件的类型造成任何更改，因此高阶组件就如同链式调用一样，可以任意多层包裹来给组件传入不同的属性，在正常情况下也可以随意调换位置，在使用上非常的灵活。这种可插拔特性使得高阶组件非常受 React 生态的青睐，很多开源库里都能看到这种特性的影子，有空也可以都拿出来分析一下。</p>\n</hr>","descriptionType":"html","publishedDate":"Fri, 21 Aug 2020 04:01:27 +0000","feedId":6615,"bgimg":"","linkMd5":"e6a36f891c6a4db5ca1ed8ca47403e3f","bgimgJsdelivr":"","metaImg":"","author":"Duang","publishedOrCreatedDate":1598310388559},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"谁动了我的 DOM？","link":"https://segmentfault.com/a/1190000023707760","description":"<p>在某些场景下，我们希望能监视 DOM 树的变动，然后做一些相关的操作。比如监听元素被插入 DOM 或从 DOM 树中移除，然后添加相应的动画效果。或者在富文本编辑器中输入特殊的符号，如 <code>#</code> 或 <code>@</code> 符号时自动高亮后面的内容等。要实现这些功能，我们就可以考虑使用 MutationObserver API，接下来阿宝哥将带大家一起来探索 MutationObserver API 所提供的强大能力。</p>\n<p>阅读完本文，你将了解以下内容：</p>\n<ul>\n <li>MutationObserver 是什么；</li>\n <li>MutationObserver API 的基本使用及 MutationRecord 对象；</li>\n <li>MutationObserver API 常见的使用场景；</li>\n <li>什么是观察者设计模式及如何使用 TS 实现观察者设计模式。</li>\n</ul>\n<h3>一、MutationObserver 是什么</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver\" rel=\"nofollow noreferrer\">MutationObserver</a> 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。</p>\n<p>利用 MutationObserver API 我们可以监视 DOM 的变化。DOM 的任何变化，比如节点的增加、减少、属性的变动、文本内容的变动，通过这个 API 我们都可以得到通知。</p>\n<p>MutationObserver 有以下特点：</p>\n<ul>\n <li>它等待所有脚本任务执行完成后，才会运行，它是异步触发的。即会等待当前所有 DOM 操作都结束才触发，这样设计是为了应对 DOM 频繁变动的问题。</li>\n <li>它把 DOM 变动记录封装成一个数组进行统一处理，而不是一条一条进行处理。</li>\n <li>它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。</li>\n</ul>\n<h3>二、MutationObserver API 简介</h3>\n<p>在介绍 MutationObserver API 之前，我们先来了解一下它的兼容性：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023707764\" alt=\"\" title=\"\" /></p>\n<p>（图片来源：<a href=\"https://caniuse.com/#search=MutationObserver\" rel=\"nofollow noreferrer\">https://caniuse.com/#search=M...</a>）</p>\n<p>从上图可知，目前主流的 Web 浏览器基本都支持 MutationObserver API，而对于 IE 浏览器只有 IE 11 才支持。在项目中，如需要使用 MutationObserver API，首先我们需要创建 MutationObserver 对象，因此接下来我们来介绍 MutationObserver 构造函数。</p>\n<p>DOM 规范中的 MutationObserver 构造函数，用于创建并返回一个新的观察器，它会在触发指定 DOM 事件时，调用指定的回调函数。MutationObserver 对 DOM 的观察不会立即启动，而必须先调用 <code>observe()</code> 方法来指定所要观察的 DOM 节点以及要响应哪些更改。</p>\n<h4>2.1 构造函数</h4>\n<p>MutationObserver 构造函数的语法为：</p>\n<pre><code class=\"javascript\">const observer = new MutationObserver(callback);</code></pre>\n<p>相关的参数说明如下：</p>\n<ul>\n <li>callback：一个回调函数，每当被指定的节点或子树有发生 DOM 变动时会被调用。该回调函数包含两个参数：一个是描述所有被触发改动的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord\" rel=\"nofollow noreferrer\">MutationRecord</a> 对象数组，另一个是调用该函数的 MutationObserver 对象。</li>\n</ul>\n<p><strong>使用示例</strong></p>\n<pre><code class=\"typescript\">const observer = new MutationObserver(function (mutations, observer) {\n  mutations.forEach(function(mutation) {\n    console.log(mutation);\n  });\n});</code></pre>\n<h4>2.2 方法</h4>\n<ul>\n <li>disconnect()：阻止 MutationObserver 实例继续接收通知，除非再次调用其 observe() 方法，否则该观察者对象包含的回调函数都不会再被调用。</li>\n <li><p>observe(target[, options])：该方法用来启动监听，它接受两个参数。第一个参数，用于指定所要观察的 DOM 节点。第二个参数，是一个配置对象，用于指定所要观察的特定变动。</p><pre><code class=\"javascript\">const editor = document.querySelector('#editor');\n\nconst options = {\n  childList: true, // 监视node直接子节点的变动\n  subtree: true, // 监视node所有后代的变动\n  attributes: true, // 监视node属性的变动\n  characterData: true, // 监视指定目标节点或子节点树中节点所包含的字符数据的变化。\n  attributeOldValue: true // 记录任何有改动的属性的旧值\n};\n\nobserver.observe(article, options);</code></pre></li>\n <li>takeRecords()：返回已检测到但尚未由观察者的回调函数处理的所有匹配 DOM 更改的列表，使变更队列保持为空。此方法最常见的使用场景是 <strong>在断开观察者之前立即获取所有未处理的更改记录，以便在停止观察者时可以处理任何未处理的更改</strong>。</li>\n</ul>\n<h4>2.3 MutationRecord 对象</h4>\n<p>DOM 每次发生变化，就会生成一条变动记录，即 MutationRecord 实例。该实例包含了与变动相关的所有信息。Mutation Observer 对象处理的就是一个个 <strong>MutationRecord</strong> 实例所组成的数组。</p>\n<p>MutationRecord 实例包含了变动相关的信息，含有以下属性：</p>\n<ul>\n <li>type：变动的类型，值可以是 attributes、characterData 或 childList；</li>\n <li>target：发生变动的 DOM 节点；</li>\n <li>addedNodes：返回新增的 DOM 节点，如果没有节点被添加，则返回一个空的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList\" rel=\"nofollow noreferrer\">NodeList</a>；</li>\n <li>removedNodes：返回移除的 DOM 节点，如果没有节点被移除，则返回一个空的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList\" rel=\"nofollow noreferrer\">NodeList</a>；</li>\n <li>previousSibling：返回被添加或移除的节点之前的兄弟节点，如果没有则返回 <code>null</code>；</li>\n <li>nextSibling：返回被添加或移除的节点之后的兄弟节点，如果没有则返回 <code>null</code>；</li>\n <li>attributeName：返回被修改的属性的属性名，如果设置了 <code>attributeFilter</code>，则只返回预先指定的属性；</li>\n <li>attributeNamespace：返回被修改属性的命名空间；</li>\n <li>oldValue：变动前的值。这个属性只对 <code>attribute</code> 和 <code>characterData</code> 变动有效，如果发生 <code>childList</code> 变动，则返回 <code>null</code>。</li>\n</ul>\n<h4>2.4 MutationObserver 使用示例</h4>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh-CN\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;DOM 变动观察器示例&lt;/title&gt;\n    &lt;style&gt;\n      .editor {border: 1px dashed grey; width: 400px; height: 300px;}\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h3&gt;阿宝哥：DOM 变动观察器（Mutation observer）&lt;/h3&gt;\n    &lt;div contenteditable id=\"container\" class=\"editor\"&gt;大家好，我是阿宝哥！&lt;/div&gt;\n\n    &lt;script&gt;\n      const containerEle = document.querySelector(\"#container\");\n\n      let observer = new MutationObserver((mutationRecords) =&gt; {\n        console.log(mutationRecords); // 输出变动记录\n      });\n\n      observer.observe(containerEle, {\n        subtree: true, // 监视node所有后代的变动\n        characterDataOldValue: true, // 记录任何有变动的属性的旧值\n      });\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>以上代码成功运行之后，阿宝哥对 id 为 <strong>container</strong> 的 div 容器中原始内容进行修改，即把 <strong>大家好，我是阿宝哥！</strong> 修改为 <strong>大家好，我</strong>。对于上述的修改，控制台将会输出 5 条变动记录，这里我们来看一下最后一条变动记录：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023707763\" alt=\"\" title=\"\" /></p>\n<p>MutationObserver 对象的 <code>observe(target [, options])</code> 方法支持很多配置项，这里阿宝哥就不详细展开介绍了。</p>\n<p>但是为了让刚接触 MutationObserver API 的小伙伴能更直观的感受每个配置项的作用，阿宝哥把 <a href=\"https://www.smashingmagazine.com/2019/04/mutationobserver-api-guide/\" rel=\"nofollow noreferrer\">mutationobserver-api-guide</a> 这篇文章中使用的在线示例统一提取出来，做了一下汇总与分类：</p>\n<blockquote>\n 1、\n <a href=\"https://codepen.io/impressivewebs/pen/aXVVjg\" rel=\"nofollow noreferrer\">MutationObserver Example - childList</a>：\n <a href=\"https://codepen.io/impressivewebs/pen/aXVVjg\" rel=\"nofollow noreferrer\">https://codepen.io/impressive...</a>\n <p>2、<a href=\"https://codepen.io/impressivewebs/pen/PVgyLa\" rel=\"nofollow noreferrer\">MutationObserver Example - childList with subtree</a>：<a href=\"https://codepen.io/impressivewebs/pen/PVgyLa\" rel=\"nofollow noreferrer\">https://codepen.io/impressive...</a></p>\n <p>3、<a href=\"https://codepen.io/impressivewebs/pen/XOzaWv\" rel=\"nofollow noreferrer\">MutationObserver Example - Attributes</a>：<a href=\"https://codepen.io/impressivewebs/pen/XOzaWv\" rel=\"nofollow noreferrer\">https://codepen.io/impressive...</a></p>\n <p>4、<a href=\"https://codepen.io/impressivewebs/pen/pGGdVr\" rel=\"nofollow noreferrer\">MutationObserver Example - Attribute Filter</a>：<a href=\"https://codepen.io/impressivewebs/pen/pGGdVr\" rel=\"nofollow noreferrer\">https://codepen.io/impressive...</a></p>\n <p>5、<a href=\"https://codepen.io/impressivewebs/pen/ywYaYv\" rel=\"nofollow noreferrer\">MutationObserver Example - attributeFilter with subtree</a>：<a href=\"https://codepen.io/impressivewebs/pen/ywYaYv\" rel=\"nofollow noreferrer\">https://codepen.io/impressive...</a></p>\n <p>6、<a href=\"https://codepen.io/impressivewebs/pen/pGdpvq\" rel=\"nofollow noreferrer\">MutationObserver Example - characterData</a>：<a href=\"https://codepen.io/impressivewebs/pen/pGdpvq\" rel=\"nofollow noreferrer\">https://codepen.io/impressive...</a></p>\n <p>7、<a href=\"https://codepen.io/impressivewebs/pen/bZVpMZ\" rel=\"nofollow noreferrer\">MutationObserver Example - characterData with subtree</a>：<a href=\"https://codepen.io/impressivewebs/pen/bZVpMZ\" rel=\"nofollow noreferrer\">https://codepen.io/impressive...</a></p>\n <p>8、<a href=\"https://codepen.io/impressivewebs/pen/wNNjrP\" rel=\"nofollow noreferrer\">MutationObserver Example - Recording an Old Attribute Value</a>：<a href=\"https://codepen.io/impressivewebs/pen/wNNjrP\" rel=\"nofollow noreferrer\">https://codepen.io/impressive...</a></p>\n <p>9、<a href=\"https://codepen.io/impressivewebs/pen/aXrzex\" rel=\"nofollow noreferrer\">MutationObserver Example - Recording old characterData</a>：<a href=\"https://codepen.io/impressivewebs/pen/aXrzex\" rel=\"nofollow noreferrer\">https://codepen.io/impressive...</a></p>\n <p>10、<a href=\"https://codepen.io/impressivewebs/pen/OqJMeG\" rel=\"nofollow noreferrer\">MutationObserver Example - Multiple Changes for a Single Observer</a>：<a href=\"https://codepen.io/impressivewebs/pen/OqJMeG\" rel=\"nofollow noreferrer\">https://codepen.io/impressive...</a></p>\n <p>11、<a href=\"https://codepen.io/impressivewebs/pen/GeRWPX\" rel=\"nofollow noreferrer\">MutationObserver Example - Moving a Node Tree</a>：<a href=\"https://codepen.io/impressivewebs/pen/GeRWPX\" rel=\"nofollow noreferrer\">https://codepen.io/impressive...</a></p>\n</blockquote>\n<h3>三、MutationObserver 使用场景</h3>\n<h4>3.1 语法高亮</h4>\n<p>相信大家对语法高亮都不会陌生，平时在阅读各类技术文章时，都会遇到它。接下来，阿宝哥将跟大家介绍如何使用 MutationObserver API 和 <a href=\"https://prismjs.com/\" rel=\"nofollow noreferrer\">Prism.js</a> 这个库实现 JavaScript 和 CSS 语法高亮。</p>\n<p>在看具体的实现代码前，我们先来看一下以下 HTML 代码段未语法高亮和语法高亮的区别：</p>\n<pre><code class=\"javascript\">let htmlSnippet = `下面是一个JavaScript代码段：\n    &lt;pre class=\"language-javascript\"&gt;\n       &lt;code&gt; let greeting = \"大家好，我是阿宝哥\"; &lt;/code&gt;\n    &lt;/pre&gt;\n    &lt;div&gt;另一个CSS代码段：&lt;/div&gt;\n       &lt;div&gt;\n         &lt;pre class=\"language-css\"&gt;\n            &lt;code&gt;#code-container { border: 1px dashed grey; padding: 5px; } &lt;/code&gt;\n         &lt;/pre&gt;\n    &lt;/div&gt;\n`</code></pre>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023707766\" alt=\"\" title=\"\" /></p>\n<p>通过观察上图，我们可以很直观地发现，有进行语法高亮的代码块阅读起来更加清晰易懂。下面我们来看一下实现语法高亮的功能代码：</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh-CN\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;MutationObserver 实战之语法高亮&lt;/title&gt;\n    &lt;style&gt;\n      #code-container {\n        border: 1px dashed grey;\n        padding: 5px;\n        width: 550px;\n        height: 200px;\n      }\n    &lt;/style&gt;\n    &lt;link href=\"https://cdn.bootcdn.net/ajax/libs/prism/9000.0.1/themes/prism.min.css\" rel=\"stylesheet\"&gt;\n    &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/prism/9000.0.1/prism.min.js\" data-manual&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/prism/9000.0.1/components/prism-javascript.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/prism/9000.0.1/components/prism-css.min.js\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h3&gt;阿宝哥：MutationObserver 实战之语法高亮&lt;/h3&gt;\n    &lt;div id=\"code-container\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n      let observer = new MutationObserver((mutations) =&gt; {\n        for (let mutation of mutations) {\n          // 获取新增的DOM节点\n          for (let node of mutation.addedNodes) {\n            // 只处理HTML元素，跳过其他节点，比如文本节点\n            if (!(node instanceof HTMLElement)) continue;\n\n            // 检查插入的节点是否为代码段\n            if (node.matches('pre[class*=\"language-\"]')) {\n              Prism.highlightElement(node);\n            }\n\n            // 检查插入节点的子节点是否为代码段\n            for (let elem of node.querySelectorAll('pre[class*=\"language-\"]')) {\n              Prism.highlightElement(elem);\n            }\n          }\n        }\n      });\n\n      let codeContainer = document.querySelector(\"#code-container\");\n\n      observer.observe(codeContainer, { childList: true, subtree: true });\n      // 动态插入带有代码段的内容\n      codeContainer.innerHTML = `下面是一个JavaScript代码段：\n        &lt;pre class=\"language-javascript\"&gt;&lt;code&gt; let greeting = \"大家好，我是阿宝哥\"; &lt;/code&gt;&lt;/pre&gt;\n        &lt;div&gt;另一个CSS代码段：&lt;/div&gt;\n        &lt;div&gt;\n          &lt;pre class=\"language-css\"&gt;\n             &lt;code&gt;#code-container { border: 1px dashed grey; padding: 5px; } &lt;/code&gt;\n          &lt;/pre&gt;\n        &lt;/div&gt;\n        `;\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>在以上代码中，首先我们在引入 <strong>prism.min.js</strong> 的 script 标签上设置 <code>data-manual</code> 属性，用于告诉 <a href=\"https://prismjs.com/\" rel=\"nofollow noreferrer\">Prism.js</a> 我们将使用手动模式来处理语法高亮。接着我们在回调函数中通过获取 mutation 对象的 <code>addedNodes</code> 属性来进一步获取新增的 DOM 节点。然后我们遍历新增的 DOM 节点，判断新增的 DOM 节点是否为代码段，如果满足条件的话则进行高亮操作。</p>\n<p>此外，除了判断当前节点之外，我们也会判断插入节点的子节点是否为代码段，如果满足条件的话，也会进行高亮操作。</p>\n<h4>3.2 监听元素的 load 或 unload 事件</h4>\n<p>对 Web 开发者来说，相信很多人对 <code>load</code> 事件都不会陌生。当整个页面及所有依赖资源如样式表和图片都已完成加载时，将会触发 <code>load</code> 事件。而当文档或一个子资源正在被卸载时，会触发 <code>unload</code> 事件。</p>\n<p>在日常开发过程中，除了监听页面的加载和卸载事件之外，我们经常还需要监听 DOM 节点的插入和移除事件。比如当 DOM 节点插入 DOM 树中产生插入动画，而当节点从 DOM 树中被移除时产生移除动画。针对这种场景我们就可以利用 MutationObserver API 来监听元素的添加与移除。</p>\n<p>同样，在看具体的实现代码前，我们先来看一下实际的效果：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023707765\" alt=\"\" title=\"\" /></p>\n<p>在以上示例中，当点击 <strong>跟踪元素生命周期</strong> 按钮时，一个新的 <strong>DIV</strong> 元素会被插入到 body 中，成功插入后，会在消息框显示相关的信息。在 <strong>3S</strong> 之后，新增的 <strong>DIV</strong> 元素会从 DOM 中移除，成功移除后，会在消息框中显示 <strong>元素已从DOM中移除了</strong> 的信息。</p>\n<p>下面我们来看一下具体实现：</p>\n<p><strong>index.html</strong></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh-CN\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;MutationObserver load/unload 事件&lt;/title&gt;\n    &lt;link\n      rel=\"stylesheet\"\n      href=\"https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.0.0/animate.min.css\"\n    /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h3&gt;阿宝哥：MutationObserver load/unload 事件&lt;/h3&gt;\n    &lt;div class=\"block\"&gt;\n      &lt;p&gt;\n        &lt;button onclick=\"trackElementLifecycle()\"&gt;跟踪元素生命周期&lt;/button&gt;\n      &lt;/p&gt;\n      &lt;textarea id=\"messageContainer\" rows=\"5\" cols=\"50\"&gt;&lt;/textarea&gt;\n    &lt;/div&gt;\n    &lt;script src=\"./on-load.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n      const busy = false;\n      const messageContainer = document.querySelector(\"#messageContainer\");\n\n      function trackElementLifecycle() {\n        if (busy) return;\n        const div = document.createElement(\"div\");\n        div.innerText = \"我是新增的DIV元素\";\n        div.classList.add(\"animate__animated\", \"animate__bounceInDown\");\n        watchElement(div);\n        document.body.appendChild(div);\n      }\n\n      function watchElement(element) {\n        onload(\n          element,\n          function (el) {\n            messageContainer.value = \"元素已被添加到DOM中, 3s后将被移除\";\n            setTimeout(() =&gt; document.body.removeChild(el), 3000);\n          },\n          function (el) {\n            messageContainer.value = \"元素已从DOM中移除了\";\n          }\n        );\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p><strong>on-load.js</strong></p>\n<pre><code class=\"javascript\">// 只包含部分代码\nconst watch = Object.create(null);\nconst KEY_ID = \"onloadid\" + Math.random().toString(36).slice(2);\nconst KEY_ATTR = \"data-\" + KEY_ID;\nlet INDEX = 0;\n\nif (window &amp;&amp; window.MutationObserver) {\n  const observer = new MutationObserver(function (mutations) {\n    if (Object.keys(watch).length &lt; 1) return;\n    for (let i = 0; i &lt; mutations.length; i++) {\n      if (mutations[i].attributeName === KEY_ATTR) {\n        eachAttr(mutations[i], turnon, turnoff);\n        continue;\n      }\n      eachMutation(mutations[i].removedNodes, function (index, el) {\n        if (!document.documentElement.contains(el)) turnoff(index, el);\n      });\n      eachMutation(mutations[i].addedNodes, function (index, el) {\n        if (document.documentElement.contains(el)) turnon(index, el);\n      });\n    }\n  });\n\n  observer.observe(document.documentElement, {\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeOldValue: true,\n    attributeFilter: [KEY_ATTR],\n  });\n}\n\nfunction onload(el, on, off, caller) {\n  on = on || function () {};\n  off = off || function () {};\n  el.setAttribute(KEY_ATTR, \"o\" + INDEX);\n  watch[\"o\" + INDEX] = [on, off, 0, caller || onload.caller];\n  INDEX += 1;\n  return el;\n}</code></pre>\n<blockquote>\n on-load.js 的完整代码：\n <a href=\"https://gist.github.com/semlinker/a149763bf033d7f2dff2d32d60c27865\" rel=\"nofollow noreferrer\">https://gist.github.com/semli...</a>\n</blockquote>\n<h4>3.3 富文本编辑器</h4>\n<p>除了前面两个应用场景，在富文本编辑器的场景，MutationObserver API 也有它的用武之地。比如我们希望在富文本编辑器中高亮 <code>#</code> 符号后的内容，这时候我们就可以通过 MutationObserver API 来监听用户输入的内容，发现用户输入 <code>#</code> 时自动对输入的内容进行高亮处理。</p>\n<p>这里阿宝哥基于 <a href=\"https://github.com/mitsuyacider/vue-hashtag-textarea\" rel=\"nofollow noreferrer\">vue-hashtag-textarea</a> 这个项目来演示一下上述的效果：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023707768\" alt=\"\" title=\"\" /></p>\n<p>此外，MutationObserver API 在 Github 上的一个名为 <a href=\"https://github.com/codex-team/editor.js\" rel=\"nofollow noreferrer\">Editor.js</a> 的项目中也有应用。Editor.js 是一个 <strong>Block-Styled</strong> 编辑器，以 JSON 格式输出数据的富文本和媒体编辑器。它是完全模块化的，由 “块” 组成，这意味着每个结构单元都是它自己的块（例如段落、标题、图像都是块），用户可以轻松地编写自己的插件来进一步扩展编辑器。 </p>\n<p>在 Editor.js 编辑器内部，它通过 MutationObserver API 来监听富文本框的内容异动，然后触发 change 事件，使得外部可以对变动进行响应和处理。上述的功能被封装到内部的 <a href=\"https://github.com/codex-team/editor.js/blob/63eeec0f3b3e05025c6f2875a1eb2a4c03a24c8c/src/components/modules/modificationsObserver.ts\" rel=\"nofollow noreferrer\">modificationsObserver.ts</a> 模块，感兴趣的小伙伴可以阅读 <a href=\"https://github.com/codex-team/editor.js/blob/63eeec0f3b3e05025c6f2875a1eb2a4c03a24c8c/src/components/modules/modificationsObserver.ts\" rel=\"nofollow noreferrer\">modificationsObserver.ts</a> 模块的代码。</p>\n<p>当然利用 MutationObserver API 提供的强大能力，我们还可以有其他的应用场景，比如防止页面的水印元素被删除，从而避免无法跟踪到 “泄密” 者，当然这并不是绝对的安全，只是多加了一层防护措施。具体如何实现水印元素被删除，篇幅有限。这里阿宝哥不继续展开介绍了，大家可以参考掘金上 <a href=\"https://juejin.im/post/6844904167618641927\" rel=\"nofollow noreferrer\">“打开控制台也删不掉的元素，前端都吓尿了”</a> 这一篇文章。</p>\n<p>至此 MutationObserver 变动观察者相关内容已经介绍完了，既然讲到观察者，阿宝哥情不自禁想再介绍一下观察者设计模式。</p>\n<h3>四、观察者设计模式</h3>\n<h4>4.1 简介</h4>\n<p><strong>观察者模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</strong></p>\n<p>我们可以使用日常生活中，期刊订阅的例子来形象地解释一下上面的概念。期刊订阅包含两个主要的角色：期刊出版方和订阅者，他们之间的关系如下：</p>\n<ul>\n <li>期刊出版方 —— 负责期刊的出版和发行工作。</li>\n <li>订阅者 —— 只需执行订阅操作，新版的期刊发布后，就会主动收到通知，如果取消订阅，以后就不会再收到通知。</li>\n</ul>\n<p>在观察者模式中也有两个主要角色：Subject（主题）和 Observer（观察者），它们分别对应例子中的期刊出版方和订阅者。接下来我们来看张图，进一步加深对以上概念的理解。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023707767\" alt=\"\" title=\"\" /></p>\n<h4>4.2 模式结构</h4>\n<p>观察者模式包含以下角色：</p>\n<ul>\n <li>Subject：主题类</li>\n <li>Observer：观察者</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023707769\" alt=\"\" title=\"\" /></p>\n<h4>4.3 观察者模式实战</h4>\n<h5>4.3.1 定义 Observer 接口</h5>\n<pre><code class=\"typescript\">interface Observer {\n  notify: Function;\n}</code></pre>\n<h5>4.3.2 创建 ConcreteObserver 观察者实现类</h5>\n<pre><code class=\"typescript\">class ConcreteObserver implements Observer{\n    constructor(private name: string) {}\n\n    notify() {\n      console.log(`${this.name} has been notified.`);\n    }\n}</code></pre>\n<h5>4.3.3 创建 Subject 类</h5>\n<pre><code class=\"typescript\">class Subject { \n    private observers: Observer[] = [];\n\n    public addObserver(observer: Observer): void {\n      console.log(observer, \"is pushed!\");\n      this.observers.push(observer);\n    }\n\n    public deleteObserver(observer: Observer): void {\n      console.log(\"remove\", observer);\n      const n: number = this.observers.indexOf(observer);\n      n != -1 &amp;&amp; this.observers.splice(n, 1);\n    }\n\n    public notifyObservers(): void {\n      console.log(\"notify all the observers\", this.observers);\n      this.observers.forEach(observer =&gt; observer.notify());\n    }\n}</code></pre>\n<h5>4.3.4 使用示例</h5>\n<pre><code class=\"typescript\">const subject: Subject = new Subject();\nconst semlinker = new ConcreteObserver(\"semlinker\");\nconst kaquqo = new ConcreteObserver(\"kakuqo\");\nsubject.addObserver(semlinker);\nsubject.addObserver(kaquqo);\nsubject.notifyObservers();\n\nsubject.deleteObserver(kaquqo);\nsubject.notifyObservers();</code></pre>\n<p>以上代码成功运行后，控制台会输出以下结果：</p>\n<pre><code>[LOG]: { \"name\": \"semlinker\" },  is pushed! \n[LOG]: { \"name\": \"kakuqo\" },  is pushed! \n[LOG]: notify all the observers,  [ { \"name\": \"semlinker\" }, { \"name\": \"kakuqo\" } ] \n[LOG]: semlinker has been notified. \n[LOG]: kakuqo has been notified. \n[LOG]: remove,  { \"name\": \"kakuqo\" } \n[LOG]: notify all the observers,  [ { \"name\": \"semlinker\" } ] \n[LOG]: semlinker has been notified. </code></pre>\n<p>通过观察以上的输出结果，当观察者被移除以后，后续的通知就接收不到了。观察者模式支持简单的广播通信，能够自动通知所有已经订阅过的对象。<strong>但如果一个被观察者对象有很多的观察者的话，将所有的观察者都通知到会花费很多时间。</strong> 所以在实际项目中使用的话，大家需要注意以上的问题。</p>\n<h3>五、参考资源</h3>\n<ul>\n <li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver\" rel=\"nofollow noreferrer\">MDN - MutationObserver</a></li>\n <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord\" rel=\"nofollow noreferrer\">MDN - MutationRecord</a></li>\n <li><a href=\"https://javascript.ruanyifeng.com/dom/mutationobserver.html\" rel=\"nofollow noreferrer\">JavaScript 标准参考教程 - MutationObserver</a></li>\n <li><a href=\"https://www.smashingmagazine.com/2019/04/mutationobserver-api-guide/\" rel=\"nofollow noreferrer\">mutationobserver-api-guide</a></li>\n <li><a href=\"https://zh.javascript.info/mutation-observer\" rel=\"nofollow noreferrer\">javascript.info-mutation-observer</a></li>\n</ul>\n<h3>六、推荐阅读</h3>\n<ul>\n <li><a href=\"http://www.semlinker.com/ts-quickstart-2020/\" rel=\"nofollow noreferrer\">了不起的 TypeScript 入门教程</a></li>\n <li><a href=\"http://www.semlinker.com/deno-quickstart/\" rel=\"nofollow noreferrer\">了不起的 Deno 入门篇</a></li>\n <li><a href=\"http://www.semlinker.com/deno-in-action/\" rel=\"nofollow noreferrer\">了不起的 Deno 实战教程</a></li>\n <li><a href=\"http://www.semlinker.com/you-dont-know-blob/\" rel=\"nofollow noreferrer\">你不知道的 Blob</a></li>\n <li><a href=\"http://www.semlinker.com/you-dont-know-weakmap/\" rel=\"nofollow noreferrer\">你不知道的 WeakMap</a></li>\n</ul>","descriptionType":"html","publishedDate":"Fri, 21 Aug 2020 00:56:51 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023707764","linkMd5":"0efc7a62efcc894fd0f116660993cd89","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn37@2020_5/2020/08/24/23-08-22-393_74b3a8806a1a5203.webp","destWidth":800,"destHeight":139,"sourceBytes":63134,"destBytes":18322,"author":"阿宝哥","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023707764":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn37@2020_5/2020/08/24/23-08-22-393_74b3a8806a1a5203.webp","https://segmentfault.com/img/remote/1460000023707763":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn2@2020_4/2020/08/24/23-08-28-672_28796882d7b84489.webp","https://segmentfault.com/img/remote/1460000023707766":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn98@2020_5/2020/08/24/23-08-28-778_597d7f470508ef42.webp","https://segmentfault.com/img/remote/1460000023707765":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn81@2020_4/2020/08/24/23-08-28-749_fbb1b3d44d3ddb63.webp","https://segmentfault.com/img/remote/1460000023707768":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn45@2020_2/2020/08/24/23-08-28-692_d2d8d27bbfe59f0d.webp","https://segmentfault.com/img/remote/1460000023707767":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn90@2020_5/2020/08/24/23-08-28-638_bfa3d2edabd96c89.webp","https://segmentfault.com/img/remote/1460000023707769":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn33@2020_5/2020/08/24/23-08-28-835_72ecbead9d15c7c3.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"Tomcat 高并发之道与性能调优","link":"https://segmentfault.com/a/1190000023657729","description":"<blockquote>\n 上帝视角拆解 Tomcat 架构设计，在了解整个组件设计思路之后。我们需要下凡深入了解每个组件的细节实现。从远到近，架构给人以宏观思维，细节展现饱满的美。关注「码哥字节」获取更多硬核，你，准备好了么？\n</blockquote>\n<p>上回「码哥字节」站在上帝视角给大家拆解了 Tomcat 架构设计，分析 Tomcat 如何实现启动、停止，通过设计连接池与容器两大组件完成了一个请求的接受与响应。<strong>连接器负责对外交流，处理 socket 连接，容器对内负责，加载 Servlet 以及处理具体 Request 请求与响应</strong>。<a href=\"https://mp.weixin.qq.com/s/fU5Jj9tQvNTjRiT9grm6RA\" rel=\"nofollow noreferrer\">详情点我进入传输门：Tomcat 架构解析到工作借鉴</a>。</p>\n<h2>高并发拆解核心准备</h2>\n<p>这回，再次拆解，<strong>专注 Tomcat 高并发设计之道与性能调优</strong>，让大家对整个架构有更高层次的了解与感悟。其中设计的每个组件思路都是将 Java 面向对象、面向接口、如何封装变与不变，如何根据实际需求抽象不同组件分工合作，如何设计类实现单一职责，怎么做到将相似功能高内聚低耦合，设计模式运用到极致的学习借鉴。</p>\n<p>这次主要涉及到的是 I/O 模型，以及线程池的基础内容。</p>\n<p>在学习之前，希望大家积累以下一些技术内容，很多内容「码哥字节」也在历史文章中分享过。大家可爬楼回顾……。<strong>希望大家重视如下几个知识点，在掌握以下知识点再来拆解 Tomcat，就会事半功倍，否则很容易迷失方向不得其法</strong>。</p>\n<p>一起来看 Tomcat 如何实现并发连接处理以及任务处理，性能的优化是每一个组件都起到对应的作用，如何使用最少的内存，最快的速度执行是我们的目标。</p>\n<h3>设计模式</h3>\n<p><a href=\"https://mp.weixin.qq.com/s/AVfEy9fMRHhESKnfRERynw\" rel=\"nofollow noreferrer\">模板方法模式</a>： 抽象算法流程在抽象类中，封装流程中的变化与不变点。将变化点延迟到子类实现，达到代码复用，开闭原则。</p>\n<p><a href=\"https://mp.weixin.qq.com/s/7FL-m75fOctUVAMI_YgIww\" rel=\"nofollow noreferrer\">观察者模式</a>：针对事件不同组件有不同响应机制的需求场景，达到解耦灵活通知下游。</p>\n<p><a href=\"https://mp.weixin.qq.com/s/Ar_FZ6ck_WEjr9ia9bjmcQ\" rel=\"nofollow noreferrer\">责任链模式</a>：将对象连接成一条链，将沿着这条链传递请求。在 Tomcat 中的 Valve 就是该设计模式的运用。</p>\n<p>更多设计模式可查看「码哥字节」之前的设计模式专辑，这里是<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3NDkwMjAyOQ==&amp;action=getalbum&amp;album_id=1351452628844363777&amp;subscene=159&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FAr_FZ6ck_WEjr9ia9bjmcQ#wechat_redirect\" rel=\"nofollow noreferrer\">传送门</a>。</p>\n<h3>I/O 模型</h3>\n<p>Tomcat 实现高并发接收连接，必然涉及到 I/O 模型的运用，了解同步阻塞、异步阻塞、I/O 多路复用，异步非阻塞相关概念以及 Java NIO 包的运用很有必要。本文也会带大家着重说明 I/O 是如何在 Tomcat 运用实现高并发连接。大家通过本文我相信对 I/O 模型也会有一个深刻认识。</p>\n<h3>Java 并发编程</h3>\n<p>实现高并发，除了整体每个组件的优雅设计、设计模式的合理、I/O 的运用，还需要线程模型，如何高效的并发编程技巧。在高并发过程中，不可避免的会出现多个线程对共享变量的访问，需要加锁实现，如何高效的降低锁冲突。因此作为程序员，要有意识的尽量避免锁的使用，比如可以使用原子类 CAS 或者并发集合来代替。如果万不得已需要用到锁，也要尽量缩小锁的范围和锁的强度。</p>\n<p>对于并发相关的基础知识，如果读者感兴趣「码哥字节」后面也给大家安排上，目前也写了部分并发专辑，大家可移步到历史文章或者专辑翻阅，这里是<a href=\"http://mp.weixin.qq.com/mp/homepage?__biz=MzU3NDkwMjAyOQ==&amp;hid=7&amp;sn=660e8728f9eb24248cc7953796dbe773&amp;scene=18#wechat_redirect\" rel=\"nofollow noreferrer\">传送门</a>，主要讲解了并发实现的原理、什么是内存可见性，JMM 内存模模型、读写锁等并发知识点。</p>\n<h2>Tomcat 总体架构</h2>\n<p>再次回顾下 Tomcat 整体架构设计，主要设计了 <strong>connector 连接器</strong>处理 TCP/IP 连接，<strong>container 容器</strong>作为 Servlet 容器，处理具体的业务请求。对外对内分别抽象两个组件实现拓展。</p>\n<ul>\n <li>一个 Tomcat 实例默认会有一个 Service，而一个 Service 可以包含多个连接器。连接器主要有 ProtocalHandler 和 Adapter 两个组件共同完成连接器核心功能。</li>\n <li><code>ProtocolHandler</code> 主要由 <code>Acceptor</code> 以及 <code>SocketProcessor</code> 构成，实现了 TCP/IP 层 的 Socket 读取并转换成 <code>TomcatRequest</code> 和 <code>TomcatResponse</code>，最后根据 http 或者 ajp 协议获取合适的 <code>Processor</code> 解析为应用层协议，并通过 Adapter 将 TomcatRequest、TomcatResponse 转化成 标准的 ServletRequest、ServletResponse。通过 <code>getAdapter().service(request, response);</code>将请求传递到 Container 容器。</li>\n <li>adapter.service()实现将请求转发到容器 <code>org.apache.catalina.connector.CoyoteAdapter</code></li>\n</ul>\n<pre><code class=\"java\">// Calling the container\nconnector.getService().getContainer().getPipeline().getFirst().invoke(\n                        request, response);</code></pre>\n<p>这个调用会触发 getPipeline 构成的责任链模式将请求一步步走入容器内部，每个容器都有一条 Pipeline，通过 First 开始到 Basic 结束并进入容器内部持有的子类容器，最后到 Servlet，这里就是责任链模式的经典运用。具体的源码组件是 Pipeline 构成一条请求链，每一个链点由 Valve 组成。「码哥字节」在上一篇<a href=\"https://mp.weixin.qq.com/s/fU5Jj9tQvNTjRiT9grm6RA\" rel=\"nofollow noreferrer\">Tomcat 架构解析到工作借鉴</a> 已经详细讲解。如下图所示，整个 Tomcat 的架构设计重要组件清晰可见，希望大家将这个全局架构图深深印在脑海里，掌握全局思路才能更好地分析细节之美。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023657732\" alt=\"Tomcat 架构\" title=\"Tomcat 架构\" /></p>\n<h3>启动流程：startup.sh 脚本到底发生了什么</h3>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023657733\" alt=\"Tomcat 启动流程\" title=\"Tomcat 启动流程\" /></p>\n<ul>\n <li>Tomcat 本生就是一个 Java 程序，所以 startup.sh 脚本就是启动一个 JVM 来运行 Tomcat 的启动类 Bootstrap。</li>\n <li>Bootstrap 主要就是实例化 Catalina 和初始化 Tomcat 自定义的类加载器。热加载与热部署就是靠他实现。</li>\n <li>Catalina: 解析 server.xml 创建 Server 组件，并且调用 Server.start() 方法。</li>\n <li>Server：管理 Service 组件，调用 Server 的 start() 方法。</li>\n <li>Service：主要职责就是管理简介器的顶层容器 Engine，分别调用 <code>Connector</code> 和 <code>Engine</code> 的 <code>start</code> 方法。</li>\n</ul>\n<p>Engine 容器主要就是组合模式将各个容器根据父子关系关联，并且 Container 容器继承了 Lifecycle 实现各个容器的初始化与启动。Lifecycle 定义了 <code>init()、start()、stop()</code> 控制整个容器组件的生命周期实现一键启停。</p>\n<p><strong>这里就是一个面向接口、单一职责的设计思想</strong> ，Container 利用组合模式管理容器，LifecycleBase 抽象类继承 Lifecycle 将各大容器生命周期统一管理这里便是，而实现初始化与启动的过程又 LifecycleBase 运用了<a href=\"https://mp.weixin.qq.com/s/AVfEy9fMRHhESKnfRERynw\" rel=\"nofollow noreferrer\">模板方法</a>设计模式抽象出组件变化与不变的点，将不同组件的初始化延迟到具体子类实现。并且利用观察者模式发布启动事件解耦。</p>\n<p>具体的 init 与 start 流程如下泳道图所示：这是我在阅读源码 debug 所做的笔记，读者朋友们<strong>不要怕笔记花费时间长，自己跟着 debug 慢慢记录，相信会有更深的感悟</strong>。</p>\n<p><strong>init 流程</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023657734\" alt=\"Tomcat Init\" title=\"Tomcat Init\" /></p>\n<p><strong>start 流程</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023657735\" alt=\"Tomcat start\" title=\"Tomcat start\" /></p>\n<p>读者朋友根据我的两篇内容，抓住主线组件去 debug，然后跟着该泳道图阅读源码，我相信都会有所收获，并且事半功倍。在读源码的过程中，切勿进入某个细节，一定要先把各个组件抽象出来，了解每个组件的职责即可。最后在了解每个组件的职责与设计哲学之后再深入理解每个组件的实现细节，千万不要一开始就想着深入理解具体一篇叶子。</p>\n<p>每个核心类我在架构设计图以及泳道图都标识出来了，「码哥字节」给大家分享下如何高效阅读源码，以及保持学习兴趣的心得体会。</p>\n<h3>如何正确阅读源码</h3>\n<p>切勿陷入细节，不看全局：<strong>我还没弄清楚森林长啥样，就盯着叶子看</strong> ，看不到全貌和整体设计思路。所以阅读源码学习的时候不要一开始就进入细节，而是宏观看待整体架构设计思想，模块之间的关系。</p>\n<p><strong>1.阅读源码之前，需要有一定的技术储备</strong></p>\n<p>比如常用的设计模式，这个必须掌握，尤其是：<strong>模板方法、策略模式、单例、工厂、观察者、动态代理、适配器、责任链、装饰器。</strong>大家可以看 「码哥字节」关于设计模式的历史文章，打造好的基础。</p>\n<p><strong>2.必须会使用这个框架/类库，精通各种变通用法</strong></p>\n<p>魔鬼都在细节中，如果有些用法根本不知道，可能你能看明白代码是什么意思，但是不知道它为什么这些写。</p>\n<p><strong>3.先去找书，找资料，了解这个软件的整体设计。</strong></p>\n<p>从全局的视角去看待，上帝视角理出主要核心架构设计，先森林后树叶。都有哪些模块？ 模块之间是怎么关联的？怎么关联的？</p>\n<p>可能一下子理解不了，但是要建立一个整体的概念，就像一个地图，防止你迷航。</p>\n<p>在读源码的时候可以时不时看看自己在什么地方。就像「码哥字节」给大家梳理好了 Tomcat 相关架构设计，然后自己再尝试跟着 debug，这样的效率如虎添翼。</p>\n<p><strong>4. 搭建系统，把源代码跑起来！</strong></p>\n<p>Debug 是非常非常重要的手段， 你想通过只看而不运行就把系统搞清楚，那是根本不可能的！合理运用调用栈（观察调用过程上下文）。</p>\n<p><strong>5.笔记</strong></p>\n<p>一个非常重要的工作就是记笔记（又是写作！），画出系统的类图（不要依靠 IDE 给你生成的）， 记录下主要的函数调用， 方便后续查看。</p>\n<p><strong>文档工作极为重要</strong>，因为代码太复杂，人的大脑容量也有限，记不住所有的细节。 文档可以帮助你记住关键点， 到时候可以回想起来，迅速地接着往下看。</p>\n<p>要不然，你今天看的，可能到明天就忘个差不多了。所以朋友们记得收藏后多翻来看看，尝试把源码下载下来反复调试。</p>\n<h4>错误方式</h4>\n<ul>\n <li>陷入细节，不看全局：<strong>我还没弄清楚森林长啥样，就盯着叶子看</strong> ，看不到全貌和整体设计思路。所以阅读源码学习的时候不要一开始就进入细节，而是宏观看待整体架构设计思想，模块之间的关系。</li>\n <li>还没学会用就研究如何设计：首先基本上框架都运用了设计模式，我们最起码也要了解常用的设计模式，即使是“背”，也得了然于胸。在学习一门技术，我推荐先看官方文档，看看有哪些模块、整体设计思想。然后下载示例跑一遍，最后才是看源码。</li>\n <li>看源码深究细节：到了看具体某个模块源码的时候也要下意识的不要去深入细节，重要的是学习设计思路，而不是具体一个方法实现逻辑。除非自己要基于源码做二次开发，而且二次开发也是基于在了解扎鞥个架构的情况下才能深入细节。</li>\n</ul>\n<h2>组件设计-落实单一职责、面向接口思想</h2>\n<p>当我们接到一个功能需求的时候，最重要的就是抽象设计，将功能拆解主要核心组件，然后找到需求的变化与不变点，将相似功能内聚，功能之间若耦合，同时对外支持可拓展，对内关闭修改。努力做到一个需求下来的时候我们需要合理的抽象能力抽象出不同组件，而不是一锅端将所有功能糅合在一个类甚至一个方法之中，这样的代码牵一发而动全身，无法拓展，难以维护和阅读。</p>\n<p>带着问题我们来分析 Tomcat 如何设计组件完成连接与容器管理。</p>\n<p>看看 Tomcat 如何实现将 Tomcat 启动，并且又是如何接受请求，将请求转发到我们的 Servlet 中。</p>\n<h3>Catalina</h3>\n<p>主要任务就是创建 Server，并不是简单创建，而是解析 server.xml 文件把文件配置的各个组件意义创建出来，接着调用 Server 的 init() 和 start() 方法，启动之旅从这里开始…，同时还要兼顾异常，比如关闭 Tomcat 还需要做到优雅关闭启动过程创建的资源需要释放，Tomcat 则是在 JVM 注册一个「关闭钩子」，源码我都加了注释，省略了部分无关代码。同时通过 <code>await()</code> 监听停止指令关闭 Tomcat。</p>\n<pre><code class=\"java\">    /**\n     * Start a new server instance.\n     */\n    public void start() {\n                // 若 server 为空，则解析 server.xml 创建\n        if (getServer() == null) {\n            load();\n        }\n                // 创建失败则报错并退出启动\n        if (getServer() == null) {\n            log.fatal(\"Cannot start server. Server instance is not configured.\");\n            return;\n        }\n\n        // 开始启动 server\n        try {\n            getServer().start();\n        } catch (LifecycleException e) {\n            log.fatal(sm.getString(\"catalina.serverStartFail\"), e);\n            try {\n                // 异常则执行 destroy 销毁资源\n                getServer().destroy();\n            } catch (LifecycleException e1) {\n                log.debug(\"destroy() failed for failed Server \", e1);\n            }\n            return;\n        }\n\n        // 创建并注册 JVM 关闭钩子\n        if (useShutdownHook) {\n            if (shutdownHook == null) {\n                shutdownHook = new CatalinaShutdownHook();\n            }\n            Runtime.getRuntime().addShutdownHook(shutdownHook);\n        }\n                // 通过 await 方法监听停止请求\n        if (await) {\n            await();\n            stop();\n        }\n    }</code></pre>\n<p>通过「关闭钩子」，就是当 JVM 关闭的时候做一些清理工作，比如说释放线程池，清理一些零时文件，刷新内存数据到磁盘中…...</p>\n<p>「关闭钩子」本质就是一个线程，JVM 在停止之前会尝试执行这个线程。我们来看下 CatalinaShutdownHook 这个钩子到底做了什么。</p>\n<pre><code class=\"java\">    /**\n     * Shutdown hook which will perform a clean shutdown of Catalina if needed.\n     */\n    protected class CatalinaShutdownHook extends Thread {\n\n        @Override\n        public void run() {\n            try {\n                if (getServer() != null) {\n                    Catalina.this.stop();\n                }\n            } catch (Throwable ex) {\n               ...\n        }\n    }\n\n    /**\n     * 关闭已经创建的 Server 实例\n     */\n    public void stop() {\n\n        try {\n            // Remove the ShutdownHook first so that server.stop()\n            // doesn't get invoked twice\n            if (useShutdownHook) {\n                Runtime.getRuntime().removeShutdownHook(shutdownHook);\n            }\n        } catch (Throwable t) {\n            ......\n        }\n\n        // 关闭 Server\n        try {\n            Server s = getServer();\n            LifecycleState state = s.getState();\n           // 判断是否已经关闭，若是在关闭中，则不执行任何操作\n            if (LifecycleState.STOPPING_PREP.compareTo(state) &lt;= 0\n                    &amp;&amp; LifecycleState.DESTROYED.compareTo(state) &gt;= 0) {\n                // Nothing to do. stop() was already called\n            } else {\n                s.stop();\n                s.destroy();\n            }\n        } catch (LifecycleException e) {\n            log.error(\"Catalina.stop\", e);\n        }\n\n    }\n</code></pre>\n<p>实际上就是执行了 Server 的 stop 方法，Server 的 stop 方法会释放和清理所有的资源。</p>\n<h3>Server 组件</h3>\n<p>来体会下面向接口设计美，看 Tomcat 如何设计组件与接口，抽象 Server 组件，Server 组件需要生命周期管理，所以继承 Lifecycle 实现一键启停。</p>\n<p>它的具体实现类是 StandardServer，如下图所示，我们知道 Lifecycle 主要的方法是组件的 初始化、启动、停止、销毁，和 监听器的管理维护，其实就是观察者模式的设计，当触发不同事件的时候发布事件给监听器执行不同业务处理，这里就是如何解耦的设计哲学体现。</p>\n<p>而 Server 自生则是负责管理 Service 组件。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023657737\" alt=\"\" title=\"\" /></p>\n<p>接着，我们再看 Server 组件的具体实现类是 StandardServer 有哪些功能，又跟哪些类关联？</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023657736\" alt=\"StandardServer\" title=\"StandardServer\" /></p>\n<p>在阅读源码的过程中，我们一定要多关注接口与抽象类，接口是组件全局设计的抽象；而抽象类基本上是模板方法模式的运用，主要目的就是抽象整个算法流程，将变化点交给子类，将不变点实现代码复用。</p>\n<p>StandardServer 继承了 LifeCycleBase，它的生命周期被统一管理，并且它的子组件是 Service，因此它还需要管理 Service 的生命周期，也就是说在启动时调用 Service 组件的启动方法，在停止时调用它们的停止方法。Server 在内部维护了若干 Service 组件，它是以数组来保存的，那 Server 是如何添加一个 Service 到数组中的呢？</p>\n<pre><code class=\"java\">    /**\n     * 添加 Service 到定义的数组中\n     *\n     * @param service The Service to be added\n     */\n    @Override\n    public void addService(Service service) {\n\n        service.setServer(this);\n\n        synchronized (servicesLock) {\n           // 创建一个 services.length + 1 长度的 results 数组\n            Service results[] = new Service[services.length + 1];\n           // 将老的数据复制到 results 数组\n            System.arraycopy(services, 0, results, 0, services.length);\n            results[services.length] = service;\n            services = results;\n                        // 启动 Service 组件\n            if (getState().isAvailable()) {\n                try {\n                    service.start();\n                } catch (LifecycleException e) {\n                    // Ignore\n                }\n            }\n\n            // 观察者模式运用，触发监听事件\n            support.firePropertyChange(\"service\", null, service);\n        }\n\n    }</code></pre>\n<p>从上面的代码可以知道，并不是一开始就分配一个很长的数组，而是在新增过程中动态拓展长度，这里就是为了节省空间，对于我们平时开发是不是也要主要空间复杂度带来的内存损耗，追求的就是极致的美。</p>\n<p>除此之外，还有一个重要功能，上面 Caralina 的启动方法的最后一行代码就是调用了 Server 的 await 方法。</p>\n<p>这个方法主要就是监听停止端口，在 <strong>await</strong> 方法里会创建一个 Socket 监听 8005 端口，并在一个死循环里接收 Socket 上的连接请求，如果有新的连接到来就建立连接，然后从 Socket 中读取数据；如果读到的数据是停止命令“SHUTDOWN”，就退出循环，进入 stop 流程。</p>\n<h3>Service</h3>\n<p>同样是面向接口设计，Service 组件的具体实现类是 StandardService，Service 组件依然是继承 Lifecycle 管理生命周期，这里不再累赘展示图片关系图。我们先来看看 Service 接口主要定义的方法以及成员变量。通过接口我们才能知道核心功能，在阅读源码的时候一定要多关注每个接口之间的关系，不要急着进入实现类。</p>\n<pre><code class=\"java\">public interface Service extends Lifecycle {\n\n  // ----------主要成员变量\n\n    //Service 组件包含的顶层容器 Engine\n    public Engine getContainer();\n\n    // 设置 Service 的 Engine 容器\n    public void setContainer(Engine engine);\n\n    // 该 Service 所属的 Server 组件\n    public Server getServer();\n\n    // --------------------------------------------------------- Public Methods\n\n   // 添加 Service 关联的连接器\n    public void addConnector(Connector connector);\n\n    public Connector[] findConnectors();\n\n   // 自定义线程池\n    public void addExecutor(Executor ex);\n\n   // 主要作用就是根据 url 定位到 Service，Mapper 的主要作用就是用于定位一个请求所在的组件处理\n    Mapper getMapper();\n}\n</code></pre>\n<p>接着再来细看 Service 的实现类：</p>\n<pre><code class=\"java\">public class StandardService extends LifecycleBase implements Service {\n    // 名字\n    private String name = null;\n\n    //Server 实例\n    private Server server = null;\n\n    // 连接器数组\n    protected Connector connectors[] = new Connector[0];\n    private final Object connectorsLock = new Object();\n\n    // 对应的 Engine 容器\n    private Engine engine = null;\n\n    // 映射器及其监听器，又是观察者模式的运用\n    protected final Mapper mapper = new Mapper();\n    protected final MapperListener mapperListener = new MapperListener(this);\n}</code></pre>\n<p>StandardService 继承了 LifecycleBase 抽象类，抽象类定义了 三个 final 模板方法定义生命周期，每个方法将变化点定义抽象方法让不同组件时间自己的流程。这里也是我们学习的地方，利用模板方法抽象变与不变。</p>\n<p>此外 StandardService 中还有一些我们熟悉的组件，比如 Server、Connector、Engine 和 Mapper。</p>\n<p>那为什么还有一个 MapperListener？这是因为 Tomcat 支持热部署，当 Web 应用的部署发生变化时，Mapper 中的映射信息也要跟着变化，MapperListener 就是一个监听器，它监听容器的变化，并把信息更新到 Mapper 中，这是典型的观察者模式。下游服务根据多上游服务的动作做出不同处理，这就是<a href=\"https://mp.weixin.qq.com/s/7FL-m75fOctUVAMI_YgIww\" rel=\"nofollow noreferrer\">观察者模式</a>的运用场景，实现一个事件多个监听器触发，事件发布者不用调用所有下游，而是通过观察者模式触发达到解耦。</p>\n<p>Service 管理了 连接器以及 Engine 顶层容器，所以继续进入它的 startInternal 方法，其实就是 LifecycleBase 模板定义的 抽象方法。看看他是怎么启动每个组件顺序。</p>\n<pre><code class=\"java\">protected void startInternal() throws LifecycleException {\n\n    //1. 触发启动监听器\n    setState(LifecycleState.STARTING);\n\n    //2. 先启动 Engine，Engine 会启动它子容器，因为运用了组合模式，所以每一层容器在会先启动自己的子容器。\n    if (engine != null) {\n        synchronized (engine) {\n            engine.start();\n        }\n    }\n\n    //3. 再启动 Mapper 监听器\n    mapperListener.start();\n\n    //4. 最后启动连接器，连接器会启动它子组件，比如 Endpoint\n    synchronized (connectorsLock) {\n        for (Connector connector: connectors) {\n            if (connector.getState() != LifecycleState.FAILED) {\n                connector.start();\n            }\n        }\n    }\n}</code></pre>\n<p>Service 先启动了 Engine 组件，再启动 Mapper 监听器，最后才是启动连接器。这很好理解，因为内层组件启动好了才能对外提供服务，才能启动外层的连接器组件。而 Mapper 也依赖容器组件，容器组件启动好了才能监听它们的变化，因此 Mapper 和 MapperListener 在容器组件之后启动。组件停止的顺序跟启动顺序正好相反的，也是基于它们的依赖关系。</p>\n<h3>Engine</h3>\n<p>作为 Container 的顶层组件，所以 Engine 本质就是一个容器，继承了 ContainerBase ，看到抽象类再次运用了模板方法设计模式。ContainerBase 使用一个 <code>HashMap&lt;String, Container&gt; children = new HashMap&lt;&gt;();</code> 成员变量保存每个组件的子容器。同时使用 <code>protected final Pipeline pipeline = new StandardPipeline(this);</code> Pipeline 组成一个管道用于处理连接器传过来的请求，责任链模式构建管道。</p>\n<pre><code class=\"java\"> public class StandardEngine extends ContainerBase implements Engine {\n }</code></pre>\n<p>Engine 的子容器是 Host，所以 children 保存的就是 Host。</p>\n<p>我们来看看 ContainerBase 做了什么...</p>\n<ul>\n <li>initInternal 定义了容器初始化，同时创建了专门用于启动停止容器的线程池。</li>\n <li>startInternal：容器启动默认实现，通过组合模式构建容器父子关系，首先获取自己的子容器，使用 startStopExecutor 启动子容器。</li>\n</ul>\n<pre><code class=\"java\">public abstract class ContainerBase extends LifecycleMBeanBase\n        implements Container {\n\n   // 提供了默认初始化逻辑\n    @Override\n    protected void initInternal() throws LifecycleException {\n        BlockingQueue&lt;Runnable&gt; startStopQueue = new LinkedBlockingQueue&lt;&gt;();\n       // 创建线程池用于启动或者停止容器\n        startStopExecutor = new ThreadPoolExecutor(\n                getStartStopThreadsInternal(),\n                getStartStopThreadsInternal(), 10, TimeUnit.SECONDS,\n                startStopQueue,\n                new StartStopThreadFactory(getName() + \"-startStop-\"));\n        startStopExecutor.allowCoreThreadTimeOut(true);\n        super.initInternal();\n    }\n\n  // 容器启动\n    @Override\n    protected synchronized void startInternal() throws LifecycleException {\n\n        // 获取子容器并提交到线程池启动\n        Container children[] = findChildren();\n        List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;();\n        for (Container child : children) {\n            results.add(startStopExecutor.submit(new StartChild(child)));\n        }\n        MultiThrowable multiThrowable = null;\n        // 获取启动结果\n        for (Future&lt;Void&gt; result : results) {\n            try {\n                result.get();\n            } catch (Throwable e) {\n                log.error(sm.getString(\"containerBase.threadedStartFailed\"), e);\n                if (multiThrowable == null) {\n                    multiThrowable = new MultiThrowable();\n                }\n                multiThrowable.add(e);\n            }\n\n        }\n       ......\n\n        // 启动 pipeline 管道，用于处理连接器传递过来的请求\n        if (pipeline instanceof Lifecycle) {\n            ((Lifecycle) pipeline).start();\n        }\n                 // 发布启动事件\n        setState(LifecycleState.STARTING);\n        // Start our thread\n        threadStart();\n    }\n\n\n}</code></pre>\n<p>继承了 LifecycleMBeanBase 也就是还实现了生命周期的管理，提供了子容器默认的启动方式，同时提供了对子容器的 CRUD 功能。</p>\n<p>Engine 在启动 Host 容器就是 使用了 ContainerBase 的 startInternal 方法。Engine 自己还做了什么呢？</p>\n<p>我们看下 构造方法，pipeline 设置了 setBasic，创建了 StandardEngineValve。</p>\n<pre><code class=\"java\">/**\n     * Create a new StandardEngine component with the default basic Valve.\n     */\n    public StandardEngine() {\n\n        super();\n        pipeline.setBasic(new StandardEngineValve());\n        .....\n\n    }</code></pre>\n<p>容器主要的功能就是处理请求，把请求转发给某一个 Host 子容器来处理，具体是通过 Valve 来实现的。每个容器组件都有一个 Pipeline 用于组成一个责任链传递请求。而 Pipeline 中有一个基础阀（Basic Valve），而 Engine 容器的基础阀定义如下：</p>\n<pre><code class=\"java\">final class StandardEngineValve extends ValveBase {\n    @Override\n    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // 选择一个合适的 Host 处理请求，通过 Mapper 组件获取到合适的 Host\n        Host host = request.getHost();\n        if (host == null) {\n            response.sendError\n                (HttpServletResponse.SC_BAD_REQUEST,\n                 sm.getString(\"standardEngine.noHost\",\n                              request.getServerName()));\n            return;\n        }\n        if (request.isAsyncSupported()) {\n            request.setAsyncSupported(host.getPipeline().isAsyncSupported());\n        }\n\n        // 获取 Host 容器的 Pipeline first Valve ,将请求转发到 Host\n        host.getPipeline().getFirst().invoke(request, response);\n}</code></pre>\n<p>这个基础阀实现非常简单，就是把请求转发到 Host 容器。处理请求的 Host 容器对象是从请求中拿到的，请求对象中怎么会有 Host 容器呢？这是因为请求到达 Engine 容器中之前，Mapper 组件已经对请求进行了路由处理，Mapper 组件通过请求的 URL 定位了相应的容器，并且把容器对象保存到了请求对象中。</p>\n<h3>组件设计总结</h3>\n<p>大家有没有发现，Tomcat 的设计几乎都是面向接口设计，也就是通过接口隔离功能设计其实就是单一职责的体现，每个接口抽象对象不同的组件，通过抽象类定义组件的共同执行流程。单一职责四个字的含义其实就是在这里体现出来了。在分析过程中，我们看到了观察者模式、模板方法模式、组合模式、责任链模式以及如何抽象组件面向接口设计的设计哲学。</p>\n<h2>连接器之 I/O 模型与线程池设计</h2>\n<p>连接器主要功能就是接受 TCP/IP 连接，限制连接数然后读取数据，最后将请求转发到 <code>Container</code> 容器。所以这里必然涉及到 I/O 编程，今天带大家一起分析 Tomcat 如何运用 I/O 模型实现高并发的，一起进入 I/O 的世界。</p>\n<p>I/O 模型主要有 5 种：<strong>同步阻塞、同步非阻塞、I/O 多路复用、信号驱动、异步 I/O</strong>。是不是很熟悉但是又傻傻分不清他们有何区别？</p>\n<p>所谓的<strong>I/O 就是计算机内存与外部设备之间拷贝数据的过程</strong>。</p>\n<p>CPU 是先把外部设备的数据读到内存里，然后再进行处理。请考虑一下这个场景，当程序通过 CPU 向外部设备发出一个读指令时，数据从外部设备拷贝到内存往往需要一段时间，这个时候 CPU 没事干了，程序是主动把 CPU 让给别人？还是让 CPU 不停地查：数据到了吗，数据到了吗……</p>\n<p>这就是 I/O 模型要解决的问题。今天我会先说说各种 I/O 模型的区别，然后重点分析 Tomcat 的 NioEndpoint 组件是如何实现非阻塞 I/O 模型的。</p>\n<h3>I/O 模型</h3>\n<p>一个网络 I/O 通信过程，比如网络数据读取，会涉及到两个对象，分别是调用这个 I/O 操作的用户线程和操作系统内核。一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间。</p>\n<p>网络读取主要有两个步骤：</p>\n<ul>\n <li>用户线程等待内核将数据从网卡复制到内核空间。</li>\n <li>内核将数据从内核空间复制到用户空间。</li>\n</ul>\n<p>同理，将数据发送到网络也是一样的流程，将数据从用户线程复制到内核空间，内核空间将数据复制到网卡发送。</p>\n<p>不同 I/O 模型的区别：实现这两个步骤的方式不一样。</p>\n<ul>\n <li>对于同步，则指的应用程序调用一个方法是否立马返回，而不需要等待。</li>\n <li>对于阻塞与非阻塞：主要就是数据从内核复制到用户空间的读写操作是否是阻塞等待的。</li>\n</ul>\n<h4>同步阻塞 I/O</h4>\n<p>用户线程发起<code>read</code>调用的时候，线程就阻塞了，只能让出 CPU，而内核则等待网卡数据到来，并把数据从网卡拷贝到内核空间，当内核把数据拷贝到用户空间，再把刚刚阻塞的读取用户线程唤醒，两个步骤的线程都是阻塞的。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023657739\" alt=\"同步阻塞 I/O\" title=\"同步阻塞 I/O\" /></p>\n<h4>同步非阻塞</h4>\n<p>用户线程一直不停的调用<code>read</code>方法，如果数据还没有复制到内核空间则返回失败，直到数据到达内核空间。用户线程在等待数据从内核空间复制到用户空间的时间里一直是阻塞的，等数据到达用户空间才被唤醒。循环调用<code>read</code>方法的时候不阻塞。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023657738\" alt=\"同步非阻塞\" title=\"同步非阻塞\" /></p>\n<h4>I/O 多路复用</h4>\n<p>用户线程的读取操作被划分为两步：</p>\n<ol>\n <li>用户线程先发起 <code>select</code> 调用，主要就是询问内核数据转备好了没？当内核把数据准备好了就执行第二步。</li>\n <li>用户线程再发起 <code>read</code> 调用，在等待内核把数据从内核空间复制到用户空间的时间里，发起 read 线程是阻塞的。</li>\n</ol>\n<p>为何叫 I/O 多路复用，核心主要就是：一次 <code>select</code> 调用可以向内核查询多个<strong>数据通道(Channel)</strong>的状态，因此叫多路复用。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023657740\" alt=\"I/O 多路复用\" title=\"I/O 多路复用\" /></p>\n<h4>异步 I/O</h4>\n<p>用户线程执行 read 调用的时候会注册一个回调函数， read 调用立即返回，不会阻塞线程，在等待内核将数据准备好以后，再调用刚刚注册的回调函数处理数据，在整个过程中用户线程一直没有阻塞。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023657741\" alt=\"异步 I/O\" title=\"异步 I/O\" /></p>\n<h3>Tomcat NioEndpoint</h3>\n<p>Tomcat 的 NioEndpoit 组件实际上就是实现了 I/O 多路复用模型，正式因为这个并发能力才足够优秀。让我们一起窥探下 Tomcat NioEndpoint 的设计原理。</p>\n<p>对于 Java 的多路复用器的使用，无非是两步：</p>\n<ol>\n <li>创建一个 Seletor，在它身上注册各种感兴趣的事件，然后调用 select 方法，等待感兴趣的事情发生。</li>\n <li>感兴趣的事情发生了，比如可以读了，这时便创建一个新的线程从 Channel 中读数据。</li>\n</ol>\n<p>Tomcat 的 NioEndpoint 组件虽然实现比较复杂，但基本原理就是上面两步。我们先来看看它有哪些组件，它一共包含 LimitLatch、Acceptor、Poller、SocketProcessor 和 Executor 共 5 个组件，它们的工作过程如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023465591\" alt=\"NioEndPoint\" title=\"NioEndPoint\" /></p>\n<p>正是由于使用了 I/O 多路复用，Poller 内部本质就是持有 Java Selector 检测 channel 的 I/O 时间，当数据可读写的时候创建 SocketProcessor 任务丢到线程池执行，也就是少量线程监听读写事件，接着专属的线程池执行读写，提高性能。</p>\n<h3>自定义线程池模型</h3>\n<p>为了提高处理能力和并发度， Web 容器通常会把处理请求的工作放在线程池来处理， Tomcat 拓展了 Java 原生的线程池来提升并发需求，在进入 Tomcat 线程池原理之前，我们先回顾下 Java 线程池原理。</p>\n<h4>Java 线程池</h4>\n<p>简单的说，Java 线程池里内部维护一个线程数组和一个任务队列，当任务处理不过来的时，就把任务放到队列里慢慢处理。</p>\n<h5>ThreadPoolExecutor</h5>\n<p>来窥探线程池核心类的构造函数，我们需要理解每一个参数的作用，才能理解线程池的工作原理。</p>\n<pre><code class=\"java\">    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue&lt;Runnable&gt; workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        ......\n    }</code></pre>\n<ul>\n <li>corePoolSize：保留在池中的线程数，即使它们空闲，除非设置了 allowCoreThreadTimeOut，不然不会关闭。</li>\n <li>maximumPoolSize：队列满后池中允许的最大线程数。</li>\n <li>keepAliveTime、TimeUnit：如果线程数大于核心数，多余的空闲线程的保持的最长时间会被销毁。unit 是 keepAliveTime 参数的时间单位。当设置 <code>allowCoreThreadTimeOut(true)</code> 时，线程池中 corePoolSize 范围内的线程空闲时间达到 keepAliveTime 也将回收。</li>\n <li>workQueue：当线程数达到 <strong>corePoolSize</strong> 后，新增的任务就放到工作队列 <strong>workQueue</strong> 里，而线程池中的线程则努力地从 <strong>workQueue</strong> 里拉活来干，也就是调用 poll 方法来获取任务。</li>\n <li>ThreadFactory：创建线程的工厂，比如设置是否是后台线程、线程名等。</li>\n <li>RejectedExecutionHandler：拒绝策略，处理程序因为达到了线程界限和队列容量执行拒绝策略。也可以自定义拒绝策略，只要实现 <code>RejectedExecutionHandler</code> 即可。默认的拒绝策略：<code>AbortPolicy</code> 拒绝任务并抛出 <code>RejectedExecutionException</code> 异常；<code>CallerRunsPolicy</code> 提交该任务的线程执行；``</li>\n</ul>\n<p>来分析下每个参数之间的关系：</p>\n<p>提交新任务的时候，如果线程池数 &lt; corePoolSize，则创建新的线程池执行任务，当线程数 = corePoolSize 时，新的任务就会被放到工作队列 workQueue 中，线程池中的线程尽量从队列里取任务来执行。</p>\n<p>如果任务很多，workQueue 满了，且 当前线程数 &lt; maximumPoolSize 时则临时创建线程执行任务，如果总线程数量超过 maximumPoolSize，则不再创建线程，而是执行拒绝策略。<code>DiscardPolicy</code> 什么都不做直接丢弃任务；<code>DiscardOldestPolicy</code> 丢弃最旧的未处理程序;</p>\n<p>具体执行流程如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023657742\" alt=\"线程池执行流程\" title=\"线程池执行流程\" /></p>\n<h4>Tomcat 线程池</h4>\n<p>定制版的 ThreadPoolExecutor，继承了 java.util.concurrent.ThreadPoolExecutor。 对于线程池有两个很关键的参数：</p>\n<ul>\n <li>线程个数。</li>\n <li>队列长度。</li>\n</ul>\n<p>Tomcat 必然需要限定想着两个参数不然在高并发场景下可能导致 CPU 和内存有资源耗尽的风险。继承了 与 java.util.concurrent.ThreadPoolExecutor 相同，但实现的效率更高。</p>\n<p>其构造方法如下，跟 Java 官方的如出一辙</p>\n<pre><code class=\"java\">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) {\n        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);\n        prestartAllCoreThreads();\n    }</code></pre>\n<p>在 Tomcat 中控制线程池的组件是 <code>StandardThreadExecutor</code> , 也是实现了生命周期接口，下面是启动线程池的代码</p>\n<pre><code class=\"java\">    @Override\n    protected void startInternal() throws LifecycleException {\n        // 自定义任务队列\n        taskqueue = new TaskQueue(maxQueueSize);\n        // 自定义线程工厂\n        TaskThreadFactory tf = new TaskThreadFactory(namePrefix,daemon,getThreadPriority());\n       // 创建定制版线程池\n        executor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS,taskqueue, tf);\n        executor.setThreadRenewalDelay(threadRenewalDelay);\n        if (prestartminSpareThreads) {\n            executor.prestartAllCoreThreads();\n        }\n        taskqueue.setParent(executor);\n        // 观察者模式，发布启动事件\n        setState(LifecycleState.STARTING);\n    }</code></pre>\n<p>其中的关键点在于：</p>\n<ol>\n <li>Tomcat 有自己的定制版任务队列和线程工厂，并且可以限制任务队列的长度，它的最大长度是 maxQueueSize。</li>\n <li>Tomcat 对线程数也有限制，设置了核心线程数（minSpareThreads）和最大线程池数（maxThreads）。</li>\n</ol>\n<p>除此之外， Tomcat 在官方原有基础上重新定义了自己的线程池处理流程，原生的处理流程上文已经说过。</p>\n<ul>\n <li>前 corePoolSize 个任务时，来一个任务就创建一个新线程。</li>\n <li>还有任务提交，直接放到队列，队列满了，但是没有达到最大线程池数则创建临时线程救火。</li>\n <li>线程总线数达到 maximumPoolSize ，直接执行拒绝策略。</li>\n</ul>\n<p>Tomcat 线程池扩展了原生的 ThreadPoolExecutor，通过重写 execute 方法实现了自己的任务处理逻辑：</p>\n<ul>\n <li>前 corePoolSize 个任务时，来一个任务就创建一个新线程。</li>\n <li>还有任务提交，直接放到队列，队列满了，但是没有达到最大线程池数则创建临时线程救火。</li>\n <li><strong>线程总线数达到 maximumPoolSize ，继续尝试把任务放到队列中。如果队列也满了，插入任务失败，才执行拒绝策略。</strong></li>\n</ul>\n<p><strong>最大的差别在于 Tomcat 在线程总数达到最大数时，不是立即执行拒绝策略，而是再尝试向任务队列添加任务，添加失败后再执行拒绝策略。</strong></p>\n<p>代码如下所示:</p>\n<pre><code class=\"java\">    public void execute(Runnable command, long timeout, TimeUnit unit) {\n       // 记录提交任务数 +1\n        submittedCount.incrementAndGet();\n        try {\n            // 调用 java 原生线程池来执行任务，当原生抛出拒绝策略\n            super.execute(command);\n        } catch (RejectedExecutionException rx) {\n          //总线程数达到 maximumPoolSize，Java 原生会执行拒绝策略\n            if (super.getQueue() instanceof TaskQueue) {\n                final TaskQueue queue = (TaskQueue)super.getQueue();\n                try {\n                    // 尝试把任务放入队列中\n                    if (!queue.force(command, timeout, unit)) {\n                        submittedCount.decrementAndGet();\n                      // 队列还是满的，插入失败则执行拒绝策略\n                        throw new RejectedExecutionException(\"Queue capacity is full.\");\n                    }\n                } catch (InterruptedException x) {\n                    submittedCount.decrementAndGet();\n                    throw new RejectedExecutionException(x);\n                }\n            } else {\n              // 提交任务书 -1\n                submittedCount.decrementAndGet();\n                throw rx;\n            }\n\n        }\n    }</code></pre>\n<p>Tomcat 线程池是用 submittedCount 来维护已经提交到了线程池，这跟 Tomcat 的定制版的任务队列有关。Tomcat 的任务队列 TaskQueue 扩展了 Java 中的 LinkedBlockingQueue，我们知道 LinkedBlockingQueue 默认情况下长度是没有限制的，除非给它一个 capacity。因此 Tomcat 给了它一个 capacity，TaskQueue 的构造函数中有个整型的参数 capacity，TaskQueue 将 capacity 传给父类 LinkedBlockingQueue 的构造函数，防止无限添加任务导致内存溢出。而且默认是无限制，就会导致当前线程数达到核心线程数之后，再来任务的话线程池会把任务添加到任务队列，并且总是会成功，这样永远不会有机会创建新线程了。</p>\n<p>为了解决这个问题，TaskQueue 重写了 LinkedBlockingQueue 的 offer 方法，在合适的时机返回 false，返回 false 表示任务添加失败，这时线程池会创建新的线程。</p>\n<pre><code class=\"java\">public class TaskQueue extends LinkedBlockingQueue&lt;Runnable&gt; {\n\n  ...\n   @Override\n  // 线程池调用任务队列的方法时，当前线程数肯定已经大于核心线程数了\n  public boolean offer(Runnable o) {\n\n      // 如果线程数已经到了最大值，不能创建新线程了，只能把任务添加到任务队列。\n      if (parent.getPoolSize() == parent.getMaximumPoolSize())\n          return super.offer(o);\n\n      // 执行到这里，表明当前线程数大于核心线程数，并且小于最大线程数。\n      // 表明是可以创建新线程的，那到底要不要创建呢？分两种情况：\n\n      //1. 如果已提交的任务数小于当前线程数，表示还有空闲线程，无需创建新线程\n      if (parent.getSubmittedCount()&lt;=(parent.getPoolSize()))\n          return super.offer(o);\n\n      //2. 如果已提交的任务数大于当前线程数，线程不够用了，返回 false 去创建新线程\n      if (parent.getPoolSize()&lt;parent.getMaximumPoolSize())\n          return false;\n\n      // 默认情况下总是把任务添加到任务队列\n      return super.offer(o);\n  }\n\n}</code></pre>\n<p>只有当前线程数大于核心线程数、小于最大线程数，并且已提交的任务个数大于当前线程数时，也就是说线程不够用了，但是线程数又没达到极限，才会去创建新的线程。这就是为什么 Tomcat 需要维护已提交任务数这个变量，它的目的就是<strong>在任务队列的长度无限制的情况下，让线程池有机会创建新的线程</strong>。可以通过设置 maxQueueSize 参数来限制任务队列的长度。</p>\n<h2>性能优化</h2>\n<h3>线程池调优</h3>\n<p>跟 I/O 模型紧密相关的是线程池，线程池的调优就是设置合理的线程池参数。我们先来看看 Tomcat 线程池中有哪些关键参数：</p>\n<table>\n <thead>\n  <tr>\n   <th>参数</th>\n   <th>详情</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>threadPriority</td>\n   <td>线程优先级，默认是 5</td>\n  </tr>\n  <tr>\n   <td>daemon</td>\n   <td>是否是 后台线程，默认 true</td>\n  </tr>\n  <tr>\n   <td>namePrefix</td>\n   <td>线程名前缀</td>\n  </tr>\n  <tr>\n   <td>maxThreads</td>\n   <td>最大线程数，默认 200</td>\n  </tr>\n  <tr>\n   <td>minSpareThreads</td>\n   <td>最小线程数（空闲超过一定时间会被回收），默认 25</td>\n  </tr>\n  <tr>\n   <td>maxIdleTime</td>\n   <td>线程最大空闲时间，超过该时间的会被回收，直到只有 minSpareThreads 个。默认是 1 分钟</td>\n  </tr>\n  <tr>\n   <td>maxQueueSize</td>\n   <td>任务队列最大长度</td>\n  </tr>\n  <tr>\n   <td>prestartAllCoreThreads</td>\n   <td>是否在线程池启动的时候就创建 minSpareThreads 个线程，默认是 fasle</td>\n  </tr>\n </tbody>\n</table>\n<p>这里面最核心的就是如何确定 maxThreads 的值，如果这个参数设置小了，Tomcat 会发生线程饥饿，并且请求的处理会在队列中排队等待，导致响应时间变长；如果 maxThreads 参数值过大，同样也会有问题，因为服务器的 CPU 的核数有限，线程数太多会导致线程在 CPU 上来回切换，耗费大量的切换开销。</p>\n<p><strong>线程 I/O 时间与 CPU 时间</strong></p>\n<p>至此我们又得到一个线程池个数的计算公式，假设服务器是单核的：</p>\n<p><strong>线程池大小 = （线程 I/O 阻塞时间 + 线程 CPU 时间 ）/ 线程 CPU 时间</strong></p>\n<p>其中：线程 I/O 阻塞时间 + 线程 CPU 时间 = 平均请求处理时间。</p>\n<h3>Tomcat 内存溢出的原因分析及调优</h3>\n<p>JVM 在抛出 java.lang.OutOfMemoryError 时，除了会打印出一行描述信息，还会打印堆栈跟踪，因此我们可以通过这些信息来找到导致异常的原因。在寻找原因前，我们先来看看有哪些因素会导致 OutOfMemoryError，其中内存泄漏是导致 OutOfMemoryError 的一个比较常见的原因。</p>\n<p>其实调优很多时候都是在找系统瓶颈，假如有个状况：系统响应比较慢，但 CPU 的用率不高，内存有所增加，通过分析 Heap Dump 发现大量请求堆积在线程池的队列中，请问这种情况下应该怎么办呢？可能是请求处理时间太长，去排查是不是访问数据库或者外部应用遇到了延迟。</p>\n<h4>java.lang.OutOfMemoryError: Java heap space</h4>\n<p>当 JVM 无法在堆中分配对象的会抛出此异常，一般有以下原因：</p>\n<ol>\n <li>内存泄漏：本该回收的对象呗程序一直持有引用导致对象无法被回收，比如在线程池中使用 ThreadLocal、对象池、内存池。为了找到内存泄漏点，我们通过 jmap 工具生成 Heap Dump，再利用 MAT 分析找到内存泄漏点。<code>jmap -dump:live,format=b,file=filename.bin pid</code></li>\n <li>内存不足：我们设置的堆大小对于应用程序来说不够，修改 JVM 参数调整堆大小，比如 -Xms256m -Xmx2048m。</li>\n <li>finalize 方法的过度使用。如果我们想在 Java 类实例被 GC 之前执行一些逻辑，比如清理对象持有的资源，可以在 Java 类中定义 finalize 方法，这样 JVM GC 不会立即回收这些对象实例，而是将对象实例添加到一个叫“java.lang.ref.Finalizer.ReferenceQueue”的队列中，执行对象的 finalize 方法，之后才会回收这些对象。Finalizer 线程会和主线程竞争 CPU 资源，但由于优先级低，所以处理速度跟不上主线程创建对象的速度，因此 ReferenceQueue 队列中的对象就越来越多，最终会抛出 OutOfMemoryError。解决办法是尽量不要给 Java 类定义 finalize 方法。</li>\n</ol>\n<h4>java.lang.OutOfMemoryError: GC overhead limit exceeded</h4>\n<p>垃圾收集器持续运行，但是效率很低几乎没有回收内存。比如 Java 进程花费超过 96％的 CPU 时间来进行一次 GC，但是回收的内存少于 3％的 JVM 堆，并且连续 5 次 GC 都是这种情况，就会抛出 OutOfMemoryError。</p>\n<p>这个问题 IDE 解决方法就是查看 GC 日志或者生成 Heap Dump，先确认是否是内存溢出，不是的话可以尝试增加堆大小。可以通过如下 JVM 启动参数打印 GC 日志:</p>\n<pre><code class=\"shell\">-verbose:gc //在控制台输出GC情况\n-XX:+PrintGCDetails  //在控制台输出详细的GC情况\n-Xloggc: filepath  //将GC日志输出到指定文件中</code></pre>\n<p>比如 可以使用 <code>java -verbose:gc -Xloggc:gc.log -XX:+PrintGCDetails -jar xxx.jar</code> 记录 GC 日志，通过 GCViewer 工具查看 GC 日志，用 GCViewer 打开产生的 gc.log 分析垃圾回收情况。</p>\n<h4>java.lang.OutOfMemoryError: Requested array size exceeds VM limit</h4>\n<p>抛出这种异常的原因是“请求的数组大小超过 JVM 限制”，应用程序尝试分配一个超大的数组。比如程序尝试分配 128M 的数组，但是堆最大 100M，一般这个也是配置问题，有可能 JVM 堆设置太小，也有可能是程序的 bug，是不是创建了超大数组。</p>\n<h4>java.lang.OutOfMemoryError: MetaSpace</h4>\n<p>JVM 元空间的内存在本地内存中分配，但是它的大小受参数 MaxMetaSpaceSize 的限制。当元空间大小超过 MaxMetaSpaceSize 时，JVM 将抛出带有 MetaSpace 字样的 OutOfMemoryError。解决办法是加大 MaxMetaSpaceSize 参数的值。</p>\n<h4>java.lang.OutOfMemoryError: Request size bytes for reason. Out of swap space</h4>\n<p>当本地堆内存分配失败或者本地内存快要耗尽时，Java HotSpot VM 代码会抛出这个异常，VM 会触发“致命错误处理机制”，它会生成“致命错误”日志文件，其中包含崩溃时线程、进程和操作系统的有用信息。如果碰到此类型的 OutOfMemoryError，你需要根据 JVM 抛出的错误信息来进行诊断；或者使用操作系统提供的 DTrace 工具来跟踪系统调用，看看是什么样的程序代码在不断地分配本地内存。</p>\n<h4>java.lang.OutOfMemoryError: Unable to create native threads</h4>\n<ol>\n <li>Java 程序向 JVM 请求创建一个新的 Java 线程。</li>\n <li>JVM 本地代码（Native Code）代理该请求，通过调用操作系统 API 去创建一个操作系统级别的线程 Native Thread。</li>\n <li>操作系统尝试创建一个新的 Native Thread，需要同时分配一些内存给该线程，每一个 Native Thread 都有一个线程栈，线程栈的大小由 JVM 参数<code>-Xss</code>决定。</li>\n <li>由于各种原因，操作系统创建新的线程可能会失败，下面会详细谈到。</li>\n <li>JVM 抛出“java.lang.OutOfMemoryError: Unable to create new native thread”错误。</li>\n</ol>\n<p>这里只是概述场景，对于生产在线排查后续会陆续推出，受限于篇幅不再展开。<strong>关注「码哥字节」给你硬货来啃！</strong></p>\n<h2>总结</h2>\n<p>回顾 Tomcat 总结架构设计，详细拆解 Tomcat 如何处理高并发连接设计。并且分享了如何高效阅读开源框架源码思路，设计模式、并发编程基础是重中之重，读者朋友可以翻阅历史「码哥字节」的历史文章学习。</p>\n<h3>推荐阅读</h3>\n<p><a href=\"https://mp.weixin.qq.com/s/fU5Jj9tQvNTjRiT9grm6RA\" rel=\"nofollow noreferrer\">Tomcat 架构解析到工作借鉴</a></p>\n<p><a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3NDkwMjAyOQ==&amp;action=getalbum&amp;album_id=1351452628844363777&amp;subscene=159&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FAr_FZ6ck_WEjr9ia9bjmcQ#wechat_redirect\" rel=\"nofollow noreferrer\">设计模式专辑</a></p>\n<p><a href=\"http://mp.weixin.qq.com/mp/homepage?__biz=MzU3NDkwMjAyOQ==&amp;hid=7&amp;sn=660e8728f9eb24248cc7953796dbe773&amp;scene=18#wechat_redirect\" rel=\"nofollow noreferrer\">并发编程实战</a></p>\n<p>拆解 Tomcat 核心组件，去体会 Tomcat 如何面向接口设计、落实单一职责的设计哲学思想。接着概括了 连接器涉及到的 I/O 模型，并对不同的 I/O 模型进行了详解，接着看 Tomcat 如何实现 NIO，如何自定义线程池以及队列实现高并发设计，最后简单分享常见的 OOM 场景以及解决思路，限于篇幅不再详细展开，关注「码哥字节」后续会分享各种线上故障排查调优思路，敬请期待…...</p>\n<p>有任何疑问或者计数探讨可以<strong>加个人微信：MageByte1024</strong>，一起学习进步。</p>\n<p>也可以通过公众号菜单加入技术群，里面有<strong>阿里、腾讯</strong>的大佬。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000022678951\" alt=\"码哥字节\" title=\"码哥字节\" /></p>\n<p><strong>编写文章不易，如果阅读后觉得有用，希望关注「码哥字节」公众号，点击「分享」、「点赞」、「在看」是最大的鼓励。</strong></p>","descriptionType":"html","publishedDate":"Mon, 17 Aug 2020 07:22:08 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023657732","linkMd5":"9569faa8acc0e079a1c10828ff9a417e","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn6@2020_3/2020/08/24/23-08-23-128_3e079a22ca630726.webp","destWidth":800,"destHeight":406,"sourceBytes":111116,"destBytes":30308,"author":"码哥字节","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023657732":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn6@2020_3/2020/08/24/23-08-23-128_3e079a22ca630726.webp","https://segmentfault.com/img/remote/1460000023657733":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn83@2020_5/2020/08/24/23-08-37-631_8c8436a6031ce5b2.webp","https://segmentfault.com/img/remote/1460000023657734":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn80@2020_6/2020/08/24/23-08-37-888_0219a4c09525c3f3.webp","https://segmentfault.com/img/remote/1460000023657735":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn76@2020_4/2020/08/24/23-08-35-718_de19cb27823856b5.webp","https://segmentfault.com/img/remote/1460000023657737":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn7@2020_6/2020/08/24/23-08-38-067_37c2c4464d2306d7.webp","https://segmentfault.com/img/remote/1460000023657736":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn71@2020_1/2020/08/24/23-08-36-091_0b3e500f3a14db18.webp","https://segmentfault.com/img/remote/1460000023657739":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn100@2020_1/2020/08/24/23-08-36-884_490e6b9cc76ef541.webp","https://segmentfault.com/img/remote/1460000023657738":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn4@2020_1/2020/08/24/23-08-37-700_47af21c1d8fe1b43.webp","https://segmentfault.com/img/remote/1460000023657740":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn95@2020_2/2020/08/24/23-08-37-201_1d04b2d366acdb5c.webp","https://segmentfault.com/img/remote/1460000023657741":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn92@2020_4/2020/08/24/23-08-36-207_577394f1b53dd12a.webp","https://segmentfault.com/img/remote/1460000023465591":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn42@2020_4/2020/08/24/23-08-31-138_5d24db7b7f08f9c8.webp","https://segmentfault.com/img/remote/1460000023657742":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn88@2020_6/2020/08/24/23-08-37-616_aaa501e20ba9eee8.webp","https://segmentfault.com/img/remote/1460000022678951":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn74@2020_4/2020/08/24/23-08-42-545_437227b461a5c9c8.webp"},"publishedOrCreatedDate":1598310388564},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"如何快速构建React组件库","link":"https://segmentfault.com/a/1190000023676547","description":"<h3>前言</h3>\n<blockquote>\n 俗话说：“麻雀虽小，五脏俱全”，搭建一个组件库，知之非难，行之不易，涉及到的技术方方面面，犹如海面风平浪静，实则暗礁险滩，处处惊险～\n</blockquote>\n<p>目前团队内已经有较为成熟的 Vue 技术栈的 <a href=\"http://nutui.jd.com/#/index\" rel=\"nofollow noreferrer\">NutUI 组件库</a>[1] 和 React 技术栈的 <a href=\"http://yep-react.jd.com/#/\" rel=\"nofollow noreferrer\">yep-react 组件库</a>[2]。然而这些组件库大都从零开始搭建，包括 Webpack 的繁杂配置，Markdown 文件转 Vue 文件功能的开发，单元测试功能的开发、按需加载的 Babel 插件开发等等，完成整个组件库项目实属不易，也是一个浩大的工程。如果我们想快速搭建一个组件库，大可不必如此耗费精力，可以借助业内专业的相关库，经过拼装调试，快速实现一个组件库。<br>本篇文章就来给大家介绍一下使用 create-react-app 脚手架、docz 文档生成器、node-sass、结合 Netlify 部署项目的整个开发组件库的流程，本着包教包会，不会没有退费的原则，来一场手摸手式教学，话不多说，让我们进入正题：</br></p>\n<p>首先看一下组件库的最终效果：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676550\" alt=\"组件库界面\" title=\"组件库界面\" /></p>\n<p>本文将从以下步骤介绍如何搭建一个 React 组件库：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676551\" alt=\"文章结构\" title=\"文章结构\" /></p>\n<h3>一、构建本地开发环境</h3>\n<p>开发一个组件库的首要步骤就是调试本地 React 环境，我们直接使用 React 官方脚手架 <code>create-react-app</code>，可以省去从底层配置 Webpack+TypeScript+React 的摧残：</p>\n<p><strong>1、使用 create-react-app 初始化脚手架，并且安装 TypeScript</strong></p>\n<p><code>npx create-react-app myapp --typescript</code></p>\n<p>注意使用 node 为较高版本 &gt;10.15.0</p>\n<p><strong>2、配置 eslint 进行格式化</strong></p>\n<p>由于安装最新的 create-react-app 结合 VScode 编辑器即可支持 eslit，但是需要在项目根目录中要添加 .env 这个配置文件，设置 <code>EXTEND_ESLINT=true</code> 这样才会启用 eslint 检测，注意要 <strong>重启 vscode</strong></p>\n<p><strong>3、组件库系统文件结构</strong></p>\n<p>新建 styles 文件夹，包含了基本样式文件，结构如下：</p>\n<pre><code class=\"js\">|-styles\n| |-variables.scss // 各种变量以及可配置设置\n| |-mixins.scss    // 全局 mixins\n| |-index.scss    // 引入全部的 scss 文件，向外抛出样式入口\n|-components\n| |-Button\n|   |-button.scss // 组件的单独样式\n|   |-button.mdx // 组件的文档\n|   |-button.tsx // 组件的核心代码\n|   |-button.test.tsx // 组件的单元测试文件\n|  |-index.tsx  // 组件对外入口</code></pre>\n<p><strong>4、安装 node-sass 处理器</strong> </p>\n<p>安装 node-sass 用来编译 SCSS 样式文件：<code>npm i node-sass -D</code></p>\n<p>这样最基本的 react 开发环境就完成了，可以开心的开发组件了。</p>\n<h3>二、组件库打包编译</h3>\n<p>本地调试完组件库之后，需要打包压缩编译代码，供其他用户使用，这里我们用的 TypeScript 编写的代码，所以使用 Typescript 来编译项目：<br>首先在每个组件中新建 index.tsx 文件：</br></p>\n<pre><code class=\"js\">import Button from './button'\nexport default Button </code></pre>\n<p>修改 index.tsx 文件，导入导出各个模块</p>\n<pre><code class=\"js\">export { default as Button } from './components/Button'</code></pre>\n<p>在根目录新建 tsconfig.build.json，对 .tsx 文件进行编译：</p>\n<pre><code class=\"js\">{\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",// 生成目录\n    \"module\": \"esnext\",// 格式\n    \"target\": \"es5\",// 版本\n    \"declaration\": true,// 为每一个 ts 文件生成 .d.ts 文件\n    \"jsx\": \"react\",\n    \"moduleResolution\":\"Node\",// 规定寻找引入文件的路径为 node 标准\n    \"allowSyntheticDefaultImports\": true,\n  },\n  \"include\": [// 要编译哪些文件\n    \"src\"\n  ],\n  \"exclude\": [// 排除不需要编译的文件\n    \"src/**/*.test.tsx\",\n    \"src/**/*.stories.tsx\",\n    \"src/setupTests.ts\",\n  ]\n}</code></pre>\n<p>对于样式文件，使用 node-sass 编译 SCSS，抽取所有 SCSS 文件生成 CSS 文件：</p>\n<pre><code class=\"js\">\"script\":{\n    \"build-css\": \"node-sass ./src/styles/index.scss ./dist/index.css\",\n}</code></pre>\n<p>并且修改 build 命令：</p>\n<pre><code class=\"js\">\"script\":{\n    \"clean\": \"rimraf ./dist\",// 跨平台的兼容\n    \"build\": \"npm run clean &amp;&amp; npm run build-ts &amp;&amp; npm run build-css\",\n}</code></pre>\n<p>这样，执行 <code>npm run build</code> 之后，就可以生成对应的组件 JS 和 CSS 文件，为后面使用者按需加载和部署到 npm 上提供准备。</p>\n<h3>三、本地调试组件库</h3>\n<p>本地完成组件库的开发之后，在发布到 npm 前，需要先在本地调试，避免带着问题上传到 npm 上。这时就需要使用 npm link 出马了。</p>\n<p><strong>什么是 npm link</strong></p>\n<p>在本地开发 npm 模块的时候，我们可以使用 npm link 命令，将 npm 模块链接到对应的运行项目中去，方便地对模块进行调试和测试。</p>\n<p><strong>使用方法</strong></p>\n<p>假设组件库是 reactui 文件夹，要在本地的 demo 项目中使用组件。则在组件库中（要被 link 的地方）执行 <code>npm link</code>，则生成从本机的 <code>node_modules/reactui</code> 到 <code> 组件库的路径 / reactui</code> 中的映射关系。<br>然后在要使用组件库的文件夹 demo 中执行 <code>npm link reactui</code> 则生成以下对应链条：</br></p>\n<p>在要使用组件的文件夹 demo 中 -[映射到]—&gt; 本机的 <code>node_modules/reactui</code> —[映射到]-&gt; 开发组件库 reactui 的文件夹 /reactui</p>\n<p>需要修改组件库的 package.json 文件来设置入口：</p>\n<pre><code class=\"js\">{\n  \"name\": \"reactui\",\n  \"main\": \"dist/index.js\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n}</code></pre>\n<p>然后在要使用组件的 demo 项目的依赖中添加：</p>\n<pre><code class=\"js\">\"dependencies\":{\n  \"reactui\":\"0.0.1\"\n}</code></pre>\n<p>注意，此时并不用安装依赖，之所以写上该依赖，是为了方便在项目中使用的时候可以有代码提示功能。<br>然后在 demo 项目中使用：</br></p>\n<pre><code class=\"js\">import { Button } from 'reactui'</code></pre>\n<p>在 index.tsx 中引入 CSS 文件</p>\n<pre><code class=\"js\">import 'reactui/build/index.css'</code></pre>\n<p>正当以为大功告成的时候，下面这个报错犹如一盆冷水从天而降：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676552\" alt=\"错误提示\" title=\"错误提示\" /></p>\n<p>经过各种问题排查，在 <a href=\"https://reactjs.org/warnings/invalid-hook-call-warning.html\" rel=\"nofollow noreferrer\">react 官方网站</a>[3] 上查到以下说法：</p>\n<blockquote>\n 🔴 Do not call Hooks in class components.\n <br>🔴 Do not call in event handlers.<br>🔴 Do not call Hooks inside functions passed to useMemo, useReducer, or useEffect.</br></br>\n</blockquote>\n<p>说的很明白：</p>\n<p>原因 1: React 和 React DOM 的版本不一样的问题<br>原因 2: 可能打破了 Hooks 的规则<br>原因 3: 在同一个项目中使用了多个版本的 React</br></br></p>\n<p>官网很贴心，给出了解决方法：</p>\n<blockquote>\n This problem can also come up when you use npm link or an equivalent. In that case, your bundler might “see” two Reacts — one in application folder and one in your library folder. Assuming myapp and mylib are sibling folders, one possible fix is to run npm link ../myapp/node_modules/react from mylib. This should make the library use the application’s React copy.\n</blockquote>\n<p>核心思想在组件库中使用 <code>npm link</code> 方式，引到 demo 项目中的 react； 所以在组件库中执行： <code>npm link ../demo/node_modules/react</code></p>\n<p>具体步骤如下：</p>\n<ol>\n <li>在代码库 reactui 中执行 <code>npm link</code></li>\n <li>在代码库 reactui 中执行 <code>npm link ../../demo/node_modules/react</code></li>\n <li>在项目 demo 中执行 <code>npm link reactui</code></li>\n</ol>\n<p>如此可以解决上面 react 冲突问题；于是可以在本地一边快乐的调试组件库，一边快乐的在使用组件的项目中看到最终效果了。</p>\n<h3>四、组件库发布到 npm</h3>\n<p><strong>该过程一定要注意使用的是 npm 源！！[非常重要]</strong></p>\n<p>首先确定自己是否已经登录了 npm：</p>\n<pre><code class=\"js\">npm adduser\n// 填入用户名；密码；email\nnpm whoami // 查看当前登录名</code></pre>\n<p>修改组件库的 package.json ，注意 files 配置；以及 dependencies 文件的化简:<br>react 依赖原本是要放在 dependencies 中的，但是可能会和用户安装的 react 版本冲突，所以放在了 devDependencies 中，但是这样话用户如果没有安装 react 则无法使用组件库，所以要在 peerDependencies 中定义前置依赖 peerDependencies，告诉用户 react 和 react-dom 是必要的前置依赖:</br></p>\n<pre><code class=\"js\">\"main\": \"dist/index.js\",\n\"module\": \"dist/index.js\",\n\"types\": \"dist/index.d.ts\",\n\"files\": [ // 把哪些文件上传到 npm\n  \"dist\"\n],\n\"dependencies\": {  // 执行 npm i 的时候会安装这些依赖到 node_modules 中\n  \"axios\": \"^0.19.1\",// 发送请求\n  \"classnames\": \"^2.2.6\",//\n  \"react-transition-group\": \"^4.3.0\"\n},\n\"peerDependencies\": { // 重要！！，提醒使用者，组件库的核心依赖，必须先安装这些依赖才能使用\n  \"react\": \"&gt;=16.8.0\",  // 在 16.8 之后 才引入了 hooks\n  \"react-dom\": \"&gt;=16.8.0\"\n}</code></pre>\n<p>好了，整个组件库经过上述过程，基本上各个功能已经有了，提及一句：由于组件库使用的是 create-react-app 脚手架，最新的版本已经集成了单元测试功能。还有配置 husky 等规范代码提交，在这里不在做赘述，读者可以自行配置。</p>\n<h3>五、生成说明文档</h3>\n<p>目前生成说明文档较好的工具有 <a href=\"https://storybook.js.org/\" rel=\"nofollow noreferrer\">storybook</a>[4]、<a href=\"https://www.docz.site/\" rel=\"nofollow noreferrer\">docz</a>[5] 等工具，两者都是很优秀的文档生成工具，但是尺有所短，寸有所长，经过认真调研比较，最终选择了 docz。</p>\n<table>\n <thead>\n  <tr>\n   <th>工具名称</th>\n   <th>区别一</th>\n   <th>区别二</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>storybook</td>\n   <td>使用特有的API开发文档说明，可以引入markdown文件</td>\n   <td>生成文档的界面带有storybook的痕迹较多一些</td>\n  </tr>\n  <tr>\n   <td>docz</td>\n   <td>完美的结合了react和markdown语法开发文档</td>\n   <td>生成的文档界面是常规的文档界面</td>\n  </tr>\n </tbody>\n</table>\n<p><strong>1、确定选型</strong></p>\n<p>1）storybook 的常用编译文档规范相对 docz 而言，略有繁琐</p>\n<p>storybook 的编译文档规范如下所示：</p>\n<pre><code class=\"js\">//省略 import 引入的代码\nstoriesOf('Buttons', module)\n.addDecorator(storyFn =&gt; &lt;div style={{ textAlign: 'center' }}&gt;{storyFn()}&lt;/div&gt;)\n.add('with text', () =&gt; (\n&lt;Button onClick={action('clicked')}&gt;Hello Button111&lt;/Button&gt;\n),{\nnotes:{markdown}   // 将会渲染 markdown 内容\n}) </code></pre>\n<p>对比 docz 的开发文档：</p>\n<pre><code class=\"markdown\"># Button 组件\n\n使用方式如下所示：\nimport { Playground, Props } from 'docz';\nimport Button from './index.tsx';\n\n## 按钮组件\n\n&lt;Playground&gt;\n    &lt;Button btnWidth=\"100\"&gt;我是按钮&lt;/Button&gt;\n&lt;/Playground&gt;\n\n** 基本属性 **\n\n| 属性名称 | 说明 | 默认值 |\n|--|--|--|\n|btnType | 按钮类型 |--|</code></pre>\n<p>众所周知，Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。团队成员在开发文档时，熟练使用 markdown 语法，开发 docz 文档的 mdx 文件，结合了 Markdown 和 React 语法，相比 storybook 要使用很多的 API 来编写文档的方式，无疑减少了很多的学习 storybook 语法的成本。</p>\n<p>2）docz 生成的文档样式更加符合个人审美</p>\n<p>storybook 生成的文档样式，带有 storybook 的痕迹更为严重一些， 其生成文档界面如下所示： </p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676555\" alt=\"storybook生成界面\" title=\"storybook生成界面\" /></p>\n<p>docz 生成的文档图如下所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676553\" alt=\"docz生成界面\" title=\"docz生成界面\" /></p>\n<p>由上图对比可以看出，docz 生成的界面更加简介，较为常规。<br>综上，结合默认文档开发习惯和界面风格，我选择了docz，当然仁者见仁、智者见智，读者也可以使用同为优秀的 storybook 尝试，这都不是事儿～</br></p>\n<p><strong>2、使用 docz 开发</strong></p>\n<p>确定了 docz 进行开发后，根据官网介绍，在 create-react-app 生成的组件库中进行了安装配置：</p>\n<p><code>npm install docz</code></p>\n<p>安装成功后，就会向 package.json 文件中添加如下配置</p>\n<pre><code class=\"js\">{\n  \"scripts\": {\n    \"docz:dev\": \"docz dev\",\n    \"docz:build\": \"docz build\",\n    \"docz:serve\": \"docz build &amp;&amp; docz serve\"\n  }\n}</code></pre>\n<p>这时还需要在项目的根目录下新建 doczrc.js 文件，对 docz 进行配置：</p>\n<pre><code class=\"js\">export default {\n  files: ['./src/components/**/*.mdx','./src/*.mdx'], \n  dest: 'docsite', // 打包 docz 文档到哪个文件夹下\n  title: '组件库左上角标题',  // 设置文档的标题\n  typescript: true, // 支持 typescript 语法\n  themesDir: 'theme', // 主题样式放在哪个文件夹下，后面会讲\n  menu: ['快速上手', '业务组件'] // 生成文档的左侧菜单分类\n}</code></pre>\n<p>其中 files 规定了 docz 去对哪些文件进行编译生成文档，如果不做限制，会搜索项目中所有的 md、mdx 为后缀的文件生成文档，因此我在该文件中做了范围限制，避免一些 <code>README.md</code> 文件也被生成到文档中。</p>\n<p>此外还需要注意到两点：</p>\n<p>1、<code>menu: ['快速上手', '业务组件']</code> 对应着组件库左侧的菜单栏分类，比如在 mdx 文档中在最上面设置组件所属的菜单 <code>menu: 业务组件 </code>, 则 Button 组件属于 \"业务组件\" 的分类：</p>\n<pre><code class=\"markdown\">---\nname: Button\nroute: /button\nmenu: 业务组件\n---</code></pre>\n<p>在 src 中新建欢迎页，路由为跟路径，所属菜单为“快速上手”；</p>\n<pre><code class=\"markdown\">---\nname: 快速上手\nroute: /\n---</code></pre>\n<p>执行 <code>npm run docz:dev</code>，就可以打开</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676554\" alt=\"路由配置\" title=\"路由配置\" /></p>\n<p>介绍到这里，估计有小伙伴会有疑问了，这样生成的网站千篇一律，能否随心所欲的自定义网站的样式和功能呢？当初我也有这种疑问，经过多次尝试，皇天不负苦心人，终于摸索出如下方法：</p>\n<p><strong>1、修改 docz 文档本身的样式</strong></p>\n<p>根据 docz 官方文档中<a href=\"https://www.docz.site/docs/gatsby-theme\" rel=\"nofollow noreferrer\">增加 logo 的方法</a>[6]，可以通过自定义组件覆盖原有组件的形式：</p>\n<blockquote>\n Example: If you're using our gatsby-theme-docz which has a Header component located at src/components/Header/index.js you can override the component by creating src/gatsby-theme-docz/components/Header/index.js. Cool right?\n</blockquote>\n<p>所以根据 docz 源代码主题部分代码： <code>https://github.com/doczjs/docz/tree/master/core/gatsby-theme-docz/src</code>，找到对应的文档组件的代码结构，在组件库项目根目录新建同名称的文件夹：</p>\n<pre><code class=\"js\">|-theme\n|  |-gatsby-theme-docz\n|     |-components\n|     |-Header\n|       |-index.js // 在这里修改自定义的文档组件\n|       |-styles.js // 在这里修改生成的样式文件</code></pre>\n<p>这样在执行 <code>npm run docz:dev</code> 的时候，就会把自定义的代码覆盖原有样式，实现文档的多样化。</p>\n<p><strong>2、修改 markdown 文档样式</strong></p>\n<p>事情到这里就结束了吗？不！我们的目标不仅如此，因为我发现自动生成的 markdown 格式，并不符合我的审美，比如生成的表格文字居左对齐，并且整个表格样式单一，但是这里属于 markdown 样式的范畴，修改上述文档组件中并不包括这里的代码，那么如何修改 markdown 生成文档的样式呢？</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676556\" alt=\"docz默认生成表格样式\" title=\"docz默认生成表格样式\" /></p>\n<p>经过我灵机一动又一动，发现既然在上面修改文档组件样式的时候，重写了 component/Header/styles.js 文件，是否可以在该文件中引入自定义的样式呢？文件结构如下：</p>\n<pre><code class=\"js\">|-theme\n|  |-gatsby-theme-docz\n|     |-components\n|     |-Header\n|       |-index.js // 在这里修改自定义的文档组件\n|       |-styles.js // 在这里修改生成的样式文件\n|       |-base.css  // 这里修改 markdown 生成文档的样式</code></pre>\n<p>这样修改后的表格样式如下：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676558\" alt=\"修改docz表格样式\" title=\"修改docz表格样式\" /></p>\n<p>接下来各位小主可以根据自己的审美或者视觉设计的要求自定义文档的样式了。</p>\n<h3>六、部署文档到服务器</h3>\n<p>生成的组件库文档只在本地显示是没有意义的，所以需要部署到服务器上，于是第一时间想到的是放在 github 进行托管，打开 github 中的 setting 设置选项，GitHub Pages 设置配置的分支：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676557\" alt=\"设置分支\" title=\"设置分支\" /></p>\n<p>这时默认打开的首页路径为：</p>\n<p><code>https://plusui.github.io/plusReact/</code></p>\n<p>但实际上页面有效的访问地址是带有文件夹 docsite 路径的：</p>\n<p><code>https://plusui.github.io/plusReact/docsite/button/index.html</code></p>\n<p>此外，页面引入的其他资源路径，都是绝对路径，如下图资源路径所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676559\" alt=\"引入资源路径\" title=\"引入资源路径\" /></p>\n<p>所以直接把打包后的资源放在 github 上是无法访问各种资源的。<br>这时我们只好把网站部署到云服务器上了，考虑到服务器配置的繁琐，这里给大家提供一个简便的部署网站：<a href=\"https://app.netlify.com/teams/zhenyulei/sites\" rel=\"nofollow noreferrer\">Netlify</a>[7]</br></p>\n<p>Netlify 是一个提供静态网站托管的服务，提供 CI 服务，能够将托管 GitHub，GitLab 等网站上的 Jekyll，Hexo，Hugo 等静态网站。</p>\n<p>部署项目的过程也很简单，傻瓜式的点击选择 github 网站中代码路径，以及配置文件夹跟路径，如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676560\" alt=\"配置文件夹路径\" title=\"配置文件夹路径\" /></p>\n<p>然后就可以点击生成的网站 url，访问到部署的网站了：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676562\" alt=\"部署网站\" title=\"部署网站\" /></p>\n<p>而且很方便的是，一旦完成部署之后，之后再次向代码库中提交代码，Netlify 会自动更新网站。<br>此外，如果想自定义 url，那么就只能去申请域名了，在自己的云服务器上，解析域名即可。下面简单说一下配置步骤：</br></p>\n<p>1）首先在 Netlify 网站上，选择组件库对应的 Domain settings 下 Custom domains，增加自己的域名：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676561\" alt=\"配置域名\" title=\"配置域名\" /></p>\n<p>2）然后打开云服务器中的域名解析中的解析设置，将该域名指向 Netlify：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676564\" alt=\"云服务器上增加域名\" title=\"云服务器上增加域名\" /></p>\n<p>3）最后打开设置的网址，就可以访问到组件库了：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676563\" alt=\"最终效果\" title=\"最终效果\" /></p>\n<h3>七、组件按需加载</h3>\n<p>好了，经过上面的流程，可以在 demo 项目中使用组件库了，但是在 demo 项目中，执行 <code>npm run build</code> ，就会发现生成的静态资源中即使只使用了一个组件，也会把 reactui 组件库中所有的组件打包进来。</p>\n<p><strong>所以如何进行按需加载呢？</strong></p>\n<p>按需加载首先映入脑海的是使用 <code>babel-plugin-import</code> 插件, 该插件可以在 Babel 配置中针对组件库进行按需加载.</p>\n<p>用户需要安装 <code>babel-plugin-impor</code> 插件，然后在 plugins 中加入配置：</p>\n<pre><code class=\"js\">\"plugins\": [\n  [\n    \"import\",\n    {\n      \"libraryName\": \"reactui\", // 转换组件库的名字\n      \"libraryDirectory\": \"dist/components\", // 转换的路径\n      \"camel2DashComponentName\":false,  // 设置为 false 来阻止组件名称的转换\n      \"style\":true\n    }\n  ]\n]</code></pre>\n<p>这样在 demo 项目中使用如下方式：</p>\n<pre><code class=\"js\">import { Button } from 'reactui';</code></pre>\n<p>就会在 babel 中编译成：</p>\n<pre><code class=\"js\">import { Button } from 'reactui/dist/components/Button';\nrequire('reactui/dist/components/Button/style');</code></pre>\n<p>但是这样还有些弊端：</p>\n<p>1、 用户在使用组件库的时候还需要安装 <code>babel-plugin-import</code>， 并做相关 plugins 配置；</p>\n<p>2、 开发组件库的时候组件对应的样式文件还需要放在 style 文件夹下；</p>\n<p>那有没有更为简单的方法呢？在 ant-design 中寻找答案，发现这样一句话 “antd 的 JS 代码默认支持基于 ES modules 的 tree shaking”。 对呀！还可以使用 webpack 的新技术“tree shaking”。</p>\n<blockquote>\n 什么是 tree shaking？ AST 对 JS 代码进行语法分析后得出的语法树 (Abstract Syntax Tree)。AST 语法树可以把一段 JS 代码的每一个语句都转化为树中的一个节点。DCE Dead Code Elimination，在保持代码运行结果不变的前提下，去除无用的代码。\n</blockquote>\n<p>webpack 4x 中已经使用了 tree shaking 技术，我们只需要在 package.json 文件中配置参数 <code>\"sideEffects\": false</code>，来告诉 webpack 打包的时候可以大胆的去掉没有用到的模块即可。这时用户在 demo 项目中使用组件库的时候不需要做任何处理，就可以按需引用 JS 资源了。<br>不知道大家在看到这里时，是否发现这样配置还是有问题的：即 sideEffects 配置成 false 是有问题的。<br>因为按照上述配置，就会发现组件的样式不见了！！</br></br></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023676565\" alt=\"样式无效\" title=\"样式无效\" /></p>\n<p>经过排查，原因是引入 CSS 样式的代码：<code>import './button.scss'</code>，可以看到相当于只是引入了样式，并不像其他 JS 模块后面做了调用，在 tree shaking 的时候，会把 css 样式去掉。所以在配置 sideEffects 就要把 CSS 文件排除掉：</p>\n<pre><code class=\"js\">\"sideEffects\": [\n  \"*.scss\"\n]</code></pre>\n<p>通过上述 tree shaking 的方法，可以实现组件库的按需加载功能，打包的文件去除了没有用到的组件代码，同时省去了用户的配置。</p>\n<h3>八、样式按需加载</h3>\n<p>通常来说，组件库的 JS 是按需加载的，但是样式文件一般只输出一个文件，即把组件库中的所有文件打包编译成一个 index.css 文件，用户在项目中引入即可；但是如果就是想做按需加载组件的样式文件，该如何去做呢？</p>\n<p>这里我提供一种思路，由于 .tsx 文件是由 TS 编译器打包编译的，并没有处理 SCSS，所以我使用了 node-sass 来编译 SCSS 文件，如果需要按需加载 SCSS 文件，则每个组件的 index.tsx 文件中就需要引入对应的 SCSS 文件：</p>\n<pre><code class=\"js\">import Button from './button';\nimport './button.scss';\nexport default Button;</code></pre>\n<p>生成的 SCSS 文件也需要打包到每个组件中，而不是生成到一个文件中：</p>\n<p>所以使用了 node-sass 中的 sass.render 函数，抽取每个文件中的样式文件，并打包编译到对应的文件中，代码如下所示：</p>\n<pre><code class=\"js\">//省略 import 引入,核心代码如下\nfunction createCss(name){\n    const lowerName = name.toLowerCase();\n    sass.render({ // 调用 node-sass 函数方法，编译指定的 scss 文件到指定的路径下\n        file: currPath(`../src/components/${name}/${lowerName}.scss`),\n        outputStyle: 'compressed', // 进行压缩\n        sourceMap: true,\n    },(err,result)=&gt;{\n        if(err){\n            console.log(err);\n        }\n        const stylePath = `../dist/components/${name}/`;\n        fs.writeFile(currPath(stylePath+`/${lowerName}.scss`), result.css, function(err){\n            if(err){\n                console.log(err);\n            }\n        });\n    });\n}</code></pre>\n<p>这样就在生成的 dist 文件中的每个组件中增加了 SCSS 文件，用户通过“按需加载小节”中的方法在引入组件的时候，会调用对应的 index 文件，在 index.js 文件中就会调用对应的 SCSS 文件，从而也实现了样式文件的按需加载。</p>\n<p>但是这样还有一个问题，就是在开发组件库的时候每个组件中的 index.tsx 文件中引入的是 SCSS 文件 <code>import './button.scss';</code> ，所以 node-sass 编译后的文件需要是 SCSS 后缀的文件（虽然已经是 CSS 格式），如果生成的是 CSS 文件，则用户在使用组件的时候就会因找不到 SCSS 文件而报错，也就是用户在使用组件的时候，也需要安装 node-sass 插件。<br>不知大家有没有更好的办法，在组件库开发的时候使用的是 SCSS 文件，编译后生成的是 CSS 后缀的文件，在用户使用组件的中调用的也是 CSS 文件呢？欢迎在文末留言讨论～</br></p>\n<h3>结语</h3>\n<p>以上就是整个搭建组件库的过程，从一开始决定使用现有的 create-react-app 脚手架和 docz 来构成核心功能，到文档的网站部署和 npm 资源的发布，最初感觉应该能够快速完成整个组件库的搭建，实际上如果要想改动这些现有的库来实现自己想要的效果，还是经历了一些探索，不过整个摸索过程也是一种收获和乐趣所在，愿走过路过的小伙伴能有所收获～</p>\n<h3>参考文章</h3>\n<p>[1] NutUI 组件库: <a href=\"http://nutui.jd.com/#/index\" rel=\"nofollow noreferrer\">http://nutui.jd.com/#/index</a></p>\n<p>[2] yep-react 组件库: <a href=\"http://yep-react.jd.com\" rel=\"nofollow noreferrer\">http://yep-react.jd.com</a></p>\n<p>[3] react 官方网站: <a href=\"https://reactjs.org/warnings/invalid-hook-call-warning.html\" rel=\"nofollow noreferrer\">https://reactjs.org/warnings/...</a></p>\n<p>[4] storybook: <a href=\"https://storybook.js.org/\" rel=\"nofollow noreferrer\">https://storybook.js.org/</a></p>\n<p>[5] docz: <a href=\"https://www.docz.site/\" rel=\"nofollow noreferrer\">https://www.docz.site/</a></p>\n<p>[6] docz 官方文档: <a href=\"https://www.docz.site/docs/gatsby-theme\" rel=\"nofollow noreferrer\">https://www.docz.site/docs/ga...</a></p>\n<p>[7] Netlify: <a href=\"https://app.netlify.com/teams/zhenyulei/sites\" rel=\"nofollow noreferrer\">https://app.netlify.com/teams...</a></p>\n<p>[8]基于 Storybook 5 打造组件库开发与文档站建设小结: <a href=\"http://jelly.jd.com/article/5f06fe8505541b015b6a708a\" rel=\"nofollow noreferrer\">http://jelly.jd.com/article/5...</a></p>","descriptionType":"html","publishedDate":"Wed, 19 Aug 2020 01:00:00 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023676550","linkMd5":"c737187f4a9de041a952fc2de76447f5","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn2@2020_3/2020/08/24/23-08-22-747_a6db2e4da23bc72a.webp","destWidth":800,"destHeight":323,"sourceBytes":30082,"destBytes":7094,"author":"京东设计中心JDC","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023676550":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn2@2020_3/2020/08/24/23-08-22-747_a6db2e4da23bc72a.webp","https://segmentfault.com/img/remote/1460000023676551":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn14@2020_5/2020/08/24/23-08-30-685_b578e1f4a1bcc92e.webp","https://segmentfault.com/img/remote/1460000023676552":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn10@2020_2/2020/08/24/23-08-30-890_4c734adeed2c35c9.webp","https://segmentfault.com/img/remote/1460000023676555":"https://cdn.jsdelivr.net/gh/myreaderx/cdn26@2020_5/2020/08/24/23-08-31-078_44b46b0331cb728c.webp","https://segmentfault.com/img/remote/1460000023676553":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn6@2020_5/2020/08/24/23-08-30-950_7610edbe97df9755.webp","https://segmentfault.com/img/remote/1460000023676554":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn30@2020_5/2020/08/24/23-08-30-953_c58330355fbc3305.webp","https://segmentfault.com/img/remote/1460000023676556":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn22@2020_1/2020/08/24/23-08-30-886_927b33d1efd81a57.webp","https://segmentfault.com/img/remote/1460000023676558":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn88@2020_6/2020/08/24/23-08-44-191_7a2abde1a113f500.webp","https://segmentfault.com/img/remote/1460000023676557":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn18@2020_6/2020/08/24/23-08-30-898_7f8fc8b01d6f5da7.webp","https://segmentfault.com/img/remote/1460000023676559":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn83@2020_4/2020/08/24/23-08-44-531_3579403f639c7f72.webp","https://segmentfault.com/img/remote/1460000023676560":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn56@2020_1/2020/08/24/23-08-43-795_6fb596722509c584.webp","https://segmentfault.com/img/remote/1460000023676562":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn71@2020_5/2020/08/24/23-08-44-474_56f279fc9b89be8a.webp","https://segmentfault.com/img/remote/1460000023676561":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn76@2020_4/2020/08/24/23-08-44-872_34e1f70a34f32d2c.webp","https://segmentfault.com/img/remote/1460000023676564":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn60@2020_5/2020/08/24/23-08-44-070_4c20e67204c9c665.webp","https://segmentfault.com/img/remote/1460000023676563":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn64@2020_6/2020/08/24/23-08-44-213_2c7c0f8d1664550e.webp","https://segmentfault.com/img/remote/1460000023676565":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn79@2020_6/2020/08/24/23-08-44-563_3b2757439dfe26eb.webp"},"publishedOrCreatedDate":1598310388563},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"2020 年最牛逼的 10 门编程语言","link":"https://segmentfault.com/a/1190000023699206","description":"<blockquote>\n 先看再点赞，给自己一点思考的时间，微信搜索【\n <strong>沉默王二</strong>】关注这个有颜值却假装靠才华苟且的程序员。\n <br>本文&nbsp;<strong>GitHub</strong>&nbsp;<a href=\"https://github.com/itwanger/itwanger.github.io\" rel=\"nofollow noreferrer\">github.com/itwanger</a>&nbsp;已收录，里面还有我精心为你准备的一线大厂面试题。</br>\n</blockquote>\n<p>对于很多初学编程的人来说，尤其是马上要入学的大一新生来说，选择哪门子编程语言实在是个痛苦的事。选择对了，毕业后顺利找到工作，完美走向职场；选择错了，毕业后受伤的才华无处安放，大学算是虚度光阴了。</p>\n<p>前一段时间哈，我有个远房的亲戚，她家的小孩非要让我指导一下。然后就带了一本书来见我，看了一下封面，我惊呆了。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023699209\" alt=\"\" title=\"\" /></p>\n<p>《易语言从入门到精通》。这是哪门子编程语言，我第一次见到！不敢怠慢，也担心亲戚说我孤陋寡闻，偷偷地搜了一下。易语言的创始人是吴涛，国内为数不多的推崇中文编程语言的程序员大佬。</p>\n<p>郑重其事地说，我是个三观很正的人，绝没有半点虚情假意。但我实在不忍心看我这远房表弟误入歧途，毕竟易语言即便是入门了，甚至是精通了，将来也不一定能找到工作啊！</p>\n<p>当做兴趣爱好学编程固然好，值得称赞。我这表弟虽然学习不咋滴，年纪轻轻，初中毕业，但据亲戚反馈，酷爱编程，酷爱计算机（也不确定是不是酷爱打游戏）。易语言这本书也是他自己在网上买的。</p>\n<p>我有点担心地问他：“能看懂吗？”</p>\n<p>表弟不假思索，信誓旦旦地回答：“能啊！”</p>\n<p>我随手翻了翻这边书，发现书签已经夹在第 202 页，我天呐，真的有在看啊，看了将近一半了。</p>\n<p>必须得负责任啊，我就对亲戚和表弟说，“你看，要不咱换个编程语言吧，比如说 Java！”</p>\n<p>亲戚一脸惊愕，“你说哈？”</p>\n<p>我只好无奈地将脸迈向我这表弟，只听他娓娓道来：“J-A-V-A！”</p>\n<p>“哎呀，不错啊，真的私底下有研究！”我心中暗暗佩服起来了我这表弟。真看不出来，挺爱学的嘛。</p>\n<p>“别看这本易语言了，当做兴趣学编程没问题，可咱学习是为了啥，就是为了以后能找份工作，虽然我说得比较俗气。如果说确实对编程感兴趣的话，买点 Java 方面的书读一读。”我语重心长地建议。</p>\n<p>表弟深以为然地点点头。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023699210\" alt=\"\" title=\"\" /></p>\n<p>之所以说这件事，就是想告诉同学们，努力固然重要，但选择必须要对，一旦选择错了，那很多努力都是白费。</p>\n<p>那，这篇文章就是来给同学们提个醒，2020 年最牛逼的编程语言是什么？看完后你就知道该如何地去选择了。</p>\n<p>先来个简要的概括：</p>\n<ul>\n <li>Java，服务器端最好的编程语言</li>\n <li>C++，最通用的编程语言</li>\n <li>C，迄今为止，最值得信任的编程语言</li>\n <li>Python，AI（人工智能）、机器学习方向最佳的编程语言</li>\n <li>JavaScript，客户端最常用的脚本语言</li>\n <li>C#，微软最强有力的面向对象编程语言</li>\n <li>Swift，IOS 端最高效的编程语言</li>\n <li>GO（Golang），可扩展的编程语言，谷歌出品</li>\n <li>PHP，世界上最好的编程语言，不，最好用的 Web 编程语言</li>\n <li>Ruby，数据科学方面最可靠的编程语言</li>\n</ul>\n<p>为什么我会选择这 10 门编程语言？可不是我收了这些编程语言的钱，故意让它们上榜的，我是有足够多的理由的。</p>\n<p>首先来看一下 TIOBE 排行榜，非常非常权威的榜单，下面这 14 个是活得比较久的，可以看得出，除了 SQL 换成了 GO，其他 9 门编程语言都在，并且长期霸榜。<br><img src=\"https://segmentfault.com/img/remote/1460000023699211\" alt=\"\" title=\"\" /></br></p>\n<p>活得比较久，意味着这门编程语言的生命力比较顽强，生态系统比较完备，它们属于丛林的王者——物竞天择，适者生存嘛。它们活得久，并且活得好，那就意味着还能活得更好更久，是这个道理吧？强者更强！</p>\n<p>同学们尽管放心，我是负责任的——主要是这些编程语言的作者或者团队是负责任的，尽管开源 PHP 的官方团队已经在 2019 年底彻底解散了，但 PHP 依然很坚挺，很牛逼。</p>\n<p>下面让我来详细地说道说道这 10 门编程语言。</p>\n<h3>01、Java</h3>\n<p>Java 其实是 C++ 的一个替代品，Sun 公司原本想开发一种比 C++ 更简单的面向对象编程语言，起初叫 Oak。结果没想到，随着时间的流逝，因为 Java 更容易学习，跨平台，就导致 Java 的普及程度远远地超过了 C++。</p>\n<p>说句不那么优雅的话，就好像狗血剧里小三上位的桥段一样。</p>\n<p>在 Java 虚拟机的帮助下，Java 可以无障碍的在 Linux、Windows、Mac-OS 等多种操作系统下自由地穿梭，这使得它在企业级开发中非常受欢迎。</p>\n<p>Java 可以做网站开发、做安卓开发、做桌面级应用开发（Eclipse、NetBeans 等等）、做游戏开发（我的世界）。</p>\n<p>来一发 Java 版的 Hello World 吧：</p>\n<pre><code class=\"java\">public class HelloWorld {\n public static void main(String[] args) {\n  System.out.println(\"Hello World\");\n }\n}</code></pre>\n<h3>02、C++</h3>\n<p>C++，从名字上就可以看得出来，它是 C 语言的亲儿子，是对 C 语言的扩展，旨在为 C 语言创造出面向对象的功能。</p>\n<p>随着时间的发展，C++ 进一步发展为具有最直接的内存访问和完整硬件控制的通用语言。正因为 C++ 提供了最广泛的通用功能，就导致掌握起来有一定的难度。</p>\n<p>C++ 可以在所有的平台上运行，并且可以有效地利用任何类型的硬件，这使得它可以在资源受到限制的平台上发挥最佳性能。</p>\n<p>C++ 可以做游戏开发（星际争霸、魔兽争霸），办公软件（微软 Office）、操作系统（Windows）、关系型数据库（MySQL）、3D 引擎（Microsoft DirectX）、嵌入式开发。</p>\n<p>来一发 C++ 版的 Hello World 吧：</p>\n<pre><code class=\"c++\">#include&lt;iostream.h&gt;\nusing namespace std;\n \nvoid main() {\n    cout&lt;&lt;\"Hello World\";\n}</code></pre>\n<h3>03、C</h3>\n<p>C 语言诞生于 1960 年，作者团队对它只有一个要求：必须得通用，并且能够有效地利用系统资源。因为在那个年代，每一个字节的内存都是昂贵的。</p>\n<p>就像 C++ 那样，C 也可以直接访问内存并且控制硬件。C 和操作系统紧密相关，程序员必须亲自处理内存的分配细节，因此很难掌握。尽管 C 语言诞生的很早，但它仍然是目前最常用的编程语言之一。</p>\n<p>C 语言的设计影响了众多后来的编程语言，比如说 C++、Ruby、PHP、Python、Java、C# 等等。</p>\n<p>C 语言可以做嵌入式开发（单片机），基于嵌入式操作系统的应用软件、驱动程序，高性能的 Web 服务器（Nginx），常见的缓存数据库（Redis）、智能设备或者物联网设备中的操作系统（路由器、摄像头）等等。据说，反正能想到的，都可以用 C 做，就看会不会做。</p>\n<p>来一发 C 版的 Hello World 吧：</p>\n<pre><code class=\"c\">#include&lt;iostream.h&gt;\nvoid main()\n{\n    printf(\"Hello World\");\n}</code></pre>\n<h3>04、Python</h3>\n<p>Python 诞生于 1990 年，作者叫吉多·范罗苏姆（Guido van Rossum，Python 之父）。可以说，所有的编程人员都喜欢 Python，因为它的学习成本很低，但应用的等级很高，比如说当下非常有深度的人工智能、机器学习、数据分析。</p>\n<p>Python 的语法简洁而优雅，社区也非常活跃。但有一说一，<a href=\"https://mp.weixin.qq.com/s/HVr0RCu0tWQkySOquJiVsA\" rel=\"nofollow noreferrer\">Python 岗位对学历的要求很高</a>。</p>\n<p>来一发 Python 版的 Hello World 吧：</p>\n<pre><code class=\"python\">print(\"Hello World\")</code></pre>\n<h3>05、JavaScript</h3>\n<p>JavaScript 是 Brendan Eich（只用了 10 天时间就设计出来了，牛逼）在第一次浏览器大战时为 Netscape（网景公司）开发的脚本语言。尽管一开始 JavaScript 的设计不够优良（毕竟时间短啊），但随着时间的推移，JavaScript 逐渐发展为一种高级的动态编程语言。</p>\n<blockquote>\n 与其说我爱 Javascript，不如说我恨它。它是 C 语言和 Self 语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：'它的优秀之处并非原创，它的原创之处并不优秀。'\n</blockquote>\n<p>以上 Brendan Eich 对 JavaScript 的评价，读完是不是感觉好气啊——竟然看不起自己的亲生儿子，哈哈。</p>\n<p>有大佬曾说，“JavaScript 是互联网的胶带。”这个称赞非常高。HTML 负责结构， CSS 负责展示， 而 JavaScript 负责逻辑，网页前端编程的三剑客形成了。 </p>\n<p>ExtJS、prototype、JQuery 这些基于 JavaScript 的框架更是把 JavaScript 推向了巅峰。随着 Node.js 的出现，JavaScript 这种客户端的脚本语言竟然可以在服务器端立足了。</p>\n<p>现在非常火热的前端框架，Vue.js 就是用 JavaScript 编写的，可以这说，想从事前端开发工作的话，JavaScript 是必学的！</p>\n<p>来一发 JavaScript 版的 Hello World 吧：</p>\n<pre><code class=\"js\">&lt;script&gt;\n alert('Hello World');\n&lt;/script&gt;</code></pre>\n<h3>06、C</h3>\n<p>一看名字，就知道 C# 和 C/C++ 有着亲密的关系，微软把 C# 设计成具有面向对象的，像 C 一样的编程语言。</p>\n<p>最初，C# 被看作是 Java 的复制品，它们之间有着惊人的相似之处，比如说继承、接口，以及与 Java 几乎同样的语法，同样需要先编译后运行。随着时间的发展，以及微软为之付出的巨大努力， C# 沉淀了丰富的类库和框架，开发人员可以在此基础上快速地编写各种基于 .NET 平台的应用程序。</p>\n<p>随着 Unity3D 的出现，跨平台的 C# 终于可以大展拳脚了，在开发游戏方面的优势巨大，比如说编译速度快、类库充足。除此之外，要知道 C# 背后的大山是谁，微软啊！</p>\n<p>来一发 C# 版的 Hello World 吧：</p>\n<pre><code class=\"c#\">namespace HelloWorld\n{\n    class Hello\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World\");\n        }\n    }\n}</code></pre>\n<h3>07、Swift</h3>\n<p>关于 Swift，直接来看苹果官方给出的介绍吧：</p>\n<blockquote>\n Swift 是一种强劲而直观的编程语言，它由 Apple 创造，可用来为 iOS、Mac、Apple TV 和 Apple Watch 开发 app。它旨在为开发者提供充分的自由。Swift 易用并且开源，只要有想法，谁都可以创造非凡。\n</blockquote>\n<p>Swift 是一种快速而高效的语言，能够提供实时反馈，而且可以被无缝集成到现有的 Objective-C 代码中，因此，开发者能够编写安全而可靠的代码，并在节省时间的同时，创造出非常丰富的 app 体验。</p>\n<p>来一发 Swift 版的 Hello World 吧：</p>\n<pre><code class=\"swift\">print(\"Hello World\")</code></pre>\n<h3>08、Go</h3>\n<p>Go 的亲爹是 Google，又是一家互联网巨头，可以想象它未来的潜力。</p>\n<p>Go 语言的设计非常精致，用起来也非常简单，解决开发扩展方面的能力也比较出众。关键是学习起来也非常容易上手，这些优点促使 Go 语言的增长非常快。</p>\n<p>国外如 Google、AWS、Cloudflare、CoreOS 等，国内如七牛、阿里等都已经开始大规模使用 Golang 开发其云计算相关的产品。 可以说前途非常光明。</p>\n<p>来一发 Go 版的 Hello World 吧：</p>\n<pre><code class=\"go\">package main\nimport \"fmt\"\nfunc main() \n{\n     fmt.Println(\"Hello World\")\n}</code></pre>\n<h3>09、PHP</h3>\n<p>PHP 用来开发 Web 应用程序的历史已经超过 35 年了，可以说是老资历了。尽管最近流行度在下降，但瘦死的骆驼比马大。</p>\n<p>PHP 是最好的编程语言，这个梗是从哪里来的呢？显然不是吐槽大会！而是 PHP 的官方文档！</p>\n<blockquote>\n PHP is the best language for web programming, but what about other languages?\n</blockquote>\n<p>下图是 PHP 是最好的编程语言的确凿证据。<br><img src=\"https://segmentfault.com/img/remote/1460000023699212\" alt=\"\" title=\"\" /></br></p>\n<p>2010 年前后，PHP 在 Web 开发中一直处于王者的地位，尤其是 WordPress 等内容管理平台的流行，再加上“扎男”的 Facebook（PHP 开发的）的烘托，更加巩固了 PHP 在业界的地位。</p>\n<p>我在 2013 年 底准备回洛阳的时候，还学习了三个月的 PHP。时隔多年，下面这本书还躺在我家的书架上积灰。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023699213\" alt=\"\" title=\"\" /></p>\n<p>好了，来一发 PHP 版的 Hello World 吧：</p>\n<pre><code class=\"go\">&lt;?php\necho \"Hello World\";\n?&gt;</code></pre>\n<h3>10、Ruby</h3>\n<p>Ruby 最初是一种面向对象的脚本编程语言，但是随着时间的流逝，它逐渐发展成为一种解释性的高级通用编程语言。它的学习曲线相当平坦，非常有助于提高开发人员的生产力。</p>\n<p>Ruby 的作者松本行弘曾说过一段非常经典的话：</p>\n<blockquote>\n “ 人们特别是电脑工程师们，常常从机器着想。他们认为：‘这样做，机器就能运行的更快；这样做，机器运行效率更高；这样做，机器就会怎样怎样怎样。’实际上，我们需要从人的角度考虑问题，人们怎样编写程序或者怎样使用机器上应用程序。我们是主人，他们是仆人。 ”\n</blockquote>\n<p>Ruby 正是基于这种理念产生的。网上有句话是这样说的，学习 Ruby on Rails 能让你看到 Web 框架顶端的景色。听说，GitHub 官网是通过 Ruby on Rails 开发的（不准确，不知道有没有同学可以确认下）。</p>\n<p>JavaEye 的创始人范凯曾说：</p>\n<blockquote>\n 在我们国内，Ruby 是个小众的编程语言，但在硅谷，Ruby 很火，被誉为云计算时代的 Web 编程语言。\n</blockquote>\n<p>当然了，之所以把 Ruby 放在最后一位，同学们一定懂我的意思。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023699214\" alt=\"\" title=\"\"><br>最后，希望同学们能够从这 10 门编程语言中选择一门自己喜欢的，深入研究，无论是哪门语言，我相信，只要你精通了，就一定能够找到自己心仪的工作，如果你只是浅尝辄止，那就不好意思呵呵了。</br></img></p>\n<hr>\n <p>我是沉默王二，一枚有颜值却假装靠才华苟且的程序员。<strong>关注即可提升学习效率，别忘了三连啊，点赞、收藏、留言，我不挑，奥利给🌹</strong>。</p>\n <p>注：如果文章有任何问题，欢迎毫不留情地指正。</p>\n <p>如果你觉得文章对你有些帮助，欢迎微信搜索「<strong>沉默王二</strong>」第一时间阅读；本文&nbsp;<strong>GitHub</strong>&nbsp;<a href=\"https://github.com/itwanger/itwanger.github.io\" rel=\"nofollow noreferrer\">github.com/itwanger</a>&nbsp;已收录，欢迎 star。</p>\n</hr>","descriptionType":"html","publishedDate":"Thu, 20 Aug 2020 06:19:49 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023699209","linkMd5":"fbe29875f9063bd2517a65d848a2914c","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn51@2020_5/2020/08/24/23-08-22-960_ae361416bba7e1ff.webp","destWidth":459,"destHeight":412,"sourceBytes":216965,"destBytes":14810,"author":"沉默王二","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023699209":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn51@2020_5/2020/08/24/23-08-22-960_ae361416bba7e1ff.webp","https://segmentfault.com/img/remote/1460000023699210":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn26@2020_5/2020/08/24/23-08-43-739_f76cb0b6b146d3e0.webp","https://segmentfault.com/img/remote/1460000023699211":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn29@2020_5/2020/08/24/23-08-43-675_a2f4276387b1f0d3.webp","https://segmentfault.com/img/remote/1460000023699212":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn34@2020_6/2020/08/24/23-08-43-818_9d28dfb62c6fab5b.webp","https://segmentfault.com/img/remote/1460000023699213":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn38@2020_5/2020/08/24/23-08-43-614_dc0539cebd31b98e.webp","https://segmentfault.com/img/remote/1460000023699214":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn42@2020_1/2020/08/24/23-08-43-808_86b4044738c9cb37.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"浅入浅出Dubbo","link":"https://segmentfault.com/a/1190000023668057","description":"<h1>前言</h1>\n<p>接下来一段时间敖丙将带大家开启紧张刺激的 Dubbo 之旅！是的要开始写 Dubbo 系列的文章了，之前我已经写过一篇架构演进的文章，也说明了微服务的普及化以及重要性，服务化场景下随之而来的就是服务之间的通信问题，那服务间的通信脑海中想到的就是 RPC，说到 RPC 就离不开咱们的 Dubbo。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu96ukhevj30h203mmxm.jpg\" alt=\"\" title=\"\" /></p>\n<p>这篇文章敖丙先带着大家来<strong>总览全局</strong>，一般而言熟悉一个框架你要先知道这玩意是做什么的，能解决什么痛点，核心的模块是什么，大致运转流程是怎样的。</p>\n<p>你要一来就扎入细节之中无法自拔，一波 DFS 直接被劝退的可能性高达99.99%，所以本暖男敖丙将带大家先过一遍 <strong>Dubbo 的简介、总体分层、核心组件以及大致调用流程</strong>。</p>\n<p>不仅如此我还会带着大家过一遍如果要让你<strong>设计一个 RPC 框架你看看都需要什么功能</strong>？这波操作之后你会发现嘿嘿 Dubbo 怎么设计的和我想的一样呢？真是英雄所见略同啊！</p>\n<p>而且我还会写一个简单版 RPC 框架实现，让大家明白 RPC 到底是如何工作的。</p>\n<p>如果看了这篇文章你要还是不知道 Dubbo 是啥，我可以要劝退了。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu970lp1rj30me0hq494.jpg\" alt=\"\" title=\"\" /></p>\n<p>我们先来谈一谈什么叫 RPC ，我发现有很多同学不太了解这个概念，还有人把 RPC 和 HTTP 来进行对比。所以咱们先来说说什么是 RPC。</p>\n<h1>什么是 RPC</h1>\n<p>RPC，Remote Procedure Call 即远程过程调用，远程过程调用其实对标的是本地过程调用，本地过程调用你熟悉吧？</p>\n<p>想想那青葱岁月，你在大学赶着期末大作业，正在攻克图书管理系统，你奋笔疾书疯狂地敲击键盘，实现了图书借阅、图书归还等等模块，你实现的一个个方法之间的调用就叫本地过程调用。</p>\n<p>你要是和我说你实现图书馆里系统已经用了服务化，搞了远程调用了，我只能和你说你有点东西。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu973myg2j3073073q3c.jpg\" alt=\"\" title=\"\" /></p>\n<p>简单的说本机上内部的方法调用都可以称为本地过程调用，而远程过程调用实际上就指的是你本地调用了远程机子上的某个方法，这就是远程过程调用。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu975kcouj30ny0c074q.jpg\" alt=\"\" title=\"\" /></p>\n<p>所以说 RPC 对标的是本地过程调用，至于 RPC 要如何调用远程的方法可以走 HTTP、也可以是基于 TCP 自定义协议。</p>\n<p>所以说你讨论 RPC 和 HTTP 就不是一个层级的东西。</p>\n<p>而 <strong>RPC 框架就是要实现像那小助手一样的东西，目的就是让我们使用远程调用像本地调用一样简单方便，并且解决一些远程调用会发生的一些问题</strong>，使用户用的无感知、舒心、放心、顺心，它好我也好，快乐没烦恼。</p>\n<h1>如何设计一个 RPC 框架</h1>\n<p>在明确了什么是 RPC，以及 RPC 框架的目的之后，咱们想想如果让你做一款 RPC 框架你该如何设计？</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu978x2kog3064064tg4.gif\" alt=\"\" title=\"\" /></p>\n<h2>服务消费者</h2>\n<p>我们先从消费者方(也就是调用方)来看需要些什么，首先消费者面向接口编程，所以需要得知有哪些接口可以调用，可以通过<strong>公用 jar 包</strong>的方式来维护接口。</p>\n<p>现在知道有哪些接口可以调用了，但是只有接口啊，具体的实现怎么来？这事必须框架给处理了！所以还<strong>需要来个代理类</strong>，让消费者只管调，啥事都别管了，我<strong>代理帮你搞定</strong>。</p>\n<p>对了，还需要告诉代理，你调用的是哪个方法，并且参数的值是什么。</p>\n<p>虽说代理帮你搞定但是代理也需要知道它到底要调哪个机子上的远程方法，所以<strong>需要有个注册中心</strong>，这样调用方从注册中心可以知晓可以调用哪些服务提供方，一般而言提供方不止一个，毕竟只有一个挂了那不就没了。</p>\n<p>所以提供方一般都是集群部署，那调用方需要通过<strong>负载均衡</strong>来选择一个调用，可以通过<strong>某些策略</strong>例如同机房优先调用啊啥的。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97d1ky0j306g06dt9v.jpg\" alt=\"\" title=\"\" /></p>\n<p>当然还需要有<strong>容错机制</strong>，毕竟这是远程调用，网络是不可靠的，所以可能需要重试什么的。</p>\n<p>还要和服务提供方<strong>约定一个协议</strong>，例如我们就用 HTTP 来通信就好啦，也就是大家要讲一样的话，不然可能听不懂了。</p>\n<p>当然序列化必不可少，毕竟我们本地的结构是“立体”的，需要序列化之后才能传输，因此还需要<strong>约定序列化格式</strong>。</p>\n<p>并且这过程中间可能还需要掺入一些 Filter，来作一波统一的处理，例如调用计数啊等等。</p>\n<p>这些都是框架需要做的，让消费者像在调用本地方法一样，无感知。</p>\n<h2>服务提供者</h2>\n<p>服务提供者肯定要<strong>实现对应的接口</strong>这是毋庸置疑的。</p>\n<p>然后需要把自己的接口暴露出去，向<strong>注册中心注册自己</strong>，暴露自己所能提供的服务。</p>\n<p>然后有消费者请求过来需要处理，提供者需要用和消费者<strong>协商好的协议</strong>来处理这个请求，然后做<strong>反序列化</strong>。</p>\n<p>序列化完的请求应该<strong>扔到线程池里面做处理</strong>，某个线程接受到这个请求之后找到对应的实现调用，然后再<strong>将结果原路返回</strong>。</p>\n<h2>注册中心</h2>\n<p>上面其实我们都提到了注册中心，这东西就相当于一个平台，大家在上面暴露自己的服务，也在上面得知自己能调用哪些服务。</p>\n<p>当然还能做配置中心，将配置集中化处理，动态变更通知订阅者。</p>\n<h2>监控运维</h2>\n<p>面对众多的服务，精细化的监控和方便的运维必不可少。</p>\n<p>这点很多开发者在开发的时候察觉不到，到你真正上线开始运行维护的时候，如果没有良好的监控措施，快速的运维手段，到时候就是睁眼瞎！手足无措，等着挨批把！</p>\n<p>那种痛苦不要问我为什么知道，我就是知道！</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97gshgmj306o06o0so.jpg\" alt=\"\" title=\"\" /></p>\n<h2>小结一下</h2>\n<p>让我们小结一下，大致上一个 RPC 框架需要做的就是约定要通信协议，序列化的格式、一些容错机制、负载均衡策略、监控运维和一个注册中心！</p>\n<h1>简单实现一个 RPC 框架</h1>\n<p>没错就是简单的实现，上面我们在思考如何设计一个 RPC 框架的时候想了很多，那算是生产环境使用级别的功能需求了，我们这是 Demo，目的是突出 RPC框架重点功能 - <strong>实现远程调用</strong>。</p>\n<p>所以啥七七八八的都没，并且我用伪代码来展示，其实也就是删除了一些保护性和约束性的代码，因为看起来太多了不太直观，需要一堆 try-catch 啥的，因此我删减了一些，直击重点。</p>\n<p>Let's Do It！</p>\n<p>首先我们定义一个接口和一个简单实现。</p>\n<p>`public&nbsp;interface&nbsp;AobingService {&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;hello(String&nbsp;name);&nbsp;&nbsp; <br>}&nbsp; </br></br></p>\n<p>public&nbsp;class&nbsp;AobingServiceImpl&nbsp;implements&nbsp;AobingService {&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;hello(String&nbsp;name) {&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;\"Yo&nbsp;man&nbsp;Hello，I&nbsp;am\"&nbsp;+&nbsp;name;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; <br>}` </br></br></br></br></p>\n<p>然后我们再来实现服务提供者暴露服务的功能。</p>\n<p>`public&nbsp;class&nbsp;AobingRpcFramework {&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;export(Object&nbsp;service,&nbsp;int&nbsp;port)&nbsp;throws&nbsp;Exception {&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServerSocket&nbsp;server&nbsp;=&nbsp;new&nbsp;ServerSocket(port); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true)&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Socket&nbsp;socket&nbsp;=&nbsp;server.accept(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(new&nbsp;Runnable()&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//反序列化 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectInputStream&nbsp;input&nbsp;=&nbsp;new&nbsp;ObjectInputStream(socket.getInputStream());&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;methodName&nbsp;=&nbsp;input.read();&nbsp;//读取方法名 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class&lt;?&gt;[]&nbsp;parameterTypes&nbsp;=&nbsp;(Class&lt;?&gt;[])&nbsp;input.readObject();&nbsp;//参数类型 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object[]&nbsp;arguments&nbsp;=&nbsp;(Object[])&nbsp;input.readObject();&nbsp;//参数 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;method&nbsp;=&nbsp;service.getClass().getMethod(methodName,&nbsp;parameterTypes);&nbsp;&nbsp;//找到方法 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;result&nbsp;=&nbsp;method.invoke(service,&nbsp;arguments);&nbsp;//调用方法 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;返回结果 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutputStream&nbsp;output&nbsp;=&nbsp;new&nbsp;ObjectOutputStream(socket.getOutputStream()); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.writeObject(result); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).start(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;&lt;T&gt;&nbsp;T&nbsp;refer&nbsp;(Class&lt;T&gt;&nbsp;interfaceClass,&nbsp;String&nbsp;host,&nbsp;int&nbsp;port)&nbsp;throws&nbsp;Exception { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;(T)&nbsp;Proxy.newProxyInstance(interfaceClass.getClassLoader(),&nbsp;new&nbsp;Class&lt;?&gt;[]&nbsp;{interfaceClass},&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;InvocationHandler()&nbsp;{&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Object&nbsp;invoke(Object&nbsp;proxy,&nbsp;Method&nbsp;method,&nbsp;Object[]&nbsp;arguments)&nbsp;throws&nbsp;Throwable {&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Socket&nbsp;socket&nbsp;=&nbsp;new&nbsp;Socket(host,&nbsp;port);&nbsp;&nbsp;//指定&nbsp;provider&nbsp;的&nbsp;ip&nbsp;和端口 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutputStream&nbsp;output&nbsp;=&nbsp;new&nbsp;ObjectOutputStream(socket.getOutputStream());&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.write(method.getName());&nbsp;&nbsp;//传方法名 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.writeObject(method.getParameterTypes());&nbsp;&nbsp;//传参数类型 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output.writeObject(arguments);&nbsp;&nbsp;//传参数值 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectInputStream&nbsp;input&nbsp;=&nbsp;new&nbsp;ObjectInputStream(socket.getInputStream());&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;result&nbsp;=&nbsp;input.readObject();&nbsp;&nbsp;//读取结果 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; <br>} <br>`</br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></p>\n<p>好了，这个 RPC 框架就这样好了，是不是很简单？就是<strong>调用者传递了方法名、参数类型和参数值，提供者接收到这样参数之后调用对于的方法返回结果就好了</strong>！这就是远程过程调用。</p>\n<p>我们来看看如何使用</p>\n<p>`//服务提供者只需要暴露出接口 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AobingService&nbsp;service&nbsp;=&nbsp;new&nbsp;AobingServiceImpl&nbsp;();&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AobingRpcFramework.export(service,&nbsp;2333);&nbsp;&nbsp; </br></br></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//服务调用者只需要设置依赖 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AobingService&nbsp;service&nbsp;=&nbsp;AobingRpcFramework.refer(AobingService.class,&nbsp;\"127.0.0.1\",&nbsp;2333);&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;service.hello();` </br></br></p>\n<p>看起来好像好不错哟，不过这很是简陋，用作 demo 有助理解还是极好的！</p>\n<p>接下来就来看看 Dubbo 吧！上正菜！</p>\n<h1>Dubbo 简介</h1>\n<p>Dubbo 是阿里巴巴 2011年开源的一个基于 Java 的 RPC 框架，中间沉寂了一段时间，不过其他一些企业还在用 Dubbo 并自己做了扩展，比如当当网的 Dubbox，还有网易考拉的 Dubbok。</p>\n<p>但是在 2017 年阿里巴巴又重启了对 Dubbo 维护。在 2017 年荣获了开源中国 2017 最受欢迎的中国开源软件 Top 3。</p>\n<p>在 2018 年和 Dubbox 进行了合并，并且进入 Apache 孵化器，在 2019 年毕业正式成为 Apache 顶级项目。</p>\n<p>目前 Dubbo 社区主力维护的是 2.6.x 和 2.7.x 两大版本，2.6.x 版本主要是 bug 修复和少量功能增强为准，是稳定版本。</p>\n<p>而 2.7.x 是主要开发版本，更新和新增新的 feature 和优化，并且 2.7.5 版本的发布被 Dubbo 认为是里程碑式的版本发布，之后我们再做分析。</p>\n<p>它实现了面向接口的代理 RPC 调用，并且可以配合 ZooKeeper 等组件实现服务注册和发现功能，并且拥有负载均衡、容错机制等。</p>\n<h1>Dubbo 总体架构</h1>\n<p>我们先来看下官网的一张图。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97ntsacj30e00ak3yx.jpg\" alt=\"\" title=\"\" /></p>\n<p>本丙再暖心的给上图内每个节点的角色说明一下。</p>\n<p>节点</p>\n<p>角色说明</p>\n<p>Consumer</p>\n<p>需要调用远程服务的服务消费方</p>\n<p>Registry</p>\n<p>注册中心</p>\n<p>Provider</p>\n<p>服务提供方</p>\n<p>Container</p>\n<p>服务运行的容器</p>\n<p>Monitor</p>\n<p>监控中心</p>\n<p>我再来大致说一下整体的流程，首先服务提供者 <strong>Provider 启动然后向注册中心注册</strong>自己所能提供的服务。</p>\n<p>服务消费者 <strong>Consumer 启动向注册中心订阅</strong>自己所需的服务。然后注册中心将提供者元信息通知给 Consumer， 之后 Consumer 因为已经从注册中心获取提供者的地址，因此可以<strong>通过负载均衡选择一个 Provider 直接调用</strong> 。</p>\n<p>之后服务提供方元数据变更的话<strong>注册中心会把变更推送给服务消费者</strong>。</p>\n<p>服务提供者和消费者都会在内存中记录着调用的次数和时间，然后<strong>定时的发送统计数据到监控中心</strong>。</p>\n<h2>一些注意点</h2>\n<p>首先<strong>注册中心和监控中心是可选的</strong>，你可以不要监控，也不要注册中心，直接在配置文件里面写然后提供方和消费方直连。</p>\n<p>然后注册中心、提供方和消费方之间都是长连接，和监控方不是长连接，并且<strong>消费方是直接调用提供方，不经过注册中心</strong>。</p>\n<p>就算<strong>注册中心和监控中心宕机了也不会影响到已经正常运行的提供者和消费者</strong>，因为消费者有本地缓存提供者的信息。</p>\n<h1>Dubbo 分层架构</h1>\n<p>总的而言 Dubbo 分为三层，如果每一层再细分下去，一共有十层。别怕也就十层，本丙带大家过一遍，大家先有个大致的印象，之后的文章丙会带着大家再深入。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97sgc39j30e20csglg.jpg\" alt=\"\" title=\"\" /></p>\n<p>大的三层分别为 Business（业务层）、RPC 层、Remoting，并且还分为 API 层和 SPI 层。</p>\n<p>分为大三层其实就是和我们知道的网络分层一样的意思，<strong>只有层次分明，职责边界清晰才能更好的扩展</strong>。</p>\n<p>而分 API 层和 SPI 层这是 Dubbo 成功的一点，<strong>采用微内核设计+SPI扩展</strong>，使得有特殊需求的接入方可以自定义扩展，做定制的二次开发。</p>\n<p>接下来咱们再来看看每一层都是干嘛的。</p>\n<ul>\n <li>Service，业务层，就是咱们开发的业务逻辑层。</li>\n <li>Config，配置层，主要围绕 ServiceConfig 和 ReferenceConfig，初始化配置信息。</li>\n <li>Proxy，代理层，服务提供者还是消费者都会生成一个代理类，使得服务接口透明化，代理层做远程调用和返回结果。</li>\n <li>Register，注册层，封装了服务注册和发现。</li>\n <li>Cluster，路由和集群容错层，负责选取具体调用的节点，处理特殊的调用要求和负责远程调用失败的容错措施。</li>\n <li>Monitor，监控层，负责监控统计调用时间和次数。</li>\n <li>Portocol，远程调用层，主要是封装 RPC 调用，主要负责管理 Invoker，Invoker代表一个抽象封装了的执行体，之后再做详解。</li>\n <li>Exchange，信息交换层，用来封装请求响应模型，同步转异步。</li>\n <li>Transport，网络传输层，抽象了网络传输的统一接口，这样用户想用 Netty 就用 Netty，想用 Mina 就用 Mina。</li>\n <li>Serialize，序列化层，将数据序列化成二进制流，当然也做反序列化。</li>\n</ul>\n<h2>SPI</h2>\n<p>我再稍微提一下 SPI（Service Provider Interface），是 JDK 内置的一个服务发现机制，<strong>它使得接口和具体实现完全解耦</strong>。我们只声明接口，具体的实现类在配置中选择。</p>\n<p>具体的就是你定义了一个接口，然后在<code>META-INF/services</code>目录下<strong>放置一个与接口同名的文本文件</strong>，文件的内容为<strong>接口的实现类</strong>，多个实现类用换行符分隔。</p>\n<p>这样就通过配置来决定具体用哪个实现！</p>\n<p>而 Dubbo SPI 还做了一些改进，篇幅有限留在之后再谈。</p>\n<h1>Dubbo 调用过程</h1>\n<p>上面我已经介绍了每个层到底是干嘛的，我们现在再来串起来走一遍调用的过程，加深你对 Dubbo 的理解，让知识点串起来，由点及面来一波连连看。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97wrwzzj30aj08ydfv.jpg\" alt=\"\" title=\"\" /></p>\n<p>我们先从服务提供者开始，看看它是如何工作的。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97zzd7lj30fx0jzwed.jpg\" alt=\"\" title=\"\" /></p>\n<h2>服务暴露过程</h2>\n<p>首先 Provider 启动，通过 Proxy 组件根据具体的协议 Protocol 将需要暴露出去的接口封装成 Invoker，Invoker 是 Dubbo 一个很核心的组件，代表一个可执行体。</p>\n<p>然后再通过 Exporter 包装一下，这是为了在注册中心暴露自己套的一层，然后将 Exporter 通过 Registry 注册到注册中心。 这就是整体服务暴露过程。</p>\n<h2>消费过程</h2>\n<p>接着我们来看消费者调用流程（把服务者暴露的过程也在图里展示出来了，这个图其实算一个挺完整的流程图了）。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu983qeo1j30vj0kkjsj.jpg\" alt=\"\" title=\"\" /></p>\n<p>首先消费者启动会向注册中心拉取服务提供者的元信息，然后调用流程也是从 Proxy 开始，毕竟都需要代理才能无感知。</p>\n<p>Proxy 持有一个 Invoker 对象，调用 invoke 之后需要通过 Cluster 先从 Directory 获取所有可调用的远程服务的 Invoker 列表，如果配置了某些路由规则，比如某个接口只能调用某个节点的那就再过滤一遍 Invoker 列表。</p>\n<p>剩下的 Invoker 再通过 LoadBalance 做负载均衡选取一个。然后再经过 Filter 做一些统计什么的，再通过 Client 做数据传输，比如用 Netty 来传输。</p>\n<p>传输需要经过 Codec 接口做协议构造，再序列化。最终发往对应的服务提供者。</p>\n<p>服务提供者接收到之后也会进行 Codec 协议处理，然后反序列化后将请求扔到线程池处理。某个线程会根据请求找到对应的 Exporter ，而找到 Exporter 其实就是找到了 Invoker，但是还会有一层层 Filter，经过一层层过滤链之后最终调用实现类然后原路返回结果。</p>\n<p>完成整个调用过程！</p>\n<h1>总结</h1>\n<p>这次敖丙带着大家先了解了下什么是 RPC，然后规划了一波 RPC 框架需要哪些组件，然后再用代码实现了一个简单的 RPC 框架。</p>\n<p>然后带着大家了解了下 Dubbo 的发展历史、总体架构、分层设计架构以及每个组件是干嘛的，再带着大伙走了一遍整体调用过程。</p>\n<p>我真的是太暖了啊！</p>\n<p>dubbo近期我会安排几个章节继续展开，最后会出一个面试版本的dubbo，我们拭目以待吧。</p>\n<p>我是敖丙，你知道的越多，你不知道的越多，我们下期见！</p>\n<p><strong>人才</strong>们的 <strong>【三连】</strong> 就是敖丙创作的最大动力，如果本篇博客有任何错误和建议，欢迎人才们留言！</p>","descriptionType":"html","publishedDate":"Wed, 19 Aug 2020 01:00:00 +0000","feedId":6615,"bgimg":"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu96ukhevj30h203mmxm.jpg","linkMd5":"dcb1ca1d6d9e74559b1305ed3b0d3469","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn98@2020_2/2020/08/24/23-08-21-517_8f13d8b07f643ac5.webp","destWidth":614,"destHeight":130,"sourceBytes":16877,"destBytes":8954,"author":"敖丙","articleImgCdnMap":{"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu96ukhevj30h203mmxm.jpg":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn98@2020_2/2020/08/24/23-08-21-517_8f13d8b07f643ac5.webp","https://tva1.sinaimg.cn/large/007S8ZIlly1ghu970lp1rj30me0hq494.jpg":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn100@2020_1/2020/08/24/23-08-38-382_bd6c3dce7d6e55b1.webp","https://tva1.sinaimg.cn/large/007S8ZIlly1ghu973myg2j3073073q3c.jpg":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn38@2020_2/2020/08/24/23-08-31-068_4b19e03c9a05d1ad.webp","https://tva1.sinaimg.cn/large/007S8ZIlly1ghu975kcouj30ny0c074q.jpg":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn54@2020_5/2020/08/24/23-08-30-913_c03142b1c5b40ef9.webp","https://tva1.sinaimg.cn/large/007S8ZIlly1ghu978x2kog3064064tg4.gif":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn12@2020_2/2020/08/24/23-08-45-134_20348afea74325a7.webp","https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97d1ky0j306g06dt9v.jpg":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn82@2020_4/2020/08/24/23-08-41-795_8c6bb5bc6317c8dc.webp","https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97gshgmj306o06o0so.jpg":"https://cdn.jsdelivr.net/gh/myreaderx/cdn16@2020_4/2020/08/24/23-08-43-891_cf34405c50ce7960.webp","https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97ntsacj30e00ak3yx.jpg":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn77@2020_2/2020/08/24/23-08-28-534_9ec7e1fd07438993.webp","https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97sgc39j30e20csglg.jpg":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn60@2020_1/2020/08/24/23-08-41-132_634987b590838a90.webp","https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97wrwzzj30aj08ydfv.jpg":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn12@2020_3/2020/08/24/23-08-40-518_f5f7dfcb6fc90747.webp","https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97zzd7lj30fx0jzwed.jpg":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn35@2020_1/2020/08/24/23-08-40-294_a6171109d968ad49.webp","https://tva1.sinaimg.cn/large/007S8ZIlly1ghu983qeo1j30vj0kkjsj.jpg":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn45@2020_3/2020/08/24/23-08-30-738_7fa453e24c96970a.webp"},"publishedOrCreatedDate":1598310388562},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"思否开源项目推介丨Gitako：开源、免费的文件树插件","link":"https://segmentfault.com/a/1190000023652718","description":"<p><img src=\"https://segmentfault.com/img/bVbLphW\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n<blockquote>\n 开源项目名称：Gitako \n <br>开源项目负责人：@Enix <br>开源项目简介：开源、免费的文件树插件 <br>开源项目类型：个人开源项目<br>项目创建时间：2019 年 <br>GitHub 数据：301 Star，27 Fork <br>GitHub 地址：<a href=\"https://github.com/EnixCoda/Gitako\" rel=\"nofollow noreferrer\">https://github.com/EnixCoda/G...</a></br></br></br></br></br></br>\n</blockquote>\n<h2>项目介绍</h2>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023652721\" alt=\"wnpXiEISZ4xgh92\" title=\"wnpXiEISZ4xgh92\" /></p>\n<p>Gitako 是一款开源、免费的文件树插件，以完善 GitHub 功能为目标，可以让你的 GitHub 浏览体验更上一层楼。</p>\n<h4>1. 特性</h4>\n<ul>\n <li>📂 通过文件树展示仓库或 Pull Request 相关的文件</li>\n <li>🔎 极速搜索文件，在其间快速跳转</li>\n <li>🕶️ 支持私有仓库、企业版 GitHub、Gitee</li>\n <li>🏎 即使在巨型项目中也流畅无比</li>\n <li>⌨️ 内置符合直觉的快捷键</li>\n <li>🗂 支持 git submodule</li>\n <li>↔️ 尺寸可按需调整</li>\n <li>📋 复制代码、文件内容的按钮</li>\n <li>🎨 友好的界面、丰富的图标</li>\n</ul>\n<h4>2. 安装&amp;源码</h4>\n<p><a href=\"https://chrome.google.com/webstore/detail/gitako-github-file-tree/giljefjcheohhamkjphiebfjnlphnokk\" rel=\"nofollow noreferrer\">Chrome、</a><a href=\"https://addons.mozilla.org/en-US/firefox/addon/gitako-github-file-tree/\" rel=\"nofollow noreferrer\">Firefox、</a><a href=\"https://github.com/EnixCoda/Gitako\" rel=\"nofollow noreferrer\">GitHub</a></p>\n<h4>3. 名称与图标的来历？</h4>\n<p>GitHub 的图标是一只猫头章鱼身的“神兽”。Gitako 的定位就像是这只神兽身上的一只触手，图标正是表现了这一寓意。关于名字，章鱼在日语中叫做 <code>タコ(tako)</code>，再增加前缀 <code>git</code> ：</p>\n<p><code>git + tako =&gt; gitako</code></p>\n<h2>思否推荐</h2>\n<p>程序员们在使用 GitHub 浏览一些比较复杂的开源项目源码时，会遇到目录多导致的重复点击切换问题，非常浪费时间。如果有类似文档阅读的侧边栏导航工具，通过侧边点击目录，快捷展开跳转到对应的源码，那真的就方便很多。</p>\n<p>gitako 插件可以帮助我们通过文件树展示仓库或 Pull Request 相关的文件，提高搜索文件、复制代码和相关文件内容的速度，无疑是提升开发者们效率的优质工具。</p>\n<p><img src=\"https://segmentfault.com/img/bVbHZSb\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>\n<p>该项目已入选<a href=\"https://segmentfault.com/a/1190000022680721\">「SFOSSP - 思否开源项目支持计划」</a>，我们希望借助社区的资源对开源项目进行相关的宣传推广，并作为一个长期项目助力开源事业的发展，与广大开发者共建开源新生态。</p>\n<p>有意向的开源项目负责人或团队成员，可通过邮箱提供相应的信息（开源项目地址、项目介绍、团队介绍、联系方式等），以便提升交流的效率。</p>\n<p>联系邮箱：pr@segmentfault.com</p>\n<p><img src=\"https://segmentfault.com/img/bVbJgYT\" alt=\"clipboard.png\" title=\"clipboard.png\" /></p>","descriptionType":"html","publishedDate":"Mon, 17 Aug 2020 02:36:38 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLphW","linkMd5":"edffa444454de4e48a3d973ca7297088","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn55@2020_5/2020/08/24/23-08-22-420_8237a8f2bc153c7c.webp","destWidth":800,"destHeight":430,"sourceBytes":25107,"destBytes":4332,"author":"徐九","articleImgCdnMap":{"https://segmentfault.com/img/bVbLphW":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn55@2020_5/2020/08/24/23-08-22-420_8237a8f2bc153c7c.webp","https://segmentfault.com/img/remote/1460000023652721":null,"https://segmentfault.com/img/bVbHZSb":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn68@2020_4/2020/08/24/23-08-37-572_9328baa6c41eb7d7.webp","https://segmentfault.com/img/bVbJgYT":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn92@2020_2/2020/08/24/23-08-40-881_7f8323e1c3c7e5a5.webp"},"publishedOrCreatedDate":1598310388565},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"【译】使用Kotlin从零开始写一个现代Android 项目-Part1","link":"https://segmentfault.com/a/1190000023708775","description":"<h3>前言</h3>\n<p>经常在medium.com上看到一些高质量的技术帖子，但是由于国内的上网环境或者有的同学对于看英文比较排斥，错过了不少好文章。因此，西哥决定弄一个《优质译文专栏》，花一些时间翻译一些优质技术文给大家。这篇文章是一个小系列，用Kotlin开发现代Android APP,总共四篇，后面的会陆续翻译！以下是正文。</p>\n<p>现在，真的很难找到一个涵盖所有Android新技术的项目，因此我决定自己来写一个，在本文中，我们将用到如下技术：</p>\n<ul>\n <li>0 、Android Studio</li>\n <li>1、Kotlin 语言</li>\n <li>2、构建变体</li>\n <li>3、ConstraintLayout</li>\n <li>4、DataBinding库</li>\n <li>5、MVVM+repository+Android Manager架构模式</li>\n <li>6、RxJava2及其对架构的帮助</li>\n <li>7、Dagger 2.11，什么是依赖注入？为什么要使用它？</li>\n <li>8、Retrofit + RxJava2 实现网络请求</li>\n <li>9、RooM + RxJava2 实现储存</li>\n</ul>\n<h5>我们的APP最终是什么样子？</h5>\n<p>我们的APP是一个非常简单的应用程序，它涵盖了上面提到的所有技术。只有一个简单的功能：从Github 获取<code>googlesamples</code>用户下的所有仓库，将数据储存到本地数据库，然后在界面展示它。</p>\n<p>我将尝试解释更多的代码，你也可以看看你Github上的代码提交。</p>\n<p>Github:<a href=\"https://github.com/mladenrakonjac/ModernAndroidApp/tags\" rel=\"nofollow noreferrer\">https://github.com/mladenrako...</a></p>\n<p>让我们开始吧。</p>\n<h3>0、Android Studio</h3>\n<p>首先安卓Android Studio 3 beta 1(注：现在最新版为Android Studio 4.0),Android Studio 已经支持Kotlin，去到<code>Create Android Project</code>界面，你将在此处看到新的内容：带有标签的复选框<code>include Kotlin support</code>。默认情况下选中。按两次下一步，然后选择<code>EmptyActivity</code>，然后完成了。 恭喜！你用Kotlin开发了第一个Android app)</p>\n<h3>1、Kotlin</h3>\n<p>在刚才新建的项目中，你可以看到一个<code>MainActivity.kt</code>:</p>\n<pre><code class=\"kotlin\">package me.mladenrakonjac.modernandroidapp\n\nimport android.support.v7.app.AppCompatActivity\nimport android.os.Bundle\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}</code></pre>\n<p><code>.kt</code>后缀代表了这是一个Kotlin文件</p>\n<p><code>MainActivity : AppCompatActivity() </code>表示我们的<code>MainActivity</code>继承自<code>AppCompatActivity</code> 。</p>\n<p>此外，所有的方法都必须有一个关键字<code>fun</code>,在Kotlin 中，你不能使用<code>@override</code>注解，如果你要表明方法是复写父类或者接口的方法的话，直接使用<code>override</code>关键字，注意：它和Java不一样，不是一个注解了。</p>\n<p>然后，<code>savedInstanceState: Bundle?</code> 中的<code>?</code>代表什么呢？它代表了<code>savedInstanceState</code>这个参数可以是<code>Bundle</code>或者null。Kotlin是一门null 安全语言，如果你像下面这样写：</p>\n<pre><code class=\"kotlin\">var a : String</code></pre>\n<p>你将会得到一个编译错误。因为<code>a</code>变量必须被初始化，并且不能为null，因此你要像这样写：</p>\n<pre><code class=\"kotlin\">var a : String = \"Init value\"</code></pre>\n<p>并且，如果你执行以下操作，也会报编译错误：</p>\n<pre><code class=\"kotlin\">a = null</code></pre>\n<p>要想使<code>a</code>变量为null ,你必须这样写：</p>\n<pre><code class=\"kotlin\">var a : String?</code></pre>\n<p>为什么这是Kotlin语言的一个重要功能呢？因为它帮我们避免了NPE,Androd开发者已经对NPE感到厌倦了，甚至是null的发明者-<code>Tony Hoare</code>先生，也为发明它而道歉。假设我们有一个可以为空的<code>nameTextView</code>。如果为null，以下代码将会发生NPE：</p>\n<pre><code class=\"kotlin\">nameTextView.setEnabled(true)</code></pre>\n<p>但实际上，Kotlin做得很好，它甚至不允许我们做这样的事情。它会强制我们使用<code>?</code>或者<code>!!</code>操作符。如果我们使用<code>?</code>操作符：</p>\n<pre><code class=\"kotlin\">nameTextView?.setEnabled(true)</code></pre>\n<p>仅当<code>nameTextView</code>不为null时，这行代码才会继续执行。另一种情况下，如果我们使用<code>!!</code>操作符：</p>\n<pre><code class=\"kotlin\">nameTextView!!.setEnabled(true)</code></pre>\n<p>如果<code>nameTextView</code>为null，它将为我们提供NPE。它只适合喜欢冒险的家伙)</p>\n<p>这是对Kotlin的一些介绍。我们继续进行，我将停止描述其他Kotlin特定代码。</p>\n<h3>2、构建变体</h3>\n<p>通常，在开发中，如果你有两套环境，最常见的是测试环境和生产环境。这些环境在服务器<code>URL</code>，<code>图标</code>，<code>名称</code>，<code>目标api</code>等方面可能有所不同。通常，在开始的每个项目中我都有以下内容：</p>\n<ul>\n <li><code>finalProduction</code>: 上传Google Play 使用</li>\n <li><code>demoProduction</code>:该版本使用生产环境服务器Url,并且它有着GP上的版本没有的新功能，用户可以在Google play 旁边安装，然后可以进行新功能测试和提供反馈。</li>\n <li><code>demoTesting</code>:和demoProduction一样，只不过它用的是测试地址</li>\n <li><code>mock</code>: 对于我来说，作为开发人员和设计师而言都是很有用的。有时我们已经准备好设计，而我们的API仍未准备好。等待API准备就绪后再开始开发可不是好的解决方案。此构建变体为提供有mock数据，因此设计团队可以对其进行测试并提供反馈。对于保证项目进度真的很有帮助,一旦API准备就绪，我们便将开发转移到demoTesting环境。</li>\n</ul>\n<p>在此应用程序中，我们将拥有所有这些变体。它们的applicationId和名称不同。 gradle 3.0.0 <code>flavourDimension</code>中有一个新的<code>api</code>，可让您混合不同的产品风味，因此您可以混合<code>demo</code>和<code>minApi23</code>风味。在我们的应用程序中，我们将仅使用“默认” 的<code>flavorDimension</code>。早app的<code>build.gradle</code>中，将此代码插入<code>android {}</code>下：</p>\n<pre><code>flavorDimensions \"default\"\n    \nproductFlavors {\n\n    finalProduction {\n        dimension \"default\"\n        applicationId \"me.mladenrakonjac.modernandroidapp\"\n        resValue \"string\", \"app_name\", \"Modern App\"\n    }\n\n    demoProduction {\n        dimension \"default\"\n        applicationId \"me.mladenrakonjac.modernandroidapp.demoproduction\"\n        resValue \"string\", \"app_name\", \"Modern App Demo P\"\n    }\n\n    demoTesting {\n        dimension \"default\"\n        applicationId \"me.mladenrakonjac.modernandroidapp.demotesting\"\n        resValue \"string\", \"app_name\", \"Modern App Demo T\"\n    }\n\n\n    mock {\n        dimension \"default\"\n        applicationId \"me.mladenrakonjac.modernandroidapp.mock\"\n        resValue \"string\", \"app_name\", \"Modern App Mock\"\n    }\n}</code></pre>\n<p>打开<code>string.xml</code>文件，删掉<code>app_name</code>string资源，因此，我们才不会发生资源冲突，然后点击<code>Sync Now</code>,如果转到屏幕左侧的<code>“构建变体”</code>，则可以看到4个不同的构建变体，其中每个都有两种构建类型：“Debug”和“Release”,切换到<code>demoProduction</code>构建变体并运行它。然后切换到另一个并运行它。您就可以看到两个名称不同的应用程序。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023708779\" alt=\"\" title=\"\" /></p>\n<h3>3、ConstraintLayout</h3>\n<p>如果你打开<code>activity_main.xml </code>,你可以看到跟布局是<code>ConstraintLayout</code>,如果你开发过iOS应用程序，你可能知道<code>AutoLayout</code>，<code>ConstraintLayout</code>和它非常的相似，他们甚至用了相同的<code> Cassowary </code>算法。</p>\n<pre><code class=\"kotlin\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"me.mladenrakonjac.modernandroidapp.MainActivity\"&gt;\n\n    &lt;TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" /&gt;</code></pre>\n<p>Constraints可以帮我们描述View之间的关系。对于每一个View来说，应该有4个约束，每一边一个约束，在这种情况下，我们的View就被约束在了父视图的每一边了。</p>\n<p>在Design Tab中，如果你将<code>Hello World</code>文本稍微向上移动，则在<code>Text</code>Tab中将增加下面这行代码：</p>\n<pre><code class=\"kotlin\">app:layout_constraintVertical_bias=\"0.28\"</code></pre>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023708778\" alt=\"\" title=\"\" /></p>\n<p><code>Design</code> tab 和 <code>Text</code> tab是同步的，我们在Design中移动视图，则会影响Text中的<code>xml</code>，反之亦然。垂直偏差描述了视图对其约束的垂直趋势。如果要使视图垂直居中，则应使用：</p>\n<pre><code>app:layout_constraintVertical_bias=\"0.28\"</code></pre>\n<p>我们让<code>Activity</code>只显示一个仓库，它有仓库的名字，star的数量，作者，并且还会显示是否有issue</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023708781\" alt=\"\" title=\"\" /></p>\n<p>要得到上面的布局设计，代码如下所示：</p>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"me.mladenrakonjac.modernandroidapp.MainActivity\"&gt;\n\n    &lt;TextView\n        android:id=\"@+id/repository_name\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginEnd=\"16dp\"\n        android:layout_marginStart=\"16dp\"\n        android:textSize=\"20sp\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintHorizontal_bias=\"0.0\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintVertical_bias=\"0.083\"\n        tools:text=\"Modern Android app\" /&gt;\n\n    &lt;TextView\n        android:id=\"@+id/repository_has_issues\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginEnd=\"16dp\"\n        android:layout_marginStart=\"16dp\"\n        android:layout_marginTop=\"8dp\"\n        android:text=\"@string/has_issues\"\n        android:textStyle=\"bold\"\n        app:layout_constraintBottom_toBottomOf=\"@+id/repository_name\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintHorizontal_bias=\"1.0\"\n        app:layout_constraintStart_toEndOf=\"@+id/repository_name\"\n        app:layout_constraintTop_toTopOf=\"@+id/repository_name\"\n        app:layout_constraintVertical_bias=\"1.0\" /&gt;\n\n    &lt;TextView\n        android:id=\"@+id/repository_owner\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginBottom=\"8dp\"\n        android:layout_marginEnd=\"16dp\"\n        android:layout_marginStart=\"16dp\"\n        android:layout_marginTop=\"8dp\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toBottomOf=\"@+id/repository_name\"\n        app:layout_constraintVertical_bias=\"0.0\"\n        tools:text=\"Mladen Rakonjac\" /&gt;\n\n    &lt;TextView\n        android:id=\"@+id/number_of_starts\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginBottom=\"8dp\"\n        android:layout_marginEnd=\"16dp\"\n        android:layout_marginStart=\"16dp\"\n        android:layout_marginTop=\"8dp\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintHorizontal_bias=\"1\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toBottomOf=\"@+id/repository_owner\"\n        app:layout_constraintVertical_bias=\"0.0\"\n        tools:text=\"0 stars\" /&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>\n<p>不要被<code>tools:text</code>搞迷惑了，它的作用仅仅是让我们可以预览我们的布局。</p>\n<p>我们可以注意到，我们的布局是扁平的，没有任何嵌套，你应该尽量少的使用布局嵌套，因为它会影响我们的性能。ConstraintLayout也可以在不同的屏幕尺寸下正常工作。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023708780\" alt=\"\" title=\"\" /></p>\n<p>我有种预感，很快就能达到我们想要的布局效果了。</p>\n<p>上面只是一些关于<code>ConstraintLayout</code>的少部分介绍，你也可以看一下关于<code>ConstraintLayout</code>使用的google code lab: <a href=\"https://codelabs.developers.google.com/codelabs/constraint-layout/index.html?index=..%2F..%2Findex#0\" rel=\"nofollow noreferrer\">https://codelabs.developers.g...</a></p>\n<h3>4. Data binding library</h3>\n<p>当我听到Data binding 库的时候，我的第一反应是：Butterknife已经很好了，再加上，我现在使用一个插件来从xml中获取View,我为啥要改变，来使用Data binding呢？但当我对Data binding有了更多的了解之后，我的它的感觉就像我第一次见到Butterknife一样，无法自拔。</p>\n<h5>Butterknife能帮我们做啥？</h5>\n<p>ButterKnife帮助我们摆脱无聊的<code>findViewById</code>。因此，如果您有5个视图，而没有Butterknife，则你有5 + 5行代码来绑定您的视图。使用ButterKnife，您只有我行代码就搞定。就是这样。</p>\n<h5>Butterknife的缺点是什么？</h5>\n<p>Butterknife仍然没有解决代码可维护问题，使用ButterKnife时，我经常发现自己遇到运行时异常，这是因为我删除了xml中的视图，而没有删除Activity/Fragment类中的绑定代码。另外，如果要在xml中添加视图，则必须再次进行绑定。真的很不好维护。你将浪费大量时间来维护View绑定。</p>\n<h5>那与之相比，Data Binding 怎么样呢？</h5>\n<p>有很多好处，使用Data Binding，你可以只用一行代码就搞定View的绑定，让我们看看它是如何工作的，首先，先将Data Binding 添加到项目：</p>\n<pre><code>// at the top of file \napply plugin: 'kotlin-kapt'\n\n\nandroid {\n    //other things that we already used\n    dataBinding.enabled = true\n}\ndependencies {\n    //other dependencies that we used\n    kapt \"com.android.databinding:compiler:3.0.0-beta1\"\n}</code></pre>\n<p>请注意，数据绑定编译器的版本与项目<code>build.gradle</code>文件中的gradle版本相同：</p>\n<pre><code>classpath 'com.android.tools.build:gradle:3.0.0-beta1'</code></pre>\n<p>然后，点击<code>Sync Now</code>,打开<code>activity_main.xml</code>,将<code>Constraint Layout </code>用layout标签包裹</p>\n<pre><code class=\"kotlin\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n    &lt;android.support.constraint.ConstraintLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        tools:context=\"me.mladenrakonjac.modernandroidapp.MainActivity\"&gt;\n\n        &lt;TextView\n            android:id=\"@+id/repository_name\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_marginEnd=\"16dp\"\n            android:layout_marginStart=\"16dp\"\n            android:textSize=\"20sp\"\n            app:layout_constraintBottom_toBottomOf=\"parent\"\n            app:layout_constraintHorizontal_bias=\"0.0\"\n            app:layout_constraintLeft_toLeftOf=\"parent\"\n            app:layout_constraintRight_toRightOf=\"parent\"\n            app:layout_constraintTop_toTopOf=\"parent\"\n            app:layout_constraintVertical_bias=\"0.083\"\n            tools:text=\"Modern Android app\" /&gt;\n\n        &lt;TextView\n            android:id=\"@+id/repository_has_issues\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_marginEnd=\"16dp\"\n            android:layout_marginStart=\"16dp\"\n            android:layout_marginTop=\"8dp\"\n            android:text=\"@string/has_issues\"\n            android:textStyle=\"bold\"\n            app:layout_constraintBottom_toBottomOf=\"@+id/repository_name\"\n            app:layout_constraintEnd_toEndOf=\"parent\"\n            app:layout_constraintHorizontal_bias=\"1.0\"\n            app:layout_constraintStart_toEndOf=\"@+id/repository_name\"\n            app:layout_constraintTop_toTopOf=\"@+id/repository_name\"\n            app:layout_constraintVertical_bias=\"1.0\" /&gt;\n\n        &lt;TextView\n            android:id=\"@+id/repository_owner\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"wrap_content\"\n            android:layout_marginBottom=\"8dp\"\n            android:layout_marginEnd=\"16dp\"\n            android:layout_marginStart=\"16dp\"\n            android:layout_marginTop=\"8dp\"\n            app:layout_constraintBottom_toBottomOf=\"parent\"\n            app:layout_constraintEnd_toEndOf=\"parent\"\n            app:layout_constraintStart_toStartOf=\"parent\"\n            app:layout_constraintTop_toBottomOf=\"@+id/repository_name\"\n            app:layout_constraintVertical_bias=\"0.0\"\n            tools:text=\"Mladen Rakonjac\" /&gt;\n\n        &lt;TextView\n            android:id=\"@+id/number_of_starts\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_marginBottom=\"8dp\"\n            android:layout_marginEnd=\"16dp\"\n            android:layout_marginStart=\"16dp\"\n            android:layout_marginTop=\"8dp\"\n            app:layout_constraintBottom_toBottomOf=\"parent\"\n            app:layout_constraintEnd_toEndOf=\"parent\"\n            app:layout_constraintHorizontal_bias=\"1\"\n            app:layout_constraintStart_toStartOf=\"parent\"\n            app:layout_constraintTop_toBottomOf=\"@+id/repository_owner\"\n            app:layout_constraintVertical_bias=\"0.0\"\n            tools:text=\"0 stars\" /&gt;\n\n    &lt;/android.support.constraint.ConstraintLayout&gt;\n\n&lt;/layout&gt;\n</code></pre>\n<p>注意，你需要将所有的xml移动到layout 标签下面，然后点击<code>Build</code>图标或者使用快捷键<code>Cmd + F9</code>,我们需要构建项目来使Data Binding库为我们生成<code>ActivityMainBinding</code>类，后面在MainActivity中将用到它。</p>\n<p>如果没有重新编译项目，你是看不到<code>ActivityMainBinding</code>的，因为它在编译时生成。</p>\n<p>我们还没有完成绑定，我们只是定义了一个非空的 ActivityMainBinding 类型的变量。你会注意到我没有把<code>?</code> 放在 ActivityMainBinding 的后面，而且也没有初始化它。这怎么可能呢？<code>lateinit</code> 关键字允许我们使用非空的延迟被初始化的变量。和 ButterKnife 类似，在我们的布局准备完成后，初始化绑定需要在 onCreate 方法中进行。此外，你不应该在 onCreate 方法中声明绑定，因为你很有可能在 onCreate 方法外使用它。我们的 binding 不能为空，所以这就是我们使用 lateinit 的原因。使用 lateinit 修饰，我们不需要在每次访问它的时候检查 binding 变量是否为空。</p>\n<p>我们初始化binding变量，你需要替换:</p>\n<pre><code class=\"kotin\">setContentView(R.layout.activity_main)</code></pre>\n<p>为：</p>\n<pre><code class=\"kotlin\">binding = DataBindingUtil.setContentView(this, R.layout.activity_main)</code></pre>\n<p>就是这样，你成功的绑定了所有View,现在你可以访问它并且做一些更改，例如，我们将仓库名字改为<code>Modern Android Medium Article</code>:</p>\n<pre><code class=\"kotlin\">binding.repositoryName.text = \"Modern Android Medium Article\"</code></pre>\n<p>如你所见，现在我们可以通过<code>bingding</code>变量来访问<code>main_activity.xml</code>的所有View了（前提是它们有id）,这就是Data Binding 比ButterKnife 好用的原因。</p>\n<h5>kotlin的 Getters 和 setters</h5>\n<p>大概，你已经注意到了，我们没有像Java那样使用<code>.setText()</code>，我想在这里暂停一下，以说明与Java相比，Kotlin中的getter和setter方法如何工作的。</p>\n<p>首先，你需要知道，我们为什么要使用getters和setters，我们用它来隐藏类中的变量，仅允许使用方法来访问这些变量，这样我们就可以向用户隐藏类中的细节，并禁止用户直接修改我们的类。假设我们用 Java 写了一个 Square 类：</p>\n<pre><code class=\"java\">public class Square {\n  private int a;\n  \n  Square(){\n    a = 1;\n  }\n\n  public void setA(int a){\n    this.a = Math.abs(a);\n  }\n  \n  public int getA(){\n    return this.a;\n  }\n  \n}</code></pre>\n<p>使用<code>setA()</code>方法，我们禁止了用户向<code>Square</code>类的<code>a</code>变量设置一个负数,因为正方形的边长一定是正数，要使用这种方法，我们必须将其设为私有，因此不能直接设置它。这也意味着我们不能直接获得<code>a</code>，需要给它定一个get方法来返回<code>a</code>，如果有10个变量，那么我们就得定义10个相似的get方法，写这样无聊的样板代码，通常会影响我们的心情。</p>\n<p>Kotling使我们的开发人员更轻松了。如果你调用下面的代码：</p>\n<pre><code class=\"kotlin\">var side: Int = square.a</code></pre>\n<p>这并不意味着你是在直接访问a变量，它和Java中调用<code>getA()</code>是相同的</p>\n<pre><code class=\"java\">int side = square.getA();</code></pre>\n<p>因为Kotlin自动生成默认的getter和setter。在Kotlin中，只有当您有特殊的setter或getter时，才应指定它。否则，Kotlin会为您自动生成：</p>\n<pre><code class=\"kotlin\">var a = 1\n   set(value) { field = Math.abs(value) }</code></pre>\n<p><code>field</code> ? 这又是个什么东西？为了更清楚明白，请看下面代码：</p>\n<pre><code class=\"kotlin\">var a = 1\n   set(value) { a = Math.abs(value) }</code></pre>\n<p>这表明你在调用set方法中的<code>set(value){}</code>，因为Kotlin的世界中，没有直接访问属性，这就会造成无限递归，当你调用<code>a = something</code>,会自动调用set方法。使用filed就能避免无限递归，我希望这能让你明白为什么要用filed关键字，并且了解getters和setters是如何工作的。</p>\n<p>回到代码中继续，我将向你介绍Kotlin语言的另一个重要功能:apply函数：</p>\n<pre><code class=\"kotlin\">class MainActivity : AppCompatActivity() {\n\n    lateinit var binding: ActivityMainBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        binding = DataBindingUtil.setContentView(this, R.layout.activity_main)\n        binding.apply {\n            repositoryName.text = \"Medium Android Repository Article\"\n            repositoryOwner.text = \"Mladen Rakonjac\"\n            numberOfStarts.text = \"1000 stars\"\n            \n        }\n    }\n}</code></pre>\n<p>apply 允许你在一个实例上调用多个方法，我们仍然还没有完成数据绑定，还有更棒的事儿，让我们为仓库定义一个UI模型（这个是github仓库的数据模型Repository,它持有要展示的数据，请不要和Repository模式的中的Repository搞混淆了哈），要创建一个Kotlin class，点击<code>New -&gt; Kotlin File/Class :</code></p>\n<pre><code class=\"kotlin\">class Repository(var repositoryName: String?,var repositoryOwner: String?,var numberOfStars: Int? ,var hasIssues: Boolean = false)</code></pre>\n<p>在Kotlin中，主构造函数是类头的一部分，如果你不想定义次构造函数，那就是这样了，数据类到此就完成了，构造函数没有参数分配给字段，没有setters和getters,整个类就一行代码。</p>\n<p>回到<code>MainActivity.kt</code>，为<code>Repository</code>创建一个实例。</p>\n<pre><code class=\"kotlin\">var repository = Repository(\"Medium Android Repository Article\",\n        \"Mladen Rakonjac\", 1000, true)</code></pre>\n<p>你应该注意到了，创建类实例，没有用<code>new</code></p>\n<p>现在，我们在<code>activity_main.xml </code>中添加data标签。</p>\n<pre><code class=\"kotlin\">&lt;data&gt;\n      &lt;variable\n        name=\"repository\"\n        type=\"me.mladenrakonjac.modernandroidapp.uimodels.Repository\"\n        /&gt;\n&lt;/data&gt;</code></pre>\n<p>我们可以在布局中访问存储的变量<code>repository</code>,例如，我们可以如下使用id是<code>repository_name</code>的TextView,如下：</p>\n<pre><code class=\"kotlin\">android:text=\"@{repository.repositoryName}\"</code></pre>\n<p>repository_name文本视图将显示从repository变量的属性<code>repositoryName</code>获取的文本。剩下的唯一事情就是将<code>repository</code>变量从xml绑定到<code>MainActivity.kt</code>中的repository。</p>\n<p>点击Build使DataBinding 为我们生成类，然后在MainActivity中添加两行代码：</p>\n<pre><code class=\"kotlin\">binding.repository = repository\nbinding.executePendingBindings()</code></pre>\n<p>如果你运行APP,你会看到TextView上显示的是：<code>“Medium Android Repository Article”</code>,非常棒的功能，是吧？</p>\n<p>但是，如果我们像下面这样改一下呢？</p>\n<pre><code class=\"kotlin\">Handler().postDelayed({repository.repositoryName=\"New Name\"}, 2000)</code></pre>\n<p>新的文本将会在2000ms后显示吗？不会的，你必须重新设置一次<code>repository</code>,像这样：</p>\n<pre><code class=\"kotlin\">Handler().postDelayed({repository.repositoryName=\"New Name\"\n    binding.repository = repository\n    binding.executePendingBindings()}, 2000)</code></pre>\n<p>但是，如果我们每次更改一个属性都要这么写的话，那就非常蛋疼了，这里有一个更好的方案叫做<code>Property Observer</code>。</p>\n<p>让我们首先解释一下什么是观察者模式，因为在rxJava部分中我们也将需要它：</p>\n<p>可能你已经听说过<code> http://androidweekly.net/</code>,这是一个关于Android开发的周刊。如果您想接收它，则必须订阅它并提供您的电子邮件地址。过了一段时间，如果你不想看了，你可以去网站上取消订阅。</p>\n<p>这就是一个<code>观察者/被观察者</code>的模式,在这个例子中， Android 周刊是<code>被观察者</code>,它每周都会发布新闻通讯。读者是<code>观察者</code>，因为他们订阅了它，一旦订阅就会收到数据，如果不想读了，则可以停止订阅。</p>\n<p><code>Property Observer</code>在这个例子中就是 xml layout,它将会监听<code>Repository</code>实例的变化。因此，<code>Repository</code>是<code>被观察者</code>,例如，一旦在Repository类的实例中更改了repository nane 属性后，xml不调用下面的代码也会更新：</p>\n<pre><code class=\"kotlin\">binding.repository = repository\nbinding.executePendingBindings()</code></pre>\n<p>如何让它使用Data Binding 库呢？，Data Binding库提供了一个<code>BaseObservable</code>类，我们的Repostory类必须继承它。</p>\n<pre><code class=\"kotlin\">class Repository(repositoryName : String, var repositoryOwner: String?, var numberOfStars: Int?\n                 , var hasIssues: Boolean = false) : BaseObservable(){\n\n    @get:Bindable\n    var repositoryName : String = \"\"\n    set(value) {\n        field = value\n        notifyPropertyChanged(BR.repositoryName)\n    }\n\n}</code></pre>\n<p>当我们使用了 Bindable 注解时，就会自动生成 BR 类。你会看到，一旦设置新值，就会通知它更新。现在运行 app 你将看到仓库的名字在 2 秒后改变而不必再次调用 <code>executePendingBindings()</code>。</p>\n<p>以上就是这一节的所有内容，下一节将会讲MVVM+Repository 模式的使用。敬请期待！感谢阅读。</p>\n<blockquote>\n 作者 | Mladen Rakoajc\n <br>译者 | 依然范特稀西<br>编辑 | 依然范特稀西</br></br>\n</blockquote>\n<p>原文地址：<a href=\"https://proandroiddev.com/modern-android-development-with-kotlin-september-2017-part-1-f976483f7bd6\" rel=\"nofollow noreferrer\">https://proandroiddev.com/mod...</a></p>\n<p>本系列已更新完毕：</p>\n<p><a href=\"https://juejin.im/post/6844904185633177608\" rel=\"nofollow noreferrer\">【译】使用Kotlin从零开始写一个现代Android 项目-Part1</a></p>\n<p><a href=\"https://juejin.im/post/6844904193275215880\" rel=\"nofollow noreferrer\">【译】使用Kotlin从零开始写一个现代Android 项目-Part2</a></p>\n<p><a href=\"https://juejin.im/post/6844904197507268622\" rel=\"nofollow noreferrer\">【译】使用Kotlin从零开始写一个现代Android 项目-Part3</a></p>\n<p><a href=\"https://juejin.im/post/6844904177408147463\" rel=\"nofollow noreferrer\">【译】使用Kotlin从零开始写一个现代Android 项目-Part4</a></p>\n<blockquote>\n 文章首发于公众号：\n <code>「 技术最TOP 」</code>，每天都有干货文章持续更新，可以微信搜索\n <code>「 技术最TOP 」</code>第一时间阅读，回复【思维导图】【面试】【简历】有我准备一些Android进阶路线、面试指导和简历模板送给你\n</blockquote>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023708782\" alt=\"\" title=\"\" /></p>","descriptionType":"html","publishedDate":"Fri, 21 Aug 2020 01:53:54 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023708779","linkMd5":"b4d24379ce31382e9336abd377405f85","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn42@2020_5/2020/08/24/23-08-23-053_b410fb298e7c2e62.webp","destWidth":754,"destHeight":488,"sourceBytes":38573,"destBytes":14822,"author":"依然饭特稀西","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023708779":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn42@2020_5/2020/08/24/23-08-23-053_b410fb298e7c2e62.webp","https://segmentfault.com/img/remote/1460000023708778":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn23@2020_2/2020/08/24/23-08-38-329_bf5033b02384e3e7.webp","https://segmentfault.com/img/remote/1460000023708781":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn35@2020_2/2020/08/24/23-08-38-260_1b98c2cb4699745d.webp","https://segmentfault.com/img/remote/1460000023708780":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn44@2020_6/2020/08/24/23-08-40-620_dfc9c678416ce7f2.webp","https://segmentfault.com/img/remote/1460000023708782":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn39@2020_5/2020/08/24/23-08-38-804_234d06daf8751ef2.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"连肝4天，这瞬间戳中面试官小心心的AQS大餐，给大家安排上！ ","link":"https://segmentfault.com/a/1190000023709787","description":"<blockquote>\n 点赞的靓仔，你时人群中最闪耀的光芒\n</blockquote>\n<h3>前言</h3>\n<p>AQS，英文全称AbstractQueuedSynchronizer，直接翻译为抽象的队列同步器。是JDK1.5出现的一个用于解决并发问题的工具类，由大名鼎鼎的Doug Lea打造，与synchornized关键字不同的是，AQS是通过代码解决并发问题。</p>\n<h3>回顾并发问题</h3>\n<p>并发问题是指在多线程运行环境下，共享资源安全的问题。<br>现在的银行账户，通过银行卡和手机银行都可以操作账户， 如果我们同时拿着银行卡和存折去银行搞事情，会怎么样呢？</br></p>\n<pre><code class=\"java\">package demo.pattren.aqs;\n\npublic class Money {\n    /**\n     * 假设现在账户有1000块钱\n     */\n    private int money = 1000;\n    /**\n     * 取钱\n     */\n    public void drawMoney(){\n        this.money--;\n    }\n    public static void main(String[] args) throws InterruptedException {\n        Money money = new Money();\n        for(int i=0; i&lt;1000; i++){\n            new Thread(() -&gt; {\n                try {\n                    Thread.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                money.drawMoney();\n            },i + \"\").start();\n        }\n        Thread.sleep(2000);\n        System.out.println(\"当前账户余额：\" + money.money);\n    }\n}</code></pre>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023709792\" alt=\"\" title=\"\"><br>这样想着是不是马上可以去银行搞一波事情？ 哈哈，你想太多了，如果能这样搞，银行早破产了。我们主要是来分析一下出现这个问题的原因,JVM内存是JMM结构的，每个线程操作的数据是从主内存中复制的一个和备份，而多个线程就会存在多个备份，当线程中的备份数据被修改时，会将值刷新到主内存，比如多个线程同时获取到了账户的余额为500元，A线程存钱100，线程A将600刷新到主内存，$\\color{red}{主内存并不会主动通知其他线程此时值已经被修改}$，所以主内存的值此时与其他线程的值是不同的，如果其他线程再操作账户余额，是在500的基础上进行的，这显然不是我们想要的结果。<br><img src=\"https://segmentfault.com/img/remote/1460000023709790\" alt=\"\" title=\"\" /></br></br></img></p>\n<h3>解决并发问题</h3>\n<p>JDK提供了多种解决多线程安全的方式。</p>\n<h4>volatile关键字</h4>\n<p>volatile是JDK提供的关键字，用来修饰变量，volatile修饰的变量能够保证多个线程下的可见性，如上个案例，A修改了账户的余额，然后将最新的值刷新到主内存，此时主内存会将最新的值同步到其他线程。<br><img src=\"https://segmentfault.com/img/remote/1460000023709791\" alt=\"\" title=\"\"><br>volatile解决了多线程下数据读取一致的问题，$\\color{red}{即保证可见性，但是其并不能保证写操作的原子性}$,<br><img src=\"https://segmentfault.com/img/remote/1460000023709793\" alt=\"\" title=\"\"><br>当多个线程同时写操作的时候，即多个线程同时去将线程中最新的值刷新到主内存，将会出现问题。<br><img src=\"https://segmentfault.com/img/remote/1460000023709794\" alt=\"\" title=\"\"><br>通过volatile关键字修饰money变量，发下并不能解决线程安全问题。</br></img></br></br></img></br></br></img></br></p>\n<h4>原子操作类</h4>\n<p>原子操作类是JDK提供的一系列保证原子操作的工具类，原子类可以保证多线程环境下对其值的操作是安全的。</p>\n<pre><code class=\"java\">package demo.pattren.aqs;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicMoney {\n    /**\n     * 假设现在账户有1000块钱\n     */\n    private AtomicInteger money = new AtomicInteger(1000);\n    /**\n     * 取钱\n     */\n    public void drawMoney(){\n        //AtomicInteger的自减操作\n        this.money.getAndDecrement();\n    }\n    public static void main(String[] args) throws InterruptedException {\n        AtomicMoney money = new AtomicMoney();\n        for(int i=0; i&lt;1000; i++){\n            new Thread(() -&gt; {\n                try {\n                    Thread.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                money.drawMoney();\n            },i + \"\").start();\n        }\n        Thread.sleep(2000);\n        System.out.println(\"当前账户余额：\" + money.money);\n    }\n}</code></pre>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023709795\" alt=\"\" title=\"\"><br>多次测试结果都是0，与预期一致。原子操作类是使用CAS(Compare and swap 比较并替换)的机制来保证操作的原子性，相对于锁，他的并发性更高。</br></img></p>\n<h4>synchronized关键字</h4>\n<p>synchronized关键字是jvm层面来保证线程安全的，通过在代码块前后添加monitorenter与monitorexit命令来保证线程的安全，而且在JDK1.6对synchronized关键字做了较大的优化，性能有了较大的提升。可以确定的是，通过synchronized肯定可以保证线程安全，所以使用synchronized也是很好的选择，当然synchronized锁的升级不可逆特征，导致在高并发下性能是不能很好的保证。</p>\n<h4>Lock锁</h4>\n<p>终于迎来了本篇文章的主角，前面的内容，其实与文章的主题AQS并没有直接的关联，就简单带过。前面很多都是JVM层面来保证线程安全的，而AQS则是完全通过代码层面来处理线程安全的。<br>(PS：小节标题明明是Lock锁，怎么写AQS了，骗我读书少)<br><img src=\"https://segmentfault.com/img/remote/1460000023709797\" alt=\"\" title=\"\" /></br></br></p>\n<p>博主怕挨打，正在全力解释中<del>~</del>。先上类图压场！<br><img src=\"https://segmentfault.com/img/remote/1460000023709796\" alt=\"\" title=\"\"><br>如上图，左边是抽象队列同步器，而右边则是使用队列同步器实现的功能——锁、信号量、发令枪等。<br>可以先不看源码，咱们自己思考，要以纯代码的方式实现应当考虑哪些问题？</br></br></img></br></p>\n<ol>\n <li>线程互斥：可以使用state状态进行判断，state=0，则可以获取到锁，state&gt;0,则不能获取。</li>\n <li>排队等候：不能获取锁的线程应当存储起来，当锁释放后可以继续获取锁执行。</li>\n <li>线程唤醒：当锁释放后，处于等待状态的线程应当被唤醒。</li>\n <li>锁重入 ： 如何解决同一个进入多个加锁的方法(不解决的话分分钟死锁给你看)。</li>\n</ol>\n<p>对于1、2两点，难度应带不大，而3、4两点如何去设计呢？我们通过伪代码预演操作流程。</p>\n<p>在业务端，是这样操作的。</p>\n<pre><code>  加锁\n  {需要被锁住的代码}\n  释放锁</code></pre>\n<p>加锁与释放锁的逻辑</p>\n<pre><code class=\"java\">    if(state == 0)\n      获取到锁\n      set(state == 1)\n    else\n      继续等待\n      while(true){\n           if(state == 0)\n             再次尝试获取锁\n      }</code></pre>\n<p>这样设计之后，整个操作流程再次变成了串行操作。<br><img src=\"https://segmentfault.com/img/remote/1460000023709798\" alt=\"\" title=\"\" /></br></p>\n<p>这和我们去食堂排队打饭是一样的，食堂不可能为每个学生都开放一个窗口，所以多个学生就会争抢有限的窗口，如果没有一定的控制，那么食堂每到吃饭的时候都是乱套的，一群学生围着窗口同时去打饭，想想都是多么的恐怖。而由此出现了排队的机制，一个窗口同一时间打饭的人只能有一个，当前一个人离开窗口后，后面排队的学生才能去打饭。<br><img src=\"https://segmentfault.com/img/remote/1460000023709801\" alt=\"\" title=\"\" /></br></p>\n<h3>源码解读</h3>\n<p>下面我们深入JDK源码，领略大师级的代码设计。<br>业务调用代码:</br></p>\n<pre><code class=\"java\">package demo.aqs;\n\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class LockMoney {\n    Lock lock = new ReentrantLock();\n    /**\n     * 假设现在账户有1000块钱\n     */\n    private int money = 1000;\n    //private int money = 1000;\n    /**\n     * 取钱\n     */\n    public void drawMoney(){\n        lock.lock();\n        this.money--;\n        lock.unlock();\n    }\n    public static void main(String[] args) throws InterruptedException {\n        LockMoney money = new LockMoney();\n        for(int i=0; i&lt;1000; i++){\n            new Thread(() -&gt; {\n                try {\n                    Thread.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                money.drawMoney();\n            },i + \"\").start();\n        }\n        Thread.sleep(2000);\n        System.out.println(\"当前账户余额：\" + money.money);\n    }\n}</code></pre>\n<p>追踪Lock方法：<br>直接看源码基本一会儿就晕车，我尝试绘制出lock方法的调用链路。然后结合源码解释。<br><img src=\"https://segmentfault.com/img/remote/1460000023709799\" alt=\"\" title=\"\" /></br></br></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023709796\" alt=\"\" title=\"\"><br>大家跟着箭头走一遍源码，多多少少能够体会到AQS的实现机制。</br></img></p>\n<h4>NonfairSync.lock</h4>\n<pre><code class=\"java\">final void lock() {\n    //CAS尝试将state从0更新为1，更新成功则执行if下面的代码。\n    if (compareAndSetState(0, 1))\n        //获取锁成功，执行线程执行\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        //获取锁失败，线程入队列\n        acquire(1);\n}</code></pre>\n<p>看到这段代码，是不是瞬间明白前面提到的1、2两点问题。首先compareAndSetState方法是使用Unsafe直接操作内存并且使用乐观锁的方式，能够保证有且仅有一个线程能够操作成功，是多线程安全的。即设置将state设置为1成功的线程能够抢占到锁(<strong><em>线程互斥</em></strong>)，而没有设置成功的线程将进行入队操作(<strong><em>排队等候</em></strong>)，这样感觉瞬间明朗了许多，那我们接着往下看。</p>\n<h4>AbstractQueuedSynchronizor.acquire</h4>\n<pre><code class=\"java\"> public final void acquire(int arg) {\n    //tryAcquire失败并且acquireQueued成功，则调用selfInterrupt\n    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        //当线程获取锁失败并且线程阻塞失败会中断线程\n        selfInterrupt();\n}</code></pre>\n<p>AbstractQueuedSynchronizor的tryAcquire方法,其最终调用到了Sync的nonfairTryAcquire</p>\n<pre><code class=\"java\"> final boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    //获取当前锁的状态值\n    int c = getState();\n    // state = 0,表示当前锁为空闲状态，其实这一段代码和前面lock的方法是一样的\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //不等于0 则判断当前线程是否为持有锁的线程，如果是则执行代码，这里解决了重入锁问题\n    else if (current == getExclusiveOwnerThread()) {\n        //当前状态值 + 1(可以看前面的传参)\n        int nextc = c + acquires;\n        // 囧， 这里是超出了int的最大值才会出现这样的情况\n        if (nextc &lt; 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        //更新state的值\n        setState(nextc);\n        return true;\n    }\n    return false;\n}</code></pre>\n<p>通过阅读源码，可以发现，tryAcquire方法在当前线程获取锁成功或者是重入锁的情况下返回true，否则返回false。而同时这个方法解决了上面提到的第4点锁重入的问题。ok，感觉越来越接近真相了，接着看addWaiter方法。<br>理解addWaiter方法的代码，先看方法中用的得Node对象。 Node对象是对Thread对象的封装，使其具有线程的功能，同时他还有prev、next等属性。那么很明了，Node是一个链表结构的对象</br></p>\n<pre><code class=\"java\">   //前一个结点\n   volatile Node prev;\n   //下一个结点\n   volatile Node next;\n</code></pre>\n<p>同时AbstractQueuedSynchronizor中包含head、tail属性</p>\n<pre><code class=\"java\"> //Node链表的头结点\n private transient volatile Node head;\n //Node链表的尾结点\n private transient volatile Node tail;</code></pre>\n<pre><code class=\"java\">private Node addWaiter(Node mode) {\n    //将当前线程包装为Node对象\n    Node node = new Node(Thread.currentThread(), mode);\n    //获取尾节点，当这段代码第一次运行的时候，并没有尾结点\n    //所以肯定值为null，那么会执行下面的enq方法\n    Node pred = tail;\n    //当再次运行代码的时候，尾结点不再为null(enq方法初始化了尾结点,可以先往下看enq方法源码)\n    if (pred != null) {\n        //当前结点的前置结点指向之前的尾结点\n        node.prev = pred;\n        //CAS尝试将尾结点从pred设置为node\n        if (compareAndSetTail(pred, node)) {\n            //设置成功则将pred的next结点执行node\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node);\n    return node;\n}</code></pre>\n<p>上面的解释听着有点绕脑袋。<br><img src=\"https://segmentfault.com/img/remote/1460000023709803\" alt=\"\" title=\"\"><br>不着急，我们先看enq方法</br></img></br></p>\n<pre><code class=\"java\">private Node enq(final Node node) {\n    //死循环\n    for (;;) {\n        //获取尾结点\n        Node t = tail;\n        //尾结点为空，则初始化尾结点和头结点为同一个新创建的Node对象\n        if (t == null) { // Must initialize\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\n            //将当前结点设为为尾结点，并将前一个尾结点的next指向当前结点\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                //退出循环\n                return t;\n            }\n        }\n    }\n}</code></pre>\n<p>enq具体做了什么事情呢：</p>\n<ol>\n <li>第一次循环，初始化头结点与尾结点 new Node()</li>\n <li>第二次循环，将当前线程封装的Node对象设置为尾结点，并将前一个尾结点的next指向此Node</li>\n</ol>\n<p>这里需要一些时间 + 空间的想象力，但如果对链表结构比较熟悉的话，这里理解也是不太困难的。<br>我们动态的想一想执行过程：</br></p>\n<ol>\n <li>第一个线程进入lock方法，此时是肯定可以获取到锁，直接执行，不会进入到addWaiter方法</li>\n <li>第二个线程进入lock方法，我们假设第一个线程还没有释放锁，此时进入执行enq方法，enq进行链表的初始化。</li>\n</ol>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023709802\" alt=\"\" title=\"\" /></p>\n<ol>\n <li>第三个线程以及更多的线程进入lock方法，此时不再执行enq方法，而是在初始化之后的链表进行链接。</li>\n</ol>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023709804\" alt=\"\" title=\"\" /></p>\n<h4>acquireQueued</h4>\n<pre><code>final boolean acquireQueued(final Node node, int arg) {\n  //局部变量\n  boolean failed = true;\n  try {\n      //局部变量\n      boolean interrupted = false;\n      //死循环\n      for (;;) {\n          //获取前置结点\n          final Node p = node.predecessor();\n          //前置结点为head并且尝试获取锁成功，则不阻塞\n          if (p == head &amp;&amp; tryAcquire(arg)) {\n              setHead(node);\n              p.next = null; // help GC\n              failed = false;\n              return interrupted;\n          }\n          //阻塞操作 ， 判断是否应该阻塞 并且 阻塞是否成功\n          if (\n                //是否在抢占锁失败后阻塞\n              shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n              //Unsafe操作使线程阻塞\n              parkAndCheckInterrupt())\n              interrupted = true;\n      }\n  } finally {\n      if (failed)\n          cancelAcquire(node);\n  }\n}</code></pre>\n<h4>shouldParkAfterFailedAcquire分析</h4>\n<pre><code>//Node pred 前置结点, Node node 当前结点\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    //获取前置结点的等待状态\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL)\n        /*\n         * 唤醒信号，即前结点正常，就设置waitStatus为SIGNAL，表示前置结点可以唤醒当前结点，那          * 么当前结点才会安心的被阻塞(如果前置结点不正常，可能就会导致自己不能被唤醒，那肯定不          * 能安心睡觉的)\n         */\n        return true;\n    if (ws &gt; 0) {\n        /*\n         * 找到前置结点中waitStatus &lt;= 0 的Node结点并设置为当前结点的前置结点\n         * 此状态表示结点不是处于正常状态，那么将他从链表中删除，直到找到状态正常的结点\n         */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus &gt; 0);\n        pred.next = node;\n    } else {\n        /*\n         * 当waitStatus = 0 或者 PROPAGATE(-3) 时，CAS设置值为SIGNAL(-1)\n         * 此状态表示线程正常，但没有设置唤醒，一般为tail的前一个结点，那么需要将其设置为可唤醒          * 状态(SIGNAL)\n         */\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}</code></pre>\n<p>图解如下。<br><img src=\"https://segmentfault.com/img/remote/1460000023709805\" alt=\"\" title=\"\" /></br></p>\n<p>至此，我们了解了AQS对需要等待的线程存储的过程。<br>而AQS的解锁以及公平锁、非公平锁，共享锁、独享锁等后续跟上。</br></p>\n<p>参考资料：</p>\n<p><a href=\"https://www.cnblogs.com/waterystone/p/4920797.html\" rel=\"nofollow noreferrer\">https://www.cnblogs.com/water...</a><br><a href=\"https://www.jianshu.com/p/d61f025ad836\" rel=\"nofollow noreferrer\">https://www.jianshu.com/p/d61...</a></br></p>","descriptionType":"html","publishedDate":"Fri, 21 Aug 2020 02:39:45 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023709792","linkMd5":"ac9425a1dc212f5c19afed90d55afc0d","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn9@2020_2/2020/08/24/23-08-23-053_139a4be2af02dca5.webp","destWidth":678,"destHeight":64,"sourceBytes":3107,"destBytes":2152,"author":"FishCode","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023709792":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn9@2020_2/2020/08/24/23-08-23-053_139a4be2af02dca5.webp","https://segmentfault.com/img/remote/1460000023709790":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn66@2020_1/2020/08/24/23-08-33-212_466a91e430815709.webp","https://segmentfault.com/img/remote/1460000023709791":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn62@2020_2/2020/08/24/23-08-33-065_aca834d1f78506e1.webp","https://segmentfault.com/img/remote/1460000023709793":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn54@2020_1/2020/08/24/23-08-33-326_296fe34c1d67332e.webp","https://segmentfault.com/img/remote/1460000023709794":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn57@2020_2/2020/08/24/23-08-33-158_ea591013ed81ca92.webp","https://segmentfault.com/img/remote/1460000023709795":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn90@2020_4/2020/08/24/23-08-33-301_d3cdfa771a80fd89.webp","https://segmentfault.com/img/remote/1460000023709797":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn74@2020_4/2020/08/24/23-08-33-616_c5d493b3e367e934.webp","https://segmentfault.com/img/remote/1460000023709796":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn94@2020_1/2020/08/24/23-08-33-609_05d4dc7dacd0d54d.webp","https://segmentfault.com/img/remote/1460000023709798":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn85@2020_2/2020/08/24/23-08-33-136_31a2ac49b076af15.webp","https://segmentfault.com/img/remote/1460000023709801":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn48@2020_1/2020/08/24/23-08-37-123_d94dd4f33dfc2b9f.webp","https://segmentfault.com/img/remote/1460000023709799":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn69@2020_3/2020/08/24/23-08-33-492_971c0824e4b34173.webp","https://segmentfault.com/img/remote/1460000023709803":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn60@2020_2/2020/08/24/23-08-37-310_d2a8b739b73e75b1.webp","https://segmentfault.com/img/remote/1460000023709802":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn52@2020_2/2020/08/24/23-08-36-907_f10a55c3175000a3.webp","https://segmentfault.com/img/remote/1460000023709804":"https://cdn.jsdelivr.net/gh/myreaderx/cdn64@2020_4/2020/08/24/23-08-37-435_4af65fb32a269cbc.webp","https://segmentfault.com/img/remote/1460000023709805":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn56@2020_6/2020/08/24/23-08-35-625_7a194b4bce014c56.webp"},"publishedOrCreatedDate":1598310388570},{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","title":"从Generator入手读懂co模块源码","link":"https://segmentfault.com/a/1190000023652879","description":"<p>这篇文章是讲JS异步原理和实现方式的第四篇文章，前面三篇是：</p>\n<p><a href=\"https://segmentfault.com/a/1190000023315304\">setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000023385521\">从发布订阅模式入手读懂Node.js的EventEmitter源码</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000023157856\">手写一个Promise/A+,完美通过官方872个测试用例</a></p>\n<p>本文主要会讲Generator的运用和实现原理，然后我们会去读一下co模块的源码，最后还会提一下async/await。</p>\n<p>本文全部例子都在GitHub上：<a href=\"https://github.com/dennis-jiang/Front-End-Knowledges/tree/master/Examples/JavaScript/Generator\" rel=\"nofollow noreferrer\">https://github.com/dennis-jiang/Front-End-Knowledges/tree/master/Examples/JavaScript/Generator</a></p>\n<h2>Generator</h2>\n<p>异步编程一直是JS的核心之一，业界也是一直在探索不同的解决方法，从“回调地狱”到发布订阅模式，再到Promise，都是在优化异步编程。尽管Promise已经很优秀了，也不会陷入“回调地狱”，但是嵌套层数多了也会有一连串的<code>then</code>，始终不能像同步代码那样直接往下写就行了。Generator是ES6引入的进一步改善异步编程的方案，下面我们先来看看基本用法。</p>\n<h3>基本用法</h3>\n<p>Generator的中文翻译是“生成器”，其实他要干的事情也是一个生成器，一个函数如果加了<code>*</code>，他就会变成一个生成器函数，他的运行结果会返回一个迭代器对象，比如下面的代码：</p>\n<pre><code class=\"javascript\">// gen是一个生成器函数\nfunction* gen() {\n  let a = yield 1;\n  let b = yield a + 2;\n  yield b + 3;\n}\n\nlet itor = gen();   // 生成器函数运行后会返回一个迭代器对象，即itor。</code></pre>\n<h4>next</h4>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE\" rel=\"nofollow noreferrer\">ES6规范中规定</a>迭代器必须有一个<code>next</code>方法，这个方法会返回一个对象，这个对象具有<code>done</code>和<code>value</code>两个属性，<code>done</code>表示当前迭代器内容是否已经执行完，执行完为<code>true</code>，否则为<code>false</code>，<code>value</code>表示当前步骤返回的值。在<code>generator</code>具体运用中，每次遇到<code>yield</code>关键字都会暂停执行，当调用迭代器的<code>next</code>时，会将<code>yield</code>后面表达式的值作为返回对象的<code>value</code>，比如上面生成器的执行结果如下:</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023652882\" alt=\"image-20200419153257750\" title=\"image-20200419153257750\" /></p>\n<p>我们可以看到第一次调<code>next</code>返回的就是第一个<code>yeild</code>后面表达式的值，也就是1。<strong>需要注意的是，整个迭代器目前暂停在了第一个<code>yield</code>这里，给变量<code>a</code>赋值都没执行，要调用下一个<code>next</code>的时候才会给变量<code>a</code>赋值，然后一直执行到第二个<code>yield</code></strong>。那应该给<code>a</code>赋什么值呢？从代码来看，<code>a</code>的值应该是<code>yield</code>语句的返回值，但是<code>yield</code>本身是没有返回值的，或者说返回值是<code>undefined</code>，如果要给<code>a</code>赋值需要下次调<code>next</code>的时候手动传进去，我们这里传一个4，4就会作为上次<code>yield</code>的返回值赋给<code>a</code>:</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023652883\" alt=\"image-20200419154159553\" title=\"image-20200419154159553\" /></p>\n<p>可以看到第二个<code>yield</code>后面的表达式<code>a + 2</code>的值是6，这是因为我们传进去的4被作为上一个<code>yield</code>的返回值了，然后计算<code>a + 2</code>自然就是6了。</p>\n<p>我们继续<code>next</code>，把这个迭代器走完：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023652885\" alt=\"image-20200419155225702\" title=\"image-20200419155225702\" /></p>\n<p>上图是接着前面运行的，图中第一个<code>next</code>返回的<code>value</code>是<code>NaN</code>是因为我们调<code>next</code>的时候没有传参数，也就是说<code>b</code>为<code>undefined</code>，<code>undefined + 3</code>就为<code>NaN</code>了 。最后一个<code>next</code>其实是把函数体执行完了，这时候的<code>value</code>应该是这个函数<code>return</code>的值，但是因为我们没有写<code>return</code>，默认就是<code>return undefined</code>了，执行完后<code>done</code>会被置为<code>true</code>。</p>\n<h4>throw</h4>\n<p>迭代器还有个方法是<code>throw</code>，这个方法可以在函数体外部抛出错误，然后在函数里面捕获，还是上面那个例子:</p>\n<pre><code class=\"javascript\">function* gen() {\n  let a = yield 1;\n  let b = yield a + 2;\n  yield b + 3;\n}\n\nlet itor = gen();  </code></pre>\n<p>我们这次不用<code>next</code>执行了，直接<code>throw</code>错误出来:</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023652884\" alt=\"image-20200419160330384\" title=\"image-20200419160330384\" /></p>\n<p>这个错误因为我们没有捕获，所以直接抛到最外层来了，我们可以在函数体里面捕获他，稍微改下:</p>\n<pre><code class=\"javascript\">function* gen() {\n  try {\n    let a = yield 1;\n    let b = yield a + 2;\n    yield b + 3;\n  } catch (e) {\n    console.log(e);\n  }\n}\n\nlet itor = gen();  </code></pre>\n<p>然后再来<code>throw</code>下：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023652886\" alt=\"image-20200419160604004\" title=\"image-20200419160604004\" /></p>\n<p>这个图可以看出来，错误在函数里里面捕获了，走到了<code>catch</code>里面，这里面只有一个<code>console</code>同步代码，整个函数直接就运行结束了，所以<code>done</code>变成<code>true</code>了，当然<code>catch</code>里面可以继续写<code>yield</code>然后用<code>next</code>来执行。</p>\n<h4>return</h4>\n<p>迭代器还有个<code>return</code>方法，这个方法就很简单了，他会直接终止当前迭代器，将<code>done</code>置为<code>true</code>，这个方法的参数就是迭代器的<code>value</code>，还是上面的例子：</p>\n<pre><code class=\"javascript\">function* gen() {\n  let a = yield 1;\n  let b = yield a + 2;\n  yield b + 3;\n}\n\nlet itor = gen();  </code></pre>\n<p>这次我们直接调用<code>return</code>:</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023652887\" alt=\"image-20200419161105691\" title=\"image-20200419161105691\" /></p>\n<h4>yield*</h4>\n<p>简单理解，<code>yield*</code>就是在生成器里面调用另一个生成器，但是他并不会占用一个<code>next</code>，而是直接进入被调用的生成器去运行。</p>\n<pre><code class=\"javascript\">function* gen() {\n  let a = yield 1;\n  let b = yield a + 2;\n}\n\nfunction* gen2() {\n  yield 10 + 5;\n  yield* gen();\n}\n\nlet itor = gen2();  </code></pre>\n<p>上面代码我们第一次调用<code>next</code>，值自然是<code>10 + 5</code>，即15，然后第二次调用<code>next</code>，其实就走到了<code>yield*</code>了，这其实就相当于调用了<code>gen</code>，然后执行他的第一个<code>yield</code>，值就是1。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023652888\" alt=\"image-20200419161624637\" title=\"image-20200419161624637\" /></p>\n<h3>协程</h3>\n<p>其实Generator就是实现了协程，协程是一个比线程还小的概念。一个进程可以有多个线程，一个线程可以有多个协程，但是一个线程同时只能有一个协程在运行。这个意思就是说如果当前协程可以执行，比如同步代码，那就执行他，如果当前协程暂时不能继续执行，比如他是一个异步读文件的操作，那就将它挂起，然后去执行其他协程，等这个协程结果回来了，可以继续了再来执行他。<code>yield</code>其实就相当于将当前任务挂起了，下次调用再从这里开始。协程这个概念其实很多年前就已经被提出来了，其他很多语言也有自己的实现。Generator相当于JS实现的协程。</p>\n<h3>异步应用</h3>\n<p>前面讲了Generator的基本用法，我们用它来处理一个异步事件看看。我还是使用前面文章用到过的例子，三个网络请求，请求3依赖请求2的结果，请求2依赖请求1的结果，如果使用回调是这样的:</p>\n<pre><code class=\"javascript\">const request = require(\"request\");\n\nrequest('https://www.baidu.com', function (error, response) {\n  if (!error &amp;&amp; response.statusCode == 200) {\n    console.log('get times 1');\n\n    request('https://www.baidu.com', function(error, response) {\n      if (!error &amp;&amp; response.statusCode == 200) {\n        console.log('get times 2');\n\n        request('https://www.baidu.com', function(error, response) {\n          if (!error &amp;&amp; response.statusCode == 200) {\n            console.log('get times 3');\n          }\n        })\n      }\n    })\n  }\n});</code></pre>\n<p>我们这次使用Generator来解决“回调地狱”：</p>\n<pre><code class=\"javascript\">const request = require(\"request\");\n\nfunction* requestGen() {\n  function sendRequest(url) {\n    request(url, function (error, response) {\n      if (!error &amp;&amp; response.statusCode == 200) {\n        console.log(response.body);\n\n        // 注意这里，引用了外部的迭代器itor\n        itor.next(response.body);\n      }\n    })\n  }\n\n  const url = 'https://www.baidu.com';\n\n  // 使用yield发起三个请求，每个请求成功后再继续调next\n  const r1 = yield sendRequest(url);\n  console.log('r1', r1);\n  const r2 = yield sendRequest(url);\n  console.log('r2', r2);\n  const r3 = yield sendRequest(url);\n  console.log('r3', r3);\n}\n\nconst itor = requestGen();\n\n// 手动调第一个next\nitor.next();</code></pre>\n<p>这个例子中我们在生成器里面写了一个请求方法，这个方法会去发起网络请求，每次网络请求成功后又继续调用next执行后面的<code>yield</code>，最后是在外层手动调一个<code>next</code>触发这个流程。这其实就类似一个尾调用，这样写可以达到效果，但是在<code>requestGen</code>里面引用了外面的迭代器<code>itor</code>，耦合很高，而且不好复用。</p>\n<h2>thunk函数</h2>\n<p>为了解决前面说的耦合高，不好复用的问题，就有了thunk函数。thunk函数理解起来有点绕，我先把代码写出来，然后再一步一步来分析它的执行顺序：</p>\n<pre><code class=\"javascript\">function Thunk(fn) {\n  return function(...args) {\n    return function(callback) {\n      return fn.call(this, ...args, callback)\n    }\n  }\n}\n\nfunction run(fn) {\n  let gen = fn();\n  \n  function next(err, data) {\n    let result = gen.next(data);\n    \n    if(result.done) return;\n    \n    result.value(next);\n  }\n  \n  next();\n}\n\n// 使用thunk方法\nconst request = require(\"request\");\nconst requestThunk = Thunk(request);\n\nfunction* requestGen() {\n  const url = 'https://www.baidu.com';\n  \n  let r1 = yield requestThunk(url);\n  console.log(r1.body);\n  \n  let r2 = yield requestThunk(url);\n  console.log(r2.body);\n  \n  let r3 = yield requestThunk(url);\n  console.log(r3.body);\n}\n\n// 启动运行\nrun(requestGen);</code></pre>\n<p>这段代码里面的Thunk函数返回了好几层函数，我们从他的使用入手一层一层剥开看：</p>\n<ol>\n <li><p><code>requestThunk</code>是Thunk运行的返回值，也就是第一层返回值，参数是<code>request</code>，也就是:</p><pre><code class=\"javascript\">function(...args) {\n  return function(callback) {\n    return request.call(this, ...args, callback);   // 注意这里调用的是request\n  }\n}</code></pre></li>\n <li><p><code>run</code>函数的参数是生成器，我们看看他到底干了啥:</p>\n  <blockquote>\n   <ol>\n    <li>run里面先调用生成器，拿到迭代器<code>gen</code>，然后自定义了一个<code>next</code>方法，并调用这个<code>next</code>方法，为了便于区分，我这里称这个自定义的<code>next</code>为局部<code>next</code></li>\n    <li><p>局部<code>next</code>会调用生成器的<code>next</code>，生成器的<code>next</code>其实就是<code>yield requestThunk(url)</code>，参数是我们传进去的<code>url</code>，这就调到我们前面的那个方法，这个<code>yield</code>返回的<code>value</code>其实是：</p><pre><code class=\"javascript\">function(callback) {\n  return request.call(this, url, callback);   \n}</code></pre></li>\n    <li>检测迭代器是否已经迭代完毕，如果没有，就继续调用第二步的这个函数，这个函数其实才真正的去<code>request</code>，这时候传进去的参数是局部<code>next</code>，局部<code>next</code>也作为了<code>request</code>的回调函数。</li>\n    <li>这个回调函数在执行时又会调<code>gen.next</code>，这样生成器就可以继续往下执行了，同时<code>gen.next</code>的参数是回调函数的<code>data</code>，这样，生成器里面的<code>r1</code>其实就拿到了请求的返回值。</li>\n   </ol>\n  </blockquote></li>\n</ol>\n<p>Thunk函数就是这样一种可以自动执行Generator的函数，因为Thunk函数的包装，我们在Generator里面可以像同步代码那样直接拿到<code>yield</code>异步代码的返回值。</p>\n<h2>co模块</h2>\n<p>co模块是一个很受欢迎的模块，他也可以自动执行Generator，他的yield后面支持thunk和Promise，我们先来看看他的基本使用，然后再去分析下他的源码。<br>官方GitHub：<a href=\"https://github.com/tj/co\" rel=\"nofollow noreferrer\">https://github.com/tj/co</a></br></p>\n<h3>基本使用</h3>\n<h4>支持thunk</h4>\n<p>前面我们讲了thunk函数，我们还是从thunk函数开始。代码还是用我们前面写的thunk函数，但是因为co支持的thunk是只接收回调函数的函数形式，我们使用时需要调整下:</p>\n<pre><code class=\"javascript\">// 还是之前的thunk函数\nfunction Thunk(fn) {\n  return function(...args) {\n    return function(callback) {\n      return fn.call(this, ...args, callback)\n    }\n  }\n}\n\n// 将我们需要的request转换成thunk\nconst request = require('request');\nconst requestThunk = Thunk(request);\n\n// 转换后的requestThunk其实可以直接用了\n// 用法就是 requestThunk(url)(callback)\n// 但是我们co接收的thunk是 fn(callback)形式\n// 我们转换一下\n// 这时候的baiduRequest也是一个函数，url已经传好了，他只需要一个回调函数做参数就行\n// 使用就是这样：baiduRequest(callback)\nconst baiduRequest = requestThunk('https://www.baidu.com');\n\n// 引入co执行, co的参数是一个Generator\n// co的返回值是一个Promise，我们可以用then拿到他的结果\nconst co = require('co');\nco(function* () {\n  const r1 = yield baiduRequest;\n  const r2 = yield baiduRequest;\n  const r3 = yield baiduRequest;\n  \n  return {\n    r1,\n    r2,\n    r3,\n  }\n}).then((res) =&gt; {\n  // then里面就可以直接拿到前面返回的{r1, r2, r3}\n  console.log(res);\n});</code></pre>\n<h4>支持Promise</h4>\n<p>其实co官方是建议yield后面跟Promise的，虽然支持thunk，但是未来可能会移除。使用Promise，我们代码写起来其实更简单，直接用fetch就行，不用包装Thunk。</p>\n<pre><code class=\"javascript\">const fetch = require('node-fetch');\nconst co = require('co');\nco(function* () {\n  // 直接用fetch，简单多了，fetch返回的就是Promise\n  const r1 = yield fetch('https://www.baidu.com');\n  const r2 = yield fetch('https://www.baidu.com');\n  const r3 = yield fetch('https://www.baidu.com');\n  \n  return {\n    r1,\n    r2,\n    r3,\n  }\n}).then((res) =&gt; {\n  // 这里同样可以拿到{r1, r2, r3}\n  console.log(res);\n});</code></pre>\n<h3>源码分析</h3>\n<p>本文的源码分析基于co模块4.6.0版本，源码：<a href=\"https://github.com/tj/co/blob/master/index.js\" rel=\"nofollow noreferrer\">https://github.com/tj/co/blob/master/index.js</a></p>\n<p>仔细看源码会发现他代码并不多，总共两百多行，一半都是在进行yield后面的参数检测和处理，检测他是不是Promise，如果不是就转换为Promise，所以即使你yield后面传的thunk，他还是会转换成Promise处理。转换Promise的代码相对比较独立和简单，我这里不详细展开了，这里主要还是讲一讲核心方法<code>co(gen)</code>。下面是我复制的去掉了注释的简化代码:</p>\n<pre><code class=\"javascript\">function co(gen) {\n  var ctx = this;\n  var args = slice.call(arguments, 1);\n\n  return new Promise(function(resolve, reject) {\n    if (typeof gen === 'function') gen = gen.apply(ctx, args);\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\n\n    onFulfilled();\n\n    function onFulfilled(res) {\n      var ret;\n      try {\n        ret = gen.next(res);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n      return null;\n    }\n\n    function onRejected(err) {\n      var ret;\n      try {\n        ret = gen.throw(err);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n    function next(ret) {\n      if (ret.done) return resolve(ret.value);\n      var value = toPromise.call(ctx, ret.value);\n      if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);\n      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '\n        + 'but the following object was passed: \"' + String(ret.value) + '\"'));\n    }\n  });\n}</code></pre>\n<ol>\n <li>从整体结构看，co的参数是一个Generator，返回值是一个Promise，几乎所有逻辑代码都在这个Promise里面，这也是我们使用时用then拿结果的原因。</li>\n <li>Promise里面先把Generator拿出来执行，得到一个迭代器<code>gen</code></li>\n <li><p>手动调用一次<code>onFulfilled</code>，开启迭代</p>\n  <blockquote>\n   <ol>\n    <li><code>onFulfilled</code>接收一个参数<code>res</code>，第一次调用是没有传这个参数，这个参数主要是用来接收后面的then返回的结果。</li>\n    <li>然后调用<code>gen.next</code>，注意这个的返回值ret的形式是{value, done}，然后将这个ret传给局部的next</li>\n   </ol>\n  </blockquote></li>\n <li><p>然后执行局部next，他接收的参数是yield返回值{value, done}</p>\n  <blockquote>\n   <ol>\n    <li>这里先检测迭代是否完成，如果完成了，就直接将整个promise resolve。</li>\n    <li>这里的value是yield后面表达式的值，可能是thunk，也可能是promise</li>\n    <li>将value转换成promise</li>\n    <li>将转换后的promise拿出来执行，成功的回调是前面的<code>onFulfilled</code></li>\n   </ol>\n  </blockquote></li>\n <li>我们再来看下<code>onFulfilled</code>，这是第二次执行<code>onFulfilled</code>了。这次执行的时候传入的参数res是上次异步promise的执行结果，对应我们的fetch就是拿回来的数据，这个数据传给第二个<code>gen.next</code>，效果就是我们代码里面的赋值给了第一个<code>yield</code>前面的变量<code>r1</code>。然后继续局部next，这个next其实就是执行第二个异步Promise了。这个promise的成功回调又继续调用<code>gen.next</code>，这样就不断的执行下去，直到<code>done</code>变成<code>true</code>为止。</li>\n <li>最后看一眼<code>onRejected</code>方法，这个方法其实作为了异步promise的错误分支，这个函数里面直接调用了<code>gen.throw</code>，这样我们在Generator里面可以直接用<code>try...catch...</code>拿到错误。需要注意的是<code>gen.throw</code>后面还继续调用了<code>next(ret)</code>，这是因为在Generator的<code>catch</code>分支里面还可能继续有<code>yield</code>，比如错误上报的网络请求，这时候的迭代器并不一定结束了。</li>\n</ol>\n<h2>async/await</h2>\n<p>最后提一下<code>async/await</code>，先来看一下用法:</p>\n<pre><code class=\"javascript\">const fetch = require('node-fetch');\n\nasync function sendRequest () {\n  const r1 = await fetch('https://www.baidu.com');\n  const r2 = await fetch('https://www.baidu.com');\n  const r3 = await fetch('https://www.baidu.com');\n  \n  return {\n    r1,\n    r2,\n    r3,\n  }\n}\n\n// 注意async返回的也是一个promise\nsendRequest().then((res) =&gt; {\n  console.log('res', res);\n});</code></pre>\n<p>咋一看这个跟前面promise版的co是不是很像，返回值都是一个promise，只是Generator换成了一个<code>async</code>函数，函数里面的<code>yield</code>换成了<code>await</code>，而且外层不需要co来包裹也可以自动执行了。其实async函数就是Generator加自动执行器的语法糖，可以理解为从语言层面支持了Generator的自动执行。上面这段代码跟co版的promise其实就是等价的。</p>\n<h2>总结</h2>\n<ol>\n <li>Generator是一种更现代的异步解决方案，在JS语言层面支持了协程</li>\n <li>Generator的返回值是一个迭代器</li>\n <li>这个迭代器需要手动调<code>next</code>才能一条一条执行<code>yield</code></li>\n <li><code>next</code>的返回值是{value, done}，<code>value</code>是yield后面表达式的值</li>\n <li><code>yield</code>语句本身并没有返回值，下次调<code>next</code>的参数会作为上一个<code>yield</code>语句的返回值</li>\n <li>Generator自己不能自动执行，要自动执行需要引入其他方案，前面讲<code>thunk</code>的时候提供了一种方案，<code>co</code>模块也是一个很受欢迎的自动执行方案</li>\n <li>这两个方案的思路有点类似，都是先写一个局部的方法，这个方法会去调用<code>gen.next</code>，同时这个方法本身又会传到回调函数或者promise的成功分支里面，异步结束后又继续调用这个局部方法，这个局部方法又调用<code>gen.next</code>，这样一直迭代，直到迭代器执行完毕。</li>\n <li><code>async/await</code>其实是Generator和自动执行器的语法糖，写法和实现原理都类似co模块的promise模式。</li>\n</ol>\n<p><strong>文章的最后，感谢你花费宝贵的时间阅读本文，如果本文给了你一点点帮助或者启发，请不要吝啬你的赞和GitHub小星星，你的支持是作者持续创作的动力。</strong></p>\n<p><strong>作者博文GitHub项目地址： <a href=\"https://github.com/dennis-jiang/Front-End-Knowledges\" rel=\"nofollow noreferrer\">https://github.com/dennis-jiang/Front-End-Knowledges</a></strong></p>","descriptionType":"html","publishedDate":"Mon, 17 Aug 2020 02:44:39 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023652882","linkMd5":"d0ff9ddefe9a6a882e6318d475159e5e","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx/cdn94@2020_1/2020/08/24/23-08-21-894_de0e13cfc9042733.webp","destWidth":221,"destHeight":44,"sourceBytes":5263,"destBytes":1932,"author":"蒋鹏飞","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023652882":"https://cdn.jsdelivr.net/gh/myreaderx/cdn94@2020_1/2020/08/24/23-08-21-894_de0e13cfc9042733.webp","https://segmentfault.com/img/remote/1460000023652883":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn12@2020_2/2020/08/24/23-08-36-976_aa939d9b8362bbcf.webp","https://segmentfault.com/img/remote/1460000023652885":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn16@2020_2/2020/08/24/23-08-38-819_d6f77ebf0796d56f.webp","https://segmentfault.com/img/remote/1460000023652884":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn20@2020_6/2020/08/24/23-08-39-520_d14dbd35c4d89843.webp","https://segmentfault.com/img/remote/1460000023652886":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn51@2020_5/2020/08/24/23-08-38-491_33b83eb09ae0f820.webp","https://segmentfault.com/img/remote/1460000023652887":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn48@2020_5/2020/08/24/23-08-39-891_6cd080a4e73af923.webp","https://segmentfault.com/img/remote/1460000023652888":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn56@2020_3/2020/08/24/23-08-38-339_51682126a715d4c0.webp"},"publishedOrCreatedDate":1598310388568}],"record":{"createdTime":"2020-08-25 07:06:28","updatedTime":"2020-08-25 07:06:28","feedId":6615,"fetchDate":"Mon, 24 Aug 2020 23:06:28 +0000","fetchMs":3656,"handleMs":5945,"totalMs":164347,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"52.18.59.102","hostName":"europe-22.herokuapp.com","requestId":"6ddc10fb0dc14114b45a5867560605a5_6615","contentType":"application/atom+xml; charset=UTF-8","totalBytes":7426814,"bgimgsTotal":46,"bgimgsGithubTotal":46,"articlesImgsTotal":288,"articlesImgsGithubTotal":283,"successGithubMap":{"myreaderx14":9,"myreaderx8":9,"myreaderx7":11,"myreaderx15":9,"myreaderx16":9,"myreaderx6":10,"myreaderx10":10,"myreaderx4":10,"myreaderx32":9,"myreaderx3":11,"myreaderx33":10,"myreaderx11":10,"myreaderx12":11,"myreaderx2":9,"myreaderx1":9,"myreaderx13":9,"myreaderx30":10,"myreaderx31":11,"myreaderx18":10,"myreaderx19":11,"myreaderx":10,"myreaderx25":10,"myreaderx27":10,"myreaderx21":10,"myreaderx22":9,"myreaderx23":10,"myreaderx24":10,"myreaderx5oss":9,"myreaderx29":8},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:33:08","updatedTime":"2020-08-25 04:33:08","id":6615,"name":"SegmentFault 最新的文章","url":"http://segmentfault.com/feeds/blogs","subscriber":null,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"https://segmentfault.com"},"noPictureArticleList":[{"createdTime":"2020-08-25 07:09:02","updatedTime":"2020-08-25 07:09:02","id":null,"feedId":6615,"linkMd5":"3c5ab7837e45f9183c9783494075346a"},{"createdTime":"2020-08-25 07:09:02","updatedTime":"2020-08-25 07:09:02","id":null,"feedId":6615,"linkMd5":"edffa444454de4e48a3d973ca7297088"}],"tmpCommonImgCdnBytes":1883052,"tmpBodyImgCdnBytes":5543762,"tmpBgImgCdnBytes":0,"extra4":{"start":1598310378003,"total":0,"statList":[{"spend":4628,"msg":"获取xml内容"},{"spend":5945,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":1,"msg":"修正封面图上传失败重新上传"},{"spend":35096,"msg":"正文链接上传到cdn"}]},"extra5":288,"extra6":288,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023652721","sourceStatusCode":409,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":1341,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:31","host":"europe-23*","referer":"https://segmentfault.com/a/1190000023652718","linkMd5ListStr":"edffa444454de4e48a3d973ca7297088","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[409],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023652721","sourceStatusCode":409,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":1455,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:33","host":"us-030*","referer":"https://segmentfault.com/a/1190000023652718","linkMd5ListStr":"edffa444454de4e48a3d973ca7297088","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[409],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730239","sourceStatusCode":401,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":2359,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:38","host":"us-55*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[401],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730240","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4331,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:38","host":"us-035*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730237","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4307,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:38","host":"us-024*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730238","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4550,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:37","host":"europe65*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730239","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4903,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:40","host":"europe-24*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730240","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4559,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:42","host":"us-031*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730237","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4844,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:42","host":"europe68*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730238","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":5125,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:42","host":"europe-25*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730239","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":5606,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:45","host":"us-008*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730240","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4548,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:47","host":"us-011*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730237","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4430,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:47","host":"us-014*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730238","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4334,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:47","host":"us-010*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730239","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4315,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:51","host":"us-027*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730237","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4436,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:52","host":"us-033*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730238","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4621,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:52","host":"us-033*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730240","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":5208,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:51","host":"europe-57*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730239","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":5182,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:55","host":"us-021*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730237","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4567,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:56","host":"us-002*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730238","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":4340,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:57","host":"us-007*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023730240","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":5111,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:57","host":"us-54*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a","extra22GetBytesInfo":"2、Referer字段 ： https://segmentfault.com/a/1190000023730234","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"}],"extra10_invalidATagHrefValue":{"https://segmentfault.com/a/1190000023677258_#%E4%BA%8C%E5%88%86%E6%B3%95%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%8F%98%E7%A7%8D%E7%BB%93%E6%9E%84":"https://segmentfault.com/a/1190000023677258#%E4%BA%8C%E5%88%86%E6%B3%95%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%8F%98%E7%A7%8D%E7%BB%93%E6%9E%84","https://segmentfault.com/a/1190000023677258_#%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7":"https://segmentfault.com/a/1190000023677258#%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7","https://segmentfault.com/a/1190000023677258_#%E5%89%8D%E8%A8%80":"https://segmentfault.com/a/1190000023677258#%E5%89%8D%E8%A8%80","https://segmentfault.com/a/1190000023669152_#":"https://segmentfault.com/a/1190000023669152#","https://segmentfault.com/a/1190000023677258_#%E5%87%BA%E5%B8%88%E8%AF%95%E7%82%BC":"https://segmentfault.com/a/1190000023677258#%E5%87%BA%E5%B8%88%E8%AF%95%E7%82%BC","https://segmentfault.com/a/1190000023677258_#%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80":"https://segmentfault.com/a/1190000023677258#%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80"},"extra111_proxyServerAndStatMap":{"http://us-032.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-037.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-002.herokuapp.com/":{"failCount":1,"successCount":10,"resultList":[200,200,200,200,200,200,200,200,200,200,403]},"http://us-007.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,403]},"http://us-028.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-52.herokuapp.com/":{"failCount":0,"successCount":7,"resultList":[200,200,200,200,200,200,200]},"http://us-011.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,403]},"http://us-025.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-020.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-54.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,403]},"http://europe69.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-004.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://europe64.herokuapp.com/":{"failCount":0,"successCount":8,"resultList":[200,200,200,200,200,200,200,200]},"http://europe-57.herokuapp.com/":{"failCount":1,"successCount":2,"resultList":[200,200,403]},"http://us-016.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-013.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-24.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,403]},"http://us-039.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-55.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[401,200]},"http://europe61.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-030.herokuapp.com/":{"failCount":1,"successCount":7,"resultList":[200,200,200,200,200,200,409,200]},"http://us-026.herokuapp.com/":{"failCount":0,"successCount":9,"resultList":[200,200,200,200,200,200,200,200,200]},"http://europe-25.herokuapp.com/":{"failCount":1,"successCount":3,"resultList":[200,200,200,403]},"http://us-001.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-031.herokuapp.com/":{"failCount":1,"successCount":3,"resultList":[200,200,200,403]},"http://europe62.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-014.herokuapp.com/":{"failCount":1,"successCount":12,"resultList":[200,200,200,200,200,200,200,200,200,200,200,200,403]},"http://us-027.herokuapp.com/":{"failCount":1,"successCount":2,"resultList":[200,200,403]},"http://europe-56.herokuapp.com/":{"failCount":0,"successCount":9,"resultList":[200,200,200,200,200,200,200,200,200]},"http://us-53.herokuapp.com/":{"failCount":0,"successCount":4,"resultList":[200,200,200,200]},"http://europe68.herokuapp.com/":{"failCount":1,"successCount":7,"resultList":[200,200,200,200,200,200,200,403]},"http://europe63.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://europe-60.herokuapp.com/":{"failCount":0,"successCount":9,"resultList":[200,200,200,200,200,200,200,200,200]},"http://us-024.herokuapp.com/":{"failCount":1,"successCount":2,"resultList":[200,403,200]},"http://europe70.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-038.herokuapp.com/":{"failCount":0,"successCount":9,"resultList":[200,200,200,200,200,200,200,200,200]},"http://europe-23.herokuapp.com/":{"failCount":1,"successCount":6,"resultList":[200,200,200,200,200,409,200]},"http://europe21.herokuapp.com/":{"failCount":0,"successCount":4,"resultList":[200,200,200,200]},"http://us-033.herokuapp.com/":{"failCount":2,"successCount":4,"resultList":[200,200,200,200,403,403]},"http://us-003.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-008.herokuapp.com/":{"failCount":1,"successCount":4,"resultList":[200,200,200,200,403]},"http://us-029.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-012.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-018.herokuapp.com/":{"failCount":0,"successCount":8,"resultList":[200,200,200,200,200,200,200,200]},"http://europe65.herokuapp.com/":{"failCount":1,"successCount":3,"resultList":[200,403,200,200]},"http://us-021.herokuapp.com/":{"failCount":1,"successCount":2,"resultList":[200,200,403]},"http://us-034.herokuapp.com/":{"failCount":0,"successCount":8,"resultList":[200,200,200,200,200,200,200,200]},"http://us-005.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://europe-58.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-035.herokuapp.com/":{"failCount":1,"successCount":2,"resultList":[200,200,403]},"http://us-022.herokuapp.com/":{"failCount":0,"successCount":11,"resultList":[200,200,200,200,200,200,200,200,200,200,200]},"http://us-006.herokuapp.com/":{"failCount":0,"successCount":7,"resultList":[200,200,200,200,200,200,200]},"http://us-036.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-019.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-010.herokuapp.com/":{"failCount":1,"successCount":12,"resultList":[200,200,200,200,200,200,200,200,200,200,200,200,403]},"http://europe-59.herokuapp.com/":{"failCount":0,"successCount":4,"resultList":[200,200,200,200]},"http://europe67.herokuapp.com/":{"failCount":0,"successCount":5,"resultList":[200,200,200,200,200]},"http://us-51.herokuapp.com/":{"failCount":0,"successCount":4,"resultList":[200,200,200,200]},"http://us-023.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-040.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/banner-rmc-compare.png","sourceStatusCode":200,"destWidth":900,"destHeight":383,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn26@2020_4/2020/08/24/23-08-20-365_ca3ba6545607b5e9.webp","sourceBytes":526228,"destBytes":26564,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":1025,"convertSpendMs":44,"createdTime":"2020-08-25 07:08:20","host":"us-022*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f,cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"513.9 KB","destSize":"25.9 KB","compressRate":"5%"},{"code":1,"isDone":false,"source":"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu96ukhevj30h203mmxm.jpg","sourceStatusCode":200,"destWidth":614,"destHeight":130,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn98@2020_2/2020/08/24/23-08-21-517_8f13d8b07f643ac5.webp","sourceBytes":16877,"destBytes":8954,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2121,"convertSpendMs":42,"createdTime":"2020-08-25 07:08:20","host":"us-52*","referer":"https://segmentfault.com/a/1190000023668057","linkMd5ListStr":"dcb1ca1d6d9e74559b1305ed3b0d3469,dcb1ca1d6d9e74559b1305ed3b0d3469","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"16.5 KB","destSize":"8.7 KB","compressRate":"53.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023652882","sourceStatusCode":200,"destWidth":221,"destHeight":44,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn94@2020_1/2020/08/24/23-08-21-894_de0e13cfc9042733.webp","sourceBytes":5263,"destBytes":1932,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2839,"convertSpendMs":3,"createdTime":"2020-08-25 07:08:20","host":"europe64*","referer":"https://segmentfault.com/a/1190000023652879","linkMd5ListStr":"d0ff9ddefe9a6a882e6318d475159e5e,d0ff9ddefe9a6a882e6318d475159e5e","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"5.1 KB","destSize":"1.9 KB","compressRate":"36.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023601930","sourceStatusCode":200,"destWidth":800,"destHeight":417,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn50@2020_1/2020/08/24/23-08-21-971_83bb94c2dc369fca.webp","sourceBytes":52499,"destBytes":10952,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2912,"convertSpendMs":15,"createdTime":"2020-08-25 07:08:20","host":"europe64*","referer":"https://segmentfault.com/a/1190000023601927","linkMd5ListStr":"caee1d7512ed006f50fb714e278bb4f4,caee1d7512ed006f50fb714e278bb4f4","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"51.3 KB","destSize":"10.7 KB","compressRate":"20.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbESbH","sourceStatusCode":200,"destWidth":258,"destHeight":258,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn79@2020_4/2020/08/24/23-08-22-002_23e3d2b285dd74b0.webp","sourceBytes":9980,"destBytes":9980,"feedId":6615,"totalSpendMs":2941,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:20","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023691221","linkMd5ListStr":"ed2d9ff0860340e13c972d901109e6db,ed2d9ff0860340e13c972d901109e6db","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"9.7 KB","destSize":"9.7 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLphW","sourceStatusCode":200,"destWidth":800,"destHeight":430,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn55@2020_5/2020/08/24/23-08-22-420_8237a8f2bc153c7c.webp","sourceBytes":25107,"destBytes":4332,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3208,"convertSpendMs":15,"createdTime":"2020-08-25 07:08:20","host":"europe63*","referer":"https://segmentfault.com/a/1190000023652718","linkMd5ListStr":"edffa444454de4e48a3d973ca7297088,edffa444454de4e48a3d973ca7297088","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.5 KB","destSize":"4.2 KB","compressRate":"17.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023473305","sourceStatusCode":200,"destWidth":800,"destHeight":317,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn14@2020_2/2020/08/24/23-08-22-277_79d59aaca7438433.webp","sourceBytes":62172,"destBytes":17268,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3293,"convertSpendMs":15,"createdTime":"2020-08-25 07:08:20","host":"europe68*","referer":"https://segmentfault.com/a/1190000023736395","linkMd5ListStr":"420bda976c9e79232c9adc2d2bfab39b,0350953f3ed11c58067e084970f74395,420bda976c9e79232c9adc2d2bfab39b,0350953f3ed11c58067e084970f74395","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"60.7 KB","destSize":"16.9 KB","compressRate":"27.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023707764","sourceStatusCode":200,"destWidth":800,"destHeight":139,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn37@2020_5/2020/08/24/23-08-22-393_74b3a8806a1a5203.webp","sourceBytes":63134,"destBytes":18322,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3361,"convertSpendMs":10,"createdTime":"2020-08-25 07:08:20","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023707760","linkMd5ListStr":"0efc7a62efcc894fd0f116660993cd89,0efc7a62efcc894fd0f116660993cd89","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"61.7 KB","destSize":"17.9 KB","compressRate":"29%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLFeR","sourceStatusCode":200,"destWidth":800,"destHeight":532,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn18@2020_5/2020/08/24/23-08-22-045_aea76744bd0bf3f8.webp","sourceBytes":78474,"destBytes":22338,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3439,"convertSpendMs":16,"createdTime":"2020-08-25 07:08:20","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023714011","linkMd5ListStr":"317dc10a0d3fb89965600980c204116d,317dc10a0d3fb89965600980c204116d","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"76.6 KB","destSize":"21.8 KB","compressRate":"28.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLqMU","sourceStatusCode":200,"destWidth":300,"destHeight":300,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn65@2020_5/2020/08/24/23-08-22-735_cebd68292a8c6202.webp","sourceBytes":20447,"destBytes":5946,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3327,"convertSpendMs":11,"createdTime":"2020-08-25 07:08:20","host":"us-030*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee,6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"20 KB","destSize":"5.8 KB","compressRate":"29.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023636705","sourceStatusCode":200,"destWidth":461,"destHeight":180,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn78@2020_2/2020/08/24/23-08-22-752_88bc2bcf04a82bf3.webp","sourceBytes":32231,"destBytes":9310,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3350,"convertSpendMs":11,"createdTime":"2020-08-25 07:08:20","host":"us-55*","referer":"https://segmentfault.com/a/1190000023636701","linkMd5ListStr":"3f522baba1e817cf81ff90c5e1d10cfb,3f522baba1e817cf81ff90c5e1d10cfb","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"31.5 KB","destSize":"9.1 KB","compressRate":"28.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdLv","sourceStatusCode":200,"destWidth":800,"destHeight":300,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn69@2020_2/2020/08/24/23-08-22-589_061a58f778cd47e5.webp","sourceBytes":101996,"destBytes":7834,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3521,"convertSpendMs":16,"createdTime":"2020-08-25 07:08:20","host":"europe-23*","referer":"https://segmentfault.com/a/1190000023608432","linkMd5ListStr":"749b88d16e8263f6e6691f06881f8209,749b88d16e8263f6e6691f06881f8209","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"99.6 KB","destSize":"7.7 KB","compressRate":"7.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676550","sourceStatusCode":200,"destWidth":800,"destHeight":323,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn2@2020_3/2020/08/24/23-08-22-747_a6db2e4da23bc72a.webp","sourceBytes":30082,"destBytes":7094,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3372,"convertSpendMs":21,"createdTime":"2020-08-25 07:08:20","host":"us-030*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5,c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"29.4 KB","destSize":"6.9 KB","compressRate":"23.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLr7m","sourceStatusCode":200,"destWidth":800,"destHeight":340,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn74@2020_1/2020/08/24/23-08-22-400_863f702969491e2a.webp","sourceBytes":81708,"destBytes":24254,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3559,"convertSpendMs":27,"createdTime":"2020-08-25 07:08:20","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023663493","linkMd5ListStr":"b02edc6d556383db4bdfaad310312379,b02edc6d556383db4bdfaad310312379","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"79.8 KB","destSize":"23.7 KB","compressRate":"29.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023648367","sourceStatusCode":200,"destWidth":800,"destHeight":337,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn98@2020_1/2020/08/24/23-08-22-613_13d61e813eca2336.webp","sourceBytes":128310,"destBytes":26444,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3625,"convertSpendMs":15,"createdTime":"2020-08-25 07:08:20","host":"europe-23*","referer":"https://segmentfault.com/a/1190000023648364","linkMd5ListStr":"47f945d0758f841a94d5a32def62ad1a,47f945d0758f841a94d5a32def62ad1a","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"125.3 KB","destSize":"25.8 KB","compressRate":"20.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023677261","sourceStatusCode":200,"destWidth":219,"destHeight":219,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn86@2020_6/2020/08/24/23-08-22-904_dce38b7c68cc1701.webp","sourceBytes":7088,"destBytes":6372,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3517,"convertSpendMs":9,"createdTime":"2020-08-25 07:08:20","host":"us-014*","referer":"https://segmentfault.com/a/1190000023677258","linkMd5ListStr":"81351ef5cee65b004bca5b0902fb9913,81351ef5cee65b004bca5b0902fb9913","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"6.9 KB","destSize":"6.2 KB","compressRate":"89.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000018549678","sourceStatusCode":200,"destWidth":258,"destHeight":258,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn62@2020_2/2020/08/24/23-08-22-916_a02e97e5e2b41934.webp","sourceBytes":20858,"destBytes":6490,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3528,"convertSpendMs":8,"createdTime":"2020-08-25 07:08:20","host":"us-52*","referer":"https://segmentfault.com/a/1190000023734444","linkMd5ListStr":"77294d18bacb4a429bc351cad2ce49d1,b7dfe327eb9a61822da340b39059d2f1,77294d18bacb4a429bc351cad2ce49d1,b7dfe327eb9a61822da340b39059d2f1","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"20.4 KB","destSize":"6.3 KB","compressRate":"31.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLbdV","sourceStatusCode":200,"destWidth":800,"destHeight":361,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn90@2020_2/2020/08/24/23-08-22-917_b612e89919e9c268.webp","sourceBytes":60839,"destBytes":11212,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3545,"convertSpendMs":17,"createdTime":"2020-08-25 07:08:20","host":"us-002*","referer":"https://segmentfault.com/a/1190000023601065","linkMd5ListStr":"76c9c6e6cb88560c51a4d8dfd2fa525b,76c9c6e6cb88560c51a4d8dfd2fa525b","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"59.4 KB","destSize":"10.9 KB","compressRate":"18.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK4w3","sourceStatusCode":200,"destWidth":800,"destHeight":450,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn14@2020_6/2020/08/24/23-08-22-984_c34630b4bcb95121.webp","sourceBytes":40285,"destBytes":12508,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2417,"convertSpendMs":20,"createdTime":"2020-08-25 07:08:21","host":"us-014*","referer":"https://segmentfault.com/a/1190000023572844","linkMd5ListStr":"b422d5e4e3dee35be3d3afd3b84c77cd,b422d5e4e3dee35be3d3afd3b84c77cd","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"39.3 KB","destSize":"12.2 KB","compressRate":"31%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023735152","sourceStatusCode":200,"destWidth":254,"destHeight":121,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn94@2020_3/2020/08/24/23-08-22-973_d9a4a0f3fdb1bd81.webp","sourceBytes":8576,"destBytes":3076,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3598,"convertSpendMs":15,"createdTime":"2020-08-25 07:08:20","host":"us-010*","referer":"https://segmentfault.com/a/1190000023735149","linkMd5ListStr":"e96585e49877b1a5d367d8d830ee693d,e96585e49877b1a5d367d8d830ee693d","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"8.4 KB","destSize":"3 KB","compressRate":"35.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK8rH","sourceStatusCode":200,"destWidth":800,"destHeight":444,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn2@2020_3/2020/08/24/23-08-22-403_40b51c4991f714b5.webp","sourceBytes":79075,"destBytes":58018,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3744,"convertSpendMs":39,"createdTime":"2020-08-25 07:08:20","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023587881","linkMd5ListStr":"38260b3f6e6b52df89d4a67c52a99d4e,38260b3f6e6b52df89d4a67c52a99d4e","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"77.2 KB","destSize":"56.7 KB","compressRate":"73.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023699209","sourceStatusCode":200,"destWidth":459,"destHeight":412,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn51@2020_5/2020/08/24/23-08-22-960_ae361416bba7e1ff.webp","sourceBytes":216965,"destBytes":14810,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3635,"convertSpendMs":16,"createdTime":"2020-08-25 07:08:20","host":"us-001*","referer":"https://segmentfault.com/a/1190000023699206","linkMd5ListStr":"fbe29875f9063bd2517a65d848a2914c,fbe29875f9063bd2517a65d848a2914c","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"211.9 KB","destSize":"14.5 KB","compressRate":"6.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023604341","sourceStatusCode":200,"destWidth":720,"destHeight":365,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn90@2020_2/2020/08/24/23-08-22-943_ebf9b33d099efdb6.webp","sourceBytes":32507,"destBytes":23038,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3649,"convertSpendMs":15,"createdTime":"2020-08-25 07:08:20","host":"us-022*","referer":"https://segmentfault.com/a/1190000023604337","linkMd5ListStr":"7fbcd44c2485b915a169b959a08502eb,7fbcd44c2485b915a169b959a08502eb","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"31.7 KB","destSize":"22.5 KB","compressRate":"70.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709792","sourceStatusCode":200,"destWidth":678,"destHeight":64,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn9@2020_2/2020/08/24/23-08-23-053_139a4be2af02dca5.webp","sourceBytes":3107,"destBytes":2152,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3650,"convertSpendMs":15,"createdTime":"2020-08-25 07:08:20","host":"us-026*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d,ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"3 KB","destSize":"2.1 KB","compressRate":"69.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLKdl","sourceStatusCode":200,"destWidth":800,"destHeight":342,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn21@2020_1/2020/08/24/23-08-23-024_2805d581158c2c2d.webp","sourceBytes":70114,"destBytes":27064,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3715,"convertSpendMs":22,"createdTime":"2020-08-25 07:08:20","host":"us-034*","referer":"https://segmentfault.com/a/1190000023733064","linkMd5ListStr":"2bab059fcc83687a9e4e5c0f8280a58a,2bab059fcc83687a9e4e5c0f8280a58a","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"68.5 KB","destSize":"26.4 KB","compressRate":"38.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLJtP","sourceStatusCode":200,"destWidth":800,"destHeight":340,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn86@2020_1/2020/08/24/23-08-23-023_4f776d9d8dfa05aa.webp","sourceBytes":93089,"destBytes":25484,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3722,"convertSpendMs":26,"createdTime":"2020-08-25 07:08:20","host":"us-034*","referer":"https://segmentfault.com/a/1190000023730234","linkMd5ListStr":"3c5ab7837e45f9183c9783494075346a,3c5ab7837e45f9183c9783494075346a","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"90.9 KB","destSize":"24.9 KB","compressRate":"27.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023708779","sourceStatusCode":200,"destWidth":754,"destHeight":488,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn42@2020_5/2020/08/24/23-08-23-053_b410fb298e7c2e62.webp","sourceBytes":38573,"destBytes":14822,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3732,"convertSpendMs":27,"createdTime":"2020-08-25 07:08:20","host":"us-038*","referer":"https://segmentfault.com/a/1190000023708775","linkMd5ListStr":"b4d24379ce31382e9336abd377405f85,b4d24379ce31382e9336abd377405f85","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"37.7 KB","destSize":"14.5 KB","compressRate":"38.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023647613","sourceStatusCode":200,"destWidth":800,"destHeight":267,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn74@2020_6/2020/08/24/23-08-22-906_d94bb8e812bfe91b.webp","sourceBytes":14509,"destBytes":7928,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3790,"convertSpendMs":8,"createdTime":"2020-08-25 07:08:20","host":"us-006*","referer":"https://segmentfault.com/a/1190000023647609","linkMd5ListStr":"bd58cfa67f4f5a8296c3cadfd7f5f584,bd58cfa67f4f5a8296c3cadfd7f5f584","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"14.2 KB","destSize":"7.7 KB","compressRate":"54.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023737674","sourceStatusCode":200,"destWidth":800,"destHeight":449,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn78@2020_3/2020/08/24/23-08-23-064_68e17a2630a82d60.webp","sourceBytes":64842,"destBytes":31124,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3794,"convertSpendMs":26,"createdTime":"2020-08-25 07:08:20","host":"us-038*","referer":"https://segmentfault.com/a/1190000023737670","linkMd5ListStr":"f6d9b255d764f38d4cfc647c5d61450c,f6d9b255d764f38d4cfc647c5d61450c","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"63.3 KB","destSize":"30.4 KB","compressRate":"48%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023657732","sourceStatusCode":200,"destWidth":800,"destHeight":406,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn6@2020_3/2020/08/24/23-08-23-128_3e079a22ca630726.webp","sourceBytes":111116,"destBytes":30308,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3822,"convertSpendMs":18,"createdTime":"2020-08-25 07:08:20","host":"us-018*","referer":"https://segmentfault.com/a/1190000023657729","linkMd5ListStr":"9569faa8acc0e079a1c10828ff9a417e,9569faa8acc0e079a1c10828ff9a417e","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"108.5 KB","destSize":"29.6 KB","compressRate":"27.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023655554","sourceStatusCode":200,"destWidth":800,"destHeight":458,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn9@2020_4/2020/08/24/23-08-23-117_4774f58479cda1db.webp","sourceBytes":333627,"destBytes":23424,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3858,"convertSpendMs":25,"createdTime":"2020-08-25 07:08:20","host":"us-006*","referer":"https://segmentfault.com/a/1190000023655551","linkMd5ListStr":"5043732a2558bb2fe1d74251745d70bf,5043732a2558bb2fe1d74251745d70bf","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"325.8 KB","destSize":"22.9 KB","compressRate":"7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbKYWU","sourceStatusCode":200,"destWidth":800,"destHeight":450,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn69@2020_4/2020/08/24/23-08-23-184_0d30b74097bcfe0f.webp","sourceBytes":209291,"destBytes":39226,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3882,"convertSpendMs":17,"createdTime":"2020-08-25 07:08:20","host":"us-018*","referer":"https://segmentfault.com/a/1190000023552474","linkMd5ListStr":"518d797df1c7c9d30e2acaaec433d26b,518d797df1c7c9d30e2acaaec433d26b","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"204.4 KB","destSize":"38.3 KB","compressRate":"18.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLvba","sourceStatusCode":200,"destWidth":800,"destHeight":534,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn6@2020_1/2020/08/24/23-08-23-211_d89633fd6dfd81d7.webp","sourceBytes":513728,"destBytes":23052,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3902,"convertSpendMs":36,"createdTime":"2020-08-25 07:08:20","host":"us-038*","referer":"https://segmentfault.com/a/1190000023675512","linkMd5ListStr":"8130037c23e0c993c51e97490b17f7b6,8130037c23e0c993c51e97490b17f7b6","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"501.7 KB","destSize":"22.5 KB","compressRate":"4.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLAIE","sourceStatusCode":200,"destWidth":800,"destHeight":355,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn46@2020_4/2020/08/24/23-08-23-218_dae355b894bbb09e.webp","sourceBytes":54090,"destBytes":17642,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3937,"convertSpendMs":118,"createdTime":"2020-08-25 07:08:20","host":"us-026*","referer":"https://segmentfault.com/a/1190000023696737","linkMd5ListStr":"6077149de366230a75fc5ccb09f8bad7,6077149de366230a75fc5ccb09f8bad7","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"52.8 KB","destSize":"17.2 KB","compressRate":"32.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLty0","sourceStatusCode":200,"destWidth":800,"destHeight":725,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn82@2020_3/2020/08/24/23-08-23-222_57802582ab559705.webp","sourceBytes":46146,"destBytes":17710,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3940,"convertSpendMs":118,"createdTime":"2020-08-25 07:08:20","host":"us-026*","referer":"https://segmentfault.com/a/1190000023669152","linkMd5ListStr":"c9849a6e55ae7d588b45b8503f19231a,c9849a6e55ae7d588b45b8503f19231a","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"45.1 KB","destSize":"17.3 KB","compressRate":"38.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLyLa","sourceStatusCode":200,"destWidth":800,"destHeight":450,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn66@2020_4/2020/08/24/23-08-23-072_538d4e9f5497d55e.webp","sourceBytes":100901,"destBytes":51728,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4052,"convertSpendMs":33,"createdTime":"2020-08-25 07:08:20","host":"us-010*","referer":"https://segmentfault.com/a/1190000023689023","linkMd5ListStr":"5a738e1afa2c3c1a2044a79c194873cd,5a738e1afa2c3c1a2044a79c194873cd","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"98.5 KB","destSize":"50.5 KB","compressRate":"51.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLgRH","sourceStatusCode":200,"destWidth":800,"destHeight":507,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn30@2020_3/2020/08/24/23-08-23-291_58228cad1bdea290.webp","sourceBytes":607936,"destBytes":65920,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4150,"convertSpendMs":67,"createdTime":"2020-08-25 07:08:20","host":"us-010*","referer":"https://segmentfault.com/a/1190000023622134","linkMd5ListStr":"feb087fef9d4181f56dd8589fa8fcc79,feb087fef9d4181f56dd8589fa8fcc79","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"593.7 KB","destSize":"64.4 KB","compressRate":"10.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023735009","sourceStatusCode":200,"destWidth":800,"destHeight":290,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn18@2020_4/2020/08/24/23-08-23-811_c3c6f2a2a3fccaba.webp","sourceBytes":36632,"destBytes":9762,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2154,"convertSpendMs":11,"createdTime":"2020-08-25 07:08:22","host":"us-002*","referer":"https://segmentfault.com/a/1190000023735006","linkMd5ListStr":"83e2007305092901a28598ddbadd1356,83e2007305092901a28598ddbadd1356","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"35.8 KB","destSize":"9.5 KB","compressRate":"26.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023517942","sourceStatusCode":200,"destWidth":800,"destHeight":739,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn21@2020_1/2020/08/24/23-08-24-093_e49a8578e1b0f2ed.webp","sourceBytes":62742,"destBytes":34606,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2342,"convertSpendMs":18,"createdTime":"2020-08-25 07:08:22","host":"europe64*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594,9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"61.3 KB","destSize":"33.8 KB","compressRate":"55.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023650522","sourceStatusCode":200,"destWidth":800,"destHeight":426,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn26@2020_5/2020/08/24/23-08-24-392_31a173cafd36f563.webp","sourceBytes":79664,"destBytes":37504,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2203,"convertSpendMs":30,"createdTime":"2020-08-25 07:08:23","host":"us-52*","referer":"https://segmentfault.com/a/1190000023650518","linkMd5ListStr":"569e2336cd79bc25ac4f434bfa5337fb,569e2336cd79bc25ac4f434bfa5337fb","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"77.8 KB","destSize":"36.6 KB","compressRate":"47.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023602036","sourceStatusCode":200,"destWidth":800,"destHeight":445,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn30@2020_2/2020/08/24/23-08-24-482_02dc9380d0589ef6.webp","sourceBytes":56763,"destBytes":40328,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2279,"convertSpendMs":16,"createdTime":"2020-08-25 07:08:23","host":"us-030*","referer":"https://segmentfault.com/a/1190000023602033","linkMd5ListStr":"a52d5aa652910e157d09aa5f6fb7920b,a52d5aa652910e157d09aa5f6fb7920b","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"55.4 KB","destSize":"39.4 KB","compressRate":"71%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023685022","sourceStatusCode":200,"destWidth":653,"destHeight":128,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn33@2020_6/2020/08/24/23-08-24-844_33ebdc5c0e4cb893.webp","sourceBytes":64675,"destBytes":10000,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2268,"convertSpendMs":9,"createdTime":"2020-08-25 07:08:23","host":"us-018*","referer":"https://segmentfault.com/a/1190000023685018","linkMd5ListStr":"c6ea63b543bcf14780252f9af45af4e0,c6ea63b543bcf14780252f9af45af4e0","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"63.2 KB","destSize":"9.8 KB","compressRate":"15.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663455","sourceStatusCode":200,"destWidth":770,"destHeight":494,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn38@2020_4/2020/08/24/23-08-24-961_f11044dd1174001a.webp","sourceBytes":334245,"destBytes":28466,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2337,"convertSpendMs":24,"createdTime":"2020-08-25 07:08:23","host":"us-006*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7,aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"326.4 KB","destSize":"27.8 KB","compressRate":"8.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdSk","sourceStatusCode":200,"destWidth":800,"destHeight":430,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn34@2020_5/2020/08/24/23-08-25-088_b71f870050272f58.webp","sourceBytes":4675788,"destBytes":1007754,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":7221,"convertSpendMs":2273,"createdTime":"2020-08-25 07:08:20","host":"europe-23*","referer":"https://segmentfault.com/a/1190000023608841","linkMd5ListStr":"06182f917f57c9d9612487bd563c6868,06182f917f57c9d9612487bd563c6868","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"4.5 MB","destSize":"984.1 KB","compressRate":"21.6%"},{"code":1,"isDone":false,"source":"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97ntsacj30e00ak3yx.jpg","sourceStatusCode":200,"destWidth":504,"destHeight":380,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn77@2020_2/2020/08/24/23-08-28-534_9ec7e1fd07438993.webp","sourceBytes":22894,"destBytes":11026,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":1913,"convertSpendMs":25,"createdTime":"2020-08-25 07:08:27","host":"us-014*","referer":"https://segmentfault.com/a/1190000023668057","linkMd5ListStr":"dcb1ca1d6d9e74559b1305ed3b0d3469","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"22.4 KB","destSize":"10.8 KB","compressRate":"48.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023707767","sourceStatusCode":200,"destWidth":414,"destHeight":273,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn90@2020_5/2020/08/24/23-08-28-638_bfa3d2edabd96c89.webp","sourceBytes":7039,"destBytes":8664,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2084,"convertSpendMs":8,"createdTime":"2020-08-25 07:08:27","host":"us-52*","referer":"https://segmentfault.com/a/1190000023707760","linkMd5ListStr":"0efc7a62efcc894fd0f116660993cd89","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"6.9 KB","destSize":"8.5 KB","compressRate":"123.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023517952","sourceStatusCode":200,"destWidth":399,"destHeight":178,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn86@2020_1/2020/08/24/23-08-28-586_d34b134de0d771e7.webp","sourceBytes":8998,"destBytes":4264,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2179,"convertSpendMs":4,"createdTime":"2020-08-25 07:08:27","host":"europe64*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"8.8 KB","destSize":"4.2 KB","compressRate":"47.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023517944","sourceStatusCode":200,"destWidth":126,"destHeight":121,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn66@2020_6/2020/08/24/23-08-28-682_f7b01d199b4e2d10.webp","sourceBytes":4367,"destBytes":2688,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2042,"convertSpendMs":4,"createdTime":"2020-08-25 07:08:27","host":"us-006*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"4.3 KB","destSize":"2.6 KB","compressRate":"61.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023517950","sourceStatusCode":200,"destWidth":220,"destHeight":220,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn30@2020_3/2020/08/24/23-08-28-488_a496bc91ec0bd42e.webp","sourceBytes":10135,"destBytes":11060,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2196,"convertSpendMs":5,"createdTime":"2020-08-25 07:08:27","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"9.9 KB","destSize":"10.8 KB","compressRate":"109.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023707768","sourceStatusCode":200,"destWidth":800,"destHeight":200,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn45@2020_2/2020/08/24/23-08-28-692_d2d8d27bbfe59f0d.webp","sourceBytes":18791,"destBytes":8140,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2047,"convertSpendMs":9,"createdTime":"2020-08-25 07:08:27","host":"us-002*","referer":"https://segmentfault.com/a/1190000023707760","linkMd5ListStr":"0efc7a62efcc894fd0f116660993cd89","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.4 KB","destSize":"7.9 KB","compressRate":"43.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLqQQ","sourceStatusCode":200,"destWidth":260,"destHeight":260,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn42@2020_3/2020/08/24/23-08-28-490_cccdf6bf3e166584.webp","sourceBytes":33557,"destBytes":11100,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2228,"convertSpendMs":7,"createdTime":"2020-08-25 07:08:27","host":"europe68*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"32.8 KB","destSize":"10.8 KB","compressRate":"33.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLqT9","sourceStatusCode":200,"destWidth":440,"destHeight":411,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn58@2020_3/2020/08/24/23-08-28-734_c26934c85deabe10.webp","sourceBytes":64753,"destBytes":12336,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2131,"convertSpendMs":22,"createdTime":"2020-08-25 07:08:27","host":"us-010*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"63.2 KB","destSize":"12 KB","compressRate":"19.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023517953","sourceStatusCode":200,"destWidth":800,"destHeight":739,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn93@2020_4/2020/08/24/23-08-28-689_1ce65c690cf43f47.webp","sourceBytes":62742,"destBytes":34606,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2202,"convertSpendMs":26,"createdTime":"2020-08-25 07:08:27","host":"us-030*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"61.3 KB","destSize":"33.8 KB","compressRate":"55.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023517946","sourceStatusCode":200,"destWidth":286,"destHeight":191,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn81@2020_6/2020/08/24/23-08-28-792_8d547681cad5df9e.webp","sourceBytes":9026,"destBytes":5340,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2126,"convertSpendMs":5,"createdTime":"2020-08-25 07:08:27","host":"us-022*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"8.8 KB","destSize":"5.2 KB","compressRate":"59.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023707763","sourceStatusCode":200,"destWidth":800,"destHeight":239,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn2@2020_4/2020/08/24/23-08-28-672_28796882d7b84489.webp","sourceBytes":77187,"destBytes":26676,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2220,"convertSpendMs":11,"createdTime":"2020-08-25 07:08:27","host":"us-006*","referer":"https://segmentfault.com/a/1190000023707760","linkMd5ListStr":"0efc7a62efcc894fd0f116660993cd89","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"75.4 KB","destSize":"26.1 KB","compressRate":"34.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLbSq","sourceStatusCode":200,"destWidth":800,"destHeight":189,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn46@2020_2/2020/08/24/23-08-28-505_e4ee0051d3ebdd4a.webp","sourceBytes":59342,"destBytes":17262,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2298,"convertSpendMs":11,"createdTime":"2020-08-25 07:08:27","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023601065","linkMd5ListStr":"76c9c6e6cb88560c51a4d8dfd2fa525b","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"58 KB","destSize":"16.9 KB","compressRate":"29.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023602038","sourceStatusCode":200,"destWidth":800,"destHeight":341,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn49@2020_6/2020/08/24/23-08-28-724_8b97a00e92f7b9a5.webp","sourceBytes":32562,"destBytes":32562,"feedId":6615,"totalSpendMs":2155,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:27","host":"us-034*","referer":"https://segmentfault.com/a/1190000023602033","linkMd5ListStr":"a52d5aa652910e157d09aa5f6fb7920b","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"31.8 KB","destSize":"31.8 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLuVG","sourceStatusCode":200,"destWidth":128,"destHeight":128,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn18@2020_2/2020/08/24/23-08-28-788_0f370e0b14289a17.webp","sourceBytes":11916,"destBytes":3814,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2166,"convertSpendMs":5,"createdTime":"2020-08-25 07:08:27","host":"us-022*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"11.6 KB","destSize":"3.7 KB","compressRate":"32%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023707765","sourceStatusCode":200,"destWidth":800,"destHeight":187,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn81@2020_4/2020/08/24/23-08-28-749_fbb1b3d44d3ddb63.webp","sourceBytes":45396,"destBytes":17016,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2178,"convertSpendMs":8,"createdTime":"2020-08-25 07:08:27","host":"us-002*","referer":"https://segmentfault.com/a/1190000023707760","linkMd5ListStr":"0efc7a62efcc894fd0f116660993cd89","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"44.3 KB","destSize":"16.6 KB","compressRate":"37.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663462","sourceStatusCode":200,"destWidth":800,"destHeight":209,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn10@2020_2/2020/08/24/23-08-28-508_51ef71423df3d477.webp","sourceBytes":100413,"destBytes":16422,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2325,"convertSpendMs":9,"createdTime":"2020-08-25 07:08:27","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"98.1 KB","destSize":"16 KB","compressRate":"16.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663458","sourceStatusCode":200,"destWidth":800,"destHeight":122,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn65@2020_6/2020/08/24/23-08-28-473_cec3b758d21a710e.webp","sourceBytes":19158,"destBytes":4652,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2351,"convertSpendMs":7,"createdTime":"2020-08-25 07:08:27","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.7 KB","destSize":"4.5 KB","compressRate":"24.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023517945","sourceStatusCode":200,"destWidth":322,"destHeight":398,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn77@2020_2/2020/08/24/23-08-28-801_26cd4b8b48fcfbad.webp","sourceBytes":53388,"destBytes":35208,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2219,"convertSpendMs":15,"createdTime":"2020-08-25 07:08:27","host":"us-034*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"52.1 KB","destSize":"34.4 KB","compressRate":"65.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023517949","sourceStatusCode":200,"destWidth":570,"destHeight":286,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn74@2020_1/2020/08/24/23-08-28-748_386e2ac4d66c0eef.webp","sourceBytes":31443,"destBytes":16836,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2224,"convertSpendMs":24,"createdTime":"2020-08-25 07:08:27","host":"us-026*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"30.7 KB","destSize":"16.4 KB","compressRate":"53.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023707766","sourceStatusCode":200,"destWidth":800,"destHeight":189,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn98@2020_5/2020/08/24/23-08-28-778_597d7f470508ef42.webp","sourceBytes":57451,"destBytes":19844,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2312,"convertSpendMs":9,"createdTime":"2020-08-25 07:08:27","host":"us-018*","referer":"https://segmentfault.com/a/1190000023707760","linkMd5ListStr":"0efc7a62efcc894fd0f116660993cd89","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"56.1 KB","destSize":"19.4 KB","compressRate":"34.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663467","sourceStatusCode":200,"destWidth":800,"destHeight":341,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn26@2020_3/2020/08/24/23-08-28-656_c96df5d663364d77.webp","sourceBytes":5715,"destBytes":1542,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2381,"convertSpendMs":10,"createdTime":"2020-08-25 07:08:27","host":"europe-23*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"5.6 KB","destSize":"1.5 KB","compressRate":"27%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663463","sourceStatusCode":200,"destWidth":800,"destHeight":493,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn6@2020_2/2020/08/24/23-08-28-516_a78bd2cd84532ab6.webp","sourceBytes":103745,"destBytes":14470,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2396,"convertSpendMs":18,"createdTime":"2020-08-25 07:08:27","host":"europe68*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"101.3 KB","destSize":"14.1 KB","compressRate":"13.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023685021","sourceStatusCode":200,"destWidth":586,"destHeight":196,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn86@2020_1/2020/08/24/23-08-28-842_9dd4a1623c27860b.webp","sourceBytes":63589,"destBytes":11006,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2247,"convertSpendMs":96,"createdTime":"2020-08-25 07:08:27","host":"us-010*","referer":"https://segmentfault.com/a/1190000023685018","linkMd5ListStr":"c6ea63b543bcf14780252f9af45af4e0","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"62.1 KB","destSize":"10.7 KB","compressRate":"17.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023517948","sourceStatusCode":200,"destWidth":137,"destHeight":136,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn74@2020_1/2020/08/24/23-08-28-514_112237e2027b570b.webp","sourceBytes":5686,"destBytes":3628,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2400,"convertSpendMs":3,"createdTime":"2020-08-25 07:08:27","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"5.6 KB","destSize":"3.5 KB","compressRate":"63.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023602037","sourceStatusCode":200,"destWidth":800,"destHeight":417,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn54@2020_3/2020/08/24/23-08-28-794_86f6da9014919043.webp","sourceBytes":28296,"destBytes":28296,"feedId":6615,"totalSpendMs":2296,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:27","host":"us-022*","referer":"https://segmentfault.com/a/1190000023602033","linkMd5ListStr":"a52d5aa652910e157d09aa5f6fb7920b","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"27.6 KB","destSize":"27.6 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663459","sourceStatusCode":200,"destWidth":800,"destHeight":445,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn62@2020_5/2020/08/24/23-08-28-683_06ae40cf5655a06c.webp","sourceBytes":84398,"destBytes":12306,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2461,"convertSpendMs":15,"createdTime":"2020-08-25 07:08:27","host":"europe-23*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"82.4 KB","destSize":"12 KB","compressRate":"14.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023517951","sourceStatusCode":200,"destWidth":214,"destHeight":250,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn42@2020_6/2020/08/24/23-08-28-736_f4da94180b1b7f17.webp","sourceBytes":11102,"destBytes":7952,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2314,"convertSpendMs":10,"createdTime":"2020-08-25 07:08:27","host":"us-014*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"10.8 KB","destSize":"7.8 KB","compressRate":"71.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663461","sourceStatusCode":200,"destWidth":782,"destHeight":374,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn14@2020_5/2020/08/24/23-08-28-862_28c5749083b296c8.webp","sourceBytes":72680,"destBytes":12298,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2309,"convertSpendMs":19,"createdTime":"2020-08-25 07:08:27","host":"us-034*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"71 KB","destSize":"12 KB","compressRate":"16.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663464","sourceStatusCode":200,"destWidth":800,"destHeight":324,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn54@2020_6/2020/08/24/23-08-28-853_f70d6764a3ae6436.webp","sourceBytes":103720,"destBytes":15582,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2309,"convertSpendMs":25,"createdTime":"2020-08-25 07:08:27","host":"us-52*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"101.3 KB","destSize":"15.2 KB","compressRate":"15%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023707769","sourceStatusCode":200,"destWidth":600,"destHeight":320,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn33@2020_5/2020/08/24/23-08-28-835_72ecbead9d15c7c3.webp","sourceBytes":31286,"destBytes":31286,"feedId":6615,"totalSpendMs":2331,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:27","host":"us-038*","referer":"https://segmentfault.com/a/1190000023707760","linkMd5ListStr":"0efc7a62efcc894fd0f116660993cd89","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"30.6 KB","destSize":"30.6 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023517947","sourceStatusCode":200,"destWidth":302,"destHeight":203,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn70@2020_2/2020/08/24/23-08-28-578_118080821669f072.webp","sourceBytes":24086,"destBytes":15360,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2486,"convertSpendMs":7,"createdTime":"2020-08-25 07:08:27","host":"europe68*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23.5 KB","destSize":"15 KB","compressRate":"63.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023517943","sourceStatusCode":200,"destWidth":323,"destHeight":700,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn61@2020_6/2020/08/24/23-08-28-873_ce700e4c9aab44af.webp","sourceBytes":67208,"destBytes":67208,"feedId":6615,"totalSpendMs":2371,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:27","host":"us-018*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"65.6 KB","destSize":"65.6 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663460","sourceStatusCode":200,"destWidth":800,"destHeight":577,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn21@2020_2/2020/08/24/23-08-28-891_e2bd700b6524c208.webp","sourceBytes":193645,"destBytes":27538,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2384,"convertSpendMs":40,"createdTime":"2020-08-25 07:08:27","host":"us-010*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"189.1 KB","destSize":"26.9 KB","compressRate":"14.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663465","sourceStatusCode":200,"destWidth":800,"destHeight":502,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn50@2020_4/2020/08/24/23-08-28-553_0db805f790b2fe3b.webp","sourceBytes":477299,"destBytes":69028,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2575,"convertSpendMs":27,"createdTime":"2020-08-25 07:08:27","host":"europe64*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"466.1 KB","destSize":"67.4 KB","compressRate":"14.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663457","sourceStatusCode":200,"destWidth":800,"destHeight":453,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn69@2020_6/2020/08/24/23-08-29-241_e461d9020d0ef79a.webp","sourceBytes":121806,"destBytes":19024,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2383,"convertSpendMs":21,"createdTime":"2020-08-25 07:08:27","host":"us-038*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"119 KB","destSize":"18.6 KB","compressRate":"15.6%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/9.png","sourceStatusCode":200,"destWidth":801,"destHeight":623,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn82@2020_6/2020/08/24/23-08-29-965_b89ab3d0fde9ac24.webp","sourceBytes":36232,"destBytes":36232,"feedId":6615,"totalSpendMs":1109,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:29","host":"us-52*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"35.4 KB","destSize":"35.4 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu983qeo1j30vj0kkjsj.jpg","sourceStatusCode":200,"destWidth":1135,"destHeight":740,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn45@2020_3/2020/08/24/23-08-30-738_7fa453e24c96970a.webp","sourceBytes":82088,"destBytes":33760,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":1919,"convertSpendMs":24,"createdTime":"2020-08-25 07:08:29","host":"us-022*","referer":"https://segmentfault.com/a/1190000023668057","linkMd5ListStr":"dcb1ca1d6d9e74559b1305ed3b0d3469","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"80.2 KB","destSize":"33 KB","compressRate":"41.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023685024","sourceStatusCode":200,"destWidth":392,"destHeight":204,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn93@2020_6/2020/08/24/23-08-30-679_209c5d3f7df6d78a.webp","sourceBytes":61317,"destBytes":9948,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2218,"convertSpendMs":7,"createdTime":"2020-08-25 07:08:29","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023685018","linkMd5ListStr":"c6ea63b543bcf14780252f9af45af4e0","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"59.9 KB","destSize":"9.7 KB","compressRate":"16.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676551","sourceStatusCode":200,"destWidth":607,"destHeight":261,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn14@2020_5/2020/08/24/23-08-30-685_b578e1f4a1bcc92e.webp","sourceBytes":31360,"destBytes":12686,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2169,"convertSpendMs":8,"createdTime":"2020-08-25 07:08:29","host":"europe64*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"30.6 KB","destSize":"12.4 KB","compressRate":"40.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676554","sourceStatusCode":200,"destWidth":600,"destHeight":331,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn30@2020_5/2020/08/24/23-08-30-953_c58330355fbc3305.webp","sourceBytes":42592,"destBytes":11056,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2100,"convertSpendMs":10,"createdTime":"2020-08-25 07:08:29","host":"us-006*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"41.6 KB","destSize":"10.8 KB","compressRate":"26%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676557","sourceStatusCode":200,"destWidth":800,"destHeight":424,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn18@2020_6/2020/08/24/23-08-30-898_7f8fc8b01d6f5da7.webp","sourceBytes":30087,"destBytes":23132,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2124,"convertSpendMs":33,"createdTime":"2020-08-25 07:08:29","host":"us-52*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"29.4 KB","destSize":"22.6 KB","compressRate":"76.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023685023","sourceStatusCode":200,"destWidth":549,"destHeight":221,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn89@2020_6/2020/08/24/23-08-30-573_1334f2d2165df788.webp","sourceBytes":81450,"destBytes":13232,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2437,"convertSpendMs":9,"createdTime":"2020-08-25 07:08:29","host":"europe-23*","referer":"https://segmentfault.com/a/1190000023685018","linkMd5ListStr":"c6ea63b543bcf14780252f9af45af4e0","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"79.5 KB","destSize":"12.9 KB","compressRate":"16.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676553","sourceStatusCode":200,"destWidth":800,"destHeight":402,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn6@2020_5/2020/08/24/23-08-30-950_7610edbe97df9755.webp","sourceBytes":60643,"destBytes":15568,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2257,"convertSpendMs":32,"createdTime":"2020-08-25 07:08:29","host":"us-014*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"59.2 KB","destSize":"15.2 KB","compressRate":"25.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676556","sourceStatusCode":200,"destWidth":800,"destHeight":171,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn22@2020_1/2020/08/24/23-08-30-886_927b33d1efd81a57.webp","sourceBytes":29836,"destBytes":7438,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2206,"convertSpendMs":8,"createdTime":"2020-08-25 07:08:29","host":"us-030*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"29.1 KB","destSize":"7.3 KB","compressRate":"24.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdSN","sourceStatusCode":200,"destWidth":800,"destHeight":429,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn73@2020_6/2020/08/24/23-08-30-993_8783d0846c619bb6.webp","sourceBytes":7960,"destBytes":7960,"feedId":6615,"totalSpendMs":2093,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:29","host":"us-002*","referer":"https://segmentfault.com/a/1190000023608841","linkMd5ListStr":"06182f917f57c9d9612487bd563c6868","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"7.8 KB","destSize":"7.8 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663468","sourceStatusCode":200,"destWidth":800,"destHeight":343,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn33@2020_5/2020/08/24/23-08-30-799_c54b3b3ab9067f97.webp","sourceBytes":93558,"destBytes":13546,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2301,"convertSpendMs":19,"createdTime":"2020-08-25 07:08:29","host":"europe68*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"91.4 KB","destSize":"13.2 KB","compressRate":"14.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676552","sourceStatusCode":200,"destWidth":800,"destHeight":323,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn10@2020_2/2020/08/24/23-08-30-890_4c734adeed2c35c9.webp","sourceBytes":53162,"destBytes":41816,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2342,"convertSpendMs":14,"createdTime":"2020-08-25 07:08:29","host":"us-002*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"51.9 KB","destSize":"40.8 KB","compressRate":"78.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023650525","sourceStatusCode":200,"destWidth":800,"destHeight":362,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn57@2020_2/2020/08/24/23-08-30-874_b28db8e72475b886.webp","sourceBytes":63873,"destBytes":24086,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2277,"convertSpendMs":19,"createdTime":"2020-08-25 07:08:29","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023650518","linkMd5ListStr":"569e2336cd79bc25ac4f434bfa5337fb","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"62.4 KB","destSize":"23.5 KB","compressRate":"37.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023650528","sourceStatusCode":200,"destWidth":626,"destHeight":484,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn78@2020_4/2020/08/24/23-08-30-890_0a757f6a41f5f311.webp","sourceBytes":47366,"destBytes":19230,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2246,"convertSpendMs":11,"createdTime":"2020-08-25 07:08:29","host":"europe64*","referer":"https://segmentfault.com/a/1190000023650518","linkMd5ListStr":"569e2336cd79bc25ac4f434bfa5337fb","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"46.3 KB","destSize":"18.8 KB","compressRate":"40.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdSL","sourceStatusCode":200,"destWidth":800,"destHeight":444,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn62@2020_4/2020/08/24/23-08-31-078_6038012b8d24d65d.webp","sourceBytes":28266,"destBytes":28266,"feedId":6615,"totalSpendMs":2132,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:29","host":"us-038*","referer":"https://segmentfault.com/a/1190000023608841","linkMd5ListStr":"06182f917f57c9d9612487bd563c6868","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"27.6 KB","destSize":"27.6 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu973myg2j3073073q3c.jpg","sourceStatusCode":200,"destWidth":255,"destHeight":255,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn38@2020_2/2020/08/24/23-08-31-068_4b19e03c9a05d1ad.webp","sourceBytes":12990,"destBytes":8998,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2368,"convertSpendMs":5,"createdTime":"2020-08-25 07:08:29","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023668057","linkMd5ListStr":"dcb1ca1d6d9e74559b1305ed3b0d3469","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12.7 KB","destSize":"8.8 KB","compressRate":"69.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdLG","sourceStatusCode":200,"destWidth":400,"destHeight":254,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn18@2020_2/2020/08/24/23-08-31-035_63b0ce2dc1f9a19f.webp","sourceBytes":45480,"destBytes":9076,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2175,"convertSpendMs":8,"createdTime":"2020-08-25 07:08:29","host":"europe-23*","referer":"https://segmentfault.com/a/1190000023608432","linkMd5ListStr":"749b88d16e8263f6e6691f06881f8209","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"44.4 KB","destSize":"8.9 KB","compressRate":"20%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676555","sourceStatusCode":200,"destWidth":800,"destHeight":466,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn26@2020_5/2020/08/24/23-08-31-078_44b46b0331cb728c.webp","sourceBytes":27752,"destBytes":6404,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2302,"convertSpendMs":13,"createdTime":"2020-08-25 07:08:29","host":"us-018*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"27.1 KB","destSize":"6.3 KB","compressRate":"23.1%"},{"code":1,"isDone":false,"source":"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu975kcouj30ny0c074q.jpg","sourceStatusCode":200,"destWidth":862,"destHeight":432,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn54@2020_5/2020/08/24/23-08-30-913_c03142b1c5b40ef9.webp","sourceBytes":37118,"destBytes":16870,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2387,"convertSpendMs":12,"createdTime":"2020-08-25 07:08:29","host":"europe-23*","referer":"https://segmentfault.com/a/1190000023668057","linkMd5ListStr":"dcb1ca1d6d9e74559b1305ed3b0d3469","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"36.2 KB","destSize":"16.5 KB","compressRate":"45.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023650529","sourceStatusCode":200,"destWidth":800,"destHeight":368,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn98@2020_2/2020/08/24/23-08-30-948_d37fcf9ccf470a5a.webp","sourceBytes":72924,"destBytes":28666,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2273,"convertSpendMs":16,"createdTime":"2020-08-25 07:08:29","host":"europe68*","referer":"https://segmentfault.com/a/1190000023650518","linkMd5ListStr":"569e2336cd79bc25ac4f434bfa5337fb","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"71.2 KB","destSize":"28 KB","compressRate":"39.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023696740","sourceStatusCode":200,"destWidth":800,"destHeight":355,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn50@2020_4/2020/08/24/23-08-31-193_c69cd228aa5900d5.webp","sourceBytes":147292,"destBytes":25430,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2357,"convertSpendMs":142,"createdTime":"2020-08-25 07:08:29","host":"us-010*","referer":"https://segmentfault.com/a/1190000023696737","linkMd5ListStr":"6077149de366230a75fc5ccb09f8bad7","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"143.8 KB","destSize":"24.8 KB","compressRate":"17.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023650521","sourceStatusCode":200,"destWidth":800,"destHeight":300,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn86@2020_6/2020/08/24/23-08-31-209_90d83c08e9ab7de3.webp","sourceBytes":40458,"destBytes":20392,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2155,"convertSpendMs":11,"createdTime":"2020-08-25 07:08:29","host":"us-030*","referer":"https://segmentfault.com/a/1190000023650518","linkMd5ListStr":"569e2336cd79bc25ac4f434bfa5337fb","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"39.5 KB","destSize":"19.9 KB","compressRate":"50.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023465591","sourceStatusCode":200,"destWidth":800,"destHeight":558,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn42@2020_4/2020/08/24/23-08-31-138_5d24db7b7f08f9c8.webp","sourceBytes":138902,"destBytes":58510,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2384,"convertSpendMs":23,"createdTime":"2020-08-25 07:08:29","host":"us-034*","referer":"https://segmentfault.com/a/1190000023657729","linkMd5ListStr":"9569faa8acc0e079a1c10828ff9a417e","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"135.6 KB","destSize":"57.1 KB","compressRate":"42.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023650527","sourceStatusCode":200,"destWidth":800,"destHeight":260,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn70@2020_2/2020/08/24/23-08-31-206_51bb2ad6d7647e06.webp","sourceBytes":33118,"destBytes":15932,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2230,"convertSpendMs":43,"createdTime":"2020-08-25 07:08:29","host":"us-014*","referer":"https://segmentfault.com/a/1190000023650518","linkMd5ListStr":"569e2336cd79bc25ac4f434bfa5337fb","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"32.3 KB","destSize":"15.6 KB","compressRate":"48.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023650524","sourceStatusCode":200,"destWidth":800,"destHeight":331,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn93@2020_1/2020/08/24/23-08-31-248_82a398d90f8d4d67.webp","sourceBytes":47397,"destBytes":18976,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2178,"convertSpendMs":12,"createdTime":"2020-08-25 07:08:29","host":"us-006*","referer":"https://segmentfault.com/a/1190000023650518","linkMd5ListStr":"569e2336cd79bc25ac4f434bfa5337fb","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"46.3 KB","destSize":"18.5 KB","compressRate":"40%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663454","sourceStatusCode":200,"destWidth":800,"destHeight":391,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn1@2020_2/2020/08/24/23-08-31-134_9fa46c777ab520a1.webp","sourceBytes":153478,"destBytes":25050,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2497,"convertSpendMs":55,"createdTime":"2020-08-25 07:08:29","host":"us-026*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"149.9 KB","destSize":"24.5 KB","compressRate":"16.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023650523","sourceStatusCode":200,"destWidth":800,"destHeight":349,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn89@2020_5/2020/08/24/23-08-31-279_e99c09a9a60e22c5.webp","sourceBytes":33615,"destBytes":16312,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2247,"convertSpendMs":11,"createdTime":"2020-08-25 07:08:29","host":"us-018*","referer":"https://segmentfault.com/a/1190000023650518","linkMd5ListStr":"569e2336cd79bc25ac4f434bfa5337fb","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"32.8 KB","destSize":"15.9 KB","compressRate":"48.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbKY8G","sourceStatusCode":200,"destWidth":800,"destHeight":609,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn1@2020_1/2020/08/24/23-08-31-021_13b83779e9282377.webp","sourceBytes":202175,"destBytes":34456,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2396,"convertSpendMs":26,"createdTime":"2020-08-25 07:08:29","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023552474","linkMd5ListStr":"518d797df1c7c9d30e2acaaec433d26b","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"197.4 KB","destSize":"33.6 KB","compressRate":"17%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdL2","sourceStatusCode":200,"destWidth":800,"destHeight":391,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn13@2020_3/2020/08/24/23-08-31-249_cae8c8909f921d73.webp","sourceBytes":17678,"destBytes":17678,"feedId":6615,"totalSpendMs":2196,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:29","host":"us-010*","referer":"https://segmentfault.com/a/1190000023608432","linkMd5ListStr":"749b88d16e8263f6e6691f06881f8209","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"17.3 KB","destSize":"17.3 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdLF","sourceStatusCode":200,"destWidth":640,"destHeight":451,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn22@2020_1/2020/08/24/23-08-31-096_8bc295045278e761.webp","sourceBytes":274886,"destBytes":37010,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2335,"convertSpendMs":23,"createdTime":"2020-08-25 07:08:29","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023608432","linkMd5ListStr":"749b88d16e8263f6e6691f06881f8209","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"268.4 KB","destSize":"36.1 KB","compressRate":"13.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdLI","sourceStatusCode":200,"destWidth":602,"destHeight":301,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn26@2020_2/2020/08/24/23-08-31-464_32e3bd917b7c4cb4.webp","sourceBytes":7240,"destBytes":7240,"feedId":6615,"totalSpendMs":2044,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:30","host":"us-038*","referer":"https://segmentfault.com/a/1190000023608432","linkMd5ListStr":"749b88d16e8263f6e6691f06881f8209","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"7.1 KB","destSize":"7.1 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbKY8I","sourceStatusCode":200,"destWidth":800,"destHeight":632,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn10@2020_5/2020/08/24/23-08-31-367_4e367cfe16dd2bc7.webp","sourceBytes":130383,"destBytes":22982,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2363,"convertSpendMs":27,"createdTime":"2020-08-25 07:08:29","host":"us-022*","referer":"https://segmentfault.com/a/1190000023552474","linkMd5ListStr":"518d797df1c7c9d30e2acaaec433d26b","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"127.3 KB","destSize":"22.4 KB","compressRate":"17.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbKY8H","sourceStatusCode":200,"destWidth":800,"destHeight":669,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn6@2020_2/2020/08/24/23-08-31-343_f69c4c9c378440c7.webp","sourceBytes":250991,"destBytes":49972,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2481,"convertSpendMs":34,"createdTime":"2020-08-25 07:08:29","host":"us-034*","referer":"https://segmentfault.com/a/1190000023552474","linkMd5ListStr":"518d797df1c7c9d30e2acaaec433d26b","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"245.1 KB","destSize":"48.8 KB","compressRate":"19.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023650526","sourceStatusCode":200,"destWidth":800,"destHeight":585,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn66@2020_4/2020/08/24/23-08-31-671_9a1dabc2dfac2a2e.webp","sourceBytes":98601,"destBytes":44296,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2878,"convertSpendMs":42,"createdTime":"2020-08-25 07:08:29","host":"us-026*","referer":"https://segmentfault.com/a/1190000023650518","linkMd5ListStr":"569e2336cd79bc25ac4f434bfa5337fb","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"96.3 KB","destSize":"43.3 KB","compressRate":"44.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663456","sourceStatusCode":200,"destWidth":800,"destHeight":155,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn98@2020_2/2020/08/24/23-08-32-493_66d56292ccba60f9.webp","sourceBytes":43365,"destBytes":7268,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3681,"convertSpendMs":13,"createdTime":"2020-08-25 07:08:29","host":"us-038*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"42.3 KB","destSize":"7.1 KB","compressRate":"16.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLqNT","sourceStatusCode":200,"destWidth":240,"destHeight":240,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn58@2020_5/2020/08/24/23-08-32-542_96997f4a7107446a.webp","sourceBytes":74255,"destBytes":13622,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2147,"convertSpendMs":9,"createdTime":"2020-08-25 07:08:31","host":"us-030*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"72.5 KB","destSize":"13.3 KB","compressRate":"18.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdLH","sourceStatusCode":200,"destWidth":641,"destHeight":356,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn30@2020_3/2020/08/24/23-08-32-395_1f1e125dfeab6f55.webp","sourceBytes":20688,"destBytes":20688,"feedId":6615,"totalSpendMs":2288,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:31","host":"us-026*","referer":"https://segmentfault.com/a/1190000023608432","linkMd5ListStr":"749b88d16e8263f6e6691f06881f8209","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"20.2 KB","destSize":"20.2 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663466","sourceStatusCode":200,"destWidth":800,"destHeight":514,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn38@2020_2/2020/08/24/23-08-32-798_eb0a0c56eee8bbb0.webp","sourceBytes":479398,"destBytes":70208,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2493,"convertSpendMs":61,"createdTime":"2020-08-25 07:08:31","host":"us-026*","referer":"https://segmentfault.com/a/1190000023663451","linkMd5ListStr":"aa2132e98ae80a419b6636569f23b0d7","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"468.2 KB","destSize":"68.6 KB","compressRate":"14.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdLW","sourceStatusCode":200,"destWidth":800,"destHeight":279,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn42@2020_2/2020/08/24/23-08-32-865_bc2956f96c8c82ca.webp","sourceBytes":41062,"destBytes":4498,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2056,"convertSpendMs":12,"createdTime":"2020-08-25 07:08:31","host":"europe64*","referer":"https://segmentfault.com/a/1190000023608432","linkMd5ListStr":"749b88d16e8263f6e6691f06881f8209","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"40.1 KB","destSize":"4.4 KB","compressRate":"11%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdLJ","sourceStatusCode":200,"destWidth":769,"destHeight":541,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn38@2020_1/2020/08/24/23-08-33-099_547588ad0b88b0f6.webp","sourceBytes":20354,"destBytes":20354,"feedId":6615,"totalSpendMs":2110,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:31","host":"us-002*","referer":"https://segmentfault.com/a/1190000023608432","linkMd5ListStr":"749b88d16e8263f6e6691f06881f8209","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"19.9 KB","destSize":"19.9 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709794","sourceStatusCode":200,"destWidth":505,"destHeight":93,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn57@2020_2/2020/08/24/23-08-33-158_ea591013ed81ca92.webp","sourceBytes":5380,"destBytes":4220,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2091,"convertSpendMs":4,"createdTime":"2020-08-25 07:08:31","host":"us-006*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"5.3 KB","destSize":"4.1 KB","compressRate":"78.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709791","sourceStatusCode":200,"destWidth":723,"destHeight":390,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn62@2020_2/2020/08/24/23-08-33-065_aca834d1f78506e1.webp","sourceBytes":11065,"destBytes":13956,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2263,"convertSpendMs":10,"createdTime":"2020-08-25 07:08:31","host":"europe68*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"10.8 KB","destSize":"13.6 KB","compressRate":"126.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709798","sourceStatusCode":200,"destWidth":491,"destHeight":352,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn85@2020_2/2020/08/24/23-08-33-136_31a2ac49b076af15.webp","sourceBytes":23536,"destBytes":11680,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2170,"convertSpendMs":10,"createdTime":"2020-08-25 07:08:31","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23 KB","destSize":"11.4 KB","compressRate":"49.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709795","sourceStatusCode":200,"destWidth":746,"destHeight":60,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn90@2020_4/2020/08/24/23-08-33-301_d3cdfa771a80fd89.webp","sourceBytes":2598,"destBytes":1810,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2135,"convertSpendMs":6,"createdTime":"2020-08-25 07:08:31","host":"us-038*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"2.5 KB","destSize":"1.8 KB","compressRate":"69.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709793","sourceStatusCode":200,"destWidth":701,"destHeight":372,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn54@2020_1/2020/08/24/23-08-33-326_296fe34c1d67332e.webp","sourceBytes":9988,"destBytes":13040,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2228,"convertSpendMs":10,"createdTime":"2020-08-25 07:08:31","host":"us-018*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"9.8 KB","destSize":"12.7 KB","compressRate":"130.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709790","sourceStatusCode":200,"destWidth":723,"destHeight":397,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn66@2020_1/2020/08/24/23-08-33-212_466a91e430815709.webp","sourceBytes":8035,"destBytes":8858,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2346,"convertSpendMs":8,"createdTime":"2020-08-25 07:08:31","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"7.8 KB","destSize":"8.7 KB","compressRate":"110.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdLP","sourceStatusCode":200,"destWidth":800,"destHeight":411,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn50@2020_6/2020/08/24/23-08-33-234_a531250d12d5cd21.webp","sourceBytes":56736,"destBytes":56736,"feedId":6615,"totalSpendMs":2314,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:31","host":"us-030*","referer":"https://segmentfault.com/a/1190000023608432","linkMd5ListStr":"749b88d16e8263f6e6691f06881f8209","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"55.4 KB","destSize":"55.4 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023735010","sourceStatusCode":200,"destWidth":800,"destHeight":318,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn30@2020_2/2020/08/24/23-08-33-394_30a2866aebb9679b.webp","sourceBytes":39207,"destBytes":6632,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2120,"convertSpendMs":12,"createdTime":"2020-08-25 07:08:32","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023735006","linkMd5ListStr":"83e2007305092901a28598ddbadd1356","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"38.3 KB","destSize":"6.5 KB","compressRate":"16.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023737675","sourceStatusCode":200,"destWidth":748,"destHeight":606,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn6@2020_5/2020/08/24/23-08-33-208_54794e46f067943b.webp","sourceBytes":26493,"destBytes":12966,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2233,"convertSpendMs":13,"createdTime":"2020-08-25 07:08:32","host":"europe64*","referer":"https://segmentfault.com/a/1190000023737670","linkMd5ListStr":"f6d9b255d764f38d4cfc647c5d61450c","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.9 KB","destSize":"12.7 KB","compressRate":"48.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLk9V","sourceStatusCode":200,"destWidth":800,"destHeight":304,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn45@2020_5/2020/08/24/23-08-33-349_7f210afa164eab9c.webp","sourceBytes":41294,"destBytes":19346,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2455,"convertSpendMs":14,"createdTime":"2020-08-25 07:08:31","host":"us-52*","referer":"https://segmentfault.com/a/1190000023636701","linkMd5ListStr":"3f522baba1e817cf81ff90c5e1d10cfb","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"40.3 KB","destSize":"18.9 KB","compressRate":"46.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023735011","sourceStatusCode":200,"destWidth":800,"destHeight":602,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn25@2020_3/2020/08/24/23-08-33-283_8449a79cab74d294.webp","sourceBytes":55756,"destBytes":18434,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2263,"convertSpendMs":23,"createdTime":"2020-08-25 07:08:32","host":"europe68*","referer":"https://segmentfault.com/a/1190000023735006","linkMd5ListStr":"83e2007305092901a28598ddbadd1356","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"54.4 KB","destSize":"18 KB","compressRate":"33.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023737673","sourceStatusCode":200,"destWidth":716,"destHeight":290,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn1@2020_1/2020/08/24/23-08-33-510_28a02d81591a6ac2.webp","sourceBytes":43328,"destBytes":22146,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2172,"convertSpendMs":11,"createdTime":"2020-08-25 07:08:32","host":"us-002*","referer":"https://segmentfault.com/a/1190000023737670","linkMd5ListStr":"f6d9b255d764f38d4cfc647c5d61450c","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"42.3 KB","destSize":"21.6 KB","compressRate":"51.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023737676","sourceStatusCode":200,"destWidth":468,"destHeight":614,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn9@2020_2/2020/08/24/23-08-33-492_e143eeeacb3d77c7.webp","sourceBytes":28880,"destBytes":13822,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2171,"convertSpendMs":29,"createdTime":"2020-08-25 07:08:32","host":"us-52*","referer":"https://segmentfault.com/a/1190000023737670","linkMd5ListStr":"f6d9b255d764f38d4cfc647c5d61450c","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"28.2 KB","destSize":"13.5 KB","compressRate":"47.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709799","sourceStatusCode":200,"destWidth":800,"destHeight":240,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn69@2020_3/2020/08/24/23-08-33-492_971c0824e4b34173.webp","sourceBytes":73470,"destBytes":14336,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2343,"convertSpendMs":32,"createdTime":"2020-08-25 07:08:32","host":"us-034*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"71.7 KB","destSize":"14 KB","compressRate":"19.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbKY8w","sourceStatusCode":200,"destWidth":800,"destHeight":451,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn78@2020_4/2020/08/24/23-08-33-533_03ba1729d180dc44.webp","sourceBytes":125198,"destBytes":24588,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2303,"convertSpendMs":46,"createdTime":"2020-08-25 07:08:32","host":"us-010*","referer":"https://segmentfault.com/a/1190000023552474","linkMd5ListStr":"518d797df1c7c9d30e2acaaec433d26b","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"122.3 KB","destSize":"24 KB","compressRate":"19.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709796","sourceStatusCode":200,"destWidth":800,"destHeight":293,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn94@2020_1/2020/08/24/23-08-33-609_05d4dc7dacd0d54d.webp","sourceBytes":50961,"destBytes":11990,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2226,"convertSpendMs":39,"createdTime":"2020-08-25 07:08:32","host":"us-026*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d,ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"49.8 KB","destSize":"11.7 KB","compressRate":"23.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023735013","sourceStatusCode":200,"destWidth":800,"destHeight":418,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn18@2020_2/2020/08/24/23-08-33-574_ca64795440519632.webp","sourceBytes":78098,"destBytes":17414,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2288,"convertSpendMs":18,"createdTime":"2020-08-25 07:08:32","host":"us-018*","referer":"https://segmentfault.com/a/1190000023735006","linkMd5ListStr":"83e2007305092901a28598ddbadd1356","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"76.3 KB","destSize":"17 KB","compressRate":"22.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbKY9n","sourceStatusCode":200,"destWidth":800,"destHeight":149,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn98@2020_1/2020/08/24/23-08-33-472_6992bf171c48ab6b.webp","sourceBytes":26989,"destBytes":15974,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2260,"convertSpendMs":12,"createdTime":"2020-08-25 07:08:32","host":"us-014*","referer":"https://segmentfault.com/a/1190000023552474","linkMd5ListStr":"518d797df1c7c9d30e2acaaec433d26b","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"26.4 KB","destSize":"15.6 KB","compressRate":"59.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023735012","sourceStatusCode":200,"destWidth":800,"destHeight":405,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn22@2020_6/2020/08/24/23-08-33-580_0ee43b08f5e73b73.webp","sourceBytes":99412,"destBytes":16622,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2196,"convertSpendMs":18,"createdTime":"2020-08-25 07:08:32","host":"us-006*","referer":"https://segmentfault.com/a/1190000023735006","linkMd5ListStr":"83e2007305092901a28598ddbadd1356","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"97.1 KB","destSize":"16.2 KB","compressRate":"16.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023601931","sourceStatusCode":200,"destWidth":800,"destHeight":437,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn50@2020_6/2020/08/24/23-08-33-441_5bc3d20e66a31ee9.webp","sourceBytes":52064,"destBytes":23844,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2207,"convertSpendMs":14,"createdTime":"2020-08-25 07:08:32","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023601927","linkMd5ListStr":"caee1d7512ed006f50fb714e278bb4f4","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"50.8 KB","destSize":"23.3 KB","compressRate":"45.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709797","sourceStatusCode":200,"destWidth":327,"destHeight":410,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn74@2020_4/2020/08/24/23-08-33-616_c5d493b3e367e934.webp","sourceBytes":133053,"destBytes":19064,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2404,"convertSpendMs":17,"createdTime":"2020-08-25 07:08:32","host":"us-022*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"129.9 KB","destSize":"18.6 KB","compressRate":"14.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023735014","sourceStatusCode":200,"destWidth":800,"destHeight":450,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn13@2020_6/2020/08/24/23-08-33-616_a24995aea600c1a0.webp","sourceBytes":236692,"destBytes":21324,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2367,"convertSpendMs":35,"createdTime":"2020-08-25 07:08:32","host":"us-030*","referer":"https://segmentfault.com/a/1190000023735006","linkMd5ListStr":"83e2007305092901a28598ddbadd1356","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"231.1 KB","destSize":"20.8 KB","compressRate":"9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLvGN","sourceStatusCode":200,"destWidth":500,"destHeight":500,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn38@2020_1/2020/08/24/23-08-33-674_5324ccda8059124e.webp","sourceBytes":34779,"destBytes":24180,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2212,"convertSpendMs":19,"createdTime":"2020-08-25 07:08:32","host":"us-022*","referer":"https://segmentfault.com/a/1190000023677258","linkMd5ListStr":"81351ef5cee65b004bca5b0902fb9913","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"34 KB","destSize":"23.6 KB","compressRate":"69.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdLK","sourceStatusCode":200,"destWidth":800,"destHeight":184,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn34@2020_1/2020/08/24/23-08-33-617_a294f8a47711264c.webp","sourceBytes":22568,"destBytes":22568,"feedId":6615,"totalSpendMs":2767,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:31","host":"us-014*","referer":"https://segmentfault.com/a/1190000023608432","linkMd5ListStr":"749b88d16e8263f6e6691f06881f8209","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"22 KB","destSize":"22 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023601932","sourceStatusCode":200,"destWidth":635,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn42@2020_3/2020/08/24/23-08-33-612_ecc0aceb5b22010d.webp","sourceBytes":38376,"destBytes":38376,"feedId":6615,"totalSpendMs":2278,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:32","host":"us-010*","referer":"https://segmentfault.com/a/1190000023601927","linkMd5ListStr":"caee1d7512ed006f50fb714e278bb4f4","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"37.5 KB","destSize":"37.5 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000022332831","sourceStatusCode":200,"destWidth":302,"destHeight":62,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn54@2020_6/2020/08/24/23-08-33-768_ab7bb1a669ed6d43.webp","sourceBytes":9354,"destBytes":2638,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2342,"convertSpendMs":8,"createdTime":"2020-08-25 07:08:32","host":"us-038*","referer":"https://segmentfault.com/a/1190000023648364","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f,47f945d0758f841a94d5a32def62ad1a","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"9.1 KB","destSize":"2.6 KB","compressRate":"28.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023601933","sourceStatusCode":200,"destWidth":800,"destHeight":465,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn46@2020_3/2020/08/24/23-08-33-567_4185d7618d0af188.webp","sourceBytes":42462,"destBytes":32742,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2543,"convertSpendMs":13,"createdTime":"2020-08-25 07:08:32","host":"europe-23*","referer":"https://segmentfault.com/a/1190000023601927","linkMd5ListStr":"caee1d7512ed006f50fb714e278bb4f4","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"41.5 KB","destSize":"32 KB","compressRate":"77.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLueg","sourceStatusCode":200,"destWidth":800,"destHeight":524,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn34@2020_1/2020/08/24/23-08-33-833_d914957c0890d0d6.webp","sourceBytes":626352,"destBytes":53970,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2553,"convertSpendMs":70,"createdTime":"2020-08-25 07:08:32","host":"us-034*","referer":"https://segmentfault.com/a/1190000023675512","linkMd5ListStr":"8130037c23e0c993c51e97490b17f7b6","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"611.7 KB","destSize":"52.7 KB","compressRate":"8.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLvGJ","sourceStatusCode":200,"destWidth":539,"destHeight":622,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn57@2020_4/2020/08/24/23-08-33-915_ec37b2d3704c5497.webp","sourceBytes":247415,"destBytes":18020,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2407,"convertSpendMs":99,"createdTime":"2020-08-25 07:08:32","host":"us-026*","referer":"https://segmentfault.com/a/1190000023677258","linkMd5ListStr":"81351ef5cee65b004bca5b0902fb9913","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"241.6 KB","destSize":"17.6 KB","compressRate":"7.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000022332833","sourceStatusCode":200,"destWidth":302,"destHeight":61,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn62@2020_5/2020/08/24/23-08-34-275_d188d26ff603bb94.webp","sourceBytes":10498,"destBytes":3190,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2295,"convertSpendMs":13,"createdTime":"2020-08-25 07:08:32","host":"us-014*","referer":"https://segmentfault.com/a/1190000023648364","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f,47f945d0758f841a94d5a32def62ad1a","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"10.3 KB","destSize":"3.1 KB","compressRate":"30.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK8rM","sourceStatusCode":200,"destWidth":240,"destHeight":240,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn76@2020_3/2020/08/24/23-08-34-896_2dc307b4541a0abd.webp","sourceBytes":21764,"destBytes":8394,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2170,"convertSpendMs":17,"createdTime":"2020-08-25 07:08:33","host":"us-014*","referer":"https://segmentfault.com/a/1190000023587881","linkMd5ListStr":"38260b3f6e6b52df89d4a67c52a99d4e","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"21.3 KB","destSize":"8.2 KB","compressRate":"38.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK8rQ","sourceStatusCode":200,"destWidth":800,"destHeight":246,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn15@2020_3/2020/08/24/23-08-35-676_125212a0c80ae003.webp","sourceBytes":55763,"destBytes":25802,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2243,"convertSpendMs":31,"createdTime":"2020-08-25 07:08:34","host":"us-030*","referer":"https://segmentfault.com/a/1190000023587881","linkMd5ListStr":"38260b3f6e6b52df89d4a67c52a99d4e","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"54.5 KB","destSize":"25.2 KB","compressRate":"46.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709805","sourceStatusCode":200,"destWidth":800,"destHeight":268,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn56@2020_6/2020/08/24/23-08-35-625_7a194b4bce014c56.webp","sourceBytes":40682,"destBytes":22130,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2240,"convertSpendMs":10,"createdTime":"2020-08-25 07:08:34","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"39.7 KB","destSize":"21.6 KB","compressRate":"54.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023736398","sourceStatusCode":200,"destWidth":800,"destHeight":468,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn36@2020_5/2020/08/24/23-08-35-897_b31ea577fa877f02.webp","sourceBytes":67925,"destBytes":14918,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2228,"convertSpendMs":24,"createdTime":"2020-08-25 07:08:34","host":"us-038*","referer":"https://segmentfault.com/a/1190000023736395","linkMd5ListStr":"0350953f3ed11c58067e084970f74395","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"66.3 KB","destSize":"14.6 KB","compressRate":"22%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023657735","sourceStatusCode":200,"destWidth":800,"destHeight":637,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn76@2020_4/2020/08/24/23-08-35-718_de19cb27823856b5.webp","sourceBytes":227786,"destBytes":46674,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2456,"convertSpendMs":29,"createdTime":"2020-08-25 07:08:34","host":"europe64*","referer":"https://segmentfault.com/a/1190000023657729","linkMd5ListStr":"9569faa8acc0e079a1c10828ff9a417e","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"222.4 KB","destSize":"45.6 KB","compressRate":"20.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023657736","sourceStatusCode":200,"destWidth":475,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn71@2020_1/2020/08/24/23-08-36-091_0b3e500f3a14db18.webp","sourceBytes":223566,"destBytes":38202,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2297,"convertSpendMs":19,"createdTime":"2020-08-25 07:08:34","host":"us-002*","referer":"https://segmentfault.com/a/1190000023657729","linkMd5ListStr":"9569faa8acc0e079a1c10828ff9a417e","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"218.3 KB","destSize":"37.3 KB","compressRate":"17.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK8rO","sourceStatusCode":200,"destWidth":800,"destHeight":760,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn83@2020_4/2020/08/24/23-08-35-793_31b62aedb2eb6fe6.webp","sourceBytes":214061,"destBytes":73040,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3315,"convertSpendMs":57,"createdTime":"2020-08-25 07:08:33","host":"europe65*","referer":"https://segmentfault.com/a/1190000023587881","linkMd5ListStr":"38260b3f6e6b52df89d4a67c52a99d4e","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"209 KB","destSize":"71.3 KB","compressRate":"34.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLvGR","sourceStatusCode":200,"destWidth":435,"destHeight":348,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn68@2020_3/2020/08/24/23-08-36-191_c3fec51f8080522e.webp","sourceBytes":10264,"destBytes":14060,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3581,"convertSpendMs":25,"createdTime":"2020-08-25 07:08:33","host":"us-036*","referer":"https://segmentfault.com/a/1190000023677258","linkMd5ListStr":"81351ef5cee65b004bca5b0902fb9913","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"10 KB","destSize":"13.7 KB","compressRate":"137%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023657741","sourceStatusCode":200,"destWidth":800,"destHeight":681,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn92@2020_4/2020/08/24/23-08-36-207_577394f1b53dd12a.webp","sourceBytes":107905,"destBytes":25316,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2293,"convertSpendMs":91,"createdTime":"2020-08-25 07:08:34","host":"us-010*","referer":"https://segmentfault.com/a/1190000023657729","linkMd5ListStr":"9569faa8acc0e079a1c10828ff9a417e","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"105.4 KB","destSize":"24.7 KB","compressRate":"23.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLvGS","sourceStatusCode":200,"destWidth":366,"destHeight":284,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn71@2020_5/2020/08/24/23-08-36-323_5b993b1029d81167.webp","sourceBytes":12427,"destBytes":11566,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3584,"convertSpendMs":6,"createdTime":"2020-08-25 07:08:33","host":"us-025*","referer":"https://segmentfault.com/a/1190000023677258","linkMd5ListStr":"81351ef5cee65b004bca5b0902fb9913","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12.1 KB","destSize":"11.3 KB","compressRate":"93.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK8rN","sourceStatusCode":200,"destWidth":800,"destHeight":315,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn80@2020_3/2020/08/24/23-08-36-263_3c39699332f578b1.webp","sourceBytes":30818,"destBytes":32338,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3274,"convertSpendMs":22,"createdTime":"2020-08-25 07:08:33","host":"us-003*","referer":"https://segmentfault.com/a/1190000023587881","linkMd5ListStr":"38260b3f6e6b52df89d4a67c52a99d4e","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"30.1 KB","destSize":"31.6 KB","compressRate":"104.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK8rJ","sourceStatusCode":200,"destWidth":275,"destHeight":189,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn96@2020_2/2020/08/24/23-08-36-120_24bfbdbe72cc45ff.webp","sourceBytes":484135,"destBytes":202964,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3044,"convertSpendMs":259,"createdTime":"2020-08-25 07:08:34","host":"us-022*","referer":"https://segmentfault.com/a/1190000023587881","linkMd5ListStr":"38260b3f6e6b52df89d4a67c52a99d4e","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"472.8 KB","destSize":"198.2 KB","compressRate":"41.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023601934","sourceStatusCode":200,"destWidth":529,"destHeight":460,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn4@2020_6/2020/08/24/23-08-36-470_98a69215dba7edeb.webp","sourceBytes":24766,"destBytes":28694,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3330,"convertSpendMs":12,"createdTime":"2020-08-25 07:08:34","host":"europe-25*","referer":"https://segmentfault.com/a/1190000023601927","linkMd5ListStr":"caee1d7512ed006f50fb714e278bb4f4","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.2 KB","destSize":"28 KB","compressRate":"115.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbKULG","sourceStatusCode":200,"destWidth":800,"destHeight":379,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn27@2020_5/2020/08/24/23-08-36-689_6b82b381e1690545.webp","sourceBytes":126446,"destBytes":28740,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3491,"convertSpendMs":19,"createdTime":"2020-08-25 07:08:34","host":"europe70*","referer":"https://segmentfault.com/a/1190000023608432","linkMd5ListStr":"749b88d16e8263f6e6691f06881f8209","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"123.5 KB","destSize":"28.1 KB","compressRate":"22.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK8rI","sourceStatusCode":200,"destWidth":434,"destHeight":316,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn92@2020_5/2020/08/24/23-08-36-947_42b85b2ae6d997a1.webp","sourceBytes":162013,"destBytes":17168,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3633,"convertSpendMs":12,"createdTime":"2020-08-25 07:08:34","host":"us-033*","referer":"https://segmentfault.com/a/1190000023587881","linkMd5ListStr":"38260b3f6e6b52df89d4a67c52a99d4e","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"158.2 KB","destSize":"16.8 KB","compressRate":"10.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023652883","sourceStatusCode":200,"destWidth":226,"destHeight":41,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn12@2020_2/2020/08/24/23-08-36-976_aa939d9b8362bbcf.webp","sourceBytes":5492,"destBytes":1998,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2769,"convertSpendMs":4,"createdTime":"2020-08-25 07:08:35","host":"europe-59*","referer":"https://segmentfault.com/a/1190000023652879","linkMd5ListStr":"d0ff9ddefe9a6a882e6318d475159e5e","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"5.4 KB","destSize":"2 KB","compressRate":"36.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709801","sourceStatusCode":200,"destWidth":676,"destHeight":243,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn48@2020_1/2020/08/24/23-08-37-123_d94dd4f33dfc2b9f.webp","sourceBytes":9274,"destBytes":11720,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3303,"convertSpendMs":40,"createdTime":"2020-08-25 07:08:34","host":"us-005*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"9.1 KB","destSize":"11.4 KB","compressRate":"126.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709802","sourceStatusCode":200,"destWidth":759,"destHeight":630,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn52@2020_2/2020/08/24/23-08-36-907_f10a55c3175000a3.webp","sourceBytes":34726,"destBytes":16792,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3526,"convertSpendMs":18,"createdTime":"2020-08-25 07:08:34","host":"europe67*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"33.9 KB","destSize":"16.4 KB","compressRate":"48.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023657739","sourceStatusCode":200,"destWidth":800,"destHeight":624,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn100@2020_1/2020/08/24/23-08-36-884_490e6b9cc76ef541.webp","sourceBytes":90486,"destBytes":21124,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3187,"convertSpendMs":23,"createdTime":"2020-08-25 07:08:34","host":"europe61*","referer":"https://segmentfault.com/a/1190000023657729","linkMd5ListStr":"9569faa8acc0e079a1c10828ff9a417e","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"88.4 KB","destSize":"20.6 KB","compressRate":"23.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLvGs","sourceStatusCode":200,"destWidth":420,"destHeight":297,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn23@2020_5/2020/08/24/23-08-37-100_402763b3dd71ef2c.webp","sourceBytes":18132,"destBytes":20414,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3520,"convertSpendMs":13,"createdTime":"2020-08-25 07:08:34","host":"us-008*","referer":"https://segmentfault.com/a/1190000023677258","linkMd5ListStr":"81351ef5cee65b004bca5b0902fb9913","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"17.7 KB","destSize":"19.9 KB","compressRate":"112.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLFfh","sourceStatusCode":200,"destWidth":800,"destHeight":531,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn39@2020_4/2020/08/24/23-08-37-152_4ce085e5b8852c3c.webp","sourceBytes":81077,"destBytes":24972,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3438,"convertSpendMs":16,"createdTime":"2020-08-25 07:08:34","host":"us-027*","referer":"https://segmentfault.com/a/1190000023714011","linkMd5ListStr":"317dc10a0d3fb89965600980c204116d","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"79.2 KB","destSize":"24.4 KB","compressRate":"30.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK8rL","sourceStatusCode":200,"destWidth":800,"destHeight":418,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn8@2020_4/2020/08/24/23-08-36-839_67cdf4d01f6a82ed.webp","sourceBytes":46636,"destBytes":46136,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3882,"convertSpendMs":27,"createdTime":"2020-08-25 07:08:34","host":"europe62*","referer":"https://segmentfault.com/a/1190000023587881","linkMd5ListStr":"38260b3f6e6b52df89d4a67c52a99d4e","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"45.5 KB","destSize":"45.1 KB","compressRate":"98.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK8rP","sourceStatusCode":200,"destWidth":800,"destHeight":709,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn88@2020_1/2020/08/24/23-08-37-146_33e57f0e6761d6ff.webp","sourceBytes":58165,"destBytes":50808,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3952,"convertSpendMs":82,"createdTime":"2020-08-25 07:08:34","host":"us-54*","referer":"https://segmentfault.com/a/1190000023587881","linkMd5ListStr":"38260b3f6e6b52df89d4a67c52a99d4e","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"56.8 KB","destSize":"49.6 KB","compressRate":"87.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK8rK","sourceStatusCode":200,"destWidth":800,"destHeight":425,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn99@2020_4/2020/08/24/23-08-37-087_cedf4db363bdd8fe.webp","sourceBytes":47687,"destBytes":47036,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3812,"convertSpendMs":32,"createdTime":"2020-08-25 07:08:34","host":"us-011*","referer":"https://segmentfault.com/a/1190000023587881","linkMd5ListStr":"38260b3f6e6b52df89d4a67c52a99d4e","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"46.6 KB","destSize":"45.9 KB","compressRate":"98.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbJcHj","sourceStatusCode":200,"destWidth":800,"destHeight":189,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn20@2020_2/2020/08/24/23-08-37-345_f113e092cc336adb.webp","sourceBytes":125374,"destBytes":22852,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3718,"convertSpendMs":49,"createdTime":"2020-08-25 07:08:34","host":"us-019*","referer":"https://segmentfault.com/a/1190000023622134","linkMd5ListStr":"feb087fef9d4181f56dd8589fa8fcc79","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"122.4 KB","destSize":"22.3 KB","compressRate":"18.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023601935","sourceStatusCode":200,"destWidth":800,"destHeight":307,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn11@2020_1/2020/08/24/23-08-37-304_1fddd172f9de192b.webp","sourceBytes":44954,"destBytes":44954,"feedId":6615,"totalSpendMs":3844,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:34","host":"us-51*","referer":"https://segmentfault.com/a/1190000023601927","linkMd5ListStr":"caee1d7512ed006f50fb714e278bb4f4","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"43.9 KB","destSize":"43.9 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLFfE","sourceStatusCode":200,"destWidth":800,"destHeight":530,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn32@2020_4/2020/08/24/23-08-37-014_df9d49603cc32ef0.webp","sourceBytes":111043,"destBytes":37010,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3869,"convertSpendMs":21,"createdTime":"2020-08-25 07:08:34","host":"europe-59*","referer":"https://segmentfault.com/a/1190000023714011","linkMd5ListStr":"317dc10a0d3fb89965600980c204116d","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"108.4 KB","destSize":"36.1 KB","compressRate":"33.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709803","sourceStatusCode":200,"destWidth":347,"destHeight":278,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn60@2020_2/2020/08/24/23-08-37-310_d2a8b739b73e75b1.webp","sourceBytes":89888,"destBytes":16986,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3691,"convertSpendMs":15,"createdTime":"2020-08-25 07:08:34","host":"us-035*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"87.8 KB","destSize":"16.6 KB","compressRate":"18.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023709804","sourceStatusCode":200,"destWidth":800,"destHeight":246,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn64@2020_4/2020/08/24/23-08-37-435_4af65fb32a269cbc.webp","sourceBytes":40822,"destBytes":8012,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3652,"convertSpendMs":10,"createdTime":"2020-08-25 07:08:34","host":"us-024*","referer":"https://segmentfault.com/a/1190000023709787","linkMd5ListStr":"ac9425a1dc212f5c19afed90d55afc0d","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"39.9 KB","destSize":"7.8 KB","compressRate":"19.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLFfq","sourceStatusCode":200,"destWidth":800,"destHeight":534,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn44@2020_1/2020/08/24/23-08-37-389_8988f99120692e64.webp","sourceBytes":77646,"destBytes":24950,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3791,"convertSpendMs":36,"createdTime":"2020-08-25 07:08:34","host":"us-016*","referer":"https://segmentfault.com/a/1190000023714011","linkMd5ListStr":"317dc10a0d3fb89965600980c204116d","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"75.8 KB","destSize":"24.4 KB","compressRate":"32.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023657733","sourceStatusCode":200,"destWidth":800,"destHeight":250,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn83@2020_5/2020/08/24/23-08-37-631_8c8436a6031ce5b2.webp","sourceBytes":44180,"destBytes":13190,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3263,"convertSpendMs":12,"createdTime":"2020-08-25 07:08:35","host":"us-032*","referer":"https://segmentfault.com/a/1190000023657729","linkMd5ListStr":"9569faa8acc0e079a1c10828ff9a417e","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"43.1 KB","destSize":"12.9 KB","compressRate":"29.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023657740","sourceStatusCode":200,"destWidth":800,"destHeight":756,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn95@2020_2/2020/08/24/23-08-37-201_1d04b2d366acdb5c.webp","sourceBytes":117934,"destBytes":31088,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3674,"convertSpendMs":27,"createdTime":"2020-08-25 07:08:34","host":"europe-24*","referer":"https://segmentfault.com/a/1190000023657729","linkMd5ListStr":"9569faa8acc0e079a1c10828ff9a417e","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"115.2 KB","destSize":"30.4 KB","compressRate":"26.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023657742","sourceStatusCode":200,"destWidth":745,"destHeight":794,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn88@2020_6/2020/08/24/23-08-37-616_aaa501e20ba9eee8.webp","sourceBytes":45045,"destBytes":36340,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3720,"convertSpendMs":33,"createdTime":"2020-08-25 07:08:34","host":"us-021*","referer":"https://segmentfault.com/a/1190000023657729","linkMd5ListStr":"9569faa8acc0e079a1c10828ff9a417e","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"44 KB","destSize":"35.5 KB","compressRate":"80.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbHZSb","sourceStatusCode":200,"destWidth":800,"destHeight":340,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn68@2020_4/2020/08/24/23-08-37-572_9328baa6c41eb7d7.webp","sourceBytes":55340,"destBytes":55340,"feedId":6615,"totalSpendMs":3855,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:34","host":"us-013*","referer":"https://segmentfault.com/a/1190000023652718","linkMd5ListStr":"06182f917f57c9d9612487bd563c6868,edffa444454de4e48a3d973ca7297088","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"54 KB","destSize":"54 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023657738","sourceStatusCode":200,"destWidth":800,"destHeight":759,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn4@2020_1/2020/08/24/23-08-37-700_47af21c1d8fe1b43.webp","sourceBytes":119115,"destBytes":30466,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3590,"convertSpendMs":45,"createdTime":"2020-08-25 07:08:34","host":"us-040*","referer":"https://segmentfault.com/a/1190000023657729","linkMd5ListStr":"9569faa8acc0e079a1c10828ff9a417e","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"116.3 KB","destSize":"29.8 KB","compressRate":"25.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023657734","sourceStatusCode":200,"destWidth":800,"destHeight":634,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn80@2020_6/2020/08/24/23-08-37-888_0219a4c09525c3f3.webp","sourceBytes":203570,"destBytes":40296,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4093,"convertSpendMs":40,"createdTime":"2020-08-25 07:08:34","host":"us-53*","referer":"https://segmentfault.com/a/1190000023657729","linkMd5ListStr":"9569faa8acc0e079a1c10828ff9a417e","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"198.8 KB","destSize":"39.4 KB","compressRate":"19.8%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/12.png","sourceStatusCode":200,"destWidth":543,"destHeight":227,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn80@2020_6/2020/08/24/23-08-38-200_ba0f32660e8bc151.webp","sourceBytes":8760,"destBytes":8760,"feedId":6615,"totalSpendMs":1033,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:38","host":"us-002*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"8.6 KB","destSize":"8.6 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023708778","sourceStatusCode":200,"destWidth":539,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn23@2020_2/2020/08/24/23-08-38-329_bf5033b02384e3e7.webp","sourceBytes":42668,"destBytes":13184,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2291,"convertSpendMs":20,"createdTime":"2020-08-25 07:08:36","host":"us-018*","referer":"https://segmentfault.com/a/1190000023708775","linkMd5ListStr":"b4d24379ce31382e9336abd377405f85","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"41.7 KB","destSize":"12.9 KB","compressRate":"30.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023652888","sourceStatusCode":200,"destWidth":246,"destHeight":93,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn56@2020_3/2020/08/24/23-08-38-339_51682126a715d4c0.webp","sourceBytes":10206,"destBytes":3562,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2011,"convertSpendMs":4,"createdTime":"2020-08-25 07:08:37","host":"europe-25*","referer":"https://segmentfault.com/a/1190000023652879","linkMd5ListStr":"d0ff9ddefe9a6a882e6318d475159e5e","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"10 KB","destSize":"3.5 KB","compressRate":"34.9%"},{"code":1,"isDone":false,"source":"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu970lp1rj30me0hq494.jpg","sourceStatusCode":200,"destWidth":806,"destHeight":638,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn100@2020_1/2020/08/24/23-08-38-382_bd6c3dce7d6e55b1.webp","sourceBytes":60191,"destBytes":30932,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":978,"convertSpendMs":27,"createdTime":"2020-08-25 07:08:38","host":"us-014*","referer":"https://segmentfault.com/a/1190000023668057","linkMd5ListStr":"dcb1ca1d6d9e74559b1305ed3b0d3469","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"58.8 KB","destSize":"30.2 KB","compressRate":"51.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023657737","sourceStatusCode":200,"destWidth":450,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn7@2020_6/2020/08/24/23-08-38-067_37c2c4464d2306d7.webp","sourceBytes":146281,"destBytes":31920,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4321,"convertSpendMs":20,"createdTime":"2020-08-25 07:08:34","host":"europe69*","referer":"https://segmentfault.com/a/1190000023657729","linkMd5ListStr":"9569faa8acc0e079a1c10828ff9a417e","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"142.9 KB","destSize":"31.2 KB","compressRate":"21.8%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/11.png","sourceStatusCode":200,"destWidth":740,"destHeight":738,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn3@2020_4/2020/08/24/23-08-38-385_6664d5c4cdec1a50.webp","sourceBytes":36006,"destBytes":36006,"feedId":6615,"totalSpendMs":971,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:38","host":"us-004*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"35.2 KB","destSize":"35.2 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023708781","sourceStatusCode":200,"destWidth":800,"destHeight":685,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn35@2020_2/2020/08/24/23-08-38-260_1b98c2cb4699745d.webp","sourceBytes":135572,"destBytes":23394,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2305,"convertSpendMs":25,"createdTime":"2020-08-25 07:08:36","host":"europe61*","referer":"https://segmentfault.com/a/1190000023708775","linkMd5ListStr":"b4d24379ce31382e9336abd377405f85","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"132.4 KB","destSize":"22.8 KB","compressRate":"17.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023652886","sourceStatusCode":200,"destWidth":272,"destHeight":112,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn51@2020_5/2020/08/24/23-08-38-491_33b83eb09ae0f820.webp","sourceBytes":12767,"destBytes":5070,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2061,"convertSpendMs":6,"createdTime":"2020-08-25 07:08:37","host":"us-010*","referer":"https://segmentfault.com/a/1190000023652879","linkMd5ListStr":"d0ff9ddefe9a6a882e6318d475159e5e","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12.5 KB","destSize":"5 KB","compressRate":"39.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLuza","sourceStatusCode":200,"destWidth":800,"destHeight":340,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn27@2020_6/2020/08/24/23-08-38-440_fb92e27a6436323a.webp","sourceBytes":283958,"destBytes":30376,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2352,"convertSpendMs":28,"createdTime":"2020-08-25 07:08:36","host":"us-008*","referer":"https://segmentfault.com/a/1190000023675512","linkMd5ListStr":"8130037c23e0c993c51e97490b17f7b6","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"277.3 KB","destSize":"29.7 KB","compressRate":"10.7%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/3.png","sourceStatusCode":200,"destWidth":1008,"destHeight":525,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn28@2020_2/2020/08/24/23-08-38-581_dc3226984ea6a4b1.webp","sourceBytes":24486,"destBytes":24486,"feedId":6615,"totalSpendMs":931,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:38","host":"us-006*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23.9 KB","destSize":"23.9 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/4.png","sourceStatusCode":200,"destWidth":845,"destHeight":418,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn68@2020_3/2020/08/24/23-08-38-545_133d4c84d77e836a.webp","sourceBytes":19654,"destBytes":19654,"feedId":6615,"totalSpendMs":1060,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:38","host":"us-033*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"19.2 KB","destSize":"19.2 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023684250","sourceStatusCode":200,"destWidth":800,"destHeight":293,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn60@2020_2/2020/08/24/23-08-38-560_259f8fe4710a279d.webp","sourceBytes":59733,"destBytes":20328,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2253,"convertSpendMs":13,"createdTime":"2020-08-25 07:08:37","host":"europe63*","referer":"https://segmentfault.com/a/1190000023684246","linkMd5ListStr":"420bda976c9e79232c9adc2d2bfab39b","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"58.3 KB","destSize":"19.9 KB","compressRate":"34%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023708782","sourceStatusCode":200,"destWidth":800,"destHeight":444,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn39@2020_5/2020/08/24/23-08-38-804_234d06daf8751ef2.webp","sourceBytes":349342,"destBytes":34826,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2389,"convertSpendMs":31,"createdTime":"2020-08-25 07:08:37","host":"us-51*","referer":"https://segmentfault.com/a/1190000023708775","linkMd5ListStr":"b4d24379ce31382e9336abd377405f85","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"341.2 KB","destSize":"34 KB","compressRate":"10%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023652885","sourceStatusCode":200,"destWidth":276,"destHeight":89,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn16@2020_2/2020/08/24/23-08-38-819_d6f77ebf0796d56f.webp","sourceBytes":11012,"destBytes":4032,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3804,"convertSpendMs":5,"createdTime":"2020-08-25 07:08:35","host":"us-039*","referer":"https://segmentfault.com/a/1190000023652879","linkMd5ListStr":"d0ff9ddefe9a6a882e6318d475159e5e","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"10.8 KB","destSize":"3.9 KB","compressRate":"36.6%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/2.png","sourceStatusCode":200,"destWidth":1240,"destHeight":426,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn47@2020_4/2020/08/24/23-08-39-007_71ea8796fe8a5213.webp","sourceBytes":24860,"destBytes":24860,"feedId":6615,"totalSpendMs":1189,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:38","host":"us-018*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.3 KB","destSize":"24.3 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/14.png","sourceStatusCode":200,"destWidth":616,"destHeight":473,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn51@2020_4/2020/08/24/23-08-38-994_c44d50e66064c4ab.webp","sourceBytes":24364,"destBytes":24364,"feedId":6615,"totalSpendMs":1109,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:38","host":"us-008*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23.8 KB","destSize":"23.8 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023684251","sourceStatusCode":200,"destWidth":800,"destHeight":288,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn64@2020_1/2020/08/24/23-08-39-180_f004b02cd44eaa50.webp","sourceBytes":190525,"destBytes":37274,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2334,"convertSpendMs":39,"createdTime":"2020-08-25 07:08:37","host":"us-53*","referer":"https://segmentfault.com/a/1190000023684246","linkMd5ListStr":"420bda976c9e79232c9adc2d2bfab39b","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"186.1 KB","destSize":"36.4 KB","compressRate":"19.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023684252","sourceStatusCode":200,"destWidth":798,"destHeight":299,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn72@2020_5/2020/08/24/23-08-39-252_6e03b370097de657.webp","sourceBytes":12611,"destBytes":22666,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2180,"convertSpendMs":14,"createdTime":"2020-08-25 07:08:37","host":"us-022*","referer":"https://segmentfault.com/a/1190000023684246","linkMd5ListStr":"420bda976c9e79232c9adc2d2bfab39b","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12.3 KB","destSize":"22.1 KB","compressRate":"179.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023684249","sourceStatusCode":200,"destWidth":635,"destHeight":378,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn32@2020_2/2020/08/24/23-08-39-108_9e9ebdfe1d798e4b.webp","sourceBytes":25420,"destBytes":14732,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3154,"convertSpendMs":15,"createdTime":"2020-08-25 07:08:36","host":"europe21*","referer":"https://segmentfault.com/a/1190000023684246","linkMd5ListStr":"420bda976c9e79232c9adc2d2bfab39b","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.8 KB","destSize":"14.4 KB","compressRate":"58%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLnGW","sourceStatusCode":200,"destWidth":601,"destHeight":421,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn8@2020_5/2020/08/24/23-08-39-315_adc2628a7dd7bf8a.webp","sourceBytes":19104,"destBytes":11912,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2174,"convertSpendMs":10,"createdTime":"2020-08-25 07:08:38","host":"europe67*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.7 KB","destSize":"11.6 KB","compressRate":"62.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023652884","sourceStatusCode":200,"destWidth":231,"destHeight":41,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn20@2020_6/2020/08/24/23-08-39-520_d14dbd35c4d89843.webp","sourceBytes":5814,"destBytes":2452,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3621,"convertSpendMs":3,"createdTime":"2020-08-25 07:08:36","host":"us-028*","referer":"https://segmentfault.com/a/1190000023652879","linkMd5ListStr":"d0ff9ddefe9a6a882e6318d475159e5e","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"5.7 KB","destSize":"2.4 KB","compressRate":"42.2%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/13.png","sourceStatusCode":200,"destWidth":670,"destHeight":542,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn88@2020_2/2020/08/24/23-08-39-593_22e0b3f2ff5b9946.webp","sourceBytes":16942,"destBytes":16942,"feedId":6615,"totalSpendMs":978,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:39","host":"us-53*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"16.5 KB","destSize":"16.5 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/1.png","sourceStatusCode":200,"destWidth":875,"destHeight":221,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn100@2020_2/2020/08/24/23-08-39-801_b3b0bbd56733612b.webp","sourceBytes":5518,"destBytes":5518,"feedId":6615,"totalSpendMs":931,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:39","host":"us-012*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"5.4 KB","destSize":"5.4 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLuyc","sourceStatusCode":200,"destWidth":800,"destHeight":638,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn32@2020_1/2020/08/24/23-08-39-566_da9fdf1e5cbe5397.webp","sourceBytes":59092,"destBytes":20892,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2273,"convertSpendMs":28,"createdTime":"2020-08-25 07:08:38","host":"europe69*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"57.7 KB","destSize":"20.4 KB","compressRate":"35.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLKdp","sourceStatusCode":200,"destWidth":800,"destHeight":134,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn24@2020_1/2020/08/24/23-08-39-802_6dcde18ff4f9579f.webp","sourceBytes":88533,"destBytes":16398,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2219,"convertSpendMs":17,"createdTime":"2020-08-25 07:08:38","host":"us-016*","referer":"https://segmentfault.com/a/1190000023733064","linkMd5ListStr":"2bab059fcc83687a9e4e5c0f8280a58a","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"86.5 KB","destSize":"16 KB","compressRate":"18.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLnDZ","sourceStatusCode":200,"destWidth":461,"destHeight":261,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn44@2020_6/2020/08/24/23-08-39-925_15e73f90245f980f.webp","sourceBytes":12275,"destBytes":7396,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2113,"convertSpendMs":6,"createdTime":"2020-08-25 07:08:38","host":"us-028*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12 KB","destSize":"7.2 KB","compressRate":"60.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000021954612","sourceStatusCode":200,"destWidth":800,"destHeight":452,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn19@2020_6/2020/08/24/23-08-39-691_173e40b0392302c0.webp","sourceBytes":17692,"destBytes":17692,"feedId":6615,"totalSpendMs":2358,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:38","host":"us-026*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"17.3 KB","destSize":"17.3 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023652887","sourceStatusCode":200,"destWidth":238,"destHeight":43,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn48@2020_5/2020/08/24/23-08-39-891_6cd080a4e73af923.webp","sourceBytes":6310,"destBytes":2436,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3548,"convertSpendMs":3,"createdTime":"2020-08-25 07:08:37","host":"us-020*","referer":"https://segmentfault.com/a/1190000023652879","linkMd5ListStr":"d0ff9ddefe9a6a882e6318d475159e5e","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"6.2 KB","destSize":"2.4 KB","compressRate":"38.6%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/8.png","sourceStatusCode":200,"destWidth":743,"destHeight":273,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn12@2020_5/2020/08/24/23-08-40-119_7b2769b97c50b3fb.webp","sourceBytes":23504,"destBytes":23504,"feedId":6615,"totalSpendMs":1096,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:39","host":"us-55*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23 KB","destSize":"23 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLAK3","sourceStatusCode":200,"destWidth":800,"destHeight":505,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn39@2020_5/2020/08/24/23-08-40-208_0326fce0462089d5.webp","sourceBytes":280033,"destBytes":27476,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2464,"convertSpendMs":44,"createdTime":"2020-08-25 07:08:38","host":"us-039*","referer":"https://segmentfault.com/a/1190000023696737","linkMd5ListStr":"6077149de366230a75fc5ccb09f8bad7","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"273.5 KB","destSize":"26.8 KB","compressRate":"9.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLALn","sourceStatusCode":200,"destWidth":543,"destHeight":532,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn56@2020_4/2020/08/24/23-08-40-100_b74d346d8a6ba7ce.webp","sourceBytes":94069,"destBytes":44070,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2535,"convertSpendMs":16,"createdTime":"2020-08-25 07:08:38","host":"europe21*","referer":"https://segmentfault.com/a/1190000023696737","linkMd5ListStr":"6077149de366230a75fc5ccb09f8bad7","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"91.9 KB","destSize":"43 KB","compressRate":"46.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK4xf","sourceStatusCode":200,"destWidth":481,"destHeight":241,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn84@2020_3/2020/08/24/23-08-40-464_0f4e5e7d74c38a3f.webp","sourceBytes":20108,"destBytes":6924,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2071,"convertSpendMs":6,"createdTime":"2020-08-25 07:08:39","host":"europe63*","referer":"https://segmentfault.com/a/1190000023572844","linkMd5ListStr":"b422d5e4e3dee35be3d3afd3b84c77cd","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"19.6 KB","destSize":"6.8 KB","compressRate":"34.4%"},{"code":1,"isDone":false,"source":"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97zzd7lj30fx0jzwed.jpg","sourceStatusCode":200,"destWidth":573,"destHeight":719,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn35@2020_1/2020/08/24/23-08-40-294_a6171109d968ad49.webp","sourceBytes":31781,"destBytes":13310,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2965,"convertSpendMs":19,"createdTime":"2020-08-25 07:08:38","host":"europe-59*","referer":"https://segmentfault.com/a/1190000023668057","linkMd5ListStr":"dcb1ca1d6d9e74559b1305ed3b0d3469","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"31 KB","destSize":"13 KB","compressRate":"41.9%"},{"code":1,"isDone":false,"source":"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97wrwzzj30aj08ydfv.jpg","sourceStatusCode":200,"destWidth":379,"destHeight":322,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn12@2020_3/2020/08/24/23-08-40-518_f5f7dfcb6fc90747.webp","sourceBytes":14122,"destBytes":8532,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3160,"convertSpendMs":6,"createdTime":"2020-08-25 07:08:38","host":"europe-57*","referer":"https://segmentfault.com/a/1190000023668057","linkMd5ListStr":"dcb1ca1d6d9e74559b1305ed3b0d3469","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"13.8 KB","destSize":"8.3 KB","compressRate":"60.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023708780","sourceStatusCode":200,"destWidth":741,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn44@2020_6/2020/08/24/23-08-40-620_dfc9c678416ce7f2.webp","sourceBytes":99478,"destBytes":20760,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4221,"convertSpendMs":114,"createdTime":"2020-08-25 07:08:37","host":"us-031*","referer":"https://segmentfault.com/a/1190000023708775","linkMd5ListStr":"b4d24379ce31382e9336abd377405f85","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"97.1 KB","destSize":"20.3 KB","compressRate":"20.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK4xe","sourceStatusCode":200,"destWidth":800,"destHeight":309,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn80@2020_2/2020/08/24/23-08-40-513_d8c8f7bcd0b2f161.webp","sourceBytes":27659,"destBytes":16422,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2427,"convertSpendMs":11,"createdTime":"2020-08-25 07:08:39","host":"europe-25*","referer":"https://segmentfault.com/a/1190000023572844","linkMd5ListStr":"b422d5e4e3dee35be3d3afd3b84c77cd","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"27 KB","destSize":"16 KB","compressRate":"59.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbJgYT","sourceStatusCode":200,"destWidth":800,"destHeight":189,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn92@2020_2/2020/08/24/23-08-40-881_7f8323e1c3c7e5a5.webp","sourceBytes":129123,"destBytes":22456,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2227,"convertSpendMs":17,"createdTime":"2020-08-25 07:08:39","host":"us-033*","referer":"https://segmentfault.com/a/1190000023652718","linkMd5ListStr":"6077149de366230a75fc5ccb09f8bad7,06182f917f57c9d9612487bd563c6868,317dc10a0d3fb89965600980c204116d,edffa444454de4e48a3d973ca7297088","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"126.1 KB","destSize":"21.9 KB","compressRate":"17.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK4xj","sourceStatusCode":200,"destWidth":800,"destHeight":414,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn76@2020_3/2020/08/24/23-08-40-898_06b93a933331770f.webp","sourceBytes":27832,"destBytes":9516,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2258,"convertSpendMs":15,"createdTime":"2020-08-25 07:08:39","host":"us-010*","referer":"https://segmentfault.com/a/1190000023572844","linkMd5ListStr":"b422d5e4e3dee35be3d3afd3b84c77cd","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"27.2 KB","destSize":"9.3 KB","compressRate":"34.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023684253","sourceStatusCode":200,"destWidth":800,"destHeight":293,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn76@2020_6/2020/08/24/23-08-40-810_153921800664839e.webp","sourceBytes":181102,"destBytes":36390,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3652,"convertSpendMs":16,"createdTime":"2020-08-25 07:08:38","host":"us-012*","referer":"https://segmentfault.com/a/1190000023684246","linkMd5ListStr":"420bda976c9e79232c9adc2d2bfab39b","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"176.9 KB","destSize":"35.5 KB","compressRate":"20.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK4xi","sourceStatusCode":200,"destWidth":800,"destHeight":432,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn72@2020_6/2020/08/24/23-08-40-953_0fe59535c76a90d2.webp","sourceBytes":54967,"destBytes":13880,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2496,"convertSpendMs":19,"createdTime":"2020-08-25 07:08:39","host":"us-020*","referer":"https://segmentfault.com/a/1190000023572844","linkMd5ListStr":"b422d5e4e3dee35be3d3afd3b84c77cd","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"53.7 KB","destSize":"13.6 KB","compressRate":"25.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK4xg","sourceStatusCode":200,"destWidth":480,"destHeight":296,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn63@2020_4/2020/08/24/23-08-40-963_15be9c0256e0e892.webp","sourceBytes":26310,"destBytes":8938,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2482,"convertSpendMs":6,"createdTime":"2020-08-25 07:08:39","host":"us-51*","referer":"https://segmentfault.com/a/1190000023572844","linkMd5ListStr":"b422d5e4e3dee35be3d3afd3b84c77cd","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.7 KB","destSize":"8.7 KB","compressRate":"34%"},{"code":1,"isDone":false,"source":"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97sgc39j30e20csglg.jpg","sourceStatusCode":200,"destWidth":506,"destHeight":460,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn60@2020_1/2020/08/24/23-08-41-132_634987b590838a90.webp","sourceBytes":21558,"destBytes":9976,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2857,"convertSpendMs":8,"createdTime":"2020-08-25 07:08:39","host":"europe61*","referer":"https://segmentfault.com/a/1190000023668057","linkMd5ListStr":"dcb1ca1d6d9e74559b1305ed3b0d3469","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"21.1 KB","destSize":"9.7 KB","compressRate":"46.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbJkcQ","sourceStatusCode":200,"destWidth":800,"destHeight":509,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn3@2020_5/2020/08/24/23-08-41-152_0e8f52e3944cf4dd.webp","sourceBytes":122961,"destBytes":69544,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2354,"convertSpendMs":38,"createdTime":"2020-08-25 07:08:39","host":"us-002*","referer":"https://segmentfault.com/a/1190000023587881","linkMd5ListStr":"38260b3f6e6b52df89d4a67c52a99d4e","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"120.1 KB","destSize":"67.9 KB","compressRate":"56.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK4xh","sourceStatusCode":200,"destWidth":800,"destHeight":361,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn68@2020_3/2020/08/24/23-08-41-099_18c413ba34379e95.webp","sourceBytes":108569,"destBytes":33160,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2798,"convertSpendMs":96,"createdTime":"2020-08-25 07:08:39","host":"us-031*","referer":"https://segmentfault.com/a/1190000023572844","linkMd5ListStr":"b422d5e4e3dee35be3d3afd3b84c77cd","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"106 KB","destSize":"32.4 KB","compressRate":"30.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000021954610","sourceStatusCode":200,"destWidth":800,"destHeight":410,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn16@2020_6/2020/08/24/23-08-41-359_7ed64be196d18b41.webp","sourceBytes":219416,"destBytes":79918,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3946,"convertSpendMs":27,"createdTime":"2020-08-25 07:08:38","host":"us-037*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"214.3 KB","destSize":"78 KB","compressRate":"36.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023636711","sourceStatusCode":200,"destWidth":430,"destHeight":430,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn15@2020_3/2020/08/24/23-08-41-491_a91637ac7b4d1501.webp","sourceBytes":21301,"destBytes":14282,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2309,"convertSpendMs":11,"createdTime":"2020-08-25 07:08:40","host":"us-035*","referer":"https://segmentfault.com/a/1190000023636701","linkMd5ListStr":"3f522baba1e817cf81ff90c5e1d10cfb","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"20.8 KB","destSize":"13.9 KB","compressRate":"67%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023647616","sourceStatusCode":200,"destWidth":276,"destHeight":789,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn31@2020_4/2020/08/24/23-08-41-339_dae97fa38554c9f9.webp","sourceBytes":47370,"destBytes":32878,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2382,"convertSpendMs":11,"createdTime":"2020-08-25 07:08:40","host":"europe67*","referer":"https://segmentfault.com/a/1190000023647609","linkMd5ListStr":"bd58cfa67f4f5a8296c3cadfd7f5f584","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"46.3 KB","destSize":"32.1 KB","compressRate":"69.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023636712","sourceStatusCode":200,"destWidth":720,"destHeight":321,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn20@2020_5/2020/08/24/23-08-41-617_74973801d641c1f5.webp","sourceBytes":58469,"destBytes":23482,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2466,"convertSpendMs":23,"createdTime":"2020-08-25 07:08:40","host":"us-024*","referer":"https://segmentfault.com/a/1190000023636701","linkMd5ListStr":"3f522baba1e817cf81ff90c5e1d10cfb","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"57.1 KB","destSize":"22.9 KB","compressRate":"40.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023647612","sourceStatusCode":200,"destWidth":800,"destHeight":302,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn24@2020_6/2020/08/24/23-08-41-735_107915944ae8e8f0.webp","sourceBytes":7195,"destBytes":5406,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2329,"convertSpendMs":22,"createdTime":"2020-08-25 07:08:40","host":"us-014*","referer":"https://segmentfault.com/a/1190000023647609","linkMd5ListStr":"bd58cfa67f4f5a8296c3cadfd7f5f584","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"7 KB","destSize":"5.3 KB","compressRate":"75.1%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/7.png","sourceStatusCode":200,"destWidth":1280,"destHeight":787,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn98@2020_5/2020/08/24/23-08-41-746_deecbd4b726849a4.webp","sourceBytes":56962,"destBytes":56962,"feedId":6615,"totalSpendMs":1011,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:41","host":"us-021*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"55.6 KB","destSize":"55.6 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97d1ky0j306g06dt9v.jpg","sourceStatusCode":200,"destWidth":232,"destHeight":229,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn82@2020_4/2020/08/24/23-08-41-795_8c6bb5bc6317c8dc.webp","sourceBytes":10653,"destBytes":7290,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":1328,"convertSpendMs":4,"createdTime":"2020-08-25 07:08:41","host":"europe-59*","referer":"https://segmentfault.com/a/1190000023668057","linkMd5ListStr":"dcb1ca1d6d9e74559b1305ed3b0d3469","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"10.4 KB","destSize":"7.1 KB","compressRate":"68.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023636707","sourceStatusCode":200,"destWidth":600,"destHeight":87,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn40@2020_4/2020/08/24/23-08-42-022_92b4b2118af3de22.webp","sourceBytes":12859,"destBytes":10486,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2280,"convertSpendMs":13,"createdTime":"2020-08-25 07:08:40","host":"us-037*","referer":"https://segmentfault.com/a/1190000023636701","linkMd5ListStr":"3f522baba1e817cf81ff90c5e1d10cfb","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12.6 KB","destSize":"10.2 KB","compressRate":"81.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023636709","sourceStatusCode":200,"destWidth":143,"destHeight":49,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn53@2020_4/2020/08/24/23-08-41-847_78d5f3da1847c64b.webp","sourceBytes":5387,"destBytes":1974,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2202,"convertSpendMs":3,"createdTime":"2020-08-25 07:08:40","host":"europe21*","referer":"https://segmentfault.com/a/1190000023636701","linkMd5ListStr":"3f522baba1e817cf81ff90c5e1d10cfb","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"5.3 KB","destSize":"1.9 KB","compressRate":"36.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023636708","sourceStatusCode":200,"destWidth":206,"destHeight":44,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn44@2020_6/2020/08/24/23-08-42-102_38b4354b68e47c64.webp","sourceBytes":9731,"destBytes":3012,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2249,"convertSpendMs":6,"createdTime":"2020-08-25 07:08:40","host":"us-026*","referer":"https://segmentfault.com/a/1190000023636701","linkMd5ListStr":"3f522baba1e817cf81ff90c5e1d10cfb","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"9.5 KB","destSize":"2.9 KB","compressRate":"31%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/10.png","sourceStatusCode":200,"destWidth":486,"destHeight":289,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn17@2020_3/2020/08/24/23-08-42-141_e9b5f179c2619f81.webp","sourceBytes":12830,"destBytes":12830,"feedId":6615,"totalSpendMs":894,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:41","host":"us-038*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12.5 KB","destSize":"12.5 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023636710","sourceStatusCode":200,"destWidth":800,"destHeight":205,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn8@2020_3/2020/08/24/23-08-41-903_966b3e9e7d0df3ae.webp","sourceBytes":45714,"destBytes":19524,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3303,"convertSpendMs":16,"createdTime":"2020-08-25 07:08:39","host":"europe65*","referer":"https://segmentfault.com/a/1190000023636701","linkMd5ListStr":"3f522baba1e817cf81ff90c5e1d10cfb","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"44.6 KB","destSize":"19.1 KB","compressRate":"42.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023636704","sourceStatusCode":200,"destWidth":604,"destHeight":235,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn58@2020_5/2020/08/24/23-08-41-880_4d348bf55d8de54e.webp","sourceBytes":35501,"destBytes":19298,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2315,"convertSpendMs":9,"createdTime":"2020-08-25 07:08:40","host":"europe62*","referer":"https://segmentfault.com/a/1190000023636701","linkMd5ListStr":"3f522baba1e817cf81ff90c5e1d10cfb","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"34.7 KB","destSize":"18.8 KB","compressRate":"54.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023647615","sourceStatusCode":200,"destWidth":800,"destHeight":576,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn36@2020_3/2020/08/24/23-08-42-134_aa11cbe09197e23f.webp","sourceBytes":21378,"destBytes":11634,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2850,"convertSpendMs":13,"createdTime":"2020-08-25 07:08:40","host":"europe-57*","referer":"https://segmentfault.com/a/1190000023647609","linkMd5ListStr":"bd58cfa67f4f5a8296c3cadfd7f5f584","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"20.9 KB","destSize":"11.4 KB","compressRate":"54.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023647617","sourceStatusCode":200,"destWidth":263,"destHeight":191,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn65@2020_2/2020/08/24/23-08-42-437_c0f9fa580c29ad2c.webp","sourceBytes":3091,"destBytes":2042,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2251,"convertSpendMs":3,"createdTime":"2020-08-25 07:08:40","host":"us-033*","referer":"https://segmentfault.com/a/1190000023647609","linkMd5ListStr":"bd58cfa67f4f5a8296c3cadfd7f5f584","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"3 KB","destSize":"2 KB","compressRate":"66.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000022678951","sourceStatusCode":200,"destWidth":800,"destHeight":292,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn74@2020_4/2020/08/24/23-08-42-545_437227b461a5c9c8.webp","sourceBytes":26554,"destBytes":26554,"feedId":6615,"totalSpendMs":2161,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:41","host":"us-014*","referer":"https://segmentfault.com/a/1190000023657729","linkMd5ListStr":"9569faa8acc0e079a1c10828ff9a417e","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.9 KB","destSize":"25.9 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023647618","sourceStatusCode":200,"destWidth":800,"destHeight":488,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn61@2020_5/2020/08/24/23-08-42-563_0092cc3deacdf28c.webp","sourceBytes":48851,"destBytes":14288,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2482,"convertSpendMs":54,"createdTime":"2020-08-25 07:08:40","host":"us-52*","referer":"https://segmentfault.com/a/1190000023647609","linkMd5ListStr":"bd58cfa67f4f5a8296c3cadfd7f5f584","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"47.7 KB","destSize":"14 KB","compressRate":"29.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbKY8B","sourceStatusCode":200,"destWidth":800,"destHeight":609,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn84@2020_5/2020/08/24/23-08-42-674_0778a1e1cb410796.webp","sourceBytes":157935,"destBytes":28592,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2388,"convertSpendMs":67,"createdTime":"2020-08-25 07:08:41","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023552474","linkMd5ListStr":"518d797df1c7c9d30e2acaaec433d26b","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"154.2 KB","destSize":"27.9 KB","compressRate":"18.1%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/6.png","sourceStatusCode":200,"destWidth":770,"destHeight":388,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn51@2020_2/2020/08/24/23-08-42-743_5e3a1f6dde644120.webp","sourceBytes":22152,"destBytes":22152,"feedId":6615,"totalSpendMs":1266,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:42","host":"europe67*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"21.6 KB","destSize":"21.6 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023647614","sourceStatusCode":200,"destWidth":800,"destHeight":585,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn28@2020_2/2020/08/24/23-08-43-039_31d9dc656eb69c0c.webp","sourceBytes":23060,"destBytes":12060,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3537,"convertSpendMs":40,"createdTime":"2020-08-25 07:08:40","host":"us-004*","referer":"https://segmentfault.com/a/1190000023647609","linkMd5ListStr":"bd58cfa67f4f5a8296c3cadfd7f5f584","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"22.5 KB","destSize":"11.8 KB","compressRate":"52.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLnZN","sourceStatusCode":200,"destWidth":150,"destHeight":150,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn10@2020_1/2020/08/24/23-08-42-916_d4723e98ac161e6d.webp","sourceBytes":11952,"destBytes":4564,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2085,"convertSpendMs":4,"createdTime":"2020-08-25 07:08:41","host":"europe67*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"11.7 KB","destSize":"4.5 KB","compressRate":"38.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLrdc","sourceStatusCode":200,"destWidth":250,"destHeight":250,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn70@2020_5/2020/08/24/23-08-43-038_f7428127a3a50bf0.webp","sourceBytes":58472,"destBytes":11384,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2865,"convertSpendMs":6,"createdTime":"2020-08-25 07:08:40","host":"us-023*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"57.1 KB","destSize":"11.1 KB","compressRate":"19.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000020937494","sourceStatusCode":200,"destWidth":800,"destHeight":363,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn77@2020_2/2020/08/24/23-08-43-037_52b4b78e1ae44485.webp","sourceBytes":21618,"destBytes":21618,"feedId":6615,"totalSpendMs":2623,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:41","host":"us-005*","referer":"https://segmentfault.com/a/1190000023651246","linkMd5ListStr":"9a60a00d9e8d732bd6972e94bc783594","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"21.1 KB","destSize":"21.1 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbKY8C","sourceStatusCode":200,"destWidth":800,"destHeight":609,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn90@2020_1/2020/08/24/23-08-43-089_00fb40bbb61603de.webp","sourceBytes":174359,"destBytes":30298,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2419,"convertSpendMs":72,"createdTime":"2020-08-25 07:08:41","host":"us-040*","referer":"https://segmentfault.com/a/1190000023552474","linkMd5ListStr":"518d797df1c7c9d30e2acaaec433d26b","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"170.3 KB","destSize":"29.6 KB","compressRate":"17.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLnYJ","sourceStatusCode":200,"destWidth":300,"destHeight":300,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn2@2020_2/2020/08/24/23-08-43-211_4c945cb1f7458133.webp","sourceBytes":44855,"destBytes":11756,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2144,"convertSpendMs":8,"createdTime":"2020-08-25 07:08:41","host":"us-012*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"43.8 KB","destSize":"11.5 KB","compressRate":"26.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLnYZ","sourceStatusCode":200,"destWidth":300,"destHeight":300,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn5@2020_3/2020/08/24/23-08-43-205_580793b106d90c39.webp","sourceBytes":29595,"destBytes":8858,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2219,"convertSpendMs":7,"createdTime":"2020-08-25 07:08:41","host":"us-003*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"28.9 KB","destSize":"8.7 KB","compressRate":"29.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbKY8E","sourceStatusCode":200,"destWidth":800,"destHeight":609,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn94@2020_3/2020/08/24/23-08-43-312_99173a1bbea09ba0.webp","sourceBytes":187250,"destBytes":32274,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2593,"convertSpendMs":254,"createdTime":"2020-08-25 07:08:41","host":"us-031*","referer":"https://segmentfault.com/a/1190000023552474","linkMd5ListStr":"518d797df1c7c9d30e2acaaec433d26b","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"182.9 KB","destSize":"31.5 KB","compressRate":"17.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023636706","sourceStatusCode":200,"destWidth":610,"destHeight":237,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn49@2020_5/2020/08/24/23-08-43-314_cd76465a00b523c4.webp","sourceBytes":35565,"destBytes":19546,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3488,"convertSpendMs":10,"createdTime":"2020-08-25 07:08:40","host":"us-007*","referer":"https://segmentfault.com/a/1190000023636701","linkMd5ListStr":"3f522baba1e817cf81ff90c5e1d10cfb","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"34.7 KB","destSize":"19.1 KB","compressRate":"55%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023699210","sourceStatusCode":200,"destWidth":257,"destHeight":253,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn26@2020_5/2020/08/24/23-08-43-739_f76cb0b6b146d3e0.webp","sourceBytes":93779,"destBytes":11922,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2306,"convertSpendMs":88,"createdTime":"2020-08-25 07:08:42","host":"us-019*","referer":"https://segmentfault.com/a/1190000023699206","linkMd5ListStr":"fbe29875f9063bd2517a65d848a2914c","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"91.6 KB","destSize":"11.6 KB","compressRate":"12.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLvcU","sourceStatusCode":200,"destWidth":450,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn22@2020_1/2020/08/24/23-08-43-542_29a435c36e22e408.webp","sourceBytes":653199,"destBytes":73876,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2544,"convertSpendMs":32,"createdTime":"2020-08-25 07:08:41","host":"us-028*","referer":"https://segmentfault.com/a/1190000023675512","linkMd5ListStr":"8130037c23e0c993c51e97490b17f7b6","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"637.9 KB","destSize":"72.1 KB","compressRate":"11.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023699211","sourceStatusCode":200,"destWidth":800,"destHeight":543,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn29@2020_5/2020/08/24/23-08-43-675_a2f4276387b1f0d3.webp","sourceBytes":84284,"destBytes":20890,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2250,"convertSpendMs":32,"createdTime":"2020-08-25 07:08:42","host":"us-010*","referer":"https://segmentfault.com/a/1190000023699206","linkMd5ListStr":"fbe29875f9063bd2517a65d848a2914c","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"82.3 KB","destSize":"20.4 KB","compressRate":"24.8%"},{"code":1,"isDone":false,"source":"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/5.png","sourceStatusCode":200,"destWidth":871,"destHeight":507,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn8@2020_3/2020/08/24/23-08-43-737_c66e8101d9194ace.webp","sourceBytes":26740,"destBytes":26740,"feedId":6615,"totalSpendMs":950,"convertSpendMs":0,"createdTime":"2020-08-25 07:08:43","host":"us-027*","referer":"https://segmentfault.com/a/1190000022332809","linkMd5ListStr":"cb41ea759b4fff7fa2c9b843d9a3559f","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"26.1 KB","destSize":"26.1 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu97gshgmj306o06o0so.jpg","sourceStatusCode":200,"destWidth":240,"destHeight":240,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn16@2020_4/2020/08/24/23-08-43-891_cf34405c50ce7960.webp","sourceBytes":11394,"destBytes":9936,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":815,"convertSpendMs":8,"createdTime":"2020-08-25 07:08:43","host":"us-014*","referer":"https://segmentfault.com/a/1190000023668057","linkMd5ListStr":"dcb1ca1d6d9e74559b1305ed3b0d3469","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"11.1 KB","destSize":"9.7 KB","compressRate":"87.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023699212","sourceStatusCode":200,"destWidth":341,"destHeight":395,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn34@2020_6/2020/08/24/23-08-43-818_9d28dfb62c6fab5b.webp","sourceBytes":213738,"destBytes":27512,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2367,"convertSpendMs":13,"createdTime":"2020-08-25 07:08:42","host":"us-001*","referer":"https://segmentfault.com/a/1190000023699206","linkMd5ListStr":"fbe29875f9063bd2517a65d848a2914c","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"208.7 KB","destSize":"26.9 KB","compressRate":"12.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676564","sourceStatusCode":200,"destWidth":700,"destHeight":553,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn60@2020_5/2020/08/24/23-08-44-070_4c20e67204c9c665.webp","sourceBytes":31559,"destBytes":9366,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2135,"convertSpendMs":53,"createdTime":"2020-08-25 07:08:42","host":"us-53*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"30.8 KB","destSize":"9.1 KB","compressRate":"29.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023699213","sourceStatusCode":200,"destWidth":800,"destHeight":328,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn38@2020_5/2020/08/24/23-08-43-614_dc0539cebd31b98e.webp","sourceBytes":154295,"destBytes":27974,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2528,"convertSpendMs":18,"createdTime":"2020-08-25 07:08:42","host":"europe65*","referer":"https://segmentfault.com/a/1190000023699206","linkMd5ListStr":"fbe29875f9063bd2517a65d848a2914c","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"150.7 KB","destSize":"27.3 KB","compressRate":"18.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676560","sourceStatusCode":200,"destWidth":700,"destHeight":768,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn56@2020_1/2020/08/24/23-08-43-795_6fb596722509c584.webp","sourceBytes":123173,"destBytes":26190,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2575,"convertSpendMs":27,"createdTime":"2020-08-25 07:08:42","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"120.3 KB","destSize":"25.6 KB","compressRate":"21.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676563","sourceStatusCode":200,"destWidth":800,"destHeight":279,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn64@2020_6/2020/08/24/23-08-44-213_2c7c0f8d1664550e.webp","sourceBytes":37139,"destBytes":11340,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2284,"convertSpendMs":13,"createdTime":"2020-08-25 07:08:42","host":"us-037*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"36.3 KB","destSize":"11.1 KB","compressRate":"30.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023699214","sourceStatusCode":200,"destWidth":220,"destHeight":220,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn42@2020_1/2020/08/24/23-08-43-808_86b4044738c9cb37.webp","sourceBytes":415888,"destBytes":100852,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2827,"convertSpendMs":138,"createdTime":"2020-08-25 07:08:42","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023699206","linkMd5ListStr":"fbe29875f9063bd2517a65d848a2914c","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"406.1 KB","destSize":"98.5 KB","compressRate":"24.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676558","sourceStatusCode":200,"destWidth":800,"destHeight":161,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn88@2020_6/2020/08/24/23-08-44-191_7a2abde1a113f500.webp","sourceBytes":28919,"destBytes":6444,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2223,"convertSpendMs":9,"createdTime":"2020-08-25 07:08:42","host":"europe21*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"28.2 KB","destSize":"6.3 KB","compressRate":"22.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663498","sourceStatusCode":200,"destWidth":422,"destHeight":297,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn92@2020_4/2020/08/24/23-08-44-175_2d68dd852b72db7e.webp","sourceBytes":15563,"destBytes":17606,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2240,"convertSpendMs":8,"createdTime":"2020-08-25 07:08:42","host":"europe64*","referer":"https://segmentfault.com/a/1190000023663493","linkMd5ListStr":"b02edc6d556383db4bdfaad310312379","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"15.2 KB","destSize":"17.2 KB","compressRate":"113.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023663497","sourceStatusCode":200,"destWidth":800,"destHeight":327,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn95@2020_5/2020/08/24/23-08-44-284_d3fa1282d5721ffb.webp","sourceBytes":21653,"destBytes":15526,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2200,"convertSpendMs":9,"createdTime":"2020-08-25 07:08:43","host":"europe-58*","referer":"https://segmentfault.com/a/1190000023663493","linkMd5ListStr":"b02edc6d556383db4bdfaad310312379","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"21.1 KB","destSize":"15.2 KB","compressRate":"71.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676562","sourceStatusCode":200,"destWidth":800,"destHeight":613,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn71@2020_5/2020/08/24/23-08-44-474_56f279fc9b89be8a.webp","sourceBytes":38048,"destBytes":29160,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2324,"convertSpendMs":33,"createdTime":"2020-08-25 07:08:42","host":"us-022*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"37.2 KB","destSize":"28.5 KB","compressRate":"76.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLrbr","sourceStatusCode":200,"destWidth":407,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn14@2020_6/2020/08/24/23-08-44-242_8fce31e013f973d0.webp","sourceBytes":178422,"destBytes":16734,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3643,"convertSpendMs":17,"createdTime":"2020-08-25 07:08:41","host":"europe-58*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"174.2 KB","destSize":"16.3 KB","compressRate":"9.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676559","sourceStatusCode":200,"destWidth":800,"destHeight":497,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn83@2020_4/2020/08/24/23-08-44-531_3579403f639c7f72.webp","sourceBytes":191632,"destBytes":53100,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2356,"convertSpendMs":48,"createdTime":"2020-08-25 07:08:43","host":"us-004*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"187.1 KB","destSize":"51.9 KB","compressRate":"27.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676565","sourceStatusCode":200,"destWidth":800,"destHeight":467,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn79@2020_6/2020/08/24/23-08-44-563_3b2757439dfe26eb.webp","sourceBytes":253568,"destBytes":80948,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2487,"convertSpendMs":44,"createdTime":"2020-08-25 07:08:43","host":"us-010*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"247.6 KB","destSize":"79.1 KB","compressRate":"31.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023676561","sourceStatusCode":200,"destWidth":700,"destHeight":362,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn76@2020_4/2020/08/24/23-08-44-872_34e1f70a34f32d2c.webp","sourceBytes":53038,"destBytes":18160,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2208,"convertSpendMs":22,"createdTime":"2020-08-25 07:08:43","host":"us-016*","referer":"https://segmentfault.com/a/1190000023676547","linkMd5ListStr":"c737187f4a9de041a952fc2de76447f5","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"51.8 KB","destSize":"17.7 KB","compressRate":"34.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023622137","sourceStatusCode":200,"destWidth":800,"destHeight":771,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn100@2020_3/2020/08/24/23-08-45-005_b456f90a4d7dc104.webp","sourceBytes":68277,"destBytes":59176,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2460,"convertSpendMs":27,"createdTime":"2020-08-25 07:08:43","host":"us-51*","referer":"https://segmentfault.com/a/1190000023622134","linkMd5ListStr":"feb087fef9d4181f56dd8589fa8fcc79","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"66.7 KB","destSize":"57.8 KB","compressRate":"86.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLveu","sourceStatusCode":200,"destWidth":800,"destHeight":533,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn4@2020_2/2020/08/24/23-08-45-148_de46592035a11e50.webp","sourceBytes":603023,"destBytes":38592,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2471,"convertSpendMs":38,"createdTime":"2020-08-25 07:08:43","host":"us-034*","referer":"https://segmentfault.com/a/1190000023675512","linkMd5ListStr":"8130037c23e0c993c51e97490b17f7b6","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"588.9 KB","destSize":"37.7 KB","compressRate":"6.4%"},{"code":1,"isDone":false,"source":"https://tva1.sinaimg.cn/large/007S8ZIlly1ghu978x2kog3064064tg4.gif","sourceStatusCode":200,"destWidth":220,"destHeight":220,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn12@2020_2/2020/08/24/23-08-45-134_20348afea74325a7.webp","sourceBytes":283528,"destBytes":64618,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2257,"convertSpendMs":113,"createdTime":"2020-08-25 07:08:43","host":"us-020*","referer":"https://segmentfault.com/a/1190000023668057","linkMd5ListStr":"dcb1ca1d6d9e74559b1305ed3b0d3469","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"276.9 KB","destSize":"63.1 KB","compressRate":"22.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023604340","sourceStatusCode":200,"destWidth":720,"destHeight":363,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn95@2020_3/2020/08/24/23-08-44-556_9e65854396b9e3eb.webp","sourceBytes":27874,"destBytes":20478,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3200,"convertSpendMs":10,"createdTime":"2020-08-25 07:08:42","host":"us-022*","referer":"https://segmentfault.com/a/1190000023604337","linkMd5ListStr":"7fbcd44c2485b915a169b959a08502eb","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"27.2 KB","destSize":"20 KB","compressRate":"73.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLq6p","sourceStatusCode":200,"destWidth":440,"destHeight":440,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn20@2020_5/2020/08/24/23-08-45-396_546149266b4954c9.webp","sourceBytes":94488,"destBytes":16716,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2287,"convertSpendMs":13,"createdTime":"2020-08-25 07:08:43","host":"us-008*","referer":"https://segmentfault.com/a/1190000023660020","linkMd5ListStr":"6a526c91c6f56ccea5eb637c9da38dee","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"92.3 KB","destSize":"16.3 KB","compressRate":"17.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLvd2","sourceStatusCode":200,"destWidth":800,"destHeight":530,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn23@2020_3/2020/08/24/23-08-45-486_3343783897cb269e.webp","sourceBytes":434024,"destBytes":22550,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2383,"convertSpendMs":35,"createdTime":"2020-08-25 07:08:43","host":"us-002*","referer":"https://segmentfault.com/a/1190000023675512","linkMd5ListStr":"8130037c23e0c993c51e97490b17f7b6","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"423.9 KB","destSize":"22 KB","compressRate":"5.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLvde","sourceStatusCode":200,"destWidth":800,"destHeight":533,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn67@2020_4/2020/08/24/23-08-45-893_2b9c9b5a1aa9ddf4.webp","sourceBytes":504515,"destBytes":23612,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3832,"convertSpendMs":34,"createdTime":"2020-08-25 07:08:42","host":"us-029*","referer":"https://segmentfault.com/a/1190000023675512","linkMd5ListStr":"8130037c23e0c993c51e97490b17f7b6","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"492.7 KB","destSize":"23.1 KB","compressRate":"4.7%"}],"successGithubMap":{"myreaderx14":9,"myreaderx8":9,"myreaderx7":11,"myreaderx15":9,"myreaderx16":9,"myreaderx6":10,"myreaderx10":10,"myreaderx4":10,"myreaderx32":9,"myreaderx3":11,"myreaderx33":10,"myreaderx11":10,"myreaderx12":11,"myreaderx2":9,"myreaderx1":9,"myreaderx13":9,"myreaderx30":10,"myreaderx31":11,"myreaderx18":10,"myreaderx19":11,"myreaderx":10,"myreaderx25":10,"myreaderx27":10,"myreaderx21":10,"myreaderx22":9,"myreaderx23":10,"myreaderx24":10,"myreaderx5oss":9,"myreaderx29":8},"failGithubMap":{}}