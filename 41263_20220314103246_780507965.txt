{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2022-03-14 18:32:46","updatedTime":"2022-03-14 18:32:46","title":"Users and Passwords","link":"http://www.therailsway.com/2009/8/3/users-and-passwords","description":"\n            <p>Last week I lost several productive hours resetting my ‘insecure’ password on several websites due to <a href=\"http://perlmonks.org/?node_id=784737\">a security breach at a website I haven’t used in more than a decade</a>, if you’ve ever used that site, you’d be well advised to change your password pretty much everywhere.  In order to prevent this happening in the future, I figured I’d write up a simple best practices article on handling passwords and authentication.  There’s nothing particularly new here, but it’s always worthwhile revisiting the basics.</p>\n\n\n\t<h2>What Not to do?</h2>\n\n\n\t<p><em>Never</em> store your users’ cleartext passwords in your database, no exceptions.  The most important reasons is that if your site is compromised or <a href=\"http://www.reddit.com/comments/usqe/reddits_streak_of_bad_luck_continues/cuugl\">your backup drive lost</a> all your users will be in danger.  The attacker will have access to a ready-made list of passwords and the related email addresses which they’ll be able to go off and cause havoc with other websites.  The second risk is that any one of your staff members could steal that information and use it to attempt to access other systems where your users have used the same password.</p>\n\n\n\t<p>While it’d be nice if users never reused a password, the reality is that nearly everyone does it.  We need to be responsible and realistic, and take the necessary precautions to protect our users.</p>\n\n\n\t<p>Instead what you should be storing is a <a href=\"http://en.wikipedia.org/wiki/Cryptographic_hash_function\">hash</a> of the user’s passwords.  This will let you verify that the password provided matches the one on file, but will never let you recover that password.</p>\n\n\n\t<h2>Salting</h2>\n\n\n\t<p>But just storing a hash of the passwords isn’t enough, this would still leave you open to <a href=\"http://en.wikipedia.org/wiki/Rainbow_table\">rainbow attacks</a> where an attacker pre-calculates hashes of millions of passwords, then compares the hashes with the values they’ve stolen from your database.  To prevent this you need to <a href=\"http://en.wikipedia.org/wiki/Salt_%28cryptography%29\">salt</a> them.  This means storing a small random value against each of your users and adding that to the password before you hash it.</p>\n\n\n\t<h2>Putting it Together.</h2>\n\n\n\t<p>So this leaves us with a user model with two relevant columns, <ins>salt</ins> and <ins>hashed_password</ins>, leaving us with a simple migration like:</p>\n\n\n<table class=\"CodeRay\"><tr>\n  <td title=\"click to toggle\" class=\"line_numbers\"><pre>1<tt>\n</tt>2<tt>\n</tt>3<tt>\n</tt>4<tt>\n</tt><strong>5</strong><tt>\n</tt></pre></td>\n  <td class=\"code\"><pre>  create_table <span class=\"sy\">:users</span> <span class=\"r\">do</span> |t|<tt>\n</tt>    t.string <span class=\"sy\">:email</span><tt>\n</tt>    t.string <span class=\"sy\">:hashed_password</span><tt>\n</tt>    t.string <span class=\"sy\">:salt</span><tt>\n</tt>  <span class=\"r\">end</span></pre></td>\n</tr></table>\n\n\n\t<p>We’ll also need two kinds of method on the model itself,  hashing methods and verification methods.  We’ll cover the hashing methods first:</p>\n\n\n<table class=\"CodeRay\"><tr>\n  <td title=\"click to toggle\" class=\"line_numbers\"><pre>1<tt>\n</tt>2<tt>\n</tt>3<tt>\n</tt>4<tt>\n</tt><strong>5</strong><tt>\n</tt>6<tt>\n</tt>7<tt>\n</tt>8<tt>\n</tt>9<tt>\n</tt><strong>10</strong><tt>\n</tt>11<tt>\n</tt>12<tt>\n</tt>13<tt>\n</tt>14<tt>\n</tt><strong>15</strong><tt>\n</tt>16<tt>\n</tt>17<tt>\n</tt>18<tt>\n</tt>19<tt>\n</tt><strong>20</strong><tt>\n</tt>21<tt>\n</tt>22<tt>\n</tt>23<tt>\n</tt>24<tt>\n</tt><strong>25</strong><tt>\n</tt>26<tt>\n</tt>27<tt>\n</tt>28<tt>\n</tt>29<tt>\n</tt><strong>30</strong><tt>\n</tt></pre></td>\n  <td class=\"code\"><pre>  require <span class=\"s\"><span class=\"dl\">'</span><span class=\"k\">digest/sha2</span><span class=\"dl\">'</span></span><tt>\n</tt><tt>\n</tt>  <span class=\"r\">class</span> <span class=\"cl\">User</span> &lt; <span class=\"co\">ActiveRecord</span>::<span class=\"co\">Base</span><tt>\n</tt>    <span class=\"c\"># Create two virtual (in memory only) attributes to hold the password and its confirmation.</span><tt>\n</tt>    attr_accessor <span class=\"sy\">:new_password</span>, <span class=\"sy\">:new_password_confirmation</span><tt>\n</tt>    <span class=\"c\"># We need to validate that the user has typed the same password twice</span><tt>\n</tt>    <span class=\"c\"># but we only want to do the validation if they've opted to change their password.</span><tt>\n</tt>    validates_confirmation_of <span class=\"sy\">:new_password</span>, <span class=\"sy\">:if</span>=&gt;<span class=\"sy\">:password_changed?</span><tt>\n</tt>    <tt>\n</tt>    before_save <span class=\"sy\">:hash_new_password</span>, <span class=\"sy\">:if</span>=&gt;<span class=\"sy\">:password_changed?</span><tt>\n</tt>    <tt>\n</tt>    <span class=\"c\"># By default the form_helpers will set new_password to &quot;&quot;,</span><tt>\n</tt>    <span class=\"c\"># we don't want to go saving this as a password</span><tt>\n</tt>    <span class=\"r\">def</span> <span class=\"fu\">password_changed?</span><tt>\n</tt>      !<span class=\"iv\">@new_password</span>.blank?<tt>\n</tt>    <span class=\"r\">end</span><tt>\n</tt>    <tt>\n</tt>    private<tt>\n</tt>    <span class=\"c\"># This is where the real work is done</span><tt>\n</tt>    <span class=\"r\">def</span> <span class=\"fu\">hash_new_password</span><tt>\n</tt>      <span class=\"c\"># First reset the salt to a new random string.  You could choose a</span><tt>\n</tt>      <span class=\"c\"># longer string here but for a salt, 8 bytes of randomness is probably</span><tt>\n</tt>      <span class=\"c\"># fine.  Note this uses SecureRandom which will use your platform's secure</span><tt>\n</tt>      <span class=\"c\"># random number generator.</span><tt>\n</tt>      <span class=\"pc\">self</span>.salt = <span class=\"co\">ActiveSupport</span>::<span class=\"co\">SecureRandom</span>.base64(<span class=\"i\">8</span>)<tt>\n</tt>      <span class=\"c\"># Now calculate the hash of the password, with the salt prepended, store</span><tt>\n</tt>      <span class=\"c\"># store that in the database</span><tt>\n</tt>      <span class=\"pc\">self</span>.hashed_password = <span class=\"co\">Digest</span>::<span class=\"co\">SHA2</span>.hexdigest(<span class=\"pc\">self</span>.salt + <span class=\"iv\">@new_password</span>)<tt>\n</tt>    <span class=\"r\">end</span><tt>\n</tt>  <span class=\"r\">end</span></pre></td>\n</tr></table>\n\n\n\t<p>Of note here is the salt, it’s set to a new random value every time the user changes his password, this will come in handy another day.  The next method we need to implement is the authentication method.</p>\n\n\n<table class=\"CodeRay\"><tr>\n  <td title=\"click to toggle\" class=\"line_numbers\"><pre>1<tt>\n</tt>2<tt>\n</tt>3<tt>\n</tt>4<tt>\n</tt><strong>5</strong><tt>\n</tt>6<tt>\n</tt>7<tt>\n</tt>8<tt>\n</tt>9<tt>\n</tt><strong>10</strong><tt>\n</tt>11<tt>\n</tt>12<tt>\n</tt>13<tt>\n</tt>14<tt>\n</tt><strong>15</strong><tt>\n</tt>16<tt>\n</tt>17<tt>\n</tt>18<tt>\n</tt></pre></td>\n  <td class=\"code\"><pre>  <span class=\"r\">class</span> <span class=\"cl\">User</span> &lt; <span class=\"co\">ActiveRecord</span>::<span class=\"co\">Base</span><tt>\n</tt>    <span class=\"c\"># As is the 'standard' with rails apps we'll return the user record if the</span><tt>\n</tt>    <span class=\"c\"># password is correct and nil if it isn't.</span><tt>\n</tt>    <span class=\"r\">def</span> <span class=\"pc\">self</span>.authenticate(email, password)<tt>\n</tt>      <span class=\"c\"># Because we salt the passwords we can't do this query in one part, first</span><tt>\n</tt>      <span class=\"c\"># we need to fetch the potential user</span><tt>\n</tt>      <span class=\"r\">if</span> user = find_by_email(email)<tt>\n</tt>        <span class=\"c\"># Then compare the provided password against the hashed one in the db.</span><tt>\n</tt>        <span class=\"r\">if</span> user.hashed_password == <span class=\"co\">Digest</span>::<span class=\"co\">SHA2</span>.hexdigest(user.salt + password)<tt>\n</tt>          <span class=\"c\"># If they match we return the user </span><tt>\n</tt>          <span class=\"r\">return</span> user<tt>\n</tt>        <span class=\"r\">end</span><tt>\n</tt>      <span class=\"r\">end</span><tt>\n</tt>      <span class=\"c\"># If we get here it means either there's no user with that email, or the wrong</span><tt>\n</tt>      <span class=\"c\"># password was provided.  But we don't want to let an attacker know which. </span><tt>\n</tt>      <span class=\"r\">return</span> <span class=\"pc\">nil</span><tt>\n</tt>    <span class=\"r\">end</span><tt>\n</tt>  <span class=\"r\">end</span></pre></td>\n</tr></table>\n\n\n\t<h2>Cleanse the Logs</h2>\n\n\n\t<p>Finally, you need to make sure that your user’s passwords don’t get logged either, thankfully this is built right in with rails.</p>\n\n\n<table class=\"CodeRay\"><tr>\n  <td title=\"click to toggle\" class=\"line_numbers\"><pre>1<tt>\n</tt>2<tt>\n</tt>3<tt>\n</tt></pre></td>\n  <td class=\"code\"><pre>  <span class=\"r\">class</span> <span class=\"cl\">ApplicationController</span> &lt; <span class=\"co\">ActionController</span>::<span class=\"co\">Base</span><tt>\n</tt>    filter_parameter_logging <span class=\"sy\">:password</span><tt>\n</tt>  <span class=\"r\">end</span></pre></td>\n</tr></table>\n\n\n\t<h2>Wrap Up</h2>\n\n\n\t<p>All in all using secure password hashing takes around 15 lines of code so there’s no excuse for not doing it in your applications.  It’s also relatively simple so I wouldn’t suggest using a plugin if <strong>all</strong> you want is simple secure login code, those plugins come with tonnes of additional features which you may not want.  I’ll follow up next week with simple secure remember-me tokens which also don’t require anything fancy.</p>\n\n\n\t<p>Finally a product plug, <a href=\"http://agilewebsolutions.com/products/1Password\">1Password from AgileWebSolutions</a> is a really useful tool for generating, storing and recalling secure passwords for the myriad of websites which require logins.  It’s much simpler and more secure than re-using some ‘insecure’ password on dozens of websites.  It also has the side benefit of being pretty-well immune to phishing attacks.</p>\n          ","descriptionType":"html","publishedDate":"Mon, 03 Aug 2009 03:53:00 +0000","feedId":41263,"bgimg":"","linkMd5":"ff9151b21600289cf6b42a68f2a7c0f8","bgimgJsdelivr":"","metaImg":"","author":"Koz","publishedOrCreatedDate":1647253966471}],"record":{"createdTime":"2022-03-14 18:32:46","updatedTime":"2022-03-14 18:32:46","feedId":41263,"fetchDate":"Mon, 14 Mar 2022 10:32:46 +0000","fetchMs":10145,"handleMs":180244,"totalMs":190395,"newArticles":0,"totalArticles":15,"status":1,"type":0,"ip":"f306b40366a93aa712f78b685bea0f01","hostName":"us-014*","requestId":"c764bdae318c4cc5959a450888e43c71_41263","contentType":"text/xml; charset=UTF-8","totalBytes":0,"bgimgsTotal":0,"bgimgsGithubTotal":0,"articlesImgsTotal":0,"articlesImgsGithubTotal":0,"successGithubMap":{},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 03:23:30","updatedTime":"2020-09-07 05:43:13","id":41263,"name":"The Rails Way - Home","url":"http://feeds.feedburner.com/TheRailsWay","subscriber":78,"website":null,"icon":"http://www.therailsway.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"http://www.therailsway.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1647253776077,"total":0,"statList":[{"spend":10150,"msg":"获取xml内容"},{"spend":180244,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":0,"msg":"正文链接上传到cdn"}]},"extra5":0,"extra6":0,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{},"extra12ImgCdnSuccessResultVector":[],"successGithubMap":{},"failGithubMap":{}}