{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-08-16 19:57:47","updatedTime":"2020-08-16 19:57:47","title":"Dubbo 协议解析与 ESA RPC 实践","link":"https://toutiao.io/k/gsdn4sv","description":"<div><div><div class=\"rich_media_content \" id=\"js_content\">\n                    \n\n                    \n\n                    \n                    \n                    <section mpa-from-tpl=\"t\" data-mpa-powered-by=\"yiban.io\"><section mpa-from-tpl=\"t\"><section mpa-from-tpl=\"t\"><p><span>点击关注“OPPO互联网技术”，阅读更多技术干货</span></p></section></section></section><h2 cid=\"n3\" mdtype=\"heading\"><span>1. 背景</span></h2><p cid=\"n219\" mdtype=\"paragraph\"><span>Dubbo是一款高性能、轻量级的开源Java RPC框架，诞生于2012年，2015年停止研发，后来重启并发布了2.7及连续多个版本。Dubbo自开源以来，许多大公司都以此为微服务架构基石，甚至在官方停止维护的几年中，热度依然不减。</span></p><p cid=\"n220\" mdtype=\"paragraph\"><span>但最近几年云原生技术开始成为主流，与Dubbo框架的核心设计理念有不相容之处，再加上公司安全治理的需求，OPPO互联网技术团队开发了面向云原生、 Mesh友好的ESA RPC框架。</span></p><h2 cid=\"n6\" mdtype=\"heading\"><span>2.Dubbo协议解析</span></h2><p cid=\"n7\" mdtype=\"paragraph\"><span>协议是两个网络实体进行通信的基础，数据在网络上从一个实体传输到另一个实体，以字节流的形式传递到对端。Dubbo协议由服务提供者与消费者双端约定，需要确定的是一次有意义的传输内容在读到何时结束，因为一个一个byte传输过来，需要有一个结束。而且数据在网络上的传输，存在粘包和半包的情况，能够应对这个问题的办法就是协议能够准确的识别，当粘包发生时不会多读，当半包发生时会继续读取。</span></p><h3 cid=\"n8\" mdtype=\"heading\"><span>2.1 Dubbo Header内容</span></h3><p cid=\"n9\" mdtype=\"paragraph\"><span>Dubbo header的长度总共16字节，128位，如下图所示：</span></p><p><img class=\"rich_pages\" data-ratio=\"0.2426470588235294\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxhZLelp68ImiaU7H75PosfL9jWuRRujS8vp2ibpFxEGVXQrWyRGJT5Sel1Xr2ibJdSAxobujQK7PJdjg/640?wx_fmt=png\" data-type=\"png\" data-w=\"1496\"/></p><ul class=\"list-paddingleft-2\" cid=\"n11\" mdtype=\"list\" data-mark=\"-\"><li><p cid=\"n13\" mdtype=\"paragraph\"><span>Magic(16 bits) : 协议魔数，标识Dubbo 数据包。</span></p></li><li><p cid=\"n15\" mdtype=\"paragraph\"><span>Req/Res(1 bit) : 标识请求或者相应。请求：1，相应：0。</span></p></li><li><p cid=\"n17\" mdtype=\"paragraph\"><span>Two Way(1 bit) : 仅在 Req/Res 为1（请求）时才有用，标记是否期望从服务器返回值。如果需要来自服务器的返回值，则设置为1。</span></p></li><li><p cid=\"n19\" mdtype=\"paragraph\"><span>Event(1 bit) : 标识是否是事件消息，例如，心跳事件。如果这是一个事件，则设置为1。</span></p></li><li><p cid=\"n21\" mdtype=\"paragraph\"><span>SerializationId(5 bits) : 序列化id。</span></p></li><li><p cid=\"n23\" mdtype=\"paragraph\"><span>Status(8 bits) : 仅在 Req/Res 为0（响应）时有用，用于标识响应的状态。</span></p></li><li><p cid=\"n25\" mdtype=\"paragraph\"><span>RequstId(64 bits) : 标识唯一请求。类型为long。</span></p></li><li><p cid=\"n27\" mdtype=\"paragraph\"><span>Data length(32 bits) : 序列化后的内容长度(变长部分，即不包含header)，按字节计数。通过payload参数指定，默认为8M。</span></p></li></ul><h3 cid=\"n28\" mdtype=\"heading\"><span>2.2 Dubbo body内容</span></h3><p cid=\"n29\" mdtype=\"paragraph\"><span>Dubbo 数据包的body 部分内容，分为请求包与响应包。</span></p><p cid=\"n30\" mdtype=\"paragraph\"><span>如果是请求包，则包含的部分有：</span></p><ul class=\"list-paddingleft-2\" cid=\"n31\" mdtype=\"list\" data-mark=\"-\"><li><p cid=\"n33\" mdtype=\"paragraph\"><span>dubbo协议版本号（2.0.2）；</span></p></li><li><p cid=\"n35\" mdtype=\"paragraph\"><span>接口名；</span></p></li><li><p cid=\"n37\" mdtype=\"paragraph\"><span>接口版本号；</span></p></li><li><p cid=\"n39\" mdtype=\"paragraph\"><span>方法名；</span></p></li><li><p cid=\"n41\" mdtype=\"paragraph\"><span>方法参数类型；</span></p></li><li><p cid=\"n43\" mdtype=\"paragraph\"><span>方法参数；</span></p></li><li><p cid=\"n45\" mdtype=\"paragraph\"><span>附件（Attachment）：</span></p></li><ul class=\"list-paddingleft-2\" cid=\"n46\" mdtype=\"list\" data-mark=\"-\"><li><p cid=\"n48\" mdtype=\"paragraph\"><span>接口分组（group）；</span></p></li><li><p cid=\"n50\" mdtype=\"paragraph\"><span>接口版本号（version)；</span></p></li><li><p cid=\"n52\" mdtype=\"paragraph\"><span>接口名；</span></p></li><li><p cid=\"n54\" mdtype=\"paragraph\"><span>自定义附件参数;</span></p></li></ul></ul><p cid=\"n55\" mdtype=\"paragraph\"><span>如果是响应包，则包含的内容有：</span></p><p cid=\"n68\" mdtype=\"paragraph\"><span>通过对dubbo协议的解析，我们可以知道，dubbo协议是一个Header定长的变长协议。这也在我们ESA RPC实践过程中提供了一些思路。</span></p><h3 cid=\"n69\" mdtype=\"heading\"><span>2.3 Dubbo协议优缺点</span></h3><h3 cid=\"n70\" mdtype=\"heading\"><span>2.3.1 优点</span></h3><p cid=\"n71\" mdtype=\"paragraph\"><span>Dubbo协议的设计非常紧凑、简单，尽可能的减少传输包大小，能用一个bit表示的字段，不会用一个byte。</span></p><h3 cid=\"n72\" mdtype=\"heading\"><span>2.3.2 不足</span></h3><ul class=\"list-paddingleft-2\" cid=\"n73\" mdtype=\"list\" data-mark=\"-\"><li><p cid=\"n75\" mdtype=\"paragraph\"><span>请求body中某些字段重复传递（如接口名，接口版本号），即body内容与附件attachment 中存在重复字段，增大传输数据包大小；</span></p></li><li><p cid=\"n77\" mdtype=\"paragraph\"><span>对于ServiceMesh 场景很不友好。在ServiceMesh 场景中，会将原sdk中的大部分功能迁移至SideCar 中实现，这里以服务发现为例。Dubbo 中的服务发现，是通过接口名（interfaceName）、接口分组（group）、接口版本号（version）三者定位一个唯一服务，也是服务发现的关键要素，但是我们从dubbo body内容可知，必须要将完整的数据包全部解析（attachment位于body末），才能获取到这三个要素，这是完全没必要的。</span></p></li><li><p cid=\"n79\" mdtype=\"paragraph\"><span>没有预留字段，扩展性不足。</span></p></li></ul><h2 cid=\"n80\" mdtype=\"heading\"><span>3. Dubbo的现状</span></h2><p cid=\"n81\" mdtype=\"paragraph\"><span>Dubbo自开源以来，在业内造成了巨大的影响，许多公司甚至大厂都以此为微服务架构基石，甚至在Dubbo官方停止维护的几年中，热度依然不减，足以证明其本身的优秀。</span></p><p cid=\"n222\" mdtype=\"paragraph\"><span>在这过程中，Dubbo协议的内容一直没有太大变化，主要是为了兼容性考虑，但其他内容，随着Dubbo的发展变化却是很大。这里我们主要聊一聊dubbo从2.7.0版本以后的情况。</span></p><h3 cid=\"n83\" mdtype=\"heading\"><span>3.1 Dubbo 2.7.x版本总览</span></h3><p><img class=\"rich_pages\" data-ratio=\"0.7712871287128713\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxhZLelp68ImiaU7H75PosfL97uAhTWJnm1RrTsgSbN7ZRJLRjlKJEyEmREm5fIx5rJcva1VSErPmjw/640?wx_fmt=png\" data-type=\"png\" data-w=\"1010\"/></p><p cid=\"n85\" mdtype=\"paragraph\"><span>这是dubbo自2.7.0版本以来，各个版本的简要功能说明，以及升级建议。可以看到dubbo官方推荐生产使用的只有2.7.3 和2.7.4.1两个版本。但这两个推荐版本，也有不能满足需求的地方。</span></p><p cid=\"n86\" mdtype=\"paragraph\"><span>由于dubbo在2.7.3 和2.7.4.1 这两个版本中改动巨大，使得这两个版本无法向下兼容，这让基于其他版本做的一些dubbo扩展几乎无法使用。升级dubbo的同时，还需要将以前的扩展全部检查修改一遍，这带来很大工作量。而且除了我们自身团队的一些公共扩展外，全公司其他业务团队很可能还有自己的一些扩展，这无疑增大了我们升级dubbo的成本。</span></p><h2 cid=\"n88\" mdtype=\"heading\"><span>4. ESA RPC最佳实践</span></h2><p cid=\"n89\" mdtype=\"paragraph\"><span>最近几年云原生技术开始成为主流，与Dubbo框架的核心设计理念也有不相容之处，再加上公司安全治理的需求，我们需要一款面向云原生、 Mesh友好的RPC框架。</span></p><p cid=\"n90\" mdtype=\"paragraph\"><span>在这个背景下，OPPO互联网技术团队从2019年下半年开始动手设计开发ESA RPC，到2020年一季度，ESA RPC 第一版成功发布。下面我们简单介绍下ESA RPC的一些主要功能。</span></p><h3 cid=\"n91\" mdtype=\"heading\"><span>4.1 实例级服务注册与发现</span></h3><p cid=\"n92\" mdtype=\"paragraph\"><span>ESA RPC通过深度整合发布平台，实现实例级服务注册与发现，如图所示：</span></p><p><img class=\"rich_pages\" data-ratio=\"0.5875\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxhZLelp68ImiaU7H75PosfL9UDhqmrnmsFXzP6pF74D61JbvLyVuwtTxB6hG7dmviaHETtuswOWSatw/640?wx_fmt=png\" data-type=\"png\" data-w=\"1360\"/></p><p cid=\"n94\" mdtype=\"paragraph\"><span>应用发布时，相应的发布平台会将实例信息注册到OPPO自研的注册中心ESA Registry（应用本身则不再进行注册），注册信息包含应用名、ip、端口、实例编号等等，消费者启动时只需通过应用编号订阅相关提供者即可。</span></p><p cid=\"n95\" mdtype=\"paragraph\"><span>既然服务注册部分是由发布平台完成，开发者在发布应用时，就需要填写相关信息，即相关的暴露协议以及对应的端口，这样发布平台才可以正确注册提供者信息。</span></p><p><img class=\"rich_pages\" data-ratio=\"0.30799735624586916\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxhZLelp68ImiaU7H75PosfL9OPngSLHTTGeeSS2uPCHxev9DdHvQlhAAh5AUDoA8TypEBBNUBM8Bpg/640?wx_fmt=png\" data-type=\"png\" data-w=\"1513\"/></p><h3 cid=\"n97\" mdtype=\"heading\"><span>4.2 客户端线程模型优化</span></h3><p cid=\"n98\" mdtype=\"paragraph\"><span>ESA RPC全面拥抱java8的CompletableFuture ，我们将同步和异步的请求统一处理，认为同步是特殊的异步。而Dubbo，由于历史原因，最初dubbo使用的jdk版本还是1.7，所以在客户端的线程模型中，为了不阻塞IO线程，dubbo增加了一个Cached线程池，所有的IO消息统一都通知到这个Cached线程池中，然后再切换回相应的业务线程，这样可能会造成当请求并发较高时，客户端线程暴涨问题，进而导致客户端性能低下。</span></p><p cid=\"n99\" mdtype=\"paragraph\"><span>所以我们在ESA RPC客户端优化了线程模型，将原有的dubbo客户端cached线程池取消，改为如下图模型：</span></p><p><img class=\"rich_pages\" data-ratio=\"0.6679718089271731\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxhZLelp68ImiaU7H75PosfL9cIAUIrh5WnCjKOk5fiat58xWGFISUvfBpzeLrmxvVwUVuELmxmZeibHg/640?wx_fmt=png\" data-type=\"png\" data-w=\"1277\"/></p><p cid=\"n101\" mdtype=\"paragraph\"><span>具体做法：</span></p><ul class=\"list-paddingleft-2\" cid=\"n102\" mdtype=\"list\" data-mark=\"-\"><li><p cid=\"n104\" mdtype=\"paragraph\"><span>当前业务线程发出远程调用请求后，生成CompletableFuture 对象，并传递至IO线程，等待返回；</span></p></li><li><p cid=\"n106\" mdtype=\"paragraph\"><span>IO线程收到返回内容后，找到与之对应的CompletableFuture 对象，直接赋予其返回内容；</span></p></li><li><p cid=\"n108\" mdtype=\"paragraph\"><span>业务线程通过自己生成的CompletableFuture 对象获取返回值；</span></p></li></ul><h3 cid=\"n109\" mdtype=\"heading\"><span>4.3 智能Failover</span></h3><p cid=\"n110\" mdtype=\"paragraph\"><span>对于一些高并发的服务，可能会因传统Failover 中的重试而导致服务雪崩。ESA RPC对此进行优化，采用基于请求失败率的Failover ，即当请求失败率低于相应阈值时，执行正常的failover重试策略，而当失败率超过阈值时，则停止进行重试，直到失败率低于阈值再恢复重试功能。</span></p><p><img class=\"rich_pages\" data-ratio=\"0.6482635796972396\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxhZLelp68ImiaU7H75PosfL9djgu91KdjHBPWcRHMbWfQhuYmicydpOIa2ROGwXJHlz8U8uSm05eicwQ/640?wx_fmt=png\" data-type=\"png\" data-w=\"1123\"/></p><p cid=\"n112\" mdtype=\"paragraph\"><span>ESA RPC采用RingBuffer 的数据结构记录请求状态，成功为0，失败为1。用户可通过配置的方式指定该RingBuffer 的长度，以及请求失败率阈值。</span></p><h3 cid=\"n113\" mdtype=\"heading\"><span>4.4 ServiceKeeper</span></h3><p cid=\"n114\" mdtype=\"paragraph\"><span>ESA ServiceKeeper (以下简称ServiceKeeper )，属于OPPO自研的基础框架技术栈ESA Stack系列的一员。ServiceKeeper 是一款轻量级的服务治理框架，通过拦截并代理原始方法的方式织入限流、并发数限制、熔断、降级等功能。</span></p><p cid=\"n115\" mdtype=\"paragraph\"><span>ServiceKeeper 支持方法和参数级的服务治理以及动态动态更新配置等功能，包括：</span></p><ul class=\"list-paddingleft-2\" cid=\"n116\" mdtype=\"list\" data-mark=\"-\"><li><p cid=\"n118\" mdtype=\"paragraph\"><span>方法隔离</span></p></li><li><p cid=\"n120\" mdtype=\"paragraph\"><span>方法限流</span></p></li><li><p cid=\"n122\" mdtype=\"paragraph\"><span>方法熔断</span></p></li><li><p cid=\"n124\" mdtype=\"paragraph\"><span>方法降级</span></p></li><li><p cid=\"n126\" mdtype=\"paragraph\"><span>参数级隔离、限流、熔断</span></p></li><li><p cid=\"n128\" mdtype=\"paragraph\"><span>方法重试</span></p></li><li><p cid=\"n130\" mdtype=\"paragraph\"><span>接口分组</span></p></li><li><p cid=\"n132\" mdtype=\"paragraph\"><span>动态更新配置，实时生效</span></p></li></ul><p cid=\"n133\" mdtype=\"paragraph\"><span>ESA RPC中默认使用ServiceKeeper 来实现相关服务治理内容，使用起来也相对简单。</span></p><h4 cid=\"n134\" mdtype=\"heading\"><span>Step 1</span></h4><p cid=\"n135\" mdtype=\"paragraph\"><span>application.properties 文件中开启ServiceKeeper 功能。</span></p><section class=\"code-snippet__fix code-snippet__js\"><pre class=\"code-snippet__js\" data-lang=\"bash\"><code><span class=\"code-snippet_outer\"/></code><code><span class=\"code-snippet_outer\">esa.rpc.provider.parameter.enable-service-keeper=<span class=\"code-snippet__literal\">true</span></span></code><code><span class=\"code-snippet_outer\"><br/></span></code><code><span class=\"code-snippet_outer\"/></code><code><span class=\"code-snippet_outer\">esa.rpc.consumer.parameter.enable-service-keeper=<span class=\"code-snippet__literal\">true</span></span></code></pre></section><p cid=\"n135\" mdtype=\"paragraph\"><strong><span>Step 2</span></strong></p><p cid=\"n135\" mdtype=\"paragraph\"><span/></p><p cid=\"n138\" mdtype=\"paragraph\"><span>新增service-keeper.properties 配置文件，并按照如下规则进行配置：</span></p><section class=\"code-snippet__fix code-snippet__js\"><pre class=\"code-snippet__js\" data-lang=\"bash\"><code><span class=\"code-snippet_outer\"/></code><code><span class=\"code-snippet_outer\">com.oppo.dubbo.demo.DemoService/0.0.1/group1.maxConcurrentLimit=20</span></code><code><span class=\"code-snippet_outer\">com.oppo.dubbo.demo.DemoService/0.0.1/group1.failureRateThreshold=55.5</span></code><code><span class=\"code-snippet_outer\">com.oppo.dubbo.demo.DemoService/0.0.1/group1.forcedOpen=55.5</span></code><code><span class=\"code-snippet_outer\">...</span></code><code><span class=\"code-snippet_outer\"><br/></span></code><code><span class=\"code-snippet_outer\"/></code><code><span class=\"code-snippet_outer\">com.oppo.dubbo.demo.DemoService/0.0.1/group1.sayHello.maxConcurrentLimit=20</span></code><code><span class=\"code-snippet_outer\">com.oppo.dubbo.demo.DemoService/0.0.1/group1.sayHello.maxConcurrentLimit=20</span></code><code><span class=\"code-snippet_outer\">com.oppo.dubbo.demo.DemoService/0.0.1/group1.sayHello.failureRateThreshold=55.5</span></code><code><span class=\"code-snippet_outer\">com.oppo.dubbo.demo.DemoService/0.0.1/group1.sayHello.forcedOpen=<span class=\"code-snippet__literal\">false</span></span></code><code><span class=\"code-snippet_outer\">com.oppo.dubbo.demo.DemoService/0.0.1/group1.sayHello.limitForPeriod=600</span></code><code><span class=\"code-snippet_outer\">...</span></code><code><span class=\"code-snippet_outer\"><br/></span></code><code><span class=\"code-snippet_outer\"/></code><code><span class=\"code-snippet_outer\">com.oppo.dubbo.demo.DemoService/0.0.1/group1.sayHello.arg0.limitForPeriod={LiSi:20,ZhangSan:50}</span></code><code><span class=\"code-snippet_outer\">...</span></code></pre></section><p cid=\"n138\" mdtype=\"paragraph\"><span>4.5 连接管理</span></p><p cid=\"n142\" mdtype=\"paragraph\"><span>ESA RPC中，一个消费者与一个提供者，默认只会创建一个连接，但是允许用户通过配置创建多个，配置项为connections (与dubbo保持一致)。ESA RPC的连接池通过公司内部一个全异步对象池管理库commons pool来达到对连接的管理，其中连接的创建、销毁等操作均为异步执行，避免阻塞线程，提升框架整体性能。</span></p><p cid=\"n143\" mdtype=\"paragraph\"><span>需要注意的是，这里的建连过程，有一个并发问题要解决：当客户端在高并发的调用建连方法时，如何保证建立的连接刚好是所设定的个数呢？为了配合 Netty 的无锁理念，我们也采用一个无锁化的建连过程来实现，利用 ConcurrentHashMap 的putIfAbsent 方法：</span></p><section class=\"code-snippet__fix code-snippet__js\"><pre class=\"code-snippet__js\" data-lang=\"kotlin\"><code><span class=\"code-snippet_outer\">AcquireTask acquireTask = <span class=\"code-snippet__keyword\">this</span>.pool.<span class=\"code-snippet__keyword\">get</span>(idx);</span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__keyword\">if</span> (acquireTask == <span class=\"code-snippet__literal\">null</span>) {</span></code><code><span class=\"code-snippet_outer\">  acquireTask = new AcquireTask();</span></code><code><span class=\"code-snippet_outer\">  AcquireTask tmpTask = <span class=\"code-snippet__keyword\">this</span>.pool.putIfAbsent(idx, acquireTask);</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">if</span> (tmpTask == <span class=\"code-snippet__literal\">null</span>) {</span></code><code><span class=\"code-snippet_outer\">    acquireTask.create(); </span></code><code><span class=\"code-snippet_outer\">  }</span></code><code><span class=\"code-snippet_outer\">}</span></code></pre></section><p cid=\"n143\" mdtype=\"paragraph\"><strong><span>4.6 gRPC协议支持</span></strong><br/><span/></p><p cid=\"n146\" mdtype=\"paragraph\"><span>由于ESA RPC默认使用ESA Regsitry 作为注册中心，由上述实例注册部分可知，服务注册通过发布平台来完成，所以ESA RPC对于gRPC协议的支持具有天然的优势，即服务的提供者可以不接入任何sdk，甚至可以是其他非java语言，只需要通过公司发布平台发布应用后，就可以注册至注册中心，消费者也就可以进行订阅消费。</span></p><p cid=\"n147\" mdtype=\"paragraph\"><span>这里我们以消费端为例，来介绍ESA RPC客户端如何请求gRPC服务端。</span></p><p cid=\"n148\" mdtype=\"paragraph\"><span>proto文件定义：</span></p><section class=\"code-snippet__fix code-snippet__js\"><pre class=\"code-snippet__js\" data-lang=\"cs\"><code><span class=\"code-snippet_outer\">syntax = <span class=\"code-snippet__string\">\"proto3\"</span>;</span></code><code><span class=\"code-snippet_outer\"><br/></span></code><code><span class=\"code-snippet_outer\">option java_multiple_files = <span class=\"code-snippet__literal\">false</span>;</span></code><code><span class=\"code-snippet_outer\">option java_outer_classname = <span class=\"code-snippet__string\">\"HelloWorld\"</span>;</span></code><code><span class=\"code-snippet_outer\">option objc_class_prefix = <span class=\"code-snippet__string\">\"HLW\"</span>;</span></code><code><span class=\"code-snippet_outer\"><br/></span></code><code><span class=\"code-snippet_outer\">package esa.rpc.grpc.test.service;</span></code><code><span class=\"code-snippet_outer\"><br/></span></code><code><span class=\"code-snippet_outer\"/></code><code><span class=\"code-snippet_outer\">service GreeterService {</span></code><code><span class=\"code-snippet_outer\">  </span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__function\">rpc <span class=\"code-snippet__title\">sayHello</span> (<span class=\"code-snippet__params\">HelloRequest</span>) <span class=\"code-snippet__title\">returns</span> (<span class=\"code-snippet__params\">HelloReply</span>)</span> {</span></code><code><span class=\"code-snippet_outer\">  }</span></code><code><span class=\"code-snippet_outer\">}</span></code><code><span class=\"code-snippet_outer\"><br/></span></code><code><span class=\"code-snippet_outer\">service DemoService {</span></code><code><span class=\"code-snippet_outer\">  </span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__function\">rpc <span class=\"code-snippet__title\">sayHello</span> (<span class=\"code-snippet__params\">HelloRequest</span>) <span class=\"code-snippet__title\">returns</span> (<span class=\"code-snippet__params\">HelloReply</span>)</span> {</span></code><code><span class=\"code-snippet_outer\">  }</span></code><code><span class=\"code-snippet_outer\">}</span></code><code><span class=\"code-snippet_outer\"><br/></span></code><code><span class=\"code-snippet_outer\"/></code><code><span class=\"code-snippet_outer\">message HelloRequest {</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">string</span> name = <span class=\"code-snippet__number\">1</span>;</span></code><code><span class=\"code-snippet_outer\">}</span></code><code><span class=\"code-snippet_outer\"><br/></span></code><code><span class=\"code-snippet_outer\"/></code><code><span class=\"code-snippet_outer\">message HelloReply {</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">string</span> message = <span class=\"code-snippet__number\">1</span>;</span></code><code><span class=\"code-snippet_outer\">}</span></code></pre></section><p cid=\"n148\" mdtype=\"paragraph\"><span>然后maven中添加proto代码生成插件：</span><br/><span/></p><section class=\"code-snippet__fix code-snippet__js\"><pre class=\"code-snippet__js\" data-lang=\"xml\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">build</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">extensions</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">      <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">extension</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">        <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">groupId</span>&gt;</span>kr.motd.maven<span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">groupId</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">        <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">artifactId</span>&gt;</span>os-maven-plugin<span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">artifactId</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">        <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">version</span>&gt;</span>1.5.0.Final<span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">version</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">      <span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">extension</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">extensions</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">plugins</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">      <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">plugin</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">        <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">groupId</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">        <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">artifactId</span>&gt;</span>protobuf-maven-plugin<span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">artifactId</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">        <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">version</span>&gt;</span>0.5.0<span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">version</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">        <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">configuration</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\"><br/></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.11.0:exe:${os.detected.classifier}</span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">protocArtifact</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">          <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">pluginId</span>&gt;</span>grpc-java<span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">pluginId</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">          <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">pluginArtifact</span>&gt;</span>esa.rpc:protoc-gen-grpc-java:1.0.0-</span></code><code><span class=\"code-snippet_outer\">SNAPSHOT:exe:${os.detected.classifier}<span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">pluginArtifact</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">        <span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">configuration</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">        <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">executions</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">          <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">execution</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">            <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">goals</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">              <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">goal</span>&gt;</span>compile<span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">goal</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">              <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">goal</span>&gt;</span>compile-custom<span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">goal</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">            <span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">goals</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">          <span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">execution</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">        <span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">executions</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">      <span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">plugin</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">plugins</span>&gt;</span></span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__tag\">&lt;/<span class=\"code-snippet__name\">build</span>&gt;</span></span></code></pre></section><p cid=\"n148\" mdtype=\"paragraph\"><span>如上proto定义文件，通过protobuf:compile和protobuf:compile-custom则会生成如下代码：</span><br/><span/></p><p><img class=\"rich_pages\" data-ratio=\"0.8545081967213115\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxhZLelp68ImiaU7H75PosfL9bAMianq0LLFEovxibfrP7enj1v6LN1yia3RkdKRbjq08KO8pia5JghCSdA/640?wx_fmt=png\" data-type=\"png\" data-w=\"976\"/></p><p cid=\"n154\" mdtype=\"paragraph\"><span>可以看到，自动生成的代码中我们额外生成了相应的java接口。</span></p><p cid=\"n155\" mdtype=\"paragraph\"><span>在dubbo客户端我们就可以直接使用这个接口进行远程调用，使用方式：</span></p><section class=\"code-snippet__fix code-snippet__js\"><pre class=\"code-snippet__js\" data-lang=\"css\"><code><span class=\"code-snippet_outer\">@<span class=\"code-snippet__keyword\">Reference</span>(...,<span class=\"code-snippet__keyword\">protocol</span>=\"<span class=\"code-snippet__keyword\">grpc</span>\")</span></code><code><span class=\"code-snippet_outer\">private DemoService demoService;</span></code></pre></section><p cid=\"n155\" mdtype=\"paragraph\"><strong><span>4.7 ESA RPC性能</span></strong><br/><span/></p><p cid=\"n158\" mdtype=\"paragraph\"><span>这里仅举一例，展示ESA RPC性能。</span></p><p><img class=\"rich_pages\" data-ratio=\"0.42879019908116384\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxhZLelp68ImiaU7H75PosfL9qEruadrzd7TfLfjcwWTzLJN9HtC8WicTMCpJNGnTuZNnqziavLyhkmuQ/640?wx_fmt=png\" data-type=\"png\" data-w=\"1306\"/></p><p cid=\"n158\" mdtype=\"paragraph\"><img class=\"rich_pages\" data-ratio=\"0.69558599695586\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxhZLelp68ImiaU7H75PosfL9sIjNwcZz48wIoiasq4mHXZgp0zY1bic6o4N77FqtDicAbO3majDmNnVFw/640?wx_fmt=png\" data-type=\"png\" data-w=\"1314\"/></p><p><img class=\"rich_pages\" data-ratio=\"0.7046153846153846\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ECThdibSVDxhZLelp68ImiaU7H75PosfL9bg8cIdykDicrKcPT4xhrKAztY3hlDMkG5SNA6NoggGiaHlARBJ6HVd5Q/640?wx_fmt=png\" data-type=\"png\" data-w=\"1300\"/></p><h2 cid=\"n187\" mdtype=\"heading\"><span>5. ESA RPC未来规划</span><br/></h2><h3 cid=\"n188\" mdtype=\"heading\"><span>5.1 ESA RPC如何进行平滑迁移？</span></h3><p cid=\"n189\" mdtype=\"paragraph\"><span>由于历史原因，现公司内部大量使用的是Dubbo作为RPC框架，以及zookeeper注册中心，如何能够保证业务的平滑迁移，一直是我们在思考的问题。这个问题想要解答，主要分为以下两点。</span></p><h4 cid=\"n190\" mdtype=\"heading\"><span>5.1.1 代码层面</span></h4><p cid=\"n191\" mdtype=\"paragraph\"><span>在代码层面，ESA RPC考虑到这个历史原因，尽可能的兼容dubbo，尽可能降低迁移成本。但ESA RPC毕竟作为一款新的RPC框架，想要零成本零改动迁移是不可能的，但在没有dubbo扩展的情况下，改动很小。</span></p><h4 cid=\"n193\" mdtype=\"heading\"><span>5.1.2 整体架构</span></h4><p cid=\"n194\" mdtype=\"paragraph\"><span>这一点我们举例说明，当业务方迁移某一应用至ESA RPC框架时，该应用中消费ABCD四个接口，但这些接口的服务提供者应用并未升级至ESA RPC，接口元数据信息均保存至zookeeper注册中心当中，而ESA RPC推荐使用的ESA Registry注册中心中没有这些提供者信息，这就导致了消费者无法消费这些老的提供者信息。</span></p><p cid=\"n195\" mdtype=\"paragraph\"><span>针对这一问题，后续我们ESA Stack系列会提供相应的数据同步工具，将原zookeeper注册中心中的服务元数据信息同步到我们ESA Registry中，而zookeeper中的这些信息暂时不删除（以便老的接口消费者能够消费），等待均升级完成后，即可停用zookeeper注册中心。</span></p><h3 cid=\"n196\" mdtype=\"heading\"><span>5.2 自研RPC协议</span></h3><p cid=\"n197\" mdtype=\"paragraph\"><span>在上面Dubbo协议解析过程中，我们分析了Dubbo协议的优缺点，了解了Dubbo协议的不足。所以后续的版本升级过程中，自研RPC协议是一个不可忽视的内容。自研RPC协议需要充分考虑安全、性能、Mesh支持、可扩展、兼容性等因素，相信通过自研RPC协议可以使我们的ESA RPC更上一层楼。</span></p><h3 cid=\"n198\" mdtype=\"heading\"><span>5.3 其他</span></h3><p cid=\"n208\" mdtype=\"paragraph\"><span>在这篇文章中，我们主要分享了Dubbo协议的分析以及ESA RPC的实践内容，后续OPPO互联网技术团队会继续分享更多ESA RPC的动态。</span></p><p></p><p><strong mpa-from-tpl=\"t\">☆ </strong><span><strong><span>END</span></strong></span><strong mpa-from-tpl=\"t\"> ☆</strong></p><p></p><section><span><strong><span>招聘信息</span></strong></span></section><section powered-by=\"xiumi.us\"><section><section><section powered-by=\"xiumi.us\"><section><section label=\"Copyright Reserved by PLAYHUDONG.\" donone=\"shifuMouseDownCard('shifu_c_008')\"><section powered-by=\"xiumi.us\"><section><section><section powered-by=\"xiumi.us\"><section powered-by=\"xiumi.us\"><section label=\"Copyright Reserved by PLAYHUDONG.\" donone=\"shifuMouseDownCard('shifu_c_008')\"><section powered-by=\"xiumi.us\"><section><section><section powered-by=\"xiumi.us\"><section powered-by=\"xiumi.us\"><section label=\"Copyright Reserved by PLAYHUDONG.\" donone=\"shifuMouseDownCard('shifu_c_008')\"><p><span>OPPO互联网基础技术团队招聘一大波岗位，涵盖<strong>C++、Go、OpenJDK、Java、DevOps、Android、ElasticSearch</strong>等多个方向，<a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;mid=2247484254&amp;idx=2&amp;sn=bccee04adfd2c2e7d72b427c32f5891c&amp;chksm=cf4ad43bf83d5d2d0d4ced10e8b047565e8fb765ab1ea62a5fb1c4d5b77a1ac8248a9afca96f&amp;scene=21#wechat_redirect\" textvalue=\"请点击这里查看详细信息及JD\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><strong>请点击这里查看详细信息及JD</strong></a>。</span></p></section></section></section></section></section></section></section></section></section></section></section></section></section></section></section></section></section></section><p></p><section><span><strong><span>你可能还喜欢</span></strong></span></section><section powered-by=\"xiumi.us\"><section><section><section powered-by=\"xiumi.us\"><section><section label=\"Copyright Reserved by PLAYHUDONG.\" donone=\"shifuMouseDownCard('shifu_c_008')\"><section powered-by=\"xiumi.us\"><section><section><section powered-by=\"xiumi.us\"><section powered-by=\"xiumi.us\"><section label=\"Copyright Reserved by PLAYHUDONG.\" donone=\"shifuMouseDownCard('shifu_c_008')\"><section powered-by=\"xiumi.us\"><section><section><section powered-by=\"xiumi.us\"><section powered-by=\"xiumi.us\"><section label=\"Copyright Reserved by PLAYHUDONG.\" donone=\"shifuMouseDownCard('shifu_c_008')\"><p><a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;mid=2247484254&amp;idx=1&amp;sn=758ce50bf266cd560235f87ca5e5b82a&amp;chksm=cf4ad43bf83d5d2d385a3324b806efba8138ad71c93268eb958ccaa364de4ac2ad94d2b9dd79&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>OPPO自研ESA DataFlow架构与实践</span></a></p><p><a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;mid=2247484347&amp;idx=1&amp;sn=9b83ae42a6f1ffafc0fac18e8158050e&amp;chksm=cf4ad4def83d5dc86b0232151cb72f2a03506265a87a9019410d9daea8d6105b72b9a508683a&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"><span>自研代码审查系统火眼Code Review实践</span></a></p><p><a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=Mzg4MzE2MzY1OA==&amp;mid=2247484205&amp;idx=1&amp;sn=854ce615743cddac295661bf81f14589&amp;chksm=cf4ad448f83d5d5ef2a5137f20aada572d6cae111020040e3a7e117c4a6e5279906c19dd33eb&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\" hasload=\"1\">OPPO异地多活实践——缓存篇</a></p></section></section></section></section></section></section></section></section></section></section></section></section></section></section></section></section></section></section><section data-mid=\"\" mpa-from-tpl=\"t\"><section data-mid=\"\" mpa-from-tpl=\"t\"><section data-mid=\"\" mpa-from-tpl=\"t\"><section data-mid=\"\" mpa-from-tpl=\"t\"><p data-mid=\"\"><span>更多技术干货</span></p><p data-mid=\"\"><span>扫码关注</span></p></section><section data-mid=\"\" mpa-from-tpl=\"t\"><p data-mid=\"\"><span>OPPO互联网技术</span></p></section></section><section data-mid=\"\" mpa-from-tpl=\"t\"><img data-cropselx1=\"0\" data-cropselx2=\"120\" data-cropsely1=\"0\" data-cropsely2=\"120\" data-ratio=\"1\" data-type=\"jpeg\" data-w=\"258\" data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxjYDM1fnDY1N9LLUp4gJV8ulKxP20jO66gHdE8q9DgFIB5hvxfBxEERyWeSxpc6nor8SPgiadWNVsQ/640?wx_fmt=jpeg\"/> </section></section><section data-mid=\"\" mpa-from-tpl=\"t\"><section data-mid=\"\" mpa-from-tpl=\"t\"><br/></section></section></section><section data-tools=\"135编辑器\" data-id=\"95172\" mpa-from-tpl=\"t\"><section mpa-from-tpl=\"t\"><section mpa-from-tpl=\"t\"><section data-brushtype=\"text\" mpa-from-tpl=\"t\"><span>我就知道你“在看”</span></section></section><section mpa-from-tpl=\"t\"><section mpa-from-tpl=\"t\"><img class=\"__bg_gif\" data-ratio=\"1.0377358490566038\" data-type=\"gif\" data-w=\"53\" data-width=\"100%\" data-src=\"https://mmbiz.qpic.cn/mmbiz_gif/ECThdibSVDxjYDM1fnDY1N9LLUp4gJV8uk9kQ2Hw3Ucae5fnjEfVb2noBlx2NuTgMwzuiceEL19F9prbiaKnZZd3A/640?wx_fmt=gif\"/></section></section></section></section>\n                </div>\n\n                \n\n                \n\n\n\n                \n                </div></div>","descriptionType":"html","feedId":540,"bgimg":"http://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxhZLelp68ImiaU7H75PosfL9BTTMib9z6CxjBLAsUOD5MwWXncdyAPrMTkMCYicy8YVCj5DMYTlaBVog/0?wx_fmt=jpeg","linkMd5":"f610ab73ec1a1a7a184fd15a6865cd76","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn16@2020_1/2020/08/16/11-57-51-388_8a472a2145c9b4d6.webp","metaImg":"http://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxhZLelp68ImiaU7H75PosfL9BTTMib9z6CxjBLAsUOD5MwWXncdyAPrMTkMCYicy8YVCj5DMYTlaBVog/0?wx_fmt=jpeg","destWidth":1076,"destHeight":459,"author":""},{"createdTime":"2020-08-16 19:57:49","updatedTime":"2020-08-16 19:57:49","title":"使用 Hugo 搭建博客","link":"https://toutiao.io/k/pcw56h6","description":"<div><div><div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>关于 Hugo 的介绍，直接转摘维基百科的介绍了：</p>\n</div>\n<div class=\"quoteblock\">\n<blockquote>\n<div class=\"paragraph\">\n<p>Hugo 是一个用 Go 编写的静态网站生成器，2013由 Steve Francia 原创，自 v0.14 (2015年) 由 Bjørn Erik Pedersen 主力开发，并由全球各地的开发者和用户提交贡献。Hugo 以 Apache License 2.0 许可的开放源代码项目。</p>\n</div>\n<div class=\"paragraph\">\n<p>Hugo 一般只需几秒钟就能生成一个网站（每页少于 1 毫秒），被称为“世界上最快的网站构建框架”，也使 Hugo 大受欢迎，成为最热门的静态网站生成器之一，被广泛采用。例如，2015年7月，Netlify 推出专为 Hugo 而设的网站托管服务，而2017年，Smashing Magazine 推出重新设计的官方网站，从原来的 WordPress 迁移到基于 Hugo 的 JAMstack 解决方案。</p>\n</div>\n</blockquote>\n<p class=\"attribution\">\n— https://zh.wikipedia.org/wiki/Hugo_(軟件)\n</p>\n</div>\n<div class=\"paragraph\">\n<p>Hugo 确实非常快，Kubernetes 的官网以及文档就是使用 Hugo 生成的，那么庞大的文档，在本地预览是，启动服务器也非常快。</p>\n</div>\n<div class=\"paragraph\">\n<p>D瓜哥在查资料时，遇到从 Hexo 切换到 Hugo 的案例，主要原因就是 Hugo 的速度惊人。我们就直接上 Hugo 了。</p>\n</div>\n</div>\n</div></div>","descriptionType":"html","feedId":540,"bgimg":"","linkMd5":"dd496d645029f44543c8c27ff8499360","metaImg":"","author":""},{"createdTime":"2020-08-16 19:57:43","updatedTime":"2020-08-16 19:57:43","title":"利用 puppeteer 来录制网页操作导出 GIF 动图","link":"https://toutiao.io/k/hj0qn2o","description":"<div><div><div class=\"RichText ztext Post-RichText\"><p>先来看看效果，然后我们再说怎么实现。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-346f2d2889014acfde41151983a4f824_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"220\" data-rawheight=\"344\" data-thumbnail=\"https://pic4.zhimg.com/v2-346f2d2889014acfde41151983a4f824_b.jpg\" class=\"content_image\"/></noscript><img src=\"\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"220\" data-rawheight=\"344\" data-thumbnail=\"https://pic4.zhimg.com/v2-346f2d2889014acfde41151983a4f824_b.jpg\" class=\"content_image lazy\" data-actualsrc=\"https://pic4.zhimg.com/v2-346f2d2889014acfde41151983a4f824_b.gif\"/></figure><p>可以看到完整的录制了我用puppeteer来编写的自动化脚本行为，那么是如何实现的呢，一开始我也没什么思路，看了一下开源的方案，大部分都是让使用一个 recoder 插件，看了一眼源码很简单，是利用ffmpeg 来实现的，还有很多对css动画录制的方案也是基于这个原理。</p><a target=\"_blank\" href=\"https://link.zhihu.com/?target=https%3A//ffmpeg.org/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"LinkCard LinkCard--noImage\"><span class=\"LinkCard-content\"><span class=\"LinkCard-text\"><span class=\"LinkCard-title\" data-text=\"true\">https://ffmpeg.org/</span><span class=\"LinkCard-meta\"><span>​<svg class=\"Zi Zi--InsertLink\" fill=\"currentColor\" viewbox=\"0 0 24 24\"><path d=\"M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z\"/></svg></span>ffmpeg.org</span></span><span class=\"LinkCard-imageCell\"/></span></a><a target=\"_blank\" href=\"https://link.zhihu.com/?target=https%3A//github.com/clipisode/puppeteer-recorder/blob/master/index.js\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"LinkCard LinkCard--noImage\"><span class=\"LinkCard-content\"><span class=\"LinkCard-text\"><span class=\"LinkCard-title\" data-text=\"true\">https://github.com/clipisode/puppeteer-recorder/blob/master/index.js</span><span class=\"LinkCard-meta\"><span>​<svg class=\"Zi Zi--InsertLink\" fill=\"currentColor\" viewbox=\"0 0 24 24\"><path d=\"M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z\"/></svg></span>github.com</span></span><span class=\"LinkCard-imageCell\"/></span></a><p>代码很短，一看就懂，page.screenshot一顿猛拍就完了。</p><p>一开始我也是这么做的，我把我每一步操作的结束都可以包装一次page.screenshot来截个图，然后多次操作的结果组合到一起就是完整的视频或者 GIF 了，可是这样真的很麻烦，而且screenshot本身的性能也很差。</p><p>其实换一个思路，我们知道puppeteer还支持 tracing 的 api，tracing 导出的结果是一个 json 文件里面是基于DevTools Protocol的，大家知道在性能测试阶段，DevTools 是支持截屏功能的，我们可以不可以利用这一点呢？</p><div class=\"highlight\"><pre><code class=\"language-ts\"><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">_config</span><span class=\"p\">.</span><span class=\"nx\">withGif</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">await</span> <span class=\"nx\">page</span><span class=\"p\">.</span><span class=\"nx\">tracing</span><span class=\"p\">.</span><span class=\"nx\">start</span><span class=\"p\">({</span> <span class=\"nx\">path</span>: <span class=\"kt\">tracefile</span><span class=\"p\">,</span> <span class=\"nx\">screenshots</span>: <span class=\"kt\">true</span> <span class=\"p\">});</span>\n<span class=\"p\">}</span>\n<span class=\"kr\">const</span> <span class=\"nx\">res</span> <span class=\"o\">=</span> <span class=\"nx\">await</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">_task</span><span class=\"p\">.</span><span class=\"nx\">apply</span><span class=\"p\">(</span><span class=\"kc\">null</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"nx\">page</span><span class=\"p\">,</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">_taskId</span><span class=\"p\">]);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">_config</span><span class=\"p\">.</span><span class=\"nx\">withGif</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">await</span> <span class=\"nx\">page</span><span class=\"p\">.</span><span class=\"nx\">tracing</span><span class=\"p\">.</span><span class=\"nx\">stop</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>简单的代码就是这样，我们在开始我们的操作任务，也就是_task.apply 完成所有行为的前后，加入录制 gif 的功能，我们开启了 page.tracing.start 和 stop，这样就不必每一步里都去做screenshot了。</p><p>看一下导出来的文件格式大概是这样的：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bafda49f2fe472616e30103fce6d58d2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2546\" data-rawheight=\"1214\" class=\"origin_image zh-lightbox-thumb\" data-original=\"https://pic2.zhimg.com/v2-bafda49f2fe472616e30103fce6d58d2_r.jpg\"/></noscript><img src=\"\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2546\" data-rawheight=\"1214\" class=\"origin_image zh-lightbox-thumb lazy\" data-original=\"https://pic2.zhimg.com/v2-bafda49f2fe472616e30103fce6d58d2_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bafda49f2fe472616e30103fce6d58d2_b.jpg\"/></figure><p>里面 cat 的协议就是 DevTools的规范协议了，瞅了一眼，发现 snapshot 里的就是一段 base64的图片字符数据。</p><p>下面的代码我们这么来写：</p><div class=\"highlight\"><pre><code class=\"language-ts\"> <span class=\"kr\">const</span> <span class=\"nx\">tracing</span> <span class=\"o\">=</span> <span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nx\">parse</span><span class=\"p\">(</span><span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nx\">readFileSync</span><span class=\"p\">(</span><span class=\"nx\">tracefile</span><span class=\"p\">,</span> <span class=\"s1\">'utf8'</span><span class=\"p\">));</span>\n <span class=\"kr\">const</span> <span class=\"nx\">traceScreenshots</span> <span class=\"o\">=</span> <span class=\"nx\">tracing</span><span class=\"p\">.</span><span class=\"nx\">traceEvents</span><span class=\"p\">.</span><span class=\"nx\">filter</span><span class=\"p\">(</span>\n        <span class=\"p\">(</span><span class=\"nx\">x</span>: <span class=\"kt\">any</span><span class=\"p\">,</span> <span class=\"nx\">index</span>: <span class=\"kt\">number</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span>\n          <span class=\"nx\">x</span><span class=\"p\">.</span><span class=\"nx\">cat</span> <span class=\"o\">===</span> <span class=\"s1\">'disabled-by-default-devtools.screenshot'</span> <span class=\"o\">&amp;&amp;</span>\n          <span class=\"nx\">x</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">===</span> <span class=\"s1\">'Screenshot'</span> <span class=\"o\">&amp;&amp;</span>\n          <span class=\"k\">typeof</span> <span class=\"nx\">x</span><span class=\"p\">.</span><span class=\"nx\">args</span> <span class=\"o\">!==</span> <span class=\"s1\">'undefined'</span> <span class=\"o\">&amp;&amp;</span>\n          <span class=\"k\">typeof</span> <span class=\"nx\">x</span><span class=\"p\">.</span><span class=\"nx\">args</span><span class=\"p\">.</span><span class=\"nx\">snapshot</span> <span class=\"o\">!==</span> <span class=\"s1\">'undefined'</span> <span class=\"o\">&amp;&amp;</span>\n          <span class=\"nx\">index</span> <span class=\"o\">%</span> <span class=\"mi\">10</span> <span class=\"o\">==</span> <span class=\"mi\">1</span>\n      <span class=\"p\">);</span>\n</code></pre></div><p>先读取到 tracefile，然后过滤出来 screenshot 相关的数据，最后有个 index % 10 == 1 ，我们为了避免帧数过多，进行了抽帧操作，如果不抽帧一个10几 s 的行为录制完的 gif 大概有30多 MB，这个是接受不了的，后边还有除了抽帧之外的其他优化操作，比如把每张图片进行整体的cover 还有 resize 操作，还有对 gif 的 quality 设置等。</p><p>代码简单分几步说一下，我们首先获取视窗大小，然后创建一个新的 gifencode 实例，进行合并 gif 的前置操作：</p><div class=\"highlight\"><pre><code class=\"language-ts\"> <span class=\"kr\">const</span> <span class=\"nx\">viewport</span> <span class=\"o\">=</span> <span class=\"nx\">page</span><span class=\"p\">.</span><span class=\"nx\">viewport</span><span class=\"p\">();</span>\n <span class=\"kd\">let</span> <span class=\"nx\">file</span> <span class=\"o\">=</span> <span class=\"nx\">fs</span><span class=\"p\">.</span><span class=\"nx\">createWriteStream</span><span class=\"p\">(</span><span class=\"nx\">giffile</span><span class=\"p\">);</span>\n <span class=\"kr\">const</span> <span class=\"nx\">encoder</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">GIFEncoder</span><span class=\"p\">(</span><span class=\"nx\">viewport</span><span class=\"p\">.</span><span class=\"nx\">width</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"nx\">viewport</span><span class=\"p\">.</span><span class=\"nx\">height</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n <span class=\"nx\">encoder</span><span class=\"p\">.</span><span class=\"nx\">setFrameRate</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">);</span>\n <span class=\"nx\">encoder</span><span class=\"p\">.</span><span class=\"nx\">pipe</span><span class=\"p\">(</span><span class=\"nx\">file</span><span class=\"p\">);</span>\n <span class=\"nx\">encoder</span><span class=\"p\">.</span><span class=\"nx\">setQuality</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n <span class=\"nx\">encoder</span><span class=\"p\">.</span><span class=\"nx\">writeHeader</span><span class=\"p\">();</span>\n <span class=\"nx\">encoder</span><span class=\"p\">.</span><span class=\"nx\">setRepeat</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n</code></pre></div><p>获取 page 的 viewport，然后我们创建一个可写流，来做本地的 gif 保存，然后再创建一个新的 gifencoder 实例，设置高宽是实际高宽的一半，这是为了节约最后的体积。</p><p>然后设置了帧率是100ms，质量最低，无限重复。</p><div class=\"highlight\"><pre><code class=\"language-ts\">  <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">index</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">index</span> <span class=\"o\">&lt;</span> <span class=\"nx\">traceScreenshots</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span> <span class=\"nx\">index</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kd\">let</span> <span class=\"nx\">snap</span> <span class=\"o\">=</span> <span class=\"nx\">traceScreenshots</span><span class=\"p\">[</span><span class=\"nx\">index</span><span class=\"p\">];</span>\n        <span class=\"kd\">let</span> <span class=\"nx\">base64string</span> <span class=\"o\">=</span> <span class=\"nx\">snap</span><span class=\"p\">.</span><span class=\"nx\">args</span><span class=\"p\">.</span><span class=\"nx\">snapshot</span><span class=\"p\">;</span>\n        <span class=\"kd\">let</span> <span class=\"nx\">buffer</span> <span class=\"o\">=</span> <span class=\"nx\">Buffer</span><span class=\"p\">.</span><span class=\"nx\">from</span><span class=\"p\">(</span><span class=\"nx\">base64string</span><span class=\"p\">,</span> <span class=\"s1\">'base64'</span><span class=\"p\">);</span>\n        <span class=\"kd\">let</span> <span class=\"nx\">image</span> <span class=\"o\">=</span> <span class=\"nx\">await</span> <span class=\"nx\">jimp</span><span class=\"p\">.</span><span class=\"nx\">read</span><span class=\"p\">(</span><span class=\"nx\">buffer</span><span class=\"p\">);</span>\n        <span class=\"nx\">await</span> <span class=\"nx\">image</span>\n          <span class=\"p\">.</span><span class=\"nx\">cover</span><span class=\"p\">(</span>\n            <span class=\"nx\">viewport</span><span class=\"p\">.</span><span class=\"nx\">width</span><span class=\"p\">,</span>\n            <span class=\"nx\">viewport</span><span class=\"p\">.</span><span class=\"nx\">height</span><span class=\"p\">,</span>\n            <span class=\"nx\">jimp</span><span class=\"p\">.</span><span class=\"nx\">HORIZONTAL_ALIGN_LEFT</span> <span class=\"o\">|</span> <span class=\"nx\">jimp</span><span class=\"p\">.</span><span class=\"nx\">VERTICAL_ALIGN_TOP</span>\n          <span class=\"p\">)</span>\n          <span class=\"p\">.</span><span class=\"nx\">resize</span><span class=\"p\">(</span><span class=\"nx\">viewport</span><span class=\"p\">.</span><span class=\"nx\">width</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"nx\">viewport</span><span class=\"p\">.</span><span class=\"nx\">height</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n        <span class=\"nx\">encoder</span><span class=\"p\">.</span><span class=\"nx\">addFrame</span><span class=\"p\">(</span><span class=\"nx\">image</span><span class=\"p\">.</span><span class=\"nx\">bitmap</span><span class=\"p\">.</span><span class=\"nx\">data</span><span class=\"p\">);</span>\n        <span class=\"nx\">encoder</span><span class=\"p\">.</span><span class=\"nx\">read</span><span class=\"p\">();</span>\n      <span class=\"p\">}</span>\n      <span class=\"nx\">encoder</span><span class=\"p\">.</span><span class=\"nx\">finish</span><span class=\"p\">()</span>\n</code></pre></div><p>下面这个 for 循环可以详细说说，首先为什么不用 forEach，因为 forEach 中的 await 是有问题的，可以参考文末链接，这里就不细说了。</p><p>然后我们获取到每一帧数据，拿到 base64字符串，这里要转换成 buffer 进行操作，避免每一帧都本地存图，这里又用到了一个 jimp 的库，他的 read 方法支持读 buffer ，然后我们进行 cover 的裁切操作，强制每一张图片的高宽都是 viewport 的高宽，这里是因为 snapshot 有时候偶尔会出现实际尺寸和 viewport 不一致的情况，那么叠加 gif 的时候就会花屏，这里做了统一处理。</p><p>cover 之后再做一次裁切，resize 到一半，减少体积，gifencoder的文档后边大家可以自己去看一下，addFrame 的 data 是 pixels的格式，像素数据，所以正好 jimp 的 bitmap.data 就是 pixels 的，直接加入到帧就好了，因为怕数据过大，每次 addFrame 后都进行 read 操作，这里不解释太多，熟悉 stream 操作的同学应该都懂，最后调用finish 结束。</p><p>然后就是清理操作了，比如删除 json 文件什么的，这里如果大家对nodejs 的流操作比较熟悉，可以在 encoder.pipe 这里做一下变动，不 pipe 到一个可写流中，可以直接在 end 和 data 事件里把 buffer 处理好，最后一次性转成 base64的导给前端接口就行了。</p><p>这个就看各自的业务场景了，没什么太难的。</p><p>最后给出参考的一些文档和地址吧：</p><a target=\"_blank\" href=\"https://link.zhihu.com/?target=https%3A//github.com/clipisode/puppeteer-recorder\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"LinkCard LinkCard--noImage\"><span class=\"LinkCard-content\"><span class=\"LinkCard-text\"><span class=\"LinkCard-title\" data-text=\"true\">https://github.com/clipisode/puppeteer-recorder</span><span class=\"LinkCard-meta\"><span>​<svg class=\"Zi Zi--InsertLink\" fill=\"currentColor\" viewbox=\"0 0 24 24\"><path d=\"M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z\"/></svg></span>github.com</span></span><span class=\"LinkCard-imageCell\"/></span></a><a target=\"_blank\" href=\"https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/gif-encoder\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-338e4905a2684ca96e08c7780fc68412_180x120.jpg\" data-image-width=\"1200\" data-image-height=\"630\" class=\"LinkCard LinkCard--hasImage\"><span class=\"LinkCard-backdrop\"/><span class=\"LinkCard-content\"><span class=\"LinkCard-text\"><span class=\"LinkCard-title\" data-text=\"true\">gif-encoder</span><span class=\"LinkCard-meta\"><span>​<svg class=\"Zi Zi--InsertLink\" fill=\"currentColor\" viewbox=\"0 0 24 24\"><path d=\"M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z\"/></svg></span>www.npmjs.com</span></span><span class=\"LinkCard-imageCell\"><img class=\"LinkCard-image LinkCard-image--horizontal\" alt=\"图标\" src=\"https://pic2.zhimg.com/v2-338e4905a2684ca96e08c7780fc68412_180x120.jpg\"/></span></span></a><a target=\"_blank\" href=\"https://link.zhihu.com/?target=https%3A//github.com/oliver-moran/jimp/tree/master/packages/jimp\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-057c26f0805b37c7c989ff63919981da_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\"LinkCard LinkCard--hasImage\"><span class=\"LinkCard-backdrop\"/><span class=\"LinkCard-content\"><span class=\"LinkCard-text\"><span class=\"LinkCard-title\" data-text=\"true\">oliver-moran/jimp</span><span class=\"LinkCard-meta\"><span>​<svg class=\"Zi Zi--InsertLink\" fill=\"currentColor\" viewbox=\"0 0 24 24\"><path d=\"M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z\"/></svg></span>github.com</span></span><span class=\"LinkCard-imageCell\"><img class=\"LinkCard-image LinkCard-image--square\" alt=\"图标\" src=\"https://pic2.zhimg.com/v2-057c26f0805b37c7c989ff63919981da_ipico.jpg\"/></span></span></a><a target=\"_blank\" href=\"https://link.zhihu.com/?target=https%3A//chromedevtools.github.io/devtools-protocol/tot/Page/%23method-startScreencast\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"LinkCard LinkCard--noImage\"><span class=\"LinkCard-content\"><span class=\"LinkCard-text\"><span class=\"LinkCard-title\" data-text=\"true\">https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-startScreencast</span><span class=\"LinkCard-meta\"><span>​<svg class=\"Zi Zi--InsertLink\" fill=\"currentColor\" viewbox=\"0 0 24 24\"><path d=\"M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z\"/></svg></span>chromedevtools.github.io</span></span><span class=\"LinkCard-imageCell\"/></span></a><a target=\"_blank\" href=\"https://www.zhihu.com/question/53466898\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg\" class=\"LinkCard LinkCard--hasImage\"><span class=\"LinkCard-backdrop\"/><span class=\"LinkCard-content\"><span class=\"LinkCard-text\"><span class=\"LinkCard-title\" data-text=\"true\">JavaScript forEach 不支持 async/await？</span><span class=\"LinkCard-meta\"><span>​<svg class=\"Zi Zi--InsertLink\" fill=\"currentColor\" viewbox=\"0 0 24 24\"><path d=\"M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z\"/></svg></span>www.zhihu.com</span></span><span class=\"LinkCard-imageCell\"><img class=\"LinkCard-image LinkCard-image--square\" alt=\"图标\" src=\"https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg\"/></span></span></a><p/></div></div></div>","descriptionType":"html","feedId":540,"bgimg":"https://pic4.zhimg.com/v2-346f2d2889014acfde41151983a4f824_b.gif","linkMd5":"596f5e31a783ec327594946a83e9d0e6","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx/cdn24@2020_1/2020/08/16/11-57-51-742_cb51489b0dd1a6a0.webp","destWidth":220,"destHeight":344,"author":"","articleImgCdnMap":{"https://pic4.zhimg.com/v2-346f2d2889014acfde41151983a4f824_b.gif":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn35@2020_3/2020/08/16/11-57-51-509_cb51489b0dd1a6a0.webp","https://pic2.zhimg.com/v2-bafda49f2fe472616e30103fce6d58d2_b.jpg":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn31@2020_3/2020/08/16/11-57-50-660_7b93e67606b6daa5.webp","https://pic2.zhimg.com/v2-338e4905a2684ca96e08c7780fc68412_180x120.jpg":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn39@2020_4/2020/08/16/11-57-50-419_1447ff43329d32b6.webp","https://pic2.zhimg.com/v2-057c26f0805b37c7c989ff63919981da_ipico.jpg":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn27@2020_6/2020/08/16/11-57-50-385_2765b3441969c020.webp","https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn43@2020_5/2020/08/16/11-58-03-740_ed37ae9bace8e944.svg"}},{"createdTime":"2020-08-16 19:57:49","updatedTime":"2020-08-16 19:57:49","title":"记一次 Sqlalchemy Session 问题","link":"https://toutiao.io/k/f4yv4kl","description":"<div><div><section><h2><span>背景</span></h2><p>在一次更新中，我们优化了线上查询大数据量数据库记录的接口，将原来的串行查询，改成了多线程并发查询。上线后发现，日志偶尔会出现</p><p><code>Instance XXX is not bound to a Session; attribute refresh operation cannot proceed</code></p><h2><span>复现</span></h2><p>因在线下回归测试的过程中，并没有出现类似的问题。所以初步怀疑是在多并发访问的时候才会出现这种场景。因此，在线下构建复现环境。</p><p>测试代码如下：</p><pre><code><span>import</span> gevent<br/><span>from</span> gevent <span>import</span> monkey<br/><br/><span>import</span> threading<br/><br/>monkey.patch_all()<br/><br/><span>with</span> app.test_client() <span>as</span> c:<br/>    <span><span>def</span> <span>_exec</span><span>(_id)</span>:</span><br/>        req_data = {<br/>            ...<br/>        }<br/>        rv = c.post(<span>'/api/v1/A'</span>, json=req_data)<br/>        print(rv.get_json())<br/>        <span>assert</span> rv.status_code == <span>200</span><br/><br/>    ts = []<br/>    <span>for</span> i <span>in</span> range(<span>2</span>):<br/>        ts.append(gevent.spawn(_exec, i))<br/><br/>    <span>for</span> t <span>in</span> ts:<br/>        t.join()<br/></code></pre><p>代码省略了一些业务数据，一些无关的<code>import</code>和<code>Mock</code>代码。</p><p>测试代码模拟的是线上<code>Gunicorn(gevent mode) =&gt; Flask API</code>这种进线程模型来进行复现.</p><p>接口<code>A</code>的概要逻辑如下：</p><pre><code><span>1</span>  db_session = scoped_session(sessionmaker(autocommit=<span>False</span>, autoflush=<span>False</span>, bind=engine))<br/><span>2</span>  @blueprint.route(<span>\"/A\"</span>, methods=[<span>\"POST\"</span>])<br/><span>3</span>  <span><span>def</span> <span>A</span><span>(*args, **kwargs)</span>:</span><br/><span>4</span>      params = request.get_json()    <br/><span>5</span>      valid(params)<br/><span>6</span>      b = create_orm_obj_b(params)<br/><span>7</span>      db_session.add(b)<br/><span>8</span>      multiple_threads_query_database()<br/><span>9</span>      <span>try</span>:<br/><span>10</span>         db_session.commit()<br/><span>11</span>     <span>except</span> Exception <span>as</span> ex:<br/><span>12</span>         db_session.rollback()<br/><span>13</span>         <span>return</span> <span>500</span>    <br/><span>14</span>     <span>return</span> <span>200</span><br/></code></pre><p>变更主要改动的地方就在于新增了<strong>第8行</strong>逻辑。</p><p>按照上面的测试脚本，开启<strong>两个</strong>协程并发请求接口。遗憾并不能复现。</p><p>紧接着猜想是否是协程数不够多，或许将协程的并发度逐步调大，然后看看结果。当并发度开到<strong>3</strong>的时候，果然，问题就复现了</p><figure><p><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.05078125\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/zz4SicRwEWWliaKHpqZ9tntdARd3nE12bQk2CxFMbEmfCTcy7nkiavCAibicia75Rn5TrZibft7MJMh9ZEH7tN8vvicejQ/640?wx_fmt=png\" data-type=\"png\" data-w=\"1280\"/></p></figure><p>将上面测试代码改成<strong>没有 gevent 模式下的纯线程</strong>试试，不管并发度如何，错误都没有出现</p><p>因此，可以怀疑的是<code>gevent</code>协程库的问题</p><h2><span>分析</span></h2><p>http://sqlalche.me/e/13/bhk3 报错信息的后面，官方解析了报错原因是: 操作的ORM对象(如上诉的<code>b</code>)已经不和当前的<code>session</code>关联了, 后续代码存在使用懒加载的形式来加载对象属性。</p><p>所以问题的关键点就在于: <strong><code>b</code>对象在哪一步和当前的<code>session</code>对象失去关联了？？</strong></p><p><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.2974607013301088\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/zz4SicRwEWWliaKHpqZ9tntdARd3nE12bQ9Gx06H3S65OcWdFYjc6zTIR87EBLL5HP6pjCnNJ7YWGiaUO1nEtSgibA/640?wx_fmt=jpeg\" data-type=\"jpeg\" data-w=\"827\"/></p><p><code>sqlalchemy.session.add()</code>这个是将ORM对象和<code>Session</code>进行关联，与之相反的是<code>sqlalchemy.session.expunge()</code>操作。</p><p>但是，很明确地知道，业务代码中没有任何一处的地方显示调用了<code>expunge</code>。</p><p>其实，深入研究一下<code>add</code>的代码。会发现，对象是由Session实例对象的<code>_new</code>属性中。而<code>_new</code>属性会在<code>flush</code>方法最后调用<code>pop</code>方法来删除ORM对象。</p><p><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.45394736842105265\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/zz4SicRwEWWliaKHpqZ9tntdARd3nE12bQ2v23aBV7b5VZiaWXswjpVu4cEpCshPRq85a76jsSNpYpQo9GF1Q6T1Q/640?wx_fmt=jpeg\" data-type=\"jpeg\" data-w=\"760\"/></p><p><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.1952247191011236\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/zz4SicRwEWWliaKHpqZ9tntdARd3nE12bQxxB3b9tatUia26WOus7mHia70gKmNfX1h7apB5lHRbPjIWErImV4f7Tg/640?wx_fmt=jpeg\" data-type=\"jpeg\" data-w=\"712\"/></p><p>所以，严重怀疑地是<code>Session</code>在调用<code>commit()</code>方法的时候，让<code>b</code>对象和<code>session</code>的联系脱节了。(关于<code>flush</code>和<code>commit</code>两个操作的关系，可以看看这个链接：SQLAlchemy: What's the difference between flush() and commit()? , 大概就是commit内部也对调用flush操作)</p><p>打开<code>DEBUG</code>日志看看<code>Sqlalchemy</code>执行SQL日志。</p><p><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.7635467980295566\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/zz4SicRwEWWliaKHpqZ9tntdARd3nE12bQ7AYECb7dJnM3qpBOhGnZ0krUqQc5MIMY3V2MGc4nkEoAXuDibC0356g/640?wx_fmt=jpeg\" data-type=\"jpeg\" data-w=\"609\"/></p><p>果然，在一次事物中，执行了两次插入<code>b</code>对象的操作。</p><p>这就可以得出初步的结论：</p><p><strong>两次接口调用中，使用了相同的Session对象。A1调用在最后commit的时候将A2中的对象b2也一起提交了，最后当b2在使用属性的时候，就会发现b2不在Session的管理中(都flush出去了)</strong></p><p><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"1.7865546218487396\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/zz4SicRwEWWliaKHpqZ9tntdARd3nE12bQxlStb2Q2VZnOGCLvbySloVVs21SgicNzUtvfVXRKUHg08hdTFHtJzTQ/640?wx_fmt=jpeg\" data-type=\"jpeg\" data-w=\"595\"/></p><p>上图，在<code>print(b1.id)</code>的时候，系统就会出错。</p><p>虽然找到了Object和Session取消关联的原因，但是归根结底，是因为两个协程公用的一个Session。正确的逻辑应该是每一个协程都应该维护自己的对象关系。</p><p>再来看看<code>Sesseion</code>的初始化方法</p><pre><code>db_session = scoped_session(sessionmaker(autocommit=<span>False</span>, autoflush=<span>False</span>, bind=engine))<br/><br/><span><span>class</span> <span>scoped_session</span><span>(object)</span>:</span><br/><br/>    <span><span>def</span> <span>__init__</span><span>(self, session_factory, scopefunc=None)</span>:</span><br/><br/>          self.session_factory = session_factory<br/><br/>        <span>if</span> scopefunc:<br/>            self.registry = ScopedRegistry(session_factory, scopefunc)<br/>        <span>else</span>:<br/>            self.registry = ThreadLocalRegistry(session_factory)<br/></code></pre><p>默认情况下，Session使用<code>Thread Local Storage(TLS)</code>来使每个线程都持有一个独立的<code>Session</code>, 这就解析为什么在多线程环境下运行测试代码，是没有问题的。</p><p>而<code>gunicorn</code>的<code>gevent模式</code>，在启动阶段，会调用<code>gevent.monkey.patch_all()</code>方法来覆写<code>TLS =&gt; gevent.local</code>。</p><p>我们再来看<code>Session</code>和<code>gunicorn</code>的执行顺序</p><pre><code><span><span>def</span> <span>main</span><span>()</span>:</span><br/><br/>    db_session = scoped_session(sessionmaker(autocommit=<span>False</span>, autoflush=<span>False</span>, bind=engine))<br/><br/>    run_with_gunicorn(flask_app)<br/></code></pre><p>我们可以发现，<code>Session</code>里面的TLS初始化是<code>threading.local.local</code>对象，然后gunicorn才运行<code>gevent.monkey.patch_all()</code></p><p>在<code>scoped_session</code>调用前，先PATCH一下<code>gevent</code>的代码，结果问题彻底解决了。</p><h2><span>结论</span></h2><p>在使用<code>Gevent + Sqlalchemy</code>的时候，需要优先执行<code>gevent.monkey.patch_all()</code>, 以防在并发逻辑下出现各种奇怪的问题。</p><p>同时，尽量避免把<code>Session</code>定义成全局变量来使用。</p></section></div></div>","descriptionType":"html","feedId":540,"bgimg":"http://mmbiz.qpic.cn/mmbiz_jpg/zz4SicRwEWWliaKHpqZ9tntdARd3nE12bQjLtVUqV1a6rdibLVnTUNA52Ph6icydqibblKdstGsiay01r1s9w0EgnfxQ/0?wx_fmt=jpeg","linkMd5":"1a964612e4889a165cfbedeecb26af33","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn20@2020_6/2020/08/16/11-57-51-320_a353a9d846c0c3d1.webp","metaImg":"http://mmbiz.qpic.cn/mmbiz_jpg/zz4SicRwEWWliaKHpqZ9tntdARd3nE12bQjLtVUqV1a6rdibLVnTUNA52Ph6icydqibblKdstGsiay01r1s9w0EgnfxQ/0?wx_fmt=jpeg","destWidth":499,"destHeight":211,"author":""},{"createdTime":"2020-08-16 19:57:48","updatedTime":"2020-08-16 19:57:48","title":"丢弃掉那些 BeanUtils 工具类吧，MapStruct 真香","link":"https://toutiao.io/k/nn7q9kk","description":"<div><div><article class=\"article-content\">&#13;\n<p>在前几天的文章《<a href=\"https://www.hollischuang.com/archives/5337\">为什么阿里巴巴禁止使用Apache Beanutils进行属性的copy？</a>》中，我曾经对几款属性拷贝的工具类进行了对比。</p>\n<p>然后在评论区有些读者反馈说MapStruct才是真的香，于是我就抽时间了解了一下MapStruct。结果我发现，这真的是一个神仙框架，炒鸡香。</p>\n<p>这一篇文章就来简单介绍下MapStruct的用法，并且再和其他几个工具类进行一下对比。</p>\n<h3>为什么需要MapStruct ？</h3>\n<p>首先，我们先说一下MapStruct这类框架适用于什么样的场景，为什么市面上会有这么多的类似的框架。</p>\n<p>在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。很多人都对三层架构、四层架构等并不陌生。</p>\n<p>甚至有人说：<strong>“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，如果不行，那就加两层。”</strong></p>\n<p>但是，随着软件架构分层越来越多，那么各个层次之间的数据模型就要面临着相互转换的问题，典型的就是我们可以在代码中见到各种O，如DO、DTO、VO等。</p>\n<p>一般情况下，同样一个数据模型，我们在不同的层次要使用不同的数据模型。<strong>如在数据存储层，我们使用DO来抽象一个业务实体；在业务逻辑层，我们使用DTO来表示数据传输对象；到了展示层，我们又把对象封装成VO来与前端进行交互。</strong></p>\n<p>那么，数据的从前端透传到数据持久化层（从持久层透传到前端），就需要进行对象之间的互相转化，即在不同的对象模型之间进行映射。</p>\n<p>通常我们可以使用get/set等方式逐一进行字段映射操作，如：</p>\n<pre><code>personDTO.setName(personDO.getName());\npersonDTO.setAge(personDO.getAge());\npersonDTO.setSex(personDO.getSex());\npersonDTO.setBirthday(personDO.getBirthday());\n</code></pre>\n<p>但是，编写这样的映射代码是一项冗长且容易出错的任务。MapStruct等类似的框架的目标是通过自动化的方式尽可能多地简化这项工作。</p>\n<h3>MapStruct的使用</h3>\n<p>MapStruct（https://mapstruct.org/ ）是一种代码生成器，它极大地简化了基于”约定优于配置”方法的Java bean类型之间映射的实现。生成的映射代码使用纯方法调用，因此快速、类型安全且易于理解。</p>\n<blockquote>\n<p>约定优于配置，也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。</p>\n</blockquote>\n<p>假设我们有两个类需要进行互相转换，分别是PersonDO和PersonDTO，类定义如下：</p>\n<pre><code>public class PersonDO {\n    private Integer id;\n    private String name;\n    private int age;\n    private Date birthday;\n    private String gender;\n}\n\npublic class PersonDTO {\n    private String userName;\n    private Integer age;\n    private Date birthday;\n    private Gender gender;\n}\n</code></pre>\n<p>我们演示下如何使用MapStruct进行bean映射。</p>\n<p>想要使用MapStruct，首先需要依赖他的相关的jar包，使用maven依赖方式如下：</p>\n<pre><code>...\n&lt;properties&gt;\n    &lt;org.mapstruct.version&gt;1.3.1.Final&lt;/org.mapstruct.version&gt;\n&lt;/properties&gt;\n...\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;\n        &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;\n        &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n...\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n            &lt;version&gt;3.8.1&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;source&gt;1.8&lt;/source&gt; &lt;!-- depending on your project --&gt;\n                &lt;target&gt;1.8&lt;/target&gt; &lt;!-- depending on your project --&gt;\n                &lt;annotationProcessorPaths&gt;\n                    &lt;path&gt;\n                        &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;\n                        &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;\n                        &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;\n                    &lt;/path&gt;\n                    &lt;!-- other annotation processors --&gt;\n                &lt;/annotationProcessorPaths&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre>\n<p>因为MapStruct需要在编译器生成转换代码，所以需要在maven-compiler-plugin插件中配置上对mapstruct-processor的引用。这部分在后文会再次介绍。</p>\n<p>之后，我们需要定义一个做映射的接口，主要代码如下：</p>\n<pre><code>@Mapper\ninterface PersonConverter {\n    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);\n\n    @Mappings(@Mapping(source = \"name\", target = \"userName\"))\n    PersonDTO do2dto(PersonDO person);\n}\n</code></pre>\n<p>使用注解 <code>@Mapper</code>定义一个Converter接口，在其中定义一个do2dto方法，方法的入参类型是PersonDO，出参类型是PersonDTO，这个方法就用于将PersonDO转成PersonDTO。</p>\n<p>测试代码如下：</p>\n<pre><code>public static void main(String[] args) {\n    PersonDO personDO = new PersonDO();\n    personDO.setName(\"Hollis\");\n    personDO.setAge(26);\n    personDO.setBirthday(new Date());\n    personDO.setId(1);\n    personDO.setGender(Gender.MALE.name());\n    PersonDTO personDTO = PersonConverter.INSTANCE.do2dto(personDO);\n    System.out.println(personDTO);\n}\n</code></pre>\n<p>输出结果：</p>\n<pre><code>PersonDTO{userName='Hollis', age=26, birthday=Sat Aug 08 19:00:44 CST 2020, gender=MALE}\n</code></pre>\n<p>可以看到，我们使用MapStruct完美的将PersonDO转成了PersonDTO。</p>\n<p>上面的代码可以看出，MapStruct的用法比较简单，主要依赖<code>@Mapper</code>注解。</p>\n<p>但是我们知道，大多数情况下，我们需要互相转换的两个类之间的属性名称、类型等并不完全一致，还有些情况我们并不想直接做映射，那么该如何处理呢？</p>\n<p>其实MapStruct在这方面也是做的很好的。</p>\n<h3>MapStruct处理字段映射</h3>\n<p>首先，可以明确的告诉大家，如果要转换的两个类中源对象属性与目标对象属性的类型和名字一致的时候，会自动映射对应属性。</p>\n<p>那么，如果遇到特殊情况如何处理呢？</p>\n<h4>名字不一致如何映射</h4>\n<p>如上面的例子中，在PersonDO中用name表示用户名称，而在PersonDTO中使用userName表示用户名，那么如何进行参数映射呢。</p>\n<p>这时候就要使用<code>@Mapping</code>注解了，只需要在方法签名上，使用该注解，并指明需要转换的源对象的名字和目标对象的名字就可以了，如将name的值映射给userName，可以使用如下方式：</p>\n<pre><code>@Mapping(source = \"name\", target = \"userName\")\n</code></pre>\n<h4>可以自动映射的类型</h4>\n<p>除了名字不一致以外，还有一种特殊情况，那就是类型不一致，如上面的例子中，在PersonDO中用String类型表示用户性别，而在PersonDTO中使用一个Genter的枚举表示用户性别。</p>\n<p>这时候类型不一致，就需要涉及到互相转换的问题</p>\n<p>其实，MapStruct会对部分类型自动做映射，不需要我们做额外配置，如例子中我们将String类型自动转成了枚举类型。</p>\n<p>一般情况下，对于以下情况可以做自动类型转换：</p>\n<ul>\n<li>基本类型及其他们对应的包装类型。</li>\n<li>基本类型的包装类型和String类型之间</li>\n<li>String类型和枚举类型之间</li>\n</ul>\n<h4>自定义常量</h4>\n<p>如果我们在转换映射过程中，想要给一些属性定义一个固定的值，这个时候可以使用 constant</p>\n<pre><code>@Mapping(source = \"name\", constant = \"hollis\")\n</code></pre>\n<h4>类型不一致的如何映射</h4>\n<p>还是上面的例子，如果我们需要在Person这个对象中增加家庭住址这个属性，那么我们一般在PersonoDTO中会单独定义一个HomeAddress类来表示家庭住址，而在Person类中，我们一般使用String类型表示家庭住址。</p>\n<p>这就需要在HomeAddress和String之间使用JSON进行互相转化，这种情况下，MapStruct也是可以支持的。</p>\n<pre><code>public class PersonDO {\n    private String name;\n    private String address;\n}\n\npublic class PersonDTO {\n    private String userName;\n    private HomeAddress address;\n}\n@Mapper\ninterface PersonConverter {\n    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);\n\n    @Mapping(source = \"userName\", target = \"name\")\n    @Mapping(target = \"address\",expression = \"java(homeAddressToString(dto2do.getAddress()))\")\n    PersonDO dto2do(PersonDTO dto2do);\n\n    default String homeAddressToString(HomeAddress address){\n        return JSON.toJSONString(address);\n    }\n}\n</code></pre>\n<p>我们只需要在PersonConverter中在定义一个方法（因为PersonConverter是一个接口，所以在JDK 1.8以后的版本中可以定义一个default方法），这个方法的作用就是将HomeAddress转换成String类型。</p>\n<blockquote>\n<p>default方法：Java 8 引入的新的语言特性，用关键字default来标注，被default所标注的方法，需要提供实现，而子类可以选择实现或者不实现该方法</p>\n</blockquote>\n<p>然后在dto2do方法上，通过以下注解方式即可实现类型的转换：</p>\n<pre><code>@Mapping(target = \"address\",expression = \"java(homeAddressToString(dto2do.getAddress()))\")\n</code></pre>\n<p>上面这种是自定义的类型转换，还有一些类型的转换是MapStruct本身就支持的，如String和Date之间的转换：</p>\n<pre><code>@Mapping(target = \"birthday\",dateFormat = \"yyyy-MM-dd HH:mm:ss\")\n</code></pre>\n<p>以上，简单介绍了一些常用的字段映射的方法，也是我自己在工作中经常遇到的几个场景，更多的情况大家可以查看官方的示例（https://github.com/mapstruct/mapstruct-examples）。</p>\n<h3>MapStruct的性能</h3>\n<p>前面说了这么多MapStruct的用法，可以看出MapStruct的使用还是比较简单的，并且字段映射上面的功能很强大，那么他的性能到底怎么样呢？</p>\n<p>参考《<a href=\"https://www.hollischuang.com/archives/5337\">为什么阿里巴巴禁止使用Apache Beanutils进行属性的copy？</a>》中的示例，我们对MapStruct进行性能测试。</p>\n<p>分别执行1000、10000、100000、1000000次映射的耗时分别为：0ms、1ms、3ms、6ms。</p>\n<p>可以看到，<strong>MapStruct的耗时相比较于其他几款工具来说是非常短的</strong>。</p>\n<p>那么，为什么MapStruct的性能可以这么好呢？</p>\n<p>其实，MapStruct和其他几类框架最大的区别就是：<strong>与其他映射框架相比，MapStruct在编译时生成bean映射，这确保了高性能，可以提前将问题反馈出来，也使得开发人员可以彻底的错误检查。</strong></p>\n<p>还记得前面我们在引入MapStruct的依赖的时候，特别在maven-compiler-plugin中增加了mapstruct-processor的支持吗？</p>\n<p>并且我们在代码中使用了很多MapStruct提供的注解，这使得在编译期，MapStruct就可以直接生成bean映射的代码，相当于代替我们写了很多setter和getter。</p>\n<p>如我们在代码中定义了以下一个Mapper：</p>\n<pre><code>@Mapper\ninterface PersonConverter {\n    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);\n\n    @Mapping(source = \"userName\", target = \"name\")\n    @Mapping(target = \"address\",expression = \"java(homeAddressToString(dto2do.getAddress()))\")\n    @Mapping(target = \"birthday\",dateFormat = \"yyyy-MM-dd HH:mm:ss\")\n    PersonDO dto2do(PersonDTO dto2do);\n\n    default String homeAddressToString(HomeAddress address){\n        return JSON.toJSONString(address);\n    }\n}\n</code></pre>\n<p>经过代码编译后，会自动生成一个PersonConverterImpl：</p>\n<pre><code>@Generated(\n    value = \"org.mapstruct.ap.MappingProcessor\",\n    date = \"2020-08-09T12:58:41+0800\",\n    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_181 (Oracle Corporation)\"\n)\nclass PersonConverterImpl implements PersonConverter {\n\n    @Override\n    public PersonDO dto2do(PersonDTO dto2do) {\n        if ( dto2do == null ) {\n            return null;\n        }\n\n        PersonDO personDO = new PersonDO();\n\n        personDO.setName( dto2do.getUserName() );\n        if ( dto2do.getAge() != null ) {\n            personDO.setAge( dto2do.getAge() );\n        }\n        if ( dto2do.getGender() != null ) {\n            personDO.setGender( dto2do.getGender().name() );\n        }\n\n        personDO.setAddress( homeAddressToString(dto2do.getAddress()) );\n\n        return personDO;\n    }\n}\n</code></pre>\n<p>在运行期，对于bean进行映射的时候，就会直接调用PersonConverterImpl的dto2do方法，这样就没有什么特殊的事情要做了，只是在内存中进行set和get就可以了。</p>\n<p>所以，因为在编译期做了很多事情，所以MapStruct在运行期的性能会很好，并且还有一个好处，那就是可以把问题的暴露提前到编译期。</p>\n<p>使得如果代码中字段映射有问题，那么应用就会无法编译，强制开发者要解决这个问题才行。</p>\n<h3>总结</h3>\n<p>本文介绍了一款Java中的字段映射工具类，MapStruct，他的用法比较简单，并且功能非常完善，可以应付各种情况的字段映射。</p>\n<p>并且因为他是编译期就会生成真正的映射代码，使得运行期的性能得到了大大的提升。</p>\n<p>强烈推荐，真的很香！！！</p>\n</article>&#13;\n            </div></div>","descriptionType":"html","feedId":540,"bgimg":"","linkMd5":"ceff25e1fc974e32d11cdd7fe7dbbeac","metaImg":"","author":""}],"record":{"createdTime":"2020-08-16 19:57:49","updatedTime":"2020-08-16 19:57:49","feedId":540,"fetchDate":"Sun, 16 Aug 2020 11:57:49 +0000","fetchMs":369,"handleMs":15842,"totalMs":31090,"newArticles":0,"totalArticles":5,"status":1,"type":0,"ip":"52.214.171.64","hostName":"europe-020.herokuapp.com","requestId":"b56788447fb94f0f917f04298cf7b6cd_540","bgimgsTotal":3,"bgimgsGithubTotal":3,"articlesImgsTotal":5,"articlesImgsGithubTotal":5},"extra4":{"start":1597579053528,"total":0,"statList":[{"spend":557,"msg":"获取xml内容"},{"spend":15842,"msg":"解释文章"},{"spend":2971,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":14675,"msg":"正文链接上传到cdn"}]},"extra5":5,"extra6":5,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://fierce-sierra-10390.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-004.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://enigmatic-headland-52348.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-016.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://tranquil-oasis-84875.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://pic2.zhimg.com/v2-338e4905a2684ca96e08c7780fc68412_180x120.jpg","sourceStatusCode":200,"destWidth":1200,"destHeight":630,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn39@2020_4/2020/08/16/11-57-50-419_1447ff43329d32b6.webp","sourceBytes":1759,"destBytes":3166,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1134,"convertSpendMs":29,"createdTime":"2020-08-16 19:57:50","host":"fierce-sierra-10390.herokuapp.com","referer":"https://toutiao.io/k/hj0qn2o","linkMd5ListStr":"596f5e31a783ec327594946a83e9d0e6","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"1.7 KB","destSize":"3.1 KB","compressRate":"180%"},{"code":1,"isDone":false,"source":"https://pic2.zhimg.com/v2-057c26f0805b37c7c989ff63919981da_ipico.jpg","sourceStatusCode":200,"destWidth":400,"destHeight":400,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn27@2020_6/2020/08/16/11-57-50-385_2765b3441969c020.webp","sourceBytes":26312,"destBytes":11392,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1406,"convertSpendMs":8,"createdTime":"2020-08-16 19:57:49","host":"europe-004.herokuapp.com","referer":"https://toutiao.io/k/hj0qn2o","linkMd5ListStr":"596f5e31a783ec327594946a83e9d0e6","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.7 KB","destSize":"11.1 KB","compressRate":"43.3%"},{"code":1,"isDone":false,"source":"https://pic2.zhimg.com/v2-bafda49f2fe472616e30103fce6d58d2_b.jpg","sourceStatusCode":200,"destWidth":720,"destHeight":343,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn31@2020_3/2020/08/16/11-57-50-660_7b93e67606b6daa5.webp","sourceBytes":179054,"destBytes":86568,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1513,"convertSpendMs":23,"createdTime":"2020-08-16 19:57:50","host":"enigmatic-headland-52348.herokuapp.com","referer":"https://toutiao.io/k/hj0qn2o","linkMd5ListStr":"596f5e31a783ec327594946a83e9d0e6","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"174.9 KB","destSize":"84.5 KB","compressRate":"48.3%"},{"code":1,"isDone":false,"source":"http://mmbiz.qpic.cn/mmbiz_jpg/ECThdibSVDxhZLelp68ImiaU7H75PosfL9BTTMib9z6CxjBLAsUOD5MwWXncdyAPrMTkMCYicy8YVCj5DMYTlaBVog/0?wx_fmt=jpeg","sourceStatusCode":200,"destWidth":1076,"destHeight":459,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn16@2020_1/2020/08/16/11-57-51-388_8a472a2145c9b4d6.webp","sourceBytes":41331,"destBytes":21062,"targetWebpQuality":75,"feedId":540,"totalSpendMs":2098,"convertSpendMs":15,"createdTime":"2020-08-16 19:57:50","host":"secret-beyond-24225.herokuapp.com","referer":"https://toutiao.io/k/gsdn4sv","linkMd5ListStr":"f610ab73ec1a1a7a184fd15a6865cd76","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"40.4 KB","destSize":"20.6 KB","compressRate":"51%"},{"code":1,"isDone":false,"source":"http://mmbiz.qpic.cn/mmbiz_jpg/zz4SicRwEWWliaKHpqZ9tntdARd3nE12bQjLtVUqV1a6rdibLVnTUNA52Ph6icydqibblKdstGsiay01r1s9w0EgnfxQ/0?wx_fmt=jpeg","sourceStatusCode":200,"destWidth":499,"destHeight":211,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn20@2020_6/2020/08/16/11-57-51-320_a353a9d846c0c3d1.webp","sourceBytes":23630,"destBytes":21168,"targetWebpQuality":75,"feedId":540,"totalSpendMs":2376,"convertSpendMs":8,"createdTime":"2020-08-16 19:57:49","host":"europe-012.herokuapp.com","referer":"https://toutiao.io/k/f4yv4kl","linkMd5ListStr":"1a964612e4889a165cfbedeecb26af33","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23.1 KB","destSize":"20.7 KB","compressRate":"89.6%"},{"code":1,"isDone":false,"source":"https://pic4.zhimg.com/v2-346f2d2889014acfde41151983a4f824_b.gif","sourceStatusCode":200,"destWidth":220,"destHeight":344,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn35@2020_3/2020/08/16/11-57-51-509_cb51489b0dd1a6a0.webp","sourceBytes":1172596,"destBytes":309916,"targetWebpQuality":75,"feedId":540,"totalSpendMs":2560,"convertSpendMs":346,"createdTime":"2020-08-16 19:57:50","host":"tranquil-oasis-84875.herokuapp.com","referer":"https://toutiao.io/k/hj0qn2o","linkMd5ListStr":"596f5e31a783ec327594946a83e9d0e6,596f5e31a783ec327594946a83e9d0e6","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"1.1 MB","destSize":"302.7 KB","compressRate":"26.4%"},{"code":1,"isDone":false,"source":"https://pic4.zhimg.com/v2-346f2d2889014acfde41151983a4f824_b.gif","sourceStatusCode":200,"destWidth":220,"destHeight":344,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn24@2020_1/2020/08/16/11-57-51-742_cb51489b0dd1a6a0.webp","sourceBytes":1172596,"destBytes":309916,"targetWebpQuality":75,"feedId":540,"totalSpendMs":2787,"convertSpendMs":576,"createdTime":"2020-08-16 19:57:50","host":"blooming-woodland-06913.herokuapp.com","referer":"https://toutiao.io/k/hj0qn2o","linkMd5ListStr":"596f5e31a783ec327594946a83e9d0e6,596f5e31a783ec327594946a83e9d0e6","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"1.1 MB","destSize":"302.7 KB","compressRate":"26.4%"},{"code":1,"isDone":false,"source":"https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg","sourceStatusCode":200,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn43@2020_5/2020/08/16/11-58-03-740_ed37ae9bace8e944.svg","sourceBytes":969,"destBytes":969,"feedId":540,"totalSpendMs":14652,"convertSpendMs":0,"createdTime":"2020-08-16 19:57:49","host":"europe-016.herokuapp.com","referer":"https://toutiao.io/k/hj0qn2o","linkMd5ListStr":"596f5e31a783ec327594946a83e9d0e6","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"969 B","destSize":"969 B","compressRate":"100%"}]}