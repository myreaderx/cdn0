{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-11-12 13:06:12","updatedTime":"2020-11-12 13:06:12","title":"WOW64!Hooks: WOW64 Subsystem Internals and Hooking Techniques","link":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","description":"<p>Microsoft is known for their backwards compatibility. When they\n  rolled out the 64-bit variant of Windows years ago they needed to\n  provide compatibility with existing 32-bit applications. In order to\n  provide seamless execution regardless of application bitness, the WoW\n  (Windows on Windows) system was coined. This layer, which will be\n  referred to as ‘WOW64’ from here on out, is responsible for\n  translating all Windows API calls from 32-bit userspace to the 64-bit\n  operating system kernel. This blog post is broken up into two\n  sections. First we start by diving deep into the WOW64 system. To do\n  this, we trace a call from 32-bit userspace and follow the steps it\n  takes to finally transition to the kernel. The second part of the post\n  assesses two hooking techniques and their effectiveness. I will cover\n  how this system works, the ways malware abuses it, and detail a\n  mechanism by which all WoW syscalls can be hooked from userspace. Note\n  that all information here is true as of Windows 10, version 2004 and\n  in some cases <i>has</i> changed from how previous Windows versions\n  were implemented.</p>\n <h4>Recognition</h4>\n <p>First and foremost, this is a topic which has existing research by\n  multiple authors. This work was critical in efficient exploration of\n  the internals and research would have taken much longer had these\n  authors not publicly posted their awesome work. I would like to\n  callout the following references:</p>\n <ul> <li>(<a\n    href=\"https://wbenny.github.io/2018/11/04/wow64-internals.html\">wbenny</a>):\n    An extremely detailed view of WOW64 internals on ARM</li> <li>(<a\n    href=\"http://blog.rewolf.pl/blog/?p=102\">ReWolf</a>): A PoC heaven’s\n    gate implementation</li> <li>(<a\n    href=\"https://github.com/JustasMasiulis/wow64pp\">JustasMasiulis</a>):\n    A very clean C++ heaven’s gate implementation</li> <li>(<a\n    href=\"https://www.malwaretech.com/2014/02/the-0x33-segment-selector-heavens-gate.html\">MalwareTech</a>):\n    A WOW64 segmentation explanation</li> </ul>\n <h4>WOW64 Internals</h4>\n <p>To understand how the WOW64 system works internally we will explore\n  the call sequence starting in 32-bit usermode before transitioning\n  into the kernel from within a system DLL. Within these system DLLs the\n  operating system will check arguments and eventually transition to a\n  stub known as a syscall stub. This syscall stub is responsible for\n  servicing the API call in the kernel. On a 64-bit system, the syscall\n  stub is straightforward as it directly executes the syscall\n  instruction as shown in Figure 1.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure2.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 1: Native x64 Syscall Stub</span></p>\n <p>Figure 2 shows a syscall stub for a 32-bit process running on WOW64</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure1.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 2: WOW64 Syscall Stub</span></p>\n <p>Notice that instead of a syscall instruction in the WOW64 version,\n    <span class=\"code\">Wow64SystemServiceCall</span> is called. In the\n  WOW64 system what would normally be an entry into the kernel is\n  instead replaced by a call to a usermode routine. Following this <span\n  class=\"code\">Wow64SystemServiceCall</span>, we can see in Figure 3\n  that it immediately performs an indirect jmp through a pointer named\n    <span class=\"code\">Wow64Transition</span>.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure3.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 3: Wow64SystemService transitions\n    through a pointer ‘Wow64Transition’</span></p>\n <p>Note that the <span class=\"code\">Wow64SystemServiceCall</span>\n  function is found within ntdll labeled as ntdll_77550000; a WOW64\n  process has two ntdll modules loaded, a 32-bit one and a 64-bit one.\n  WinDbg differentiates between these two by placing the address of the\n  module after the 32-bit variant. The 64-bit ntdll can be found in\n  %WINDIR%\\System32 and the 32-bit in %WINDIR%\\SysWOW64. In the PDBs,\n  the 64bit and 32bit ntdlls are referred to as ntdll.pdb and wntdll.pdb\n  respectively, try loading them in a disassembler! Continuing with the\n  call trace, if we look at what the <span\n  class=\"code\">Wow64Transition</span> pointer holds we can see its\n  destination is <span class=\"code\">wow64cpu!KiFastSystemCall</span>. As\n  an aside, note that the address of <span\n  class=\"code\">wow64cpu!KiFastSystemCall</span> is held in the 32-bit\n  TEB (Thread Environment Block) via member WOW32Reserved, this isn’t\n  relevant for this trace but is useful to know. In Figure 4 we see the\n  body of <span class=\"code\">KiFastSystemCall</span>.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure4.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 4: KiFastSystemCall transitions to\n    x64 mode via segment selector 0x33</span></p>\n <p>The <span class=\"code\">KiFastSystemCall</span> performs a jmp using\n  the 0x33 segment selector to a memory location just after the\n  instruction. This 0x33 segment transitions the CPU into 64-bit mode\n  via a GDT entry as described by (MalwareTech).</p>\n <p>Let's recap the trace we've performed to this point. We started from\n  a call in ntdll, NtResumeThread. This function calls the\n  Wow64SystemServiceCall function which then executes the\n  Wow64Transition. The KiFastSystemCall performs the transition from\n  32-bit to 64-bit execution. The flow is shown in Figure 5.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure5.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 5: 32-bit to 64-bit transition</span></p>\n <p>The destination of the CPU transition jump is the 64-bit code show\n  in Figure 6.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure6.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 6: Destination of KiFastSystemCall</span></p>\n <p>Figure 6 shows the first 64-bit instruction we’ve seen executed in\n  this call trace so far. In order to understand it, we need to look at\n  how the WOW64 system initializes itself. For a detailed explanation of\n  this refer to (wbenny). For now, we can look at the important parts in\n    <span class=\"code\">wow64cpu!RunSimulatedCode</span>.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure7.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 7: 64bit registers are saved in RunSimulatedCode</span></p>\n <p>Figure 7 depicts the retrieval of the 64-bit TEB which is used to\n  access Thread Local Storage at slot index 1. Then the moving of a\n  function pointer table into register r15. The TLS data retrieved is an\n  undocumented data structure <span\n  class=\"code\">WOW64_CPURESERVED</span> that contains register data and\n  CPU state information used by the WOW64 layer to set and restore\n  registers across the 32-bit and 64-bit boundaries. Within this\n  structure is the <span class=\"code\">WOW64_CONTEXT</span> structure, <a\n    href=\"https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-wow64_context\">partially\n    documented on the Microsoft website</a>. I have listed both\n  structures at the end of this post. We’ll look at how this context\n  structure is used later, but for our understanding of the jmp earlier\n  all we need to know is that r15 is a function pointer table.</p>\n <p>It’s interesting to note at this point the architecture of the WOW64\n  layer. From the perspective of the 64-bit kernel the execution of\n  32-bit (Wow64) usermode applications is essentially a big while loop.\n  The loop executes x86 instructions in the processor's 32-bit execution\n  mode and occasionally exits the loop to service a system call. Because\n  the kernel is 64-bit, the processor mode is temporarily switched to\n  64-bit, the system call serviced, then the mode switched back and the\n  loop continued where it was paused. One could say the WOW64 layer acts\n  like an emulator where the instructions are instead executed on the\n  physical CPU.</p>\n <p>Going back to the jmp instruction we saw in Figure 6, we now know\n  what is occurring. The instruction jmp [r15 + 0xF8] is equivalent to\n  the C code jmp TurboThunkDispatch[0xF8 / sizeof(uint64_t)]. Looking at\n  the function pointer at this index we can see we’re at the function\n    <span class=\"code\">wow64cpu!CpupReturnFromSimulatedCode</span>\n  (Figure 8).</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure8.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 8: TurboThunk table's last\n    function pointer entry is an exit routine</span></p>\n <p>This routine is responsible for saving the state of the 32-bit\n  registers into the <span class=\"code\">WOW64_CONTEXT</span> structure\n  we mentioned before as well as retrieving the arguments for the\n  syscall. There is some trickiness going on here, so let’s examine this\n  in detail. First a pointer to the stack is moved into r14 via xchg,\n  the value at this location will be the return address from the syscall\n  stub where <span class=\"code\">Wow64SystemServiceCall</span> was\n  called. The stack pointer r14 is then incremented by 4 to get a\n  pointer to where the stack should be reset when it’s time to restore\n  all these context values. These two values are then stored in the\n  context’s EIP and ESP variables respectively. The r14 stack pointer is\n  then incremented one more time to get the location where the __stdcall\n  arguments are (remember stdcall passes all arguments on the stack).\n  This argument array is important for later, remember it. The arguments\n  pointer is moved into r11, so in C this means that r11 is equivalent\n  to an array of stack slots where each slot is an argument uint32_t\n  r11[argCount]. The rest of the registers and EFlags are then saved.</p>\n <p>Once the 32-bit context is saved, the WOW64 layer then calculates\n  the appropriate TurboThunk to invoke by grabbing the upper 16 bits of\n  the syscall number and dispatches to that thunk. Note that at the\n  beginning of this array is the function <span\n  class=\"code\">TurboDispatchJumpAddressEnd</span>, shown in Figure 9,\n  which is invoked for functions that do not support TurboThunks.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure9.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 9: TurboThunk table's first\n    function pointer entry is an entry routine</span></p>\n <p>TurboThunks are described by (wbenny)—read his blog post at this\n  point if you have not. To summarize the post, for functions that have\n  simple arguments with widths &lt;= sizeof(uint32_t) the WOW64 layer\n  will directly widen these arguments to 64 bits via zero or\n  sign-extension and then perform a direct syscall into the kernel. This\n  all occurs within wow64cpu, rather than executing a more complex path\n  detailed as follows. This acts as an optimization. For more complex\n  functions that do not support TurboThunks the <span\n  class=\"code\">TurboDispatchJumpAddressEnd</span> stub is used which\n  dispatches to <span class=\"code\">wow64!SystemServiceEx</span> to\n  perform the system call as shown in Figure 10.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure10.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 10: Complex system calls go\n    through Wow64SystemServiceEx</span></p>\n <p>We’ll look at this routine in a moment as it’s the meat of this blog\n  post, but for now let’s finish this call trace. Once <span\n  class=\"code\">Wow64SystemServiceEx</span> returns from doing the system\n  call the return value in eax is moved into the <span\n  class=\"code\">WOW64_CONTEXT</span> structure and then the 32-bit\n  register states are restored. There’s two paths for this, a common\n  case and a case that appears to exist only to be used by <span\n  class=\"code\">NtContinue</span> and other WOW64 internals. A flag at\n  the start of the <span class=\"code\">WOW64_CPURESERVED</span> structure\n  retrieved from the TLS slot is checked, and controls which restore\n  path to follow as shown in Figure 11.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure11.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 11: CPU state is restored once the\n    system call is done; there’s a simple path and a complex one\n    handling XMM registers</span></p>\n <p>The simpler case will build a jmp that uses the segment selector\n  0x23 to transition back to 32-bit mode after restoring all the saved\n  registers in the <span class=\"code\">WOW64_CONTEXT</span>. The more\n  complex case will additionally restore some segments, xmm values, and\n  the saved registers in the <span class=\"code\">WOW64_CONTEXT</span>\n  structure and then will do an iret to transition back. The common case\n  jmp once built is shown in Figure 12.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure12.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 12: Dynamically built jmp to\n    transition back to 32bit mode</span></p>\n <p>At this point our call trace is complete. The WOW64 layer has\n  transitioned back to 32-bit mode and will continue execution at the\n  ret after <span class=\"code\">Wow64SystemServiceCall</span> in the\n  syscall stub we started with. Now that an understanding of the flow of\n  the WOW64 layer itself is understood, let’s examine the <span\n  class=\"code\">Wow64SystemServiceEx</span> call we glossed over before.</p>\n <p>A little bit into the <span class=\"code\">Wow64SystemServiceEx</span>\n  routine, Figure 13 shows some interesting logic that we will use later.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure13.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 13: Logging routines invoked\n    before and after dispatching the syscalls</span></p>\n <p>The routine starts by indexing into service tables which hold\n  pointers to routines that convert the passed argument array into the\n  wider 64-bit types expected by the regular 64-bit system modules. This\n  argument array is exactly the stack slot that was stored earlier in r14.</p>\n <p>Two calls to the <span class=\"code\">LogService</span> function\n  exist, however these are only called if the DLL\n  %WINDIR%\\system32\\wow64log.dll is loaded and has the exports\n  Wow64LogInitialize, Wow64LogSystemService, Wow64LogMessageArgList, and\n  Wow64LogTerminate. This DLL is not present on Windows by default, but\n  it can be placed there with administrator privileges. </p>\n <p>The next section will detail how this logging DLL can be used to\n  hook syscalls that transition through this wow64layer. Because the\n  logging routine <span class=\"code\">LogService</span> is invoked before\n  and after the syscall is serviced we can achieve a standard looking\n  inline hook style callback function capable of inspecting arguments\n  and return values.</p>\n <h4>Bypassing Inline Hooks</h4>\n <p>As described in this blog post, Windows provides a way for 32-bit\n  applications to execute 64-bit syscalls on a 64-bit system using the\n  WOW64 layer. However, the segmentation switch we noted earlier can be\n  manually performed, and 64-bit shellcode can be written to setup a\n  syscall. This technique is popularly called “Heaven’s Gate”.\n  JustasMasiulis’ work <a\n  href=\"https://github.com/JustasMasiulis/wow64pp/blob/be72557d0bd2e997d985fd9c590529b62de3765b/include/wow64pp.hpp#L727\">call_function64</a>\n  can be used as a reference to see how this may be done in practice\n  (JustasMasiulis). When system calls are performed this way the 32-bit\n  syscall stub that the WOW64 layer uses is completely skipped in the\n  execution chain. This is unfortunate for security products or tracing\n  tools because any inline hooks in-place on these stubs are also\n  bypassed. Malware authors know this and utilize “Heaven’s Gate” as a\n  bypass technique in some cases. Figure 14 and Figure 15 shows the\n  execution flow of a regular syscall stub through the WOW64 layer, and\n  hooked syscall stub where malware utilizes “Heaven’s Gate”.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure14.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 14: NtResumeThread transitioning\n    through the WOW64 layer</span></p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure15b.png\" alt=\"\" />\n  <span class=\"type-XS\">\n    <br /> Figure 15: NtResumeThread inline hook before transitioning\n    through the WOW64 layer</span></p>\n <p>As seen in Figure 15, when using the Heaven’s Gate technique,\n  execution begins <i>after</i> the inline hook and WOW64 layer is done.\n  This is an effective bypass technique, but one that is easy to detect\n  from a lower level such as a driver or hypervisor. The easiest bypass\n  to inline hooks is simply to restore the original function bytes,\n  usually from bytes on disk. Malware such as AgentTesla and Conti has\n  been known to utilize this last evasion technique.</p>\n <h4>Hooking WOW64 via Inline Hooks</h4>\n <p>As a malware analyst being able to detect when samples attempt to\n  bypass the WOW64 layer can be very useful. The obvious technique to\n  detect this is to place inline hooks on the 64-bit syscall stubs as\n  well as the 32-bit syscall stubs. If the 64-bit hook detects an\n  invocation that didn’t also pass through the 32-bit hook, then it’s\n  known that a sample is utilizing Heaven’s Gate. This technique can\n  detect both evasion techniques previously detailed. However, in\n  practice this is very difficult to implement. Looking at the\n  requirements that must be satisfied to hook the 64-bit syscall stub we\n  come up with this list:</p>\n <ol> <li>Install 64-bit hook from a 32-bit module<ul> <li>How do you\n        read/write 64-bit address space from a 32-bit module?</li> </ul>\n  </li> <li>Implement a 64-bit callback from a 32-bit module<ul>\n        <li>Typically, inline hooking uses C functions as callback\n        stubs, but we’re compiling a 32-bit module so we’ll have a\n        32-bit callback instead of the required 64-bit one.</li> </ul>\n  </li> </ol>\n <p>To solve the first challenge ntdll kindly provides the exports <span\n  class=\"code\">NtWow64ReadVirtualMemory64</span>, <span\n  class=\"code\">NtWow64WriteVirtualMemory64</span>, and <span\n  class=\"code\">NtWow64QueryInformationProcess64</span>. Using these it\n  is possible to read memory, write memory, and retrieve the PEB of a\n  64-bit module from a 32-bit process. However, the second challenge is\n  much harder as either shellcode or a JIT will be required to craft a\n  callback stub of the right bitness. In practice ASMJIT may be utilized\n  for this. This is however a very tedious technique to trace a large\n  number of APIs. There are other challenges to this technique as well.\n  For example, in modern Windows 10 the base address of ntdll64 is set\n  to a high 64-bit address rather than a lower 32-bit address as in\n  Windows 7. Due to this, supporting returns from callbacks back up to\n  the original hooked stub and allocating a trampoline within the\n  required memory range is difficult since the standard ret instruction\n  doesn’t have enough bits on the stack to represent the 64-bit return address.</p>\n <p>As an aside, it should be noted that the WOW64 layer contains what\n  is likely a bug when dealing with the <span\n  class=\"code\">NtWow64*</span> functions. These APIs all take a <span\n  class=\"code\">HANDLE</span> as first argument, which <i>should</i> be\n  sign extended to 64-bits. However, this does not occur for these APIs,\n  therefore when using the pseudo handle -1 the call fails with <span\n  class=\"code\">STATUS_INVALID_HANDLE</span>. This bug was introduced in\n  an unknown Windows 10 version. To successfully use these APIs <span\n  class=\"code\">OpenProcess</span> must be used to retrieve a real,\n  positive valued handle.</p>\n <p>I will not be covering the internals of how to inline hook the\n  64-bit syscall stub since this post is already very long. Instead I\n  will show how my hooking library <a\n  href=\"https://github.com/stevemk14ebr/PolyHook_2_0\">PolyHook2</a> can\n  be extended to support cross-architecture hooking using these Windows\n  APIs, and leave the rest as an exercise to the reader. This works\n  because PolyHook’s trampolines are not limited to +-2GB and do not\n  spoil registers. The internals of how <i>that</i> is achieved is a\n  topic for another post. Figure 16 depicts how to overload the C++ API\n  of polyhook to read/write memory using the aforementioned WinAPIs.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure16.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 16: Overloading the memory\n    operations to read/write/protect 64-bit memory</span></p>\n <p>Once these inline hooks are in-place on the 64-bit syscall stubs,\n  any application utilizing Heaven’s Gate will be properly intercepted.\n  This hooking technique is very invasive and complicated and can still\n  be bypassed if a sample was to directly execute a syscall instruction\n  rather than using the 64-bit module’s syscalls stub. Therefore, a\n  driver or hypervisor is more suitable to detect this evasion\n  technique. Instead we can focus on the more common byte restoration\n  evasion techniques and look for a way to hook the WOW64 layer itself.\n  This doesn’t involve assembly modifications at all.</p>\n <h4>Hooking WOW64 via LogService</h4>\n <p>Thinking back to the WOW64 layer’s execution flow we know that all\n  calls which are sent through the <span\n  class=\"code\">Wow64SystemServiceEx</span> routine may invoke the\n  routine <span class=\"code\">Wow64LogSystemService</span> if the logging\n  DLL is loaded. We can utilize this logging DLL and routine to\n  implement hooks which can be written the exact same way as inline\n  hooks, without modifying any assembly.</p>\n <p>The first step to implementing this is to force all API call paths\n  through the <span class=\"code\">Wow64SystemServiceEx</span> routine so\n  that the log routine may be called. Remember earlier that those that\n  support TurboThunks will not take this path. Lucky for us we know that\n  any TurboThunk entry that points to <span\n  class=\"code\">TurboDispatchJumpAddressEnd</span> will take this path.\n  Therefore, by pointing every entry in the TurboThunk table to point at\n  that address, the desired behavior is achieved. Windows kindly\n  implements this patching via <span\n  class=\"code\">wow64cpu!BTCpuTurboThunkControl</span> as shown in Figure 17.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure17.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 17: Patching the TurboThunk table\n    is implemented for us</span></p>\n <p>Note that in previous Windows versions the module which exported\n  this and how it did is different to Windows 10, version 2004. After\n  invoking this patch routine all syscall paths through WOW64 go through\n    <span class=\"code\">Wow64SystemServiceEx</span> and we can focus on\n  crafting a logging DLL that man-in-the-middles (MITMs) all calls.\n  There are a couple of challenges to be considered here:</p>\n <ol> <li>How do we determine which system call is currently occurring\n    from the logging DLL?</li> <li>How are callbacks written? Wow64log\n    is 64-bit DLL, we’d like a 32-bit callback.<ul> <li>Is shellcode\n        required, or can we make nice C style function callbacks?</li>\n    </ul> </li> <li>What APIs may we call? All that’s loaded is 64-bit\n  ntdll.</li> </ol>\n <p>The first concern is rather easy, from within the wow64log DLL we\n  can read the syscall number from the syscall stubs to create a map of\n  number to name. This is possible because syscall stubs always start\n  with the same assembly and the syscall number is at a static offset of\n  0x4. Figure 18 shows how we can then compare the values in this map\n  against the syscall number passed to <span\n  class=\"code\">Wow64LogSystemService</span>’s parameter structure <span class=\"code\">WOW64_LOG_SERVICE</span>.</p>\n <table cellpadding=\"1\" cellspacing=\"0\" border=\"1\"> <tbody>\n    <tr>\n      <td><p>\n          <span class=\"code\">typedef uint32_t* WOW64_ARGUMENTS;<br />\n            struct WOW64_LOG_SERVICE<br />  {<br />        uint64_t\n            BtLdrEntry;<br />        WOW64_ARGUMENTS Arguments;<br />   \n                ULONG ServiceTable;<br />        ULONG\n            ServiceNumber;<br />        NTSTATUS Status;<br />       \n            BOOLEAN PostCall;<br />  };</span></p> <p>\n          <span class=\"code\">EXTERN_C<br />  __declspec(dllexport)<br />\n            NTSTATUS<br />  NTAPI<br />\n            Wow64LogSystemService(WOW64_LOG_SERVICE* service)<br />\n            {<br />       for (uint32_t i = 0; i &lt; LAST_SYSCALL_ID;\n            i++) {<br />          const char* sysname =\n            SysCallMap[i].name;<br />          uint32_t syscallNum =\n            SysCallMap[i].SystemCallNumber;<br />          if\n            (ServiceParameters-&gt;ServiceNumber != syscallNum)<br />   \n                      continue;<br />          //LOG sysname<br />     \n             }<br />  }</span></p> </td> </tr></tbody></table>\n <p>\n  <span class=\"type-XS\">Figure 18: Minimal example of determining which\n    syscall is occurring—in practice the service table must be checked too</span></p>\n <p>Writing callbacks is a bit more challenging. The wow64log DLL is\n  executing in 64-bit mode and we’d like to be able to write callbacks\n  in 32-bit mode since it’s very easy to load additional 32-bit modules\n  into a WOW64 process. The best way to handle this is to write\n  shellcode which is capable of transitioning back to 32-bit mode,\n  execute the callback, then go back to 64-bit mode to continue\n  execution in the wow64log DLL. The segment transitions themselves are\n  rather easy at this point, we know we just need to use 0x23 or 0x33\n  segment selectors when jumping. But we also need to deal with the\n  calling convention differences between 64-bit and 32-bit. Our\n  shellcode will therefore be responsible for moving 64-bit arguments’\n  register/stack slots to the 32-bit arguments register/stack slots.\n  Enforcing that 32-bit callbacks may only be __cdecl makes this easier\n  as all arguments are on the stack and the shellcode has full control\n  of stack layout and cleanup. Figure 19 shows the locations of the\n  arguments for each calling convention. Once the first 4 arguments are\n  relocated all further arguments can be moved in a loop since it’s\n  simply moving stack values into lower slots. This is relatively easy\n  to implement using external masm files in MSVC. Raw bytes will need to\n  be emitted at points rather than using the assembler due to the mix of\n  architectures. Alternatively, GCC or Clang inline assembly could be\n  used. ReWolf’s work achieves the opposite direction of 32-bit -&gt;\n  64-bit and implements the shellcode via msvc inline asm. X64 MSVC\n  doesn’t support this and there are complications with REX prefixes\n  when using that method. It’s nicer to use external masm files and rely\n  on the linker to implement this shellcode.</p>\n <table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" width=\"651\"> <tbody>\n    <tr>\n      <td width=\"163\"><p>\n          <b>Arg Number</b></p> </td> <td width=\"163\" valign=\"top\"><p>\n          <b>Cdecl Location</b></p> </td> <td width=\"196\" valign=\"top\"><p>\n          <b>Fastcall Location</b></p> </td> <td width=\"129\" valign=\"top\"><p>\n          <b>Special Case?</b></p> </td> </tr>\n    <tr>\n      <td width=\"163\" valign=\"top\"><p>0</p> </td> <td width=\"163\"\n          valign=\"top\"><p>[ebp + 8]</p> </td> <td width=\"196\"\n        valign=\"top\"><p>rcx</p> </td> <td width=\"129\"\n        valign=\"top\"><p>Yes</p> </td> </tr>\n    <tr>\n      <td width=\"163\" valign=\"top\"><p>1</p> </td> <td width=\"163\"\n          valign=\"top\"><p>[ebp + 12]</p> </td> <td width=\"196\"\n        valign=\"top\"><p>rdx</p> </td> <td width=\"129\"\n        valign=\"top\"><p>Yes</p> </td> </tr>\n    <tr>\n      <td width=\"163\" valign=\"top\"><p>2</p> </td> <td width=\"163\"\n          valign=\"top\"><p>[ebp + 16]</p> </td> <td width=\"196\"\n        valign=\"top\"><p>r8d</p> </td> <td width=\"129\"\n        valign=\"top\"><p>Yes</p> </td> </tr>\n    <tr>\n      <td width=\"163\" valign=\"top\"><p>3</p> </td> <td width=\"163\"\n          valign=\"top\"><p>[ebp + 20]</p> </td> <td width=\"196\"\n        valign=\"top\"><p>r9d</p> </td> <td width=\"129\"\n        valign=\"top\"><p>Yes</p> </td> </tr>\n    <tr>\n      <td width=\"163\" valign=\"top\"><p>4</p> </td> <td width=\"163\"\n          valign=\"top\"><p>[ebp + 24]</p> </td> <td width=\"196\"\n          valign=\"top\"><p>[rbp + 32 + 8]</p> </td> <td width=\"129\"\n        valign=\"top\"><p>No</p> </td> </tr>\n    <tr>\n      <td width=\"163\" valign=\"top\"><p>5</p> </td> <td width=\"163\"\n          valign=\"top\"><p>[ebp + 28]</p> </td> <td width=\"196\"\n          valign=\"top\"><p>[rbp + 32 + 16]</p> </td> <td width=\"129\"\n        valign=\"top\"><p>No</p> </td> </tr>\n    <tr>\n      <td width=\"163\" valign=\"top\"><p>6</p> </td> <td width=\"163\"\n          valign=\"top\"><p>[ebp + 32]</p> </td> <td width=\"196\"\n          valign=\"top\"><p>[rbp + 32 + 24]</p> </td> <td width=\"129\"\n        valign=\"top\"><p>No</p> </td> </tr></tbody></table>\n <p>\n  <span class=\"type-XS\">Figure 19: Cdecl vs Fastcall argument positions</span></p>\n <p>Once this shellcode is written and wrapped into a nice C++ function,\n  it’s possible for the wow64log DLL to invoke the callback via a simple\n  C style function pointer call shown in Figure 20.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure20.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 20: call_function32 invokes\n    shellcode to call a 32-bit callback from the 64-bit logging DLL</span></p>\n <p>From within the 32-bit callback any desired MITM operations can be\n  performed, but restrictions exist on which APIs are callable. Due to\n  the context saving that the WOW64 layer performs, 32-bit APIs that\n  would re-enter the WOW64 layer may not be called as the context values\n  would be corrupted. We are therefore limited to only APIs that won’t\n  re-enter WOW64, which are those that are exported from the 64-bit\n  ntdll. The <span class=\"code\">NtWriteFile</span> export may be used to\n  easily write to stdout or a file, but we must re-enter the 64-bit\n  execution mode and do the inverse argument mapping as before. This\n  logging routine can be called from within the 32-bit callbacks and is\n  shown in Figure 21 and Figure 22.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure21.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 21: call_function64 invokes\n    shellcode to call the 64bit WriteFile from with the 32bit callback</span></p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure22.png\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 22: 32bit callbacks must log via\n    routines that only call non-reentrant WOW64 APIs</span></p>\n <p>The result is clean looking callback stubs that function exactly how\n  inline hooks might, but with zero assembly modifications required.\n  Arguments can easily be manipulated as well, but the return status may\n  not be modified unless a little stack walk hackery is implemented. The\n  only other consideration is that the wow64log DLL itself needs to be\n  carefully crafted to not build with any CRT mechanisms. The flags\n  required are:</p>\n <ul> <li>Disable CRT with /NODEFAULT LIB (all C APIs now unavailable),\n    set a new entry point name to not init CRT NtDllMain</li>\n    <li>Disable all CRT security routines /GS-</li> <li>Disable C++\n  exceptions</li> <li>Remove default linker libraries, only link\n  ntdll.lib</li> <li>Use extern “C” __declspec(dllimport)\n    &lt;typedef&gt; to link against the correct NtApis</li> </ul>\n <p>An example of a program hooking its own system calls via wow64log\n  inline hooks is shown in Figure 23.</p>\n <p>\n  <img\n    src=\"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure23.gif\" alt=\"\" />\n  <br /> <span class=\"type-XS\">Figure 23: Demonstration of inline hooks\n    in action</span></p>\n <h4>Conclusion</h4>\n <p>Using inline WOW64 hooks, wow64log hooks, and kernel/hypervisor\n  hooks, all techniques of usermode hook evasion can be identified\n  easily and automatically. Detecting which layers of hooks are skipped\n  or bypassed will give insight into which evasion technique is\n  employed. The identifying table is:</p>\n <table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" width=\"624\"> <tbody>\n    <tr>\n      <td width=\"194\" valign=\"top\"><p>\n          <b>Evasion Mode</b></p> </td> <td width=\"87\" valign=\"top\"><p>\n          <b>32bit Inline</b></p> </td> <td width=\"97\" valign=\"top\"><p>\n          <b>wow64Log</b></p> </td> <td width=\"91\" valign=\"top\"><p>\n          <b>64bit Inline</b></p> </td> <td width=\"156\" valign=\"top\"><p>\n          <b>Kernel/Hypervisor</b></p> </td> </tr>\n    <tr>\n      <td width=\"194\" valign=\"top\"><p>Prologue Restore</p> </td> <td\n        width=\"87\" valign=\"top\"><p>❌</p> </td> <td width=\"97\" valign=\"top\"><p>\n          <b>✔</b></p> </td> <td width=\"91\" valign=\"top\"><p>\n          <b>✔</b></p> </td> <td width=\"156\" valign=\"top\"><p>\n          <b>✔</b></p> </td> </tr>\n    <tr>\n      <td width=\"194\" valign=\"top\"><p>Heavens Gate sys-stub</p> </td>\n        <td width=\"87\" valign=\"top\"><p>❌</p> </td> <td width=\"97\"\n        valign=\"top\"><p>❌</p> </td> <td width=\"91\" valign=\"top\"><p>\n          <b>✔</b></p> </td> <td width=\"156\" valign=\"top\"><p>\n          <b>✔</b></p> </td> </tr>\n    <tr>\n      <td width=\"194\" valign=\"top\"><p>Heavens Gate direct syscall</p>\n      </td> <td width=\"87\" valign=\"top\"><p>❌</p> </td> <td width=\"97\"\n        valign=\"top\"><p>❌</p> </td> <td width=\"91\" valign=\"top\"><p>❌</p>\n      </td> <td width=\"156\" valign=\"top\"><p>\n          <b>✔</b></p> </td> </tr></tbody></table>\n <h4>Structure Appendix</h4>\n <p>\n  <span class=\"code\">struct _WOW64_CPURESERVED<br />  {<br />    USHORT\n    Flags;<br />    USHORT MachineType;<br />    WOW64_CONTEXT\n    Context;<br />    char ContextEx[1024];<br />  };</span></p>\n <p>\n  <span class=\"code\">typedef ULONG *WOW64_LOG_ARGUMENTS;<br />  struct\n    _WOW64_SYSTEM_SERVICE<br />  {<br />    unsigned __int32\n    SystemCallNumber : 12;<br />    unsigned __int32 ServiceTableIndex :\n    4;<br />    unsigned __int32 TurboThunkNumber : 5;<br />    unsigned\n    __int32 AlwaysZero : 11;<br />  };<br />  #pragma pack(push,\n    1)<br />  struct _WOW64_FLOATING_SAVE_AREA<br />  {<br />    DWORD\n    ControlWord;<br />    DWORD StatusWord;<br />    DWORD\n    TagWord;<br />    DWORD ErrorOffset;<br />    DWORD\n    ErrorSelector;<br />    DWORD DataOffset;<br />    DWORD\n    DataSelector;<br />    BYTE RegisterArea[80];<br />    DWORD\n    Cr0NpxState;<br />  };<br />  #pragma pack(pop)</span></p>\n <p>\n  <span class=\"code\">#pragma pack(push, 1)<br />  struct\n    _WOW64_CONTEXT<br />  {<br />    DWORD ContextFlags;<br />    DWORD\n    Dr0;<br />    DWORD Dr1;<br />    DWORD Dr2;<br />    DWORD\n    Dr3;<br />    DWORD Dr6;<br />    DWORD Dr7;<br />   \n    WOW64_FLOATING_SAVE_AREA FloatSave;<br />    DWORD SegGs;<br />   \n    DWORD SegFs;<br />    DWORD SegEs;<br />    DWORD SegDs;<br />   \n    DWORD Edi;<br />    DWORD Esi;<br />    DWORD Ebx;<br />    DWORD\n    Edx;<br />    DWORD Ecx;<br />    DWORD Eax;<br />    DWORD\n    Ebp;<br />    DWORD Eip;<br />    DWORD SegCs;<br />    DWORD\n    EFlags;<br />    DWORD Esp;<br />    DWORD SegSs;<br />    BYTE\n    ExtendedRegistersUnk[160];<br />    M128A Xmm0;<br />    M128A\n    Xmm1;<br />    M128A Xmm2;<br />    M128A Xmm3;<br />    M128A\n    Xmm4;<br />    M128A Xmm5;<br />    M128A Xmm6;<br />    M128A\n    Xmm7;<br />    M128A Xmm8;<br />    M128A Xmm9;<br />    M128A\n    Xmm10;<br />    M128A Xmm11;<br />    M128A Xmm12;<br />    M128A\n    Xmm13;<br />    M128A Xmm14;<br />    M128A Xmm15;<br />  };<br />\n    #pragma pack(pop)</span></p>\n","descriptionType":"html","publishedDate":"Mon, 09 Nov 2020 19:00:00 +0000","feedId":6165,"bgimg":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure2.png","linkMd5":"29ddb8ddc4d0604695fcc4f554dd4736","destWidth":678,"destHeight":150,"sourceBytes":7533,"destBytes":17476,"author":"Stephen Eckels","articleImgCdnMap":{"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure2.png":null,"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure1.png":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn77@2020_6/2020/11/12/05-06-13-080_0062b95be3732f79.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure3.png":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn49@2020_4/2020/11/12/05-06-13-031_af12ab72904ca814.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure4.png":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn41@2020_4/2020/11/12/05-06-13-084_7119542557248c4c.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure5.png":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn34@2020_1/2020/11/12/05-06-12-998_83db628f370e12a7.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure6.png":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn26@2020_5/2020/11/12/05-06-12-985_1f1e4cdc9a3e5d13.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure7.png":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn18@2020_1/2020/11/12/05-06-13-106_b2f2369f14f8bef4.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure8.png":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn14@2020_1/2020/11/12/05-06-12-989_3c12cbd5a5b69d77.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure9.png":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn9@2020_1/2020/11/12/05-06-12-951_3ce83e1a9b0d43d7.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure10.png":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn5@2020_2/2020/11/12/05-06-12-957_4fc1ff7c85632e57.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure11.png":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn89@2020_5/2020/11/12/05-06-13-080_139676edd1d5ee80.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure12.png":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn81@2020_4/2020/11/12/05-06-12-914_5f463e21a7574d3e.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure13.png":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn97@2020_5/2020/11/12/05-06-13-110_efad0f77fa77e891.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure14.png":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn93@2020_4/2020/11/12/05-06-13-008_1f12ce86519fb3be.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure15b.png":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn21@2020_1/2020/11/12/05-06-13-164_cfb33bdfa7a281fc.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure16.png":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn38@2020_6/2020/11/12/05-06-13-978_71c0b8b946121d14.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure17.png":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn45@2020_2/2020/11/12/05-06-12-912_93d905f2d29e6194.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure20.png":null,"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure21.png":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn85@2020_2/2020/11/12/05-06-13-041_e19de08e5463373f.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure22.png":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn1@2020_4/2020/11/12/05-06-13-065_31c7c1264e7f7508.webp","https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure23.gif":"https://cdn.jsdelivr.net/gh/myreaderx/cdn29@2020_6/2020/11/12/05-07-31-983_8bbf6e16e5145225.webp"},"publishedOrCreatedDate":1605157572103}],"record":{"createdTime":"2020-11-12 13:06:12","updatedTime":"2020-11-12 13:06:12","feedId":6165,"fetchDate":"Thu, 12 Nov 2020 05:06:12 +0000","fetchMs":546,"handleMs":286,"totalMs":83612,"newArticles":0,"totalArticles":100,"status":1,"type":0,"ip":"ac489040e066f721b0d0c3774cf6c214","hostName":"us-030*","requestId":"d8bcef30217847e9a08793da83700f33_6165","contentType":"application/atom+xml","totalBytes":4582086,"bgimgsTotal":1,"bgimgsGithubTotal":0,"articlesImgsTotal":21,"articlesImgsGithubTotal":19,"successGithubMap":{"myreaderx8":1,"myreaderx25":1,"myreaderx7":1,"myreaderx15":1,"myreaderx16":1,"myreaderx6":1,"myreaderx10":1,"myreaderx4":1,"myreaderx32":1,"myreaderx11":1,"myreaderx33":1,"myreaderx22":1,"myreaderx3":1,"myreaderx2":1,"myreaderx12":1,"myreaderx31":1,"myreaderx18":1,"myreaderx19":1,"myreaderx":1},"failGithubMap":{"myreaderx14":1,"myreaderx23":1}},"feed":{"createdTime":"2020-08-25 04:32:51","updatedTime":"2020-09-01 11:26:17","id":6165,"name":"Threat Research","url":"https://www.fireeye.com/blog/threat-research/_jcr_content.feed","subscriber":null,"website":null,"icon":"http://www.fireeye.com/content/dam/fireeye-www/fw/images/fireeye.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx61/cdn27@2020_4/2020/09/01/03-26-17-596_ef516858c02d2a62.png","description":"Technical review and analysis of malware and TTPs from FireEye engagements.","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2020-11-12 13:07:34","updatedTime":"2020-11-12 13:07:34","id":null,"feedId":6165,"linkMd5":"29ddb8ddc4d0604695fcc4f554dd4736"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":4582086,"tmpBgImgCdnBytes":0,"extra4":{"start":1605157570935,"total":0,"statList":[{"spend":888,"msg":"获取xml内容"},{"spend":286,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":81739,"msg":"正文链接上传到cdn"}]},"extra5":21,"extra6":21,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure2.png","sourceStatusCode":200,"destWidth":678,"destHeight":150,"sourceBytes":7533,"destBytes":17476,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":380,"convertSpendMs":8,"createdTime":"2020-11-12 13:06:12","host":"us-012*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736,29ddb8ddc4d0604695fcc4f554dd4736","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn67/contents/2020/11/12/05-06-12-562_f7b3480af5dcb4b3.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Thu, 12 Nov 2020 05:06:12 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["ABE4:291B:11E01AA:1E5FB01:5FACC2C4"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1605160176"],"x-ratelimit-used":["64"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn67/contents/2020/11/12/05-06-12-562_f7b3480af5dcb4b3.webp","historyStatusCode":[],"spendMs":39},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"7.4 KB","destSize":"17.1 KB","compressRate":"232%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure2.png","sourceStatusCode":200,"destWidth":678,"destHeight":150,"sourceBytes":7533,"destBytes":17476,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":166,"convertSpendMs":10,"createdTime":"2020-11-12 13:06:12","host":"us-012*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736,29ddb8ddc4d0604695fcc4f554dd4736","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn67/contents/2020/11/12/05-06-12-737_f7b3480af5dcb4b3.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Thu, 12 Nov 2020 05:06:12 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["ABE4:291B:11E01C4:1E5FB13:5FACC2C4"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1605160176"],"x-ratelimit-used":["64"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn67/contents/2020/11/12/05-06-12-737_f7b3480af5dcb4b3.webp","historyStatusCode":[],"spendMs":43},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"7.4 KB","destSize":"17.1 KB","compressRate":"232%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure20.png","sourceStatusCode":200,"destWidth":1001,"destHeight":151,"sourceBytes":15524,"destBytes":11164,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":354,"convertSpendMs":33,"createdTime":"2020-11-12 13:06:12","host":"us-001*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn74/contents/2020/11/12/05-06-12-983_2ac9918517d1a86f.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Thu, 12 Nov 2020 05:06:13 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["8D4C:170B:434C64:B56B5D:5FACC2B6"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1605160176"],"x-ratelimit-used":["66"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn74/contents/2020/11/12/05-06-12-983_2ac9918517d1a86f.webp","historyStatusCode":[],"spendMs":45},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"15.2 KB","destSize":"10.9 KB","compressRate":"71.9%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure20.png","sourceStatusCode":200,"destWidth":1001,"destHeight":151,"sourceBytes":15524,"destBytes":11164,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":396,"convertSpendMs":218,"createdTime":"2020-11-12 13:06:13","host":"us-001*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn74/contents/2020/11/12/05-06-13-525_2ac9918517d1a86f.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Thu, 12 Nov 2020 05:06:13 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["8D4C:170B:434C6A:B5717A:5FACC2C5"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1605160176"],"x-ratelimit-used":["66"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn74/contents/2020/11/12/05-06-13-525_2ac9918517d1a86f.webp","historyStatusCode":[],"spendMs":84},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"15.2 KB","destSize":"10.9 KB","compressRate":"71.9%"},null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-013.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-56.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe68.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-021.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-005.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-034.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-009.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-60.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-52.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-038.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-025.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://us-001.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-017.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe64.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://europe-22.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-029.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure17.png","sourceStatusCode":200,"destWidth":402,"destHeight":108,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn45@2020_2/2020/11/12/05-06-12-912_93d905f2d29e6194.webp","sourceBytes":4727,"destBytes":8258,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":863,"convertSpendMs":13,"createdTime":"2020-11-12 13:06:12","host":"us-52*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"4.6 KB","destSize":"8.1 KB","compressRate":"174.7%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure10.png","sourceStatusCode":200,"destWidth":447,"destHeight":105,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn5@2020_2/2020/11/12/05-06-12-957_4fc1ff7c85632e57.webp","sourceBytes":9453,"destBytes":9790,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":785,"convertSpendMs":6,"createdTime":"2020-11-12 13:06:12","host":"us-034*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"9.2 KB","destSize":"9.6 KB","compressRate":"103.6%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure9.png","sourceStatusCode":200,"destWidth":629,"destHeight":70,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn9@2020_1/2020/11/12/05-06-12-951_3ce83e1a9b0d43d7.webp","sourceBytes":5422,"destBytes":7468,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":807,"convertSpendMs":7,"createdTime":"2020-11-12 13:06:12","host":"us-021*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"5.3 KB","destSize":"7.3 KB","compressRate":"137.7%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure12.png","sourceStatusCode":200,"destWidth":644,"destHeight":19,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn81@2020_4/2020/11/12/05-06-12-914_5f463e21a7574d3e.webp","sourceBytes":1934,"destBytes":3154,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":883,"convertSpendMs":6,"createdTime":"2020-11-12 13:06:12","host":"us-52*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"1.9 KB","destSize":"3.1 KB","compressRate":"163.1%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure3.png","sourceStatusCode":200,"destWidth":606,"destHeight":34,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn49@2020_4/2020/11/12/05-06-13-031_af12ab72904ca814.webp","sourceBytes":2972,"destBytes":5060,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":857,"convertSpendMs":62,"createdTime":"2020-11-12 13:06:12","host":"us-029*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"2.9 KB","destSize":"4.9 KB","compressRate":"170.3%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure5.png","sourceStatusCode":200,"destWidth":982,"destHeight":576,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn34@2020_1/2020/11/12/05-06-12-998_83db628f370e12a7.webp","sourceBytes":14951,"destBytes":25804,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":893,"convertSpendMs":20,"createdTime":"2020-11-12 13:06:12","host":"us-013*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"14.6 KB","destSize":"25.2 KB","compressRate":"172.6%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure6.png","sourceStatusCode":200,"destWidth":205,"destHeight":23,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn26@2020_5/2020/11/12/05-06-12-985_1f1e4cdc9a3e5d13.webp","sourceBytes":1304,"destBytes":1236,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":921,"convertSpendMs":3,"createdTime":"2020-11-12 13:06:12","host":"us-038*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"1.3 KB","destSize":"1.2 KB","compressRate":"94.8%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure8.png","sourceStatusCode":200,"destWidth":463,"destHeight":239,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn14@2020_1/2020/11/12/05-06-12-989_3c12cbd5a5b69d77.webp","sourceBytes":19309,"destBytes":25628,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":907,"convertSpendMs":9,"createdTime":"2020-11-12 13:06:12","host":"us-009*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.9 KB","destSize":"25 KB","compressRate":"132.7%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure14.png","sourceStatusCode":200,"destWidth":1269,"destHeight":338,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn93@2020_4/2020/11/12/05-06-13-008_1f12ce86519fb3be.webp","sourceBytes":40171,"destBytes":65638,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":1003,"convertSpendMs":48,"createdTime":"2020-11-12 13:06:12","host":"us-005*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"39.2 KB","destSize":"64.1 KB","compressRate":"163.4%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure21.png","sourceStatusCode":200,"destWidth":1221,"destHeight":170,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn85@2020_2/2020/11/12/05-06-13-041_e19de08e5463373f.webp","sourceBytes":23692,"destBytes":17212,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":1053,"convertSpendMs":70,"createdTime":"2020-11-12 13:06:12","host":"us-029*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23.1 KB","destSize":"16.8 KB","compressRate":"72.6%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure1.png","sourceStatusCode":200,"destWidth":592,"destHeight":108,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn77@2020_6/2020/11/12/05-06-13-080_0062b95be3732f79.webp","sourceBytes":5140,"destBytes":9962,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":1119,"convertSpendMs":8,"createdTime":"2020-11-12 13:06:12","host":"europe64*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"5 KB","destSize":"9.7 KB","compressRate":"193.8%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure11.png","sourceStatusCode":200,"destWidth":1007,"destHeight":1033,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn89@2020_5/2020/11/12/05-06-13-080_139676edd1d5ee80.webp","sourceBytes":121369,"destBytes":109178,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":1174,"convertSpendMs":94,"createdTime":"2020-11-12 13:06:12","host":"us-017*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"118.5 KB","destSize":"106.6 KB","compressRate":"90%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure4.png","sourceStatusCode":200,"destWidth":330,"destHeight":36,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn41@2020_4/2020/11/12/05-06-13-084_7119542557248c4c.webp","sourceBytes":1622,"destBytes":4248,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":1071,"convertSpendMs":5,"createdTime":"2020-11-12 13:06:13","host":"europe64*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"1.6 KB","destSize":"4.1 KB","compressRate":"261.9%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure7.png","sourceStatusCode":200,"destWidth":471,"destHeight":223,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn18@2020_1/2020/11/12/05-06-13-106_b2f2369f14f8bef4.webp","sourceBytes":9945,"destBytes":10194,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":1078,"convertSpendMs":7,"createdTime":"2020-11-12 13:06:13","host":"europe-22*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"9.7 KB","destSize":"10 KB","compressRate":"102.5%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure22.png","sourceStatusCode":200,"destWidth":887,"destHeight":170,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn1@2020_4/2020/11/12/05-06-13-065_31c7c1264e7f7508.webp","sourceBytes":18823,"destBytes":13666,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":1123,"convertSpendMs":8,"createdTime":"2020-11-12 13:06:12","host":"europe-56*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.4 KB","destSize":"13.3 KB","compressRate":"72.6%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure13.png","sourceStatusCode":200,"destWidth":851,"destHeight":214,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn97@2020_5/2020/11/12/05-06-13-110_efad0f77fa77e891.webp","sourceBytes":12906,"destBytes":20418,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":1139,"convertSpendMs":10,"createdTime":"2020-11-12 13:06:13","host":"europe68*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12.6 KB","destSize":"19.9 KB","compressRate":"158.2%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure15b.png","sourceStatusCode":200,"destWidth":1584,"destHeight":744,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn21@2020_1/2020/11/12/05-06-13-164_cfb33bdfa7a281fc.webp","sourceBytes":217659,"destBytes":44610,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":1341,"convertSpendMs":51,"createdTime":"2020-11-12 13:06:13","host":"europe-60*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"212.6 KB","destSize":"43.6 KB","compressRate":"20.5%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure16.png","sourceStatusCode":200,"destWidth":1404,"destHeight":1204,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn38@2020_6/2020/11/12/05-06-13-978_71c0b8b946121d14.webp","sourceBytes":184423,"destBytes":116682,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":2595,"convertSpendMs":928,"createdTime":"2020-11-12 13:06:12","host":"us-001*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"180.1 KB","destSize":"113.9 KB","compressRate":"63.3%"},{"code":1,"isDone":false,"source":"https://www.fireeye.com/content/dam/fireeye-www/blog/images/wowhooks/figure23.gif","sourceStatusCode":200,"destWidth":2419,"destHeight":1081,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn29@2020_6/2020/11/12/05-07-31-983_8bbf6e16e5145225.webp","sourceBytes":3632674,"destBytes":4083880,"targetWebpQuality":75,"feedId":6165,"totalSpendMs":21283,"convertSpendMs":18601,"createdTime":"2020-11-12 13:07:13","host":"europe-60*","referer":"http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html","linkMd5ListStr":"29ddb8ddc4d0604695fcc4f554dd4736","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"3.5 MB","destSize":"3.9 MB","compressRate":"112.4%"}],"successGithubMap":{"myreaderx8":1,"myreaderx25":1,"myreaderx7":1,"myreaderx15":1,"myreaderx16":1,"myreaderx6":1,"myreaderx10":1,"myreaderx4":1,"myreaderx32":1,"myreaderx11":1,"myreaderx33":1,"myreaderx22":1,"myreaderx3":1,"myreaderx2":1,"myreaderx12":1,"myreaderx31":1,"myreaderx18":1,"myreaderx19":1,"myreaderx":1},"failGithubMap":{"myreaderx14":1,"myreaderx23":1}}