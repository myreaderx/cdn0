{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-08-23 12:46:01","updatedTime":"2020-08-23 12:46:01","title":"QUIC 协议详解之 Initial 包的处理","link":"https://toutiao.io/k/5fht3f0","description":"<div><div><div class=\"RichText ztext Post-RichText\"><p>本文介绍了在 QUIC 服务器在收到 QUIC 客户端发起的第一个 UDP 请求— Initial 数据包的分析、处理和解密过程，涉及Initial数据包的格式，数据包头部保护的去除， Packet Number 的计算，负载数据的解密，client hello 的解析，等等。本文的 C 实现采用 OpenSSL，并基于 IETFQUIC Draft-27。</p><h2><b>术语</b></h2><p><b>PacketNumber</b> ：数据包序号</p><p><b>Initial Packet</b>：初始数据包</p><p><b>Variable-length Integer Encode</b>：可变长度整型编码</p><p><b>HMAC</b>：Hash-based messageauthencation code，基于 Hash 的验证信息码</p><p><b>HKDF</b>: HMAC-based Extract-and-Expand KeyDerivation Function，基于 HMAC 的提取扩展密钥衍生函数</p><p><b>AEAD</b>: authenticated encryption withassociated data, 带有关联数据的认证加密</p><p><b>ECB</b>: Electronic codebook，电子密码本</p><p><b>GCM</b>: Galois/Counter Mode，伽罗瓦/计数器模式</p><p><b>IV</b>: InitialVector, 初始化向量</p><h2><b>基本概念介绍</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ef3060e936c63cf5813fd57c57039535_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"820\" data-rawheight=\"602\" class=\"origin_image zh-lightbox-thumb\" data-original=\"https://pic1.zhimg.com/v2-ef3060e936c63cf5813fd57c57039535_r.jpg\"/></noscript><img src=\"\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"820\" data-rawheight=\"602\" class=\"origin_image zh-lightbox-thumb lazy\" data-original=\"https://pic1.zhimg.com/v2-ef3060e936c63cf5813fd57c57039535_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ef3060e936c63cf5813fd57c57039535_b.jpg\"/></figure><p><b>Initial 数据包的结构</b></p><p>Initial 包是长头部结构的数据包，结构如图 3.1 所示，在 CRYPTO 帧后面需要跟上 PADDING 帧，这是 QUIC 协议预防 UDP 攻击的手段之一。一般情况下，CRYPTO 帧太短了（确实也有比较长“一锅炖不下”的情况，可参阅 QTS-TLS 4.3节），服务端为了响应 CRYPTO， 必须发送数据长度大得多的握手包（Handshake Packet），这样就会造成所谓的反射攻击。</p><p>QUIC 使用三种方法来抑制此类攻击：</p><ul><li>含有 ClientHello 的数据包必须使用 PADDING 帧，达到协议要求的最小数据长度 1200 字节；</li><li>当服务端响应未经验证原地址的请求，第一次（firstflight）发送数据时，不允许发送超过三个 UDP 数据报的数据；</li><li>确认握手包是带验证的，盲攻击者无法伪造。</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">typedef struct {\n  uint8_t flag;\n  uint32_t version;\n  uint8_t dcid_length;\n  uint8_t *dcid;\n  uint8_t scid_length;\n  uint8_t *scid;\n  uint64_t token_length;\n  uint8_t *token;\n  uint64_t packet_length;\n  uint8_t *payload;} quic_long_header_packet_t;</code></pre></div><p><b>Packet Number 三种上下文空间</b></p><p>Packet Number 为整型变量，其值在 0 到 2^62-1 之间，它也用于生成数据包加密所需的 nonce。通讯双方维护各自的 Packet Number 体系， 并且分为三个独立的上下文空间：</p><ul><li>Initial 空间：所有的 Initial 数据包的 Packet Number 均在这个上下文空间里；</li><li>Handshake 空间：所有的握手数据包；</li><li>应用数据空间：所有的 0-RTT 和 1-RTT 包。</li></ul><p>所谓的 Packet Number 空间，指得是一种上下文关系，在这个上下文关系里，数据包被处理，被确认。换言之，初始数据包只能使用初始数据包专用的密钥，也只能确认初始数据包。类似的， 握手包只能使用握手包专用的密钥，也只能确认握手数据包。从 Initial 阶段进入 Handshake 阶段后， Initial 阶段使用的密钥就可以被丢弃了，Packet Number 也重新从 0 开始编号。</p><p>0-RTT 和 1-RTT 共享同一个 Packet Number 空间，这样做是为了更容易实现这两类数据包的丢包处理算法。</p><p>在同一连接同一个 Packet Number 空间里，你不能复用包号，包号必须是单调递增的，当然，具体实现的时候草案并不强制要求每次都递增1， 你可以递增 20，30。当 Packet Number 达到 2^62 -1 时，发送方必须关闭该连接。</p><p>通讯过程 Packet Number 的处理还有许多细节，比如重复抑制问题，这部分可以参考 QUIC-TLS 部分以及 RFC4303 的 3.4.3 节，这里就不深入展开讨论。</p><p><b>HKDF：基于 HMAC 的密钥衍生函数</b></p><p>密钥衍生函数（KDF）是加密系统最为基本核心的组件，它将初始密钥作为输入，生成一个或多个足够健壮的加密密钥。</p><p>HKDF 的提出一方面是为了给其他协议和应用程序提供基本的功能块，同时也为了解决各种不同机制的密钥衍生函数实现的激增问题。它采用“先提取再扩展（extract-and-expand）”的设计方式，逻辑上，一般采用两个步骤来完成密钥衍生。第一步，将输入的字符转换成固定长度的伪随机密钥。第二步，将其扩展成若干个伪随机密钥。一般人们把通过 Diffie-Hellman 交换的共享密文转换为指定长度的密钥，用于加密，完整性检查以及验证。具体原理可参考 RFC5869。</p><p><b>可变长度整型编码</b></p><p>QUIC 协议中大量使用可变长度整型编码，用首字节的高 2 位来表示数据的长度，编码规则如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a4a475b889dc6fac455fec0bb2389019_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1426\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb\" data-original=\"https://pic3.zhimg.com/v2-a4a475b889dc6fac455fec0bb2389019_r.jpg\"/></noscript><img src=\"\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1426\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb lazy\" data-original=\"https://pic3.zhimg.com/v2-a4a475b889dc6fac455fec0bb2389019_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a4a475b889dc6fac455fec0bb2389019_b.jpg\"/></figure><p>举个例子：</p><p>0b00000011 01011110，0x035e =&gt; 2Bit=00，代表长度为 1，可用位数 6， 所以，Value = 3</p><p>0b01011001 01011110，0x595e =&gt; 2Bit=01，代表长度为 2，可用位数 14，所以，Value = 6494</p><p>代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">uint64_t Buffer_pull_uint_var(upai_buffer_t *buf, ssize_t *size)\n  {\n    CK_RD_BOUNDS(buf, 1)\n    uint64_t value;\n    switch (*(buf-&gt;pos) &gt;&gt; 6) {\n    case 0:\n        value = *(buf-&gt;pos++) &amp; 0x3F;\n        if (size != NULL) *size = 1;\n        break;\n    case 1:\n        CK_RD_BOUNDS(buf, 2)\n        value = (uint16_t)(*(buf-&gt;pos) &amp; 0x3F) &lt;&lt; 8 |\n                (uint16_t)(*(buf-&gt;pos + 1));\n        buf-&gt;pos += 2;\n        if (size != NULL) *size = 2;\n        break;\n    case 2:\n        CK_RD_BOUNDS(buf, 4)\n        value = (uint32_t)(*(buf-&gt;pos) &amp; 0x3F) &lt;&lt; 24 |\n                (uint32_t)(*(buf-&gt;pos + 1)) &lt;&lt; 16 |\n                (uint32_t)(*(buf-&gt;pos + 2)) &lt;&lt; 8 |\n                (uint32_t)(*(buf-&gt;pos + 3));\n        buf-&gt;pos += 4;\n        if (size != NULL) *size = 4;\n        break;\n\n    default:\n        CK_RD_BOUNDS(buf, 8)\n        value = (uint64_t)(*(buf-&gt;pos) &amp; 0x3F) &lt;&lt; 56 |\n                (uint64_t)(*(buf-&gt;pos + 1)) &lt;&lt; 48 |\n                (uint64_t)(*(buf-&gt;pos + 2)) &lt;&lt; 40 |\n                (uint64_t)(*(buf-&gt;pos + 3)) &lt;&lt; 32 |\n                (uint64_t)(*(buf-&gt;pos + 4)) &lt;&lt; 24 |\n                (uint64_t)(*(buf-&gt;pos + 5)) &lt;&lt; 16 |\n                (uint64_t)(*(buf-&gt;pos + 6)) &lt;&lt; 8 |\n                (uint64_t)(*(buf-&gt;pos + 7));\n        buf-&gt;pos += 8;\n        if (size != NULL) *size = 8;\n        break;\n    }\n    return value;}</code></pre></div><h2><b>Initial 包的处理过程</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f6b31f5caf6144c2095a1d00a6edb9c2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"602\" class=\"origin_image zh-lightbox-thumb\" data-original=\"https://pic3.zhimg.com/v2-f6b31f5caf6144c2095a1d00a6edb9c2_r.jpg\"/></noscript><img src=\"\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"602\" class=\"origin_image zh-lightbox-thumb lazy\" data-original=\"https://pic3.zhimg.com/v2-f6b31f5caf6144c2095a1d00a6edb9c2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f6b31f5caf6144c2095a1d00a6edb9c2_b.jpg\"/></figure><p><b>头部明文信息解析</b></p><p>这部分比较简单，直接上代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">uapi_err_t pull_quic_header(upai_buffer_t *buf, quic_header_packet_t *header){\n    int32_t retcode = 0;\n    CK_RET(Buffer_pull_uint8(buf, &amp;(header-&gt;flag)),\n        UPAI_ERR_HEADER|1))\n\n    header-&gt;is_long_header = (header-&gt;flag &amp; PACKET_LONG_HEADER) == 0 ? -1 : 1;\n\n    if (header-&gt;is_long_header &gt; 0) {\n        CK_RET(Buffer_pull_uint32(buf, &amp;(header-&gt;version)),\n            UPAI_ERR_HEADER|2)\n        CK_RET(Buffer_pull_uint8(buf, &amp;(header-&gt;dcid_length)),\n            UPAI_ERR_HEADER|3)\n        CK_RET(Buffer_pull_bytes(buf, header-&gt;dcid_length, \n            &amp;(header-&gt;dcid)),\n            UPAI_ERR_HEADER|4)\n        CK_RET(Buffer_pull_uint8(buf, &amp;(header-&gt;scid_length)),\n            UPAI_ERR_HEADER|5)\n        CK_RET(Buffer_pull_bytes(buf, header-&gt;scid_length , \n            &amp;(header-&gt;scid)),\n            UPAI_ERR_HEADER|6)\n\n        if (header-&gt;version == PROTO_NEGOTIATION) {\n            header-&gt;packet_type = 0;\n        } else {\n            header-&gt;packet_type = header-&gt;flag &amp; PACKET_TYPE_MASK;\n        }\n\n        if (header-&gt;packet_type == PACKET_TYPE_INITIAL) {\n            CK_RET(Buffer_pull_uint_var(buf, NULL, \n                &amp;(header-&gt;token_length)),\n                UPAI_ERR_HEADER|7)\n            CK_RET(Buffer_pull_bytes(buf, header-&gt;token_length, \n                &amp;(header-&gt;token)),\n                UPAI_ERR_HEADER|8)\n            CK_RET(Buffer_pull_uint_var(buf, NULL, \n                &amp;(header-&gt;packet_length)),\n                UPAI_ERR_HEADER|9)\n\n            header-&gt;packet_number_offset = buffer_tell(buf);\n\n            CK_RET(Buffer_pull_bytes(buf, header-&gt;packet_length, \n                &amp;(header-&gt;payload)),\n                UPAI_ERR_HEADER|10)\n        } else if (header-&gt;packet_type == PACKET_TYPE_RETRY) {\n\n            //TODO: deal with retry packet parsing\n\n        } else {\n            CK_RET(Buffer_pull_uint_var(buf, NULL, \n                &amp;(header-&gt;packet_length)),\n                UPAI_ERR_HEADER|11)\n            CK_RET(Buffer_pull_bytes(buf, header-&gt;packet_length, \n                &amp;(header-&gt;payload)),\n                UPAI_ERR_HEADER|12)\n        }\n    } else {\n\n        //TODO: short header parse\n\n    }\n    return UPAI_RES_OK;}</code></pre></div><p><b>生成 KEY, IV, HP</b></p><p>QUIC 协议定义了 4 组加密密钥集，对应四个不同的加密层级，这与 Packet Number 空间有类似的意思，他们是：</p><ul><li>Initial 密钥集</li><li>Early Data（0-RTT）密钥集</li><li>Handshake，握手密钥集</li><li>Application Data（1-RTT），应用数据密钥集</li></ul><p>QUIC 的 CRYPTO 帧和 TCP 上的 TLS 最大不不同点在于，一个 QUIC 数据包里可能含有多个数据帧，协议规范本身也要求，只要在同一加密密钥层里，一个数据包就应该尽可能的多放入数据帧。</p><p>解密 Initial 数据包，使用的便是 Initial 密钥集。进入某个加密层级，需要三样东西：</p><p>QUIC 的 Initial 包的初始机密（Initial secrets）同版本号，目标 Connection ID 相关，加密算法固定为 AES-128-GCM，Initial secrets 的提取方式如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">uint32_t algorithm_digest_size = _get_algorithm_digest_size(ctx-&gt;cipher_name);//SHA256的长度是32\nconst uint8_t initial_salt_d27 []= {0xc3,0xee,0xf7,0x12,\n                       0xc7,0x2e,0xbb,0x5a,\n                       0x11,0xa7,0xd2,0x43,\n                       0x2b,0xb4,0x63,0x65,\n                       0xbe,0xf9,0xf5,0x02};//Draft-27的salt\nuint8_t *initial_secrets = (uint8_t *)upai_mem_pool_alloc(algorithm_digest_size);\nret = upai_HKDF_Extract(_get_hash_method(ctx-&gt;cipher_name), //SHA256\n    initial_salt_d27, \n    sizeof(initial_salt_d27), \n    initial_packet.dcid, \n    initial_packet.dcid_length, \n    initial_secrets);\nCK_KG_RET(ret, UPAI_KG_ERR | 1)</code></pre></div><p>提取出 Initial Secrets 之后，便是扩展出 Key，IV 和 HP 了，在这之前，于服务端，需要先扩展出接收机密（receive secrets），需要用“client in”作为标签。标签函数大致长这样：</p><div class=\"highlight\"><pre><code class=\"language-text\">static uapi_err_tupai_hkdf_label(\n    upai_memory_pool_t *m,\n    const uint8_t * label,\n    uint32_t sz_label,\n    const uint8_t * hash_value,\n    uint32_t sz_hash_value,\n    uint32_t sz,\n    uint8_t **out,\n    uint32_t *sz_out){\n    uint32_t full_size = 10 + sz_label + sz_hash_value;\n    if (sz_out != NULL)\n        *sz_out = full_size;\n    *out = (uint8_t *)upai_mem_pool_alloc(m, full_size);\n    (*out)[0] = (uint8_t)((uint16_t)(sz &gt;&gt; 8));\n    (*out)[1] = (uint8_t) sz;\n    (*out)[2] = 6 + sz_label;\n    memcpy(*out+3, \"tls13 \", 6);\n    memcpy(*out + 9, label, sz_label);\n    (*out)[sz_label + 9] = sz_hash_value;\n    memcpy(*out + 9 + sz_label + 1, hash_value, sz_hash_value);\n    return UPAI_RES_OK;}</code></pre></div><p>有了 receive secrets，接下来就是由它再扩展出以“quic key”为标签的 Key，以“quiciv”为标签的 IV 和以“quic hp”为标签的 HP。前两个用于解密负载，后一个用于去除数据包头部掩码。代码如下所示：</p><div class=\"highlight\"><pre><code class=\"language-text\">uint8_t *recv_label;\nuint32_t sz_recv_label;\nuint32_t sz_defined_key = = _get_algorithm_key_size(ctx-&gt;cipher_name);\nupai_hkdf_label(m, \"client in\", 9, \"\", 0, algorithm_digest_size, &amp;recv_label, &amp;sz_recv_label);\nuint8_t *recv_secrets = (uint8_t *)upai_mem_pool_alloc(ctx-&gt;mem, algorithm_digest_size);\nret = upai_HKDF_Expand(_get_hash_method(ctx-&gt;cipher_name),\n        initial_secrets,\n        sz_initial_secrets,\n        recv_label,\n        sz_recv_label,\n        recv_secrets,\n        algorithm_digest_size);\nCK_KG_RET(ret, UPAI_KG_ERR | 2)\nuint8_t *key, *iv, *hp;uint32_t sz_key, sz_iv, sz_hp;\nupai_hkdf_label(m, \"quic key\", 8, \"\", 0, sz_defined_key, &amp;key, &amp;sz_key);\nupai_hkdf_label(m, \"quic iv\", 7, \"\", 0, AEAD_NONCE_LENGTH, &amp;iv, &amp;sz_iv);\nupai_hkdf_label(m, \"quic hp\", 7, \"\", 0, sz_defined_key, &amp;hp, &amp;sz_hp);\nuint8_t *key_for_client = upai_mem_pool_alloc(ctx-&gt;mem, sz_defined_key);\nuint8_t *iv_for_client = upai_mem_pool_alloc(ctx-&gt;mem, AEAD_NONCE_LENGTH);\nuint8_t *hp_for_client= upai_mem_pool_alloc(ctx-&gt;mem, sz_defined_key);\nret = upai_HKDF_Expand(_get_hash_method(ctx-&gt;cipher_name), //Initial包的Hash函数是SHA256\n        recv_secrets, algorithm_digest_size, key, sz_key, key_for_client, sz_defined_key);\nCK_KG_RET(ret, UPAI_KG_ERR | 3)\nret = upai_HKDF_Expand(_get_hash_method(ctx-&gt;cipher_name),\n        recv_secrets, \n        algorithm_digest_size, iv, sz_iv, \n        iv_for_client, AEAD_NONCE_LENGTH);\nCK_KG_RET(ret, UPAI_KG_ERR | 4)\nret = upai_HKDF_Expand(_get_hash_method(ctx-&gt;cipher_name),\n        recv_secrets, \n        algorithm_digest_size, hp, sz_hp, \n        hp_for_client, sz_defined_key);\nCK_KG_RET(ret, UPAI_KG_ERR | 5)</code></pre></div><p><b>去除头部保护</b></p><p>QUIC 协议的 Initial 数据包头部第一个字节的后 4～5 比特，以及头部的 PacketNumber 域是经过 AES-128-ECB 混淆的， 其中第一字节的最后两位指示了 Packet Number 的存储长度，使得数据包的 Pakcet Number 长度不可见。不确定 Packet Number 的长度，负载的解密也无从谈起。加密这两部分的密钥由初始化向量IV以及保护密钥衍生而来。该密钥使用“quic hp”作为标签（生成方式可参考上一节），作用于头部第一字节的最低有效位和 Packet Number 域，如果是长头部，则加密 4 位；若是短头部则加密最低 5 位。不过版本协商包和重试包不需要做头部加密。</p><p>以下代码初始化 crypto_context，并执行 remove header protection 操作：</p><div class=\"highlight\"><pre><code class=\"language-text\">upai_memory_pool_t *m = upai_create_memory_pool(MEM_POOL_SIZE);//创建内存池\n//.....\n//此处省略若干无关代码\n//.....\nuint8_t *plain_header;\nuint32_t plain_header_len, truncated_pn, pn_length;\nupai_crypto_ctx_t *  crypt_ctx = upai_create_quic_crypto(m);\ncrypt_ctx-&gt;initialize(crypt_ctx,\n    \"AES-128-ECB\", //去除头部混淆用的算法\n    \"AES-128-GCM\", //负载部分的加解密算法\n    key_for_client, sz_key, //Key\n    iv_for_client, sz_iv,   //IV\n    hp_for_client, sz_hp);  //HP\ncrypt_ctx-&gt;remove_hp(crypt_ctx,\n    Buffer_get_base(quic_buffer), //QUIC数据包存储首地址\n    Buffer_get_size(quic_buffer), //长度\n    initial_packet.packet_number_offset, //Packet Number域的偏移位置\n    &amp;plain_header, //输出的纯文本头部\n    &amp;plain_header_len, //长度\n    &amp;truncated_pn, //编码后的Packet Number\n    &amp;pn_length);//PN存储长度</code></pre></div><p>以下为 crypt_ctx-&gt;initialize 函数的头部保护去除初始化部分代码</p><div class=\"highlight\"><pre><code class=\"language-text\">//header protection init\nint res = EVP_CipherInit(ctx-&gt;hp_ctx,\nEVP_get_cipherbyname(hp_cipher_name), NULL, NULL, 1);\nCRYPTO_CK_RET(res, UPAI_ERR_CRYPTO | 1)\nres = EVP_CIPHER_CTX_set_key_length(ctx-&gt;hp_ctx, hp_len);\nCRYPTO_CK_RET(res, UPAI_ERR_CRYPTO | 2)\nres = EVP_CipherInit_ex(ctx-&gt;hp_ctx, NULL, NULL, hp, NULL, 1);\nCRYPTO_CK_RET(res, UPAI_ERR_CRYPTO | 3)</code></pre></div><p>解密头部保护的代码如下</p><div class=\"highlight\"><pre><code class=\"language-text\">//remove_hp主要代码u\nint8_t mask[32] = {0}, buffer[PACKET_LENGTH_MAX] = {0};\nint32_t outlen;\nuint8_t *sample = packet_buffer + packet_number_offset + PACKET_NUMBER_LENGTH_MAX;\nint32_t res = EVP_CipherUpdate(ctx-&gt;hp_ctx, mask, &amp;outlen, sample, SAMPLE_LENGTH);\nCRYPTO_CK_RET(res, UPAI_ERR_CRYPTO | 4)\nmemcpy(buffer, packet_buffer, packet_number_offset + PACKET_NUMBER_LENGTH_MAX);\nif (buffer[0] &amp; 0x80) //长头部数据包，后4位去混淆\n{\n    buffer[0] ^= mask[0] &amp; 0x0f;\n} else //短头部数据包，后5位去混淆\n{\n    buffer[0] ^= mask[0] &amp; 0x1f;\n}\nint pn_length = (buffer[0] &amp; 0x03) + 1;//第一字节的最低2位指示Packet Number的长度\n*truncated_pn = 0;\nfor (int i = 0; i &lt; pn_length; ++ i) {\nbuffer[packet_number_offset + i] ^= mask[i + 1];\n*truncated_pn = buffer[packet_number_offset + i] | (*truncated_pn) &lt;&lt; 8);\n}\n*plain_header =(uint8_t *) upai_mem_pool_alloc(ctx-&gt;mem, packet_number_offset + pn_length);\nmemcpy(*plain_header, buffer, packet_number_offset + pn_length);\n*plain_header_len = packet_number_offset + pn_length;\n*packet_number_len = pn_length;</code></pre></div><p><b>计算 Packet Number</b></p><p>Packet numbers 是大小为 0-2^62-1 之间的整型数值，单调递增，表示数据包的先后顺序， 但是放入 QUIC 数据包头部时却编码成 1-4 字节的数据。通过丢弃 packet number 的高位数据 接收方通过上下文恢复 packet number，这样一来就达到缩减数据长度的目的。</p><p>发送端的 packet number 数据存储容量，一般要求是其最近确认收到的数据包的 packet number 与正要发送的数据包的 packet number 之差的两倍以上，如此接收端方能正确解码。</p><p>举个例子，如果通讯的某一方收到对方的确认帧，确认己方发出的 packetnumber 为 0xabe8bc 的数据包已收到， 那么如果要发送 packetnumber 为 0xac5c02 的数据包，则至少需要（0xac5c02- 0xabe8bc）* 2 = 0xe68c, 16 位的编码空间，如果发送packet number是0xace8fe，则至少需要（0xace8fe - 0xabe8bc）*2= 0x20084, 24 位的编码空间。</p><p>接收端必须得去掉包头保护，再才能进行 packet number 的解码工作。头部保护去掉后就可以拿到编码过的 packet number 亦即 truncatedpacket number，需根据一定算法还原真实数字。其中 expected 为解码端预期的包号，即已接收的最大包号值加 1。举个例子，当前最大的包号是 0xa82f30ea，那么如果接收到的编码包号是 16 位数据 0x9b32， 那么最终解码出来的 packet number 是 0xa82f9b32。</p><p>实现代码如下所示。</p><div class=\"highlight\"><pre><code class=\"language-text\">uint64_t decode_packet_number(uint32_t truncated, uint8_t num_bits, uint64_t expected){\n    uint64_t window = 1L &lt;&lt; num_bits;\n    uint64_t half_window = (uint64_t )(window/2);\n    uint64_t candidate = (expected &amp; ~(window - 1)) | truncated;\n    const uint64_t pn_max = 1L &lt;&lt; 62;\n    if (((int64_t)candidate &lt;= (int64_t)(expected - half_window))\n      &amp;&amp; (candidate &lt; (pn_max - window))) {\n        return candidate + window;\n    } else if ((candidate &gt; expected + half_window)&amp;&amp;(candidate &gt;= window)) {\n        return candidate - window;\n    } else {\n        return candidate;\n    }}</code></pre></div><p class=\"ztext-empty-paragraph\"></p><p><b>解密负载内容</b></p><p>Initial 数据包的负载采用的是 AES-128-GCM 加密算法。首先初始化 OpenSSL EVP：</p><div class=\"highlight\"><pre><code class=\"language-text\">res = EVP_CipherInit_ex(ctx-&gt;decrypt_ctx,\n    EVP_get_cipherbyname(aead_cipher_name), //Cipher name=AES-128-GCM\n    NULL, NULL, NULL, 0);\nCRYPTO_CK_RET(res, UPAI_ERR_CRYPTO|6)\nres = EVP_CIPHER_CTX_set_key_length(ctx-&gt;decrypt_ctx, key_len);\nCRYPTO_CK_RET(res, UPAI_ERR_CRYPTO|7)\nres = EVP_CIPHER_CTX_ctrl(ctx-&gt;decrypt_ctx,\n    EVP_CTRL_GCM_SET_IVLEN, iv_len, NULL);\nCRYPTO_CK_RET(res, UPAI_ERR_CRYPTO|8)</code></pre></div><p>解密负载时，IV 部分还需要 PacketNumber 参与计算最终生成 nonce，</p><div class=\"highlight\"><pre><code class=\"language-text\">uint8_t nonce[AEAD_NONCE_LENGTH] = {0};\nmemcpy(nonce, ctx-&gt;iv, AEAD_NONCE_LENGTH);\n*plain_payload_len = 0;\n*plain_payload = NULL;\nuint8_t *data = packet_buffer + plain_header_len;\nuint32_t data_len = packet_buffer_len - plain_header_len;\nuint8_t buffer_payload[PACKET_LENGTH_MAX] = {0};\nfor (int i = 0; i &lt; 8; i++) {\n    nonce[AEAD_NONCE_LENGTH - 1 - i] ^= (uint8_t )(packet_number &gt;&gt; 8 * i);\n    }\nint32_t res = EVP_CipherInit_ex(ctx-&gt;decrypt_ctx,\n    NULL, NULL, ctx-&gt;key, nonce, 0);\nres = EVP_CIPHER_CTX_ctrl(ctx-&gt;decrypt_ctx,\n        EVP_CTRL_GCM_SET_TAG,\n        AEAD_TAG_LENGTH,\n        (void *)(data + (data_len-AEAD_TAG_LENGTH)));\nCRYPTO_CK_RET(res, UPAI_ERR_CRYPTO|10)\nint32_t outlen, outlen2;\nres = EVP_CipherUpdate(ctx-&gt;decrypt_ctx, NULL, &amp;outlen,\n        plain_header,\n        plain_header_len);\nCRYPTO_CK_RET(res, UPAI_ERR_CRYPTO|11)\nres = EVP_CipherUpdate(ctx-&gt;decrypt_ctx, buffer_payload, &amp;outlen,\n        data,\n        data_len - AEAD_TAG_LENGTH);\nCRYPTO_CK_RET(res, UPAI_ERR_CRYPTO|12)\nres = EVP_CipherFinal_ex(ctx-&gt;decrypt_ctx, NULL, &amp;outlen2);\nif (res == 0) {\n    return UPAI_ERR_CRYPTO|14;\n} else {\n    *plain_payload = (uint8_t *) upai_mem_pool_alloc(ctx-&gt;mem, outlen);\n    memcpy(*plain_payload, buffer_payload, outlen);\n    *plain_payload_len = outlen;\n    return UPAI_RES_OK;\n}\n</code></pre></div><p class=\"ztext-empty-paragraph\"></p><p><b>解析 ClientHello</b></p><p>上一节我们拿到了负载的明文, 这个区域存储的是至少一个或者一个以上的数据帧。Initial 数据包负载区第一帧一般是 CRYPTO 数据帧，FrameType 值为 0x06。以下代码获取了 CRYPTO 帧的四个数据段：FrameType，Offset， Length，CryptoData。其中，Offset，为变长整型数值，指示数据在该帧中的字节偏移位置， Length 段，为变长整型数值，指示 Crypto Data 的长度。</p><div class=\"highlight\"><pre><code class=\"language-text\">uint64_t frame_type, frame_length, frame_offset;\nuint8_t *crypto_data;\nRef_buffer(m, payload_buffer, 0, plain_payload, plain_payload_len);\nBuffer_pull_uint_var(payload_buffer, NULL, &amp;frame_type);\nif (frame_type == FRAME_TYPE_CRYPTO) {\n    Buffer_pull_uint_var(plain_payload_buffer, NULL, &amp;frame_offset);\n    Buffer_pull_uint_var(plain_payload_buffer, NULL, &amp;frame_length);\n    Buffer_pull_bytes(plain_payload_buffer, frame_length, &amp;crypto_data);\n}</code></pre></div><p>取得 Crypto Data 后，接着是对该段数据的解析。第一个字节是 HandshakeType，定义如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">typedef enum {\n    client_hello = 1,\n    server_hello = 2,\n    new_session_ticket = 4,\n    end_of_early_data = 5,\n    encrypted_extensions = 8,\n    certificate = 11,\n    certificate_request = 13,\n    certificate_verify = 15,\n    finished = 20,\n    key_update = 24,\n    message_hash = 254} handshake_type_t;</code></pre></div><p>显而易见，Initial 包里该段的类型值为 0x01，表明是 ClientHello 数据。接下来便是解析 TLS1.3 的 ClientHello 数据结构。</p><p>以下为 RFC8446 的 ClientHello 结构体：</p><div class=\"highlight\"><pre><code class=\"language-text\">uint16_t ProtocolVersion;opaque Random[32];\nuint8 CipherSuite[2];\nstruct {\n      ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */\n      Random random;\n      opaque legacy_session_id&lt;0..32&gt;;\n      CipherSuite cipher_suites&lt;2..2^16-2&gt;;\n      opaque legacy_compression_methods&lt;1..2^8-1&gt;;\n      Extension extensions&lt;8..2^16-1&gt;;\n      } ClientHello;</code></pre></div><p>解释一下为什么 legacy_version 是 0x0303: 在 TLS 的前一个版本中，该字段用于版本协商，也表示客户端能支持到的最高版本号。实践证明许多服务器并没有很好地实现版本协商功能，导致了所谓的“版本不宽容”的问题，只要此版号高于服务器能支持的,它就会连带着拒绝其他它它能接受的 ClientHello，在 TLS1.3 中， 客户端可以在 ClientHello 扩展信息的“supported_versions”字段中声明它版本支持的优先级， 因此，为兼容性考虑，legacy_version 就必须设为 0x0303，表示版本 TLS1.2。如此一来， 通过将 legacy_version 等于 0x0303，并在 supported_versions 字段中设 0x0304 为最高优先版本， 就可以表明，此 ClientHello 为 TLS1.3 了。</p><p>简单的实现代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">uint8_t handshake_type;\nuint8_t h_length;\nuint16_t l_length;\nuint16_t tls_version;\nuint8_t *random_value;\nuint8_t session_id_length;\nuint8_t *session_id;\nuint16_t cipher_suites_length;\nuint16_t ciphers[256];\nuint8_t compression_length;\nuint8_t *compression_methods;\nBuffer_pull_uint8(plain_payload_buffer, &amp;handshake_type);\nBuffer_pull_uint8(plain_payload_buffer, &amp;h_length);\nBuffer_pull_uint16(plain_payload_buffer, &amp;l_length);\nBuffer_pull_uint16(plain_payload_buffer, &amp;tls_version);\nBuffer_pull_bytes(plain_payload_buffer, 32, &amp;random_value);\nBuffer_pull_uint8(plain_payload_buffer, &amp;session_id_length);\nBuffer_pull_bytes(plain_payload_buffer, session_id_length, &amp;session_id);\nBuffer_pull_uint16(plain_payload_buffer, &amp;cipher_suites_length);\nfor (int i = 0; i &lt; cipher_suites_length/2;i++){\n    Buffer_pull_uint16(plain_payload_buffer, ciphers + i);\n    }\nBuffer_pull_uint8(plain_payload_buffer, &amp;compression_length);\nBuffer_pull_bytes(plain_payload_buffer, compression_length, &amp;compression_methods);</code></pre></div><p>最后，我们来看看 Extension 的结构，引用自 RFC8446。</p><div class=\"highlight\"><pre><code class=\"language-text\">struct {\n    ExtensionType extension_type;\n    opaque extension_data&lt;0..2^16-1&gt;;} Extension;\nenum {\n    server_name(0),                             /* RFC 6066 */\n    max_fragment_length(1),                     /* RFC 6066 */\n    status_request(5),                          /* RFC 6066 */\n    supported_groups(10),                       /* RFC 8422, 7919 */\n    signature_algorithms(13),                   /* RFC 8446 */\n    use_srtp(14),                               /* RFC 5764 */\n    heartbeat(15),                              /* RFC 6520 */\n    application_layer_protocol_negotiation(16), /* RFC 7301 */\n    signed_certificate_timestamp(18),           /* RFC 6962 */\n    client_certificate_type(19),                /* RFC 7250 */\n    server_certificate_type(20),                /* RFC 7250 */\n    padding(21),                                /* RFC 7685 */\n    pre_shared_key(41),                         /* RFC 8446 */\n    early_data(42),                             /* RFC 8446 */\n    supported_versions(43),                     /* RFC 8446 */\n    cookie(44),                                 /* RFC 8446 */\n    psk_key_exchange_modes(45),                 /* RFC 8446 */\n    certificate_authorities(47),                /* RFC 8446 */\n    oid_filters(48),                            /* RFC 8446 */\n    post_handshake_auth(49),                    /* RFC 8446 */\n    signature_algorithms_cert(50),              /* RFC 8446 */\n    key_share(51),                              /* RFC 8446 */\n    (65535)} ExtensionType;</code></pre></div><h2><b>总结</b></h2><p>到这里，QUIC 协议的解析总算是走出了万里长征的第一步，作为服务端，得回复 ACK 帧，告知客户端“你方请求已经收到”，然后回复 ServerHello，放入 CRYPTO 帧，把该交代的事情交代清楚，该协商的事情协商明白，这两个帧塞在同一个数据包发给客户端，然后，双方就可以愉快的步入 Handshake 的殿堂了。是的，1-RTT 握手过程就是这样。</p><p><b>推荐阅读：</b></p><a target=\"_blank\" href=\"https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/567/TCP%2520%25E5%2592%258C%2520UDP%25EF%25BC%258C%25E5%2593%25AA%25E4%25B8%25AA%25E6%259B%25B4%25E8%2583%259C%25E4%25B8%2580%25E7%25AD%25B9.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-cfefda8e4b484e3aaea7aad55f240635_180x120.jpg\" data-image-width=\"660\" data-image-height=\"304\" class=\"LinkCard LinkCard--hasImage\"><span class=\"LinkCard-backdrop\"/><span class=\"LinkCard-content\"><span class=\"LinkCard-text\"><span class=\"LinkCard-title\" data-text=\"true\">TCP 和 UDP，哪个更胜一筹</span><span class=\"LinkCard-meta\"><span>​<svg class=\"Zi Zi--InsertLink\" fill=\"currentColor\" viewbox=\"0 0 24 24\"><path d=\"M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z\"/></svg></span>www.upyun.com</span></span><span class=\"LinkCard-imageCell\"><img class=\"LinkCard-image LinkCard-image--horizontal\" alt=\"图标\" src=\"https://pic4.zhimg.com/v2-cfefda8e4b484e3aaea7aad55f240635_180x120.jpg\"/></span></span></a><a target=\"_blank\" href=\"https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/564/%25E5%25BD%2593%25E6%2588%2591%25E8%25B0%2588%2520HTTP%2520%25E6%2597%25B6%25EF%25BC%258C%25E6%2588%2591%25E8%25B0%2588%25E4%25BA%259B%25E4%25BB%2580%25E4%25B9%2588%253F.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-5f3e9230cffe936eb24adfa99af4a869_180x120.jpg\" data-image-width=\"958\" data-image-height=\"632\" class=\"LinkCard LinkCard--hasImage\"><span class=\"LinkCard-backdrop\"/><span class=\"LinkCard-content\"><span class=\"LinkCard-text\"><span class=\"LinkCard-title\" data-text=\"true\">当我谈 HTTP 时，我谈些什么?</span><span class=\"LinkCard-meta\"><span>​<svg class=\"Zi Zi--InsertLink\" fill=\"currentColor\" viewbox=\"0 0 24 24\"><path d=\"M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z\"/></svg></span>www.upyun.com</span></span><span class=\"LinkCard-imageCell\"><img class=\"LinkCard-image LinkCard-image--horizontal\" alt=\"图标\" src=\"https://pic3.zhimg.com/v2-5f3e9230cffe936eb24adfa99af4a869_180x120.jpg\"/></span></span></a><p><b>参考资料</b></p><p><a href=\"https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/draft-ietf-quic-transport-27/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">tools.ietf.org/html/dra</span><span class=\"invisible\">ft-ietf-quic-transport-27/</span><span class=\"ellipsis\"/></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//datatracker.ietf.org/doc/draft-ietf-quic-tls/27/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">datatracker.ietf.org/do</span><span class=\"invisible\">c/draft-ietf-quic-tls/27/</span><span class=\"ellipsis\"/></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/aiortc/aioquic\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/aiortc/aioqu</span><span class=\"invisible\">ic</span><span class=\"ellipsis\"/></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/carlescufi/wireshark/blob/bb7014731cfa39f7742f552f2817461b75ed084f/epan/dissectors/packet-quic.c\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/carlescufi/w</span><span class=\"invisible\">ireshark/blob/bb7014731cfa39f7742f552f2817461b75ed084f/epan/dissectors/packet-quic.c</span><span class=\"ellipsis\"/></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc5246\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">tools.ietf.org/html/rfc</span><span class=\"invisible\">5246</span><span class=\"ellipsis\"/></a> TLS1.2</p><p><a href=\"https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc8446\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">tools.ietf.org/html/rfc</span><span class=\"invisible\">8446</span><span class=\"ellipsis\"/></a> TLS1.3</p><p><a href=\"https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc5869\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">tools.ietf.org/html/rfc</span><span class=\"invisible\">5869</span><span class=\"ellipsis\"/></a> HKDF</p><p><a href=\"https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc4303\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">tools.ietf.org/html/rfc</span><span class=\"invisible\">4303</span><span class=\"ellipsis\"/></a> IPEncapsulating Security Payload</p></div></div></div>","descriptionType":"html","feedId":540,"bgimg":"https://pic1.zhimg.com/v2-ef3060e936c63cf5813fd57c57039535_b.jpg","linkMd5":"93980994a43ac2a6b2c3690e5a0933d4","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn9@2020_3/2020/08/23/04-46-41-303_6237780530775343.webp","destWidth":720,"destHeight":529,"sourceBytes":73639,"destBytes":29018,"author":"","articleImgCdnMap":{"https://pic1.zhimg.com/v2-ef3060e936c63cf5813fd57c57039535_b.jpg":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn9@2020_3/2020/08/23/04-46-41-303_6237780530775343.webp","https://pic3.zhimg.com/v2-a4a475b889dc6fac455fec0bb2389019_b.jpg":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn28@2020_3/2020/08/23/04-46-42-971_f6e084043311e8cf.webp","https://pic3.zhimg.com/v2-f6b31f5caf6144c2095a1d00a6edb9c2_b.jpg":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn33@2020_3/2020/08/23/04-46-43-245_a991af5300091794.webp","https://pic4.zhimg.com/v2-cfefda8e4b484e3aaea7aad55f240635_180x120.jpg":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn30@2020_4/2020/08/23/04-46-43-166_6092c83fc9326da8.webp","https://pic3.zhimg.com/v2-5f3e9230cffe936eb24adfa99af4a869_180x120.jpg":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn15@2020_6/2020/08/23/04-46-43-115_82b822c267d61423.webp"},"publishedOrCreatedDate":1598157961542},{"createdTime":"2020-08-23 12:46:07","updatedTime":"2020-08-23 12:46:07","title":"Ray，面向新兴 AI 应用的分布式框架","link":"https://toutiao.io/k/svce46c","description":"<div><div><div class=\"rich_media_content \" id=\"js_content\">\n                    \n\n                    \n\n                    \n                    \n                    <p><img class=\"rich_pages\" data-ratio=\"0.2730844793713163\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ib3G4kbB3s91mXhGahOLusJTOv85a3JSrWdJwEv7J7qpG1Ovj10c1QL05CqRXib2ncCB7XyibXEWmhJk5ZGoDy1AQ/640?wx_fmt=png\" data-type=\"png\" data-w=\"1018\"/></p><p>下一代AI应用需要不断和环境进行交互，并且在交互中学习。这些应用暴露了新的系统需求：性能和弹性。本文提出了Ray解决上述问题。</p><p>Ray实现了动态执行引擎，可以表达任务并行和actor模型计算任务。它通过分布式调度器以及分布式容错存储来实现高性能与容错。</p><h2>问题与方案</h2><p>AI中的监督学习部分，已经出现了优秀的深度学习框架，使用定制的硬件加速计算。但是对于新兴的AI应用不仅要收集探索数据，还要采取动作不断和环境交互学习，这一类可以概括为强化学习。</p><p>强化学习提出了新的系统需求：</p><p><span><span>1.</span>支持细粒度计算</span><span><span>2.</span>支持动态执行，RL需要模拟</span><span><span>3.</span>支持多样的资源：时间、CPU、内存等</span></p><p><strong>因此，新兴RL应用需要动态计算框架，每秒处理百万级任务且延迟在毫秒级</strong>。</p><p>当前的一些框架无法完全满足上面的要求：</p><p><span><span>1.</span>像MapReduce、Spark、Dryad一类BSP模型框架不支持细粒度模拟或策略服务</span><span><span>2.</span>CIEL和Dask的任务并行框架对分布式训练和模型服务支持很少</span><span><span>3.</span>分布式深度学习框架TensorFlow、MXNet不天然支持模拟和服务</span></p><p>因此，如果要开发端到端解决方案，需要使用不同的计算组件，分布式训练、模拟、模型服务等都需要一个组件。这种方法会带来大量的开发负担，而且系统紧耦合，不实用。</p><p>所以，Ray的目标是成为一款通用的计算框架，同时支持RL中的模拟、训练和服务这些需求。计算负载包括模拟这样的轻量、无状态的计算，也包括像训练这样长时、有状态的计算任务。对于无状态任务，Ray提供了Task抽象，对于有状态任务，Ray提供了actor抽象。这些抽象是建立在底层动态执行引擎上的。</p><p><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.3125\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ib3G4kbB3s90rrH58pAeic036rLqLof2c1O6hvl8CF13j4Bjib8tnlJIvfSjPgxyKCheMnInbIdhlnFTe1eSLiaLhA/640?wx_fmt=png\" data-type=\"png\" data-w=\"1280\"/></p><p>Ray的贡献如下：</p><p><span><span>1.</span>设计和实现了第一个统一训练、模拟和服务的分布式框架</span><span><span>2.</span>基于动态执行引擎实现了task和actor并行抽象</span><span><span>3.</span>将控制状态存储在共享的元数据存储中，其它系统组件都是无状态的</span><span><span>4.</span>自底向上的分布式调度策略</span></p><h2>编程与计算模型</h2><p>Ray实现了动态任务图计算模型，将应用建模成调度图中独立的计算任务。</p><h2>编程模型</h2><p><span><span>1.</span>Task表示可以在无状态worker节点上执行远程函数(remote function)。远程函数是无状态且幂等的，相同的输入输出相同，这样易于容错。</span><span><span>2.</span>Actors，表示有状态的计算，每个actor会暴露一些方法，可以被远程调用或顺序执行。actor的方法只会在有状态的worker上执行。</span></p><p>下面的表格是Task和Actor的比较：</p><table><thead><tr><td>Task(stateless)</td><td>Actors(stateful)</td></tr></thead><tbody><tr><td>Fine-grained load balancing</td><td>Coarse-grained load balancing</td></tr><tr><td>Support for object locality</td><td>Poor locality support</td></tr><tr><td>High overhead for small updates</td><td>Low overhead for small updates</td></tr><tr><td>Efficient failure handling</td><td>Overhead from checkpointing</td></tr></tbody></table><h2>计算模型</h2><p>Ray采用了动态任务图计算模型，这种模型中，当输入准备好后，task和actor的方法会自动被系统调用执行。</p><p><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"1.0163265306122449\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ib3G4kbB3s90rrH58pAeic036rLqLof2c1D9NypaZfq5sVcuA6eUsrsTFBT8fjlibcGricJ7D9JLWuLeR84vhjCQKA/640?wx_fmt=png\" data-type=\"png\" data-w=\"490\"/></p><p>上面的图就是一个动态任务图，这个图包含三种类型的边：</p><p><span><span>1.</span>数据边，表示数据依赖关系</span><span><span>2.</span>控制边</span><span><span>3.</span>有状态边</span></p><p>图中有两种类型的节点：</p><p><span><span>1.</span>对象节点，包含有状态信息</span><span><span>2.</span>任务/远程函数调用，无状态函数/方法</span></p><p>在任务图中，Ray会维护数据间的依赖世系，当某个task或actor的方法崩溃时，可以快速恢复丢失的数据。</p><h2>系统架构</h2><p>下图是<span>Ray早期论文<sup>[1]</sup></span>中的整体架构，包含的组件更全面，对架构可以有一个整体的认识。</p><p><img class=\"rich_pages\" data-ratio=\"0.7618243243243243\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ib3G4kbB3s90rrH58pAeic036rLqLof2c1mTR5lBUx3dKJ9R8yULx8nyrZd4E0VKDS8zOH9nX6OpYNPqdrPTS1ag/640?wx_fmt=png\" data-type=\"png\" data-w=\"592\"/></p><p>Ray的架构分为两层，上层为应用层，为用户提供简炼、易用的API；下层为系统层，提供高可用、容错的执行引擎。</p><h2>应用层</h2><p>由三种类型的进程构成：</p><p><span><span>1.</span><strong>Driver</strong>：用于执行用户程序</span><span><span>2.</span><strong>Worker</strong>：自动运行的<code>无状态</code>进程，由系统层分配任务。会串行执行driver或其它worker触发的任务。</span><span><span>3.</span><strong>Actor</strong>：有状态进程，只能由dirver或worker实例化。</span></p><h2>系统层</h2><p>包含三个主要的组件：全局控制存储、分布式调度器和分布式对象存储。</p><h3>Global Control Store(GCS)</h3><p>全局控制存储(GCS)维护系统所有控制状态，它的核心是带有发布-订阅功能的键值存储。通过分片实现扩展，每个分片通过<span>链式备份<sup>[2]</sup></span>实现容错。</p><p><strong>GCS的目的是为每秒百万级任务调度提供容错和低延时</strong>。同时简化了整体架构，使得Ray中的每个组件都是无状态的，组件的调度、扩展、调试、可视化都非常方便</p><h3>自底向上的分布式调度</h3><p>Ray的一个目标是实现每秒百万级任务调度，为此设计了两级调度器，包括<code>全局调度器</code>和每个节点上的<code>本地调度器</code>。为了降低全部调度器的负载，节点(worker，actor)上派生的任务首先提交给本地调度器，当本地调度器过载时，会把待调度的任务提交给全局调度器。</p><p><img class=\"rich_pages\" data-ratio=\"0.5963302752293578\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/ib3G4kbB3s90rrH58pAeic036rLqLof2c1HpjQutLFUZKDCI6ibdTk3dzclR9zrhknKYz9YARibZZDNLEdVlrRBH8Q/640?wx_fmt=png\" data-type=\"png\" data-w=\"545\"/></p><p>全局调度器会根据每个节点的负载和任务的需求进行调度。决策依据有：</p><p><span><span>1.</span>每个节点上任务队列的大小</span><span><span>2.</span>节点上任务的排队时间</span><span><span>3.</span>任务需要的数据传输到该节点所需的时间</span></p><p>当全局调度器出现瓶颈时，Ray会实例化更多的全局调度器来分担工作，这得益于GCS，使得全局调度器可扩展。</p><h3>内存分布式对象存储</h3><p>基于内存实现是为了最小化任务的延迟，数据格式使用Apache Arrow。</p><p>当任务所需的数据不在本地节点时，数据会从其它节点复制过来。因为认读读写数据都在本地内存中，这极大增加了吞吐量。</p><p>内存对象存储是分布式的，但是存储的内容必须作为一个整体存储在一个节点上，不能分割成多个块，存储在多个节点上，Ray没有这样做，因为会增加系统的复杂度。</p><h2>代码实现</h2><p>截至2017年，Ray主要包含40K行代码，系统层由C++编写，占72%；应用层由Python编写，占28%。</p><p>两级调度器都是基于事件驱动(event-driven)的单线程模型。</p><h2>总结</h2><p>Ray的开发是一段长期旅程，早期它作为分布式训练和模拟的Spark库出现，因无法满足强化学习的要求而独立演进。</p><p>Ray提供了无状态(task)和有状态(actor)的通用分布式调度框架，支持训练、服务和模拟整个强化学习周期。通过良好的架构设计支撑了每秒百万级的任务调度，可以很好支撑未来新兴AI应用的需求。</p><p>截止到2020年，Ray已经不局限于强化学习任务，而是作为一个<strong>通用的分布式框架</strong>，上层封装了<span>Tune<sup>[3]</sup></span>、<span>RLlib<sup>[4]</sup></span>、<span>SGD<sup>[5]</sup></span>、<span>Serve<sup>[6]</sup></span>等生态库，为用户提供更多可能，并且专门创办公司<span>Anyscale<sup>[7]</sup></span>来推动，这会成为下一个Spark和Databricks吗？我们拭目以待。</p><p><span><span><sup/></span></span></p><h3>References</h3><p><code>[1]</code> Ray早期论文: <em>https://arxiv.org/abs/1703.03924</em><br/><code>[2]</code> 链式备份: <em>https://www.cs.cornell.edu/home/rvr/papers/OSDI04.pdf</em><br/><code>[3]</code> Tune: <em>https://docs.ray.io/en/latest/tune.html</em><br/><code>[4]</code> RLlib: <em>https://docs.ray.io/en/latest/rllib.html</em><br/><code>[5]</code> SGD: <em>https://docs.ray.io/en/latest/raysgd/raysgd.html</em><br/><code>[6]</code> Serve: <em>https://docs.ray.io/en/latest/serve/index.html</em><br/><code>[7]</code> Anyscale: <em>https://anyscale.com/</em><br/><code>[8]</code> 10 分钟了解 Actor 模型: <em>https://www.jianshu.com/p/449850aa8e82</em><br/><code>[9]</code> BSP模型: <em>https://zh.wikipedia.org/wiki/%E6%95%B4%E4%BD%93%E5%90%8C%E6%AD%A5%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B</em><br/><code>[10]</code> Ray官网: <em>https://ray.io</em><br/><code>[11]</code> Ray paper: <em>https://arxiv.org/abs/1712.05889</em></p><p></p><hr/><p></p><p>推荐阅读：</p><p></p><p><img class=\"rich_pages\" data-ratio=\"1\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/ib3G4kbB3s93K1Be8mDr49iaibSp5pFh9ib8LibvMZgUAXR7ibN2CwzabYekA5D8epWaXZVWk5MPc6fzzNPnSZ7RUvrA/640?wx_fmt=jpeg\" data-type=\"jpeg\" data-w=\"430\"/></p><p><span/><a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzI0NzEwMzg5Ng==&amp;mid=2650910986&amp;idx=1&amp;sn=7cb15431538ef5f0644291334b437ffe&amp;chksm=f24039fdc537b0ebc6dab2e96c1d926ecaae9b86baa028feef17fb30a960e70695a2b4afb4ca&amp;scene=21#wechat_redirect\" data-itemshowtype=\"0\" tab=\"innerlink\" data-linktype=\"2\"/><span>扫码关注，与我互动~</span></p>\n                </div>\n\n                \n\n                \n\n\n\n                \n                </div></div>","descriptionType":"html","feedId":540,"bgimg":"http://mmbiz.qpic.cn/mmbiz_jpg/ib3G4kbB3s90rrH58pAeic036rLqLof2c1Xek25ugEiaAZY7faiaBzyVg5Yj0Ilr84VkWZUHoxfCO9pPyu6hreWSHA/0?wx_fmt=jpeg","linkMd5":"0ab5a9e86ece1aaa6db5196ae763ce99","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn13@2020_6/2020/08/23/04-46-43-551_d57a1d8c0a317f72.webp","metaImg":"http://mmbiz.qpic.cn/mmbiz_jpg/ib3G4kbB3s90rrH58pAeic036rLqLof2c1Xek25ugEiaAZY7faiaBzyVg5Yj0Ilr84VkWZUHoxfCO9pPyu6hreWSHA/0?wx_fmt=jpeg","destWidth":1280,"destHeight":544,"sourceBytes":36953,"destBytes":22314,"author":"","publishedOrCreatedDate":1598157967464},{"createdTime":"2020-08-23 12:46:40","updatedTime":"2020-08-23 12:46:40","title":"K3s + Ambassador，强大的轻量级 K8S 解决方案","link":"https://toutiao.io/k/53h9oed","description":"<div><div><section powered-by=\"xiumi.us\"><p>默认情况下，K3s将Traefik作为ingress controller。要使用Ambassador和Envoy Proxy需要按照以下步骤操作（这些步骤假设你已经安装好了K3s，如果你尚未安装请根据先快速指南进行安装：</p><p><span>https://rancher.com/docs/k3s/latest/en/quick-start/</span>）</p><p></p><p>1、 使用<span>--disable treafik</span>选项启动K3s。你可以通过编辑<span>/etc/systemd/system/k3s.service</span>进行此操作并且编辑<span>ExecStart</span>行：</p><p></p><section class=\"code-snippet__fix code-snippet__js\"><pre class=\"code-snippet__js\" data-lang=\"properties\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">ExecStart</span>=<span class=\"code-snippet__string\">/usr/local/bin/k3s \\</span></span></code><code><span class=\"code-snippet_outer\">server \\</span></code><code><span class=\"code-snippet_outer\">--disable traefik \\</span></code></pre></section><p></p><p>2、 重启K3s</p><p></p><section class=\"code-snippet__fix code-snippet__js\"><pre class=\"code-snippet__js\" data-lang=\"properties\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">sudo</span> <span class=\"code-snippet__string\">systemctl daemon-reload</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">sudo</span> <span class=\"code-snippet__string\">systemctl restart k3s.service</span></span></code></pre></section><p></p><p>3、 通过应用标准的Ambassador Kubernetes manifest安装Ambassador（Ambassador也支持Helm安装：</p><p><span>https://www.getambassador.io/docs/latest/topics/install/helm/</span>）</p><p></p><section class=\"code-snippet__fix code-snippet__js\"><pre class=\"code-snippet__js\" data-lang=\"ruby\"><code><span class=\"code-snippet_outer\">kubectl apply -f <span class=\"code-snippet__symbol\">https:</span>/<span class=\"code-snippet__regexp\">/www.getambassador.io/yaml</span><span class=\"code-snippet__regexp\">/ambassador/ambassador</span>-crds.yaml</span></code><code><span class=\"code-snippet_outer\">kubectl apply -f <span class=\"code-snippet__symbol\">https:</span>/<span class=\"code-snippet__regexp\">/www.getambassador.io/yaml</span><span class=\"code-snippet__regexp\">/ambassador/ambassador</span>-rbac.yaml</span></code><code><span class=\"code-snippet_outer\">kubectl apply -f <span class=\"code-snippet__symbol\">https:</span>/<span class=\"code-snippet__regexp\">/www.getambassador.io/yaml</span><span class=\"code-snippet__regexp\">/ambassador/ambassador</span>-service.yaml</span></code></pre></section><p></p><p>4、 现在我们将部署一个简单的服务。保存以下Kubernetes YAML到文件中，称为<span>quote.yaml.</span></p><p></p><section class=\"code-snippet__fix code-snippet__js\"><pre class=\"code-snippet__js\" data-lang=\"properties\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">---</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">apiVersion</span>: <span class=\"code-snippet__string\">v1</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">kind</span>: <span class=\"code-snippet__string\">Service</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">metadata</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">name</span>: <span class=\"code-snippet__string\">quote</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">spec</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">ports</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__meta\">-</span> <span class=\"code-snippet__string\">name: http</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">port</span>: <span class=\"code-snippet__string\">80</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">targetPort</span>: <span class=\"code-snippet__string\">8080</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">selector</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">app</span>: <span class=\"code-snippet__string\">quote</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">---</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">apiVersion</span>: <span class=\"code-snippet__string\">apps/v1</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">kind</span>: <span class=\"code-snippet__string\">Deployment</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">metadata</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">name</span>: <span class=\"code-snippet__string\">quote</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">spec</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">replicas</span>: <span class=\"code-snippet__string\">1</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">selector</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">matchLabels</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__attr\">app</span>: <span class=\"code-snippet__string\">quote</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">strategy</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">type</span>: <span class=\"code-snippet__string\">RollingUpdate</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">template</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">metadata</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__attr\">labels</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__attr\">app</span>: <span class=\"code-snippet__string\">quote</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">spec</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__attr\">containers</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__meta\">-</span> <span class=\"code-snippet__string\">name: backend</span></span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__attr\">image</span>: <span class=\"code-snippet__string\">docker.io/datawire/quote:0.4.1</span></span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__attr\">ports</span>:<span class=\"code-snippet__string\"/></span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__meta\">-</span> <span class=\"code-snippet__string\">name: http</span></span></code><code><span class=\"code-snippet_outer\">        <span class=\"code-snippet__attr\">containerPort</span>: <span class=\"code-snippet__string\">8080</span></span></code></pre></section><p></p><p>5、 部署quote服务到K3s：<span>kubectl apply -f quote.yaml</span></p><p></p><p>6、 Ambassador支持标准的Kubernetes ingress资源进行路由。Ingress资源是单体对象，既包括Ingress本身的配置（如TLS配置），也包括路由。然而，官方的ingress标准相当有限，所以大多数Ambassador用户都依赖Mapping，Mapping是Ambassador特有的自定义资源定义。Mapping资源与Ambassador的部署完全解耦，使得Mapping资源只是用来描述请求路由。将下面的YAML配置保存到一个名为quote-mapping.yaml的文件中。</p><p></p><section class=\"code-snippet__fix code-snippet__js\"><pre class=\"code-snippet__js\" data-lang=\"makefile\"><code><span class=\"code-snippet_outer\">---</span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__section\">apiVersion: getambassador.io/v2</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__section\">kind: Mapping</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__section\">metadata:</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__section\">name: quote-backend</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__section\">spec:</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__section\">prefix: /give-me-a-quote/</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__section\">service: quote</span></span></code></pre></section><p></p><p>7、 应用配置到集群：</p><p><span>kubectl apply -f quote-mapping.yaml</span></p><p></p><p>8、 获取Ambassador LoadBalancer 服务的IP地址：</p><p></p><section class=\"code-snippet__fix code-snippet__js\"><pre class=\"code-snippet__js\" data-lang=\"properties\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__meta\">$</span> <span class=\"code-snippet__string\">sudo kubectl get svc</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">NAME</span>               <span class=\"code-snippet__string\">TYPE           CLUSTER-IP      EXTERNAL-IP    PORT(S)          AGE</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">kubernetes</span>         <span class=\"code-snippet__string\">ClusterIP      10.43.0.1       &lt;none&gt;         443/TCP          60m</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__meta\">ambassador-admin</span>   <span class=\"code-snippet__string\">NodePort       10.43.134.74    &lt;none&gt;         8877:31032/TCP   5m15s</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">ambassador</span>         <span class=\"code-snippet__string\">LoadBalancer   10.43.61.86     10.128.0.111   80:31347/TCP     89s</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">quote</span>              <span class=\"code-snippet__string\">ClusterIP      10.43.129.249   &lt;none&gt;         80/TCP           31s</span></span></code></pre></section><p></p><p>9、 复制IP地址并测试配置：</p><p><span>curl http://&lt;IP address&gt;/give-me-a-quote/:</span></p><p></p><section class=\"code-snippet__fix code-snippet__js\"><pre class=\"code-snippet__js\" data-lang=\"bash\"><code><span class=\"code-snippet_outer\">$ curl 10.128.0.111/give-me<span class=\"code-snippet___\">-a</span>-quote/</span></code><code><span class=\"code-snippet_outer\">{</span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__string\">\"server\"</span>: <span class=\"code-snippet__string\">\"harmonious-strawberry-z6onbsu2\"</span>,</span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__string\">\"quote\"</span>: <span class=\"code-snippet__string\">\"A small mercy is nothing at all?\"</span>,</span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__string\">\"time\"</span>: <span class=\"code-snippet__string\">\"2020-07-15T13:59:50.716712445Z\"</span></span></code><code><span class=\"code-snippet_outer\">}</span></code></pre></section><p></p><p>恭喜你！你已经成功使用Ambassador来路由一个HTTP请求到quote服务。</p><p></p></section></div></div>","descriptionType":"html","feedId":540,"bgimg":"http://mmbiz.qpic.cn/mmbiz_png/sC8cuWIVuv6VuUPNo8usMp1OLVzOoytaasa8wicev4xEtL2217SRszvXhjxkJuw6yTrq3MVqWFFGI65h1pbE9NA/0?wx_fmt=png","linkMd5":"93fc10e6dbf04b42221ebf1d75a45096","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn22@2020_6/2020/08/23/04-46-43-013_4cd16bc548ff4c8d.webp","metaImg":"http://mmbiz.qpic.cn/mmbiz_png/sC8cuWIVuv6VuUPNo8usMp1OLVzOoytaasa8wicev4xEtL2217SRszvXhjxkJuw6yTrq3MVqWFFGI65h1pbE9NA/0?wx_fmt=png","destWidth":1067,"destHeight":400,"sourceBytes":24861,"destBytes":15880,"author":"","publishedOrCreatedDate":1598158000980},{"createdTime":"2020-08-23 12:46:07","updatedTime":"2020-08-23 12:46:07","title":"[译] 图解 Go 内存管理与内存清理","link":"https://toutiao.io/k/rfvpcag","description":"<div><div><div class=\"rich_media_content \" id=\"js_content\">\n                    \n\n                    \n\n                    \n                    \n                    <section><span>点击上方蓝色“</span><span>Go语言中文网</span><span>”关注我们，</span><span>领全套Go资料</span><span>，每天学习 Go 语言</span><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.71171875\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBK7TduZYCtwhzd7l0pn5cXdZBp5vk9ibcObMTXXmFF78liaMU9LoiaQfjsQ/640?wx_fmt=png\" data-type=\"png\" data-w=\"1280\"/></section><section data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\"><p data-tool=\"mdnice编辑器\">Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French.</p><p data-tool=\"mdnice编辑器\"><em>这篇文章基于 Go 1.13 版本。有关内存管理的讨论在我的文章  ”<span>Go:内存管理与分配</span><sup>[1]</sup> ” 中有解释。</em></p><p data-tool=\"mdnice编辑器\">清理内存是一个过程，它能够让 Go 知道哪些内存段最近可用于分配。但是，它并不会使用将位置 0 的方式来清理内存。</p><h2 data-tool=\"mdnice编辑器\"><span/><span>将内存置 0</span><span> </span></h2><p data-tool=\"mdnice编辑器\">将内存置 0 的过程 —— 就是把内存段中的所有位赋值为 0 —— 是在分配过程中即时执行的。</p><p data-tool=\"mdnice编辑器\"><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.3355119825708061\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBKbhJJ0ibzk4cwn0IlnHNvlruQlIS6Ym4cojmSaW8uBp6CltpIoMibESLw/640?wx_fmt=png\" data-type=\"png\" data-w=\"918\"/></p><p data-tool=\"mdnice编辑器\">Zeroing the memory</p><p data-tool=\"mdnice编辑器\">但是，我们可能想知道 Go 采用什么样的策略去知道哪些对象能够用于分配。由于在每个范围内有一个内部位图 <code>allocBits</code> ，Go 实际上会追踪那些空闲的对象。让我们从初始态开始来回顾一下它的工作流程，</p><p data-tool=\"mdnice编辑器\"><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.2387332521315469\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBK6tKf33NEiajqmibqj4WVSdXWItQiciaQsVCqMFzNuLib9MrqkfF3AI5e53A/640?wx_fmt=png\" data-type=\"png\" data-w=\"821\"/></p><p data-tool=\"mdnice编辑器\">Free objects tracking with allocBits</p><p data-tool=\"mdnice编辑器\">就性能角度来看，<code>allocBits</code> 代表了一个初始态并且会保持不变，但是它会由 <code>freeIndex</code>（一个指向第一个空闲位置的增量计数器）所协助。</p><p data-tool=\"mdnice编辑器\">然后，第一个分配就开始了：</p><p data-tool=\"mdnice编辑器\"><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.23636363636363636\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBKgGric18nx1Srf7eTEUGI12qD2e9MaoyhSettNia5Jl0DwxZRuFGU0txQ/640?wx_fmt=png\" data-type=\"png\" data-w=\"825\"/></p><p data-tool=\"mdnice编辑器\">Free objects tracking with allocBits</p>`freeIndex` 现在增加了，并且基于 `allocBits` 知道了下一段空闲位置。<p data-tool=\"mdnice编辑器\">分配过程将会再一次出现，之后， GC 将会启动去释放不再被使用的内存。在标记期间，GC 会用一个位图 <code>gcmarkBits</code> 来跟踪在使用中的内存。让我们通过我们运行的程序以相同的示例为例，在第一个块不再被使用的地方。</p><p data-tool=\"mdnice编辑器\"><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.31234866828087166\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBKOJguiadLR9iaiawJmGUwhu3vS6AsKoicqy9rlPzqIAAhNPEyZtLiaQSxYnQ/640?wx_fmt=png\" data-type=\"png\" data-w=\"826\"/></p><p data-tool=\"mdnice编辑器\">Memory tracking during the garbage collector</p>正在被使用的内存被标记为黑色，然而当前执行并不能够到达的那些内存会保持为白色。&gt; 有关更多关于标记和着色阶段的信息，我建议你阅读我的这篇文章 [Go：GC 是如何标记内存的？]( \"Go：GC 是如何标记内存的？\")\n现在，我们可以使用 `gomarkBits` 精确查看可用于分配的内存。Go 现在也使用 `gomarkBits` 代替了 `allocBits` ，这个操作就是内存清理：</section><section data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\"><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.31630170316301703\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBKfxOUjVck0cib2WWF6VdXdhKaQGTpkYBKoZtwq7rWWSxpfyjw6JL00iaw/640?wx_fmt=png\" data-type=\"png\" data-w=\"822\"/><p data-tool=\"mdnice编辑器\">Sweeping a span</p>但是，这必须在每一个范围内执行完毕并且会花费许多时间。Go 的目标是在清理内存时不阻碍执行，并为此提供了两种策略。<h2 data-tool=\"mdnice编辑器\"><span/><span>清理阶段</span><span> </span></h2><p data-tool=\"mdnice编辑器\">Go 提供了两种方式来清理内存：</p><ul data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\"><li><section>使用一个工作程序在后台等待，一个一个的清理这些范围。</section></li><li><section>当分配需要一个范围的时候即时执行。</section></li></ul><p data-tool=\"mdnice编辑器\">关于后台工作程序，当开始运行程序时，Go 将设置一个后台运行的 Worker（唯一的任务就是去清理内存），它将进入睡眠状态并等待内存段扫描：</p><p data-tool=\"mdnice编辑器\"><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.4527777777777778\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBKpCPXXNtpib2JGDC89bibyEXHl2pDpkxerbrW1Cs8290xlJgnKLicibtRXQ/640?wx_fmt=png\" data-type=\"png\" data-w=\"720\"/></p><p data-tool=\"mdnice编辑器\">Background sweeper</p>通过追踪过程的周期，我们也能看到这个后台工作程序总是出现去清理内存：</section><section data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\"><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.2265625\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBKU8LReibFC3dJxlZmzIS8g4LgoicPFd7JF1Emz9QLfAzUcpib2xEXdMRmQ/640?wx_fmt=png\" data-type=\"png\" data-w=\"1280\"/><p data-tool=\"mdnice编辑器\">Background sweeper</p>清理内存段的第二种方式是即时执行。但是，由于这些内存段已经被分发到每一个处理器的本地缓存 `mcache` 中，因此很难追踪首先清理哪些内存。这就是为什么 Go 首先将所有内存段移动到 `mcentral` 的原因。</section><section data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\"><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.5609243697478992\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBKzx7tIfaZTSHfctEaV7onMBRbN3PGQDcKpepgUpvN3BZB1xJxwjaq3g/640?wx_fmt=png\" data-type=\"png\" data-w=\"952\"/><p data-tool=\"mdnice编辑器\">Spans are released to the central list</p>然后，它将会让本地缓存 `mcache` 再次请求它们，去即时清理：</section><section data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\"><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.2813163481953291\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBKsvoybibicP1kibAMlxCticvXSlhmqdXqQlkeBssRp1icjmGL6bo7P4d9cmQ/640?wx_fmt=png\" data-type=\"png\" data-w=\"942\"/><p data-tool=\"mdnice编辑器\">Sweep span on the fly during allocation</p>即时扫描确保所有内存段在保存资源的过程中都会得到清理，同时会保存资源以及不会阻塞程序执行。<h2 data-tool=\"mdnice编辑器\"><span/><span>与 GC 周期的冲突</span><span> </span></h2><p data-tool=\"mdnice编辑器\">正如之前看到的，由于后台只有一个 worker 在清理内存块，清理过程可能会花费一些时间。但是，我们可能想知道如果另一个 GC 周期在一次清理过程中启动会发生什么。在这种情况下，这个运行 GC 的 Goroutine 就会在开始标记阶段前去协助完成剩余的清理工作。让我们举个例子看一下连续调用两次 GC，包含数千个对象的内存分配的过程。</p><p data-tool=\"mdnice编辑器\"><img class=\"rich_pages js_insertlocalimg\" data-ratio=\"0.31640625\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBKsyLqwVoG6WtKyV0rSu1bx1JdQpXhUibrYWicib31Xv4s408zGia46G0dsQ/640?wx_fmt=png\" data-type=\"png\" data-w=\"1280\"/></p><p data-tool=\"mdnice编辑器\">Sweeping must be finished before a new cycle</p>但是，如果开发者没有强制调用 GC，这个情况并不会发生。在后台运行的清理工作以及在执行过程中的清理工作应该足够多，因为清理内存块的数量和去触发一个新的周期（译者注：GC 周期）的所需的分配的数量成正比。<hr data-tool=\"mdnice编辑器\"/><p data-tool=\"mdnice编辑器\">via：https://medium.com/a-journey-with-go/go-memory-management-and-memory-sweep-cc71b484de05作者：<span>Vincent Blanchon</span><sup>[2]</sup>译者：</p><p data-tool=\"mdnice编辑器\"><sup>[3]</sup>校对：<span>polaris1119</span><sup>[4]</sup></p><p data-tool=\"mdnice编辑器\">本文由 <span>GCTT</span><sup>[5]</sup> 原创编译，<span>Go 中文网</span><sup>[6]</sup> 荣誉推出</p><h3 data-tool=\"mdnice编辑器\"><span>参考资料</span></h3><section data-tool=\"mdnice编辑器\"><span><span>[1]</span><p>Go:内存管理与分配: <em>https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44</em></p></span><span><span>[2]</span><p>Vincent Blanchon: <em>https://medium.com/@blanchon.vincent</em></p></span><span><span>[3]</span><p>sh1luo: <em>https://github.com/sh1luo</em></p></span><span><span>[4]</span><p>polaris1119: <em>https://github.com/polaris1119</em></p></span><span><span>[5]</span><p>GCTT: <em>https://github.com/studygolang/GCTT</em></p></span><span><span>[6]</span><p>Go 中文网: <em>https://studygolang.com/</em></p></span></section></section><section><br/></section><hr/><p><strong>推荐阅读</strong></p><p></p><section data-darkmode-bgcolor-15906318746582=\"rgb(36, 36, 36)\" data-darkmode-original-bgcolor-15906318746582=\"rgb(255, 255, 255)\" data-style=\"width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;\"><span>学习交流 Go 语言，扫码回复「<strong>进群</strong>」即可</span><br/></section><section data-darkmode-bgcolor-15906318746582=\"rgb(36, 36, 36)\" data-darkmode-original-bgcolor-15906318746582=\"rgb(255, 255, 255)\" data-style=\"width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;\"><br/></section><section data-mpa-template=\"t\"><section><section><section><section><section><section><section data-mpa-template=\"t\"><section><section><section><section><section><section><section data-mpa-template=\"t\"><section><section><section><section><section><p><img data-cropselx1=\"0\" data-cropselx2=\"150\" data-cropsely1=\"0\" data-cropsely2=\"150\" data-ratio=\"1\" data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUskFk80F3o5s1uCQfwwibAKM6x4RyOvMt7SMgrBIqy6icmK0pB1AAQhbg/640?wx_fmt=jpeg\" data-type=\"jpeg\" data-w=\"258\"/></p></section></section><section><section><section><br/></section><section><p>站长 polarisxu</p><p><span>自己的原创文章</span></p><p>不限于 Go 技术</p><p><span>职场和创业经验</span></p></section></section></section></section><section><section><section><section><br/></section><section><p><span>Go语言中文网</span></p><p><span>每天为你</span></p><p><span>分享 Go 知识</span></p><p><span>Go爱好者值得关注</span></p></section></section></section><section><p><img data-cropselx1=\"0\" data-cropselx2=\"150\" data-cropsely1=\"0\" data-cropsely2=\"150\" data-ratio=\"1\" data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg\" data-type=\"jpeg\" data-w=\"258\"/></p><p></p></section></section></section></section></section></section></section></section></section></section></section></section></section></section></section></section></section></section></section>\n                </div>\n\n                \n\n                \n\n\n\n                \n                </div></div>","descriptionType":"html","feedId":540,"bgimg":"http://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBKx9lXoDyDrcjHTKWMxAbC86QU9ibyVjw5zESkYAeM3KmrV7iaBXRaRpGQ/0?wx_fmt=jpeg","linkMd5":"25f5be28633a60c6f6324adca1a8a72b","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn24@2020_4/2020/08/23/04-46-43-267_ddd4a1bad8a7f07e.webp","metaImg":"http://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBKx9lXoDyDrcjHTKWMxAbC86QU9ibyVjw5zESkYAeM3KmrV7iaBXRaRpGQ/0?wx_fmt=jpeg","destWidth":909,"destHeight":905,"sourceBytes":101582,"destBytes":70514,"author":"","publishedOrCreatedDate":1598157967924}],"record":{"createdTime":"2020-08-23 12:46:41","updatedTime":"2020-08-23 12:46:41","feedId":540,"fetchDate":"Sun, 23 Aug 2020 04:46:41 +0000","fetchMs":1181,"handleMs":39515,"totalMs":44196,"newArticles":0,"totalArticles":5,"status":1,"type":0,"ip":"34.199.96.217","hostName":"us-006.herokuapp.com","requestId":"915f3936dc3a4139b5494fe53b2dcfe7_540","contentType":"application/rss+xml","totalBytes":125938,"bgimgsTotal":4,"bgimgsGithubTotal":4,"articlesImgsTotal":5,"articlesImgsGithubTotal":5,"successGithubMap":{"myreaderx6":1,"myreaderx32":1,"myreaderx11":1,"myreaderx12":1,"myreaderx24":1,"myreaderx1":1,"myreaderx30":1,"myreaderx18":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-16 17:44:27","updatedTime":"2020-08-23 01:32:03","id":540,"name":"开发者头条","url":"http://feedmaker.kindle4rss.com/feeds/toutiao.io.xml","subscriber":null,"website":null,"icon":"http://toutiao.io/apple-icon-57x57.png","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn52@2020_5/2020/08/22/17-32-01-270_072eae503565bd23.png","description":"","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":29018,"tmpBodyImgCdnBytes":96920,"tmpBgImgCdnBytes":0,"extra4":{"start":1598157960207,"total":0,"statList":[{"spend":1268,"msg":"获取xml内容"},{"spend":39515,"msg":"解释文章"},{"spend":1777,"msg":"正文链接上传到cdn"},{"spend":2000,"msg":"上传封面图到cdn"},{"spend":1,"msg":"修正封面图上传失败重新上传"}]},"extra5":5,"extra6":5,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://pic1.zhimg.com/v2-ef3060e936c63cf5813fd57c57039535_b.jpg","sourceStatusCode":200,"destWidth":720,"destHeight":529,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn9@2020_3/2020/08/23/04-46-41-303_6237780530775343.webp","sourceBytes":73639,"destBytes":29018,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1192,"convertSpendMs":14,"createdTime":"2020-08-23 12:46:41","host":"europe67.herokuapp.com","referer":"https://toutiao.io/k/5fht3f0","linkMd5ListStr":"93980994a43ac2a6b2c3690e5a0933d4,93980994a43ac2a6b2c3690e5a0933d4","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"28.3 KB","compressRate":"39.4%","sourceSize":"71.9 KB"},{"code":1,"isDone":false,"source":"https://pic3.zhimg.com/v2-a4a475b889dc6fac455fec0bb2389019_b.jpg","sourceStatusCode":200,"destWidth":1426,"destHeight":424,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn28@2020_3/2020/08/23/04-46-42-971_f6e084043311e8cf.webp","sourceBytes":44213,"destBytes":17158,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1311,"convertSpendMs":32,"createdTime":"2020-08-23 12:46:42","host":"us-008.herokuapp.com","referer":"https://toutiao.io/k/5fht3f0","linkMd5ListStr":"93980994a43ac2a6b2c3690e5a0933d4","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"16.8 KB","compressRate":"38.8%","sourceSize":"43.2 KB"},{"code":1,"isDone":false,"source":"http://mmbiz.qpic.cn/mmbiz_png/sC8cuWIVuv6VuUPNo8usMp1OLVzOoytaasa8wicev4xEtL2217SRszvXhjxkJuw6yTrq3MVqWFFGI65h1pbE9NA/0?wx_fmt=png","sourceStatusCode":200,"destWidth":1067,"destHeight":400,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn22@2020_6/2020/08/23/04-46-43-013_4cd16bc548ff4c8d.webp","sourceBytes":24861,"destBytes":15880,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1393,"convertSpendMs":27,"createdTime":"2020-08-23 12:46:42","host":"us-028.herokuapp.com","referer":"https://toutiao.io/k/53h9oed","linkMd5ListStr":"93fc10e6dbf04b42221ebf1d75a45096","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"15.5 KB","compressRate":"63.9%","sourceSize":"24.3 KB"},{"code":1,"isDone":false,"source":"https://pic3.zhimg.com/v2-5f3e9230cffe936eb24adfa99af4a869_180x120.jpg","sourceStatusCode":200,"destWidth":640,"destHeight":320,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn15@2020_6/2020/08/23/04-46-43-115_82b822c267d61423.webp","sourceBytes":33248,"destBytes":26514,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1528,"convertSpendMs":10,"createdTime":"2020-08-23 12:46:42","host":"us-52.herokuapp.com","referer":"https://toutiao.io/k/5fht3f0","linkMd5ListStr":"93980994a43ac2a6b2c3690e5a0933d4","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"25.9 KB","compressRate":"79.7%","sourceSize":"32.5 KB"},{"code":1,"isDone":false,"source":"https://pic4.zhimg.com/v2-cfefda8e4b484e3aaea7aad55f240635_180x120.jpg","sourceStatusCode":200,"destWidth":660,"destHeight":304,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn30@2020_4/2020/08/23/04-46-43-166_6092c83fc9326da8.webp","sourceBytes":36331,"destBytes":34562,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1654,"convertSpendMs":13,"createdTime":"2020-08-23 12:46:42","host":"us-013.herokuapp.com","referer":"https://toutiao.io/k/5fht3f0","linkMd5ListStr":"93980994a43ac2a6b2c3690e5a0933d4","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"33.8 KB","compressRate":"95.1%","sourceSize":"35.5 KB"},{"code":1,"isDone":false,"source":"https://pic3.zhimg.com/v2-f6b31f5caf6144c2095a1d00a6edb9c2_b.jpg","sourceStatusCode":200,"destWidth":700,"destHeight":602,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn33@2020_3/2020/08/23/04-46-43-245_a991af5300091794.webp","sourceBytes":47416,"destBytes":18686,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1656,"convertSpendMs":13,"createdTime":"2020-08-23 12:46:42","host":"us-005.herokuapp.com","referer":"https://toutiao.io/k/5fht3f0","linkMd5ListStr":"93980994a43ac2a6b2c3690e5a0933d4","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"18.2 KB","compressRate":"39.4%","sourceSize":"46.3 KB"},{"code":1,"isDone":false,"source":"http://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm11NjicrrKCeC0nfvOdDpBKx9lXoDyDrcjHTKWMxAbC86QU9ibyVjw5zESkYAeM3KmrV7iaBXRaRpGQ/0?wx_fmt=jpeg","sourceStatusCode":200,"destWidth":909,"destHeight":905,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn24@2020_4/2020/08/23/04-46-43-267_ddd4a1bad8a7f07e.webp","sourceBytes":101582,"destBytes":70514,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1738,"convertSpendMs":34,"createdTime":"2020-08-23 12:46:42","host":"us-007.herokuapp.com","referer":"https://toutiao.io/k/rfvpcag","linkMd5ListStr":"25f5be28633a60c6f6324adca1a8a72b","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"68.9 KB","compressRate":"69.4%","sourceSize":"99.2 KB"},{"code":1,"isDone":false,"source":"http://mmbiz.qpic.cn/mmbiz_jpg/ib3G4kbB3s90rrH58pAeic036rLqLof2c1Xek25ugEiaAZY7faiaBzyVg5Yj0Ilr84VkWZUHoxfCO9pPyu6hreWSHA/0?wx_fmt=jpeg","sourceStatusCode":200,"destWidth":1280,"destHeight":544,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn13@2020_6/2020/08/23/04-46-43-551_d57a1d8c0a317f72.webp","sourceBytes":36953,"destBytes":22314,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1917,"convertSpendMs":20,"createdTime":"2020-08-23 12:46:42","host":"us-53.herokuapp.com","referer":"https://toutiao.io/k/svce46c","linkMd5ListStr":"0ab5a9e86ece1aaa6db5196ae763ce99","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"21.8 KB","compressRate":"60.4%","sourceSize":"36.1 KB"}],"successGithubMap":{"myreaderx6":1,"myreaderx32":1,"myreaderx11":1,"myreaderx12":1,"myreaderx24":1,"myreaderx1":1,"myreaderx30":1,"myreaderx18":1},"failGithubMap":{}}