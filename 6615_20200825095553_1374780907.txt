{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-08-25 17:55:24","updatedTime":"2020-08-25 17:55:24","title":"Go微服务架构系列--gin框架(上) ","link":"https://segmentfault.com/a/1190000023725914","description":"<p><img src=\"https://segmentfault.com/img/bVbLIlu\" alt=\"image\" title=\"image\"><br>hi，大家好，小弟飞狐。这次带来的是Golang微服务系列。Deno从零到架构级系列文章里就提到过微服务。最近一次项目重构中，采用了go-micro微服务架构。又恰逢deno1.0正式版推出，于是乎node业务层也用deno重写。把Java的业务模块也全部用go重构了。</br></img></p>\n<h3>Go-micro重构Java业务</h3>\n<p>重构业务的时候，我们用go-micro来做微服务，全面的替代了Java栈。比如：</p>\n<ul>\n <li>服务注册发现用到了etcd</li>\n <li>通信用到了grpc</li>\n <li>框架集成了gin</li>\n</ul>\n<p>订单、支付等等都作为单独的服务。而deno之上都归前端来处理业务层，这样职责明确，更利于前后端协作。另外，我们这套将会采用最新的<strong>go-micro V3</strong>来搭建架构。</p>\n<p><img src=\"https://segmentfault.com/img/bVbLIlw\" alt=\"image\" title=\"image\" /></p>\n<h3>gin框架初体验</h3>\n<p>话不多说，即刻开始。这套微服务系列不是入门教程，需要有go项目经验。从框架选型开始，到go-micro构建微服务架构。go的框架选型不用纠结。在go的web框架中，飞狐推荐两个框架：</p>\n<ul>\n <li>echo</li>\n <li>gin</li>\n</ul>\n<p>介绍这两框架的文章太多了，优势与区别我就不多说了。这两个框架大家可以任选其一，可以任凭喜好，那飞狐选择gin框架，并将gin框架集成到go-micro中。我们先从gin基础架构搭建开始。先来个简单的例子，如下：</p>\n<pre><code class=\"go\">package main\n// 获取gin\nimport \"github.com/gin-gonic/gin\"\n\n// 主函数\nfunc main() {\n    // 取r是router的缩写\n    r := gin.Default()\n    // 这里非常简单，很像deno、node的路由吧\n    r.GET(\"/\", func(c \\*gin.Context) {\n        c.JSON(200, gin.H{ \"message\": \"pong\", })\n    })\n    // 监听端口8080\n    r.Run(\":8080\")\n}</code></pre>\n<p>这个例子非常简单，直接copy的gin官方代码。加了中文注释，运行即可，相信有点基础的童鞋都能看懂。这里的路由，一般会单独写文件来维护。不过，我在deno架构系列中提到过，拿到项目直接就是干路由，不要去维护一个单独的路由文件。deno系列我们用的是注解路由。虽然go也可以通过反射实现注解路由，但go不是一门面向对象的语言。根据go的语法特性，<strong>飞狐推荐把路由放到控制层中维护</strong>。</p>\n<p><img src=\"https://segmentfault.com/img/bVbLIl5\" alt=\"image\" title=\"image\" /></p>\n<h3>路由改造</h3>\n<p>路由改造之前我们新建controller层，然后操作如下：</p>\n<pre><code class=\"go\">// 新建userController.go\npackage controller\nimport (\n    \"github.com/gin-gonic/gin\"\n)\ntype UserController struct {\n    *gin.Engine\n}\n\n// 这里是构造函数\nfunc NewUserController(e *gin.Engine) *UserController {\n    return &amp;UserController{e}\n}\n\n// 这里是业务方法\nfunc (this *UserController) GetUser() gin.HandlerFunc {\n    return func(ctx *gin.Context) {\n        ctx.JSON(200, gin.H{\n            \"data\": \"hello world\",\n        })\n    }\n}\n\n// 这里是处理路由的地儿\nfunc (this *UserController) Router () {\n    this.Handle(\"GET\", \"/\", this.GetUser())\n}</code></pre>\n<p>这样路由就维护到每个控制器中了，那如何映射呢？我们改造主文件如下：</p>\n<pre><code class=\"go\">func main () {\n    r := gin.Default()\n    NewUserController(r).Router()\n    r.Run(\":8080\")\n}</code></pre>\n<p>关键代码就是将构造器的Router方法在主函数中执行。这样就达到目的，不用去维护单独的路由文件了。不过，大家发现没？这样也带来了一些弊端。比如：</p>\n<ul>\n <li>规范性很差</li>\n <li>代码耦合性高</li>\n <li>灵活性不够、维护起来就很麻烦</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/bVbLIl6\" alt=\"image\" title=\"image\" /></p>\n<h3>搭建脚手架</h3>\n<p>为了解决上述弊端，基于gin我们搭建一个脚手架。就如同我们基于oak搭建deno的脚手架一样。同样换做echo框架也同样适用。新建server目录，在此目录下新建server.go文件，代码如下：</p>\n<pre><code class=\"go\">package server\n\nimport (\n    \"github.com/gin-gonic/gin\"\n)\n// 这里是定义一个接口，解决上述弊端的规范性\ntype IController interface {\n    // 这个传参就是脚手架主程\n    Router(server *Server)\n}\n\n// 定义一个脚手架\ntype Server struct {\n    *gin.Engine\n    // 路由分组一会儿会用到\n    g *gin.RouterGroup\n}\n\n// 初始化函数\nfunc Init() *Server {\n    // 作为Server的构造器\n    s := &amp;Server{Engine: gin.New()}\n    // 返回作为链式调用\n    return s\n}\n\n// 监听函数，更好的做法是这里的端口应该放到配置文件\nfunc (this *Server) Listen() {\n    this.Run(\":8080\")\n}\n\n// 这里是路由的关键代码，这里会挂载路由\nfunc (this *Server) Route(controllers ...IController) *Server {\n    // 遍历所有的控制层，这里使用接口，就是为了将Router实例化\n    for _, c := range controllers {\n        c.Router(this)\n    }\n    return this\n}</code></pre>\n<p>这一步完成了，主函数就减负了，主函数改造如下：</p>\n<pre><code class=\"go\">// main.go\npackage main\n\nimport (\n    . \"feihu/controller\"\n    \"feihu/server\"\n)\n// 这里其实之前飞狐讲的deno入口文件改造几乎一样\nfunc main () {\n    // 这里就是脚手架提供的服务\n    server.\n    // 初始化\n    Init().\n    // 路由\n    Route(\n        NewUserController(),\n    ).\n    // 监听端口\n    Listen()\n}</code></pre>\n<p>那控制层的代码也会相应简化，之前的控制层代码改造如下：</p>\n<pre><code class=\"go\">package controller\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"feihu/server\"\n)\n\n// 这里的gin引擎直接移到脚手架server里\ntype UserController struct {\n}\n\n// 这里是构造函数\nfunc NewUserController() *UserController {\n    return &amp;UserController{}\n}\n\n// 这里是业务方法\nfunc (this *UserController) GetUser() gin.HandlerFunc {\n    return func(ctx *gin.Context) {\n        ctx.JSON(200, gin.H{\n            \"data\": \"hello world\",\n        })\n    }\n}\n\n// 这里依然是处理路由的地儿，而由于我们定义了接口规范，就必须实现Router方法\nfunc (this *UserController) Router (server *server.Server) {\n    server.Handle(\"GET\", \"/\", this.GetUser())\n}</code></pre>\n<p>这样就比较完善了。不过众所周知，gin支持路由分组。如何实现呢？我们继续往下。</p>\n<h3>路由分组</h3>\n<p>路由分组只需要在server.go里加一个方法就OK了，代码如下：</p>\n<pre><code>func (this *Server) GroupRouter(group string, controllers ...IController) *Server {\n    this.g = this.Group(group)\n    for _, c := range controllers {\n        c.Router(this)\n    }\n    return this\n}\n</code></pre>\n<p>使用路由分组时，主函数main.go的代码如下：</p>\n<pre><code class=\"go\">package main\n\nimport (\n    . \"feihu/controller\"\n    \"feihu/server\"\n)\n\nfunc main () {\n    server.\n    Init().\n    Route(\n        NewUserController(),\n    ).\n    // 这里就是路由分组啦\n    GroupRouter(\"v1\",\n        NewOrderController(),\n    ).\n    Listen()\n}</code></pre>\n<p>好啦，这篇内容就结束了。下面是彩蛋部分，还有激情的小伙伴，鼓励继续学。</p>\n<p><img src=\"https://segmentfault.com/img/bVbLIl7\" alt=\"image\" title=\"image\" /></p>\n<h3>彩蛋：Go设计模式之单例模式</h3>\n<p>今天的内容其实很轻松，加餐部分我们来个Go的设计模式好了。几年前<a href=\"https://segmentfault.com/blog/feihu\">《听飞狐聊JavaScript设计模式》</a>中有讲到单利模式。JS、Java实现单利模式都特别简单，但Go不太一样，我们就拿单利模式来玩玩儿。从最简单的例子开始</p>\n<pre><code class=\"go\">package main\n\nimport \"fmt\"\n// 定义结构\ntype Singleton struct {\n    MobileUrl string\n}\n// 变量\nvar instance *Singleton\n// 这里是单例，返回的是单例结构\nfunc  GetSingleton() *Singleton {\n    // 先判断变量是否存在，如果不存在才创建\n    if instance == nil {\n        instance = &amp;Singleton{MobileUrl: \"https://www.aizmen.com\"}\n    }\n    return instance\n}\n\nfunc main () {\n    x := GetSingleton()  // 单独打印x，可以得到：&amp;{https://www.aizmen.com}\n\n    x1 := GetSingleton()  // 单独打印x1，也得到：&amp;{https://www.aizmen.com}\n    fmt.Println(x == x1) \n}</code></pre>\n<p>打印结果为：true，说明是同一块内存。这样就实现了最简单的单利模式了。</p>\n<h3>sync.Once单例模式</h3>\n<p>Go其实提供了一个更简洁的sync.Once，实现如下：</p>\n<pre><code class=\"go\">package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\ntype Singleton struct {\n    MobileUrl string\n}\n\nvar (\n    once     sync.Once\n    instance *Singleton\n)\nfunc GetSingleton() *Singleton {\n    once.Do(func() {\n        instance = &amp;Singleton{MobileUrl: \"https://www.aizmen.com\"}\n    })\n    return instance\n}\n\nfunc main () {\n    x := GetSingleton()\n    x1 := GetSingleton()\n    fmt.Println(x == x1)\n}\n</code></pre>\n<p>众所周知，Go语言的协程很强大，在使用协程时，可以使用sync.Once来控制。</p>\n<h3>单例模式之加锁机制</h3>\n<p>Go还提供了一个基础对象sync.Mutex，用以实现协程之间的同步逻辑，代码实现如下：</p>\n<pre><code class=\"go\">package main\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\ntype Singleton struct {\n    MobileUrl string\n}\nvar (\n    once     sync.Once\n    instance *Singleton\n    mutex sync.Mutex\n)\nfunc GetSingleton() *Singleton {\n    mutex.Lock()\n    defer mutex.Unlock()\n    if instance == nil {\n        instance = &amp;Singleton{MobileUrl: \"https://www.aizmen.com\"}\n    }\n    return instance\n}\n\nfunc main () {\n    x := GetSingleton()\n    x1 := GetSingleton()\n    fmt.Println(x == x1)\n}</code></pre>\n<p>好啦，这篇的内容就全部结束啦，后续内容会讲中间件、错误处理等等。</p>","descriptionType":"html","publishedDate":"Tue, 25 Aug 2020 02:00:00 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLIlu","linkMd5":"2e8010fe1e3267b74b961aaa740bda56","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn58@2020_3/2020/08/25/09-55-41-592_a62e8ed1d2e9de09.webp","destWidth":800,"destHeight":450,"sourceBytes":91236,"destBytes":34334,"author":"飞狐","articleImgCdnMap":{"https://segmentfault.com/img/bVbLIlu":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn58@2020_3/2020/08/25/09-55-41-592_a62e8ed1d2e9de09.webp","https://segmentfault.com/img/bVbLIlw":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn39@2020_4/2020/08/25/09-55-49-797_1ab8edceafbdb3f2.webp","https://segmentfault.com/img/bVbLIl5":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn25@2020_5/2020/08/25/09-55-49-947_6cddad447b6009cd.webp","https://segmentfault.com/img/bVbLIl6":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn23@2020_5/2020/08/25/09-55-49-712_b939c3ffbbcabd2e.webp","https://segmentfault.com/img/bVbLIl7":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn19@2020_2/2020/08/25/09-55-49-684_9589bb6404eec2c3.webp"},"publishedOrCreatedDate":1598349324348},{"createdTime":"2020-08-25 17:55:24","updatedTime":"2020-08-25 17:55:24","title":"OpenResty 和 Nginx 的共享内存区是如何消耗物理内存的","link":"https://segmentfault.com/a/1190000023588957","description":"<p><a href=\"https://openresty.org/cn/\" rel=\"nofollow noreferrer\">OpenResty</a> 和 Nginx 服务器通常会配置共享内存区，用于储存在所有工作进程之间共享的数据。例如，Nginx 标准模块 <a href=\"http://nginx.org/en/docs/http/ngx_http_limit_req_module.html\" rel=\"nofollow noreferrer\">ngx_http_limit_req</a> 和 <a href=\"http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html\" rel=\"nofollow noreferrer\">ngx_http_limit_conn</a> 使用共享内存区储存状态数据，以限制所有工作进程中的用户请求速率和用户请求的并发度。OpenResty 的 <a href=\"https://github.com/openresty/lua-nginx-module#readme\" rel=\"nofollow noreferrer\">ngx_lua</a> 模块通过 <a href=\"https://github.com/openresty/lua-nginx-module#lua_shared_dict\" rel=\"nofollow noreferrer\">lua_shared_dict</a>，向用户 Lua 代码提供基于共享内存的数据字典存储。</p> \n<p>本文通过几个简单和独立的例子，探讨这些共享内存区如何使用物理内存资源（或 RAM）。我们还会探讨共享内存的使用率对系统层面的进程内存指标的影响，例如在 <code>ps</code> 等系统工具的结果中的 <code>VSZ</code> 和 <code>RSS</code> 等指标。</p> \n<p>与本<a href=\"https://blog.openresty.com.cn/cn/?src=sf\" rel=\"nofollow noreferrer\">博客网站</a> 中的几乎所有技术类文章类似，我们使用 <a href=\"https://openresty.com.cn/cn/xray/\" rel=\"nofollow noreferrer\">OpenResty XRay</a> 这款<a href=\"https://blog.openresty.com.cn/cn/dynamic-tracing/?src=sf\" rel=\"nofollow noreferrer\">动态追踪</a>产品对未经修改的 OpenResty 或 Nginx 服务器和应用的内部进行深度分析和可视化呈现。因为 <a href=\"https://openresty.com.cn/cn/xray/\" rel=\"nofollow noreferrer\">OpenResty XRay</a> 是一个非侵入性的分析平台，所以我们不需要对 OpenResty 或 Nginx 的目标进程做任何修改 -- 不需要代码注入，也不需要在目标进程中加载特殊插件或模块。这样可以保证我们通过 <a href=\"https://openresty.com.cn/cn/xray/\" rel=\"nofollow noreferrer\">OpenResty XRay</a> 分析工具所看到的目标进程内部状态，与没有观察者时的状态是完全一致的。</p> \n<p>我们将在多数示例中使用 <a href=\"https://github.com/openresty/lua-nginx-module#readme\" rel=\"nofollow noreferrer\">ngx_lua</a> 模块的 <a href=\"https://github.com/openresty/lua-nginx-module#lua_shared_dict\" rel=\"nofollow noreferrer\">lua_shared_dict</a>，因为该模块可以使用自定义的 Lua 代码进行编程。我们在这些示例中展示的行为和问题，也同样适用于所有标准 Nginx 模块和第三方模块中的其他共享内存区。</p> \n<h1>Slab 与内存页</h1> \n<p>Nginx 及其模块通常使用 Nginx 核心里的 <em>slab 分配器</em> 来管理共享内存区内的空间。这个slab 分配器专门用于在固定大小的内存区内分配和释放较小的内存块。</p> \n<p>在 slab 的基础之上，共享内存区会引入更高层面的数据结构，例如红黑树和链表等等。</p> \n<p>slab 可能小至几个字节，也可能大至跨越多个内存页。</p> \n<p>操作系统以内存页为单位来管理进程的共享内存（或其他种类的内存）。<br>在 <code>x86_64</code> Linux 系统中，默认的内存页大小通常是 4 KB，但具体大小取决于体系结构和 Linux 内核的配置。例如，某些 <code>Aarch64</code> Linux 系统的内存页大小高达 64 KB。</br></p> \n<p>我们将会看到 OpenResty 和 Nginx 进程的共享内存区，分别在内存页层面和 slab 层面上的细节信息。</p> \n<h1>分配的内存不一定有消耗</h1> \n<p>与硬盘这样的资源不同，物理内存（或 RAM）总是一种非常宝贵的资源。<br>大部分现代操作系统都实现了一种优化技术，叫做 <a href=\"https://en.wikipedia.org/wiki/Demand_paging\" rel=\"nofollow noreferrer\">按需分页</a>（demand-paging），用于减少用户应用对 RAM 资源的压力。具体来说，就是当你分配大块的内存时，操作系统核心会将 RAM 资源（或物理内存页）的实际分配推迟到内存页里的数据被实际使用的时候。例如，如果用户进程分配了 10 个内存页，但却只使用了 3 个内存页，则操作系统可能只把这 3 个内存页映射到了 RAM 设备。这种行为同样适用于 Nginx 或 OpenResty 应用中分配的共享内存区。用户可以在 <code>nginx.conf</code> 文件中配置庞大的共享内存区，但他可能会注意到在服务器启动之后，几乎没有额外占用多少内存，毕竟通常在刚启动的时候，几乎没有共享内存页被实际使用到。</br></p> \n<h2>空的共享内存区</h2> \n<p>我们以下面这个 <code>nginx.conf</code> 文件为例。该文件分配了一个空的共享内存区，并且从没有使用过它：</p> \n<pre><code class=\"nginx\">master_process on;\nworker_processes 2;\n\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    lua_shared_dict dogs 100m;\n\n    server {\n        listen 8080;\n\n        location = /t {\n            return 200 \"hello world\\n\";\n        }\n    }\n}</code></pre> \n<p>我们通过 <a href=\"https://github.com/openresty/lua-nginx-module#lua_shared_dict\" rel=\"nofollow noreferrer\">lua_shared_dict</a> 指令配置了一个 100 MB 的共享内存区，名为 <code>dogs</code>。并且我们为这个服务器配置了 2 个工作进程。请注意，我们在配置里从没有触及这个 <code>dogs</code> 区，所以这个区是空的。</p> \n<p>可以通过下列命令启动这个服务器：</p> \n<pre><code class=\"bash\">mkdir ~/work/\ncd ~/work/\nmkdir logs/ conf/\nvim conf/nginx.conf  # paste the nginx.conf sample above here\n/usr/local/openresty/nginx/sbin/nginx -p $PWD/</code></pre> \n<p>然后用下列命令查看 nginx 进程是否已在运行：</p> \n<pre><code class=\"console\">$ ps aux|head -n1; ps aux|grep nginx\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nagentzh   9359  0.0  0.0 137508  1576 ?        Ss   09:10   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /home/agentzh/work/\nagentzh   9360  0.0  0.0 137968  1924 ?        S    09:10   0:00 nginx: worker process\nagentzh   9361  0.0  0.0 137968  1920 ?        S    09:10   0:00 nginx: worker process</code></pre> \n<p>这两个工作进程占用的内存大小很接近。下面我们重点研究 PID 为 9360 的这个工作进程。在 <a href=\"https://openresty.com.cn/cn/xray/\" rel=\"nofollow noreferrer\">OpenResty XRay</a> 控制台的 Web 图形界面中，我们可以看到这个进程一共占用了 134.73 MB 的虚拟内存（virtual memory）和 1.88 MB 的常驻内存（resident memory），这与上文中的 <code>ps</code> 命令输出的结果完全相同：</p> \n<p><img src=\"https://segmentfault.com/img/bVbK7gY\" alt=\"空的共享内存区的虚拟内存使用量明细\" title=\"空的共享内存区的虚拟内存使用量明细\" /></p> \n<p>正如我们的另一篇文章 <a href=\"https://segmentfault.com/a/1190000021673696\">《OpenResty 和 Nginx 如何分配和管理内存》</a>中所介绍的，我们最关心的就是常驻内存的使用量。常驻内存将硬件资源实际映射到相应的内存页（如 RAM <sup id=\"fnref-1\"><a href=\"https://segmentfault.com/a/1190000023588957#fn-1\" class=\"footnote-ref\">1</a></sup>）。所以我们从图中看到，实际映射到硬件资源的内存量很少，总计只有 1.88MB。上文配置的 100 MB 的共享内存区在这个常驻内存当中只占很小的一部分（详情请见后续的讨论）。</p> \n<p>当然，共享内存区的这 100 MB 还是全部贡献到了该进程的虚拟内存总量中去了。操作系统会为这个共享内存区预留出虚拟内存的地址空间，不过，这只是一种簿记记录，此时并不占用任何的 RAM 资源或其他硬件资源。</p> \n<h3>空 <em>不是</em> 空无一物</h3> \n<p>我们可以通过该进程的“应用层面的内存使用量的分类明细”图，来检查空的共享内存区是否占用了常驻（或物理）内存。</p> \n<p><img src=\"https://segmentfault.com/img/bVbK7if\" alt=\"应用层面内存使用量明细\" title=\"应用层面内存使用量明细\" /></p> \n<p>有趣的是，我们在这个图中看到了一个非零的 <code>Nginx Shm Loaded</code> （已加载的 Nginx 共享内存）组分。这部分很小，只有 612 KB，但还是出现了。所以空的共享内存区也并非空无一物。这是因为 Nginx 已经在新初始化的共享内存区域中放置了一些元数据，用于簿记目的。这些元数据为 Nginx 的 slab 分配器所使用。</p> \n<h3>已加载和未加载内存页</h3> \n<p>我们可以通过 <a href=\"https://openresty.com.cn/cn/xray/\" rel=\"nofollow noreferrer\">OpenResty XRay</a> 自动生成的下列图表，查看共享内存区内被实际使用（或加载）的内存页数量。</p> \n<p><img src=\"https://segmentfault.com/img/bVbK7iK\" alt=\"共享内存区域内已加载和未加载的内存页\" title=\"共享内存区域内已加载和未加载的内存页\" /></p> \n<p>我们发现在<code>dogs</code>区域中已经加载（或实际使用）的内存大小为 608 KB，同时有一个特殊的 <code>ngx_accept_mutex_ptr</code> 被 Nginx 核心自动分配用于 accept_mutex 功能。</p> \n<p>这两部分内存的大小相加为 612 KB，正是上文的饼状图中显示的 <code>Nginx Shm Loaded</code> 的大小。</p> \n<p>如前文所述，<code>dogs</code> 区使用的 608 KB 内存实际上是 <em>slab 分配器</em> 使用的元数据。</p> \n<p>未加载的内存页只是被保留的虚拟内存地址空间，并没有被使用过。</p> \n<h4>关于进程的页表</h4> \n<p>我们没有提及的一种复杂性是，每一个 nginx 工作进程其实都有各自的<a href=\"https://en.wikipedia.org/wiki/Page_table\" rel=\"nofollow noreferrer\">页表</a>。CPU 硬件或操作系统内核正是通过查询这些页表来查找虚拟内存页所对应的存储。因此每个进程在不同共享内存区内可能有不同的<em>已加载页</em>集合，因为每个进程在运行过程中可能访问过不同的内存页集合。为了简化这里的分析，<a href=\"https://openresty.com.cn/cn/xray/\" rel=\"nofollow noreferrer\">OpenResty XRay</a> 会显示所有的为<em>任意一个</em>工作进程加载过的内存页，即使当前的目标工作进程从未碰触过这些内存页。也正因为这个原因，已加载内存页的总大小可能（略微）高于目标进程的常驻内存的大小。</p> \n<h3>空闲的和已使用的 slab</h3> \n<p>如上文所述，Nginx 通常使用 <em>slabs</em> 而不是内存页来管理共享内存区内的空间。我们可以通过 <a href=\"https://openresty.com.cn/cn/xray/\" rel=\"nofollow noreferrer\">OpenResty XRay</a> 直接查看某一个共享内存区内已使用的和空闲的（或未使用的）slabs 的统计信息：</p> \n<p><img src=\"https://segmentfault.com/img/bVbK7j4\" alt=\"dogs区域中空的和已使用的slab\" title=\"dogs区域中空的和已使用的slab\" /></p> \n<p>如我们所预期的，我们这个例子里的大部分 slabs 是<em>空闲的</em>或<em>未被使用的</em>。注意，这里的内存大小的数字远小于上一节中所示的内存页层面的统计数字。这是因为 slabs 层面的抽象层次更高，并不包含 slab 分配器针对内存页的大小补齐和地址对齐的内存消耗。</p> \n<p>我们可以通过<a href=\"https://openresty.com.cn/cn/xray/\" rel=\"nofollow noreferrer\">OpenResty XRay</a>进一步观察在这个 <code>dogs</code> 区域中各个 slab 的大小分布情况：</p> \n<p><img src=\"https://segmentfault.com/img/bVbK7kP\" alt=\"空白区域的已使用 slab 大小分布\" title=\"空白区域的已使用 slab 大小分布\" /></p> \n<p><img src=\"https://segmentfault.com/img/bVbK7lh\" alt=\"空的 slab 大小分布\" title=\"空的 slab 大小分布\" /></p> \n<p>我们可以看到这个空的共享内存区里，仍然有 3 个已使用的 slab 和 157 个空闲的 slab。这些 slab 的总个数为：3 + 157 = 160个。请记住这个数字，我们会在下文中跟写入了一些用户数据的 <code>dogs</code> 区里的情况进行对比。</p> \n<h2>写入了用户数据的共享内存区</h2> \n<p>下面我们会修改之前的配置示例，在 Nginx 服务器启动时主动写入一些数据。具体做法是，我们在 <code>nginx.conf</code> 文件的 <code>http {}</code> 配置分程序块中增加下面这条 <a href=\"https://github.com/openresty/lua-nginx-module#init_by_lua_block\" rel=\"nofollow noreferrer\">init_by_lua_block</a> 配置指令：</p> \n<pre><code class=\"nginx\">init_by_lua_block {\n    for i = 1, 300000 do\n        ngx.shared.dogs:set(\"key\" .. i, i)\n    end\n}</code></pre> \n<p>这里在服务器启动的时候，主动对 <code>dogs</code> 共享内存区进行了初始化，写入了 300,000 个键值对。</p> \n<p>然后运行下列的 shell 命令以重新启动服务器进程：</p> \n<pre><code class=\"bash\">kill -QUIT `cat logs/nginx.pid`\n/usr/local/openresty/nginx/sbin/nginx -p $PWD/</code></pre> \n<p>新启动的 Nginx 进程如下所示：</p> \n<pre><code class=\"consoel\">$ ps aux|head -n1; ps aux|grep nginx\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nagentzh  29733  0.0  0.0 137508  1420 ?        Ss   13:50   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /home/agentzh/work/\nagentzh  29734 32.0  0.5 138544 41168 ?        S    13:50   0:00 nginx: worker process\nagentzh  29735 32.0  0.5 138544 41044 ?        S    13:50   0:00 nginx: worker process</code></pre> \n<h3>虚拟内存与常驻内存</h3> \n<p>针对 Nginx 工作进程 29735，<a href=\"https://openresty.com.cn/cn/xray/\" rel=\"nofollow noreferrer\">OpenResty XRay</a> 生成了下面这张饼图：</p> \n<p><img src=\"https://segmentfault.com/img/bVbK7mp\" alt=\"非空白区域的虚拟内存使用量明细\" title=\"非空白区域的虚拟内存使用量明细\" /></p> \n<p>显然，常驻内存的大小远高于之前那个空的共享区的例子，而且在总的虚拟内存大小中所占的比例也更大（29.6%）。</p> \n<p>虚拟内存的使用量也略有增加（从 134.73 MB 增加到了 135.30 MB）。因为共享内存区本身的大小没有变化，所以共享内存区对于虚拟内存使用量的增加其实并没有影响。这里略微增大的原因是我们通过 <a href=\"https://github.com/openresty/lua-nginx-module#init_by_lua_block\" rel=\"nofollow noreferrer\">init_by_lua_block</a> 指令新引入了一些 Lua 代码（这部分微小的内存也同时贡献到了常驻内存中去了）。</p> \n<p>应用层面的内存使用量明细显示，Nginx 共享内存区域的已加载内存占用了最多常驻内存：</p> \n<p><img src=\"https://segmentfault.com/img/bVbK7ni\" alt=\"dogs 区域内已加载和未加载的内存页\" title=\"dogs 区域内已加载和未加载的内存页\" /></p> \n<h3>已加载和未加载内存页</h3> \n<p>现在在这个 <code>dogs</code> 共享内存区里，已加载的内存页多了很多，而未加载的内存页也有了相应的显著减少：</p> \n<p><img src=\"https://segmentfault.com/img/bVbK7qi\" alt=\"dogs区域中的已加载和未加载内存页\" title=\"dogs区域中的已加载和未加载内存页\" /></p> \n<h3>空的和已使用的 slab</h3> \n<p>现在 <code>dogs</code> 共享内存区增加了 300,000 个已使用的 slab（除了空的共享内存区中那 3 个总是会预分配的 slab 以外）：</p> \n<p><img src=\"https://segmentfault.com/img/bVbK7qD\" alt=\"dogs非空白区域中的已使用slab\" title=\"dogs非空白区域中的已使用slab\" /></p> \n<p>显然，<a href=\"https://github.com/openresty/lua-nginx-module#lua_shared_dict\" rel=\"nofollow noreferrer\">lua_shared_dict</a> 区中的每一个键值对，其实都直接对应一个 slab。</p> \n<p>空闲 slab 的数量与先前在空的共享内存区中的数量是完全相同的，即 157 个 slab：</p> \n<p><img src=\"https://segmentfault.com/img/bVbK7lh\" alt=\"dogs非空白区域的空slab\" title=\"dogs非空白区域的空slab\" /></p> \n<h1>虚假的内存泄漏</h1> \n<p>正如我们上面所演示的，共享内存区在应用实际访问其内部的内存页之前，都不会实际耗费物理内存资源。因为这个原因，用户可能会观察到 Nginx 工作进程的常驻内存大小似乎会持续地增长，特别是在进程刚启动之后。这会让用户误以为存在内存泄漏。下面这张图展示了这样的一个例子：</p> \n<p><img src=\"https://segmentfault.com/img/bVbK7rA\" alt=\"process memory growing\" title=\"process memory growing\" /></p> \n<p>通过查看 OpenResty XRay 生成的应用级别的内存使用明细图，我们可以清楚地看到 Nginx 的共享内存区域其实占用了绝大部分的常驻内存空间：</p> \n<p><img src=\"https://segmentfault.com/img/bVbK7rU\" alt=\"Memory usage breakdown for huge shm zones\" title=\"Memory usage breakdown for huge shm zones\" /></p> \n<p>这种内存增长是暂时的，会在共享内存区被填满时停止。但是当用户把共享内存区配置得特别大，大到超出当前系统中可用的物理内存的时候，仍然是有潜在风险的。正因为如此，我们应该注意观察如下所示的内存页级别的内存使用量的柱状图：</p> \n<p>![Loaded and unloaded memory pages in shared memory zones](/img/bVbK7iK<br>\"Loaded and unloaded memory pages in shared memory zones\")</br></p> \n<p>图中蓝色的部分可能最终会被进程用尽（即变为红色），而对当前系统产生冲击。</p> \n<h1>HUP 重新加载</h1> \n<p>Nginx 支持通过 HUP 信号来<a href=\"http://nginx.org/en/docs/control.html#reconfiguration\" rel=\"nofollow noreferrer\">重新加载服务器的配置</a>而不用退出它的 master 进程（worker 进程仍然会优雅退出并重启）。通常 Nginx 共享内存区会在 HUP 重新加载（HUP reload）之后自动继承原有的数据。所以原先为已访问过的共享内存页分配的那些物理内存页也会保留下来。于是想通过 HUP 重新加载来释放共享内存区内的常驻内存空间的尝试是会失败的。用户应改用 Nginx 的重启或<a href=\"http://nginx.org/en/docs/control.html#upgrade\" rel=\"nofollow noreferrer\">二进制升级</a>操作。</p> \n<p>值得提醒的是，某一个 Nginx 模块还是有权决定是否在 HUP 重新加载后保持原有的数据。所以可能会有例外。</p> \n<h1>结论</h1> \n<p>我们在上文中已经解释了 Nginx 的共享内存区所占用的物理内存资源，可能远少于 <code>nginx.conf</code> 文件中配置的大小。这要归功于现代操作系统中的<a href=\"https://en.wikipedia.org/wiki/Demand_paging\" rel=\"nofollow noreferrer\">按需分页</a>特性。我们演示了空的共享内存区内依然会使用到一些内存页和 slab，以用于存储 slab 分配器本身需要的元数据。通过 <a href=\"https://openresty.com.cn/cn/xray/\" rel=\"nofollow noreferrer\">OpenResty XRay</a> 的高级分析器，我们可以实时检查运行中的 nginx 工作进程，查看其中的共享内存区实际使用或加载的内存，包括内存页和 slab 这两个不同层面。</p> \n<p>另一方面，按需分页的优化也会产生内存在某段时间内持续增长的现象。这其实并不是内存泄漏，但仍然具有一定的风险。我们也解释了 Nginx 的 HUP 重新加载操作通常并不会清空共享内存区里已有的数据。</p> \n<p>我们将在<a href=\"https://blog.openresty.com.cn/cn/?src=sf\" rel=\"nofollow noreferrer\">本博客网站</a>后续的文章中，继续探讨共享内存区中使用的高级数据结构，例如红黑树和队列，以及如何分析和缓解共享内存区内的内存碎片的问题。</p> \n<h1>关于作者</h1> \n<p>章亦春是开源项目 <a href=\"https://openresty.org/cn/\" rel=\"nofollow noreferrer\">OpenResty<sup>®</sup></a> 的创始人，同时也是 <a href=\"https://openresty.com.cn/cn/\" rel=\"nofollow noreferrer\">OpenResty Inc.</a> 公司的创始人和 CEO。他贡献了许多 Nginx 的第三方模块，相当多 Nginx 和 <a href=\"https://github.com/openresty/luajit2#readme\" rel=\"nofollow noreferrer\">LuaJIT</a> 核心补丁，并且设计了 <a href=\"https://openresty.com.cn/cn/xray\" rel=\"nofollow noreferrer\">OpenResty XRay</a> 等产品。</p> \n<h1>关注我们</h1> \n<p>如果您觉得本文有价值，非常欢迎关注我们 <a href=\"https://openresty.com/\" rel=\"nofollow noreferrer\">OpenResty Inc.</a> 公司的<a href=\"https://blog.openresty.com.cn/cn/?src=sf\" rel=\"nofollow noreferrer\">博客网站</a> 。也欢迎扫码关注我们的微信公众号：</p> \n<p><img src=\"https://segmentfault.com/img/bVbLQNA\" alt=\"我们的微信公众号\" title=\"我们的微信公众号\" /></p> \n<h1>翻译</h1> \n<p>我们提供了<a href=\"https://blog.openresty.com/en/how-nginx-shm-consume-ram/?src=sf\" rel=\"nofollow noreferrer\">英文版</a>原文和中译版（本文） 。我们也欢迎读者提供其他语言的翻译版本，只要是全文翻译不带省略，我们都将会考虑采用，非常感谢！</p> \n<hr> \n <ol> \n  <li id=\"fn-1\"> 当发生交换（swapping）时，一些常驻内存会被保存和映射到硬盘设备上去。 <a href=\"https://segmentfault.com/a/1190000023588957#fnref-1\" class=\"footnote-backref\">↩</a></li> \n </ol> \n</hr>","descriptionType":"html","publishedDate":"Wed, 12 Aug 2020 02:08:56 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbK7gY","linkMd5":"17811c139a90fe837eb00a558d033704","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn46@2020_1/2020/08/25/09-55-41-171_1c7c428307a34a7e.webp","destWidth":800,"destHeight":373,"sourceBytes":43995,"destBytes":12616,"author":"OpenResty技术","articleImgCdnMap":{"https://segmentfault.com/img/bVbK7gY":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn46@2020_1/2020/08/25/09-55-41-171_1c7c428307a34a7e.webp","https://segmentfault.com/img/bVbK7if":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn55@2020_2/2020/08/25/09-55-52-199_05d188a0e6eca8e1.webp","https://segmentfault.com/img/bVbK7iK":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn47@2020_4/2020/08/25/09-55-49-271_990e0077e99f058e.webp","https://segmentfault.com/img/bVbK7j4":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn51@2020_5/2020/08/25/09-55-49-205_fcb873ab0ab5eedd.webp","https://segmentfault.com/img/bVbK7kP":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn32@2020_4/2020/08/25/09-55-49-358_7294fa6cc480165d.webp","https://segmentfault.com/img/bVbK7lh":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn35@2020_1/2020/08/25/09-55-48-736_7b67620fa91c338f.webp","https://segmentfault.com/img/bVbK7mp":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn42@2020_1/2020/08/25/09-55-49-792_d2be868524e38f59.webp","https://segmentfault.com/img/bVbK7ni":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn99@2020_5/2020/08/25/09-55-49-284_2b9874d37d2020b0.webp","https://segmentfault.com/img/bVbK7qi":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn11@2020_4/2020/08/25/09-55-50-499_a42831297c41182e.webp","https://segmentfault.com/img/bVbK7qD":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn3@2020_4/2020/08/25/09-55-50-437_5c3014e94ba141ae.webp","https://segmentfault.com/img/bVbK7rA":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn5@2020_2/2020/08/25/09-55-49-681_d2bee9c2a0429789.webp","https://segmentfault.com/img/bVbK7rU":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn14@2020_3/2020/08/25/09-55-51-276_269fb8820a4962f1.webp","https://segmentfault.com/img/bVbLQNA":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn63@2020_4/2020/08/25/09-55-49-427_24a235104dfabe34.webp"},"publishedOrCreatedDate":1598349324348},{"createdTime":"2020-08-25 17:55:24","updatedTime":"2020-08-25 17:55:24","title":"TypeScript 配置文件该怎么写？","link":"https://segmentfault.com/a/1190000023750243","description":"<p>TypeScript 的学习资料非常多，其中也不乏很多优秀的文章和教程。但是目前为止没有一个我特别满意的。原因有：</p>\n<ul>\n <li>它们大多数没有一个清晰的主线，而是按照 API 组织章节的，内容在<strong>逻辑上</strong>比较零散。</li>\n <li>大多是“讲是什么，怎么用“，而不是”讲为什么，讲原理“。</li>\n <li>大多数内容比较枯燥，趣味性比较低。都是干巴巴的文字，没有图片，缺乏能够引起强烈共鸣的例子。</li>\n</ul>\n<p>因此我的想法是做一套不同市面上大多数的 TypeScript 学习教程。以人类认知的角度思考问题，学习 TypeScript，通过通俗易懂的例子和图片来帮助大家建立 TypeScript 世界观。</p>\n<p>系列安排：</p>\n<ul>\n <li><a href=\"https://lucifer.ren/blog/2020/08/04/ts-internal/\" rel=\"nofollow noreferrer\">上帝视角看 TypeScript（已发布）</a></li>\n <li><a href=\"https://lucifer.ren/blog/2020/08/15/ts-type-system/\" rel=\"nofollow noreferrer\">TypeScript 类型系统（已发布）</a></li>\n <li><a href=\"https://lucifer.ren/blog/2020/08/21/ts-type/\" rel=\"nofollow noreferrer\">types 和 @types 是什么？（已发布）</a></li>\n <li><a href=\"https://lucifer.ren/blog/2020/06/16/ts-generics/\" rel=\"nofollow noreferrer\">你不知道的 TypeScript 泛型（万字长文，建议收藏）（已发布）</a></li>\n <li>TypeScript 配置文件该怎么写？（就是本文）</li>\n <li>TypeScript 是如何与 React，Vue，Webpack 集成的？</li>\n <li>TypeScript 练习题</li>\n</ul>\n<blockquote>\n 目录将来可能会有所调整。\n</blockquote>\n<p>注意，我的系列文章基本不会讲 API，因此需要你有一定的 TypeScript 使用基础，推荐两个学习资料。</p>\n<ul>\n <li><a href=\"https://jkchao.github.io/typescript-book-chinese/\" rel=\"nofollow noreferrer\">深入理解 TypeScript</a></li>\n <li><a href=\"https://www.typescriptlang.org/docs/home\" rel=\"nofollow noreferrer\">官方文档</a></li>\n</ul>\n<p>结合这两个资料和我的系列教程，掌握 TypeScript 指日可待。</p>\n<p>接下来，我们通过几个方面来从宏观的角度来看一下 TypeScript。</p>\n<p>&lt;!-- more --&gt;</p>\n<h2>前言</h2>\n<p>这篇文章是我的 TypeScript 系列的<strong>第 5 篇</strong>。今天我们就来看下， TypeScript 的配置文件 tsconfig.json 该如何写。</p>\n<p>和 package.json 一样， 它也是一个 JSON 文件。package.json 是包描述文件，对应的 Commonjs 规范，而 <strong>tsconfig.json 是最终被 TypeScript Compiler 解析和使用的一个 JSON 文件</strong>。 TypeScript Compiler 用这个配置文件来决定如何对项目进行编译。</p>\n<p>说到编译，不得不提一个知名选手 - <a href=\"https://www.babeljs.cn/docs/babel-cli\" rel=\"nofollow noreferrer\">babel</a>。 和 TypeScript 类似， 他们都可以将一种语法静态编译成另外一种语法。如果说我想编译一个文件，我只需要告诉 babel 我的文件路径即可。</p>\n<pre><code class=\"bash\">npx babel script.js</code></pre>\n<p>有时候我想编译整个文件夹：</p>\n<pre><code class=\"bash\">npx babel src --out-dir lib</code></pre>\n<p>babel 也可以指定输出目录，指定需要忽略的文件或目录等等， TypeScript 也是一样！你当然可以像 babel 一样在命令行中全部指定好，也可以将这些配置放到 tsconfig.json 中，以配置文件的形式传递给 TypeScript Compiler 。 这就是 tsconfig.json 文件的初衷，即接受用户输入作为配置项。</p>\n<h2>初探 tsconfig</h2>\n<p>我们先来看一个简单的 tsconfig 文件。</p>\n<pre><code class=\"json\">{\n  \"compilerOptions\": {\n    \"outDir\": \"./built\",\n    \"allowJs\": true,\n    \"target\": \"es5\"\n  },\n  \"include\": [\"./src/**/*\"]\n}</code></pre>\n<p>如上配置做了：</p>\n<ul>\n <li>读取所有可识别的 src 目录下的文件（通过 include）。</li>\n <li>接受 JavaScript 做为输入（通过 allowJs）。</li>\n <li>生成的所有文件放在 built 目录下（通过 outDir）。</li>\n <li>将 JavaScript 代码降级到低版本比如 ECMAScript 5（通过 target）。</li>\n</ul>\n<p>实际项目有比这个更复杂。 接下来， 我们来进一步解读。 不过在讲配置项之前，我们先来看下 tsconfig.json 是如何被解析的。</p>\n<h2>tsconfig 是如何被解析的？</h2>\n<p><strong>如果一个目录下存在一个 tsconfig.json 文件，那么意味着这个目录是 TypeScript 项目的根目录。</strong> 如果你使用 tsc 编译你的项目，并且没有显式地指定配置文件的路径，那么 tsc 则会逐级向上搜索父目录寻找 tsconfig.json ，这个过程类似 node 的模块查找机制。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023750246\" alt=\"\" title=\"\" /></p>\n<p>如图：</p>\n<ul>\n <li>在 _uglify-js@3.7.2@uglify-js 下执行 tsc 则会找到 配置文件 1，在 _uglify-js@3.7.2@uglify-js/bin 下执行 tsc 也会找到 配置文件 1</li>\n <li>同理在 lib，node_modules 也会找到 配置文件 1</li>\n <li>在 _uglify-js@3.7.2@uglify-js/bin/lucifer 下执行 tsc 则会找到 配置文件 2</li>\n <li>在 _uglify-js@3.7.2@uglify-js/lib/lucifer 下执行 tsc 则会找到 配置文件 3</li>\n</ul>\n<p>我在 <a href=\"https://lucifer.ren/blog/2020/08/04/ts-internal/\" rel=\"nofollow noreferrer\">上帝视角看 TypeScript</a> 一种讲述了 TypeScript 究竟做了什么，带你从宏观的角度看了一下 TypeScript。 其中提到了 TypeScript 编译器会接受文件或者文件集合作为输入，最终转换为 JavaScript（noEmit 为 false） 和 .d.ts(declarations 为 true)。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023489697\" alt=\"\" title=\"\" /></p>\n<p>这里其实还少了一个点，那就是除了接受文件或者文件集合作为输入，还会接受 tsconfig.json。tsconfig.json 的内容决定了编译的范围和行为，不同的 配置可能会得到不同的输出，或者得到不同的检查结果。</p>\n<p>当 tsc 找到了一个 tsconfig.json 文件，那么其规定的编译目录则全部会被 typescript 处理，当然也包括其依赖的文件。 如果 tsc 没有找到一个 tsconfig.json 或 tsconfig 没有有效信息，那么 tsc 会使用默认配置。 比如 tsconfig 是一个空的就没有有效信息：</p>\n<pre><code class=\"json\">{}</code></pre>\n<blockquote>\n tsconfig 的全部属性，以及属性的默认值可以在这里找到： \n <a href=\"http://json.schemastore.org/tsconfig\" rel=\"nofollow noreferrer\">http://json.schemastore.org/t...</a>\n</blockquote>\n<p>总结一下 tsc 解析 tsconfig.json 的逻辑。</p>\n<ul>\n <li><p>如果命令行指定了配置选项或者指定了配置文件的路径，那么直接会读取。</p>\n  <ul>\n   <li><p>根据 <a href=\"http://json.schemastore.org/tsconfig\" rel=\"nofollow noreferrer\">tsconfig json schema</a> 校验是否格式正确。</p>\n    <ul>\n     <li>如果正确，则将其和默认配置合并（如果有 extends 字段，也会一起合并），将合并后的配置传递给 TypeScript 编译器并开始编译。</li>\n     <li>否则抛出错误</li>\n    </ul></li>\n  </ul></li>\n <li><p>否则，会从当前目录查找 tsconfig.json 文件， 如果找不到则逐层向上搜索父目录。</p>\n  <ul>\n   <li><p>如果找到了则会去根据 <a href=\"http://json.schemastore.org/tsconfig\" rel=\"nofollow noreferrer\">tsconfig json schema</a> 校验是否格式正确。</p>\n    <ul>\n     <li>如果正确，则将其和默认配置合并（如果有 extends 字段，也会一起合并），将合并后的配置传递给 TypeScript 编译器并开始编译。</li>\n     <li>否则抛出错误</li>\n    </ul></li>\n   <li>否则，始终找不到则直接使用默认配置</li>\n  </ul></li>\n</ul>\n<h2>tsconfig 的顶层属性</h2>\n<p>tsconfig 的顶层属性（Top Level）不多，主要有：<strong>compilerOptions, files, include, exclude,extends,compileOnSave</strong>等。</p>\n<ul>\n <li>compilerOptions 是重头戏，其属性也是最多的，我们的项目也是对这个定制比较多，这个我后面会重点讲。</li>\n <li>files 则是你需要编译的文件</li>\n <li>exclude 则是你不需要编译的文件目录（支持 glob）</li>\n <li>include 是你需要编译的文件目录（支持 glob）</li>\n <li>extends 就是继承另外一个配置文件，TypeScript 会对其进行合并，多项目公共配置有用。你也可以直接继承社区的“最佳实践”，比如:</li>\n</ul>\n<pre><code class=\"json\">{\n  \"extends\": \"@tsconfig/node12/tsconfig.json\",\n\n  \"compilerOptions\": {},\n\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\"]\n}</code></pre>\n<ul>\n <li>compileOnSave 则是和编辑器（确切地说是文件系统）联动的配置，即是否在文件保存后进行编译，实际项目不建议使用。</li>\n</ul>\n<p>除了 compilerOptions，其他也相对比较好理解。 因此接下来我只针对 compilerOptions 详细讲解一番。</p>\n<h2>tsconfig 的编译项</h2>\n<p>详细全面的内容，大家只需要参考<a href=\"https://www.typescriptlang.org/tsconfig\" rel=\"nofollow noreferrer\">官网</a>的就好了。官网写的不仅全面，而且做了分类，非常清晰。</p>\n<p>接下来，我会根据功能分开讲几个<strong>常用</strong> 的配置。</p>\n<h3>文件相关</h3>\n<p>常用的是以下四个，由于前面已经做了介绍，因此就不赘述了。</p>\n<ul>\n <li>exclude</li>\n <li>extends</li>\n <li>files</li>\n <li>include</li>\n</ul>\n<h3>严格检查</h3>\n<ul>\n <li>alwaysStrict</li>\n</ul>\n<p>默认：false</p>\n<p>首次发布版本：2.1</p>\n<p>这个是和 ECMAScript 规范相关的，工作机制和 ES 5 的严格模式一样， 并且输出的 JS 顶部也会也会带上 'use strict'。</p>\n<ul>\n <li>noImplicitAny（推荐打开）</li>\n</ul>\n<p>默认：true</p>\n<p>首次发布版本：-</p>\n<p>我在 - <a href=\"https://lucifer.ren/blog/2020/08/15/ts-type-system/\" rel=\"nofollow noreferrer\">TypeScript 类型系统</a> 中提到了如果不对变量显式声明类型，那么 TypeScript 会对变量进行类型推导，这当然也有推导不出的情况，这个时候该变量的类型就是 any，这个叫做隐式 any。区别于显式 any：</p>\n<pre><code class=\"ts\">const a: any = {};</code></pre>\n<p>隐式 any 是 TypeScript 编译器推断的。</p>\n<ul>\n <li>noImplicitThis（推荐打开）</li>\n</ul>\n<p>默认：true</p>\n<p>首次发布版本：2.0</p>\n<p>和隐式 any 类型， 只不过这次是针对的特殊的一个关键字 this，也就是你需要显式地指定 this 的类型。</p>\n<ul>\n <li>strict（推荐打开）</li>\n</ul>\n<p>默认：true</p>\n<p>首次发布版本：2.3</p>\n<p>实际上 strict 只是一个简写，是多个规则的合集。 类似于 babel 中插件（plugins）和 预设（presets）的差别。换句话说如果你指定了 strict 为 true ，那么所有严格相关的规则的都会开启，我所讲的<strong>严格检查</strong>都是，还有一部分我没有提到的。另外将来如果增加更多严格规则，你只要开启了 strict 则会自动加进来。</p>\n<h3>模块解析</h3>\n<h4>模块相关</h4>\n<p>目的：<strong>allowSyntheticDefaultImports，allowUmdGlobalAccess，esModuleInterop，moduleResolution 都是为了和其他模块化规范兼容做的。</strong></p>\n<ul>\n <li>allowSyntheticDefaultImports</li>\n <li>allowUmdGlobalAccess</li>\n <li>esModuleInterop</li>\n <li>moduleResolution</li>\n</ul>\n<p>还有一个配置 <strong>module</strong>，规定了项目的模块化方式，选项有 AMD，UMD，commonjs 等。</p>\n<h4>路径相关</h4>\n<p>目的： <strong>baseUrl，paths，rootDirs， typeRoots，types 都是为了简化路径的拼写做的。</strong></p>\n<ul>\n <li>baseUrl</li>\n</ul>\n<p>这个配置是告诉 TypeScript 如何解析模块路径的。比如：</p>\n<pre><code class=\"ts\">import { helloWorld } from \"hello/world\";\n\nconsole.log(helloWorld);</code></pre>\n<p>这个就会从 baseUrl 下找 hello 目录下的 world 文件。</p>\n<ul>\n <li>paths</li>\n</ul>\n<p>定义类似别名的存在，从而简化路径的书写。</p>\n<ul>\n <li>rootDirs</li>\n</ul>\n<p>注意是 rootDirs ，而不是 rootDir，也就是说根目录可以有多个。 当你指定了多个根目录的时候， 不同根目录的文件可以像在一个目录下一样互相访问。</p>\n<blockquote>\n 实际上也有一个叫 rootDir 的， 和 rootDirs 的区别就是其只能指定一个。\n</blockquote>\n<ul>\n <li>typeRoots</li>\n <li>types</li>\n</ul>\n<p>types 和 typeRoots 我在 - <a href=\"https://lucifer.ren/blog/2020/08/21/ts-type/\" rel=\"nofollow noreferrer\">types 和 @types 是什么？</a> 已经讲得很清楚了，这里就不多说了。</p>\n<h3>项目配置</h3>\n<h4>JavaScript 相关</h4>\n<ul>\n <li>allowJs</li>\n</ul>\n<p>默认：false</p>\n<p>首次发布版本：1.8</p>\n<p>顾名思义，允许在 TypeScript 项目中使用 JavaScript，这在从 JavaScript 迁移到 TypeScript 中是非常重要的。</p>\n<ul>\n <li>checkJs</li>\n</ul>\n<p>默认：false</p>\n<p>首次发布版本：-</p>\n<p>和 allowJs 类似， 只不过 checkJs 会额外对 JS 文件进行校验。</p>\n<h4>声明文件相关</h4>\n<p>如果 TypeScript 是将 TS 文件编译为 JS，那么声明文件 + JS 文件就可以反推出 TS 文件。</p>\n<p>这两个用来生成 .d.ts 和 .d.ts 的 sourcemap 文件。</p>\n<ul>\n <li>declaration</li>\n</ul>\n<p>默认：false</p>\n<p>首次发布版本：1.0</p>\n<ul>\n <li>declarationMap</li>\n</ul>\n<p>默认：false</p>\n<p>首次发布版本：2.9</p>\n<h4>外部库相关</h4>\n<ul>\n <li>jsx</li>\n</ul>\n<p>默认：react</p>\n<p>首次发布版本：2.2</p>\n<p>这个是告诉 TypeScript 如何编译 jsx 语法的。</p>\n<ul>\n <li>lib</li>\n</ul>\n<p>默认：-</p>\n<p>首次发布版本：2.0</p>\n<p>lib 我在 <a href=\"https://lucifer.ren/blog/2020/08/15/ts-type-system/\" rel=\"nofollow noreferrer\">TypeScript 类型系统</a> 中讲过。 Typescript 提供了诸如 lib.d.ts 等类型库文件。随着 ES 的不断更新， JavaScript 类型和全局变量会逐渐变多。Typescript 也是采用这种 lib 的方式来解决的。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023647616\" alt=\"\" title=\"\" /></p>\n<p>（TypeScript 提供的部分 lib）</p>\n<h4>输出相关</h4>\n<p>outDir 和 outFile 这两个配置则是告诉 TypeScript 将文件生成到哪里。</p>\n<ul>\n <li>outDir</li>\n</ul>\n<p>默认：和 ts 文件同目录（且同名，只是后缀不同）</p>\n<p>首次发布版本：-</p>\n<ul>\n <li>outFile</li>\n</ul>\n<p>默认：-</p>\n<p>首次发布版本：1.0</p>\n<p>module 是 CommonJS 和 ES6 module 不能知道 outFile，只有是 None, System 或 AMD 才行，其会将这些模块的文件内容打包到全局文件内容之后。</p>\n<p>而 noEmit 则是控制是否输出 JS 文件的。</p>\n<ul>\n <li>noEmit</li>\n</ul>\n<p>默认：false</p>\n<p>首次发布版本：-</p>\n<p>如果你只希望用 TypeScript 进行类型检查，不希望要它生成文件，则可以将 noEmit 设置成 true。</p>\n<ul>\n <li>target</li>\n</ul>\n<p>即输出的 JavaScript 对标的 ECMA 规范。 比如 “target”: “es6” 就是将 es6 + 的语法转换为 ES6 的 代码。其选项有 ES3，ES5，ES6 等。</p>\n<blockquote>\n 为什么没有 ES4 ？ ^_^\n</blockquote>\n<h2>总结</h2>\n<ul>\n <li>tsconfig 就是一个 JSON 文件，TypeScript 会使用该文件来决定如何编译和检查 TypeScript 项目。和 babel 类似，甚至很多配置项都是相通的。</li>\n <li>如果一个目录下存在一个 tsconfig.json 文件，那么意味着这个目录是 TypeScript 项目的根目录。 如果你使用 tsc 编译你的项目，并且没有显式地指定配置文件的路径，那么 tsc 则会逐级向上搜索父目录寻找 tsconfig.json ，这个过程类似 node 的模块查找机制。</li>\n <li>tsconfig 中最重要的恐怕就是编译器选项（compilerOptions）了。如果你按照功能去记忆则会比较简单， 比如文件相关的有哪些， 严格检查的有哪些，声明文件的有哪些等等。</li>\n</ul>\n<h2>参考</h2>\n<ul>\n <li><a href=\"https://www.typescriptlang.org/tsconfig#jsx\" rel=\"nofollow noreferrer\">typescriptlang's tsconfig</a></li>\n</ul>\n<h2>关注我</h2>\n<p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的前端硬核文章，带你认识你不知道的前端。</p>\n<p>知乎专栏【 <a href=\"https://www.zhihu.com/people/lu-xiao-13-70\" rel=\"nofollow noreferrer\">Lucifer - 知乎</a>】</p>\n<p>点关注，不迷路！</p>","descriptionType":"html","publishedDate":"Tue, 25 Aug 2020 02:51:38 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023750246","linkMd5":"1902a7fbe09693a1db292b7c5048a859","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn49@2020_5/2020/08/25/09-55-45-352_66dc7f716fd2fb24.webp","destWidth":800,"destHeight":285,"sourceBytes":29808,"destBytes":17318,"author":"lucifer","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023750246":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn49@2020_5/2020/08/25/09-55-45-352_66dc7f716fd2fb24.webp","https://segmentfault.com/img/remote/1460000023489697":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn90@2020_6/2020/08/25/09-55-52-190_8d0354c52eee968a.webp","https://segmentfault.com/img/remote/1460000023647616":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn96@2020_1/2020/08/25/09-55-49-545_dae97fa38554c9f9.webp"},"publishedOrCreatedDate":1598349324348},{"createdTime":"2020-08-25 17:55:24","updatedTime":"2020-08-25 17:55:24","title":"强烈推介的几个微信小程序开发小技巧，简单又实用","link":"https://segmentfault.com/a/1190000023748392","description":"<p><img src=\"https://segmentfault.com/img/remote/1460000023748396\" alt=\"Eu_62tl0bcU\" title=\"Eu_62tl0bcU\" /></p>\n<p>前段时间在下开发了个微信小程序，开发过程中总结了一些我觉得对我有用的小技巧，提炼出来，相当于一个总结复盘，也希望可以帮助到大家。如果对大家确实有帮助，别忘了点赞哦 🌟 ～</p>\n<ol>\n <li>微信开发者工具版本：<code>1.03.2006090</code>（2020-06-19）</li>\n <li>基础库版本： <code>v2.12.1</code> (2020-08-04)</li>\n</ol>\n<h2>1. 开发中可能遇到的坑以及 Tips</h2>\n<p>本来想写个小技巧的，结果我总结了一堆坑，没上手之前完全想象不到微信小程序的开发体验是如此之差、如此之烂，从微信开发者工具到所谓的「全新语言」，都有一种浓浓的半成品的 five 即视感，实在让我 emmm.... 另外我发现网上的小程序文章大部分都是如何使用和如何避坑的实用文，而不是技巧文，这也从侧面反映了小程序的坑多。</p>\n<p>在微信小程序原生开发过程中，我不断发出这样的疑问「为什么堂堂技术人才多如牛毛的腾讯，会推出如此 laji」，很多弱智反人类的地方，在两三年前社区就已经提出来，官方回复已经反馈正在修复中，但几年过去了，还是没有音信，官方回复仍然是一句冷冰冰的「已反馈」 😤</p>\n<ol>\n <li>微信开发者工具经常热更新不起作用甚至白屏，重新编译也不行，只能强行退出后再次打开；</li>\n <li>跟上一条类似，有时候一点样式出错，预览整个都白屏，调试器里也不说哪里的问题，直接就给你弃疗不显示，重新编译也无法解决问题，只能强行退出后再次打开；</li>\n <li>跟上一条类似，调试器里报的错经常没什么用，驴头不对马嘴，让人很难定位问题；</li>\n <li>Android 端自定义 Tabbar 在下拉刷新的时候，也会跟着屏幕一起往下移，而且是无法绕过的 Bug，自定义 Tabbar 样式都写好了的我又改成自带的 Tabbar 了！</li>\n <li><code>import</code> 的路径不支持绝对路径，比如你希望引用 <code>utils/fetch.js</code>，在不管多深的组件里面你都要慢慢 <code>../</code> 点到根目录，同样 <code>.wxss</code> 文件 <code>@import</code> 导入文件时也只能使用相对路径，所以就会出现 <code>../../../../../../utils/fetch.js</code> 这种东西；</li>\n <li>静态资源路径不能有汉字，有汉字就无法加载；</li>\n <li><code>.wxs</code> 文件不支持 ES6，只能使用蹩脚的 ES5 写法；</li>\n <li><code>.wxml</code> 中只能引入 <code>.wxs</code> 文件不能引入 <code>.js</code> 文件？？？</li>\n <li>模板 <code>{{}}</code> 中连方法都不能执行，只能处理简单的运算如 <code>+ - * /</code>，如果遇到数据需要 <code>filter</code> 的场景，需要在 <code>.js</code> 文件中预先格式化好再一个个 <code>setData</code>，比如经常写的 <code>[2,3,4].includes(type)</code>，居然都跑不起来！</li>\n <li><code>.wxs</code> 文件中无法使用 <code>Date</code> 对象，所以不能 <code>new Date()</code>，只能使用蹩脚的 <code>getDate</code> 方法，正则也是一样，生成正则对象需要使用 <code>getRegExp</code> 函数 <code>getRegExp(pattern[, flags])</code>；</li>\n <li><code>.wxs</code> 中可以调用其它 <code>.wxs</code> 文件，并且只能 require 调用 <code>.wxs</code> 文件，引入的文件必须使用相对路径；</li>\n <li><code>setData</code> 连一个对象合并都懒得做，如果 <code>data: {a: {b: 1, c: 1}}</code>，那么 <code>setData({a: {b: 2}})</code> 就会丢失 <code>a.c</code> 的值，真是让人火冒三丈啊，还要 <code>setData({['a.b': 2]})</code> 这样才行；</li>\n <li>IOS 上 <code>Date</code> 对象获取任意时间参数比如 <code>getDay</code>、<code>getTime</code> 都为 NaN，是因为 IOS 的 Date 构造函数不支持 <code>2018-04-26</code> 这种格式的日期，必须转换为 <code>2018/04/26</code> 这种格式才会显示正常；</li>\n <li>开发版小程序有时候请求莫名其妙发不出去，右上角三个点 enable debug 打开「开发调试」之后就莫名其妙能发出去请求了，在多部手机上都是这样，不明真相。</li>\n</ol>\n<h2>2. 微信请求 Promise 化</h2>\n<h3>2.1 使用现成的库</h3>\n<p>安装 Promise 库 <a href=\"https://github.com/youngjuning/wx-promise-pro\" rel=\"nofollow noreferrer\">wx-promise-pro</a>，记得一定要带 <code>-s</code> 或 <code>--production</code>，要不然无法构建成功。</p>\n<pre><code class=\"bash\">npm i -S wx-promise-pro</code></pre>\n<p>然后在 <code>app.js</code> 中：</p>\n<pre><code class=\"javascript\">import { promisifyAll } from 'wx-promise-pro'\n\npromisifyAll()  // promisify all wx api\n\nApp({ ... })</code></pre>\n<p>之后就可以正常使用了：</p>\n<pre><code class=\"javascript\">wx.pro.showLoading({\n    title: '加载中',\n    mask: true\n})\n  .then(() =&gt; console.log('in promise ~'))</code></pre>\n<h3>2.2 自己实现</h3>\n<p>其实我们可以自己来实现一个这样的库，原理很简单，以原生 API 的 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html\" rel=\"nofollow noreferrer\">wx.request</a> 为例：</p>\n<pre><code class=\"javascript\">// 原生 API 使用方式\nwx.request({\n    url: '',     // 请求的 url\n    data: {},    // 参数\n    method: '',  // post、get\n    success: res =&gt; {\n        // 请求成功回调函数，res为回调参数\n    },\n    fail: res =&gt; {\n        // 请求失败回调函数，res为回调参数\n    }\n})</code></pre>\n<p>如果我们将其 Promise 化，应该的调用方式希望是：</p>\n<pre><code class=\"javascript\">// Promise 化后的期望使用方式\nwx.pro.request({\n    url: '',     // 请求的 url\n    data: {},    // 参数\n    method: ''   // post、get\n})\n  .then(res =&gt; {\n      // 请求成功回调函数，res为回调参数\n  })\n  .catch(res =&gt; {\n      // 请求失败回调函数，res为回调参数\n  })</code></pre>\n<p>并且 <code>then</code> 函数返回的是一个 Promise 对象，让这个函数可以不断链式调用下去，所以首先需要 <code>new</code> 出来一个 Promise 对象：</p>\n<pre><code class=\"javascript\">function request(opt) {\n    return new Promise((resolve, reject) =&gt; {\n        wx.request({\n            ...opt,\n            success: res =&gt; { resolve(res)},\n            fail: res =&gt; {reject(res)}\n        })\n    })\n}</code></pre>\n<p>这里代码我们可以进一步改进，由于 <code>success</code>、<code>fail</code> 这里传入的参数只是由 <code>resolve</code>、<code>reject</code> 方法执行了下，所以可以直接传入 <code>resolve</code>、<code>reject</code> 方法即可。</p>\n<p>另外，由于其他小程序原生 API 格式一致，所以我们可以使用<a href=\"https://segmentfault.com/a/1190000012769779\">柯里化方法</a>，来将其他需要进行 Promise 化的 API 进行处理：</p>\n<pre><code class=\"javascript\">function promisify(api) {\n    return (opt = {}) =&gt; {\n        return new Promise((resolve, reject) =&gt; {\n            api({\n                ...opt,\n                fail: reject,\n                success: resolve\n            })\n        })\n    }\n}</code></pre>\n<p>然后，将柯里化方法执行的结果作为新的 Promise 化的 API 挂载到 <code>wx.pro</code> 对象上：</p>\n<pre><code class=\"javascript\">// 将指定 API 进行 Promise 化\nwx.pro.request = promisify(wx.request)\n\n// 使用\nwx.pro.request({...})\n    .then(...)</code></pre>\n<p>然后为了方便我们使用其他方法，可以循环将 <code>wx</code> 对象上可以被 Promise 化的方法比如 <code>request</code>、<code>scanCode</code>、<code>showToast</code>、<code>getUserInfo</code> 等一一挂载到 <code>wx.pro</code> 对象上，使用时可以直接 <code>wx.pro.xx</code>，由于这个方法执行返回的是一个 Promise 对象，因此可以像其它 Promise 化的对象那样使用。</p>\n<p>事实上，不知不觉，我们就自己实现了 <code>wx-promise-pro</code> 的源码，这个库的核心代码也就是上面那这几行 🥳</p>\n<h3>2.3 在项目中使用</h3>\n<p>有了上面的工具后，我们可以将其使用在项目中，为了不在项目中遍布 <code>wx.request</code> 或 <code>wx.pro.request</code> 这里可以简单进行封装，新建两个文件如下：</p>\n<pre><code class=\"javascript\">// utils/api/fetch.js 封装请求方法、请求拦截器\n\nconst app = getApp()\n\nconst BaseUrl = 'http://172.0.0.1:7300/mock'\n\nconst TokenWhiteList = [\n    '/app/user/get-by-code'     // 不需要鉴权的api手动添加到这里\n]\n\n/**\n * 设置请求拦截器\n * @param params 请求参数\n */\nconst fetch = (params = {}) =&gt; {\n    // 拦截器逻辑\n    if (!TokenWhiteList.includes(params.url)) {\n        params.header = {\n            'content-type': 'application/json',             // 默认值\n            'token': app.globalData.token || ''\n        }\n    }\n\n    if (params.url.startsWith('/')) {    // 拼接完整URL\n        params.url = BaseUrl + params.url\n    }\n\n    // 返回promise\n    return wx.pro.request({ ...params })\n      .then(({ data: { code, message, data } }) =&gt; {\n          // ... 各种异常情况的逻辑处理\n          // 与后端约定 code 20000 时正常返回\n          if (code === 20000) return Promise.resolve(data)\n          return Promise.reject(message)\n      })\n}\n\nexport { fetch }</code></pre>\n<p>然后再将所有 API 封装到单独的文件中集中管理：</p>\n<pre><code class=\"javascript\">// utils/api/apis.js 封装所有请求 API\n\nimport { fetch } from './fetch'\n\n/* 根据微信code获取用户信息 */\nconst appUserGetByCode = ({ code } = {}) =&gt; fetch({\n    url: '/app/user/get-by-code',\n    data: { code }\n})\n\n/* 扫码登录 */\nconst appUserQrLogin = ({ qrCode } = {}) =&gt; fetch({\n    method: 'POST',\n    url: '/app/user/qr-login',\n    data: { qrCode }\n})\n\n/* 个人信息 */\nconst appUserInfo = () =&gt; fetch({\n    url: '/app/user/info'\n})\n\n/* 系统参数获取，数据字典 */\nconst appSysParamListByParam = () =&gt; fetch({\n    url: '/app/sys-param/list-by-param'\n})\n\n/* 数据字典所有 */\nconst appSysParamListAll = () =&gt; fetch({\n    url: '/app/sys-param/list-all'\n})\n\nexport {\n    appSysParamListAll,   // 数据字典所有\n    appSysParamListByParam,   // 系统参数获取，数据字典\n    appUserGetByCode,   // 根据微信code获取用户信息\n    appUserQrLogin,   // 扫码登录\n    appUserInfo   // 个人信息\n}</code></pre>\n<p>在要使用 API 的地方就可以这样引入：</p>\n<pre><code class=\"javascript\">import * as Api from '../../utils/api/apis.js'   // 相对路径\n\n// 使用方式\nApi.appSysParamListAll()\n  .then(({ dataList }) =&gt; this.upData({ sysParamList: dataList }))\n  .then(() =&gt; {\n      const keyList = this.data.sysParamList.map(T =&gt; T.key)\n      this.upData({\n          keyList,\n          formData: { keys: keyList }\n      })\n  })</code></pre>\n<p>使用方式就很舒服，这里使用到了 upData，就是下面我要介绍的内容，是在下非常推介的小程序工具～ 🥳</p>\n<h2>3. setState 修改 data 中想修改对象的属性</h2>\n<p>在小程序中，<code>data</code> 是不能直接操作的，需要使用 <code>setData</code> 函数。鉴于微信小程序开发时 <code>setData</code> 的使用体验十分蹩脚，我使用了个库函数 <code>wx-updata</code>，这个库函数在开发的时候对我很有帮助，这里特意推介给大家。</p>\n<h3>3.1 为什么要使用 wx-updata</h3>\n<p>你在使用 <code>setData</code> 的时候，是不是有时候觉得很难受，举个简单的例子：</p>\n<pre><code class=\"javascript\">// 你的 data\ndata: {\n    name: '蜡笔小新',\n    info: { height: 140, color: '黄色' }\n}</code></pre>\n<p>如果要修改 <code>info.height</code> 为 155，使用 <code>setData</code> 要怎么做呢：</p>\n<pre><code class=\"javascript\">// 这样会把 info 里其他属性整不见了\nthis.setData({ info: { height: 155 } })\n\n// 你需要取出 info 对象，修改后整个 setData\nconst { info } = this.data\ninfo.height = 155\nthis.setData({ info })</code></pre>\n<p>似乎并不太复杂，但如果 <code>data</code> 是个很大的对象，要把比较深且不同的对象、数组项挨个改变：</p>\n<pre><code class=\"javascript\">data: {\n    name: '蜡笔小新',\n    info: {\n        height: 140, color: '黄色',\n        desc: [{ age: 8 }, '最喜欢大象之歌', '靓仔', { dog: '小白', color: '白色' }]\n    }\n}</code></pre>\n<p>比如某个需求，需要把 <code>info.height</code> 改为 155，同时改变 <code>info.desc</code> 数组的第 0 项的 <code>age</code> 为 12，第 3 项的 <code>color</code> 为灰色呢？</p>\n<pre><code class=\"javascript\">// 先取出要改变的对象，改变数字后 setData 回去\nconst { info } = this.data\ninfo.height = 155\ninfo.desc[0].age = 12\ninfo.desc[3].color = '灰色'\nthis.setData({ info })\n\n// 或者像某些文章里介绍的，这样可读性差，也不太实用\nthis.setData({\n    'info.height': 155,\n    'info.desc[0].age': 12,\n    'info.desc[3].color': '灰色'\n})</code></pre>\n<p>上面这两种方法，是我们平常小程序里经常用的，和其他 Web 端的框架相比，就很蹩脚，一种浓浓的半成品感扑面而来，有没有这样一个方法：</p>\n<pre><code class=\"javascript\">this.upData({\n    info: {\n        height: 155,\n        desc: [{ age: 12 }, , , { color: '灰色' }]\n    }\n})</code></pre>\n<p>这个方法会帮我们深度改变嵌套对象里对应的属性值，跳过数组项里不想改变的，只设置我们提供了的属性值、数组项，岂不是省略了一大堆蹩脚的代码，而且可读性也极佳呢。</p>\n<p>这就是为什么我在上线的项目中使用 <a href=\"https://github.com/SHERlocked93/wx-updata\" rel=\"nofollow noreferrer\">wx-updata</a>，而不是 <code>setData</code></p>\n<p>wx-updata 的原理其实很简单，举个例子：</p>\n<pre><code class=\"javascript\">this.upData({\n    info: {\n        height: 155,\n        desc: [{ age: 12 }]\n    }\n})\n\n// 会被自动转化为下面这种格式，\n// this.setData({\n//    'info.height': 155,\n//    'info.desc[0].age': 12,\n// })</code></pre>\n<p>原来这个转化工作是要我们自己手动来做，现在 wx-updata 帮我们做了，岂不美哉！</p>\n<h3>3.2 wx-updata 使用方式</h3>\n<p>在一般情况下，我们可以将方法直接挂载到 <code>Page</code> 构造函数上，这样就可以在 <code>Page</code> 实例中像使用 <code>setData</code> 一样使用 <code>upData</code> 了：</p>\n<pre><code class=\"javascript\">// app.js 中挂载\nimport { updataInit } from './miniprogram_npm/wx-updata/index'  // 你的库文件路径\n\nApp({\n    onLaunch() {\n        Page = updataInit(Page, { debug: true })\n    }\n})\n\n// 页面代码中使用方式\nthis.upData({\n    info: { height: 155 },\n    desc: [{ age: 13 }, '帅哥'],\n    family: [, , [, , , { color: '灰色' }]]\n})</code></pre>\n<p>有的框架可能在 <code>Page</code> 对象上进行了进一步修改，直接替换 <code>Page</code> 的方式可能就不太好了，<code>wx-updata</code> 同样暴露了工具方法，用户可以在页面代码中直接使用工具方法进行处理：</p>\n<pre><code class=\"javascript\">// 页面代码中\nimport { objToPath } from './miniprogram_npm/wx-updata/index'  // 你的库文件路径\n\nPage({\n    data: { a: { b: 2}, c: [3,4,5]},\n\n    // 自己封装一下\n    upData(data) {\n        return this.setData(objToPath(data))\n    },\n\n    // 你的方法中或生命周期函数\n    yourMethod() {\n        this.upData({ a: { b: 7}, c: [8,,9]})\n    }\n})</code></pre>\n<p>针对修改数组指定项的时候，可能存在的跳过数组空位的情况，wx-updata 提供了 Empty 的 Symbol 类型替位符，还有数组的对象路径方式，感兴趣可以看看 wx-updata 的<a href=\"https://github.com/SHERlocked93/wx-updata\" rel=\"nofollow noreferrer\">文档</a>，也可以参考 <a href=\"https://juejin.im/post/6854573214992072717\" rel=\"nofollow noreferrer\">&lt;开发微信小程序，我为什么放弃 setData，使用 upData&gt;</a> 这篇介绍文章。</p>\n<p>另外，使用了 wx-updata 也还可以使用原来的 setData，特别是有时候要清空数组时，灵活使用，可以获得更好的小程序开发体验，祝大家小程序开发愉快 🤣</p>\n<h2>4. 使用 scss 写样式</h2>\n<h3>4.1 Webstorm 配置方法</h3>\n<p>关于蹩脚的 <code>.wxss</code> 样式，我使用 webstorm 的 file watcher 工具把 scss 文件监听改动并实时编译成 <code>.wxss</code> 文件，感觉比较好用，这里给大家分享一下我的配置：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023748395\" alt=\"\" title=\"\" /></p>\n<p>然后记得在 <code>.gitignore</code> 文件中加入要忽略的样式：</p>\n<pre><code class=\"bash\">*.scss\n*.wxss.map</code></pre>\n<p>这样在上传到 git 的时候，就不会上传 scss 文件了～ 当然如果你的团队成员需要 scss 的话，还是建议 git 上传的时候也加上 scss 文件。</p>\n<p>这样设置之后，一个组件在本地的会是下面这样</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023748397\" alt=\"本地文件\" title=\"本地文件\" /></p>\n<p>其中我们需要关注的就是 <code>.js</code>、<code>.json</code>、<code>.scss</code>、<code>.wxml</code> 文件，另外的文件 <code>.wxss</code> 会在你改动 <code>.scss</code> 文件之后自动生成并更新，而 <code>.wxss.map</code> 是插件自动生成的映射关系，不用管。</p>\n<p>如果不是使用 webstorm，可以直接执行命令 <code>sass --watch index.scss:index.wxss -s expanded</code>，命令行如果关闭，sass 命令就不会监听文件的变动然后编译，所以最好用编辑器的插件。</p>\n<p>同理，也可以使用 less、stylus 等预编译语言。</p>\n<h3>4.2 Visual Studio Code 配置方法</h3>\n<p>万能的 VSC 当然也可以做到这个功能，搜索并下载插件 <code>easy sass</code>，然后在 <code>setting.json</code> 中修改/增加配置：</p>\n<pre><code class=\"json\">\"easysass.formats\": [\n  {\n    \"format\": \"expanded\",\n    \"extension\": \".wxss\"\n  },\n  {\n    \"format\": \"compressed\",\n    \"extension\": \".min.wxss\"\n  }\n]</code></pre>\n<p>上面 <code>expanded</code> 是编译生成的 <code>.wxss</code> 文件，下面 <code>compressed</code> 是压缩之后的 <code>.wxss</code> 样式文件，下面这个用不到可以把下面这个配置去掉，然后在 <code>.gitignore</code> 文件中加入要忽略的中间样式：</p>\n<pre><code class=\"bash\">*.scss</code></pre>\n<p>当然也可以不添加，如果你的同事也是实用 scss 来开发小程序的话，其他跟上面一样，至此你就可以在小程序开发中快乐使用 scss 了～</p>\n<h2>5. 使用 iconfont 图标字体</h2>\n<p>在 Web 开发中 <a href=\"https://www.iconfont.cn/\" rel=\"nofollow noreferrer\">iconfont</a> 可谓是最常用的灵活图标字体工具了，这里介绍一下如何在微信小程序中引入 iconfont 图标。</p>\n<p>首先找到你想使用的图标们，点击购物车之后下载到本地。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023748398\" alt=\"下载icon\" title=\"下载icon\" /></p>\n<p>下载到本地是一个压缩包，解压缩之后将 <code>iconfont.css</code> 文件复制到微信小程序的 <code>styles</code> 文件夹中 （在下的习惯，也可以放到你想放的地方比如 <code>fonts</code>），将后缀改为 <code>.wxss</code></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023748399\" alt=\"放到本地\" title=\"放到本地\" /></p>\n<p>在 <code>app.wxss</code> 中引入样式：</p>\n<pre><code class=\"css\">@import \"styles/iconfont.wxss\";</code></pre>\n<p>然后在 <code>.wxml</code> 中就可以使用刚刚你添加的图标了，Web 使用 <code>i</code> 标签，小程序中使用 <code>text</code> 标签：</p>\n<pre><code class=\"html\">&lt;text class=\"iconfont icon-my-edit\" style=\"color: blue\"&gt;&lt;/text&gt;</code></pre>\n<p>如果后面要加新的图标，要下载新的 <code>iconfont.css</code> 的文件到本地重命名并覆盖，重新走一遍这个流程。</p>\n<p>当然，如果你使用的样式库提供的一些 icon 能满足你的要求，那更好，就不用引入外部图标字体文件了，不过大部分情况下是不满足的 🤣</p>\n<hr>\n <p>网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出，如果本文帮助到了你，别忘了点赞支持一下哦（收藏不点赞，都是耍流氓 🤣）~</p>\n <blockquote>\n  <p>参考文档：</p>\n  <ol>\n   <li><a href=\"https://github.com/youngjuning/wx-promise-pro\" rel=\"nofollow noreferrer\">youngjuning/wx-promise-pro: ✨强大、优雅的微信小程序异步库🚀</a></li>\n   <li><a href=\"https://www.cnblogs.com/DesignerFly/p/8949684.html\" rel=\"nofollow noreferrer\">小程序开发坑之-IOS时间显示为NaN - 漠小飞</a></li>\n   <li><a href=\"https://juejin.im/post/5b496d5d5188251a90187635#heading-6\" rel=\"nofollow noreferrer\">【微信小程序】性能优化</a></li>\n   <li><a href=\"https://www.jianshu.com/p/74185d9c442b\" rel=\"nofollow noreferrer\">微信小程序使用Promise - 简书</a></li>\n   <li><a href=\"https://segmentfault.com/a/1190000023335827\">开发微信小程序，我为什么放弃 setData，使用 upData</a></li>\n  </ol>\n </blockquote>\n <p>PS：本人博客地址 <a href=\"https://github.com/SHERlocked93/blog\" rel=\"nofollow noreferrer\">Github - SHERlocked93/blog</a>，也欢迎大家关注我的公众号【前端下午茶】，一起加油吧~</p>\n <p><img src=\"https://segmentfault.com/img/remote/1460000021910280\" alt=\"\" title=\"\" /></p>\n <p>另外可以加入「前端下午茶交流群」微信群，长按识别下面二维码即可加我好友，备注<strong>加群</strong>，我拉你入群～</p>\n <p><img src=\"https://segmentfault.com/img/remote/1460000021910281\" alt=\"\" title=\"\" /></p>\n</hr>","descriptionType":"html","publishedDate":"Tue, 25 Aug 2020 01:30:08 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023748396","linkMd5":"435d54170d0a7cb5d4f52f6114dbed6e","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn51@2020_4/2020/08/25/09-55-42-314_091fba8bedcb5909.webp","destWidth":800,"destHeight":533,"sourceBytes":239351,"destBytes":82730,"author":"SHERlocked93","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023748396":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn51@2020_4/2020/08/25/09-55-42-314_091fba8bedcb5909.webp","https://segmentfault.com/img/remote/1460000023748395":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn88@2020_4/2020/08/25/09-55-49-036_3a59b4bca2328b76.webp","https://segmentfault.com/img/remote/1460000023748397":"https://cdn.jsdelivr.net/gh/myreaderx/cdn83@2020_3/2020/08/25/09-55-49-186_e5f29009f3d3a425.webp","https://segmentfault.com/img/remote/1460000023748398":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn73@2020_1/2020/08/25/09-55-49-948_7b8892ae2c3320a6.webp","https://segmentfault.com/img/remote/1460000023748399":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn79@2020_3/2020/08/25/09-55-49-721_f1d92c2995624f21.webp","https://segmentfault.com/img/remote/1460000021910280":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn66@2020_5/2020/08/25/09-55-48-883_43e5aab0cc8571f7.webp","https://segmentfault.com/img/remote/1460000021910281":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn71@2020_2/2020/08/25/09-55-50-123_2b12983c76c76a69.webp"},"publishedOrCreatedDate":1598349324349}],"record":{"createdTime":"2020-08-25 17:55:24","updatedTime":"2020-08-25 17:55:24","feedId":6615,"fetchDate":"Tue, 25 Aug 2020 09:55:24 +0000","fetchMs":4365,"handleMs":6140,"totalMs":40470,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"7b9c57143c89883f1c7411f24c95b098","hostName":"europe68*","requestId":"195ff846f48c42a8809925193ee787a0_6615","contentType":"application/atom+xml; charset=UTF-8","totalBytes":627824,"bgimgsTotal":4,"bgimgsGithubTotal":4,"articlesImgsTotal":28,"articlesImgsGithubTotal":28,"successGithubMap":{"myreaderx14":1,"myreaderx8":1,"myreaderx7":1,"myreaderx15":1,"myreaderx6":1,"myreaderx16":1,"myreaderx4":1,"myreaderx10":1,"myreaderx32":1,"myreaderx3":1,"myreaderx33":1,"myreaderx11":1,"myreaderx12":1,"myreaderx2":1,"myreaderx1":1,"myreaderx13":1,"myreaderx30":1,"myreaderx31":1,"myreaderx18":1,"myreaderx19":1,"myreaderx":1,"myreaderx25":1,"myreaderx21":1,"myreaderx22":1,"myreaderx23":1,"myreaderx24":1,"myreaderx5oss":1,"myreaderx29":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:33:08","updatedTime":"2020-08-25 07:11:24","id":6615,"name":"SegmentFault 最新的文章","url":"http://segmentfault.com/feeds/blogs","subscriber":null,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"https://segmentfault.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":146998,"tmpBodyImgCdnBytes":480826,"tmpBgImgCdnBytes":0,"extra4":{"start":1598349312772,"total":0,"statList":[{"spend":5437,"msg":"获取xml内容"},{"spend":6140,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":6942,"msg":"正文链接上传到cdn"}]},"extra5":28,"extra6":28,"extra7ImgCdnFailResultVector":[{"code":500,"msg":"Cannot run program \"/tmp/bin/cwebp\": error=13, Permission denied","isDone":false,"sourceBytes":0,"destBytes":0,"totalSpendMs":0,"convertSpendMs":0,"createdTime":"2020-08-25 17:55:42","sourceSize":"0","destSize":"0"}],"extra10_invalidATagHrefValue":{"https://segmentfault.com/a/1190000023588957_#fn-1":"https://segmentfault.com/a/1190000023588957#fn-1","https://segmentfault.com/a/1190000023588957_#fnref-1":"https://segmentfault.com/a/1190000023588957#fnref-1"},"extra111_proxyServerAndStatMap":{"http://us-032.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-24.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-039.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe65.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-007.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-58.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-028.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://europe66.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-011.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-25.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-54.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe62.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-036.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-004.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-57.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-008.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-016.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-040.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-027.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-012.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK7gY","sourceStatusCode":200,"destWidth":800,"destHeight":373,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn46@2020_1/2020/08/25/09-55-41-171_1c7c428307a34a7e.webp","sourceBytes":43995,"destBytes":12616,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3717,"convertSpendMs":23,"createdTime":"2020-08-25 17:55:38","host":"europe70*","referer":"https://segmentfault.com/a/1190000023588957","linkMd5ListStr":"17811c139a90fe837eb00a558d033704,17811c139a90fe837eb00a558d033704","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"43 KB","destSize":"12.3 KB","compressRate":"28.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLIlu","sourceStatusCode":200,"destWidth":800,"destHeight":450,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn58@2020_3/2020/08/25/09-55-41-592_a62e8ed1d2e9de09.webp","sourceBytes":91236,"destBytes":34334,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3863,"convertSpendMs":19,"createdTime":"2020-08-25 17:55:38","host":"us-023*","referer":"https://segmentfault.com/a/1190000023725914","linkMd5ListStr":"2e8010fe1e3267b74b961aaa740bda56,2e8010fe1e3267b74b961aaa740bda56","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"89.1 KB","destSize":"33.5 KB","compressRate":"37.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023748396","sourceStatusCode":200,"destWidth":800,"destHeight":533,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn51@2020_4/2020/08/25/09-55-42-314_091fba8bedcb5909.webp","sourceBytes":239351,"destBytes":82730,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4689,"convertSpendMs":38,"createdTime":"2020-08-25 17:55:38","host":"us-035*","referer":"https://segmentfault.com/a/1190000023748392","linkMd5ListStr":"435d54170d0a7cb5d4f52f6114dbed6e,435d54170d0a7cb5d4f52f6114dbed6e","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"233.7 KB","destSize":"80.8 KB","compressRate":"34.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023750246","sourceStatusCode":200,"destWidth":800,"destHeight":285,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn49@2020_5/2020/08/25/09-55-45-352_66dc7f716fd2fb24.webp","sourceBytes":29808,"destBytes":17318,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4129,"convertSpendMs":10,"createdTime":"2020-08-25 17:55:42","host":"europe63*","referer":"https://segmentfault.com/a/1190000023750243","linkMd5ListStr":"1902a7fbe09693a1db292b7c5048a859,1902a7fbe09693a1db292b7c5048a859","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"29.1 KB","destSize":"16.9 KB","compressRate":"58.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000021910280","sourceStatusCode":200,"destWidth":536,"destHeight":154,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn66@2020_5/2020/08/25/09-55-48-883_43e5aab0cc8571f7.webp","sourceBytes":14948,"destBytes":14948,"feedId":6615,"totalSpendMs":3652,"convertSpendMs":0,"createdTime":"2020-08-25 17:55:46","host":"europe-25*","referer":"https://segmentfault.com/a/1190000023748392","linkMd5ListStr":"435d54170d0a7cb5d4f52f6114dbed6e","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"14.6 KB","destSize":"14.6 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK7lh","sourceStatusCode":200,"destWidth":800,"destHeight":400,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn35@2020_1/2020/08/25/09-55-48-736_7b67620fa91c338f.webp","sourceBytes":61667,"destBytes":14558,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3671,"convertSpendMs":17,"createdTime":"2020-08-25 17:55:46","host":"europe62*","referer":"https://segmentfault.com/a/1190000023588957","linkMd5ListStr":"17811c139a90fe837eb00a558d033704,17811c139a90fe837eb00a558d033704","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"60.2 KB","destSize":"14.2 KB","compressRate":"23.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023748397","sourceStatusCode":200,"destWidth":267,"destHeight":178,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn83@2020_3/2020/08/25/09-55-49-186_e5f29009f3d3a425.webp","sourceBytes":9722,"destBytes":4370,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3535,"convertSpendMs":6,"createdTime":"2020-08-25 17:55:46","host":"us-016*","referer":"https://segmentfault.com/a/1190000023748392","linkMd5ListStr":"435d54170d0a7cb5d4f52f6114dbed6e","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"9.5 KB","destSize":"4.3 KB","compressRate":"44.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK7j4","sourceStatusCode":200,"destWidth":800,"destHeight":373,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn51@2020_5/2020/08/25/09-55-49-205_fcb873ab0ab5eedd.webp","sourceBytes":32120,"destBytes":9356,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3542,"convertSpendMs":18,"createdTime":"2020-08-25 17:55:46","host":"us-004*","referer":"https://segmentfault.com/a/1190000023588957","linkMd5ListStr":"17811c139a90fe837eb00a558d033704","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"31.4 KB","destSize":"9.1 KB","compressRate":"29.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK7iK","sourceStatusCode":200,"destWidth":800,"destHeight":533,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn47@2020_4/2020/08/25/09-55-49-271_990e0077e99f058e.webp","sourceBytes":48987,"destBytes":12512,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3620,"convertSpendMs":23,"createdTime":"2020-08-25 17:55:46","host":"us-016*","referer":"https://segmentfault.com/a/1190000023588957","linkMd5ListStr":"17811c139a90fe837eb00a558d033704","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"47.8 KB","destSize":"12.2 KB","compressRate":"25.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK7ni","sourceStatusCode":200,"destWidth":800,"destHeight":373,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn99@2020_5/2020/08/25/09-55-49-284_2b9874d37d2020b0.webp","sourceBytes":76298,"destBytes":19366,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3655,"convertSpendMs":27,"createdTime":"2020-08-25 17:55:46","host":"us-032*","referer":"https://segmentfault.com/a/1190000023588957","linkMd5ListStr":"17811c139a90fe837eb00a558d033704","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"74.5 KB","destSize":"18.9 KB","compressRate":"25.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023748395","sourceStatusCode":200,"destWidth":800,"destHeight":580,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn88@2020_4/2020/08/25/09-55-49-036_3a59b4bca2328b76.webp","sourceBytes":143171,"destBytes":49536,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4042,"convertSpendMs":48,"createdTime":"2020-08-25 17:55:46","host":"europe65*","referer":"https://segmentfault.com/a/1190000023748392","linkMd5ListStr":"435d54170d0a7cb5d4f52f6114dbed6e","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"139.8 KB","destSize":"48.4 KB","compressRate":"34.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK7kP","sourceStatusCode":200,"destWidth":800,"destHeight":400,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn32@2020_4/2020/08/25/09-55-49-358_7294fa6cc480165d.webp","sourceBytes":62097,"destBytes":14730,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4048,"convertSpendMs":21,"createdTime":"2020-08-25 17:55:46","host":"europe-25*","referer":"https://segmentfault.com/a/1190000023588957","linkMd5ListStr":"17811c139a90fe837eb00a558d033704","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"60.6 KB","destSize":"14.4 KB","compressRate":"23.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLQNA","sourceStatusCode":200,"destWidth":800,"destHeight":189,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn63@2020_4/2020/08/25/09-55-49-427_24a235104dfabe34.webp","sourceBytes":22093,"destBytes":9746,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4052,"convertSpendMs":9,"createdTime":"2020-08-25 17:55:46","host":"europe-24*","referer":"https://segmentfault.com/a/1190000023588957","linkMd5ListStr":"17811c139a90fe837eb00a558d033704","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"21.6 KB","destSize":"9.5 KB","compressRate":"44.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023647616","sourceStatusCode":200,"destWidth":276,"destHeight":789,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn96@2020_1/2020/08/25/09-55-49-545_dae97fa38554c9f9.webp","sourceBytes":47370,"destBytes":32878,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3940,"convertSpendMs":37,"createdTime":"2020-08-25 17:55:46","host":"us-54*","referer":"https://segmentfault.com/a/1190000023750243","linkMd5ListStr":"1902a7fbe09693a1db292b7c5048a859","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"46.3 KB","destSize":"32.1 KB","compressRate":"69.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLIl6","sourceStatusCode":200,"destWidth":800,"destHeight":450,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn23@2020_5/2020/08/25/09-55-49-712_b939c3ffbbcabd2e.webp","sourceBytes":32819,"destBytes":17112,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4120,"convertSpendMs":13,"createdTime":"2020-08-25 17:55:46","host":"us-011*","referer":"https://segmentfault.com/a/1190000023725914","linkMd5ListStr":"2e8010fe1e3267b74b961aaa740bda56","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"32 KB","destSize":"16.7 KB","compressRate":"52.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLIl7","sourceStatusCode":200,"destWidth":800,"destHeight":591,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn19@2020_2/2020/08/25/09-55-49-684_9589bb6404eec2c3.webp","sourceBytes":153615,"destBytes":74906,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4171,"convertSpendMs":28,"createdTime":"2020-08-25 17:55:46","host":"us-036*","referer":"https://segmentfault.com/a/1190000023725914","linkMd5ListStr":"2e8010fe1e3267b74b961aaa740bda56","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"150 KB","destSize":"73.2 KB","compressRate":"48.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLIlw","sourceStatusCode":200,"destWidth":800,"destHeight":254,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn39@2020_4/2020/08/25/09-55-49-797_1ab8edceafbdb3f2.webp","sourceBytes":47150,"destBytes":15344,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4199,"convertSpendMs":13,"createdTime":"2020-08-25 17:55:46","host":"us-027*","referer":"https://segmentfault.com/a/1190000023725914","linkMd5ListStr":"2e8010fe1e3267b74b961aaa740bda56","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"46 KB","destSize":"15 KB","compressRate":"32.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK7mp","sourceStatusCode":200,"destWidth":800,"destHeight":373,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn42@2020_1/2020/08/25/09-55-49-792_d2be868524e38f59.webp","sourceBytes":49193,"destBytes":14026,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4251,"convertSpendMs":17,"createdTime":"2020-08-25 17:55:46","host":"us-028*","referer":"https://segmentfault.com/a/1190000023588957","linkMd5ListStr":"17811c139a90fe837eb00a558d033704","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"48 KB","destSize":"13.7 KB","compressRate":"28.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLIl5","sourceStatusCode":200,"destWidth":310,"destHeight":163,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn25@2020_5/2020/08/25/09-55-49-947_6cddad447b6009cd.webp","sourceBytes":14569,"destBytes":6726,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4294,"convertSpendMs":11,"createdTime":"2020-08-25 17:55:46","host":"us-012*","referer":"https://segmentfault.com/a/1190000023725914","linkMd5ListStr":"2e8010fe1e3267b74b961aaa740bda56","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"14.2 KB","destSize":"6.6 KB","compressRate":"46.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023748398","sourceStatusCode":200,"destWidth":800,"destHeight":355,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn73@2020_1/2020/08/25/09-55-49-948_7b8892ae2c3320a6.webp","sourceBytes":81145,"destBytes":19262,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4381,"convertSpendMs":17,"createdTime":"2020-08-25 17:55:46","host":"us-040*","referer":"https://segmentfault.com/a/1190000023748392","linkMd5ListStr":"435d54170d0a7cb5d4f52f6114dbed6e","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"79.2 KB","destSize":"18.8 KB","compressRate":"23.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK7rA","sourceStatusCode":200,"destWidth":800,"destHeight":666,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn5@2020_2/2020/08/25/09-55-49-681_d2bee9c2a0429789.webp","sourceBytes":88495,"destBytes":21122,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4398,"convertSpendMs":41,"createdTime":"2020-08-25 17:55:46","host":"us-008*","referer":"https://segmentfault.com/a/1190000023588957","linkMd5ListStr":"17811c139a90fe837eb00a558d033704","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"86.4 KB","destSize":"20.6 KB","compressRate":"23.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023748399","sourceStatusCode":200,"destWidth":317,"destHeight":228,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn79@2020_3/2020/08/25/09-55-49-721_f1d92c2995624f21.webp","sourceBytes":16525,"destBytes":7164,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4441,"convertSpendMs":7,"createdTime":"2020-08-25 17:55:46","host":"us-028*","referer":"https://segmentfault.com/a/1190000023748392","linkMd5ListStr":"435d54170d0a7cb5d4f52f6114dbed6e","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"16.1 KB","destSize":"7 KB","compressRate":"43.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000021910281","sourceStatusCode":200,"destWidth":283,"destHeight":283,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn71@2020_2/2020/08/25/09-55-50-123_2b12983c76c76a69.webp","sourceBytes":24018,"destBytes":24018,"feedId":6615,"totalSpendMs":4487,"convertSpendMs":0,"createdTime":"2020-08-25 17:55:46","host":"us-039*","referer":"https://segmentfault.com/a/1190000023748392","linkMd5ListStr":"435d54170d0a7cb5d4f52f6114dbed6e","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23.5 KB","destSize":"23.5 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK7qD","sourceStatusCode":200,"destWidth":800,"destHeight":400,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn3@2020_4/2020/08/25/09-55-50-437_5c3014e94ba141ae.webp","sourceBytes":69929,"destBytes":16410,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4793,"convertSpendMs":17,"createdTime":"2020-08-25 17:55:46","host":"us-007*","referer":"https://segmentfault.com/a/1190000023588957","linkMd5ListStr":"17811c139a90fe837eb00a558d033704","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"68.3 KB","destSize":"16 KB","compressRate":"23.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK7qi","sourceStatusCode":200,"destWidth":800,"destHeight":533,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn11@2020_4/2020/08/25/09-55-50-499_a42831297c41182e.webp","sourceBytes":50356,"destBytes":13020,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":5143,"convertSpendMs":20,"createdTime":"2020-08-25 17:55:46","host":"europe-57*","referer":"https://segmentfault.com/a/1190000023588957","linkMd5ListStr":"17811c139a90fe837eb00a558d033704","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"49.2 KB","destSize":"12.7 KB","compressRate":"25.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK7rU","sourceStatusCode":200,"destWidth":800,"destHeight":373,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn14@2020_3/2020/08/25/09-55-51-276_269fb8820a4962f1.webp","sourceBytes":100286,"destBytes":24576,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":5899,"convertSpendMs":17,"createdTime":"2020-08-25 17:55:46","host":"europe-58*","referer":"https://segmentfault.com/a/1190000023588957","linkMd5ListStr":"17811c139a90fe837eb00a558d033704","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"97.9 KB","destSize":"24 KB","compressRate":"24.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK7if","sourceStatusCode":200,"destWidth":800,"destHeight":373,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn55@2020_2/2020/08/25/09-55-52-199_05d188a0e6eca8e1.webp","sourceBytes":79509,"destBytes":20662,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":6863,"convertSpendMs":19,"createdTime":"2020-08-25 17:55:46","host":"europe66*","referer":"https://segmentfault.com/a/1190000023588957","linkMd5ListStr":"17811c139a90fe837eb00a558d033704","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"77.6 KB","destSize":"20.2 KB","compressRate":"26%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023489697","sourceStatusCode":200,"destWidth":800,"destHeight":411,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn90@2020_6/2020/08/25/09-55-52-190_8d0354c52eee968a.webp","sourceBytes":41817,"destBytes":24478,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":6914,"convertSpendMs":12,"createdTime":"2020-08-25 17:55:46","host":"europe66*","referer":"https://segmentfault.com/a/1190000023750243","linkMd5ListStr":"1902a7fbe09693a1db292b7c5048a859","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"40.8 KB","destSize":"23.9 KB","compressRate":"58.5%"}],"successGithubMap":{"myreaderx14":1,"myreaderx8":1,"myreaderx7":1,"myreaderx15":1,"myreaderx6":1,"myreaderx16":1,"myreaderx4":1,"myreaderx10":1,"myreaderx32":1,"myreaderx3":1,"myreaderx33":1,"myreaderx11":1,"myreaderx12":1,"myreaderx2":1,"myreaderx1":1,"myreaderx13":1,"myreaderx30":1,"myreaderx31":1,"myreaderx18":1,"myreaderx19":1,"myreaderx":1,"myreaderx25":1,"myreaderx21":1,"myreaderx22":1,"myreaderx23":1,"myreaderx24":1,"myreaderx5oss":1,"myreaderx29":1},"failGithubMap":{}}