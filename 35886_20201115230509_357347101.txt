{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-11-16 07:04:43","updatedTime":"2020-11-16 07:04:43","title":"iOS开发同学的arm64汇编入门","link":"http://blog.cnbluebox.com/blog/2017/07/24/arm64-start","description":"<p>在定位某些crash问题的时候，有时候遇到一些问题很诡异。有时候挂在了系统库里面。这个时候定位crash问题往往是比较头疼的。那么这个时候学会一些汇编知识，利用汇编调试技巧进行调试可能会起到意想不到的效果。</p>\n\n<p>学习汇编语言不只是帮助定位crash而已，学习汇编可以帮助你真正的理解计算机。毕竟CPU上跑的就是对应的指令集。</p>\n\n<!-- more -->\n\n\n<h2>0x1 工具</h2>\n\n<p>我们面对的要么是源代码，要么是二进制。因此我们需要一些反汇编的工具来辅助我们进行汇编代码查看。推荐工具有：\n&#8211; <a href=\"https://www.hopperapp.com/\">Hopper Disassembler</a> 收费应用，看汇编代码非常方便\n&#8211; <a href=\"https://github.com/gdbinit/MachOView\">MachOView</a> 开源工具，看Mach-o文件结构非常方便。</p>\n\n<h2>0x2 基本概念</h2>\n\n<p>从高级语言过渡到汇编语言，重要的是基本概念的转换。汇编里面要学习的三个重要概念，我认为是 寄存器、栈、指令。\narm64架构又分为2种执行状态： <code>AArch64 Application Level</code> 和 <code>AArch32 Application Level</code>, 本文只讲AArch64.</p>\n\n<h3>0x21 寄存器</h3>\n\n<p>如果你还不知道什么是寄存器，建议先Google一下。 这里不再详细说明，寄存器是CPU中的高速存储单元，要比内存中存取要快的多。</p>\n\n<p>这里说明一下arm64有哪些寄存器：</p>\n\n<ul>\n<li><strong>R0 &#8211; R30</strong></li>\n</ul>\n\n\n<p><code>r0 - r30</code> 是31个通用整形寄存器。每个寄存器可以存取一个64位大小的数。 当使用 <code>x0 - x30</code>访问时，它就是一个64位的数。当使用 <code>w0 - w30</code>访问时，访问的是这些寄存器的低32位，如图：</p>\n\n<p><img src=\"http://blog.cnbluebox.com/images/arm64-start/1.png\" alt=\"1.png\" /></p>\n\n<p>其实通用寄存器有32个，第32个寄存器x31，在指令编码中，使用来做 <code>zero register</code>, 即<code>ZR</code>, <code>XZR/WZR</code>分别代表64/32位，<code>zero register</code>的作用就是0，写进去代表丢弃结果，拿出来是0.</p>\n\n<p>其中 <code>r29</code> 又被叫做 <code>fp</code> (frame pointer).  <code>r30</code> 又被叫做 <code>lr</code> (link register)。其用途会在下一节《栈》中讲到。</p>\n\n<ul>\n<li><strong>SP</strong></li>\n</ul>\n\n\n<p>SP寄存器其实就是 x31，在指令编码中，使用 <code>SP/WSP</code>来进行对SP寄存器的访问。</p>\n\n<ul>\n<li><strong>PC</strong></li>\n</ul>\n\n\n<p>PC寄存器中存的是当前执行的指令的地址。在arm64中，软件是不能改写PC寄存器的。</p>\n\n<ul>\n<li><strong>V0 &#8211; V31</strong></li>\n</ul>\n\n\n<p><code>V0 - V31</code> 是向量寄存器，也可以说是浮点型寄存器。它的特点是每个寄存器的大小是 128 位的。 分别可以用<code>Bn Hn Sn Dn Qn</code>的方式来访问不同的位数。如图：</p>\n\n<p><img src=\"http://blog.cnbluebox.com/images/arm64-start/2.png\" alt=\"2.png\" /></p>\n\n<p><code>Bn Hn Sn Dn Qn</code>可以这样理解记忆, 基于一个word是32位，也就是4Byte大小：</p>\n\n<blockquote><p>Bn:  一个Byte的大小 </br>\nHn:  half word. 就是16位 </br>\nSn:  single word. 32位 </br>\nDn:  double word. 64位 </br>\nQn:  quad word.  128位 </br></p></blockquote>\n\n<ul>\n<li><strong>SPRs</strong></li>\n</ul>\n\n\n<p>SPRs是状态寄存器，用于存放程序运行中一些状态标识。不同于编程语言里面的if else.在汇编中就需要根据状态寄存器中的一些状态来控制分支的执行。状态寄存器又分为 <code>The Current Program Status Register (CPSR)</code> 和 <code>The Saved Program Status Registers (SPSRs)</code>。 一般都是使用<code>CPSR</code>， 当发生异常时， <code>CPSR</code>会存入<code>SPSR</code>。当异常恢复，再拷贝回<code>CPSR</code>。</p>\n\n<p>还有一些系统寄存器，还有 <code>FPSR</code> <code>FPCR</code>是浮点型运算时的状态寄存器等。基本了解上面这些寄存器就可以了。</p>\n\n<h3>0x22 栈</h3>\n\n<p>栈就是指令执行时存放临时变量的内存空间。在学习汇编代码的执行过程中，了解栈的结构非常重要。</p>\n\n<p>先列出一些栈的特性：</p>\n\n<ul>\n<li>栈是从高地址到低地址的， 栈低是高地址，栈顶是低地址。</li>\n<li><code>fp</code>指向当前frame的栈底，也就是高地址。</li>\n<li><code>sp</code>指向栈顶，也就是地地址。</li>\n</ul>\n\n\n<p>下面的图简单的描述了从方法A调用方法B时 栈是如何划分的：</p>\n\n<p><img src=\"http://blog.cnbluebox.com/images/arm64-start/3.jpeg\" alt=\"3.jpeg\" /></p>\n\n<p>其中3行汇编代码就是方法B的前三行汇编指令。它们做的事情就是图中描述的事情 (x29就是fp, x30就是lr)：</p>\n\n<ul>\n<li>将<code>fp, lr</code>保存到 <code>sp - 0x10</code>的地方. 也就是图中 <code>--&#62; fp_B</code>的位置。然后将sp设置为 <code>sp-0x10</code></li>\n<li>将 <code>fp</code> 设置为当前 <code>sp</code>。也就是 <code>--&#62; fp_B</code>的位置。 这一步就设置了<code>_funcB</code>的 fp了</li>\n<li>将 <code>sp</code> 设置为 <code>sp - 0x30</code>。 也就是将<code>sp</code>指向了图中 <code>--&#62; sp_B</code> 的位置</li>\n</ul>\n\n\n<blockquote><p>注： <code>lr</code> 是<code>link register</code>中的值，它存的是方法<code>_funcA</code>的执行的最后一行指令的下一行。它的作用也很好理解：当<code>_funcB</code>执行完了之后要返回<code>_funcA</code>继续执行，但是计算机要如何知道返回到哪执行呢？ 就是靠<code>lr</code>记录了返回的地址，方法才能得以正常返回。</p></blockquote>\n\n<p>说道这里，那么当 <code>_funcB</code>执行完毕后，是如何把栈恢复到<code>_funcA</code>的过程的呢？ 我们直接分析 <code>_funcB</code>的最后3条指令：</p>\n\n<figure class='code'><figcaption><span></span></figcaption><div class=\"highlight\"><table><tr><td class=\"gutter\"><pre class=\"line-numbers\"><span class='line-number'>1</span>\n<span class='line-number'>2</span>\n<span class='line-number'>3</span>\n<span class='line-number'>4</span>\n<span class='line-number'>5</span>\n</pre></td><td class='code'><pre><code class='c'><span class='line'><span class=\"n\">mov</span>        <span class=\"n\">sp</span><span class=\"p\">,</span> <span class=\"n\">fp</span><span class=\"p\">;</span>              <span class=\"c1\">//  sp 设置为fp, 就是图中 --&#62;fp_B 的位置</span>\n</span><span class='line'><span class=\"n\">ldp</span>           <span class=\"n\">fp</span><span class=\"p\">,</span> <span class=\"n\">lr</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">sp</span><span class=\"p\">],</span> <span class=\"err\">#</span><span class=\"mh\">0x10</span><span class=\"p\">;</span> <span class=\"c1\">//  从sp指向的地址中读取 2个64位，分别存入fp,lr。 然后将sp += 0x10</span>\n</span><span class='line'><span class=\"c1\">// 这一步执行完之后，fp就执行了图中 --&#62;fp_A. lr恢复成 _funcA的返回地址。 sp指向了 --&#62;sp_A. </span>\n</span><span class='line'><span class=\"c1\">// 这个时候状态已经完全恢复到了 _funcA 的环境</span>\n</span><span class='line'><span class=\"n\">ret</span><span class=\"p\">;</span>    <span class=\"c1\">// 返回指令，这一步直接执行lr的指令。</span>\n</span></code></pre></td></tr></table></div></figure>\n\n\n<blockquote><p>上面描述了方法如何调用的。我们知道在编程语言里面方法都有入参，有返回值的。在汇编里面如何体现呢？</p></blockquote>\n\n<ul>\n<li>一般来说 arm64上 x0 &#8211; x7 分别会存放方法的前 8 个参数</li>\n<li>如果参数个数超过了8个，多余的参数会存在栈上，新方法会通过栈来读取。</li>\n<li>方法的返回值一般都在 x0 上。</li>\n<li>如果方法返回值是一个较大的数据结构时，结果会存在 x8 执行的地址上。</li>\n</ul>\n\n\n<h3>0x23 指令</h3>\n\n<p>在上一级的内容中我们已经看到了一些指令。 汇编指令除了数量较多，其基本原理都是比较简单的，单拎出来一条指令就是很simple的操作。 比如<code>mov</code>就是一个赋值。<code>ldr</code>就是一个取值。</p>\n\n<p>那汇编指令大概可以分为哪几种呢？我认为了解以下几种基本指令就可以正常阅读汇编代码了。</p>\n\n<h4>0x231 <strong>运算</strong></h4>\n\n<ul>\n<li>算术运算</li>\n</ul>\n\n\n<p>算术运算就是像 <code>ADD</code> <code>SUB</code> <code>MUL</code> &#8230; 等加减乘除运算，也是很好理解的指令 </br>\n如：</p>\n\n<figure class='code'><figcaption><span></span></figcaption><div class=\"highlight\"><table><tr><td class=\"gutter\"><pre class=\"line-numbers\"><span class='line-number'>1</span>\n<span class='line-number'>2</span>\n<span class='line-number'>3</span>\n<span class='line-number'>4</span>\n<span class='line-number'>5</span>\n</pre></td><td class='code'><pre><code class='c'><span class='line'><span class=\"n\">add</span> <span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">x1</span><span class=\"p\">,</span> <span class=\"n\">x2</span><span class=\"p\">;</span> <span class=\"c1\">// 把 x1 + x2 = x0 这样一个操作。</span>\n</span><span class='line'><span class=\"n\">sub</span> <span class=\"n\">sp</span><span class=\"p\">,</span> <span class=\"n\">sp</span><span class=\"p\">,</span> <span class=\"mh\">0x30</span><span class=\"p\">;</span> <span class=\"c1\">// 把 sp - 30 存入sp.</span>\n</span><span class='line'><span class=\"n\">cmp</span> <span class=\"n\">x11</span><span class=\"p\">,</span> <span class=\"err\">#</span><span class=\"mi\">4</span><span class=\"p\">;</span>  <span class=\"c1\">// 相当于 subs xzr, x11, #4.  </span>\n</span><span class='line'>              <span class=\"c1\">// 如果 x11 - 4 == 0, 那么状态寄存器NZCV.Z = 1</span>\n</span><span class='line'>              <span class=\"c1\">// 如果 x11 - 4 &#60; 0, 那么 NZCV.N = 1</span>\n</span></code></pre></td></tr></table></div></figure>\n\n\n<blockquote><p><code>NZCV</code>是状态寄存器中存的几个状态值，分别代表运算过程中产生的状态，其中： <br>\n  * N,  negative condition flag，一般代表运算结果是负数 <br>\n  * Z,  zero condition flag,  运算结果为0 <br>\n  * C,  carry condition flag, 无符号运算有溢出时，C=1。 <br>\n  * V,  oVerflow condition flag 有符号运算有溢出时，V=1。 <br></p></blockquote>\n\n<ul>\n<li>逻辑运算指令</li>\n</ul>\n\n\n<p>有 <code>LSL</code>(逻辑左移) <code>LSR</code>(逻辑右移) <code>ASR</code>(算术右移) <code>ROR</code>(循环右移)。 </br>\n有 <code>AND</code>(与)  <code>ORR</code>(或) <code>EOR</code>(异或)</p>\n\n<p>逻辑位移运算通常也可以与算术运算一起用，如：</br></p>\n\n<figure class='code'><figcaption><span></span></figcaption><div class=\"highlight\"><table><tr><td class=\"gutter\"><pre class=\"line-numbers\"><span class='line-number'>1</span>\n</pre></td><td class='code'><pre><code class='c'><span class='line'> <span class=\"n\">add</span>  <span class=\"n\">x14</span><span class=\"p\">,</span> <span class=\"n\">x4</span><span class=\"p\">,</span> <span class=\"n\">x27</span><span class=\"p\">,</span> <span class=\"n\">lsl</span> <span class=\"err\">#</span><span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"c1\">// 意思是把  (x27 &#60;&#60; 1) + x4 = x14;</span>\n</span></code></pre></td></tr></table></div></figure>\n\n\n<ul>\n<li>拓展位数运算</li>\n</ul>\n\n\n<p>有 <code>zero extend</code>(高位补0) 和 <code>sign extend</code>(高位填充和符号位一致，一般有符号数用这个)。 一般用来补齐位数。常和算术运算配合一起.</br>\n如：</p>\n\n<figure class='code'><figcaption><span></span></figcaption><div class=\"highlight\"><table><tr><td class=\"gutter\"><pre class=\"line-numbers\"><span class='line-number'>1</span>\n</pre></td><td class='code'><pre><code class='c'><span class='line'><span class=\"n\">add</span>        <span class=\"n\">w20</span><span class=\"p\">,</span> <span class=\"n\">w30</span><span class=\"p\">,</span> <span class=\"n\">w20</span><span class=\"p\">,</span> <span class=\"n\">uxth</span>  <span class=\"c1\">// 取 w20的低16位，无符号补齐到32位后再进行  w30 + w20的运算。</span>\n</span></code></pre></td></tr></table></div></figure>\n\n\n<ul>\n<li>Mov</li>\n</ul>\n\n\n<h4>0x232 寻址</h4>\n\n<p>既然是和内存相关的，那就是两种，一种存，一种取。一般来说 </br>\n<strong>L打头的基本都是取值指令，如 LDR LDP;</strong> </br>\n<strong>S打头的基本都是存值指令，如 STR STP;</strong> </br></p>\n\n<p>例：</p>\n\n<figure class='code'><figcaption><span></span></figcaption><div class=\"highlight\"><table><tr><td class=\"gutter\"><pre class=\"line-numbers\"><span class='line-number'>1</span>\n<span class='line-number'>2</span>\n<span class='line-number'>3</span>\n<span class='line-number'>4</span>\n<span class='line-number'>5</span>\n</pre></td><td class='code'><pre><code class='c'><span class='line'><span class=\"n\">ldr</span> <span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">x1</span><span class=\"p\">];</span> <span class=\"c1\">// 从`x1`指向的地址里面取出一个 64 位大小的数存入 `x0`</span>\n</span><span class='line'><span class=\"n\">ldp</span> <span class=\"n\">x1</span><span class=\"p\">,</span> <span class=\"n\">x2</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">x10</span><span class=\"p\">,</span> <span class=\"err\">#</span><span class=\"mh\">0x10</span><span class=\"p\">];</span> <span class=\"c1\">// 从 x10 + 0x10 指向的地址里面取出 2个 64位的数，分别存入x1, x2</span>\n</span><span class='line'><span class=\"n\">str</span> <span class=\"n\">x5</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">sp</span><span class=\"p\">,</span> <span class=\"err\">#</span><span class=\"mi\">24</span><span class=\"p\">];</span> <span class=\"c1\">// 把x5的值（64位数值）存到 sp+24 指向的内存地址上</span>\n</span><span class='line'><span class=\"n\">stp</span> <span class=\"n\">x29</span><span class=\"p\">,</span> <span class=\"n\">x30</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">sp</span><span class=\"p\">,</span> <span class=\"err\">#</span><span class=\"o\">-</span><span class=\"mi\">16</span><span class=\"p\">]</span><span class=\"o\">!</span><span class=\"p\">;</span> <span class=\"c1\">// 把 x29, x30的值存到 sp-16的地址上，并且把 sp-=16. </span>\n</span><span class='line'><span class=\"n\">ldp</span> <span class=\"n\">x29</span><span class=\"p\">,</span> <span class=\"n\">x30</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">sp</span><span class=\"p\">],</span> <span class=\"err\">#</span><span class=\"mi\">16</span><span class=\"p\">;</span>  <span class=\"c1\">// 从sp地址取出 16 byte数据，分别存入x29, x30. 然后 sp+=16;</span>\n</span></code></pre></td></tr></table></div></figure>\n\n\n<p>其中寻址的格式由分为下面这3种类型：</p>\n\n<figure class='code'><figcaption><span></span></figcaption><div class=\"highlight\"><table><tr><td class=\"gutter\"><pre class=\"line-numbers\"><span class='line-number'>1</span>\n<span class='line-number'>2</span>\n<span class='line-number'>3</span>\n</pre></td><td class='code'><pre><code class='c'><span class='line'><span class=\"p\">[</span><span class=\"n\">x10</span><span class=\"p\">,</span> <span class=\"err\">#</span><span class=\"mh\">0x10</span><span class=\"p\">]</span>      <span class=\"c1\">// signed offset。 意思是从 x10 + 0x10的地址取值</span>\n</span><span class='line'><span class=\"p\">[</span><span class=\"n\">sp</span><span class=\"p\">,</span> <span class=\"err\">#</span><span class=\"o\">-</span><span class=\"mi\">16</span><span class=\"p\">]</span><span class=\"o\">!</span>       <span class=\"c1\">// pre-index。  意思是从 sp-16地址取值，取值完后在把 sp-16  writeback 回 sp</span>\n</span><span class='line'><span class=\"p\">[</span><span class=\"n\">sp</span><span class=\"p\">],</span> <span class=\"err\">#</span><span class=\"mi\">16</span>         <span class=\"c1\">// post-index。 意思是从 sp 地址取值，取值完后在把 sp+16 writeback 回 sp</span>\n</span></code></pre></td></tr></table></div></figure>\n\n\n<h4>0x233 跳转</h4>\n\n<p>跳转氛围有返回跳转<code>BL</code>和无返回跳转<code>B</code>。  有返回的意思就是会存<code>lr</code>,因此 <code>BL</code>的<code>L</code>也可以理解为<code>LR</code>的意思。</p>\n\n<blockquote><p> 1.存了<code>LR</code>也就意味着可以返回到本方法继续执行。一般用于不同方法直接的调用</br>\n 2.<code>B</code>相关的跳转没有<code>LR</code>，一般是本方法内的跳转，如<code>while</code>循环，<code>if else</code>等。</p></blockquote>\n\n<p>跳转相关的指令还会有种逻辑运算，就是<code>condition code</code>。配合状态寄存器中的状态标示，就是代码分支<code>if else</code>实现的关键。</br>\n<code>condition code</code>有以下这些，表格中还标注除了分别是比NZCV的哪个值：\n<img src=\"http://blog.cnbluebox.com/images/arm64-start/4.png\" alt=\"4.png\" /></p>\n\n<p>如：</p>\n\n<figure class='code'><figcaption><span></span></figcaption><div class=\"highlight\"><table><tr><td class=\"gutter\"><pre class=\"line-numbers\"><span class='line-number'>1</span>\n<span class='line-number'>2</span>\n<span class='line-number'>3</span>\n<span class='line-number'>4</span>\n<span class='line-number'>5</span>\n</pre></td><td class='code'><pre><code class='c'><span class='line'><span class=\"n\">cmp</span> <span class=\"n\">x2</span><span class=\"p\">,</span> <span class=\"err\">#</span><span class=\"mi\">0</span><span class=\"p\">;</span>         <span class=\"c1\">// x2 - 0 = 0。  状态寄存器标识zero: PSTATE.NZCV.Z = 1</span>\n</span><span class='line'><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">ne</span>  <span class=\"mh\">0x1000d48f0</span><span class=\"p\">;</span>  <span class=\"c1\">// ne就是个condition code, 这句的意思是，当判断状态寄存器 NZCV.Z != 1才跳转，因此这句不会跳转</span>\n</span><span class='line'>\n</span><span class='line'><span class=\"mh\">0x1000d4ab0</span> <span class=\"n\">bl</span> <span class=\"n\">testFuncA</span><span class=\"p\">;</span>  <span class=\"c1\">// 跳转方法，这个时候 lr 设置为 0x1000d4ab4</span>\n</span><span class='line'><span class=\"mh\">0x1000d4ab4</span> <span class=\"n\">orr</span> <span class=\"n\">x8</span><span class=\"p\">,</span> <span class=\"n\">xzr</span><span class=\"p\">,</span> <span class=\"err\">#</span><span class=\"mh\">0x1f00000000</span> <span class=\"c1\">// testFuncA执行完之后跳回lr就周到了这一行</span>\n</span></code></pre></td></tr></table></div></figure>\n\n\n<h2>0x4 小结</h2>\n\n<p>本文简单介绍了一些arm64的汇编知识，arm64汇编的学习对于理解iOS代码的执行，计算机的运行都有着不少的好处。我们在日常中利用汇编知识可以定位一些疑难杂症的crash问题。可以从汇编原理出手开一个个脑洞，玩一些黑科技。比如包瘦身，静态扫描等。</p>\n\n<p>汇编指令的执行是简单确定的，不会像我们调试其他代码一眼，有些诡异问题，而汇编每条指令的结果都是确定的，从这一角度来定位问题往往可以定位到根本原因。</p>\n\n<p>在汇编指令执行的世界，你可以对代码执行有更深刻的理解，原来一行代码会被分解成这么多的指令！因此，如果你在看完本文后对于学习汇编有了兴趣，但是有很多细节还不太懂，建议你自己用<code>hopper</code>反编译一些代码，自己尝试一行一行理解每一个指令的意义，基本看透几个方法就可以融汇贯通了。</p>\n\n<h2>0x5 参考</h2>\n\n<ul>\n<li><a href=\"https://developer.arm.com/products/architecture\">ARMv8-A Architecture &#8211; ARM</a></li>\n</ul>\n\n","descriptionType":"html","feedId":35886,"bgimg":"http://blog.cnbluebox.com/images/arm64-start/1.png","linkMd5":"5de78b017f9d0f607e8c352cbe7996ef","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn40@2020_2/2020/11/15/23-04-53-556_b0fe171bcd653436.webp","destWidth":1204,"destHeight":228,"sourceBytes":19201,"destBytes":5234,"author":"","articleImgCdnMap":{"http://blog.cnbluebox.com/images/arm64-start/1.png":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn40@2020_2/2020/11/15/23-04-53-556_b0fe171bcd653436.webp","http://blog.cnbluebox.com/images/arm64-start/2.png":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn46@2020_4/2020/11/15/23-05-07-165_afc239da0d9a87e0.webp","http://blog.cnbluebox.com/images/arm64-start/3.jpeg":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn44@2020_4/2020/11/15/23-05-07-798_5147f669962bb886.webp","http://blog.cnbluebox.com/images/arm64-start/4.png":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn52@2020_6/2020/11/15/23-05-08-424_167948f9fa0ed4ce.webp"},"publishedOrCreatedDate":1605481483175}],"record":{"createdTime":"2020-11-16 07:04:43","updatedTime":"2020-11-16 07:04:43","feedId":35886,"fetchDate":"Sun, 15 Nov 2020 23:04:43 +0000","fetchMs":3389,"handleMs":31,"totalMs":30753,"newArticles":0,"totalArticles":20,"status":1,"type":0,"ip":"07219db1b3e400b7fa1500b956025226","hostName":"europe-58*","requestId":"bccfffb73e344df79aa844480fa1e5b0_35886","contentType":"text/xml","totalBytes":109856,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":4,"articlesImgsGithubTotal":4,"successGithubMap":{"myreaderx10":1,"myreaderx21":1,"myreaderx3":1,"myreaderx29":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 03:06:01","updatedTime":"2020-09-07 05:19:28","id":35886,"name":"刘坤的技术博客","url":"http://blog.cnbluebox.com/atom.xml","subscriber":90,"website":null,"icon":"http://blog.cnbluebox.com/favicon.png","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx64/cdn60@2020_4/2020/09/06/21-19-22-302_5c59f4da2d8a04c2.png","description":"","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":5234,"tmpBodyImgCdnBytes":104622,"tmpBgImgCdnBytes":0,"extra4":{"start":1605481478610,"total":0,"statList":[{"spend":4535,"msg":"获取xml内容"},{"spend":31,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":14934,"msg":"正文链接上传到cdn"}]},"extra5":4,"extra6":4,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-032.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-020.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-031.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"http://blog.cnbluebox.com/images/arm64-start/1.png","sourceStatusCode":200,"destWidth":1204,"destHeight":228,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn40@2020_2/2020/11/15/23-04-53-556_b0fe171bcd653436.webp","sourceBytes":19201,"destBytes":5234,"targetWebpQuality":75,"feedId":35886,"totalSpendMs":11226,"convertSpendMs":10,"createdTime":"2020-11-16 07:04:43","host":"europe67*","referer":"http://blog.cnbluebox.com/blog/2017/07/24/arm64-start","linkMd5ListStr":"5de78b017f9d0f607e8c352cbe7996ef,5de78b017f9d0f607e8c352cbe7996ef","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.8 KB","destSize":"5.1 KB","compressRate":"27.3%"},{"code":1,"isDone":false,"source":"http://blog.cnbluebox.com/images/arm64-start/2.png","sourceStatusCode":200,"destWidth":1486,"destHeight":426,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn46@2020_4/2020/11/15/23-05-07-165_afc239da0d9a87e0.webp","sourceBytes":47746,"destBytes":18774,"targetWebpQuality":75,"feedId":35886,"totalSpendMs":13436,"convertSpendMs":63,"createdTime":"2020-11-16 07:04:54","host":"us-032*","referer":"http://blog.cnbluebox.com/blog/2017/07/24/arm64-start","linkMd5ListStr":"5de78b017f9d0f607e8c352cbe7996ef","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"46.6 KB","destSize":"18.3 KB","compressRate":"39.3%"},{"code":1,"isDone":false,"source":"http://blog.cnbluebox.com/images/arm64-start/3.jpeg","sourceStatusCode":200,"destWidth":1024,"destHeight":768,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn44@2020_4/2020/11/15/23-05-07-798_5147f669962bb886.webp","sourceBytes":174949,"destBytes":29960,"targetWebpQuality":75,"feedId":35886,"totalSpendMs":14110,"convertSpendMs":36,"createdTime":"2020-11-16 07:04:54","host":"us-031*","referer":"http://blog.cnbluebox.com/blog/2017/07/24/arm64-start","linkMd5ListStr":"5de78b017f9d0f607e8c352cbe7996ef","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"170.8 KB","destSize":"29.3 KB","compressRate":"17.1%"},{"code":1,"isDone":false,"source":"http://blog.cnbluebox.com/images/arm64-start/4.png","sourceStatusCode":200,"destWidth":782,"destHeight":412,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn52@2020_6/2020/11/15/23-05-08-424_167948f9fa0ed4ce.webp","sourceBytes":114132,"destBytes":55888,"targetWebpQuality":75,"feedId":35886,"totalSpendMs":14768,"convertSpendMs":20,"createdTime":"2020-11-16 07:04:54","host":"us-020*","referer":"http://blog.cnbluebox.com/blog/2017/07/24/arm64-start","linkMd5ListStr":"5de78b017f9d0f607e8c352cbe7996ef","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"111.5 KB","destSize":"54.6 KB","compressRate":"49%"}],"successGithubMap":{"myreaderx10":1,"myreaderx21":1,"myreaderx3":1,"myreaderx29":1},"failGithubMap":{}}