{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2021-04-26 02:10:41","updatedTime":"2021-04-26 02:10:41","title":"前端基础-TCP/IP 不完全详解","link":"https://segmentfault.com/a/1190000039880772","description":"<h1>TCP/IP 不完全详解</h1>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039880774\" alt=\"\" title=\"\" /></p>\n<p>TCP/IP是通信协议的统称。首先，我们先认识一下OSI参考模型</p>\n<h2>OSI 参考模型</h2>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039880775\" alt=\"\" title=\"\" /></p>\n<p>OSI 参考模型中各个分层的作用如下：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039880776\" alt=\"\" title=\"\" /></p>\n<p><strong>概括的说：</strong></p>\n<ul>\n <li><code>应用层</code>：为应用程序提供服务并规定应用程序中通信的相关细节。包括文件传输、电子邮件、远程登陆等协议</li>\n <li><code>表示层</code>：将应用处理的信息转换为适合网络传输的格式，或将下一层的数据转换为上层能够处理的格式。因此它主要负责数据格式的转换。 具体来说，就是将设备固有的数据格式转换为网络标准传输格式。不同设备对比同一比特流解释的结果可能会不同。因此，使它们保持一致是这一层的主要作用。</li>\n <li><code>会话层</code>：负责建立和断开通信链接，以及数据的分割等数据传输相关的管理。</li>\n <li><code>传输层</code>：起着可靠传输的作用。只在通信双方节点上进行处理，而无需在路由器上处理。</li>\n <li><code>网络层</code>：将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。</li>\n <li><code>数据链路层</code>：负责物理层面上互连的、节点之间的通信传输。例如与1个以太网相连的2 个节点之间的通信。 将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）。</li>\n <li><code>物理层</code>：负责0、1比特流（0、1序列）与电压的高低、光的闪灭之间的互换。</li>\n</ul>\n<h2>TCP/IP 基础知识</h2>\n<p><strong>TCP/IP与OSI参考模型</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039880777\" alt=\"\" title=\"\" /></p>\n<h3>硬件（物理层）</h3>\n<p>TCP/IP的最底层是负责数据传输的硬件。这种硬件就相当于以太网或电话线路等物理层的设备。关于它的内容一直无法统一定义。因为只要人们在物理层面上所使用的传输媒介不同（如使用网线或无线），网络的带宽、可靠性、安全性、 延迟等都会有所不同，而在这些方面又没有一个既定的指标。总之，TCP/IP是在网络互连的设备之间能够通信的前提下才被提出的协议。</p>\n<h3>网络接口层（数据链路层）</h3>\n<p>利用以太网中的数据链路层进行通信，因此属于接口层。也就是说，把它当做让NIC起作用的“驱动程序”也无妨。驱动程序是在操作系统与硬件之间起桥梁作用的软件。计算机的外围附加设备或扩展卡，不是直接插到电脑上或电脑的扩展槽上就能马上使用的，还需要有相应驱动程序的支持。</p>\n<h3>互联网层（网络层）</h3>\n<p>互联网层使用IP协议，它相当于OSI模型中的第3层网络层。IP协议基于IP地址转发分包数据。</p>\n<p>TCP/IP分层中的互联网层与传输层的功能通常由操作系统提供。尤其是路由 器，它必须得实现通过互联网层转发分组数据包的功能。</p>\n<p>此外，连接互联网的所有主机跟路由器必须都实现IP的功能。其他连接互联网的网络设备（如网桥、中继器或集线器）就没必要一定实现IP或TCP的功能。</p>\n<p><strong>IP</strong></p>\n<ul>\n <li>ip是跨越网络传送数据包，使整个互联网都能收到数据的协议。ip协议使数据能够发送到地球的另一端，这期间它使用IP地址作为主机的标识。</li>\n <li>IP还隐含着数据链路层的功能。通过IP,相互通信的主机之间不论经过怎样的底层数据链路都能够实现通信。</li>\n <li>虽然IP也是分组交换的一种协议，但是它不具有重发机制。即使分组数据包未能到达对端主机也不会重发。因此，属于非可靠性传输协议。</li>\n</ul>\n<p><strong>ICMP</strong></p>\n<ul>\n <li>IP数据包在发送途中一旦发生异常导致无法到达对端目标地址时，需要给发送端发送一个发生异常的通知。ICMP就是为这一功能而制定的。它有时也被用来诊断网络的健康状况。</li>\n</ul>\n<p><strong>ARP</strong></p>\n<ul>\n <li>从分组数据包的IP地址中解析出物理地址（MAC地址）的一种协议。</li>\n</ul>\n<h3>传输层</h3>\n<p>TCP/IP的传输层有两个具有代表性的协议。该层的功能本身与OSI参考模型 中的传输层类似。</p>\n<p>传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同一时间运行着多个程序。为此，必须分清是哪些程序与哪些程序在进行通信。识别这些应用程序的是端口号。</p>\n<p><strong>TCP</strong></p>\n<ul>\n <li>TCP是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外, TCP还能够有效利用带宽，缓解网络拥堵。</li>\n <li>然而，为了建立与断开连接，有时它需要至少7次的发包收包，导致网络流量的浪费。此外，为了提高网络的利用率，TCP协议中定义了各种各样复杂的规范，因此不利于视频会议（音频、视频的数据量既定）等场合使用。</li>\n</ul>\n<p><strong>UDP</strong></p>\n<ul>\n <li>UDP有别于TCP,它是一种面向无连接的传输层协议。UDP不会关注对端是否真的收到了传送过去的数据，如果需要检査对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。</li>\n <li>UDP常用于分组数据较少或多播、广播通信以及视频通信等多媒体领域。</li>\n</ul>\n<h3>应用层（会话层以上的分层）</h3>\n<p>TCP/IP的分层中，将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。这些功能有时由一个单一的程序实现，有时也可能会由多个程序实现。因此，细看TCP/IP的应用程序功能会发现，它不仅实现OSI模型中应用层的内容，还要实现会话层与表示层的功能。</p>\n<p>TCP/IP应用的架构绝大多数属于客户端/服务端模型。提供服务的程序叫服务端，接受服务的程序叫客户端。在这种通信模式中，提供服务的程序会预先被部署到主机上，等待接收任何时刻客户可能发送的请求。</p>\n<p>客户端可以随时发送请求给服务端。有时服务端可能会有处理异常、超出负载等情况，这时客户端可以在等待片刻后重发一次请求。</p>\n<p><strong>WWW</strong></p>\n<ul>\n <li>WWW可以说是互联网能够如此普及的一个重要原动力。用户在一种叫Web 浏览器的软件上借助鼠标和键盘就可以轻轻松松地在网上自由地冲浪。也就是说轻按一下鼠标架设在远端服务器上的各种信息就会呈现到浏览器上。浏览器中既可以显示文字、图片、动画等信息，还能播放声音以及运行程序。</li>\n <li>浏览器与服务端之间通信所用的协议是HTTP（ HyperText Transfer Protocol）。所传输数据的主要格式是HTML（ HyperText Markup Language ）。WWW中的HTTP属于OSI应用层的协议，而HTML属于表示层的协议。</li>\n</ul>\n<p><strong>E-Mail</strong></p>\n<ul>\n <li>电子邮件其实就是指在网络上发送信件。有了电子邮件，不管距离多远的人,只要连着互联网就可以相互发送邮件。发送电子邮件时用到的协议叫做SMTP。</li>\n</ul>\n<p><strong>文件传输（FTP）</strong></p>\n<ul>\n <li>文件传输是指将保存在其他计算机硬盘上的文件转移到本地的硬盘上，或将本地硬盘的文件传送到其他机器硬盘上的意思。</li>\n <li>该过程使用的协议叫做FTP(File Transfer Prototol)。FTP很早就已经投入使用、传输过程中可以选择用二进制方式还是文本方式。</li>\n <li>在FTP中进行文件传输时会建立两个TCP连接，分别是发出传输请求时所要用到的控制连接与实际传输数据时所要用到的数据连接。</li>\n</ul>\n<p><strong>远程登录（TELNET与SSH）</strong></p>\n<ul>\n <li>远程登录是指登录到远程的计算机上，使那台计算机上的程序得以运行的一种功能。TCP/IP网络中远程登录常用TELNET和SSH两种协议。</li>\n</ul>\n<p><strong>网络管理(SNMP)</strong></p>\n<ul>\n <li>在TCP/IP 中进行网络管理时，采用SNMP( Simple Network Management Protocol)协议。使用SNMP管理的主机、网桥、路由器等称作SNMP代理(Agent),而进行管理的那一段叫做管理器(Manager)。SNMP正是这个Manager与Agent所要用到的协议。</li>\n <li>在SNMP的代理端，保存着网络接口的信息、通信数据量、异常数据量以及设备温度等信息。这些信息可以通过MIB( Management Information Base)访问。因此，在TCP/IP的网络管理中，SNMP属于应用协议，MIB属于表示层协议。</li>\n <li>一个网络范围越大，结构越复杂，就越需要对其进行有效的管理。而SNMP可以让管理员及时检査网络拥堵情况，及早发现故障，也可以为以后扩大网络收集必要的信息。</li>\n</ul>\n<h3>TCP/IP 分层模型与通信示例</h3>\n<p><strong>数据包首部</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039880778\" alt=\"\" title=\"\" /></p>\n<p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。</p>\n<hr>\n <p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上层传过来的数据。首部的结构由协议的具体规范详细定义。例如，识别上一层协议的域应该从包的哪一位开始取多少个比特、如何计算校验和并插入包的哪一位等。相互通信的两端计算机如果在识别协议的序号以及校验和的计算方法上不一样，就根本无法实现通信。</p>\n <p>因此，在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理内容。因此，看到包首部就如同看到协议的规范。首部就像是协议的脸。</p>\n <p><strong>示例：发送数据包</strong></p>\n <p>假设甲给乙发送电子邮件，内容为：“早上好”。而从TCP/IP通信上看，是从一台计算机A向另一台计算机B发送电子邮件。我们就通过这个例子来讲解一 下TCP/IP通信的过程。</p>\n <ul>\n  <li><p><code>应用程序处理</code></p><p>启动应用程序新建邮件，将收件人邮箱填好，再由键盘输入邮件内容“早上好”，鼠标点击“发送”按钮就可以开始TCP/IP的通信了。</p><p>首先，应用程序中会进行编码处理。(UTF-8等)这些编码相当于OSI的表示层功能。</p><p>编码转化后，实际邮件不一定会马上被发送出去，因为有些邮件的软件有一次同时发送多个邮件的功能，也可能会有用户点击“收信”按钮以后才一并接收新邮件的功能。像这种何时建立通信连接何时发送数据的管理功能，从某种宽泛的意义上看属于OSI参考模型中会话层的功能。</p><p>应用在发送邮件的那一刻建立TCP连接，从而利用这个TCP连接发送数据。 它的过程首先是将应用的数据发送给下一层的TCP,再做实际的转发处理。</p></li>\n  <li><p><code>TCP模块的处理</code></p><p>TCP根据应用的指示负责建立连接、发送数据以及断开连接。TCP提供将应用层发来的数据顺利发送至对端的可靠传输。</p><p>为了实现TCP的这一功能，需要在应用层数据的前端附加一个TCP首部。TCP首部中包括源端口号和目标端口号（用以识别发送主机跟接收主机上的应用）、序号（用以发送的包中哪部分是数据）以及校验和（用以判断数据是否被损坏）。随后将附加了TCP首部的包再发送给IP。</p></li>\n  <li><p><code>IP模块的处理</code></p><p>IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端在加上自己的IP首部。因此，IP数据包中IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含接收端IP地址以及发送端IP地址。紧随IP首部的还有用来判断其后面数据是TCP还是UDP的信息。</p><p>IP包生成后，参考路由控制表决定接受此IP包的路由或主机。随后，IP包将被发送给连接这些路由器或主机网络接口的驱动程序，以实现真正发送数据。</p><p>如果尚不知道接收端的MAC地址，可以利用ARP（ Address Resolution Protocol）查找。只要知道了对端的MAC地址，就可以将MAC地址和IP地址交给以太网的驱动程序，实现数据传输。</p></li>\n  <li><p><code>网络接口（以太网驱动）的处理</code></p><p>从IP传过来的IP包，对于以太网驱动来说不过就是数据。给这数据附加上以太网首部并进行发送处理。以太网首部中包含接收端MAC地址、发送端MAC地址以及标志以太网类型的以太网数据的协议。根据上述信息产生的以太网数据包将通过物理层传输给接收端。发送处理中的FCS由硬件计算，添加到包的最后。设置FCS的目的是为了判断数据包是否由于噪声而被破坏。</p></li>\n </ul>\n <p>总结如下图：</p>\n <p><img src=\"https://segmentfault.com/img/remote/1460000039880779\" alt=\"\" title=\"\" /></p>\n <hr>\n  <p><strong>经过数据链路的包</strong></p>\n  <p>包流动时，从前往后依此被附加了以太网包首部、IP包首部、TCP包首部 （或者UDP包首部）以及应用自己的包首部和数据。而包的最后则追加了以太网包尾</p>\n  <p>每个包首部中至少都会包含两个信息：一个是发送端和接收端地址，另一个是上一层的协议类型。</p>\n  <p>经过每个协议分层时，都必须有识别包发送端和接收端的信息。以太网会用MAC地址，IP会用IP地址，而TCP/UDP则会用端口号作为识别两端主机的地址。即使是在应用程序中，像电子邮件地址这样的信息也是一种地址标识。这些地址信息都在每个包经由各个分层时，附加到协议对应的包首部里边。如图：</p>\n  <p><img src=\"https://segmentfault.com/img/remote/1460000039880780\" alt=\"\" title=\"\" /></p>\n  <p>此外，每个分层的包首部中还包含一个识别位，它是用来标识上一层协议的种类信息。例如以太网的包首部中的以太网类型，IP中的协议类型以及TCP/UDP中两个端口的端口号等都起着识别协议类型的作用。就是在应用的首部信息中，有时也会包含一个用来识别其数据类型的标签。</p>\n  <p><strong>数据包接收处理</strong></p>\n  <p>接收与发送是逆序的过程：</p>\n  <ul>\n   <li><p><code>网络接口 （以太网驱动）的处理</code></p><p>主机收到以太网包以后，首先从以太网的包首部找到MAC地址判断是否为发给自己的包。如果不是发给自己的包则丢弃数据。</p><p>而如果接收到了恰好是发给自己的包，就查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型。在这个例子中数据类型显然是IP包，因此再将数据传给处理IP的子程序，如果这时不是IP而是其他诸如ARP的协议, 就把数据传给ARP处理。总之，如果以太网包首部的类型域包含了一个无法识别的协议类型，则丢弃数据。</p></li>\n   <li><p><code>IP模块的处理</code></p><p>IP模块收到IP包首部及后面的数据部分以后，也做类似的处理。如果判断得出包首部中的IP地址与自己的IP地址匹配，则可接收数据并从中查找上一层的协议。如果上一层是TCP就将IP包首部之后的部分传给TCP处理；如果是UDP则将IP包首部后面的部分传给UDP处理。对于有路由器的情况下，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调査应该送达的主机或路由器以后再转发数据。</p></li>\n   <li><p><code>TCP模块的处理</code></p><p>在TCP模块中，首先会计算一下校验和判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。</p><p>数据接收完毕后，接收端则发送一个“确认回执”给发送端。如果这个回执信息未能达到发送端，那么发送端会认为接收端没有接收到数据而一直反复发送。</p><p>数据被完整地接收以后，会传给由端口号识别的应用程序。</p></li>\n   <li><p><code>应用程序的处理</code></p><p>接收端应用程序会直接接收发送端发送的数据。通过解析数据可以获知邮件的收件人地址是乙的地址。如果主机B上没有乙的邮件信箱，那么主机B返回给发送端一个“无此收件地址”的报错信息。</p><p>但在这个例子中，主机B上恰好有乙的收件箱，所以主机B和收件人乙能够收到电子邮件的正文。邮件会被保存到本机的硬盘上。如果保存也能正常进行, 那么接收端会返回一个“处理正常”的回执给发送端。反之，一旦出现磁盘满、邮件未能成功保存等问题，就会发送一个“处理异常”的回执给发送端。</p><p>由此，用户乙就可以利用主机B上的邮件客户端，接收并阅读由主机A上的用户甲所发送过来的电子邮件——“早上好”。</p></li>\n  </ul>\n  <hr>\n   <h2>数据链路</h2>\n   <p>数据链路，指OSI参考模型中的数据链路层，有时也指以太网、无线局域网等通信手段。</p>\n   <p>数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范。通信媒介包括双绞线电缆、同轴电缆、光纤、电波以及红外线等介质。此外，各个设备之间有时也会通过交换机、网桥、中继器等中转数据。</p>\n   <p>数据链路也可以被视为网络传输中的最小单位。其实，仔细观察连通全世界的互联网就可以发现，它也不外乎是由众多这样的数据链路组成的，因此又可以称互联网为“数据链路的集合”。</p>\n   <p><strong>MAC地址</strong></p>\n   <p>MAC地址用于识别数据链路中互连的节点。以太网或FDDI中，根据IEEE802.3V的规范使用MAC地址。其他诸如无线LAN（IEEE802.lla/b/g/n等）、蓝牙等设备中也是用相同规格的MAC地址。</p>\n   <p>MAC地址长48比特。MAC地址中3~24位（比特位）表示厂商识别码，每个NICT商都有特定唯一的识别数字。25-48位是厂商内部为识别每个网卡而用。因此，可以保证全世界不会有相同MAC地址的网卡。</p>\n   <p>IEEE802.3制定MAC地址规范时没有限定数据链路的类型，即不论哪种数据链路的网络（以太网、FDDI、ATM、无线LAN、蓝牙等），都不会有相同的MAC地址出现。</p>\n   <ul>\n    <li>例外情况：人们可以在微机板上自由设置自己的MAC地址。再例如，一 台主机上如果启动多个虚拟机，由于没有硬件的网卡只能由虚拟软件自己设定MAC地址给多个虚拟网卡，这时就很难保证所生成的MAC地址是独一无二的了。但是，无论哪个协议成员通信设备，设计前提都是MAC地址的唯一性。这也可以说是网络世界的基本准则。</li>\n   </ul>\n   <p><strong>共享介质型网络</strong></p>\n   <p>从通信介质（通信，介质）的使用方法上看，网络可分为共享介质型和非共享介质型。</p>\n   <p>共享介质型网络指由多个设备共享一个通信介质的一种网络。最早的以太网和FDDI就是介质共享型网络。在这种方式下，设备之间使用同一个载波信道进行发送和接收。为此，基本上采用半双工通信方式，并有必要对介质进行访问控制。</p>\n   <p>共享介质型网络中有两种介质访问控制方式：一种是争用方式，另一种是令牌传递方式。</p>\n   <ul>\n    <li><p><code>争用方式</code></p><p>争用方式（Contention）是指争夺获取数据传输的权力，也叫CSMA（载波监听多路访问）。这种方法通常令网络中的各个站采用先到先得的方式占用信道发送数据，如果多个站同时发送帧，则会产生冲突现象。也因此会导致网络拥堵和性能下降。</p></li>\n   </ul>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000039880781\" alt=\"\" title=\"\" /></p>\n   <p>另在一部分以太网当中，采用了改良CSMA的另一种方式——CSMA/CD方式。CSMA/CD要求每个站提前检査冲突，一旦发生冲突，则尽早释放信道。其具体工作原理如下:</p>\n   <ul>\n    <li>如果载波信道上没有数据流动，则任何站都可以发送数据。</li>\n    <li>检査是否会发生冲突。一旦发生冲突时，放弃发送数据同时立即释放载波信道。</li>\n    <li>放弃发送以后，随机延时一段时间，再重新争用介质，重新发送帧。</li>\n   </ul>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000039880782\" alt=\"\" title=\"\" /></p>\n   <ul>\n    <li><p><code>令牌传递方式</code></p><p>令牌传递方式是沿着令牌环发送一种叫做“令牌”的特殊报文，是控制传输的一种方式。只有获得令牌的站才能发送数据。这种方式有两个特点：一是不会有冲突，二是每个站都有通过平等循环获得令牌的机会。因此，即使网络拥堵也不会导致性能下降。</p><p>当然，这种方式中，一个站在没有收到令牌前不能发送数据帧，因此在网络不太拥堵的情况下数据链路的利用率也就达不到100%。为此，衍生了多种令牌传递的技术。例如，早期令牌释放、令牌追加等方式以及多个令牌同时循环等方式。这些方式的目的都是为了尽可能地提高网络性能。</p></li>\n   </ul>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000039880783\" alt=\"\" title=\"\" /></p>\n   <p><strong>非共享介质网络</strong></p>\n   <p>非共享介质网络是指不共享介质，是对介质采取专用的一种传输控制方式。在这种方式下，网络中的每个站直连交换机，由交换机负责转发数据帧。此方式下，发送端与接收端并不共享通信介质，因此很多情况下采用全双工通信方式。</p>\n   <p>不仅ATM采用这种传输控制方式，最近它也成为了以太网的主流方式。通过以太网交换机构建网络，从而使计算机与交换机端口之间形成一对一的连接，即可实现全双工通信。在这种一对一连接全双工通信的方式下不会发生冲突，因此不需要CSMA/CD的机制就可以实现更高效的通信。</p>\n   <p><strong>半双工与全双工通信</strong></p>\n   <p>半双工是指，只发送或只接收的通信方式。它类似于无线电收发器，若两端同时说话，是听不见对方说的话的。而全双工不同，它允许在同一时间既可以发送数据也可以接收数据。类似于电话，接打双方可以同时说话。</p>\n   <p><strong>根据MAC地址转发</strong></p>\n   <p>在使用同轴电缆的以太网(10BASE5、10BASE2)等介质共享网络中，同一时间只能有一台主机发送数据。当连网的主机数量增加时，通信性能会明显下降。若将集线器或集中器等设备以星型连接，就出现了一款新的网络设备--<code>交换集线器</code>，这是一种将非介质共享型网络中所使用的交换机用在以太网中的技术，交换集线器也叫做<code>以太网交换机</code>。</p>\n   <p>以太网交换机就是持有多个端口的网桥。它们根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的、用以记录发送接口的表就叫做转发表。</p>\n   <ul>\n    <li><p><code>交换机转发方式</code></p><p>交换机转发方式有两种，一种叫存储转发，另一种叫直通转发。</p><p>存储转发方式检查以太网数据帧末尾的FCS位后再进行转发。因此，可以避免发送由于冲突而被破坏的帧或噪声导致的错误帧。</p><p>直通转发方式中不需要将整个帧全部接收下来以后再进行转发。只需要得知目标地址即可开始转发。因此，它具有延迟较短的优势。但同时也不可避免地有发送错误帧的可能性。</p></li>\n   </ul>\n   <h2>IP协议</h2>\n   <p><code>IP相当于OSI参考模型的第3层</code>。</p>\n   <p>IP (IPv4、IPv6)相当于OSI参考模型中的第3层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点(end-to-end)通信”。</p>\n   <p>网络层的下一层一数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p>\n   <p><code>IP的主要作用就是在复杂的网络环境中将数据包发给最终的目标地址。</code></p>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000039880784\" alt=\"\" title=\"\" /></p>\n   <p>在互联网世界中，将那些配有IP地址的设备叫做“主机”。可以是超天型计算机，也可以是小型计算机。然而，准确地说，主机的定义应该是指“配置有IP地址，但是不进行路由控制的设备”。既配有IP地址又具有路由控制能力的设备叫做“路由器”，跟主机有所区别。而节点则是主机和路由器的统称。</p>\n   <p><strong>网络层与数据链路层的关系</strong></p>\n   <p>数据链路层提供直连两个设备之间的通信功能。与之相比，作为网络层的ip则负责在没有直连的两个网络之间进行通信传输。</p>\n   <h3>IP基础知识</h3>\n   <p>IP大致分为三大作用模块，它们是IP寻址、路由（最终节点为止的转发）以及IP分包与组包。</p>\n   <p><code>MAC地址</code>正是用来标识 同一个链路中不同计算机的一种识别码。<code>IP地址</code>用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。</p>\n   <p><strong>路由控制</strong></p>\n   <p>路由控制（Routing）是指将分组数据发送到最终目标地址的功能。即使网络非常复杂，也可以通过路由控制确定到达目标地址的通路。一旦这个路由控制的运行出现异常，分组数据极有可能“迷失”，无法到达目标地址。因此，一个数据包之所以能够成功地到达最终的目标地址，全靠路由控制。</p>\n   <p><strong>IP属于面向无连接型</strong></p>\n   <p>ip面向无连接。即在发包之前，不需要建立与对端目标地址之间的连接。上层如果遇到需要发送给ip的数据，该数据会立即被压缩成ip包发送出去。</p>\n   <p>在面向有连接的情况下，需要事先建立连接。如果对端主机关机或不存在，也就不可能建立连接。反之，一个没有建立连接的主机也不可能发送数据过来。</p>\n   <p>而面向无连接的情况则不同。即使对端主机关机或不存在，数据包还是会被发送出去。反之，对于一台主机来说，它会何时从哪里收到数据也是不得而知的。通常应该进行网络监控，让主机只接收发给自己的数据包。若没有做好准备很有可能会错过一些该收的包。因此，在面向无连接的方式下可能会有很多冗余的通信。</p>\n   <p><code>ip面向无连接的原因</code>：一是为了简化，二是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外，每次通信之前都要事先建立连接，又会降低处理速度。需要有连接时，可以委托上一层提供此项服务。因此，ip为了实现简单化与高速化采用面向无连接的方式。</p>\n   <p><code>与此对应的上层（传输层）TCP采用的是面向有链接型</code></p>\n   <p>ip的作用在于尽力将数据包发送到目的地，它<code>不做最终收到与否的验证</code>。ip数据包在发送途中可能会出现丢包、错位、数据量翻倍等问题。而这时就需要tcp提供这种保障，tcp负责保证对端主机确实收到收据。</p>\n   <h3>DNS</h3>\n   <p><strong>DNS是用来维护一个用来表示组织内部主机名和IP地址之间对应关系的数据库</strong>。在应用中，当用户输入主机名（域名）时，DNS会自动检索那个注册了主机名和IP地址的数据库，并迅速定位对应的IP地址。而且，如果主机名和IP地址需要进行变更时，也只需要在组织机构内部进行处理即可，而没必要再向其他机构进行申请或报告。</p>\n   <p>域名和域名服务器需要按照分层进行设置。如果域名服务器宕机，那么针对该域的DNS査询也就无法正常工作。因此，为了提高容灾能力，一般会设 置至少两个以上的域名服务器。一旦第一个域名服务器无法提供查询时，就会自动转到第二个甚至第三个域名服务器上进行，以此可以按照顺序进行灾备处理。</p>\n   <p>进行DNS査询的主机和软件叫做DNS解析器。用户所使用的工作站或个人电脑都属于解析器。一个解析器至少要注册一个以上域名服务器的IP地址。通常，它至少包括组织内部的域名服务器的IP地址。</p>\n   <h3>DNS查询</h3>\n   <p><strong>dns查询机制</strong>：</p>\n   <ul>\n    <li>计算机A要访问www.baidu.com。</li>\n    <li>首先向域名服务器中查询对应IP地址。</li>\n    <li>DNS服务器如果知道IP就直接返回，不知道就会向根域名服务器请求查询。</li>\n    <li>根域名返回地址。</li>\n    <li>DNS服务器向www.baidu.com的域名服务器查询IP地址。</li>\n    <li>将查到的IP地址返回给客户端。</li>\n    <li>计算机A建立起跟www.baidu.com的通信。</li>\n   </ul>\n   <h2>TCP与UDP</h2>\n   <p><code>TCP</code>是面向连接的、可靠的流协议。流就是指不间断的数据结构。TCP为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</p>\n   <p><code>UDP</code>是不具有可靠性的数据报协议。细微的处理它会交给上层的应用层去完成。在UDP的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此有时应用需要做重发处理。</p>\n   <h3>UDP的特点</h3>\n   <p><code>UDP</code>不提供复杂的控制机制，利用<code>IP</code>提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中即使出现丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交由釆用UDP的应用程序去处理。由于UDP面向无连接，且本身的处理简单高效，因此经常用于以下几个方面：</p>\n   <ul>\n    <li>包总量较少的通信（DNS，SNMP等）</li>\n    <li>视频、音频等多媒体通信</li>\n    <li>限定于LAN等特定网络中的应用通信</li>\n    <li>广播通信</li>\n   </ul>\n   <h3>TCP的特点</h3>\n   <p><code>TCP</code>与<code>UDP</code>的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p>\n   <p><strong>TCP握手挥手示意图：</strong></p>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000039880785\" alt=\"\" title=\"\" /></p>\n   <p><strong>TCP窗口控制与重发控制</strong></p>\n   <p>在使用窗口控制中，如果出现段丢失，先考虑确认应答未能返回的情况。在这种情况下，数据已经到达 对端，是不需要再进行重发的。然而，在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发。</p>\n   <p>其次考虑发送时丢失情况，接收主机如果收到一个自己应该接收的序号以外的数据时，会针对当前为止收到数据返回确认应答。如下图：</p>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000039880786\" alt=\"\" title=\"\" /></p>\n   <p>当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，这个确认应答好像在提醒发送端“我想接收的是从1001开始的数据”。 因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答、就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称作<code>高速重发控制</code>。</p>\n   <p><strong>流控制</strong></p>\n   <p>发送端根据自己的实际情况发送数据。但是，接收端可能收到的是一个毫无关系的数据包又可能会在处理其他问题上花费一些时间。因此在为这个数据包做其他处理时会耗费一些时间，甚至在高负荷的情况下无法接收任何数据。如此一来，如果接收端将本应该接收的数据丢弃的话，就又会触发重发机制，从而导致网络流量的无端浪费。</p>\n   <p>为了防止这种现象的发生，TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的流控制。它的具体操作是，接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度就被称作窗口大小。</p>\n   <p>TCP首部中，专门有一个字段用来通知窗口大小。接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。这个字段的值越大，说明网络的吞吐量越高。</p>\n   <p>不过，接收端的这个缓冲区一旦面临数据溢出时，窗口大小的值也会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。也就是说，发送端主机会根据接收端主机的指示，对发送数据的量进行控制。这也就形成了一个完整的<code>TCP流控制</code>。</p>\n   <p><strong>拥塞控制</strong></p>\n   <p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪。</p>\n   <p>TCP为了防止该问题的出现，在通信一开始时就会通过一个叫做慢启动的算法得出的数值，对发送数据量进行控制。</p>\n   <h2>应用协议</h2>\n   <p><strong>应用层协议的定义</strong></p>\n   <p>利用网络的应用程序有很多，包括Web浏览器、电子邮件、远程登录、文件 传输、网络管理等。能够让这些应用进行特定通信处理的正是应用协议。</p>\n   <p>TCP和IP等下层协议是不依赖于上层应用类型、适用性非常广的协议。而应用协议则是为了实现某种应用而设计和创造的协议。</p>\n   <blockquote>\n    TCP/IP的应用层涵盖了 OSI参考模型中第5、第6、第7层的所有功能，不仅包含了管理通信连接的会话层功能、转换数据格式的表示层功能，还包括与对端主机交互的应用层功能在内的所有功能。\n   </blockquote>\n   <h3>远程登录</h3>\n   <p>实现从自己的本地计算机登录到网络另一端计算功能的应用就叫做<code>远程登录</code>。通过远程登录到通用计算机或UNIX工作站以后，不仅可以直接使用这些主机上的应用，还可以对这些计算机进行参数设置。远程登录主要使用TELNET和SSH两种协议。</p>\n   <p><strong>TELNET</strong></p>\n   <p>TELNET利用TCP的一条连接，通过这一条连接向主机发送文字命令并在主机上执行。本地用户好像直接与远端主机内部的Shell相连着似的，直接在本地进行操作。</p>\n   <p>TELNET可以分为两类基本服务。一是仿真终端功能，二是协商选项机制。</p>\n   <p><strong>SSH</strong></p>\n   <p>SSH是加密的远程登录系统。TELNET中登录时无需输入密码就可以发送，容易造成通信窃听和非法入侵的危险。使用SSH后可以加密通信内容。即使信息被窃听也无法破解所发送的密码、具体命令以及命令返回的结果是什么。</p>\n   <h3>文件传输</h3>\n   <p>FTP是在两个相连的计算机之间进行文件传输时使用的协议。</p>\n   <p><strong>FTP工作机制</strong></p>\n   <p>FTP使用两条TCP连接来实现文件传输：<code>一条用来控制，另一条用于数据(文件)的传输。</code></p>\n   <p>用于控制的TCP连接主要在FTP的控制部分使用。例如登录用户名和密码的验证、发送文件的名称、发送方式的设置。利用这个连接，可以通过ASCII码字符串发送请求和接收应答。在这个连接上无法发送数据，数据需要一个专门的TCP进行连接。</p>\n   <p>控制用的连接，在用户要求断开之前会一直保持连接状态。不过，绝大多数FTP服务器都会对长时间没有任何新命令输入的用户的连接强制断开。</p>\n   <p>通常，用于数据传输的TCP连接是按照与控制用的连接相反的方向建立的。</p>\n   <h3>电子邮件</h3>\n   <p>提供电子邮件服务的协议叫做SMTP ( Simple Mail Transfer Protocol) o SMTP为了实现高效发送邮件内容，在其传输层使用了TCP协议。</p>\n   <h3>WWW</h3>\n   <p>WWW定义了3个重要的概念，它们分别是访问信息的手段与位置(URI, Uniform Resource Identifier)、信息的表现形式(HTML, HyperText Markup Language) 以及信息转发(HTTP, HyperText Transfer Protocol)等操作。</p>\n   <p><strong>URI</strong></p>\n   <p>URI是Uniform Resource Identifier的缩写，用于标识资源。URI是一种可以用于WWW之外的高效的识别码，它被用于主页地址、电子邮件、电话号码等各种 组合中。</p>\n   <p>URL常被人们用来表示互联网中资源(文件)的具体位置。但是URI不局限于标识互联网资源，它可以作为所有资源的识别码。现在，在有效的RFC文档中，已经不再使用URL,转而在使用URI，相比URL狭义的概念，URI则是一个广义的概念。因此，URI可以用于除了WWW之外的其他应用协议中。</p>\n   <p><strong>URI格式</strong></p>\n   <p><code>http： //主机名：端口号/路径？访问内容#部分信息</code></p>\n   <p><strong>TLS/SSL与HTTPS</strong></p>\n   <p>通过TLS/SSL对HTTP通信进行加密叫做HTTPS通信。如图：</p>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000039880787\" alt=\"\" title=\"\" /></p>\n   <h2>结尾一道题</h2>\n   <p>文章到这里，已经写的差不多了。接下来由一道题深入巩固一下知识体系</p>\n   <p><code>从输入URL到页面加载的过程？</code></p>\n   <p>先梳理主干部分：</p>\n   <ol>\n    <li>从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</li>\n    <li>开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）</li>\n    <li>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</li>\n    <li>后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）</li>\n    <li>单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）</li>\n    <li>浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</li>\n    <li>CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）</li>\n    <li>JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</li>\n    <li><p>其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）</p></li>\n   </ol>\n   <h3>从浏览器接收url到开启网络请求线程</h3>\n   <p>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程。</p>\n   <p>进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p>\n   <ul>\n    <li>Browser进程：浏览器的主进程（负责协调、主控），只有一个</li>\n    <li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li>\n    <li>GPU进程：最多一个，用于3D绘制</li>\n    <li>浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li>\n   </ul>\n   <p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程</p>\n   <ul>\n    <li>GUI线程</li>\n    <li>JS引擎线程</li>\n    <li>事件触发线程</li>\n    <li>定时器线程</li>\n    <li>网络请求线程</li>\n   </ul>\n   <p>输入URL后，会进行解析（URL的本质就是统一资源定位符）。URL一般包括几大部分：</p>\n   <ul>\n    <li><code>protocol</code>，协议头，譬如有http，ftp等</li>\n    <li><code>host</code>，主机域名或IP地址</li>\n    <li><code>port</code>，端口号</li>\n    <li><code>path</code>，目录路径</li>\n    <li><code>query</code>，即查询参数</li>\n    <li><code>fragment</code>，即#后的hash值，一般用来定位到某个位置</li>\n   </ul>\n   <p>每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载</p>\n   <p>因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）</p>\n   <h3>开启网络线程到发出一个完整的http请求</h3>\n   <p>这一部分主要内容包括：<code>dns查询</code>，<code>tcp/ip请求构建</code>，<code>五层因特网协议栈</code>等等</p>\n   <p><strong>DNS解析</strong></p>\n   <p>如果输入的是域名，需要进行dns解析成IP，大致流程：</p>\n   <ul>\n    <li>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host</li>\n    <li>如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP</li>\n   </ul>\n   <p>域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话），而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑dns-prefetch优化</p>\n   <p><strong>TCP/IP请求</strong></p>\n   <p>tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输。</p>\n   <p>然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）</p>\n   <p><strong>tcp/ip的并发限制</strong></p>\n   <p>浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）。而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求</p>\n   <p><strong>get和post的区别</strong></p>\n   <p>get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。</p>\n   <p>get会产生一个tcp数据包，post两个</p>\n   <ul>\n    <li>get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据），</li>\n    <li>post请求时，浏览器先发送headers，服务器响应100 continue，浏览器再发送data，服务器响应200（返回数据）。</li>\n   </ul>\n   <p>http层面区别：</p>\n   <ul>\n    <li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>\n    <li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>\n    <li>GET请求只能进行url编码，而POST支持多种编码方式。</li>\n    <li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>\n    <li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>\n    <li>GET参数通过URL传递，POST放在Request body中。</li>\n   </ul>\n   <p><strong>五层因特网协议栈</strong></p>\n   <p>这里的五层就是：应用层、传输层、网络层、数据链路层、硬件层。对应的OSI模型：</p>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000039880788\" alt=\"\" title=\"\" /></p>\n   <h3>从服务器接收到请求到对应后台接收到请求</h3>\n   <p><strong>负载均衡</strong></p>\n   <p>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户</p>\n   <p><strong>http报文结构</strong></p>\n   <ol>\n    <li>通用头部</li>\n   </ol>\n   <pre><code>Request Url: 请求的web服务器地址\nRequest Method: 请求方式\n（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）\nStatus Code: 请求的返回状态码，如200代表成功\nRemote Address: 请求的远程服务器地址（会转为IP）</code></pre>\n   <ol>\n    <li>状态码</li>\n   </ol>\n   <pre><code>1xx——指示信息，表示请求已接收，继续处理\n2xx——成功，表示请求已被成功接收、理解、接受\n3xx——重定向，要完成请求必须进行更进一步的操作\n4xx——客户端错误，请求有语法错误或请求无法实现\n5xx——服务器端错误，服务器未能实现合法的请求\n\n// 常见状态码\n200——表明该请求被成功地完成，所请求的资源发送回客户端\n304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存\n400——客户端请求有错（譬如可以是安全模块拦截）\n401——请求未经授权\n403——禁止访问（譬如可以是未登录时禁止）\n404——资源未找到\n500——服务器内部错误\n503——服务不可用</code></pre>\n   <ol>\n    <li>请求/响应头部</li>\n   </ol>\n   <pre><code>Accept: 接收类型，表示浏览器支持的MIME类型\n（对标服务端返回的Content-Type）\nAccept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收\nContent-Type：客户端发送出去实体内容的类型\nCache-Control: 指定请求和响应遵循的缓存机制，如no-cache\nIf-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中\nExpires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间\nMax-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中\nIf-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中\nCookie: 有cookie并且同域访问时会自动带上\nConnection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive\nHost：请求的服务器URL\nOrigin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私\nReferer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)\nUser-Agent：用户客户端的一些必要信息，如UA头部等</code></pre>\n   <ol>\n    <li>常用的响应头部（部分）</li>\n   </ol>\n   <pre><code>Access-Control-Allow-Headers: 服务器端允许的请求Headers\nAccess-Control-Allow-Methods: 服务器端允许的请求方法\nAccess-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）\nContent-Type：服务端返回的实体内容的类型\nDate：数据从服务器发送的时间\nCache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档\nLast-Modified：请求资源的最后修改时间\nExpires：应该在什么时候认为文档已经过期,从而不再缓存它\nMax-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效\nETag：请求变量的实体标签的当前值\nSet-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端\nKeep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）\nServer：服务器的一些相关信息</code></pre>\n   <p><strong>cookie</strong></p>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000039880789\" alt=\"\" title=\"\" /></p>\n   <p><strong>长连接与短连接</strong></p>\n   <p>TCP/IP 层面：</p>\n   <ul>\n    <li>长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li>\n    <li>短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接</li>\n   </ul>\n   <p>HTTP层面</p>\n   <ul>\n    <li>http1.0中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li>\n    <li>http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li>\n   </ul>\n   <p><code>keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效</code></p>\n   <p><strong>http 2.0</strong></p>\n   <p>http2.0与http1.1的显著不同点:</p>\n   <ul>\n    <li>http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来</li>\n    <li>http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li>\n   </ul>\n   <p>http2.0特性：</p>\n   <ul>\n    <li>多路复用（即一个tcp/ip连接可以请求多个资源）</li>\n    <li>首部压缩（http头部压缩，减少体积）</li>\n    <li>二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li>\n    <li>服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li>\n    <li>请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</li>\n   </ul>\n   <p><strong>https</strong></p>\n   <p>SSL/TLS握手：</p>\n   <ol>\n    <li>浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。</li>\n    <li>服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</li>\n    <li>浏览器收到服务端的证书后</li>\n    <li>验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示</li>\n    <li>用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密<code>Premaster secret</code>，发送给服务器。</li>\n    <li>利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-<code>session key</code></li>\n    <li>使用约定好的HASH算法计算握手消息，并使用生成的<code>session key</code>对消息进行加密，最后将之前生成的所有信息发送给服务端。</li>\n    <li>服务端收到浏览器的回复</li>\n    <li>利用已知的加解密方式与自己的私钥进行解密，获取<code>Premaster secret</code></li>\n    <li>和浏览器相同规则生成<code>session key</code></li>\n    <li>使用<code>session key</code>解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致</li>\n    <li>使用<code>session key</code>加密一段握手消息，发送给浏览器</li>\n    <li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。</li>\n   </ol>\n   <p><strong>HTTP缓存</strong></p>\n   <p>缓存可以简单的划分成两种类型：强缓存（200 from cache）与协商缓存（304）</p>\n   <ul>\n    <li>强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求</li>\n    <li>协商缓存（304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存</li>\n   </ul>\n   <p>http1.1中的缓存控制：</p>\n   <ul>\n    <li><code>Cache-Control</code>：缓存控制头部，有no-cache、max-age等多种取值</li>\n    <li><code>Max-Age</code>：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算</li>\n    <li><code>If-None-Match/E-tag</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</li>\n   </ul>\n   <p><code>Last-Modified</code>：</p>\n   <ul>\n    <li>表明服务端的文件最后何时改变的</li>\n    <li>它有一个缺陷就是只能精确到1s</li>\n    <li>然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效</li>\n   </ul>\n   <p><code>E-tag</code>:</p>\n   <ul>\n    <li>是一种指纹机制，代表文件相关指纹</li>\n    <li>只有文件变才会变，也只要文件变就会变，</li>\n    <li>也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了</li>\n   </ul>\n   <p><code>如果同时带有E-tag和Last-Modified，服务端会优先检查E-tag</code></p>\n   <p><code>如果同时启用了Cache-Control与Expires，Cache-Control优先级高。</code></p>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000039880790\" alt=\"\" title=\"\" /></p>\n   <h3>解析页面流程</h3>\n   <ol>\n    <li>解析HTML，构建DOM树</li>\n    <li>解析CSS，生成CSS规则树</li>\n    <li>合并DOM树和CSS规则，生成render树</li>\n    <li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li>\n    <li>绘制render树（paint），绘制页面像素信息</li>\n    <li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</li>\n   </ol>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000039880791\" alt=\"\" title=\"\" /></p>\n   <p>整个渲染步骤中，HTML解析是第一步。简单的理解，这一步的流程是这样的：<code>浏览器解析HTML，构建DOM树。</code> 过程如下 <code>Bytes → characters → tokens → nodes → DOM</code></p>\n   <ol>\n    <li>Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</li>\n    <li>Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</li>\n    <li>Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</li>\n    <li>DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样。例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象</li>\n   </ol>\n   <p>CSS规则树的生成也是类似。</p>\n   <p><strong>构建渲染树</strong></p>\n   <p>当DOM树和CSSOM都有了后，就要开始构建渲染树了。一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应。因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者<code>display: none</code>等。</p>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000039880792\" alt=\"\" title=\"\" /></p>\n   <p><strong>渲染</strong></p>\n   <p>有了render树，接下来就是开始渲染，基本流程如下：</p>\n   <p><img src=\"https://segmentfault.com/img/remote/1460000039880793\" alt=\"\" title=\"\" /></p>\n   <ol>\n    <li>计算CSS样式</li>\n    <li>构建渲染树</li>\n    <li>布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性</li>\n    <li>绘制，将图像绘制出来</li>\n   </ol>\n   <p>然后，图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）</p>\n   <p>Layout和Repaint的区别：</p>\n   <ul>\n    <li>Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</li>\n    <li>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</li>\n   </ul>\n   <p><strong>什么会引起回流？</strong></p>\n   <ol>\n    <li>页面渲染初始化</li>\n    <li>DOM结构改变，比如删除了某个节点</li>\n    <li>render树变化，比如减少了padding</li>\n    <li>窗口resize</li>\n    <li>最复杂的一种：获取某些属性，引发回流。很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</li>\n    <li>offset(Top/Left/Width/Height)</li>\n    <li>scroll(Top/Left/Width/Height)</li>\n    <li>cilent(Top/Left/Width/Height)</li>\n    <li>width,height</li>\n    <li>调用了getComputedStyle()或者IE的currentStyle</li>\n   </ol>\n   <p><code>改变字体大小会引发回流</code></p>\n   <p><strong>优化方案</strong></p>\n   <ul>\n    <li>减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新</li>\n    <li>避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document</li>\n    <li>避免多次读取offset等属性。无法避免则将它们缓存到变量</li>\n    <li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li>\n   </ul>\n   <p><strong>简单层与复合层</strong></p>\n   <ul>\n    <li>可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的</li>\n    <li>如果开启了硬件加速功能，可以将某个节点变成复合图层</li>\n    <li>复合图层之间的绘制互不干扰，由GPU直接控制</li>\n    <li>而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速</li>\n   </ul>\n   <p><strong>资源外链的下载</strong></p>\n   <p>当遇到外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）</p>\n   <p><code>CSS资源的处理有几个特点</code>：</p>\n   <ul>\n    <li>CSS下载时异步，不会阻塞浏览器构建DOM树</li>\n    <li>但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</li>\n    <li>有例外，media query声明的CSS是不会阻塞渲染的</li>\n   </ul>\n   <p><code>JS脚本资源的处理有几个特点</code>：</p>\n   <ul>\n    <li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML</li>\n    <li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li>\n    <li>defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li>\n   </ul>\n   <p><code>注意，defer和async是有区别的： defer是延迟执行，而async是异步执行。</code></p>\n   <ul>\n    <li>async是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在onload前，但不确定在DOMContentLoaded事件的前或后</li>\n    <li>defer是延迟执行，在浏览器看起来的效果像是将脚本放在了body后面一样（虽然按规范应该是在DOMContentLoaded事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li>\n   </ul>\n   <p>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</p>\n   <p><strong>loaded和domcontentloaded</strong></p>\n   <ul>\n    <li>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)</li>\n    <li>load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li>\n   </ul>\n   <p><strong>BFC（Block Formatting Context）</strong></p>\n   <p>特点：</p>\n   <ul>\n    <li>内部box在垂直方向，一个接一个的放置</li>\n    <li>box的垂直方向由margin决定，属于同一个BFC的两个box间的margin会重叠</li>\n    <li>BFC区域不会与float box重叠（可用于排版)</li>\n    <li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li>\n    <li>计算BFC的高度时，浮动元素也参与计算（不会浮动坍塌）</li>\n   </ul>\n   <p>如何触发BFC？</p>\n   <ul>\n    <li>根元素</li>\n    <li>float属性不为none</li>\n    <li>position为absolute或fixed</li>\n    <li>display为inline-block, flex, inline-flex，table，table-cell，table-caption</li>\n    <li>overflow不为visible</li>\n   </ul>\n   <h2>致谢</h2>\n   <p>本文参考：[从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！<br>](<a href=\"https://zhuanlan.zhihu.com/p/34453198)\" rel=\"nofollow noreferrer\">https://zhuanlan.zhihu.com/p/...</a><br>《图解TCP/IP》</br></br></p>\n   <p>由于本人技术有限，文内如有错误，敬请与我联系，不胜感激！</p>\n  </hr>\n </hr>\n</hr>","descriptionType":"html","publishedDate":"Fri, 23 Apr 2021 02:00:16 +0000","feedId":23280,"bgimg":"https://segmentfault.com/img/remote/1460000039880774","linkMd5":"410f2bf61f9ab1a01b51cc8f96651598","destWidth":521,"destHeight":449,"sourceBytes":38417,"destBytes":20022,"author":"greet_eason","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000039880774":null,"https://segmentfault.com/img/remote/1460000039880775":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn51@2020_5/2021/04/25/18-10-56-780_789d93ac2c460aab.webp","https://segmentfault.com/img/remote/1460000039880776":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn45@2020_5/2021/04/25/18-10-56-691_dae3c0cabd3583c7.webp","https://segmentfault.com/img/remote/1460000039880777":null,"https://segmentfault.com/img/remote/1460000039880778":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn38@2020_4/2021/04/25/18-10-56-640_6fa6cdda856858a8.webp","https://segmentfault.com/img/remote/1460000039880779":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn42@2020_6/2021/04/25/18-10-56-683_22eeebe086c96a9f.webp","https://segmentfault.com/img/remote/1460000039880780":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn33@2020_6/2021/04/25/18-10-56-603_559037c8248561ee.webp","https://segmentfault.com/img/remote/1460000039880781":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn25@2020_6/2021/04/25/18-10-56-426_786c9afa226b8a06.webp","https://segmentfault.com/img/remote/1460000039880782":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn27@2020_2/2021/04/25/18-10-56-584_d6e670e1ae5a8a2c.webp","https://segmentfault.com/img/remote/1460000039880783":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn18@2020_4/2021/04/25/18-10-56-356_a8c821ed7485dabd.webp","https://segmentfault.com/img/remote/1460000039880784":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn22@2020_6/2021/04/25/18-10-56-336_984bd7651dde84c0.webp","https://segmentfault.com/img/remote/1460000039880785":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn9@2020_5/2021/04/25/18-10-56-337_c66eff399ab3de5d.webp","https://segmentfault.com/img/remote/1460000039880786":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn13@2020_3/2021/04/25/18-10-56-503_be7a9f9cf614e125.webp","https://segmentfault.com/img/remote/1460000039880787":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn1@2020_2/2021/04/25/18-10-56-370_8e1e23f7450c0c97.webp","https://segmentfault.com/img/remote/1460000039880788":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn6@2020_1/2021/04/25/18-10-56-414_5f0a190d0493d74e.webp","https://segmentfault.com/img/remote/1460000039880789":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn96@2020_3/2021/04/25/18-10-56-689_f2458b7568b599db.webp","https://segmentfault.com/img/remote/1460000039880790":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn87@2020_4/2021/04/25/18-10-56-787_7bffa19d6e64c38a.webp","https://segmentfault.com/img/remote/1460000039880791":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn94@2020_4/2021/04/25/18-10-56-477_a8677d82b077ab86.webp","https://segmentfault.com/img/remote/1460000039880792":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn82@2020_6/2021/04/25/18-10-56-421_7252a02fe15984ad.webp","https://segmentfault.com/img/remote/1460000039880793":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn84@2020_4/2021/04/25/18-10-58-704_93e0ac205c24881d.webp"},"publishedOrCreatedDate":1619374241964}],"record":{"createdTime":"2021-04-26 02:10:41","updatedTime":"2021-04-26 02:10:41","feedId":23280,"fetchDate":"Sun, 25 Apr 2021 18:10:41 +0000","fetchMs":2878,"handleMs":44,"totalMs":27428,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"af0629e1ae74a27744b4cbd27b40a78e","hostName":"us-019*","requestId":"e65a08208bbc4484bab595a72ef5f241_23280","contentType":"application/atom+xml; charset=UTF-8","totalBytes":579874,"bgimgsTotal":1,"bgimgsGithubTotal":0,"articlesImgsTotal":20,"articlesImgsGithubTotal":18,"successGithubMap":{"myreaderx25":1,"myreaderx7":1,"myreaderx16":1,"myreaderx6":1,"myreaderx27":1,"myreaderx3":1,"myreaderx33":1,"myreaderx22":1,"myreaderx11":1,"myreaderx12":1,"myreaderx2":1,"myreaderx13":1,"myreaderx24":1,"myreaderx1":1,"myreaderx5oss":1,"myreaderx29":1,"myreaderx18":1,"myreaderx19":1},"failGithubMap":{"myreaderx14":1,"myreaderx23":1}},"feed":{"createdTime":"2020-09-07 02:29:58","updatedTime":"2021-04-03 13:59:11","id":23280,"name":"SegmentFault 最新的文章","url":"https://segmentfault.com/feeds/blogs","subscriber":142,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn43@2020_1/2021/04/03/05-58-55-048_eb238dca7c8e9f0e.jpg","description":"","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2021-04-26 02:11:00","updatedTime":"2021-04-26 02:11:00","id":null,"feedId":23280,"linkMd5":"410f2bf61f9ab1a01b51cc8f96651598"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":579874,"tmpBgImgCdnBytes":0,"extra4":{"start":1619374233094,"total":0,"statList":[{"spend":8827,"msg":"获取xml内容"},{"spend":44,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":6316,"msg":"正文链接上传到cdn"}]},"extra5":20,"extra6":20,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880774","sourceStatusCode":200,"destWidth":521,"destHeight":449,"sourceBytes":38417,"destBytes":20022,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2362,"convertSpendMs":12,"createdTime":"2021-04-26 02:10:50","host":"us-039*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598,410f2bf61f9ab1a01b51cc8f96651598","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn76/contents/2021/04/25/18-10-52-580_98b632f60c718c86.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Sun, 25 Apr 2021 18:10:52 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["A358:4279:C49A09:17B108F:6085B0AC"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1619375193"],"x-ratelimit-used":["60"],"x-xss-protection":["0"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn76/contents/2021/04/25/18-10-52-580_98b632f60c718c86.webp","historyStatusCode":[],"spendMs":28},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"37.5 KB","destSize":"19.6 KB","compressRate":"52.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880774","sourceStatusCode":200,"destWidth":521,"destHeight":449,"sourceBytes":38417,"destBytes":20022,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":1589,"convertSpendMs":10,"createdTime":"2021-04-26 02:10:52","host":"us-039*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598,410f2bf61f9ab1a01b51cc8f96651598","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn76/contents/2021/04/25/18-10-54-135_98b632f60c718c86.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Sun, 25 Apr 2021 18:10:54 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["A358:4279:C49AAF:17B11A4:6085B0AE"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1619375193"],"x-ratelimit-used":["60"],"x-xss-protection":["0"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn76/contents/2021/04/25/18-10-54-135_98b632f60c718c86.webp","historyStatusCode":[],"spendMs":31},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"37.5 KB","destSize":"19.6 KB","compressRate":"52.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880777","sourceStatusCode":200,"destWidth":571,"destHeight":361,"sourceBytes":150114,"destBytes":43518,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2575,"convertSpendMs":12,"createdTime":"2021-04-26 02:10:56","host":"us-002*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn49/contents/2021/04/25/18-10-58-706_eeea26effef5cda2.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Sun, 25 Apr 2021 18:10:58 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["AA76:56B4:2AA00C7:4BD4796:6085B0B2"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1619375179"],"x-ratelimit-used":["61"],"x-xss-protection":["0"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn49/contents/2021/04/25/18-10-58-706_eeea26effef5cda2.webp","historyStatusCode":[],"spendMs":82},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"146.6 KB","destSize":"42.5 KB","compressRate":"29%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880777","sourceStatusCode":200,"destWidth":571,"destHeight":361,"sourceBytes":150114,"destBytes":43518,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":1592,"convertSpendMs":15,"createdTime":"2021-04-26 02:10:58","host":"europe-58*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn49/contents/2021/04/25/18-11-00-258_eeea26effef5cda2.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Sun, 25 Apr 2021 18:11:00 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["C7F4:3249:546716:55F417:6085B0B4"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1619375179"],"x-ratelimit-used":["61"],"x-xss-protection":["0"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn49/contents/2021/04/25/18-11-00-258_eeea26effef5cda2.webp","historyStatusCode":[],"spendMs":226},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"146.6 KB","destSize":"42.5 KB","compressRate":"29%"}],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-032.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-53.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-24.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-007.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-002.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://europe-58.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-028.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe70.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-011.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-020.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-54.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-036.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe62.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-010.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-003.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-014.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-040.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880785","sourceStatusCode":200,"destWidth":433,"destHeight":460,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn9@2020_5/2021/04/25/18-10-56-337_c66eff399ab3de5d.webp","sourceBytes":53888,"destBytes":18818,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2352,"convertSpendMs":11,"createdTime":"2021-04-26 02:10:54","host":"us-007*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"52.6 KB","destSize":"18.4 KB","compressRate":"34.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880784","sourceStatusCode":200,"destWidth":562,"destHeight":229,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn22@2020_6/2021/04/25/18-10-56-336_984bd7651dde84c0.webp","sourceBytes":57535,"destBytes":19306,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2357,"convertSpendMs":9,"createdTime":"2021-04-26 02:10:54","host":"us-036*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"56.2 KB","destSize":"18.9 KB","compressRate":"33.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880787","sourceStatusCode":200,"destWidth":551,"destHeight":377,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn1@2020_2/2021/04/25/18-10-56-370_8e1e23f7450c0c97.webp","sourceBytes":100797,"destBytes":34542,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2398,"convertSpendMs":12,"createdTime":"2021-04-26 02:10:54","host":"us-032*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"98.4 KB","destSize":"33.7 KB","compressRate":"34.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880792","sourceStatusCode":200,"destWidth":800,"destHeight":373,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn82@2020_6/2021/04/25/18-10-56-421_7252a02fe15984ad.webp","sourceBytes":211973,"destBytes":27992,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2437,"convertSpendMs":16,"createdTime":"2021-04-26 02:10:54","host":"us-014*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"207 KB","destSize":"27.3 KB","compressRate":"13.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880788","sourceStatusCode":200,"destWidth":571,"destHeight":361,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn6@2020_1/2021/04/25/18-10-56-414_5f0a190d0493d74e.webp","sourceBytes":150114,"destBytes":43518,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2453,"convertSpendMs":14,"createdTime":"2021-04-26 02:10:54","host":"us-020*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"146.6 KB","destSize":"42.5 KB","compressRate":"29%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880781","sourceStatusCode":200,"destWidth":555,"destHeight":461,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn25@2020_6/2021/04/25/18-10-56-426_786c9afa226b8a06.webp","sourceBytes":86303,"destBytes":28732,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2458,"convertSpendMs":17,"createdTime":"2021-04-26 02:10:54","host":"us-010*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"84.3 KB","destSize":"28.1 KB","compressRate":"33.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880791","sourceStatusCode":200,"destWidth":923,"destHeight":375,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn94@2020_4/2021/04/25/18-10-56-477_a8677d82b077ab86.webp","sourceBytes":43284,"destBytes":12996,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2483,"convertSpendMs":19,"createdTime":"2021-04-26 02:10:54","host":"us-53*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"42.3 KB","destSize":"12.7 KB","compressRate":"30%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880782","sourceStatusCode":200,"destWidth":494,"destHeight":503,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn27@2020_2/2021/04/25/18-10-56-584_d6e670e1ae5a8a2c.webp","sourceBytes":108330,"destBytes":34992,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2606,"convertSpendMs":12,"createdTime":"2021-04-26 02:10:54","host":"us-011*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"105.8 KB","destSize":"34.2 KB","compressRate":"32.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880783","sourceStatusCode":200,"destWidth":579,"destHeight":576,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn18@2020_4/2021/04/25/18-10-56-356_a8c821ed7485dabd.webp","sourceBytes":110396,"destBytes":42134,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2479,"convertSpendMs":14,"createdTime":"2021-04-26 02:10:54","host":"europe-58*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"107.8 KB","destSize":"41.1 KB","compressRate":"38.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880779","sourceStatusCode":200,"destWidth":588,"destHeight":758,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn42@2020_6/2021/04/25/18-10-56-683_22eeebe086c96a9f.webp","sourceBytes":261700,"destBytes":76150,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2664,"convertSpendMs":24,"createdTime":"2021-04-26 02:10:54","host":"us-040*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"255.6 KB","destSize":"74.4 KB","compressRate":"29.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880789","sourceStatusCode":200,"destWidth":800,"destHeight":527,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn96@2020_3/2021/04/25/18-10-56-689_f2458b7568b599db.webp","sourceBytes":136954,"destBytes":25576,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2724,"convertSpendMs":15,"createdTime":"2021-04-26 02:10:54","host":"us-54*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"133.7 KB","destSize":"25 KB","compressRate":"18.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880776","sourceStatusCode":200,"destWidth":575,"destHeight":853,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn45@2020_5/2021/04/25/18-10-56-691_dae3c0cabd3583c7.webp","sourceBytes":185102,"destBytes":65844,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2763,"convertSpendMs":23,"createdTime":"2021-04-26 02:10:54","host":"us-028*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"180.8 KB","destSize":"64.3 KB","compressRate":"35.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880780","sourceStatusCode":200,"destWidth":558,"destHeight":301,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn33@2020_6/2021/04/25/18-10-56-603_559037c8248561ee.webp","sourceBytes":85431,"destBytes":26756,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2649,"convertSpendMs":10,"createdTime":"2021-04-26 02:10:54","host":"europe-24*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"83.4 KB","destSize":"26.1 KB","compressRate":"31.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880790","sourceStatusCode":200,"destWidth":889,"destHeight":501,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn87@2020_4/2021/04/25/18-10-56-787_7bffa19d6e64c38a.webp","sourceBytes":45062,"destBytes":13478,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2813,"convertSpendMs":16,"createdTime":"2021-04-26 02:10:54","host":"us-003*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"44 KB","destSize":"13.2 KB","compressRate":"29.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880775","sourceStatusCode":200,"destWidth":546,"destHeight":330,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn51@2020_5/2021/04/25/18-10-56-780_789d93ac2c460aab.webp","sourceBytes":65662,"destBytes":20632,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2868,"convertSpendMs":10,"createdTime":"2021-04-26 02:10:54","host":"us-003*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"64.1 KB","destSize":"20.1 KB","compressRate":"31.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880778","sourceStatusCode":200,"destWidth":476,"destHeight":308,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn38@2020_4/2021/04/25/18-10-56-640_6fa6cdda856858a8.webp","sourceBytes":62173,"destBytes":17126,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2766,"convertSpendMs":7,"createdTime":"2021-04-26 02:10:54","host":"europe62*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"60.7 KB","destSize":"16.7 KB","compressRate":"27.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880786","sourceStatusCode":200,"destWidth":601,"destHeight":435,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn13@2020_3/2021/04/25/18-10-56-503_be7a9f9cf614e125.webp","sourceBytes":127356,"destBytes":46758,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2785,"convertSpendMs":14,"createdTime":"2021-04-26 02:10:54","host":"europe70*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"124.4 KB","destSize":"45.7 KB","compressRate":"36.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039880793","sourceStatusCode":200,"destWidth":800,"destHeight":220,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn84@2020_4/2021/04/25/18-10-58-704_93e0ac205c24881d.webp","sourceBytes":164348,"destBytes":24524,"targetWebpQuality":75,"feedId":23280,"totalSpendMs":2754,"convertSpendMs":11,"createdTime":"2021-04-26 02:10:56","host":"us-002*","referer":"https://segmentfault.com/a/1190000039880772","linkMd5ListStr":"410f2bf61f9ab1a01b51cc8f96651598","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"160.5 KB","destSize":"23.9 KB","compressRate":"14.9%"}],"successGithubMap":{"myreaderx25":1,"myreaderx7":1,"myreaderx16":1,"myreaderx6":1,"myreaderx27":1,"myreaderx3":1,"myreaderx33":1,"myreaderx22":1,"myreaderx11":1,"myreaderx12":1,"myreaderx2":1,"myreaderx13":1,"myreaderx24":1,"myreaderx1":1,"myreaderx5oss":1,"myreaderx29":1,"myreaderx18":1,"myreaderx19":1},"failGithubMap":{"myreaderx14":1,"myreaderx23":1}}