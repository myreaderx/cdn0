{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-08-18 14:26:28","updatedTime":"2020-08-18 14:26:28","title":"rsync 复制文件的一些注意事项","link":"https://toutiao.io/k/qz4uqwp","description":"<div>\n <div>\n  <div itemprop=\"articleBody\" class=\"post-content\">\n   <h2>rsync介绍</h2>\n   <p><code>rsync</code> 是 Andrew Tridgell 和 Paul Mackerras 开发的远程同步文件工具，可以通过 LAN/WAN 快速在多台主机之间同步文件。<code>rsync</code> 使用智能算法有效计算源文件和目标文件的不同，实际传输时只传输差异部分，此外还可以使用压缩算法压缩数据，因此同步速度相当快。本站之前的文章 <a href=\"https://tlanyan.me/wordpress-backup-plans-and-script/\" target=\"_blank\" rel=\"noopener\">WordPress备份方案和备份脚本</a> 便是使用 <code>rsync</code> 跨机器备份程序文件和数据库。</p>\n   <p>尽管 <code>rsync</code> 比 <code>ftp</code>、<code>scp</code> 等工具更强大，传输效果更高，实际使用中仍有一些注意事项，本文分别做介绍。</p>\n   <h2>rsync复制文件的一些注意事项<code></code></h2>\n   <h3>安装rsync</h3>\n   <p>某些精简版的系统没有默认安装<code>rsync</code>，则需要手动安装：</p>\n   <pre>yum install -y rsync</pre>\n   <p>需要注意的是，同步的两台主机<strong>必须都安装</strong><code>rsync</code>才能正常工作，而不是常规思维认为的只在执行命令的主机上安装就好了。</p>\n   <h3>rsync常用参数</h3>\n   <p><code>rsync</code> 的基本语法是：</p>\n   <pre>rsync [option] src dest</pre>\n   <p>其中 <code>src</code> 和 <code>dest</code> 既可以是本机的文件或目录，也可以是远程主机的资源。</p>\n   <p>网络同步(备份)本来就是一个复杂的事情，因此rsync的选项参数非常多，新手通过man命令看到几页参数可能一脸懵逼，不知如何下手好。其实平常使用的参数主要是以下几个：</p>\n   <ul>\n    <li><code>-a</code>：归档模式，几乎是必用的参数，等同于<code>-rlptgoD</code></li>\n    <li><code>-v</code>：详细输出模式，比较常用，与之相反的参数是-q，表示不输出信息</li>\n    <li><code>-P</code>：保持传输时的文件部分，以便增量同步，同时输出传输进度，等同于<code>--partial --progress</code>。这个参数能看到每个文件的传输进度，推荐使用</li>\n    <li><code>-z</code>：压缩数据后再传输，在 <a href=\"https://tlanyan.me/1mbps-bandwith-vps/\" target=\"_blank\" rel=\"noopener\">1mbps带宽</a> 等小水管情形下比较有用</li>\n    <li><code>--exclude</code>：排除同步的文件，例如 <code>--exclude=.svn</code>。如果需要排除的文件比较多，可以写成文件然后用–exclude-from参数</li>\n    <li><code>--delete</code>：删除dest中有而src没有的文件，其变种是<code>--delete-before</code>和<code>--delete-after</code>，指定同步前删除还是同步完成后删除</li>\n    <li><code>--bwlimit</code>：限制最大同步带宽，单位是KB/s，1mbps是128KB/s。<a href=\"https://tlanyan.me/vps-merchant-collection/\" target=\"_blank\" rel=\"noopener\">一些vps商家整理</a> 介绍的个别国内商家，如果给的带宽是20m，超过这个带宽时间稍长就会中断数据传输一段时间，此时可以用这个参数避免断流。这个参数实际中很少用。</li>\n   </ul>\n   <p>绝大多数情形下，<code>-avP</code> 参数就足够，其他参数尽在需要时才指定。</p>\n   <p>更多参数请使用 <code>man rsync</code> 查看官方文档获取。</p>\n   <h3>rsync尾部斜杆</h3>\n   <p><code>rsync</code> 让许多人搞混，也是容易感到困惑的一个事情是：<code>src</code> 和 <code>dest</code> 结尾加斜杆有什么影响？例如以下几种情形，分别有什么不同？</p>\n   <pre>rsync -avP src dest\nrsync -avP src/ dest\nrsync -avP src dest/\nrsync -avP src/ dest/</pre>\n   <p>对<code>rsync</code>来说，有无尾部斜杆说起来区别挺大，其决定了目标文件的目录结构。如果你只在乎数据同步好，不在乎多一层文件夹，也不用太关心这个事。</p>\n   <p>具体来说，上面四种写法区别是：</p>\n   <ol>\n    <li>第一种写法：如果<code>src</code>是文件，则同步到名为<code>dest</code>的文件；如果<code>src</code>是目录(文件夹)，同步结束后<code>src</code>出现在<code>dest</code>文件夹内</li>\n    <li>第二种写法：将<code>src</code>中的文件同步到<code>dest</code>文件夹内</li>\n    <li>第三种写法：不管<code>src</code>是文件还是目录，同步到<code>dest</code>文件夹内</li>\n    <li>第四种写法：同第二种写法，将<code>src</code>中的文件同步到<code>dest</code>文件夹内</li>\n   </ol>\n   <p>总结便是：</p>\n   <ul>\n    <li><strong>dest后的斜杆仅在src为文件才有影响</strong>，有斜杆表示<code>dest</code>是目录</li>\n    <li><strong>src有无斜杆决定是将整个文件(夹)复制到dest中，还是将src中的文件复制到dest中</strong>。例如有文件夹a，<code>rsync -avP a b</code>，同步结束后a出现在文件夹b中(b不存在则创建)；如果是 <code>rsync -avP a/ b</code>，那么a中的文件会出现在文件夹b中，但b中没有a文件夹。</li>\n   </ul>\n   <p>此外还需要注意的是，加斜杆就可以了，不要加<code>*</code>，否则会导致<code>--delete</code>等参数不起作用。例如 <code>rsync -avP --delete a/* b</code>能将a中的文件同步到b中，但a中删除文件后，再运行这个命令不会删除b中的文件。</p>\n   <h3>远程主机使用非标准端口</h3>\n   <p><code>rsync</code> 默认通过 <code>ssh</code> 协议与远程主机进行通讯。如果远程主机<code>ssh</code>不是监听默认的22端口，那么需要额外设置。</p>\n   <blockquote>\n    <p>尽管rsync有-p和-P两个选项，但都不是用来指示远程主机的ssh端口</p>\n   </blockquote>\n   <p>一种方式是配置~/.ssh/config文件，指定远程ssh端口：</p>\n   <pre>Host 远程IP\n    Port 远程ssh端口</pre>\n   <p>另一种方法是使用-e选项：<code>rsync -avP -e\"ssh -p 远程ssh端口\" src dest</code>。</p>\n   <p>对于经常使用的主机。建议使用第一种方式，方便平时<a href=\"https://tlanyan.me/tag/ssh/\" target=\"_blank\" rel=\"noopener\">ssh</a>登录。</p>\n   <h2>参考</h2>\n   <ol>\n    <li><a href=\"https://coolshell.cn/articles/7425.html\" target=\"_blank\" rel=\"noopener\">rsync 的核心算法</a></li>\n    <li><a href=\"https://tlanyan.me/rsync-backup-files-to-localhost/\" target=\"_blank\" rel=\"noopener\">rsync同步和备份文件到本地</a></li>\n   </ol>\n   <p class=\"clear\"></p>\n  </div>\n </div>\n</div>","descriptionType":"html","feedId":540,"bgimg":"https://tlanyan.me/wp-content/uploads/2020/08/rsync.jpg?v=1597413433","linkMd5":"04c8c5ea545a20b4c250ef3084655ed6","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn62@2020_1/2020/08/18/06-27-02-804_ffb8fee81ff72fc5.webp","metaImg":"https://tlanyan.me/wp-content/uploads/2020/08/rsync.jpg?v=1597413433","author":"","publishedOrCreatedDate":1597731988164},{"createdTime":"2020-08-18 14:26:33","updatedTime":"2020-08-18 14:26:33","title":"LeetCode 题解","link":"https://toutiao.io/k/hjie8u4","description":"<div>\n <div>\n  <div class=\"rich_media_content \" id=\"js_content\"> \n   <p><span>大家好，我是周刊菌。</span></p>\n   <p><span>LeetCode 题解，用 Go 语言实现。面向想通过 LeetCode 提高算法能力的编程爱好者。</span></p>\n   <p><span>加入「码农周刊 VIP 会员」，精彩内容不再错过！</span></p>\n   <p><img class=\"rich_pages js_insertlocalimg\" data-cropselx1=\"0\" data-cropselx2=\"578\" data-cropsely1=\"0\" data-cropsely2=\"1000\" data-ratio=\"2.461333333333333\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/t8lpVibticjQ4RfttKExWXhvaUVdZVPcr5frd6tgqcGicf21CibstfzCicq3iaRfJUfHBnkaJpVDIZTjEhg1fQL3iccLw/640?wx_fmt=png\" data-type=\"png\" data-w=\"750\" /></p>\n   <p></p>\n   <p><span><strong><span>「码农周刊 VIP 会员」是什么？</span></strong></span></p>\n   <p><span><strong><span>简介版</span></strong></span></p>\n   <p><span>码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利</span></p>\n   <p></p>\n   <p><span><strong><span>详细版</span><br /></strong></span></p>\n   <p><span>点击「阅读原文」即可查看详细介绍</span></p>\n   <p></p>\n   <p><span><strong><span>加入「码农周刊 VIP 会员」，与上市公司 CTO 一起成长！<br /></span></strong></span></p>\n   <p><span>全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利，你值得拥有！</span></p>\n   <p><span><span><strong>原价&nbsp;365 元/年</strong></span><span><strong>，现价仅需 108 元！</strong></span></span></p>\n   <p><img class=\"rich_pages\" data-cropselx1=\"0\" data-cropselx2=\"260\" data-cropsely1=\"0\" data-cropsely2=\"350\" data-ratio=\"1.3478260869565217\" data-s=\"300,640\" data-type=\"jpeg\" data-w=\"690\" data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ55lkiaIfFtAvQ7oklJLhfYEwMXeZORosBgxxRzEaXjYiapBSev2CQfYfl7kTiaFqsoiaicGyvcKIHzcSg/640?wx_fmt=jpeg\" /></p> \n  </div> \n </div>\n</div>","descriptionType":"html","feedId":540,"bgimg":"http://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicXMHIsS5tjWtiagXyWQt91JcI1SGJuoefZx2lQfh5Iqr2FfTkJw44vRsxe7vYpibUcb3iaThKJdSibEA/0?wx_fmt=jpeg","linkMd5":"19ce409900f8e11fbd0e65dd4bae37c0","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx/cdn58@2020_4/2020/08/18/06-27-02-821_c317430848e4f3b7.webp","metaImg":"http://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicXMHIsS5tjWtiagXyWQt91JcI1SGJuoefZx2lQfh5Iqr2FfTkJw44vRsxe7vYpibUcb3iaThKJdSibEA/0?wx_fmt=jpeg","destWidth":360,"destHeight":360,"author":"","publishedOrCreatedDate":1597731993412},{"createdTime":"2020-08-18 14:26:25","updatedTime":"2020-08-18 14:26:25","title":".NET Core + Ocelot：API 网关","link":"https://toutiao.io/k/xxh3674","description":"<div> \n <div> \n  <div class=\"post-body\" itemprop=\"articleBody\"> \n   <p>关于 API 网关的作用，核心是 API 请求的收口及控制，如：鉴权、限流、熔断、数据缓存 等都是开发中常见的需求，将此类需求交给网关层处理，可以使每个微服务更聚焦于业务功能开发，同时也可为下游服务的安全及稳定性保驾护航。</p> \n   <p>在之前的文章 <a href=\"http://beckjin.com/2019/01/26/aspnet-zuul/\" target=\"_blank\" rel=\"noopener\">.NET Core + Spring Cloud：API 网关</a> 有介绍过如何基于 Spring Cloud 中的 Zuul 实现 API 网关，功能实现上抛开不提，另外一个较大的特点是 .NET Core 可以完美的拥抱 Java 体系中的部分能力。本文将主要介绍 .NET Core 体系中的 API 网关框架：<a href=\"https://github.com/ThreeMammals/Ocelot\" target=\"_blank\" rel=\"noopener\">Ocelot</a>，它包含了 路由、鉴权、限流、熔断、服务发现、请求聚合等非常丰富的功能，这些功能大多基于少量的配置实现，使用起来也并不复杂。</p> \n   <p>接下来通过简单例子先跑起来，然后再继续延伸更多特性的介绍，下面是 Ocelot 官方给出的一个最基础的架构图：</p> \n   <p><img src=\"https://toutiao.io/img/aspnet-ocelot/base.jpg\" alt=\"\" /></p> \n   <p>外网访问 Ocelot API 网关服务（单实例），通过配置的规则（<code>configuration.json</code>），路由到下游的两个微服务实例（<code>Http Service</code>），这也就是最基本的转发能力。</p> \n   <h3 id=\"路由转发\"><a href=\"https://toutiao.io/k/xxh3674#路由转发\" class=\"headerlink\" title=\"路由转发\"></a>路由转发</h3> \n   <p><em>以下创建的 .NET Core API 服务均基于 .NET Core 3.1</em></p> \n   <ol> \n    <li><p>创建微服务（ServiceA），并启动2个实例，两个实例使用的配置文件设置不同的 Id，方便后面接口调用识别不同实例。</p> \n     <figure class=\"highlight plain\"> \n      <table> \n       <tr> \n        <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /><span class=\"line\">5</span><br /><span class=\"line\">6</span><br /><span class=\"line\">7</span><br /><span class=\"line\">8</span><br /><span class=\"line\">9</span><br /><span class=\"line\">10</span><br /><span class=\"line\">11</span><br /><span class=\"line\">12</span><br /><span class=\"line\">13</span><br /><span class=\"line\">14</span><br /><span class=\"line\">15</span><br /><span class=\"line\">16</span><br /><span class=\"line\">17</span><br /></pre></td> \n        <td class=\"code\"><pre><span class=\"line\">[Route(\"[controller]/[action]\")]</span><br /><span class=\"line\">[ApiController]</span><br /><span class=\"line\">public class TestController : ControllerBase</span><br /><span class=\"line\">{</span><br /><span class=\"line\">  public readonly IConfiguration _configuration;</span><br /><span class=\"line\"></span><br /><span class=\"line\">  public TestController(IConfiguration configuration)</span><br /><span class=\"line\">  {</span><br /><span class=\"line\">    _configuration = configuration;</span><br /><span class=\"line\">  }</span><br /><span class=\"line\"></span><br /><span class=\"line\">  [HttpGet]</span><br /><span class=\"line\">  public string Get()</span><br /><span class=\"line\">  {</span><br /><span class=\"line\">    return $\"service-a {_configuration[\"Id\"]}\";</span><br /><span class=\"line\">  }</span><br /><span class=\"line\">}</span><br /></pre></td> \n       </tr> \n      </table> \n     </figure> </li> \n    <li><p>创建网关服务</p> \n     <ul> \n      <li>安装 <code>Ocelot</code> NuGet 包；</li> \n      <li><p>创建配置文件 <code>configuration.json</code>，内容如下：</p> <pre><code>\n         \n         <figure class=\"highlight plain\">\n          \n          <table>\n           \n           <tr>\n            \n            <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /><span class=\"line\">5</span><br /><span class=\"line\">6</span><br /><span class=\"line\">7</span><br /><span class=\"line\">8</span><br /><span class=\"line\">9</span><br /><span class=\"line\">10</span><br /><span class=\"line\">11</span><br /><span class=\"line\">12</span><br /><span class=\"line\">13</span><br /><span class=\"line\">14</span><br /><span class=\"line\">15</span><br /><span class=\"line\">16</span><br /><span class=\"line\">17</span><br /><span class=\"line\">18</span><br /><span class=\"line\">19</span><br /><span class=\"line\">20</span><br /><span class=\"line\">21</span><br /><span class=\"line\">22</span><br /><span class=\"line\">23</span><br /></pre></td>\n            \n            <td class=\"code\"><pre><span class=\"line\">{</span><br /><span class=\"line\">  \"Routes\": [   // 路由规则定义，数组</span><br /><span class=\"line\">    {</span><br /><span class=\"line\">      \"DownstreamPathTemplate\": \"/{url}\",   // 下游路径匹配模板</span><br /><span class=\"line\">      \"DownstreamScheme\": \"http\", </span><br /><span class=\"line\">      \"DownstreamHostAndPorts\": [           // 下游服务的 host 和 port 设置，支持多实例</span><br /><span class=\"line\">        {</span><br /><span class=\"line\">          \"Host\": \"192.168.124.11\",</span><br /><span class=\"line\">          \"Port\": 8000</span><br /><span class=\"line\">        },</span><br /><span class=\"line\">        {</span><br /><span class=\"line\">          \"Host\": \"192.168.124.11\",</span><br /><span class=\"line\">          \"Port\": 8001</span><br /><span class=\"line\">        }</span><br /><span class=\"line\">      ],</span><br /><span class=\"line\">      \"UpstreamPathTemplate\": \"/servicea/{url}\",  //  客户端访问地址路径匹配模板</span><br /><span class=\"line\">      \"UpstreamHttpMethod\": [ \"Get\" ],            // 支持的 HttpMethod ，如：Get、Post、Put、Delete 等</span><br /><span class=\"line\">      \"LoadBalancerOptions\": {                    // 多实例下负载均衡方式，支持：LeastConnection（最闲）、RoundRobin（轮询）、NoLoadBalance</span><br /><span class=\"line\">        \"Type\": \"RoundRobin\"</span><br /><span class=\"line\">      }</span><br /><span class=\"line\">    }</span><br /><span class=\"line\">  ]</span><br /><span class=\"line\">}</span><br /></pre></td>\n           \n           </tr>\n          \n          </table>\n         \n         </figure>\n</code></pre> \n       <ul> \n        <li>在 <code>Program.cs</code> 中添加 Ocelot 配置文件引用： \n         <figure class=\"highlight plain\"> \n          <table> \n           <tr> \n            <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /><span class=\"line\">5</span><br /><span class=\"line\">6</span><br /><span class=\"line\">7</span><br /><span class=\"line\">8</span><br /><span class=\"line\">9</span><br /><span class=\"line\">10</span><br /><span class=\"line\">11</span><br /></pre></td> \n            <td class=\"code\"><pre><span class=\"line\">public static IHostBuilder CreateHostBuilder(string[] args) =&gt;</span><br /><span class=\"line\">  Host.CreateDefaultBuilder(args)</span><br /><span class=\"line\">    .ConfigureWebHostDefaults(webBuilder =&gt;</span><br /><span class=\"line\">    {</span><br /><span class=\"line\">      webBuilder.UseStartup&lt;Startup&gt;();</span><br /><span class=\"line\">      webBuilder.UseUrls(\"http://*:9600\");</span><br /><span class=\"line\">      webBuilder.ConfigureAppConfiguration(c =&gt;</span><br /><span class=\"line\">      {</span><br /><span class=\"line\">        c.AddJsonFile(\"configuration.json\");</span><br /><span class=\"line\">      });</span><br /><span class=\"line\">    });</span><br /></pre></td> \n           </tr> \n          </table> \n         </figure> </li> \n       </ul> \n       <ul> \n        <li>在 <code>Startup.cs</code> 中注册服务与管道配置： \n         <figure class=\"highlight plain\"> \n          <table> \n           <tr> \n            <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /><span class=\"line\">5</span><br /><span class=\"line\">6</span><br /><span class=\"line\">7</span><br /><span class=\"line\">8</span><br /><span class=\"line\">9</span><br /><span class=\"line\">10</span><br /><span class=\"line\">11</span><br /><span class=\"line\">12</span><br /><span class=\"line\">13</span><br /><span class=\"line\">14</span><br /><span class=\"line\">15</span><br /><span class=\"line\">16</span><br /><span class=\"line\">17</span><br /><span class=\"line\">18</span><br /></pre></td> \n            <td class=\"code\"><pre><span class=\"line\">public void ConfigureServices(IServiceCollection services)</span><br /><span class=\"line\">{</span><br /><span class=\"line\">  services.AddControllers();</span><br /><span class=\"line\">  services.AddOcelot();</span><br /><span class=\"line\">}</span><br /><span class=\"line\"></span><br /><span class=\"line\">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)</span><br /><span class=\"line\">{</span><br /><span class=\"line\">  // ....</span><br /><span class=\"line\">  </span><br /><span class=\"line\">  app.UseOcelot().Wait();</span><br /><span class=\"line\"></span><br /><span class=\"line\">  app.UseRouting();</span><br /><span class=\"line\">  app.UseEndpoints(endpoints =&gt;</span><br /><span class=\"line\">  {</span><br /><span class=\"line\">    endpoints.MapControllers();</span><br /><span class=\"line\">  });</span><br /><span class=\"line\">}</span><br /></pre></td> \n           </tr> \n          </table> \n         </figure> </li> \n       </ul> </li> \n     </ul> </li> \n    <li><p>网关层接口调用测试<br /> 通过以上服务搭建，就完成了路由转发的功能，即当访问 <code>/servicea/{任意路由地址}</code> 都将自动转发到下游任意一个服务实例中相匹配的路由地址，网关服务访问地址为：<code>http://192.168.124.11:9600</code>（<code>192.168.124.11</code> 是本机的 IPV4 地址），测试效果如下（下游服务实例被轮询访问）：</p> </li> \n   </ol> \n   <p><img src=\"https://toutiao.io/img/aspnet-ocelot/roundRobin.png\" alt=\"\" /></p> \n   <h3 id=\"服务发现（Consul）\"><a href=\"https://toutiao.io/k/xxh3674#服务发现（Consul）\" class=\"headerlink\" title=\"服务发现（Consul）\"></a>服务发现（Consul）</h3> \n   <p>Ocelot 支持与具备 <a href=\"https://ocelot.readthedocs.io/en/latest/features/servicediscovery.html\" target=\"_blank\" rel=\"noopener\">服务发现</a> 功能的一些框架相结合，如：<code>Consul</code>、<code>Eureka</code>，下游服务地址可直接从服务注册中心进行获取。接下来将结合 Consul 进行测试，有关 Consul 与 .NET Core 结合请参考文章：<a href=\"http://beckjin.com/2019/05/18/aspnet-consul-discovery/\" target=\"_blank\" rel=\"noopener\">.NET Core + Consul 服务注册与发现</a>，这部分内容这里就不重复介绍了，最终注册中心 <code>service-a</code> 有两个实例，如下：</p> \n   <p><img src=\"https://toutiao.io/img/aspnet-ocelot/consul.png\" alt=\"\" /></p> \n   <ol> \n    <li><p>安装 <code>Ocelot.Provider.Consul</code> NuGet 包；</p> </li> \n    <li><p><code>Startup.cs</code> 中进行服务注册：</p> \n     <figure class=\"highlight plain\"> \n      <table> \n       <tr> \n        <td class=\"gutter\"><pre><span class=\"line\">1</span><br /></pre></td> \n        <td class=\"code\"><pre><span class=\"line\">services.AddOcelot().AddConsul();</span><br /></pre></td> \n       </tr> \n      </table> \n     </figure> </li> \n    <li><p><code>configuration.json</code> 配置修改为如下：</p> \n     <figure class=\"highlight plain\"> \n      <table> \n       <tr> \n        <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /><span class=\"line\">5</span><br /><span class=\"line\">6</span><br /><span class=\"line\">7</span><br /><span class=\"line\">8</span><br /><span class=\"line\">9</span><br /><span class=\"line\">10</span><br /><span class=\"line\">11</span><br /><span class=\"line\">12</span><br /><span class=\"line\">13</span><br /><span class=\"line\">14</span><br /><span class=\"line\">15</span><br /><span class=\"line\">16</span><br /><span class=\"line\">17</span><br /><span class=\"line\">18</span><br /><span class=\"line\">19</span><br /><span class=\"line\">20</span><br /><span class=\"line\">21</span><br /><span class=\"line\">22</span><br /></pre></td> \n        <td class=\"code\"><pre><span class=\"line\">{</span><br /><span class=\"line\">  \"GlobalConfiguration\": {</span><br /><span class=\"line\">    \"ServiceDiscoveryProvider\": {  // 提供服务发现的 Provider</span><br /><span class=\"line\">      \"Scheme\": \"http\",</span><br /><span class=\"line\">      \"Host\": \"192.168.124.9\",     // Consul 服务 host</span><br /><span class=\"line\">      \"Port\": 8500,                // Consul 服务端口</span><br /><span class=\"line\">      \"Type\": \"Consul\"             // 类型</span><br /><span class=\"line\">    }</span><br /><span class=\"line\">  },</span><br /><span class=\"line\">  \"Routes\": [</span><br /><span class=\"line\">    {</span><br /><span class=\"line\">      \"DownstreamPathTemplate\": \"/{url}\",</span><br /><span class=\"line\">      \"DownstreamScheme\": \"http\",</span><br /><span class=\"line\">      \"ServiceName\": \"service-a\",  // 注册的服务名</span><br /><span class=\"line\">      \"UpstreamPathTemplate\": \"/servicea/{url}\",</span><br /><span class=\"line\">      \"UpstreamHttpMethod\": [ \"Get\" ],</span><br /><span class=\"line\">      \"LoadBalancerOptions\": {</span><br /><span class=\"line\">        \"Type\": \"RoundRobin\"</span><br /><span class=\"line\">      }</span><br /><span class=\"line\">    }</span><br /><span class=\"line\">  ]</span><br /><span class=\"line\">}</span><br /></pre></td> \n       </tr> \n      </table> \n     </figure> </li> \n   </ol> \n   <p>最终测试结果与上一部分一致，所以 Ocelot 完全可以与服务注册发现相结合应用到项目中。</p> \n   <h3 id=\"限流\"><a href=\"https://toutiao.io/k/xxh3674#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3> \n   <p>为了可以防止因请求过载而引起服务不稳定，可为路由规则添加相应的限流配置，如下：<br /> \n    <figure class=\"highlight plain\"> \n     <table> \n      <tr> \n       <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /><span class=\"line\">5</span><br /><span class=\"line\">6</span><br /><span class=\"line\">7</span><br /></pre></td> \n       <td class=\"code\"><pre><span class=\"line\">\"RateLimitOptions\": {</span><br /><span class=\"line\">  \"ClientWhitelist\": [ \"clientId1\" ],</span><br /><span class=\"line\">  \"EnableRateLimiting\": true, </span><br /><span class=\"line\">  \"Period\": \"5s\", </span><br /><span class=\"line\">  \"PeriodTimespan\": 5,</span><br /><span class=\"line\">  \"Limit\": 5  // 测试设置比较小</span><br /><span class=\"line\">}</span><br /></pre></td> \n      </tr> \n     </table> \n    </figure></p> \n   <p><strong>ClientWhitelist</strong>：限流白名单。如上，当请求头中包含 ClientId=clientId1 的请求则不受限流规则控制（<em>ClientId key 名可修改</em>）<br /><strong>EnableRateLimiting</strong>：开启限流<br /><strong>Period</strong>：限流控制时间段，也就是多长时间内。支持 s（秒）、m（分）、h（小时）、d（天）<br /><strong>PeriodTimespan</strong>：超过限制次数后，需要等待的时长（秒）<br /><strong>Limit</strong>：在 Period 时长内最大访问次数</p> \n   <p>当超出限流数量时，默认返回如下：</p> \n   <p><img src=\"https://toutiao.io/img/aspnet-ocelot/rateLimit.png\" alt=\"\" /></p> \n   <p><em>如果需要修改返回值及状态码等可以通过修改 <code>GlobalConfiguration</code> 配置中的 <code>RateLimitOptions</code> 参数。</em></p> \n   <h3 id=\"熔断\"><a href=\"https://toutiao.io/k/xxh3674#熔断\" class=\"headerlink\" title=\"熔断\"></a>熔断</h3> \n   <p>熔断是结合 Polly 实现的，在使用之前需要先安装 <code>Ocelot.Provider.Polly</code> NuGet 包，然后添加服务注册，如下：<br /> \n    <figure class=\"highlight plain\"> \n     <table> \n      <tr> \n       <td class=\"gutter\"><pre><span class=\"line\">1</span><br /></pre></td> \n       <td class=\"code\"><pre><span class=\"line\">services.AddOcelot() .AddConsul().AddPolly();</span><br /></pre></td> \n      </tr> \n     </table> \n    </figure></p> \n   <p>路由规则中增加如下配置：</p> \n   <figure class=\"highlight plain\"> \n    <table> \n     <tr> \n      <td class=\"gutter\"><pre><span class=\"line\">1</span><br /><span class=\"line\">2</span><br /><span class=\"line\">3</span><br /><span class=\"line\">4</span><br /><span class=\"line\">5</span><br /></pre></td> \n      <td class=\"code\"><pre><span class=\"line\">\"QoSOptions\": { </span><br /><span class=\"line\">  \"ExceptionsAllowedBeforeBreaking\": 3,</span><br /><span class=\"line\">  \"DurationOfBreak\": 5000,</span><br /><span class=\"line\">  \"TimeoutValue\": 3000</span><br /><span class=\"line\">}</span><br /></pre></td> \n     </tr> \n    </table> \n   </figure> \n   <p><strong>ExceptionsAllowedBeforeBreaking</strong>：允许连续发生异常次数<br /><strong>DurationOfBreak</strong>：熔断时长（ms）<br /><strong>TimeoutValue</strong>：请求超时时间（ms）</p> \n   <p>当超出允许异常次数时，接口 5s 内都会返回 503：</p> \n   <p><img src=\"https://toutiao.io/img/aspnet-ocelot/qos.png\" alt=\"\" /></p> \n   <h3 id=\"网关高可用\"><a href=\"https://toutiao.io/k/xxh3674#网关高可用\" class=\"headerlink\" title=\"网关高可用\"></a>网关高可用</h3> \n   <p>API 网关是所有请求的唯一入口，压力自然是比较大的，自身的高可用也很关键，所以网关服务在部署上必须多实例，网关上层还需要添加一层 LB，官方架构图如下：</p> \n   <p><img src=\"https://toutiao.io/img/aspnet-ocelot/lb.jpg\" alt=\"\" /></p> \n   <p>Ocelot 整体主要围绕配置进行功能扩充，本文只介绍了部分 Ocelot 的功能，另外还有 鉴权、缓存、请求合并、与 Kubernetes 结合等都是非常普遍的功能。</p> \n  </div> \n </div> \n</div>","descriptionType":"html","feedId":540,"bgimg":"https://toutiao.io/img/aspnet-ocelot/base.jpg","linkMd5":"b297de6354133cc17fb1d51ba9ee8b66","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","author":"","articleImgCdnMap":{"https://toutiao.io/img/aspnet-ocelot/base.jpg":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","https://toutiao.io/img/aspnet-ocelot/roundRobin.png":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","https://toutiao.io/img/aspnet-ocelot/consul.png":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","https://toutiao.io/img/aspnet-ocelot/rateLimit.png":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","https://toutiao.io/img/aspnet-ocelot/qos.png":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","https://toutiao.io/img/aspnet-ocelot/lb.jpg":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg"},"publishedOrCreatedDate":1597731985123},{"createdTime":"2020-08-18 14:26:25","updatedTime":"2020-08-18 14:26:25","title":"从 0 到 1 搭建业务中台","link":"https://toutiao.io/k/fonb2xz","description":"<div>\n <div>\n  <div class=\"RichText ztext Post-RichText\">\n   <h3>背景</h3>\n   <p>​ 像平凡的大多数一样，大部分的时间还是做着 CRUD 的需求，使用 ECharts 搭建各种图表看板。直到产品给我们提出了一个这样的需求，前端通过不同的筛选方式选定一种规则，后端解析这些规则并通过大数据跑数筛选出符合规则的目标对象并且生成对象 id 给后续使用。</p>\n   <p>​ 一开始这个需求并不是定位于中台开发，产品只是作为一个常规需求提给我们。深入了解业务需求以后我们发现这个需求不仅在我们的项目中要使用，在另外一个项目中也要使用，并且不同的项目中表现的形式不一致，筛选的对象在最初的需求中只是针对到商户。稍微整理一下我们发现这个需求具有 <b>跨项目</b> <b>可配置</b> <b>可扩展</b> 这些特点。所以大胆的提出采用组件化开发，以中台的形式完成这个需求。</p>\n   <p> 在业务中台搭建之前，数据部门只能提供标记了各种指标的商户数据。业务部门需要找到符合标记的商户需要自行搭建筛选页面与筛选的后端逻辑。时常会出现不同业务部门之间筛选逻辑不一致，目标商户圈选数量不同。并且新增加一个接入方以后，对应的前端团队有需要完全重写一套筛选页面。</p>\n   <p> 业务中台搭建之后，由大数据平台统一收口圈选能力，对外暴露出前端的筛选组件。各业务部门能获得一致的筛选逻辑、界面，最终生成圈选对象 id 用于后续消费</p>\n   <p>​ 目前这个业务中台已经累计接入 10+ 个项目，同时也帮助孵化了一个作为消费者的下游中台。接入方只需要添加自身的数据源，管理台进行相关配置，前端引入 SDK 输入参数便能生成圈选对象再自行消费。完全不用感知中间圈选的逻辑。大大减少了前端的开发时间。接下来将介绍作为一个中台应用，前端开发中踩过的坑。</p>\n   <h3>架构介绍</h3>\n   <figure data-size=\"normal\">\n    <noscript>\n     <img src=\"https://pic4.zhimg.com/v2-c8d40cbe8dfc37b5fcdddb3e1bb368f6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"675\" class=\"origin_image zh-lightbox-thumb\" data-original=\"https://pic4.zhimg.com/v2-c8d40cbe8dfc37b5fcdddb3e1bb368f6_r.jpg\" />\n    </noscript>\n    <img src=\"\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"675\" class=\"origin_image zh-lightbox-thumb lazy\" data-original=\"https://pic4.zhimg.com/v2-c8d40cbe8dfc37b5fcdddb3e1bb368f6_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c8d40cbe8dfc37b5fcdddb3e1bb368f6_b.jpg\" />\n   </figure>\n   <p>​ 最终产物</p>\n   <p> 作为一个中台应用必然要考虑嵌入在各个项目中，在通过 iframe 页面嵌入到项目中，以及通过打包成 npm 包由接入方各自引入两种方案中我们选择了后者。因为虽然 iframe 的方式方便发布升级，以及天然的作用域隔离，但是 iframe 本身接入方操作内部状态，消息同步，调试等成本过高。最后选择了 npm 包方案。这样接入方能够方便的通过组件对外暴露的属性调用组件的方法，并且也能直接修改组件的样式，和接入方本身的主题颜色保持一致。</p>\n   <h3>组件参数设置</h3>\n   <p>​ 整个中台通过一个 npm 包发布到内网，并且严格遵守 X.Y.Z 语义化。各个接入方在接入组件后通过 lock 文件锁定后，即使我们发布了升级也不会影响原有项目的稳定性。当涉及到 X 版本 breakchange 变更时，通过业务群同步接入方升级。因为在内网发布 npm 包后自动会同步到 cdn 中。未来我们希望通过接入 serverless。各个接入方的组件接入方式通过 script 脚本引入，由我们统一进行版本控制。这样接入方就不需要感知组件的升级状态。</p>\n   <p>​ 在组件变量的设置中，我们暴露了通用的设置方法</p>\n   <div class=\"highlight\">\n    <pre><code class=\"language-text\">export namespace StrategyCenter {\n    config(options: ConfigProps):void\n    primaryColor(color: string):void\n}</code></pre>\n   </div>\n   <p>通过全局参数设置可以指定组件使用的 鉴权方式，环境变量，筛选模式，主题颜色等参数。部分接入方只使用单一筛选方式，因此只需要一次性设置参数即可。而有的接入方可能在一个项目中使用不同的筛选模式，针对这种情况我们允许在组件中设置变量，并且遵循</p>\n   <p><code>接口参数 &gt; 组件参数 &gt; 全局变量</code> 的优先级。</p>\n   <h3>不同筛选模式切换</h3>\n   <p>在针对不同接入方筛选模式不同的需求时，一开始我们采用了 <code>维度 A * 维度B = 筛选模式</code> 这种笛卡尔乘积的配置模式，但是随着接入方越来越多，并且存在筛选模式相同但是背后对应的数据集不同的情况。最终我们改成了每一个接入方都使用一个唯一的 dataSet 作为标识符，标识符对应了接入方需要的数据源以及对应的筛选模式。开始由后端维护在代码中，后期接入了中台管理台以后可以直接由产品进行配置。减少了开发到最后和产品需求对不上的情况(都是产品自己配的)</p>\n   <h3>接口交互</h3>\n   <p>​ 完成了前期的基础配置后，再回过头来看看组件核心。中台的意义在于减少接入方的使用成本，封装复杂的具有领域特色的逻辑。因此把复杂的视图交互层都封装了组件中，由组件直接和后端的中台服务进行交互。中间复杂的接口签名接入方无需感知，全部由组件封装完毕。后端的中台服务只暴露出部分的查询服务供接入方的后端进行调用。</p>\n   <p>​ 在集团内部前端框架统一的情况下，组件采用统一的框架方便接入方使用。通过 webpack 加上 typescript 打包成 npm 包以后，组件本身会暴露出类型声明文件，在涉及到对外暴露的接口时我们也要求在接口类型声明上加上注释，以及枚举值声明。这样接入方在引入包时可以获得尽量友好的开发体验。</p>\n   <p>​ 考虑到部分老旧平台存在不同的技术栈以及可能存在接入方只是想使用查询部分参数，因此我们把和后端的交互统一封装了一个 service 层，类似微信的 jssdk。所有和后端的交互都通过 service 层进行。好处在于部分接口可以在不同的组件中重复使用，并且发生参数修改时也能在同一个地方进行修改。不同的技术栈也可以自行构建合适的筛选参数再通过调入 service 层也能完成圈选对象的生成。</p>\n   <h3>内部模块</h3>\n   <p>​ 组件的核心在于其中的筛选模块，这一块就是整个策略中台视图交互逻辑层，并且具有很强的领域特色。圈选对象的生成是通过用户在不同的筛选模块中进行交互，筛选出符合要求的具体业务对象。筛选的模块涉及到时间、区域、指标、维度等等不同模块。并且还要求进行状态的回显、数据绑定等。此处参考了 antd 的 form 表单设计思想，把每一个模块抽象为一个筛选基类，对外暴露了统一的方法</p>\n   <div class=\"highlight\">\n    <pre><code class=\"language-text\">interface BaseFilter {\n  setForm(params: FormParams)\n  getForm(): FormParams\n  onChange&lt;T&gt;(filed: string, filerValue: T)\n}</code></pre>\n   </div>\n   <p>外部的容器初始化或者进行表单回显时依次调用各个模块的 setForm 方法，传入外层的表单参数，筛选模块内部自行响应表单参数并且完成内部状态的设置；用户在进行界面交互时，又会触发筛选模块的 onChange 事件把状态同步到外部容器，此时其它对此模块由依赖的组件响应 onChange 事件完成更新。最后外部容器调用 getFiledsValue 方法时依次收集各个模块的 getForm 方法得到表单值并且完成表单校验。</p>\n   <p>​ 这里虽然我们把筛选模块定义为了一个基类，但是代码中并不是使用 extends 的方式进行继承。只是通过暴露出了对应的方法让外部组件进行调用。面向接口编程只是一种思想，并不是强制的按照某种设计模式进行代码的编写。</p>\n   <p>​ 除了筛选组件以外，还有目标设置以及效果复盘组件，这是基于大数据部门的特点提供了完整的数据分析组件。完成业务上的闭环，在打包的时候进行分组件进行打包，接入方按需引用。未来的方向也是在维护已有筛选模块数据源的同时，继续拓展出更多的效果复盘类组件。继续挖掘大数据背后的价值。</p>\n   <h3>后端和权限</h3>\n   <p>​ 目前我们的涉及到的项目几乎以及后端接口都在 <a href=\"https://link.zhihu.com/?target=http%3A//a.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">a.com</span><span class=\"invisible\"></span></a> 域名下。通过 SSO 中心设置的 cookie 后端能直接读取到用户的权限的信息。因此组件本身没有进行权限相关的控制，未来可能涉及到不同域名下的项目，因此可以通过在参数中接入方设置鉴权方式以及传入 token 的形式让后端进行权限校验</p>\n   <h3>中台管理台</h3>\n   <p>​ 中台管理台包含了 标签配置、组件文档、组件预览、组件配置表等四个模块。中台本身和 npm 包在一个仓库，发布时 npm 包和中台分别进行打包发布。</p>\n   <p>​ 组件的文档完善与否直接决定了组件的接入成本，前期通过 typescript 打包已经有了接口类型声明文件，文档中介绍了完整的组件接入流程以及对应的产品、前端、测试、后端等同学的联系方式。结尾还制作了 QA 列表列举了组件使用中常见的问题。文档约细致就能减少作为开发者被钉钉中断的痛苦</p>\n   <p>​ 组件预览中参考 elementUI 的文档，列举了组件的使用方式以及当前的效果，开发者可以直接在测试环境验证各个模块的使用方式</p>\n   <p>​ 标签配置中列举了筛选模块中的数据源，在没有管理台之前这些配置全部由产品提出 PRD，后端写死在代码中。增加新的数据集耗费时间成本，并且常常出现指标的口径错误。增加配置台以后相关的标签全部进行了建模处理，产品负责新增标签相关的属性。前端直接通过配置调取相关的资源。目前这种模式也被推广到了其它项目中，产品配置标签属性，前端已经完成了相关组件的渲染逻辑。极大的减少了开发新页面的成本。</p>\n   <p>​ 配置表中列举了不同数据集 dataSet 对应的筛选模块配置。前端通过读取模块配置渲染筛选组件，减少了由前端同学维护筛选模块可能带来的配置错误等问题。</p>\n   <h3>总结</h3>\n   <p>​ 许多同学可能觉得平时工作的需求无非就是改改页面没有太大的业务价值，我认为一个好的工程师善于把重复枯燥的逻辑抽象出来进而提升整个需求的开发效率。去抽象需求的一个重要前提就是深刻的了解业务，找到业务的痛点，并且找到不同业务中的共同点。在这个策略中台的开发中，我们就是找准了业务的共同点——利用平台大数据的能力精准的圈选出目标对象。这个是业务的核心诉求，接着再通过区分不同业务的差异性完成不同的筛选模块，这个过程中，面对也就不再是写页面等初级开发，而是更有挑战性的思考如何在保持统一性、可维护性的同时又能应对不同的业务需求，这也是对个人架构能力的提升。</p>\n   <p>​ 另一方面，前端社区一直推崇微前端方案。但是目前看到的微前端方案还是基于整个路由级的改动，并且要求接入方对自己的代码有一定的改动。我认为，在公司内部框架统一的情况下，完全可以采用这种 npm 包形式的“微前端“方案，比如策略中台中的效果复盘组件。组件中包含了完整和后端交互的逻辑，接入方不用感知，只需要输入参数便可完成页面的渲染。保证了数据、样式的准确性又能极大的减少前端重复开发页面的时间成本。以上只是个人关于 “微前端” 方案的一点思考，希望能和同学们在评论中探讨。</p>\n  </div>\n </div>\n</div>","descriptionType":"html","feedId":540,"bgimg":"https://pic4.zhimg.com/v2-c8d40cbe8dfc37b5fcdddb3e1bb368f6_b.jpg","linkMd5":"9b6fa9672bc2efb1ef061c84601064f9","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn51@2020_3/2020/08/18/06-26-58-199_ad6a99516ec8c8c9.webp","destWidth":720,"destHeight":405,"author":"","articleImgCdnMap":{"https://pic4.zhimg.com/v2-c8d40cbe8dfc37b5fcdddb3e1bb368f6_b.jpg":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn51@2020_3/2020/08/18/06-26-58-199_ad6a99516ec8c8c9.webp"},"publishedOrCreatedDate":1597731985123},{"createdTime":"2020-08-18 14:26:30","updatedTime":"2020-08-18 14:26:30","title":"微信小游戏背后的技术优化","link":"https://toutiao.io/k/lhyjn91","description":"<div>\n <div>\n  <section data-tool=\"mdnice编辑器\" data-website=\"https://www.mdnice.com\">\n   <h2 data-tool=\"mdnice编辑器\"><span></span></h2>\n   <p><img class=\"rich_pages\" data-ratio=\"0.1575\" data-src=\"https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif\" data-type=\"gif\" data-w=\"400\" /></p>\n   <p data-tool=\"mdnice编辑器\"></p>\n   <p data-tool=\"mdnice编辑器\"><span>作者：chrongzhang，腾讯 WXG 客户端开发工程师</span></p>\n   <blockquote data-tool=\"mdnice编辑器\">\n    <p>这是一篇介绍微信小游戏客户端底层，如果进行优化，可以让所有小游戏获得更好性能的文章。不是你想像的怎么优化某个小游戏的文章。来都来了，就了解一下吧:)</p>\n   </blockquote>\n   <p data-tool=\"mdnice编辑器\">小游戏主要分为渲染和逻辑两部分。渲染优化能让渲染相关的指令（WebGL/GFX）得到更高效的执行，逻辑优化是让除渲染之外的代码也能更高效的执行，本篇主要讲述逻辑相关的优化。</p>\n   <h3 data-tool=\"mdnice编辑器\"><span></span><span>基础功能优化</span><span></span></h3>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>V8</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">微信小游戏是在 2017 年 12 月 28 日上线的，当时微信安卓客户端使用的 V8 版本还是 5.5。而 Google 在 V8 上的迭代速度是很快的，其中一个大的版本变更是从 5.9 版本开始，编译器由原来的 FullCodeGenerator + Crankshaft 变更成更加高效的 Ignition + TurboFan。</p>\n   <figure data-tool=\"mdnice编辑器\">\n    <img data-ratio=\"0.3660161827701095\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvauvfZCNVQ6v27ofN9lovyXLa6e0vO895LzWTaVPTBY4PHfgyII4S4dHtend3tJkoq7t2jKExh2XBg/640?wx_fmt=png\" data-type=\"png\" data-w=\"2101\" />\n    <figcaption>\n     mark\n    </figcaption>\n   </figure>\n   <p data-tool=\"mdnice编辑器\">V8 引擎之所以性能高，在于其出色的 JIT 执行效率。JIT 依赖了一个可以在运行时优化代码的动态编译器。V8 早期的 JIT 编译器是 FullCodegen，后来是 Crankshaft，然后是一直沿用至今的 Turbofan。</p>\n   <p data-tool=\"mdnice编辑器\">升级 V8，可以获得更高的执行性能（TurboFan）、更快的启动速度（Snapshot + Code Caching）、更低的内存占用（64 位压缩指针）。小游戏上线至今，客户端使用的 V8 也一直在升级当中，从最初的 5.5，升级到 6.6，然后是 7.6，直到目前的 8.0。</p>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>JSBinding</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">微信小游戏对开发者暴露的是 JS 的接口，开发者调用某些 JS 函数时，最终会调用到客户端底层的原生能力。而从 JS 到客户端底层之间的桥接能力，就是所谓的 JS 绑定。JS 绑定又分为两种：裸绑定和非裸绑定。裸绑定是通过 V8/JavaScriptCore 提供的原生接口，将某个 JS 函数和原生函数实现绑定到一起，这是最直接，也是最高效的绑定方式。</p>\n   <p data-tool=\"mdnice编辑器\">非裸绑定是指通过某个 JS 和原生的通信的桥梁（evaluate/prompt/postMessage 等等），在此基础上再封装和转发具体的函数调用。由于存在中间一层的转发处理，会有额外的消耗。因此小游戏对外提供的 WebGL 等接口的实现，都采用了裸绑定的方式。直接用原生裸绑定的 API，又会存在以下问题：</p>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      原生 API 使用较复杂\n     </section></li>\n    <li>\n     <section>\n      不方便实现更高层次的类绑定\n     </section></li>\n    <li>\n     <section>\n      V8 和 JavaScriptCore 的 API 差异很大，两个平台需要重复实现绑定\n     </section></li>\n   </ol>\n   <p data-tool=\"mdnice编辑器\">于是，我们实现了一套通用的绑定库: <code>jsbinding</code>，公司内是开源的，未来计划对外也开源。</p>\n   <p data-tool=\"mdnice编辑器\">具有如下特点：</p>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      简单易用，支持类绑定\n     </section></li>\n    <li>\n     <section>\n      裸绑定，性能高\n     </section></li>\n    <li>\n     <section>\n      同时支持 V8 和 JavaScriptCore\n     </section></li>\n    <li>\n     <section>\n      支持 node addon 绑定实现\n     </section></li>\n   </ol>\n   <p data-tool=\"mdnice编辑器\">未来甚至计划提供 WebAssembly 的绑定实现，是不是还有点小期待呢？</p>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>NodeJs/libuv</span><span></span></h4>\n   <p data-tool=\"mdnice编辑器\">安卓客户端已经全面拥抱 node。集成 node runtime 后，拥有了如下能力：</p>\n   <ol data-tool=\"mdnice编辑器\" class=\"list-paddingleft-2\">\n    <li>\n     <section>\n      node 内置能力（如文件、setTimeout 等）\n     </section></li>\n    <li>\n     <section>\n      libuv 异步 IO 处理的能力\n     </section></li>\n   </ol>\n   <p data-tool=\"mdnice编辑器\">node 很多内置能力，是通过原生来实现的（node addon），属于裸绑定，性能较高。有了 libuv 事件驱动后，可以更加灵活和高效的处理一些异步事件。比如 WebSocket 的回调，之前的处理流程是，在子线程收到 socket 消息后，将消息内容通过 JNI 调用到 Java 层，Java 层再抛到 JS 线程（也是 JVM 线程），回调到 JS。而如果使用 libuv，可以在子线程通过 uv_async_send 封装的 ASyncCall 机制，在底层就直接抛到 JS 线程回调到 JS，避免了中间频繁的 JNI 调用和数据传输的开销。</p>\n   <h3 data-tool=\"mdnice编辑器\"><span></span><span>调用链路优化</span><span></span></h3>\n   <p data-tool=\"mdnice编辑器\">我们都知道，两点之间，直线最短。代码也是一样，调用链路越短，越直接，中间的开销就越小。</p>\n   <h4 data-tool=\"mdnice编辑器\"><span></span><span>JsApi 优化</span><span></span></h4>\n   <h5 data-tool=\"mdnice编辑器\"><span></span><span>1. JsApi 调用优化</span><span></span></h5>\n   <p data-tool=\"mdnice编辑器\">首先来看看之前 JsApi 的调用链路：</p>\n   <figure data-tool=\"mdnice编辑器\">\n    <img data-ratio=\"0.5139165009940357\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvauvfZCNVQ6v27ofN9lovyXLOk7F8CCU6x2aoJEXcQ4ejic0vKsFZqpSUNUvyaMawIhZhalphPqpAwQ/640?wx_fmt=png\" data-type=\"png\" data-w=\"2012\" />\n    <figcaption>\n     mark\n    </figcaption>\n   </figure>\n   <p data-tool=\"mdnice编辑器\">一个 js api 的调用(WeixinJSCore.invokeHandler)，首先会调用到 C/C++ 统一的回调函数 voidCallback，然后再通过 JNI 调用到 Java 的统一处理函数 callVoidJavaMethod。在这个函数里，需要根据 methodID 从 map 中找到对应的 Java Method，然后再通过<code>多次 JNI 调用</code> J2V8 各种接口将 js api 的参数转换为 Java 类型参数，最后再调用到具体 API 的 Java 实现函数 Invoke。</p>\n   <p data-tool=\"mdnice编辑器\">这个调用链路显然不是前面提到的裸绑定的实现方法，因为中间还夹了一层 Java 的中转处理层，产生了一些性能消耗。</p>\n   <p data-tool=\"mdnice编辑器\">针对 invokeHandler，缩短调用链路，减少 JNI 调用优化后，流程如下：</p>\n   <figure data-tool=\"mdnice编辑器\">\n    <img data-ratio=\"0.5192211682476285\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvauvfZCNVQ6v27ofN9lovyXLm6OXQbSiceOic9CX908qLhU5pF7nqxWV46xDergE8bm5Ozj4oicwjJgWQ/640?wx_fmt=png\" data-type=\"png\" data-w=\"2003\" />\n    <figcaption>\n     mark\n    </figcaption>\n   </figure>\n   <p data-tool=\"mdnice编辑器\">针对 js 的 WeixinJSCore.invokeHandler 接口提供专门的 C++ 裸绑定接口 InvokeHandler，取出所有参数后，只需要一次 JNI 调用到 nativeInvokeHandler，然后调到具体 API 的 Java 实现函数 Invoke。</p>\n   <p data-tool=\"mdnice编辑器\">除此之外，针对异步 JsApi 调用，之前的流程是在 java 层抛到另一个线程执行。有了 libuv Looper 后，优化成在底层起一个 uv 的 worker 线程，通过 ASyncCall 将任务抛到 worker 线程，这样 worker 里只需要执行同步的 api 流程，流程上简化了，效率上比抛 Java 层线程更高。</p>\n   <h5 data-tool=\"mdnice编辑器\"><span></span><span>2. JsApi 回调优化</span><span></span></h5>\n   <p data-tool=\"mdnice编辑器\">当框架层需要触发 JS 回调时，之前的做法是拼好一段 JS 字符串然后 evaluate：</p>\n   <pre data-tool=\"mdnice编辑器\"><code>evaluateJavascript(String.format(<br />&nbsp;&nbsp;<span>\"typeof&nbsp;WeixinJSBridge&nbsp;!==&nbsp;'undefined'&nbsp;&amp;&amp;&nbsp;\"</span>&nbsp;+<br />&nbsp;&nbsp;<span>\"WeixinJSBridge.invokeCallbackHandler(%d,&nbsp;%s)\"</span>,<br />&nbsp;&nbsp;callbackId,&nbsp;data<br />));<br /></code></pre>\n   <p data-tool=\"mdnice编辑器\">这里的本质是去调用 JS 里的统一回调处理函数 <code>WeixinJSBridge.invokeCallbackHandler</code>，采取了直接执行一段 JS 的方法。优点是实现简单，缺点是效率不高。</p>\n   <p data-tool=\"mdnice编辑器\">因为让 JS 引擎执行一段 JS 代码时，需要先编译，parse 抽象语法树，生成 Ignition 字节码，甚至启用到 TurboFan 编译优化器，最后才真正执行到想调用的 JS 函数。</p>\n   <p data-tool=\"mdnice编辑器\">同时每个回调都拼一个字符串执行，在 JS 引擎内部会积攒大量临时字符串，占用内存资源。</p>\n   <p data-tool=\"mdnice编辑器\">优化的方法其实也很简单，就是通过 <code>jsbinding</code> 预先查找好 <code>WeixinJSBridge.invokeCallbackHandler</code> 函数，在需要回调这个 JS 函数时，直接调用即可。</p>\n   <pre data-tool=\"mdnice编辑器\"><code><span>//&nbsp;查找到&nbsp;invokeCallbackHandler&nbsp;函数后，保存下来</span><br />mm::JSObject&nbsp;func&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JS_GET_AS(mm::JSObject,&nbsp;js_bridge,&nbsp;<span>\"invokeCallbackHandler\"</span>);<br />js_func_holder_&nbsp;=&nbsp;JS_NEW_OBJECT_HOLDER(func);<br /><br /><span>//&nbsp;...</span><br /><br /><span>//&nbsp;当需要回调时，直接调用</span><br />JS_CALL(js_func_holder_-&gt;Get(),&nbsp;<span>nullptr</span>,&nbsp;<span>nullptr</span>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js_bridge,&nbsp;callbackId,&nbsp;data);<br /></code></pre>\n   <h3 data-tool=\"mdnice编辑器\"><span></span><span>并行调用优化</span><span></span></h3>\n   <p data-tool=\"mdnice编辑器\">开发者在执行某些耗时较重的任务时，可以使用多线程 Worker，类比标准 H5 的 WebWorker。</p>\n   <pre data-tool=\"mdnice编辑器\"><code><span>//&nbsp;主线程初始化&nbsp;Worker</span><br /><span>const</span>&nbsp;worker&nbsp;=&nbsp;wx.createWorker(<span>'workers/request/index.js'</span>)&nbsp;<span>//&nbsp;文件名指定&nbsp;worker&nbsp;的入口文件路径，绝对路径</span><br /><span>//&nbsp;向&nbsp;Worker&nbsp;发送消息</span><br />worker.postMessage({<br />&nbsp;&nbsp;<span>msg</span>:&nbsp;<span>'hello&nbsp;worker'</span><br />})<br /><br /><span>//&nbsp;workers/request/index.js</span><br /><span>//&nbsp;在&nbsp;Worker&nbsp;线程执行上下文会全局暴露一个&nbsp;`worker`&nbsp;对象</span><br />worker.onMessage(<span><span>function</span>&nbsp;(<span>res</span>)&nbsp;</span>{<br />&nbsp;&nbsp;<span>console</span>.log(res)<br />})<br /></code></pre>\n   <p data-tool=\"mdnice编辑器\">之前的 Worker 有个限制，只能执行一些纯逻辑运算的代码，不支持 JsApi 的调用。这很大程度限制了 Worker 的使用，于是我们也在不断的扩展 Worker 的能力，增加了音频、网络、文件等能力。</p>\n   <pre data-tool=\"mdnice编辑器\"><code><span>//&nbsp;Worker&nbsp;线程</span><br /><span>var</span>&nbsp;audio&nbsp;=&nbsp;worker.createInnerAudioContext()<br />audio.src&nbsp;=&nbsp;url<br />audio.play()<br /></code></pre>\n   <p data-tool=\"mdnice编辑器\">未来 Worker 将会赋予更多能力，提高开发者并行化处理的效率。</p>\n   <h3 data-tool=\"mdnice编辑器\"><span></span><span>数据传输优化</span><span></span></h3>\n   <p data-tool=\"mdnice编辑器\">开发者在 JS 层的数据（ArrayBuffer）需要传到客户端底层，同时客户端底层的数据也需要传到 JS 上层，这中间涉及到数据的高效传输。在渲染优化时，可以通过 wgfx 提供的 <code>createNativeBuffer</code> 接口，创建一块 JS 和 Naitve 共享的内存，双方可直接读写该内存而无需额外的传输，极大的提高了效率。</p>\n   <p data-tool=\"mdnice编辑器\">NativeBuffer 的共享内存传输机制，可以应用到多个需要频繁传输数据的场景，比如 Camera 传输的数据、JS 的 WebGL CommandBuffer 传输等等。</p>\n   <p data-tool=\"mdnice编辑器\">还有一种情况是前面提到的 Worker 之间传输数据，如果通过默认的 postMessage 来传输，效率是非常低的，不利于传输较大的 ArrayBuffer 数据。为了解决这个问题，我们提供了类似标准 H5 的 <code>SharedArrayBuffer</code> 的能力，用来 Worker 之间高效的传输数据。</p>\n   <pre data-tool=\"mdnice编辑器\"><code><span>//&nbsp;game.js</span><br /><span>const</span>&nbsp;sab&nbsp;=&nbsp;wx.createSharedArrayBuffer(<span>2</span>)<br />worker.postMessage({<br />&nbsp;&nbsp;sab<br />})<br /><br /><span>//&nbsp;worker.js</span><br />worker.onMessage(<span><span>function</span>&nbsp;(<span>res</span>)&nbsp;</span>{<br />&nbsp;&nbsp;res.sab.lock(<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(<span><span>()</span>&nbsp;=&gt;</span>&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.sab.unlock()<br />&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;<span>3000</span>)<br />&nbsp;&nbsp;})<br />})<br /></code></pre>\n   <h3 data-tool=\"mdnice编辑器\"><span></span><span>总结</span><span></span></h3>\n   <p data-tool=\"mdnice编辑器\">小游戏的性能瓶颈，很大程度局限于 JavaScript，而我们所做的各种优化，是希望能尽量抹平 JavaScript 本身带来的性能损耗，接近并向原生性能靠齐，极具困难和挑战。</p>\n   <p data-tool=\"mdnice编辑器\">在 iOS 上，我们也为让 JavaScript 拥有 JIT 能力做了深入探索。同时，我们也在 WebAssembly 上也进行了深入的探索和支持，未来有机会再进行分享。</p>\n   <p data-tool=\"mdnice编辑器\">为了小游戏有更好的运行性能，开发者能更好的发挥其创意，我们所有的性能优化还将持续不断的迭代下去。</p>\n   <p data-tool=\"mdnice编辑器\"></p>\n   <p><img class=\"rich_pages\" data-ratio=\"0.729264475743349\" data-src=\"https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvatricjRxhpM1x45aB6doaVg7WMhINPwOiaqpskia1kH7hgibO0dicW2HLcW8HRGMzESQwehIcyckLXtwsA/640?wx_fmt=gif\" data-type=\"gif\" data-w=\"639\" /></p>\n  </section> \n </div>\n</div>","descriptionType":"html","feedId":540,"bgimg":"http://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauvfZCNVQ6v27ofN9lovyXLtgyZOGExF6VbicNsFgGDrOv87lCy4CicpScDXcBN0hhKTPOUSJLEyVibQ/0?wx_fmt=jpeg","linkMd5":"9b57f361cf189c3c2bc7672ed5b1da1e","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn69@2020_4/2020/08/18/06-27-03-256_676619726b420b69.webp","metaImg":"http://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauvfZCNVQ6v27ofN9lovyXLtgyZOGExF6VbicNsFgGDrOv87lCy4CicpScDXcBN0hhKTPOUSJLEyVibQ/0?wx_fmt=jpeg","destWidth":600,"destHeight":257,"author":"","publishedOrCreatedDate":1597731990809}],"record":{"createdTime":"2020-08-18 14:26:33","updatedTime":"2020-08-18 14:26:33","feedId":540,"fetchDate":"Tue, 18 Aug 2020 06:26:33 +0000","fetchMs":652,"handleMs":8303,"totalMs":44148,"newArticles":0,"totalArticles":5,"status":1,"type":0,"ip":"52.203.16.105","hostName":"tranquil-oasis-84875.herokuapp.com","requestId":"574086834b9547358f00d6ad145e99e7_540","bgimgsTotal":5,"bgimgsGithubTotal":5,"articlesImgsTotal":7,"articlesImgsGithubTotal":2},"feed":{"createdTime":"2020-08-16 17:44:27","updatedTime":"2020-08-17 21:20:33","id":540,"name":"开发者头条","url":"http://feedmaker.kindle4rss.com/feeds/toutiao.io.xml","subscriber":null,"website":null,"icon":"http://toutiao.io/apple-icon-57x57.png","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn30@2020_3/2020/08/17/11-02-38-704_072eae503565bd23.png","description":"","weekly":null,"link":null},"extra4":{"start":1597731984386,"total":0,"statList":[{"spend":723,"msg":"获取xml内容"},{"spend":8303,"msg":"解释文章"},{"spend":1689,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":6143,"msg":"正文链接上传到cdn"}]},"extra5":7,"extra6":7,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/base.jpg","sourceStatusCode":404,"sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":3160,"convertSpendMs":0,"createdTime":"2020-08-18 14:26:57","host":"hidden-journey-26361.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66,b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/base.jpg","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":1422,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:00","host":"dry-shelf-60780.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66,b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/consul.png","sourceStatusCode":404,"sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":1321,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:02","host":"europe-002.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/qos.png","sourceStatusCode":404,"sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":2000,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:02","host":"protected-shore-14665.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/rateLimit.png","sourceStatusCode":404,"sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":2093,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:02","host":"europe-003.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/lb.jpg","sourceStatusCode":404,"sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":2483,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:02","host":"europe-001.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/roundRobin.png","sourceStatusCode":404,"sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":1380,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:04","host":"afternoon-mountain-02513.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/qos.png","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":1821,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:04","host":"europe-003.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/roundRobin.png","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":1514,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:05","host":"europe-011.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/rateLimit.png","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":2801,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:04","host":"ancient-stream-41040.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/lb.jpg","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":2981,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:05","host":"mysterious-ridge-34067.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/consul.png","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":4610,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:03","host":"stormy-spire-27645.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"}],"extra10_invalidATagHrefValue":{"https://toutiao.io/k/xxh3674_#路由转发":"https://toutiao.io/k/xxh3674#路由转发","https://toutiao.io/k/xxh3674_#网关高可用":"https://toutiao.io/k/xxh3674#网关高可用","https://toutiao.io/k/xxh3674_#服务发现（Consul）":"https://toutiao.io/k/xxh3674#服务发现（Consul）","https://toutiao.io/k/xxh3674_#限流":"https://toutiao.io/k/xxh3674#限流","https://toutiao.io/k/xxh3674_#熔断":"https://toutiao.io/k/xxh3674#熔断"},"extra111_proxyServerAndStatMap":{"http://afternoon-mountain-02513.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[404]},"http://ancient-stream-41040.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[404]},"http://europe-001.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[404]},"http://mysterious-ridge-34067.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[404]},"http://europe-002.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[404]},"http://europe-003.herokuapp.com/":{"failCount":2,"successCount":0,"resultList":[404,404]},"http://stormy-spire-27645.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[404]},"http://europe-011.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[404]},"http://protected-shore-14665.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[404]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://pic4.zhimg.com/v2-c8d40cbe8dfc37b5fcdddb3e1bb368f6_b.jpg","sourceStatusCode":200,"destWidth":720,"destHeight":405,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn51@2020_3/2020/08/18/06-26-58-199_ad6a99516ec8c8c9.webp","sourceBytes":57593,"destBytes":18830,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1299,"convertSpendMs":24,"createdTime":"2020-08-18 14:26:57","host":"dry-shelf-60780.herokuapp.com","referer":"https://toutiao.io/k/fonb2xz","linkMd5ListStr":"9b6fa9672bc2efb1ef061c84601064f9,9b6fa9672bc2efb1ef061c84601064f9","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"56.2 KB","destSize":"18.4 KB","compressRate":"32.7%"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/base.jpg","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":1422,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:00","host":"dry-shelf-60780.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66,b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://tlanyan.me/wp-content/uploads/2020/08/rsync.jpg?v=1597413433","sourceStatusCode":200,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn62@2020_1/2020/08/18/06-27-02-804_ffb8fee81ff72fc5.webp","sourceBytes":9414,"destBytes":9414,"feedId":540,"totalSpendMs":1154,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:02","host":"mysterious-ridge-34067.herokuapp.com","referer":"https://toutiao.io/k/qz4uqwp","linkMd5ListStr":"04c8c5ea545a20b4c250ef3084655ed6","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"9.2 KB","destSize":"9.2 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"http://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicXMHIsS5tjWtiagXyWQt91JcI1SGJuoefZx2lQfh5Iqr2FfTkJw44vRsxe7vYpibUcb3iaThKJdSibEA/0?wx_fmt=jpeg","sourceStatusCode":200,"destWidth":360,"destHeight":360,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn58@2020_4/2020/08/18/06-27-02-821_c317430848e4f3b7.webp","sourceBytes":6843,"destBytes":4136,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1403,"convertSpendMs":7,"createdTime":"2020-08-18 14:27:02","host":"europe-016.herokuapp.com","referer":"https://toutiao.io/k/hjie8u4","linkMd5ListStr":"19ce409900f8e11fbd0e65dd4bae37c0","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"6.7 KB","destSize":"4 KB","compressRate":"60.4%"},{"code":1,"isDone":false,"source":"http://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauvfZCNVQ6v27ofN9lovyXLtgyZOGExF6VbicNsFgGDrOv87lCy4CicpScDXcBN0hhKTPOUSJLEyVibQ/0?wx_fmt=jpeg","sourceStatusCode":200,"destWidth":600,"destHeight":257,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn69@2020_4/2020/08/18/06-27-03-256_676619726b420b69.webp","sourceBytes":15018,"destBytes":11956,"targetWebpQuality":75,"feedId":540,"totalSpendMs":1629,"convertSpendMs":23,"createdTime":"2020-08-18 14:27:02","host":"obscure-cliffs-49071.herokuapp.com","referer":"https://toutiao.io/k/lhyjn91","linkMd5ListStr":"9b57f361cf189c3c2bc7672ed5b1da1e","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"14.7 KB","destSize":"11.7 KB","compressRate":"79.6%"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/qos.png","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":1821,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:04","host":"europe-003.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/roundRobin.png","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":1514,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:05","host":"europe-011.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/rateLimit.png","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":2801,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:04","host":"ancient-stream-41040.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/lb.jpg","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":2981,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:05","host":"mysterious-ridge-34067.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://toutiao.io/img/aspnet-ocelot/consul.png","sourceStatusCode":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn0@2020_1/404.jpg","sourceBytes":0,"destBytes":0,"feedId":540,"totalSpendMs":4610,"convertSpendMs":0,"createdTime":"2020-08-18 14:27:03","host":"stormy-spire-27645.herokuapp.com","referer":"https://toutiao.io/k/xxh3674","linkMd5ListStr":"b297de6354133cc17fb1d51ba9ee8b66","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[404],"sourceSize":"0","destSize":"0"}]}