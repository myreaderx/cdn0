{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-11-16 15:24:45","updatedTime":"2020-11-16 15:24:45","title":"深入浅出 MySQL 优先队列(你一定会踩到的order by limit 问题)","link":"https://segmentfault.com/a/1190000038180339","description":"<blockquote>\n 英语和算法是程序员的两条腿\n</blockquote>\n<p>本文适用于 MySQL 5.6 及以上版本</p>\n<h2>0.先抛问题</h2>\n<p>假设字段<code>category</code>无索引且有重复值，<code>order by category</code> 和<code> limit </code>组合使用的结果会和预期不符。</p>\n<h3>问题复现：</h3>\n<p>表结构（就是两个字段）</p>\n<pre><code class=\"java\">CREATE TABLE `ratings` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `category` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;</code></pre>\n<p>对所有数据按<code>category</code>字段排序： <code>select * from ratings order by category;</code></p>\n<table>\n <thead>\n  <tr>\n   <th>id</th>\n   <th>category</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>1</td>\n   <td>1</td>\n  </tr>\n  <tr>\n   <td>5</td>\n   <td>1</td>\n  </tr>\n  <tr>\n   <td>10</td>\n   <td>1</td>\n  </tr>\n  <tr>\n   <td>3</td>\n   <td>2</td>\n  </tr>\n  <tr>\n   <td>4</td>\n   <td>2</td>\n  </tr>\n  <tr>\n   <td>6</td>\n   <td>2</td>\n  </tr>\n  <tr>\n   <td>9</td>\n   <td>2</td>\n  </tr>\n  <tr>\n   <td>2</td>\n   <td>3</td>\n  </tr>\n  <tr>\n   <td>7</td>\n   <td>3</td>\n  </tr>\n  <tr>\n   <td>8</td>\n   <td>3</td>\n  </tr>\n </tbody>\n</table>\n<p>当我们想分页展示前5条时使用<code>select * from ratings order by category limit 5;</code></p>\n<p>期望得到的<code>ID</code>顺序是<code>1 5 10 3 4</code>。</p>\n<p>但实际结果如下：</p>\n<table>\n <thead>\n  <tr>\n   <th>id</th>\n   <th>category</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>1</td>\n   <td>1</td>\n  </tr>\n  <tr>\n   <td>10</td>\n   <td>1</td>\n  </tr>\n  <tr>\n   <td>5</td>\n   <td>1</td>\n  </tr>\n  <tr>\n   <td>3</td>\n   <td>2</td>\n  </tr>\n  <tr>\n   <td>4</td>\n   <td>2</td>\n  </tr>\n </tbody>\n</table>\n<p>怎么肥似？MySQL 出 Bug 了？</p>\n<p>可能有同学遇到过这个问题，百度或谷歌一下解决了，你有没有想过，你查到的办法是最优解吗？别人是怎么得出这个办法的？MySQL 为什么会这样做，跟版本有关吗？ </p>\n<p>先抛结论：</p>\n<ol>\n <li>最优解是后面再加个列值唯一的排序字段，如：<code>order by category,id</code>；</li>\n <li>MySQL 为什么这样做？答案是为了快！（<code>MySQL 5.6</code>及其之后才有此优化）</li>\n <li>次优解是对<code>order by</code>后面的<code>category</code> 加索引（为什么是次优解？看完本文你将会有答案）；</li>\n</ol>\n<p>下面课代表将还原一下这 3 条结论的产出过程。</p>\n<h2>1. 最优解</h2>\n<p>MySQL 文档 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/limit-optimization.html\" rel=\"nofollow noreferrer\">8.2.1.19 LIMIT Query Optimization</a> 中对此场景有如下描述：</p>\n<blockquote>\n If multiple rows have identical values in the \n <code>ORDER BY</code> columns, the server is free to return those rows in any order, and may do so differently depending on the overall execution plan. In other words, the sort order of those rows is nondeterministic with respect to the nonordered columns.\n <br>One factor that affects the execution plan is <code>LIMIT</code>, so an <code>ORDER BY</code> query with and without <code>LIMIT</code> may return rows in different orders.</br>\n</blockquote>\n<p>总结来说就是：</p>\n<blockquote>\n 当 ORDER BY 列的字段值存在重复，那么这条 ORDER BY 语句返回的数据顺序会因为\n <code>LIMIT</code>的存在而变得不一样\n</blockquote>\n<p>这是 MySQL 默认对该场景做的优化，如果你需要保证加不加 <code>LIMIT</code> 顺序都要一致，官方也给出了办法：</p>\n<blockquote>\n If it is important to ensure the same row order with and without \n <code>LIMIT</code>, include additional columns in the \n <code>ORDER BY</code> clause to make the order deterministic.\n</blockquote>\n<p>就是在<code>ORDER BY</code> 后面再多加一个排序字段（比如 ID 字段）。</p>\n<p>以上描述最早出现在<code>MySQL 5.6</code>文档中，从这个版本开始，引入了这个针对<code>ORDER BY LIMIT </code>的优化。</p>\n<p>好了， 针对文中的场景，我们只需要<code>select * from ratings order by category,id;</code>即可解决。</p>\n<p>那么问题来了，MySQL 为什么要做这么一个看似是 Bug 的优化？</p>\n<h2>2.MySQL 的 ORDER BY 逻辑</h2>\n<p>顾名思义，ORDER BY 就是排序。</p>\n<p>执行一下<code>explain select * from ratings order by category limit 5;</code></p>\n<pre><code class=\"json\">*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: ratings\n   partitions: NULL\n         type: ALL\npossible_keys: NULL\n          key: NULL\n      key_len: NULL\n          ref: NULL\n         rows: 10\n     filtered: 100.00\n        Extra: Using filesort\n1 row in set, 1 warning (0.00 sec)\n</code></pre>\n<p>可以看到 <code>Extra: Using filesort</code> 表示需要排序。</p>\n<p>正常情况下， MySQL 会有内存排序和外部排序两种：</p>\n<ul>\n <li>如果待排序的数据量小于<code>sort buffer size</code>，排序就在内存中完成(快速排序)；</li>\n <li>如果待排序的数据量大于<code>sort buffer size</code>，就使用临时文件进行外部排序(归并排序);</li>\n</ul>\n<p>很明显，这两种排序都是对所有结果全部排序，讲道理，不管有没有<code>LIMIT</code>，都是从排完序的结果中按顺序取需要的条数，有没有<code>LIMIT</code>是不会影响返回的结果顺序的。</p>\n<p>但是，<code>MySQL 5.6</code> 版本针对 <code>ORDER BY LIMIT</code>做了个小优化（排序字段无索引，且列值不唯一时）：优化器在遇到 <code>ORDER BY LIMIT</code>语句的时候，使用了priority queue。</p>\n<p><a href=\"https://dev.mysql.com/doc/dev/mysql-server/8.0.18/filesort_8cc.html\" rel=\"nofollow noreferrer\">filesort.cc</a> 中有如下伪代码描述该优化：</p>\n<pre><code class=\"java\">while (get_next_sortkey())\n   {\n     if (using priority queue)\n       push sort key into queue\n     else\n     {\n       try to put sort key into buffer;\n       if (no free space in sort buffer)\n       {\n         do {\n           allocate new, larger buffer;\n           retry putting sort key into buffer;\n         } until (record fits or no space for new buffer)\n         if (no space for new buffer)\n         {\n           sort record pointers (all buffers);\n           dump sorted sequence to 'tempfile';\n           dump Merge_chunk describing sequence location into 'chunk_file';\n         }\n       }\n       if (key was packed)\n         tell sort buffer the actual number of bytes used;\n     }\n   }\n   if (buffer has some elements &amp;&amp; dumped at least once)\n     sort-dump-dump as above;\n   else\n     don't sort, leave sort buffer to be sorted by caller.</code></pre>\n<p>并在 <a href=\"https://dev.mysql.com/worklog/task/?id=1393\" rel=\"nofollow noreferrer\">WL#1393: Optimizing filesort with small limit </a> 中阐述了该优化逻辑:</p>\n<pre><code class=\"java\">Many web customers have to do\n\"SELECT ... ORDER BY non_index_column LIMIT X\",\n\nWhen X *  is smaller than sort_buff_size we can use\nthe following algoritm to speed up the sort:\n\n- Create a queue to hold 'limit' keys.\n- Scan through the table and store the first (last if DESC) keys in the queue\n- Return values from queue\n\nThis is much faster than the current algoritm that works as:</code></pre>\n<p>该 WorkLog 中记录了优化后的效果：<code>10 to 20 times faster than a quicksort</code>(感兴趣的同学可以去阅读原文)。</p>\n<p>所以，就是为了快！</p>\n<p>MySQL 认为这种场景就是求 TOP N 的问题，使用 priority queue 就能解决。</p>\n<h2>3.priority queue(优先级队列)</h2>\n<p>priority queue 其实就是堆，Java 中有<code>java.util.PriorityQueue</code>类，其本质就是 堆 这种数据结构。</p>\n<p>简单解释一下什么是堆：</p>\n<p>堆是一个完全二叉树；</p>\n<p>堆中每一个节点的值都必须大于等于（大顶堆）或小于等于（小顶堆）其子树中每个节点的值。</p>\n<p>如果 MySQL 使用归并或快排，需要把所有数据都排好序，再取<code>LIMIT</code> 的前几条，剩余已排序的数据就白白浪费了。</p>\n<p>而采用 priority queue 可以根据 <code>LIMIT</code>的条数维护一个堆，只需要把所有数据在这个堆里过一遍就能得到结果。</p>\n<p>使用如下语句可以验证 MySQL 使用了 priority queue：</p>\n<pre><code class=\"java\">SET optimizer_trace='enabled=on';\nselect * from ratings order by category limit 5;\nSELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\\G;</code></pre>\n<pre><code class=\"java\"> \"filesort_priority_queue_optimization\": {\n              \"limit\": 5,\n              \"chosen\": true\n            },</code></pre>\n<p>可以看到 <code>filesort_priority_queue_optimization.chosen = true</code></p>\n<p>下面用流程图还原一下 priority queue 的执行逻辑（以<code>LIMIT 5</code>为例）：</p>\n<p><strong>友情提示：图中的小顶堆以 category 值的大小排序</strong></p>\n<ol>\n <li>取前五条数据构成一个小顶堆：</li>\n</ol>\n<p><img src=\"https://segmentfault.com/img/bVcIj9c\" alt=\"image\" title=\"image\" /></p>\n<ol>\n <li>取下一行数据(6,2),发现 2 小于当前堆中最大的<code>category</code> 3，于是把(2,3)从堆中删掉，把(6,2) 入堆：</li>\n</ol>\n<p><img src=\"https://segmentfault.com/img/bVcIj9m\" alt=\"image\" title=\"image\" /></p>\n<ol>\n <li>重复步骤 2，直至符合查询条件的数据都经历过比较入堆，最终堆中数据如图：</li>\n</ol>\n<p>以上就是通过 priority queue 找到 最小的 5 行 category 数据的执行过程。<br><img src=\"https://segmentfault.com/img/bVcIj9n\" alt=\"image\" title=\"image\" /></br></p>\n<p>最后我们将其出堆即可得到结果，每次出堆最小元素后将最后一个元素放入堆顶，按照小顶堆重新堆化，过程如图：<br><img src=\"https://segmentfault.com/img/bVcIj9w\" alt=\"image\" title=\"image\" /></br></p>\n<p>可以看到，这个结果和<code>select * from ratings order by category limit 5;</code>的输出一致</p>\n<h2>4.加索引为什么是次优解</h2>\n<p>显然，按照ORDER BY 的逻辑，直接对排序字段加索引也可以省去内存排序步骤，从而解决这个问题。</p>\n<p>但索引也不是银弹，多出来的<code>category</code>索引会增加表的维护成本，如果没有明显的业务需要，单纯为了绕过这个priority queue的优化而加索引，课代表认为有点得不偿失。</p>\n<p>尤其是当表数据量非常大的时候，索引的体量会很可观。而且，针对文中场景，<code>category</code>作为分类字段，重复率会比较高，即使有按分类查询的业务 SQL ，MySQL 也不一定会选取这条索引。</p>\n<p>综上，针对本场景，个人认为<code>order by category,id</code>才是该问题的最优解。</p>\n<p>PS：会不会有人问：关我鸟事，我从没写过带 LIMIT 的 SQL 啊！</p>\n<p>难道你写的 CRUD 功能都不带分页的吗？<code>PageHelper</code> 源码去了解一下？</p>\n<h2>5. 总结</h2>\n<p>本文案例是课代表上线过程中遭遇到的实际问题，咨询了下周围同学，有好几个都遇到过此问题，网上文章大多浅入浅出，读完有隔靴搔痒之感，无法解答心中疑惑。遂整理此文。</p>\n<p>其中涉及 数据结构，PageHelper，MySQL 文档，相关参考资料罗列在文末，如果有时间能顺着文章思路亲自读一遍参考文档，相信会有更深的收获。</p>\n<h2>6.参考资料：</h2>\n<ol>\n <li>《数据结构与算法之美》---王争 第 28,29 讲</li>\n <li>《MySQL实战45讲》---林晓斌 第 04、05、10、16、17 讲</li>\n <li>8.2.1.16 LIMIT Query Optimization---<a href=\"https://dev.mysql.com/doc/refman/5.6/en/limit-optimization.html\" rel=\"nofollow noreferrer\">https://dev.mysql.com/doc/ref...</a></li>\n <li>MySQL · 答疑解惑 · MySQL Sort 分页---<a href=\"http://mysql.taobao.org/monthly/2015/06/04/\" rel=\"nofollow noreferrer\">http://mysql.taobao.org/month...</a></li>\n <li>filesort.cc---<a href=\"https://dev.mysql.com/doc/dev/mysql-server/8.0.18/filesort_8cc.html\" rel=\"nofollow noreferrer\">https://dev.mysql.com/doc/dev...</a></li>\n <li>WL#1393: Optimizing filesort with small limit---<a href=\"https://dev.mysql.com/worklog/task/?id=1393\" rel=\"nofollow noreferrer\">https://dev.mysql.com/worklog...</a></li>\n</ol>\n<hr>\n <p>👇关注 Java课代表，获取最新 Java 干货👇<br><img src=\"https://segmentfault.com/img/bVbLbSq\" alt=\"image\" title=\"image\" /></br></p>\n</hr>","descriptionType":"html","publishedDate":"Mon, 16 Nov 2020 02:50:00 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVcIj9c","linkMd5":"b993878ba905eb866a55a16ad278b8e0","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn60@2020_6/2020/11/16/07-24-54-969_6c82542cb07cc348.webp","destWidth":354,"destHeight":336,"sourceBytes":12842,"destBytes":12842,"author":"Java课代表","articleImgCdnMap":{"https://segmentfault.com/img/bVcIj9c":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn60@2020_6/2020/11/16/07-24-54-969_6c82542cb07cc348.webp","https://segmentfault.com/img/bVcIj9m":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn65@2020_5/2020/11/16/07-24-59-682_cb588f621895c584.webp","https://segmentfault.com/img/bVcIj9n":null,"https://segmentfault.com/img/bVcIj9w":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn74@2020_5/2020/11/16/07-24-59-715_eebac97977f91b32.webp","https://segmentfault.com/img/bVbLbSq":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn63@2020_1/2020/11/16/07-24-58-238_e4ee0051d3ebdd4a.webp"},"publishedOrCreatedDate":1605511485830}],"record":{"createdTime":"2020-11-16 15:24:45","updatedTime":"2020-11-16 15:24:45","feedId":6615,"fetchDate":"Mon, 16 Nov 2020 07:24:45 +0000","fetchMs":5104,"handleMs":6683,"totalMs":28281,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"48b55560af3da9c096a2702d0ffd5d16","hostName":"us-021*","requestId":"24ce430837de4402a8c0375e77affa63_6615","contentType":"application/atom+xml; charset=UTF-8","totalBytes":97742,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":5,"articlesImgsGithubTotal":4,"successGithubMap":{"myreaderx1":1,"myreaderx30":1,"myreaderx31":1,"myreaderx18":1},"failGithubMap":{"myreaderx23":1}},"feed":{"createdTime":"2020-08-25 04:33:08","updatedTime":"2020-11-03 15:53:30","id":6615,"name":"SegmentFault 最新的文章","url":"http://segmentfault.com/feeds/blogs","subscriber":null,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"https://segmentfault.com"},"noPictureArticleList":[{"createdTime":"2020-11-16 15:25:00","updatedTime":"2020-11-16 15:25:00","id":null,"feedId":6615,"linkMd5":"b993878ba905eb866a55a16ad278b8e0"}],"tmpCommonImgCdnBytes":12842,"tmpBodyImgCdnBytes":84900,"tmpBgImgCdnBytes":0,"extra4":{"start":1605511472617,"total":0,"statList":[{"spend":6530,"msg":"获取xml内容"},{"spend":6683,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":5170,"msg":"正文链接上传到cdn"}]},"extra5":5,"extra6":5,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcIj9n","sourceStatusCode":200,"destWidth":351,"destHeight":303,"sourceBytes":12620,"destBytes":12620,"feedId":6615,"totalSpendMs":2514,"convertSpendMs":0,"createdTime":"2020-11-16 15:24:55","host":"us-036*","referer":"https://segmentfault.com/a/1190000038180339","linkMd5ListStr":"b993878ba905eb866a55a16ad278b8e0","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn71/contents/2020/11/16/07-24-58-224_478c6f29f4b16b52.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Mon, 16 Nov 2020 07:24:58 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["A596:4472:2668542:3E5F96F:5FB22947"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1605514162"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn71/contents/2020/11/16/07-24-58-224_478c6f29f4b16b52.webp","historyStatusCode":[],"spendMs":32},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12.3 KB","destSize":"12.3 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcIj9n","sourceStatusCode":200,"destWidth":351,"destHeight":303,"sourceBytes":12620,"destBytes":12620,"feedId":6615,"totalSpendMs":2624,"convertSpendMs":0,"createdTime":"2020-11-16 15:24:58","host":"us-036*","referer":"https://segmentfault.com/a/1190000038180339","linkMd5ListStr":"b993878ba905eb866a55a16ad278b8e0","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn71/contents/2020/11/16/07-25-00-138_478c6f29f4b16b52.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Mon, 16 Nov 2020 07:25:00 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["A596:4472:266860F:3E5FB47:5FB2294A"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1605514162"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn71/contents/2020/11/16/07-25-00-138_478c6f29f4b16b52.webp","historyStatusCode":[],"spendMs":43},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12.3 KB","destSize":"12.3 KB","compressRate":"100%"}],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-037.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-036.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://europe21.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe70.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcIj9c","sourceStatusCode":200,"destWidth":354,"destHeight":336,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn60@2020_6/2020/11/16/07-24-54-969_6c82542cb07cc348.webp","sourceBytes":12842,"destBytes":12842,"feedId":6615,"totalSpendMs":4529,"convertSpendMs":0,"createdTime":"2020-11-16 15:24:51","host":"us-020*","referer":"https://segmentfault.com/a/1190000038180339","linkMd5ListStr":"b993878ba905eb866a55a16ad278b8e0,b993878ba905eb866a55a16ad278b8e0","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12.5 KB","destSize":"12.5 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLbSq","sourceStatusCode":200,"destWidth":800,"destHeight":189,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn63@2020_1/2020/11/16/07-24-58-238_e4ee0051d3ebdd4a.webp","sourceBytes":23028,"destBytes":23028,"feedId":6615,"totalSpendMs":3459,"convertSpendMs":0,"createdTime":"2020-11-16 15:24:55","host":"europe21*","referer":"https://segmentfault.com/a/1190000038180339","linkMd5ListStr":"b993878ba905eb866a55a16ad278b8e0","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"22.5 KB","destSize":"22.5 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcIj9w","sourceStatusCode":200,"destWidth":800,"destHeight":556,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn74@2020_5/2020/11/16/07-24-59-715_eebac97977f91b32.webp","sourceBytes":49182,"destBytes":49182,"feedId":6615,"totalSpendMs":4974,"convertSpendMs":0,"createdTime":"2020-11-16 15:24:55","host":"us-037*","referer":"https://segmentfault.com/a/1190000038180339","linkMd5ListStr":"b993878ba905eb866a55a16ad278b8e0","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"48 KB","destSize":"48 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcIj9m","sourceStatusCode":200,"destWidth":354,"destHeight":315,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn65@2020_5/2020/11/16/07-24-59-682_cb588f621895c584.webp","sourceBytes":12690,"destBytes":12690,"feedId":6615,"totalSpendMs":4740,"convertSpendMs":0,"createdTime":"2020-11-16 15:24:55","host":"europe70*","referer":"https://segmentfault.com/a/1190000038180339","linkMd5ListStr":"b993878ba905eb866a55a16ad278b8e0","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12.4 KB","destSize":"12.4 KB","compressRate":"100%"}],"successGithubMap":{"myreaderx1":1,"myreaderx30":1,"myreaderx31":1,"myreaderx18":1},"failGithubMap":{"myreaderx23":1}}