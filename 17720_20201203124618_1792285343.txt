{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-12-03 20:45:49","updatedTime":"2020-12-03 20:45:49","title":"一万字详解 Redis Cluster Gossip 协议","link":"https://juejin.im/post/6902004920543952909","description":"<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><h1 data-id=\"heading-0\">Redis Cluster Gossip 协议</h1>\n<p>大家好，我是历小冰，今天来讲一下 Reids Cluster 的 Gossip 协议和集群操作，文章的思维导图如下所示。</p>\n<p><img alt=\"xmind\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d9b9b12ff94ede83d8b2cc55c4ec3c~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<h3 data-id=\"heading-1\">集群模式和 Gossip 简介</h3>\n<p><strong>对于数据存储领域，当数据量或者请求流量大到一定程度后，就必然会引入分布式</strong>。比如 Redis，虽然其单机性能十分优秀，但是因为下列原因时，也不得不引入集群。</p>\n<ul>\n<li>单机无法保证高可用，需要引入多实例来提供高可用性</li>\n<li>单机能够提供高达 8W 左右的QPS，再高的QPS则需要引入多实例</li>\n<li>单机能够支持的数据量有限，处理更多的数据需要引入多实例；</li>\n<li>单机所处理的网络流量已经超过服务器的网卡的上限值，需要引入多实例来分流。</li>\n</ul>\n<p>有集群，集群往往需要维护一定的元数据，比如实例的ip地址，缓存分片的 slots 信息等，所以需要一套分布式机制来维护元数据的一致性。这类机制一般有两个模式：分散式和集中式</p>\n<p>分散式机制将元数据存储在部分或者所有节点上，不同节点之间进行不断的通信来维护元数据的变更和一致性。Redis Cluster，Consul 等都是该模式。</p>\n<p><img alt=\"Gossip_model\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/320b502e55794e759f991255a156ab7b~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<p>而集中式是将集群元数据集中存储在外部节点或者中间件上，比如 zookeeper。旧版本的 kafka 和 storm 等都是使用该模式。</p>\n<p><img alt=\"center_model\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c014d78ee508476383abf1ee839300ec~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<p>两种模式各有优劣，具体如下表所示：</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>模式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>集中式</td><td>数据更新及时，时效好，元数据的更新和读取，时效性非常好，一旦元数据出现了变更，立即就更新到集中式的外部节点中，其他节点读取的时候立即就可以感知到;</td><td>较大数据更新压力，更新压力全部集中在外部节点，作为单点影响整个系统</td></tr><tr><td>分散式</td><td>数据更新压力分散，元数据的更新比较分散，不是集中某一个节点，更新请求比较分散，而且有不同节点处理，有一定的延时，降低了并发压力</td><td>数据更新延迟，可能导致集群的感知有一定的滞后</td></tr></tbody></table>\n<p>分散式的元数据模式有多种可选的算法进行元数据的同步，比如说 Paxos、Raft 和 Gossip。Paxos 和 Raft 等都需要全部节点或者大多数节点(超过一半)正常运行，整个集群才能稳定运行，而 Gossip 则不需要半数以上的节点运行。</p>\n<p>Gossip 协议，顾名思义，就像流言蜚语一样，利用一种随机、带有传染性的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。对你来说，掌握这个协议不仅能很好地理解这种最常用的，实现最终一致性的算法，也能在后续工作中得心应手地实现数据的最终一致性。</p>\n<p><img alt=\"Gossip_gif\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b50f28b940704fa88a9db5f4b7286e02~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<p>Gossip 协议又称 epidemic 协议（epidemic protocol），是基于流行病传播方式的节点或者进程之间信息交换的协议，在P2P网络和分布式系统中应用广泛，它的方法论也特别简单：</p>\n<blockquote>\n<p>在一个处于有界网络的集群里，如果每个节点都随机与其他节点交换特定信息，经过足够长的时间后，集群各个节点对该份信息的认知终将收敛到一致。</p>\n</blockquote>\n<p>这里的“特定信息”一般就是指集群状态、各节点的状态以及其他元数据等。Gossip协议是完全符合 BASE 原则，可以用在任何要求最终一致性的领域，比如分布式存储和注册中心。另外，它可以很方便地实现弹性集群，允许节点随时上下线，提供快捷的失败检测和动态负载均衡等。</p>\n<p>此外，Gossip 协议的最大的好处是，即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。这就允许 Redis Cluster 或者 Consul 集群管理的节点规模能横向扩展到数千个。</p>\n<h3 data-id=\"heading-2\">Redis Cluster 的 Gossip 通信机制</h3>\n<p>Redis Cluster 是在 3.0 版本引入集群功能。为了让让集群中的每个实例都知道其他所有实例的状态信息，Redis 集群规定各个实例之间按照 Gossip 协议来通信传递信息。</p>\n<p><img alt=\"redis_cluster\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81dcf00e35374a9ab0ef21a5cb729350~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<p>上图展示了主从架构的 Redis Cluster 示意图，其中实线表示节点间的主从复制关系，而虚线表示各个节点之间的 Gossip 通信。</p>\n<p>Redis Cluster 中的每个节点都<strong>维护一份自己视角下的当前整个集群的状态</strong>，主要包括：</p>\n<ol>\n<li><em>当前集群状态</em></li>\n<li><em>集群中各节点所负责的 slots信息，及其migrate状态</em></li>\n<li><em>集群中各节点的master-slave状态</em></li>\n<li>集群中各节点的存活状态及怀疑Fail状态</li>\n</ol>\n<p>也就是说上面的信息，就是集群中Node相互八卦传播流言蜚语的内容主题，而且比较全面，既有自己的更有别人的，这么一来大家都相互传，最终信息就全面而且一致了。</p>\n<p>Redis Cluster 的节点之间会相互发送多种消息，较为重要的如下所示：</p>\n<ul>\n<li>MEET：通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群，然后新节点就会开始与其他节点进行通信；</li>\n<li>PING：节点按照配置的时间间隔向集群中其他节点发送 ping 消息，消息中带有自己的状态，还有自己维护的集群元数据，和部分其他节点的元数据；</li>\n<li>PONG:  节点用于回应 PING 和 MEET 的消息，结构和 PING 消息类似，也包含自己的状态和其他信息，也可以用于信息广播和更新；</li>\n<li>FAIL: 节点 PING 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。</li>\n</ul>\n<p>Redis 的源码中 cluster.h 文件定义了全部的消息类型，代码为 redis 4.0版本。</p>\n<pre><code class=\"hljs language-c copyable\" lang=\"c\"><span class=\"hljs-comment\">// 注意，PING 、 PONG 和 MEET 实际上是同一种消息。</span>\n<span class=\"hljs-comment\">// PONG 是对 PING 的回复，它的实际格式也为 PING 消息，</span>\n<span class=\"hljs-comment\">// 而 MEET 则是一种特殊的 PING 消息，用于强制消息的接收者将消息的发送者添加到集群中（如果节点尚未在节点列表中的话）</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> CLUSTERMSG_TYPE_PING 0          <span class=\"hljs-comment\">/* Ping 消息 */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> CLUSTERMSG_TYPE_PONG 1          <span class=\"hljs-comment\">/* Pong 用于回复Ping */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> CLUSTERMSG_TYPE_MEET 2          <span class=\"hljs-comment\">/* Meet 请求将某个节点添加到集群中 */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> CLUSTERMSG_TYPE_FAIL 3          <span class=\"hljs-comment\">/* Fail 将某个节点标记为 FAIL */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> CLUSTERMSG_TYPE_PUBLISH 4       <span class=\"hljs-comment\">/* 通过发布与订阅功能广播消息 */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 5 <span class=\"hljs-comment\">/* 请求进行故障转移操作，要求消息的接收者通过投票来支持消息的发送者 */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 6     <span class=\"hljs-comment\">/* 消息的接收者同意向消息的发送者投票 */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> CLUSTERMSG_TYPE_UPDATE 7        <span class=\"hljs-comment\">/* slots 已经发生变化，消息发送者要求消息接收者进行相应的更新 */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> CLUSTERMSG_TYPE_MFSTART 8       <span class=\"hljs-comment\">/* 为了进行手动故障转移，暂停各个客户端 */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> CLUSTERMSG_TYPE_COUNT 9         <span class=\"hljs-comment\">/* 消息总数 */</span></span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>通过上述这些消息，集群中的每一个实例都能获得其它所有实例的状态信息。这样一来，即使有新节点加入、节点故障、Slot 变更等事件发生，实例间也可以通过 PING、PONG 消息的传递，完成集群状态在每个实例上的同步。下面，我们依次来看看几种常见的场景。</p>\n<h4 data-id=\"heading-3\">定时 PING/PONG 消息</h4>\n<p>Redis Cluster 中的节点都会定时地向其他节点发送 PING 消息，来交换各个节点状态信息，检查各个节点状态，包括在线状态、疑似下线状态 PFAIL 和已下线状态 FAIL。</p>\n<p>Redis 集群的定时 PING/PONG 的工作原理可以概括成两点：</p>\n<ul>\n<li>一是，每个实例之间会按照一定的频率，从集群中随机挑选一些实例，把 PING 消息发送给挑选出来的实例，用来检测这些实例是否在线，并交换彼此的状态信息。PING 消息中封装了发送消息的实例自身的状态信息、部分其它实例的状态信息，以及 Slot 映射表。</li>\n<li>二是，一个实例在接收到 PING 消息后，会给发送 PING 消息的实例，发送一个 PONG 消息。PONG 消息包含的内容和 PING 消息一样。</li>\n</ul>\n<p>下图显示了两个实例间进行 PING、PONG 消息传递的情况，其中实例一为发送节点，实例二是接收节点</p>\n<p><img alt=\"Gossip_PING\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b0a014046f04a19af921a449ab05522~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<h4 data-id=\"heading-4\">新节点上线</h4>\n<p>Redis Cluster 加入新节点时，客户端需要执行 CLUSTER MEET 命令，如下图所示。</p>\n<p><img alt=\"meet\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e2fd68171474de4a1686d7cda7dadf6~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<p>节点一在执行 CLUSTER MEET 命令时会首先为新节点创建一个 clusterNode 数据，并将其添加到自己维护的 clusterState 的 nodes 字典中。有关 clusterState 和 clusterNode 关系，我们在最后一节会有详尽的示意图和源码来讲解。</p>\n<p>然后节点一会根据据 CLUSTER MEET 命令中的 IP 地址和端口号，向新节点发送一条 MEET 消息。新节点接收到节点一发送的MEET消息后，新节点也会为节点一创建一个 clusterNode 结构，并将该结构添加到自己维护的 clusterState 的 nodes 字典中。</p>\n<p>接着，新节点向节点一返回一条PONG消息。节点一接收到节点B返回的PONG消息后，得知新节点已经成功的接收了自己发送的MEET消息。</p>\n<p>最后，节点一还会向新节点发送一条 PING 消息。新节点接收到该条 PING 消息后，可以知道节点A已经成功的接收到了自己返回的P ONG消息，从而完成了新节点接入的握手操作。</p>\n<p>MEET 操作成功之后，节点一会通过稍早时讲的定时 PING 机制将新节点的信息发送给集群中的其他节点，让其他节点也与新节点进行握手，最终，经过一段时间后，新节点会被集群中的所有节点认识。</p>\n<h4 data-id=\"heading-5\">节点疑似下线和真正下线</h4>\n<p>Redis Cluster 中的节点会定期检查已经发送 PING 消息的接收方节点是否在规定时间 ( cluster-node-timeout ) 内返回了 PONG 消息，如果没有则会将其标记为疑似下线状态，也就是 PFAIL 状态，如下图所示。</p>\n<p><img alt=\"pfail\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7bf4bcf7e7f47e684f3623239d8c68b~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<p>然后，节点一会通过 PING 消息，将节点二处于疑似下线状态的信息传递给其他节点，例如节点三。节点三接收到节点一的 PING 消息得知节点二进入 PFAIL 状态后，会在自己维护的 clusterState 的 nodes 字典中找到节点二所对应的 clusterNode 结构，并将主节点一的下线报告添加到 clusterNode 结构的 fail_reports 链表中。</p>\n<p><img alt=\"PING_FAIL\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c070be9901a46f5a118b84e665e4431~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<p>随着时间的推移，如果节点十 (举个例子) 也因为 PONG 超时而认为节点二疑似下线了，并且发现自己维护的节点二的 clusterNode 的 fail_reports 中有<strong>半数以上的主节点数量的未过时的将节点二标记为 PFAIL 状态报告日志</strong>，那么节点十将会把节点二将被标记为已下线 FAIL 状态，并且节点十会<strong>立刻</strong>向集群其他节点广播主节点二已经下线的 FAIL 消息，所有收到 FAIL 消息的节点都会立即将节点二状态标记为已下线。如下图所示。</p>\n<p><img alt=\"fail\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc37006994f740e7aeccbd0d9ef7f162~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<p>需要注意的是，报告疑似下线记录是由时效性的，如果超过 cluster-node-timeout *2 的时间，这个报告就会被忽略掉，让节点二又恢复成正常状态。</p>\n<h3 data-id=\"heading-6\">Redis Cluster 通信源码实现</h3>\n<p>综上，我们了解了 Redis Cluster 在定时 PING/PONG、新节点上线、节点疑似下线和真正下线等环节的原理和操作流程，下面我们来真正看一下 Redis 在这些环节的源码实现和具体操作。</p>\n<h4 data-id=\"heading-7\">涉及的数据结构体</h4>\n<p>首先，我们先来讲解一下其中涉及的数据结构，也就是上文提到的 ClusterNode 等结构。</p>\n<p><strong>每个节点都会维护一个 clusterState 结构</strong>，表示当前集群的整体状态，它的定义如下所示。</p>\n<pre><code class=\"hljs language-c copyable\" lang=\"c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">clusterState</span> {</span>\n   clusterNode *myself;  <span class=\"hljs-comment\">/* 当前节点的clusterNode信息 */</span>\n   ....\n   dict *nodes;          <span class=\"hljs-comment\">/* name到clusterNode的字典 */</span>\n   ....\n   clusterNode *slots[CLUSTER_SLOTS]; <span class=\"hljs-comment\">/* slot 和节点的对应关系*/</span>\n   ....\n} clusterState;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>它有三个比较关键的字段，具体示意图如下所示：</p>\n<ul>\n<li>myself 字段，是一个 clusterNode 结构，用来记录自己的状态；</li>\n<li>nodes 字典，记录一个 name 到 clusterNode 结构的映射，以此来记录其他节点的状态；</li>\n<li>slot 数组，记录slot 对应的节点 clusterNode结构。</li>\n</ul>\n<p><img alt=\"redis_cluster\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/578656135489435b8ed57000404fee32~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p>\n<p>clusterNode 结构<strong>保存了一个节点的当前状态</strong>，比如<strong>节点的创建时间、节点的名字、节点 当前的配置纪元、节点的IP地址和端口号等等</strong>。除此之外，clusterNode结构的 link 属性是一个clusterLink结构，该结构保存了连接节点所需的有关信息**，比如**套接字描述符，输入缓冲区和输出缓冲区。clusterNode 还有一个 fail_report 的列表，用来记录疑似下线报告。具体定义如下所示。</p>\n<pre><code class=\"hljs language-cpp copyable\" lang=\"cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">clusterNode</span> {</span>\n    <span class=\"hljs-keyword\">mstime_t</span> ctime; <span class=\"hljs-comment\">/* 创建节点的时间 */</span>\n    <span class=\"hljs-keyword\">char</span> name[CLUSTER_NAMELEN]; <span class=\"hljs-comment\">/* 节点的名字 */</span>\n    <span class=\"hljs-keyword\">int</span> flags;      <span class=\"hljs-comment\">/* 节点标识，标记节点角色或者状态，比如主节点从节点或者在线和下线 */</span>\n    <span class=\"hljs-keyword\">uint64_t</span> configEpoch; <span class=\"hljs-comment\">/* 当前节点已知的集群统一epoch */</span>\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">char</span> slots[CLUSTER_SLOTS/<span class=\"hljs-number\">8</span>]; <span class=\"hljs-comment\">/* slots handled by this node */</span>\n    <span class=\"hljs-keyword\">int</span> numslots;   <span class=\"hljs-comment\">/* Number of slots handled by this node */</span>\n    <span class=\"hljs-keyword\">int</span> numslaves;  <span class=\"hljs-comment\">/* Number of slave nodes, if this is a master */</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">clusterNode</span> **<span class=\"hljs-title\">slaves</span>;</span> <span class=\"hljs-comment\">/* pointers to slave nodes */</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">clusterNode</span> *<span class=\"hljs-title\">slaveof</span>;</span> <span class=\"hljs-comment\">/* pointer to the master node. Note that it\n                                    may be NULL even if the node is a slave\n                                    if we don't have the master node in our\n                                    tables. */</span>\n    <span class=\"hljs-keyword\">mstime_t</span> ping_sent;      <span class=\"hljs-comment\">/* 当前节点最后一次向该节点发送 PING 消息的时间 */</span>\n    <span class=\"hljs-keyword\">mstime_t</span> pong_received;  <span class=\"hljs-comment\">/* 当前节点最后一次收到该节点 PONG 消息的时间 */</span>\n    <span class=\"hljs-keyword\">mstime_t</span> fail_time;      <span class=\"hljs-comment\">/* FAIL 标志位被设置的时间 */</span>\n    <span class=\"hljs-keyword\">mstime_t</span> voted_time;     <span class=\"hljs-comment\">/* Last time we voted for a slave of this master */</span>\n    <span class=\"hljs-keyword\">mstime_t</span> repl_offset_time;  <span class=\"hljs-comment\">/* Unix time we received offset for this node */</span>\n    <span class=\"hljs-keyword\">mstime_t</span> orphaned_time;     <span class=\"hljs-comment\">/* Starting time of orphaned master condition */</span>\n    <span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span> repl_offset;      <span class=\"hljs-comment\">/* 当前节点的repl便宜 */</span>\n    <span class=\"hljs-keyword\">char</span> ip[NET_IP_STR_LEN];  <span class=\"hljs-comment\">/* 节点的IP 地址 */</span>\n    <span class=\"hljs-keyword\">int</span> port;                   <span class=\"hljs-comment\">/* 端口 */</span>\n    <span class=\"hljs-keyword\">int</span> cport;                  <span class=\"hljs-comment\">/* 通信端口，一般是端口+1000 */</span>\n    clusterLink *link;          <span class=\"hljs-comment\">/* 和该节点的 tcp 连接 */</span>\n    <span class=\"hljs-built_in\">list</span> *fail_reports;         <span class=\"hljs-comment\">/* 下线记录列表 */</span>\n} clusterNode;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>clusterNodeFailReport 是记录节点下线报告的结构体， node 是报告节点的信息，而 time 则代表着报告时间。</p>\n<pre><code class=\"hljs language-c copyable\" lang=\"c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">clusterNodeFailReport</span> {</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">clusterNode</span> *<span class=\"hljs-title\">node</span>;</span>  <span class=\"hljs-comment\">/* 报告当前节点已经下线的节点 */</span>\n    <span class=\"hljs-keyword\">mstime_t</span> time;             <span class=\"hljs-comment\">/* 报告时间 */</span>\n} clusterNodeFailReport;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 data-id=\"heading-8\">消息结构体</h4>\n<p>了解了 Reids 节点维护的数据结构体后，我们再来看节点进行通信的消息结构体。 通信消息最外侧的结构体为 clusterMsg，它包括了很多消息记录信息，包括 RCmb 标志位，消息总长度，消息协议版本，消息类型；它还包括了发送该消息节点的记录信息，比如节点名称，节点负责的slot信息，节点ip和端口等；最后它包含了一个 clusterMsgData 来携带具体类型的消息。</p>\n<pre><code class=\"hljs language-c copyable\" lang=\"c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> {</span>\n    <span class=\"hljs-keyword\">char</span> sig[<span class=\"hljs-number\">4</span>];        <span class=\"hljs-comment\">/* 标志位，\"RCmb\" (Redis Cluster message bus). */</span>\n    <span class=\"hljs-keyword\">uint32_t</span> totlen;    <span class=\"hljs-comment\">/* 消息总长度 */</span>\n    <span class=\"hljs-keyword\">uint16_t</span> ver;       <span class=\"hljs-comment\">/* 消息协议版本 */</span>\n    <span class=\"hljs-keyword\">uint16_t</span> port;      <span class=\"hljs-comment\">/* 端口 */</span>\n    <span class=\"hljs-keyword\">uint16_t</span> type;      <span class=\"hljs-comment\">/* 消息类型 */</span>\n    <span class=\"hljs-keyword\">uint16_t</span> count;     <span class=\"hljs-comment\">/*  */</span>\n    <span class=\"hljs-keyword\">uint64_t</span> currentEpoch;  <span class=\"hljs-comment\">/* 表示本节点当前记录的整个集群的统一的epoch，用来决策选举投票等，与configEpoch不同的是：configEpoch表示的是master节点的唯一标志，currentEpoch是集群的唯一标志。 */</span>\n    <span class=\"hljs-keyword\">uint64_t</span> configEpoch;   <span class=\"hljs-comment\">/* 每个master节点都有一个唯一的configEpoch做标志，如果和其他master节点冲突，会强制自增使本节点在集群中唯一 */</span>\n    <span class=\"hljs-keyword\">uint64_t</span> offset;    <span class=\"hljs-comment\">/* 主从复制偏移相关信息，主节点和从节点含义不同 */</span>\n    <span class=\"hljs-keyword\">char</span> sender[CLUSTER_NAMELEN]; <span class=\"hljs-comment\">/* 发送节点的名称 */</span>\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">char</span> myslots[CLUSTER_SLOTS/<span class=\"hljs-number\">8</span>]; <span class=\"hljs-comment\">/* 本节点负责的slots信息,16384/8个char数组，一共为16384bit */</span>\n    <span class=\"hljs-keyword\">char</span> slaveof[CLUSTER_NAMELEN]; <span class=\"hljs-comment\">/* master信息，假如本节点是slave节点的话，协议带有master信息 */</span>\n    <span class=\"hljs-keyword\">char</span> myip[NET_IP_STR_LEN];    <span class=\"hljs-comment\">/* IP */</span>\n    <span class=\"hljs-keyword\">char</span> notused1[<span class=\"hljs-number\">34</span>];  <span class=\"hljs-comment\">/* 保留字段 */</span>\n    <span class=\"hljs-keyword\">uint16_t</span> cport;      <span class=\"hljs-comment\">/* 集群的通信端口 */</span>\n    <span class=\"hljs-keyword\">uint16_t</span> flags;      <span class=\"hljs-comment\">/* 本节点当前的状态，比如 CLUSTER_NODE_HANDSHAKE、CLUSTER_NODE_MEET */</span>\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">char</span> state; <span class=\"hljs-comment\">/* Cluster state from the POV of the sender */</span>\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">char</span> mflags[<span class=\"hljs-number\">3</span>]; <span class=\"hljs-comment\">/* 本条消息的类型，目前只有两类：CLUSTERMSG_FLAG0_PAUSED、CLUSTERMSG_FLAG0_FORCEACK */</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">union</span> <span class=\"hljs-title\">clusterMsgData</span> <span class=\"hljs-title\">data</span>;</span>\n} clusterMsg;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>clusterMsgData 是一个 union 结构体，它可以为 PING，MEET，PONG 或者 FAIL 等消息体。其中当消息为 PING、MEET 和 PONG 类型时，ping 字段是被赋值的，而是 FAIL 类型时，fail 字段是被赋值的。</p>\n<pre><code class=\"hljs language-c copyable\" lang=\"c\"><span class=\"hljs-comment\">// 注意这是 union 关键字</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">union</span> <span class=\"hljs-title\">clusterMsgData</span> {</span>\n    <span class=\"hljs-comment\">/* PING, MEET 或者 PONG 消息时，ping 字段被赋值 */</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> {</span>\n        <span class=\"hljs-comment\">/* Array of N clusterMsgDataGossip structures */</span>\n        clusterMsgDataGossip gossip[<span class=\"hljs-number\">1</span>];\n    } ping;\n    <span class=\"hljs-comment\">/*  FAIL 消息时，fail 被赋值 */</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> {</span>\n        clusterMsgDataFail about;\n    } fail;\n    <span class=\"hljs-comment\">// .... 省略 publish 和 update 消息的字段</span>\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>clusterMsgDataGossip 是 PING、PONG 和 MEET 消息的结构体，它会包括发送消息节点维护的其他节点信息，也就是上文中 clusterState 中 nodes 字段包含的信息，具体代码如下所示，你也会发现二者的字段是类似的。</p>\n<pre><code class=\"hljs language-c copyable\" lang=\"c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> {</span>\n<span class=\"hljs-comment\">/* 节点的名字，默认是随机的，MEET消息发送并得到回复后，集群会为该节点设置正式的名称*/</span>\n    <span class=\"hljs-keyword\">char</span> nodename[CLUSTER_NAMELEN]; \n    <span class=\"hljs-keyword\">uint32_t</span> ping_sent; <span class=\"hljs-comment\">/* 发送节点最后一次给接收节点发送 PING 消息的时间戳，收到对应 PONG 回复后会被赋值为0 */</span>\n    <span class=\"hljs-keyword\">uint32_t</span> pong_received; <span class=\"hljs-comment\">/* 发送节点最后一次收到接收节点发送 PONG 消息的时间戳 */</span>\n    <span class=\"hljs-keyword\">char</span> ip[NET_IP_STR_LEN];  <span class=\"hljs-comment\">/* IP address last time it was seen */</span>\n    <span class=\"hljs-keyword\">uint16_t</span> port;       <span class=\"hljs-comment\">/* IP*/</span>       \n    <span class=\"hljs-keyword\">uint16_t</span> cport;      <span class=\"hljs-comment\">/* 端口*/</span>  \n    <span class=\"hljs-keyword\">uint16_t</span> flags;      <span class=\"hljs-comment\">/* 标识*/</span> \n    <span class=\"hljs-keyword\">uint32_t</span> notused1;   <span class=\"hljs-comment\">/* 对齐字符*/</span>\n} clusterMsgDataGossip;\n\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> {</span>\n    <span class=\"hljs-keyword\">char</span> nodename[CLUSTER_NAMELEN]; <span class=\"hljs-comment\">/* 下线节点的名字 */</span>\n} clusterMsgDataFail;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>看完了节点维护的数据结构体和发送的消息结构体后，我们就来看看 Redis 的具体行为源码了。</p>\n<h4 data-id=\"heading-9\">随机周期性发送PING消息</h4>\n<p>Redis 的 clusterCron 函数会被定时调用，每被执行10次，就会准备向随机的一个节点发送 PING 消息。</p>\n<p>它会先随机的选出 5 个节点，然后从中选择最久没有与之通信的节点，调用 clusterSendPing 函数发送类型为 CLUSTERMSG_TYPE_PING 的消息</p>\n<pre><code class=\"hljs language-cpp copyable\" lang=\"cpp\"><span class=\"hljs-comment\">// cluster.c 文件 </span>\n<span class=\"hljs-comment\">// clusterCron() 每执行 10 次（至少间隔一秒钟），就向一个随机节点发送 gossip 信息</span>\n<span class=\"hljs-keyword\">if</span> (!(iteration % <span class=\"hljs-number\">10</span>)) {\n    <span class=\"hljs-keyword\">int</span> j;\n\n    <span class=\"hljs-comment\">/* 随机 5 个节点，选出其中一个 */</span>\n    <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j < <span class=\"hljs-number\">5</span>; j++) {\n        de = dictGetRandomKey(server.cluster->nodes);\n        clusterNode *<span class=\"hljs-keyword\">this</span> = dictGetVal(de);\n\n        <span class=\"hljs-comment\">/* 不要 PING 连接断开的节点，也不要 PING 最近已经 PING 过的节点 */</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>->link == <span class=\"hljs-literal\">NULL</span> || <span class=\"hljs-keyword\">this</span>->ping_sent != <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">continue</span>;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))\n            <span class=\"hljs-keyword\">continue</span>;\n        <span class=\"hljs-comment\">/* 对比 pong_received 字段，选出更长时间未收到其 PONG 消息的节点(表示好久没有接受到该节点的PONG消息了) */</span>\n        <span class=\"hljs-keyword\">if</span> (min_pong_node == <span class=\"hljs-literal\">NULL</span> || min_pong > <span class=\"hljs-keyword\">this</span>->pong_received) {\n            min_pong_node = <span class=\"hljs-keyword\">this</span>;\n            min_pong = <span class=\"hljs-keyword\">this</span>->pong_received;\n        }\n    }\n    <span class=\"hljs-comment\">/* 向最久没有收到 PONG 回复的节点发送 PING 命令 */</span>\n    <span class=\"hljs-keyword\">if</span> (min_pong_node) {\n        serverLog(LL_DEBUG,<span class=\"hljs-string\">\"Pinging node %.40s\"</span>, min_pong_node->name);\n        clusterSendPing(min_pong_node->link, CLUSTERMSG_TYPE_PING);\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>clusterSendPing 函数的具体行为我们后续再了解，因为该函数在其他环节也会经常用到</p>\n<h4 data-id=\"heading-10\">节点加入集群</h4>\n<p>当节点执行 CLUSTER MEET 命令后，会在自身给新节点维护一个 clusterNode 结构体，该结构体的 link 也就是TCP连接字段是 null，表示是新节点尚未建立连接。</p>\n<p>clusterCron 函数中也会处理这些未建立连接的新节点，调用 createClusterLink 创立连接，然后调用 clusterSendPing 函数来发送 MEET 消息</p>\n<pre><code class=\"hljs language-cpp copyable\" lang=\"cpp\"><span class=\"hljs-comment\">/* cluster.c clusterCron 函数部分,为未创建连接的节点创建连接 */</span>\n<span class=\"hljs-keyword\">if</span> (node->link == <span class=\"hljs-literal\">NULL</span>) {\n    <span class=\"hljs-keyword\">int</span> fd;\n    <span class=\"hljs-keyword\">mstime_t</span> old_ping_sent;\n    clusterLink *link;\n    <span class=\"hljs-comment\">/* 和该节点建立连接 */</span>\n    fd = anetTcpNonBlockBindConnect(server.neterr, node->ip,\n        node->cport, NET_FIRST_BIND_ADDR);\n    <span class=\"hljs-comment\">/* .... fd 为-1时的异常处理 */</span>\n    <span class=\"hljs-comment\">/* 建立 link */</span>\n    link = createClusterLink(node);\n    link->fd = fd;\n    node->link = link;\n    aeCreateFileEvent(server.el,link->fd,AE_READABLE,\n            clusterReadHandler,link);\n    <span class=\"hljs-comment\">/* 向新连接的节点发送 PING 命令，防止节点被识进入下线 */</span>\n    <span class=\"hljs-comment\">/* 如果节点被标记为 MEET ，那么发送 MEET 命令，否则发送 PING 命令 */</span>\n    old_ping_sent = node->ping_sent;\n    clusterSendPing(link, node->flags & CLUSTER_NODE_MEET ?\n            CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);\n    <span class=\"hljs-comment\">/* .... */</span>\n    <span class=\"hljs-comment\">/* 如果当前节点（发送者）没能收到 MEET 信息的回复，那么它将不再向目标节点发送命令。*/</span>\n    <span class=\"hljs-comment\">/* 如果接收到回复的话，那么节点将不再处于 HANDSHAKE 状态，并继续向目标节点发送普通 PING 命令*/</span>\n    node->flags &= ~CLUSTER_NODE_MEET;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 data-id=\"heading-11\">防止节点假超时及状态过期</h4>\n<p>防止节点假超时和标记疑似下线标记也是在 clusterCron 函数中，具体如下所示。它会检查当前所有的 nodes 节点列表，如果发现某个节点与自己的最后一个 PONG 通信时间超过了预定的阈值的一半时，为了防止节点是假超时，会主动释放掉与之的 link 连接，然后会主动向它发送一个 PING 消息。</p>\n<pre><code class=\"hljs language-cpp copyable\" lang=\"cpp\"><span class=\"hljs-comment\">/* cluster.c clusterCron 函数部分，遍历节点来检查 fail 的节点*/</span>\n<span class=\"hljs-keyword\">while</span>((de = dictNext(di)) != <span class=\"hljs-literal\">NULL</span>) {\n    clusterNode *node = dictGetVal(de);\n    now = mstime(); <span class=\"hljs-comment\">/* Use an updated time at every iteration. */</span>\n    <span class=\"hljs-keyword\">mstime_t</span> delay;\n\n    <span class=\"hljs-comment\">/* 如果等到 PONG 到达的时间超过了 node timeout 一半的连接 */</span>\n    <span class=\"hljs-comment\">/* 因为尽管节点依然正常，但连接可能已经出问题了 */</span>\n    <span class=\"hljs-keyword\">if</span> (node->link && <span class=\"hljs-comment\">/* is connected */</span>\n        now - node->link->ctime >\n        server.cluster_node_timeout && <span class=\"hljs-comment\">/* 还未重连 */</span>\n        node->ping_sent && <span class=\"hljs-comment\">/* 已经发过ping消息 */</span>\n        node->pong_received < node->ping_sent && <span class=\"hljs-comment\">/* 还在等待pong消息 */</span>\n        <span class=\"hljs-comment\">/* 等待pong消息超过了 timeout/2 */</span>\n        now - node->ping_sent > server.cluster_node_timeout/<span class=\"hljs-number\">2</span>)\n    {\n        <span class=\"hljs-comment\">/* 释放连接，下次 clusterCron() 会自动重连 */</span>\n        freeClusterLink(node->link);\n    }\n\n    <span class=\"hljs-comment\">/* 如果目前没有在 PING 节点*/</span>\n    <span class=\"hljs-comment\">/* 并且已经有 node timeout 一半的时间没有从节点那里收到 PONG 回复 */</span>\n    <span class=\"hljs-comment\">/* 那么向节点发送一个 PING ，确保节点的信息不会太旧，有可能一直没有随机中 */</span>\n    <span class=\"hljs-keyword\">if</span> (node->link &&\n        node->ping_sent == <span class=\"hljs-number\">0</span> &&\n        (now - node->pong_received) > server.cluster_node_timeout/<span class=\"hljs-number\">2</span>)\n    {\n        clusterSendPing(node->link, CLUSTERMSG_TYPE_PING);\n        <span class=\"hljs-keyword\">continue</span>;\n    }\n    <span class=\"hljs-comment\">/* .... 处理failover和标记遗失下线 */</span>\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 data-id=\"heading-12\">处理failover和标记疑似下线</h4>\n<p>如果防止节点假超时处理后，节点依旧未收到目标节点的 PONG 消息，并且时间已经超过了 cluster_node_timeout，那么就将该节点标记为疑似下线状态。</p>\n<pre><code class=\"hljs language-cpp copyable\" lang=\"cpp\"><span class=\"hljs-comment\">/* 如果这是一个主节点，并且有一个从服务器请求进行手动故障转移,那么向从服务器发送 PING*/</span>\n<span class=\"hljs-keyword\">if</span> (server.cluster->mf_end &&\n    nodeIsMaster(myself) &&\n    server.cluster->mf_slave == node &&\n    node->link)\n{\n    clusterSendPing(node->link, CLUSTERMSG_TYPE_PING);\n    <span class=\"hljs-keyword\">continue</span>;\n}\n\n<span class=\"hljs-comment\">/* 后续代码只在节点发送了 PING 命令的情况下执行*/</span>\n<span class=\"hljs-keyword\">if</span> (node->ping_sent == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">continue</span>;\n\n<span class=\"hljs-comment\">/* 计算等待 PONG 回复的时长 */</span> \ndelay = now - node->ping_sent;\n<span class=\"hljs-comment\">/* 等待 PONG 回复的时长超过了限制值，将目标节点标记为 PFAIL （疑似下线)*/</span>\n<span class=\"hljs-keyword\">if</span> (delay > server.cluster_node_timeout) {\n    <span class=\"hljs-comment\">/* 超时了，标记为疑似下线 */</span>\n    <span class=\"hljs-keyword\">if</span> (!(node->flags & (REDIS_NODE_PFAIL|REDIS_NODE_FAIL))) {\n        redisLog(REDIS_DEBUG,<span class=\"hljs-string\">\"*** NODE %.40s possibly failing\"</span>,\n            node->name);\n        <span class=\"hljs-comment\">// 打开疑似下线标记</span>\n        node->flags |= REDIS_NODE_PFAIL;\n        update_state = <span class=\"hljs-number\">1</span>;\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h4 data-id=\"heading-13\">实际发送Gossip消息</h4>\n<p>以下是前方多次调用过的clusterSendPing()方法的源码，代码中有详细的注释，大家可以自行阅读。主要的操作就是将节点自身维护的 clusterState 转换为对应的消息结构体，。</p>\n<pre><code class=\"hljs language-cpp copyable\" lang=\"cpp\"><span class=\"hljs-comment\">/* 向指定节点发送一条 MEET 、 PING 或者 PONG 消息 */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">clusterSendPing</span><span class=\"hljs-params\">(clusterLink *link, <span class=\"hljs-keyword\">int</span> type)</span> </span>{\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">char</span> *buf;\n    clusterMsg *hdr;\n    <span class=\"hljs-keyword\">int</span> gossipcount = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">/* Number of gossip sections added so far. */</span>\n    <span class=\"hljs-keyword\">int</span> wanted; <span class=\"hljs-comment\">/* Number of gossip sections we want to append if possible. */</span>\n    <span class=\"hljs-keyword\">int</span> totlen; <span class=\"hljs-comment\">/* Total packet length. */</span>\n    <span class=\"hljs-comment\">// freshnodes 是用于发送 gossip 信息的计数器</span>\n    <span class=\"hljs-comment\">// 每次发送一条信息时，程序将 freshnodes 的值减一</span>\n    <span class=\"hljs-comment\">// 当 freshnodes 的数值小于等于 0 时，程序停止发送 gossip 信息</span>\n    <span class=\"hljs-comment\">// freshnodes 的数量是节点目前的 nodes 表中的节点数量减去 2 </span>\n    <span class=\"hljs-comment\">// 这里的 2 指两个节点，一个是 myself 节点（也即是发送信息的这个节点）</span>\n    <span class=\"hljs-comment\">// 另一个是接受 gossip 信息的节点</span>\n    <span class=\"hljs-keyword\">int</span> freshnodes = dictSize(server.cluster->nodes)<span class=\"hljs-number\">-2</span>;\n\n    \n    <span class=\"hljs-comment\">/* 计算要携带多少节点的信息，最少3个，最多 1/10 集群总节点数量*/</span>\n    wanted = <span class=\"hljs-built_in\">floor</span>(dictSize(server.cluster->nodes)/<span class=\"hljs-number\">10</span>);\n    <span class=\"hljs-keyword\">if</span> (wanted < <span class=\"hljs-number\">3</span>) wanted = <span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-keyword\">if</span> (wanted > freshnodes) wanted = freshnodes;\n\n    <span class=\"hljs-comment\">/* .... 省略 totlen 的计算等*/</span>\n\n    <span class=\"hljs-comment\">/* 如果发送的信息是 PING ，那么更新最后一次发送 PING 命令的时间戳 */</span>\n    <span class=\"hljs-keyword\">if</span> (link->node && type == CLUSTERMSG_TYPE_PING)\n        link->node->ping_sent = mstime();\n    <span class=\"hljs-comment\">/* 将当前节点的信息（比如名字、地址、端口号、负责处理的槽）记录到消息里面 */</span>\n    clusterBuildMessageHdr(hdr,type);\n\n    <span class=\"hljs-comment\">/* Populate the gossip fields */</span>\n    <span class=\"hljs-keyword\">int</span> maxiterations = wanted*<span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-comment\">/* 每个节点有 freshnodes 次发送 gossip 信息的机会\n       每次向目标节点发送 2 个被选中节点的 gossip 信息（gossipcount 计数） */</span>\n    <span class=\"hljs-keyword\">while</span>(freshnodes > <span class=\"hljs-number\">0</span> && gossipcount < wanted && maxiterations--) {\n        <span class=\"hljs-comment\">/* 从 nodes 字典中随机选出一个节点（被选中节点） */</span>\n        dictEntry *de = dictGetRandomKey(server.cluster->nodes);\n        clusterNode *<span class=\"hljs-keyword\">this</span> = dictGetVal(de);\n\n        <span class=\"hljs-comment\">/* 以下节点不能作为被选中节点：\n         * Myself:节点本身。\n         * PFAIL状态的节点\n         * 处于 HANDSHAKE 状态的节点。\n         * 带有 NOADDR 标识的节点\n         * 因为不处理任何 Slot 而被断开连接的节点 \n         */</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == myself) <span class=\"hljs-keyword\">continue</span>;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>->flags & CLUSTER_NODE_PFAIL) <span class=\"hljs-keyword\">continue</span>;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>->flags & (CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_NOADDR) ||\n            (<span class=\"hljs-keyword\">this</span>->link == <span class=\"hljs-literal\">NULL</span> && <span class=\"hljs-keyword\">this</span>->numslots == <span class=\"hljs-number\">0</span>))\n        {\n            freshnodes--; <span class=\"hljs-comment\">/* Tecnically not correct, but saves CPU. */</span>\n            <span class=\"hljs-keyword\">continue</span>;\n        }\n\n        <span class=\"hljs-comment\">// 检查被选中节点是否已经在 hdr->data.ping.gossip 数组里面</span>\n        <span class=\"hljs-comment\">// 如果是的话说明这个节点之前已经被选中了</span>\n        <span class=\"hljs-comment\">// 不要再选中它（否则就会出现重复）</span>\n        <span class=\"hljs-keyword\">if</span> (clusterNodeIsInGossipSection(hdr,gossipcount,<span class=\"hljs-keyword\">this</span>)) <span class=\"hljs-keyword\">continue</span>;\n\n        <span class=\"hljs-comment\">/* 这个被选中节点有效，计数器减一 */</span>\n        clusterSetGossipEntry(hdr,gossipcount,<span class=\"hljs-keyword\">this</span>);\n        freshnodes--;\n        gossipcount++;\n    }\n\n    <span class=\"hljs-comment\">/* .... 如果有 PFAIL 节点，最后添加 */</span>\n\n\n    <span class=\"hljs-comment\">/* 计算信息长度 */</span>\n    totlen = <span class=\"hljs-keyword\">sizeof</span>(clusterMsg)-<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">union</span> clusterMsgData);\n    totlen += (<span class=\"hljs-keyword\">sizeof</span>(clusterMsgDataGossip)*gossipcount);\n    <span class=\"hljs-comment\">/* 将被选中节点的数量（gossip 信息中包含了多少个节点的信息）记录在 count 属性里面*/</span>\n    hdr->count = htons(gossipcount);\n    <span class=\"hljs-comment\">/* 将信息的长度记录到信息里面 */</span>\n    hdr->totlen = htonl(totlen);\n    <span class=\"hljs-comment\">/* 发送网络请求 */</span>\n    clusterSendMessage(link,buf,totlen);\n    zfree(buf);\n}\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">clusterSetGossipEntry</span><span class=\"hljs-params\">(clusterMsg *hdr, <span class=\"hljs-keyword\">int</span> i, clusterNode *n)</span> </span>{\n    clusterMsgDataGossip *gossip;\n    <span class=\"hljs-comment\">/* 指向 gossip 信息结构 */</span>\n    gossip = &(hdr->data.ping.gossip[i]);\n    <span class=\"hljs-comment\">/* 将被选中节点的名字记录到 gossip 信息 */</span>   \n    <span class=\"hljs-built_in\">memcpy</span>(gossip->nodename,n->name,CLUSTER_NAMELEN);\n    <span class=\"hljs-comment\">/* 将被选中节点的 PING 命令发送时间戳记录到 gossip 信息 */</span>\n    gossip->ping_sent = htonl(n->ping_sent/<span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-comment\">/* 将被选中节点的 PONG 命令回复的时间戳记录到 gossip 信息 */</span>\n    gossip->pong_received = htonl(n->pong_received/<span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-comment\">/* 将被选中节点的 IP 记录到 gossip 信息 */</span>\n    <span class=\"hljs-built_in\">memcpy</span>(gossip->ip,n->ip,<span class=\"hljs-keyword\">sizeof</span>(n->ip));\n    <span class=\"hljs-comment\">/* 将被选中节点的端口号记录到 gossip 信息 */</span>\n    gossip->port = htons(n->port);\n    gossip->cport = htons(n->cport);\n    <span class=\"hljs-comment\">/* 将被选中节点的标识值记录到 gossip 信息 */</span>\n    gossip->flags = htons(n->flags);\n    gossip->notused1 = <span class=\"hljs-number\">0</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>下面是 clusterBuildMessageHdr 函数，它主要负责填充消息结构体中的基础信息和当前节点的状态信息。</p>\n<pre><code class=\"hljs language-c copyable\" lang=\"c\"><span class=\"hljs-comment\">/* 构建消息的 header */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">clusterBuildMessageHdr</span><span class=\"hljs-params\">(clusterMsg *hdr, <span class=\"hljs-keyword\">int</span> type)</span> </span>{\n    <span class=\"hljs-keyword\">int</span> totlen = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">uint64_t</span> offset;\n    clusterNode *master;\n\n    <span class=\"hljs-comment\">/* 如果当前节点是salve，则master为其主节点，如果当前节点是master节点，则master就是当前节点 */</span>\n    master = (nodeIsSlave(myself) && myself->slaveof) ?\n              myself->slaveof : myself;\n\n    <span class=\"hljs-built_in\">memset</span>(hdr,<span class=\"hljs-number\">0</span>,<span class=\"hljs-keyword\">sizeof</span>(*hdr));\n    <span class=\"hljs-comment\">/* 初始化协议版本、标识、及类型， */</span>\n    hdr->ver = htons(CLUSTER_PROTO_VER);\n    hdr->sig[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">'R'</span>;\n    hdr->sig[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">'C'</span>;\n    hdr->sig[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-string\">'m'</span>;\n    hdr->sig[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-string\">'b'</span>;\n    hdr->type = htons(type);\n    <span class=\"hljs-comment\">/* 消息头设置当前节点id */</span>\n    <span class=\"hljs-built_in\">memcpy</span>(hdr->sender,myself->name,CLUSTER_NAMELEN);\n\n    <span class=\"hljs-comment\">/* 消息头设置当前节点ip */</span>\n    <span class=\"hljs-built_in\">memset</span>(hdr->myip,<span class=\"hljs-number\">0</span>,NET_IP_STR_LEN);\n    <span class=\"hljs-keyword\">if</span> (server.cluster_announce_ip) {\n        <span class=\"hljs-built_in\">strncpy</span>(hdr->myip,server.cluster_announce_ip,NET_IP_STR_LEN);\n        hdr->myip[NET_IP_STR_LEN<span class=\"hljs-number\">-1</span>] = <span class=\"hljs-string\">'\\0'</span>;\n    }\n\n    <span class=\"hljs-comment\">/* 基础端口及集群内节点通信端口 */</span>\n    <span class=\"hljs-keyword\">int</span> announced_port = server.cluster_announce_port ?\n                         server.cluster_announce_port : server.port;\n    <span class=\"hljs-keyword\">int</span> announced_cport = server.cluster_announce_bus_port ?\n                          server.cluster_announce_bus_port :\n                          (server.port + CLUSTER_PORT_INCR);\n    <span class=\"hljs-comment\">/* 设置当前节点的槽信息 */</span>\n    <span class=\"hljs-built_in\">memcpy</span>(hdr->myslots,master->slots,<span class=\"hljs-keyword\">sizeof</span>(hdr->myslots));\n    <span class=\"hljs-built_in\">memset</span>(hdr->slaveof,<span class=\"hljs-number\">0</span>,CLUSTER_NAMELEN);\n    <span class=\"hljs-keyword\">if</span> (myself->slaveof != <span class=\"hljs-literal\">NULL</span>)\n        <span class=\"hljs-built_in\">memcpy</span>(hdr->slaveof,myself->slaveof->name, CLUSTER_NAMELEN);\n    hdr->port = htons(announced_port);\n    hdr->cport = htons(announced_cport);\n    hdr->flags = htons(myself->flags);\n    hdr->state = server.cluster->state;\n\n    <span class=\"hljs-comment\">/* 设置 currentEpoch and configEpochs. */</span>\n    hdr->currentEpoch = htonu64(server.cluster->currentEpoch);\n    hdr->configEpoch = htonu64(master->configEpoch);\n\n    <span class=\"hljs-comment\">/* 设置复制偏移量 */</span>\n    <span class=\"hljs-keyword\">if</span> (nodeIsSlave(myself))\n        offset = replicationGetSlaveOffset();\n    <span class=\"hljs-keyword\">else</span>\n        offset = server.master_repl_offset;\n    hdr->offset = htonu64(offset);\n\n    <span class=\"hljs-comment\">/* Set the message flags. */</span>\n    <span class=\"hljs-keyword\">if</span> (nodeIsMaster(myself) && server.cluster->mf_end)\n        hdr->mflags[<span class=\"hljs-number\">0</span>] |= CLUSTERMSG_FLAG0_PAUSED;\n\n    <span class=\"hljs-comment\">/* 计算并设置消息的总长度 */</span>\n    <span class=\"hljs-keyword\">if</span> (type == CLUSTERMSG_TYPE_FAIL) {\n        totlen = <span class=\"hljs-keyword\">sizeof</span>(clusterMsg)-<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">union</span> clusterMsgData);\n        totlen += <span class=\"hljs-keyword\">sizeof</span>(clusterMsgDataFail);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (type == CLUSTERMSG_TYPE_UPDATE) {\n        totlen = <span class=\"hljs-keyword\">sizeof</span>(clusterMsg)-<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">union</span> clusterMsgData);\n        totlen += <span class=\"hljs-keyword\">sizeof</span>(clusterMsgDataUpdate);\n    }\n    hdr->totlen = htonl(totlen);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 data-id=\"heading-14\">后记</h3>\n<p>本来只想写一下 Redis Cluster 的 Gossip 协议，没想到文章越写，内容越多，最后源码分析也是有点虎头蛇尾，大家就凑合看一下，也希望大家继续关注我后续的问题。</p>\n<p><a href=\"http://remcarpediem.net/article/933c5a3a/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">个人博客，欢迎来玩</a></p>\n<p><img alt class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8e1452871e345e4b89e26c2cf550862~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\"></p></div> <div class=\"image-viewer-box\" data-v-78c9b824><!----></div>","descriptionType":"text/html","publishedDate":"Thu, 03 Dec 2020 04:26:49 +0000","feedId":17720,"bgimg":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d9b9b12ff94ede83d8b2cc55c4ec3c~tplv-k3u1fbpfcp-zoom-1.image","linkMd5":"eaee4cd7bcc055d4c052e397898a6df8","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn23@2020_6/2020/12/03/12-45-52-067_d64e68d34ce8cdba.webp","destWidth":3504,"destHeight":1668,"sourceBytes":217193,"destBytes":95742,"author":"用户836357178299","articleImgCdnMap":{"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d9b9b12ff94ede83d8b2cc55c4ec3c~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn23@2020_6/2020/12/03/12-45-52-067_d64e68d34ce8cdba.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/320b502e55794e759f991255a156ab7b~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn67@2020_3/2020/12/03/12-45-54-436_d2634e7f7b2db017.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c014d78ee508476383abf1ee839300ec~tplv-k3u1fbpfcp-zoom-1.image":null,"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b50f28b940704fa88a9db5f4b7286e02~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn38@2020_1/2020/12/03/12-46-16-942_b003f548b82492e8.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81dcf00e35374a9ab0ef21a5cb729350~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn64@2020_1/2020/12/03/12-45-55-355_fccf151efc66232e.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b0a014046f04a19af921a449ab05522~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn35@2020_5/2020/12/03/12-45-54-203_d327d49ed591b6e8.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e2fd68171474de4a1686d7cda7dadf6~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn29@2020_6/2020/12/03/12-45-55-325_77a666b8a1494395.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7bf4bcf7e7f47e684f3623239d8c68b~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn27@2020_4/2020/12/03/12-45-54-205_d7624fb45b907d5f.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c070be9901a46f5a118b84e665e4431~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn54@2020_1/2020/12/03/12-45-56-936_971fbfffb2151267.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc37006994f740e7aeccbd0d9ef7f162~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn31@2020_1/2020/12/03/12-45-54-424_e3ce8bfcd9323412.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/578656135489435b8ed57000404fee32~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn49@2020_1/2020/12/03/12-45-56-219_8f5d17ace5a4311c.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8e1452871e345e4b89e26c2cf550862~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn47@2020_3/2020/12/03/12-45-55-582_2d0ccd8a48a68212.webp"},"publishedOrCreatedDate":1606999549790}],"record":{"createdTime":"2020-12-03 20:45:49","updatedTime":"2020-12-03 20:45:49","feedId":17720,"fetchDate":"Thu, 03 Dec 2020 12:45:49 +0000","fetchMs":983,"handleMs":11,"totalMs":29889,"newArticles":0,"totalArticles":5,"status":1,"type":0,"ip":"f2d45a0601594a1213b8d2dd5eb0726c","hostName":"europe61*","requestId":"0ceb702df9484bdfa957848eeca62e0f_17720","contentType":"application/xml; charset=utf-8","totalBytes":3759238,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":12,"articlesImgsGithubTotal":11,"successGithubMap":{"myreaderx7":1,"myreaderx16":1,"myreaderx6":1,"myreaderx32":1,"myreaderx21":1,"myreaderx4":1,"myreaderx11":1,"myreaderx22":1,"myreaderx24":1,"myreaderx30":1,"myreaderx19":1},"failGithubMap":{"myreaderx23":1}},"feed":{"createdTime":"2020-09-07 02:15:50","updatedTime":"2020-09-07 02:49:19","id":17720,"name":"掘金后端","url":"https://rsshub.app/juejin/category/backend","subscriber":187,"website":null,"icon":"https://juejin.im/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx63/cdn96@2020_3/2020/09/06/18-47-49-898_24cb365749d306f2.ico","description":"掘金后端 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2020-12-03 20:46:18","updatedTime":"2020-12-03 20:46:18","id":null,"feedId":17720,"linkMd5":"eaee4cd7bcc055d4c052e397898a6df8"}],"tmpCommonImgCdnBytes":95742,"tmpBodyImgCdnBytes":3663496,"tmpBgImgCdnBytes":0,"extra4":{"start":1606999548792,"total":0,"statList":[{"spend":987,"msg":"获取xml内容"},{"spend":11,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":25592,"msg":"正文链接上传到cdn"}]},"extra5":12,"extra6":12,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c014d78ee508476383abf1ee839300ec~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":461,"destHeight":321,"sourceBytes":21385,"destBytes":8880,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":1943,"convertSpendMs":18,"createdTime":"2020-12-03 20:45:53","host":"us-032*","referer":"https://juejin.im/post/6902004920543952909","linkMd5ListStr":"eaee4cd7bcc055d4c052e397898a6df8","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn60/contents/2020/12/03/12-45-55-122_a34fdca707c3e359.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Thu, 03 Dec 2020 12:45:55 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["EB7E:2CDE:9097E:18F281:5FC8DE03"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1607000912"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn60/contents/2020/12/03/12-45-55-122_a34fdca707c3e359.webp","historyStatusCode":[],"spendMs":42},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"20.9 KB","destSize":"8.7 KB","compressRate":"41.5%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c014d78ee508476383abf1ee839300ec~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":461,"destHeight":321,"sourceBytes":21385,"destBytes":8880,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":166,"convertSpendMs":8,"createdTime":"2020-12-03 20:45:55","host":"us-015*","referer":"https://juejin.im/post/6902004920543952909","linkMd5ListStr":"eaee4cd7bcc055d4c052e397898a6df8","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn60/contents/2020/12/03/12-45-55-369_a34fdca707c3e359.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Thu, 03 Dec 2020 12:45:55 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["E60A:1C4C:32DDC4:721518:5FC8DE02"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1607000912"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn60/contents/2020/12/03/12-45-55-369_a34fdca707c3e359.webp","historyStatusCode":[],"spendMs":38},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"20.9 KB","destSize":"8.7 KB","compressRate":"41.5%"}],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-013.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-038.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-032.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-020.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-53.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-54.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe66.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-015.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-008.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-016.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-014.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d9b9b12ff94ede83d8b2cc55c4ec3c~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":3504,"destHeight":1668,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn23@2020_6/2020/12/03/12-45-52-067_d64e68d34ce8cdba.webp","sourceBytes":217193,"destBytes":95742,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":3128,"convertSpendMs":169,"createdTime":"2020-12-03 20:45:49","host":"us-012*","referer":"https://juejin.im/post/6902004920543952909","linkMd5ListStr":"eaee4cd7bcc055d4c052e397898a6df8,eaee4cd7bcc055d4c052e397898a6df8","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"212.1 KB","destSize":"93.5 KB","compressRate":"44.1%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7bf4bcf7e7f47e684f3623239d8c68b~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":531,"destHeight":155,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn27@2020_4/2020/12/03/12-45-54-205_d7624fb45b907d5f.webp","sourceBytes":21678,"destBytes":9372,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":1732,"convertSpendMs":9,"createdTime":"2020-12-03 20:45:53","host":"us-013*","referer":"https://juejin.im/post/6902004920543952909","linkMd5ListStr":"eaee4cd7bcc055d4c052e397898a6df8","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"21.2 KB","destSize":"9.2 KB","compressRate":"43.2%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b0a014046f04a19af921a449ab05522~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":531,"destHeight":148,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn35@2020_5/2020/12/03/12-45-54-203_d327d49ed591b6e8.webp","sourceBytes":19378,"destBytes":9414,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":1732,"convertSpendMs":8,"createdTime":"2020-12-03 20:45:53","host":"us-015*","referer":"https://juejin.im/post/6902004920543952909","linkMd5ListStr":"eaee4cd7bcc055d4c052e397898a6df8","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.9 KB","destSize":"9.2 KB","compressRate":"48.6%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc37006994f740e7aeccbd0d9ef7f162~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":551,"destHeight":281,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn31@2020_1/2020/12/03/12-45-54-424_e3ce8bfcd9323412.webp","sourceBytes":16293,"destBytes":7552,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":1962,"convertSpendMs":12,"createdTime":"2020-12-03 20:45:53","host":"us-014*","referer":"https://juejin.im/post/6902004920543952909","linkMd5ListStr":"eaee4cd7bcc055d4c052e397898a6df8","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"15.9 KB","destSize":"7.4 KB","compressRate":"46.4%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/320b502e55794e759f991255a156ab7b~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":441,"destHeight":311,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn67@2020_3/2020/12/03/12-45-54-436_d2634e7f7b2db017.webp","sourceBytes":24599,"destBytes":10760,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":1982,"convertSpendMs":12,"createdTime":"2020-12-03 20:45:53","host":"us-008*","referer":"https://juejin.im/post/6902004920543952909","linkMd5ListStr":"eaee4cd7bcc055d4c052e397898a6df8","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24 KB","destSize":"10.5 KB","compressRate":"43.7%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e2fd68171474de4a1686d7cda7dadf6~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":541,"destHeight":221,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn29@2020_6/2020/12/03/12-45-55-325_77a666b8a1494395.webp","sourceBytes":13304,"destBytes":6038,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":2925,"convertSpendMs":15,"createdTime":"2020-12-03 20:45:53","host":"us-038*","referer":"https://juejin.im/post/6902004920543952909","linkMd5ListStr":"eaee4cd7bcc055d4c052e397898a6df8","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"13 KB","destSize":"5.9 KB","compressRate":"45.4%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81dcf00e35374a9ab0ef21a5cb729350~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":2732,"destHeight":1960,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn64@2020_1/2020/12/03/12-45-55-355_fccf151efc66232e.webp","sourceBytes":236472,"destBytes":134534,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":3099,"convertSpendMs":292,"createdTime":"2020-12-03 20:45:53","host":"us-020*","referer":"https://juejin.im/post/6902004920543952909","linkMd5ListStr":"eaee4cd7bcc055d4c052e397898a6df8","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"230.9 KB","destSize":"131.4 KB","compressRate":"56.9%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8e1452871e345e4b89e26c2cf550862~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":922,"destHeight":468,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn47@2020_3/2020/12/03/12-45-55-582_2d0ccd8a48a68212.webp","sourceBytes":118814,"destBytes":38140,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":3483,"convertSpendMs":21,"createdTime":"2020-12-03 20:45:53","host":"europe66*","referer":"https://juejin.im/post/6902004920543952909","linkMd5ListStr":"eaee4cd7bcc055d4c052e397898a6df8","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"116 KB","destSize":"37.2 KB","compressRate":"32.1%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/578656135489435b8ed57000404fee32~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":981,"destHeight":611,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn49@2020_1/2020/12/03/12-45-56-219_8f5d17ace5a4311c.webp","sourceBytes":58626,"destBytes":27126,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":3902,"convertSpendMs":25,"createdTime":"2020-12-03 20:45:53","host":"us-53*","referer":"https://juejin.im/post/6902004920543952909","linkMd5ListStr":"eaee4cd7bcc055d4c052e397898a6df8","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"57.3 KB","destSize":"26.5 KB","compressRate":"46.3%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c070be9901a46f5a118b84e665e4431~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":601,"destHeight":193,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn54@2020_1/2020/12/03/12-45-56-936_971fbfffb2151267.webp","sourceBytes":25216,"destBytes":10710,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":4504,"convertSpendMs":9,"createdTime":"2020-12-03 20:45:53","host":"us-54*","referer":"https://juejin.im/post/6902004920543952909","linkMd5ListStr":"eaee4cd7bcc055d4c052e397898a6df8","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.6 KB","destSize":"10.5 KB","compressRate":"42.5%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b50f28b940704fa88a9db5f4b7286e02~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":640,"destHeight":413,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn38@2020_1/2020/12/03/12-46-16-942_b003f548b82492e8.webp","sourceBytes":2633411,"destBytes":3409850,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":23422,"convertSpendMs":11909,"createdTime":"2020-12-03 20:45:55","host":"us-016*","referer":"https://juejin.im/post/6902004920543952909","linkMd5ListStr":"eaee4cd7bcc055d4c052e397898a6df8","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"2.5 MB","destSize":"3.3 MB","compressRate":"129.5%"}],"successGithubMap":{"myreaderx7":1,"myreaderx16":1,"myreaderx6":1,"myreaderx32":1,"myreaderx21":1,"myreaderx4":1,"myreaderx11":1,"myreaderx22":1,"myreaderx24":1,"myreaderx30":1,"myreaderx19":1},"failGithubMap":{"myreaderx23":1}}