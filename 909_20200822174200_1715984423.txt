{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-08-23 01:41:38","updatedTime":"2020-08-23 01:41:38","title":"凯蒂阿姨的自定义 Mac 终端","link":"https://linux.cn/article-12536-1.html?utm_source=rss&utm_medium=rss","description":"<blockquote>\n<p>开源意味着我可以在任何终端上找到熟悉的 Linux。</p>\n</blockquote>\n<p><img src=\"https://img.linux.net.cn/data/attachment/album/202008/21/002323xqslvqnnmdz487dq.jpg\" /></p>\n<p>十年前，我开始了我的第一份工作，它要求我使用 Linux 作为我的笔记本电脑的操作系统。如果我愿意的话，我可以使用各种 Linux 发行版，包括 Gentoo，但由于我过去曾短暂地使用过Ubuntu，所以我选择了 Ubuntu Lucid Lynx 10.04。</p>\n<p>我的&#160;<a href=\"https://konsole.kde.org/\">Konsole</a>&#160;终端使用的是&#160;<a href=\"https://github.com/brson/zenburn-konsole\">Zenburn</a>&#160;主题，有一个类似于这样的 Bash 提示符：</p>\n<pre class=\"prettyprint linenums\"><code>machinename ~/path/to/folder $\n</code></pre>\n<p>现在，我使用 Mac，具体来说是 macOS Catalina，我使用&#160;<a href=\"https://www.iterm2.com/\">iTerm2</a>&#160;与&#160;<a href=\"https://gist.github.com/fooforge/3373215\">Zenburn 主题</a>，zsh 提示符是这样的：</p>\n<pre class=\"prettyprint linenums\"><code>machinename ~/path/to/folder\n$\n</code></pre>\n<p>我想，十年来几乎相同的提示符，我已经赢得了<em>老古板</em>的称号，不过这只是标志着，我的喜好和习惯与现在耍酷的孩子们不一样而已。</p>\n<p>仿佛是为了证明我的古板观点，我想改变我的终端和我的旧终端一样。在 Mac 上获得一个看起来和感觉像 Lucid Lynx 的设置并不简单，而且我很花了一些时间。</p>\n<p>我最近最大的改变是从 Bash 转移到 zsh，并迁移了我的&#160;<a href=\"https://opensource.com/article/20/1/bash-scripts-aliases\">Bash 魔改</a>。但这只是其中一个重大的转变。我学到了许多新式的经验，现在我把这些经验赠送给你，亲爱的读者。</p>\n<h3 id=\"coreutils-%E5%AF%B9%E9%80%89%E9%A1%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9B%B4%E5%AE%BD%E5%AE%B9\" class=\"mume-header\">Coreutils 对选项的顺序更宽容</h3>\n<p>从 Ubuntu 转移到 macOS 并没有太大的转变，直到我开始觉得我失去了 Unix 范。我试着运行一些基本的操作，比如删除文件夹，但却被告知我错误地调用了&#160;<code>rm</code>。</p>\n<p>事实证明，GNU 风格的实用程序可能看起来 BSD 风格的差不多，但最大的可用性差异之一是<em>参数顺序</em>。未命名参数的排列顺序并不一致。例如：<code>rm</code>。</p>\n<p>下面是我们熟悉的 GNU 风格的删除目录的命令：</p>\n<pre class=\"prettyprint linenums\"><code>$ rm path/to/folder -rf\n</code></pre>\n<p>这与同一命令的 BSD 风格版本形成鲜明对比：</p>\n<pre class=\"prettyprint linenums\"><code>$ rm path/to/folder -rf\nrm: path/to/folder: is a directory\nrm: -rf: No such file or directory\n</code></pre>\n<p>我通过&#160;<a href=\"https://opensource.com/article/20/6/homebrew-mac\">Homebrew</a>&#160;安装&#160;<a href=\"https://formulae.brew.sh/formula/coreutils\">Coreutils</a>&#160;解决了这个问题。这将 GNU 实用程序引入到了 macOS，并使我不必为那些已经深深扎根于我的肌肉记忆中的命令记住选项顺序，从而对选项顺序更加宽容。</p>\n<h3 id=\"%E5%BC%BA%E5%A4%A7%E7%9A%84-iterm2\" class=\"mume-header\">强大的 iTerm2</h3>\n<p>我不知道有哪个操作系统的资深用户会对默认终端满意。在 macOS 这块土地上，我选择了&#160;<a href=\"https://www.iterm2.com/\">iTerm2</a>，它允许我比基本的操作系统终端应用更灵活。我最喜欢的 iTerm 强大功能之一是能够使用&#160;<code>Command+D</code>&#160;和&#160;<code>Command+Shift+D</code>&#160;来垂直和水平分割窗格。还有很多技巧需要学习，但仅是简单的分割窗格就值得用 iTerm2 换掉默认终端。</p>\n<h3 id=\"%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E7%9A%84%E6%8F%92%E4%BB%B6\" class=\"mume-header\">上下文感知的插件</h3>\n<p>即使是一个古板的用户也会自定义终端提示，其中一个原因是为了获得一些情境感知。我喜欢终端给我提供上下文，并回答所有想到的问题。不仅仅是我在哪个文件夹里，而是：我在什么机器上？这是个 Git 仓库吗？如果是，我在哪个分支？我是在 Python 虚拟环境中吗？</p>\n<p>这些问题的答案最终都归结为一类称之为&#8220;上下文感知插件&#8221;的终端扩展。</p>\n<p>对于当前的 Git 分支，我使用了这个&#160;<a href=\"https://gist.github.com/kevinchappell/09ca3805a9531b818579\">parse_git_branch()</a>&#160;方法（如果你使用的是&#160;<a href=\"https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git\">Oh My Zsh</a>，也有类似的插件）。对于 Python 来说，virtualenv 会自动给提示符加前缀。Oh My Zsh 有如此多的<a href=\"https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins\">插件</a>，你一定能找到改善你生活的东西。</p>\n<p>至于我的本地机？我就直接用&#160;<code>PS1</code>&#160;格式，因为我喜欢这样的基本信息，而且 macOS 并没有<em>真正</em>让你给机器起个名字。</p>\n<h3 id=\"%E5%A4%9A%E8%A1%8C%E6%8F%90%E7%A4%BA%E7%AC%A6%E4%B9%9F%E4%B8%8D%E9%94%99\" class=\"mume-header\">多行提示符也不错</h3>\n<p>观察力强的读者可能会注意到，十年来我的提示符有一个变化，就是现在它是两行。这是最近的一个变化，我慢慢学会了喜欢，因为我前面提到的所有这些插件都让我的提示符变得很长很长。你在文件系统中导航不能太深，要不你试图做任何基本的事情都会输入换行。随之而来的是偶尔的重绘问题和可读性问题。</p>\n<p>我收到的关于解决这个问题的建议大多围绕着&#8220;哦，你在用 zsh？用&#160;<a href=\"https://github.com/romkatv/powerlevel10k\">Powerlevel10k</a>&#160;吧！&#8221;这对于像我这样不固步自封的人来说是不错的，但我能够从这些主题中学习到一些，并从中获取一点技巧。</p>\n<p>我所做的是在我的提示符中的最后一个&#160;<code>$</code>&#160;前加一个&#160;<code>$'\\n'</code>，这样我的上下文信息 &#8212;&#8212; 当前机器、当前文件夹、当前 GitHub 分支、当前 virtualenv 等等 &#8212;&#8212; 都可以在一行中出现，然后我的命令就可以顺利输入了。</p>\n<p>我发现唯一的问题是学会在哪里<em>看</em>。我习惯于让我的眼睛从行的中心开始，因为以前我的提示符就是从那里开始的。我正在慢慢学会向左看提示符，但这是一个缓慢的过程。我有十几年的眼睛习惯要撤销。</p>\n<h3 id=\"%E4%BD%BF%E7%94%A8%E9%80%82%E5%90%88%E4%BD%A0%E7%9A%84%E6%96%B9%E6%B3%95\" class=\"mume-header\">使用适合你的方法</h3>\n<p>如果你喜欢某种风格或工具，那么你的这种偏好是绝对有效的。你可以尝试其他的东西，但千万不要认为你必须使用最新和最伟大的，只是为了像很酷的孩子一样。你的风格和喜好可以随着时间的推移而改变，但千万不要被迫做出对你来说不舒服的改变。</p>\n<p><em>等下一次，凯蒂阿姨再给你吐槽一下 IDE。</em></p>\n<hr />\n<p>via:&#160;<a href=\"https://opensource.com/article/20/7/mac-terminal\">https://opensource.com/article/20/7/mac-terminal</a></p>\n<p>作者：<a href=\"https://opensource.com/users/glasnt\">Katie McLaughlin</a>&#160;选题：<a href=\"https://github.com/lujun9972\">lujun9972</a>&#160;译者：<a href=\"https://github.com/wxy\">wxy</a>&#160;校对：<a href=\"https://github.com/wxy\">wxy</a></p>\n<p>本文由&#160;<a href=\"https://github.com/LCTT/TranslateProject\">LCTT</a>&#160;原创编译，<a href=\"https://linux.cn/\">Linux中国</a>&#160;荣誉推出</p>","descriptionType":"text/html","publishedDate":"Thu, 20 Aug 2020 16:23:42 +0000","feedId":909,"bgimg":"https://img.linux.net.cn/data/attachment/album/202008/21/002323xqslvqnnmdz487dq.jpg","linkMd5":"8ab8e81e111e7caf03040c31b9f63006","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn54@2020_4/2020/08/22/17-41-43-634_a73e02f5dec8692f.webp","destWidth":1280,"destHeight":720,"sourceBytes":261151,"destBytes":83688,"author":"linux@linux.cn (linux)","articleImgCdnMap":{"https://img.linux.net.cn/data/attachment/album/202008/21/002323xqslvqnnmdz487dq.jpg":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn54@2020_4/2020/08/22/17-41-43-634_a73e02f5dec8692f.webp"},"publishedOrCreatedDate":1598118098226},{"createdTime":"2020-08-23 01:41:38","updatedTime":"2020-08-23 01:41:38","title":"#新闻拍一拍# 科学家创造网速新巅峰：每秒 178 Tb","link":"https://linux.cn/article-12541-1.html?utm_source=rss&utm_medium=rss","description":"<p><img src=\"https://img.linux.net.cn/data/attachment/album/202008/22/112939cruoxn2uj8vn8ul0.jpg\" /></p>\n<h4 id=\"%E7%A7%91%E5%AD%A6%E5%AE%B6%E5%88%9B%E9%80%A0%E7%BD%91%E9%80%9F%E6%96%B0%E5%B7%85%E5%B3%B0%E6%AF%8F%E7%A7%92-178-tb\" class=\"code-line\" data-line=\"0\">科学家创造网速新巅峰：每秒 178 Tb</h4>\n<p class=\"code-line\" data-line=\"2\">英国和日本的工程师合作找到了新的方法，在光信号被传送到光纤之前对其进行调制，从而实现了比平时更宽的带宽。甚至远远超过美国宇航局的 ESnet（400 Gb/s）。也就是说可以在 1 秒时间内下载整个 Netflix 库。</p>\n<p class=\"code-line\" data-line=\"4\">来源：<a title=\"https://www.cnbeta.com/articles/science/1018655.htm\" href=\"https://www.cnbeta.com/articles/science/1018655.htm\" data-href=\"https://www.cnbeta.com/articles/science/1018655.htm\">cnBeta.COM</a></p>\n<blockquote class=\"code-line\" data-line=\"6\">\n<p class=\"code-line\" data-line=\"6\">拍一拍：真是不敢想象的速度。从历史可知，技术和生活的进步，取决于基础设施的改进。</p>\n</blockquote>\n<h4 id=\"%E7%9F%A5%E5%90%8D%E8%B7%91%E5%88%86-app-%E5%AE%89%E5%85%94%E5%85%94%E8%A2%AB%E8%B0%B7%E6%AD%8C%E5%88%A0%E9%99%A4%E9%9A%8F%E5%90%8E%E5%B1%B1%E5%AF%A8%E5%BA%94%E7%94%A8%E6%BB%A1%E5%A4%A9%E9%A3%9E\" class=\"code-line\" data-line=\"8\">知名跑分 App 安兔兔被谷歌删除，随后山寨应用满天飞</h4>\n<p class=\"code-line\" data-line=\"10\">由于违反了谷歌的政策，国内非常流行的跑分应用安兔兔已经被谷歌下架，3 月份就被删除了。如今被封杀，这也导致了一个意外的结果，那就是山寨安兔兔应用满天飞。毫无疑问，这些山寨 APP 不是来做慈善的。</p>\n<p class=\"code-line\" data-line=\"12\">来源：<a title=\"https://www.cnbeta.com/articles/tech/1018819.htm\" href=\"https://www.cnbeta.com/articles/tech/1018819.htm\" data-href=\"https://www.cnbeta.com/articles/tech/1018819.htm\">快科技</a></p>\n<blockquote class=\"code-line\" data-line=\"14\">\n<p class=\"code-line\" data-line=\"14\">拍一拍：管杀不管埋。</p>\n</blockquote>\n<h4 id=\"%E6%96%B0-p2p-%E5%83%B5%E5%B0%B8%E7%BD%91%E7%BB%9C%E6%84%9F%E6%9F%93%E4%BA%86-500-%E5%8F%B0%E5%B1%9E%E4%BA%8E%E7%9F%A5%E5%90%8D%E7%BE%8E%E5%9B%BD%E5%92%8C%E6%AC%A7%E6%B4%B2%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8\" class=\"code-line\" data-line=\"16\">新 P2P 僵尸网络感染了 500 台属于知名美国和欧洲大学的服务器</h4>\n<p class=\"code-line\" data-line=\"18\">安全公司 Guardicore Labs 的研究人员披露了一个没有中心服务器利用 P2P 机制进行控制的僵尸网络 FritzFrog。这种控制机制意味着僵尸网络更难被关闭。FritzFrog 只在内存中运行不留下硬盘文件的恶意负荷；自 1 月以来发布了 20 多个版本；只感染 SSH 服务器。</p>\n<p class=\"code-line\" data-line=\"20\">来源：<a title=\"https://www.solidot.org/story?sid=65307\" href=\"https://www.solidot.org/story?sid=65307\" data-href=\"https://www.solidot.org/story?sid=65307\">solidot</a></p>\n<blockquote class=\"code-line\" data-line=\"22\">\n<p class=\"code-line\" data-line=\"22\">拍一拍：对这种 P2P 机制的攻击网络确实不好阻断。有 SSH 服务器要注意了。</p>\n</blockquote>","descriptionType":"text/html","publishedDate":"Sat, 22 Aug 2020 03:31:12 +0000","feedId":909,"bgimg":"https://img.linux.net.cn/data/attachment/album/202008/22/112939cruoxn2uj8vn8ul0.jpg","linkMd5":"68776af40d6c29fa0bd21789f5063bbd","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn27@2020_5/2020/08/22/17-41-44-992_5a947636d69cdca0.webp","destWidth":1280,"destHeight":720,"sourceBytes":178706,"destBytes":41270,"author":"linux@linux.cn (linux)","articleImgCdnMap":{"https://img.linux.net.cn/data/attachment/album/202008/22/112939cruoxn2uj8vn8ul0.jpg":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn27@2020_5/2020/08/22/17-41-44-992_5a947636d69cdca0.webp"},"publishedOrCreatedDate":1598118098226},{"createdTime":"2020-08-23 01:41:38","updatedTime":"2020-08-23 01:41:38","title":"指控 NGINX 串谋侵吞的诉讼后来怎么了","link":"https://linux.cn/article-12532-1.html?utm_source=rss&utm_medium=rss","description":"<p><img src=\"https://img.linux.net.cn/data/attachment/album/202008/20/085634ureka5kh9vmt36h9.jpg\" /></p>\n<blockquote>\n<p>Nginx 的创始人 Sysoev 去年12月突然被警方带走，一时间引起轩然大波。原因是老东家 Rambler 发起刑事起诉，起诉Sysoev 盗窃了 Rambler 的资产 Nginx，声称 Sysoev 在受雇于Rambler期间，使用公司资源和上班时间开发了 Nginx，这样，Nginx 就是一个<ruby>雇佣作品<rp>（</rp><rt>work-made-for-hire</rt><rp>）</rp></ruby>。</p>\n<p>Rambler 还一并将投资 Nginx 和收购 Nginx 的公司统统告上法庭，引发整个 IT 界的强烈争议。迫于各种压力，Rambler 不得不和被诉方进行&#8220;和解谈判&#8221;，事情似乎暂告一段落。</p>\n<p>这件事引发的思考将是深远的，程序员要考虑自己的业余作品是否会被判定为公司权益？而投资人、收购人要考虑相应的尽职调查是否能发现此类风险？</p>\n<p>&#8212;&#8212; 卫sir</p>\n</blockquote>\n<h3>事件过程<strong><br /></strong></h3>\n<p>2020 年 6 月 8 日，<ruby>林伍德投资有限公司<rp>（</rp><rt>Lynwood Investments CY Limited</rt><rp>）</rp></ruby>在加利福尼亚州北区对 NGINX 相关的各种商业实体以及个人、<ruby>鲁纳资本<rp>（</rp><rt>Runa Capital</rt><rp>）</rp></ruby>、<ruby>E.venture 资本合伙人<rp>（</rp><rt>E.venture Capital Partners II, LLC</rt><rp>）</rp></ruby>和 F5 网络公司提起诉讼，指控被起诉人共谋私吞公司资产，并不当发布和使用流行开源软件 NGINX（发音为&#8220;EngineX&#8221;）。以下是投诉内容节录：</p>\n<blockquote>\n<p>原告方<ruby>林伍德公司<rp>（</rp><rt>Lynwood Investments</rt><rp>）</rp></ruby>接受俄罗斯公司&#8212;&#8212;<ruby>兰布勒</ruby>公司互联网控股有限公司的委托起诉了曾任职于<ruby>兰布勒</ruby>公司，并开发了 NGINX 软件的被告<ruby>西索耶夫</ruby> 。当时西索耶夫还开发了一款名为 NGINX Plus 的商业版本。这个开发活动是在西索耶夫任职于兰布勒并利用该公司的资源完成的。兰布勒声称按照雇佣作品的判定原则，它拥有该软件。</p>\n</blockquote>\n<p>该诉状指出：西索耶夫于 2000 年到 2011 年间受雇于兰布勒。NGINX 软件最先是在 2001 年开发出来，并在 2004 年根据 BSD 许可证发布。接下来的七年中，西索耶夫一直都是 NGINX 代码的主要作者，并在&#8220;上班时间&#8221;内提交代码。</p>\n<p><span data-shimo-docs=\"[[20,&#34;该诉状指出：西索耶夫（Sysoev）于 2000 年到 2011 年间受雇于兰布勒（Rambler）。NGINX 软件最先是在 2001 年开发出来，并在 2004 年根据 BSD 许可证发布。接下来的七年中，Sysoev 一直都是 NGINX 代码的主要作者，并在\\&#34;上班时间\\&#34;内提交代码。&#34;,&#34;0:\\&#34;%2319439c\\&#34;&#34;]]\">当时，西索耶夫的主管是兰布勒的 CTO，<ruby>马克西姆&#183;科纳沃洛夫<rp>（</rp><rt>Maxim Konavolov</rt><rp>）</rp></ruby>。诉状称，&#8220;科诺瓦洛夫在兰布勒的关键性的高级管理职位，使他能够从 2008 年开始，就向西索耶夫提供兰布勒内部的生态体系资源，而不受监督或问责。&#8221;</span></p>\n<p><span data-shimo-docs=\"[[20,&#34;该诉状指出：西索耶夫（Sysoev）于 2000 年到 2011 年间受雇于兰布勒（Rambler）。NGINX 软件最先是在 2001 年开发出来，并在 2004 年根据 BSD 许可证发布。接下来的七年中，Sysoev 一直都是 NGINX 代码的主要作者，并在\\&#34;上班时间\\&#34;内提交代码。&#34;,&#34;0:\\&#34;%2319439c\\&#34;&#34;]]\">诉状接着说，&#8220;尽管科诺瓦洛夫和其他不忠员工专注于侵占 NGINX 企业版，他们认为这是一项非常有价值的业务，但科诺瓦洛夫始终给予 NGINX 软件的评级为&#8216;1&#8217;（等级由&#8216;1-5&#8217;，&#8216;1&#8217;被视为&#8216;毫无价值&#8217;）。科诺瓦洛夫的错误等级标志旨在...哄骗兰布勒对 NGINX 软件的价值评定满意，从而避免高级管理层或董事会的任何认真监督。&#8221;</span></p>\n<p>在兰布勒工作期间，西索耶夫与科诺瓦洛夫和其他几位同事一起组建了一家名为 NGINX, Inc. 的新公司，并获得了共同被告鲁纳资本和 E.Venture 资本（当时为 BV 资本）的融资。诉状称，鲁纳资本和 E.Venture &#8220;知道...兰布勒持有 NGINX 软件的所有权&#8221;，但为了西索耶夫和科诺瓦洛夫正在建立的新生业务的利益，它们仍 &#8220;协助和鼓励当时仍是兰布勒的员工的西索耶夫和科诺瓦洛夫违反他们对兰布勒公司应尽的职责...。&#8221;</p>\n<p>诉状对 NGINX 公司于 2011 年 3 月 1 日首次申请在商业中使用 NGINX 的商标申请着墨甚多，当日该团队仍受雇于兰布勒。 新公司的融资并非没有挑战。&#8220;<ruby>格雷克罗夫特<rp>（</rp><rt>Greycroft</rt><rp>）</rp></ruby>退出了融资， 因为它担心兰布勒对 NGINX 软件的所有权....相比之下，鲁纳资本和BV 资本在进行尽职调查后，完全了解兰布勒是整个 NGINX 企业版的法定拥有者，仍于 2011 年 10 月 23 日左右完成了 A 轮融资......&#8221;</p>\n<p>NGINX, Inc. 于 2019 年以 6.7 亿美元出售给在本案同列为被告的 F5 网络公司。诉状称，&#8220; F5 在合并完成之前的尽职调查中，就已经知道共谋者从兰布勒窃取了 NGINX 企业版......&#8221;</p>\n<p>当一名告密者向他们提供了证据之后，兰布勒和林伍德公司得知被告涉嫌共谋。</p>\n<h3>事件结局<span data-shimo-docs=\"[[20,&#34;该诉状指出：西索耶夫（Sysoev）于 2000 年到 2011 年间受雇于兰布勒（Rambler）。NGINX 软件最先是在 2001 年开发出来，并在 2004 年根据 BSD 许可证发布。接下来的七年中，Sysoev 一直都是 NGINX 代码的主要作者，并在\\&#34;上班时间\\&#34;内提交代码。&#34;,&#34;0:\\&#34;%2319439c\\&#34;&#34;]]\">&#160;</span></h3>\n<p><span data-shimo-docs=\"[[20,&#34;该诉状指出：西索耶夫（Sysoev）于 2000 年到 2011 年间受雇于兰布勒（Rambler）。NGINX 软件最先是在 2001 年开发出来，并在 2004 年根据 BSD 许可证发布。接下来的七年中，Sysoev 一直都是 NGINX 代码的主要作者，并在\\&#34;上班时间\\&#34;内提交代码。&#34;,&#34;0:\\&#34;%2319439c\\&#34;&#34;]]\">这一诉状提出了包括民事诈欺在内的许多指控，是漫长历程而复杂的，并且具有戏剧性的阅读效果。而诉状声称本案只是一系列法律行动的开始。此前有报道称，兰布勒正基于本案的各项事证在俄罗斯提起刑事诉讼，直到拥有兰布勒 46.5% 股权的俄罗斯国有银行 Sberbank 劝告兰布勒董事会停止追诉。显然地，兰布勒在 2019 年末放弃了刑事追诉，转而与 F5 公司进行&#8220;和解谈判&#8221;。</span></p>\n<h3>引发思考<span data-shimo-docs=\"[[20,&#34;该诉状指出：西索耶夫（Sysoev）于 2000 年到 2011 年间受雇于兰布勒（Rambler）。NGINX 软件最先是在 2001 年开发出来，并在 2004 年根据 BSD 许可证发布。接下来的七年中，Sysoev 一直都是 NGINX 代码的主要作者，并在\\&#34;上班时间\\&#34;内提交代码。&#34;,&#34;0:\\&#34;%2319439c\\&#34;&#34;]]\">&#160;</span></h3>\n<p>&#160;</p>\n<p><span data-shimo-docs=\"[[20,&#34;该诉状指出：西索耶夫（Sysoev）于 2000 年到 2011 年间受雇于兰布勒（Rambler）。NGINX 软件最先是在 2001 年开发出来，并在 2004 年根据 BSD 许可证发布。接下来的七年中，Sysoev 一直都是 NGINX 代码的主要作者，并在\\&#34;上班时间\\&#34;内提交代码。&#34;,&#34;0:\\&#34;%2319439c\\&#34;&#34;]]\">此诉状描述了一种变得越来越普遍的不幸的情况 &#8212;&#8212; 众所周知，开发人员在公司时间编写代码，在未经适当授权的情况下用某种开源许可证发布代码，并随之利用该开源代码成立与原公司相互竞争的业务，并声称有权在该开源许可证下使用该代码。在这种情况下，发布的授权问题通常很关键，并且指出公司需要有正式的开源发布政策。但是，在本诉状中指控的不当行为程度是不寻常的，达到了 CTO 级别。投诉也很有趣，因为它点名了 NGINX, Inc. 的风险投资商和并购买家&#8212;&#8212;这是一个试图绕过公司保护伞（保护善意第三人）的不寻常的举动。对于考虑对潜在投资和收购进行尽职调查的公司来说，这是一个令人不安的发展。</span></p>\n<p><strong>作者简介</strong></p>\n<p>heatherjmeeker，技术许可律师、鼓手、舞蹈家。</p>","descriptionType":"text/html","publishedDate":"Thu, 20 Aug 2020 00:57:40 +0000","feedId":909,"bgimg":"https://img.linux.net.cn/data/attachment/album/202008/20/085634ureka5kh9vmt36h9.jpg","linkMd5":"41fdf0b897c10a186e51a610d6c066f5","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn31@2020_1/2020/08/22/17-41-41-453_e255e34f9592c3d5.webp","destWidth":1280,"destHeight":720,"sourceBytes":181759,"destBytes":51890,"author":"linux@linux.cn (linux)","articleImgCdnMap":{"https://img.linux.net.cn/data/attachment/album/202008/20/085634ureka5kh9vmt36h9.jpg":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn31@2020_1/2020/08/22/17-41-41-453_e255e34f9592c3d5.webp"},"publishedOrCreatedDate":1598118098223},{"createdTime":"2020-08-23 01:41:38","updatedTime":"2020-08-23 01:41:38","title":"#新闻拍一拍# 大学生用 GPT-3 生成伪文章成功骗过众人","link":"https://linux.cn/article-12537-1.html?utm_source=rss&utm_medium=rss","description":"<p><img src=\"https://img.linux.net.cn/data/attachment/album/202008/21/005134nctawqncaclwi2ni.jpg\" /></p>\n<h4 id=\"%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%94%A8-gpt-3-%E7%94%9F%E6%88%90%E4%BC%AA%E6%96%87%E7%AB%A0%E6%88%90%E5%8A%9F%E9%AA%97%E8%BF%87%E4%BC%97%E4%BA%BA\" class=\"mume-header\">大学生用 GPT-3 生成伪文章成功骗过众人</h4>\n<p>加州大学伯克利分校的学生以 Adolos 为笔名开通博客，在其中发布由 GPT-3 模型生成的文章，第一篇就被顶至 Hacker News 头条，还被 medium 等各大平台转载，该博客迅速获得了 60 位关注者及大约 2.6 万访问量。但注意到文章是由人工智能生成，且提出质疑的人屈指可数。这篇题为《觉得生产力低下？也许你应该停止过度思考》的文章，仅指定了标题和简介，其他内容都交由 GPT-3 完成，却引来一众网友共情并应声附和。</p>\n<p>来源：<a href=\"https://www.oschina.net/news/118021/gpt-3-fake-blog\">开源中国</a></p>\n<blockquote>\n<p>拍一拍：或许，等 GPT-3 的使用门槛进一步降低后，很多人的工作都不在需要。</p>\n</blockquote>\n<h4 id=\"g-suite-%E6%9C%8D%E5%8A%A1%E5%AE%95%E6%9C%BA%E6%95%B0%E5%B0%8F%E6%97%B6\" class=\"mume-header\">G Suite 服务宕机数小时</h4>\n<p>根据 G Suite Status Dashboard 上的信息，多个 Google 服务宕机数小时，Google 尚未给出解释，只是表示正在调查问题。受到影响的服务包括 Gmail、Google Drive、Google Docs、Google Slides、Google Sites、Google Groups、Google Chat 和 Google Meet。</p>\n<p>来源：<a href=\"https://www.solidot.org/story?sid=65302\">solidot</a></p>\n<blockquote>\n<p>拍一拍：云服务垄断了互联网服务的同时，无论是哪家云服务商，均出现过大范围的、长时间的服务故障，或许这就是集中化、规模化带来副作用。</p>\n</blockquote>\n<h4 id=\"grafana-%E7%9A%84%E5%BC%80%E5%8F%91%E5%95%86-grafana-labs-%E5%AE%A3%E5%B8%83%E5%B7%B2%E5%AE%8C%E6%88%90-5000-%E4%B8%87%E7%BE%8E%E5%85%83%E7%9A%84-b-%E8%BD%AE%E8%9E%8D%E8%B5%84\" class=\"mume-header\">Grafana 的开发商 Grafana Labs 宣布已完成 5000 万美元的 B 轮融资</h4>\n<p>2019 年 10 月的首轮融资，当时该公司筹得 2,400 万美元。Grafana 是一款开源的可视化系统指标监控与分析平台，支持与包括 Graphite、Elasticsearch、OpenTSDB、Prometheus 和 InfluxDB 等在内的众多数据源集成。</p>\n<p>来源：<a href=\"https://www.oschina.net/news/118041/grafana-labs-raises-50m-in-series-b-funding\">开源中国</a></p>\n<blockquote>\n<p>拍一拍：真正有影响力的开源软件，一样能赢得资本市场的青睐。</p>\n</blockquote>","descriptionType":"text/html","publishedDate":"Thu, 20 Aug 2020 16:51:43 +0000","feedId":909,"bgimg":"https://img.linux.net.cn/data/attachment/album/202008/21/005134nctawqncaclwi2ni.jpg","linkMd5":"93ddb03a8f56bdb16f711b876c4b21de","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn25@2020_3/2020/08/22/17-41-43-201_5be923aed2ab604b.webp","destWidth":1280,"destHeight":720,"sourceBytes":364169,"destBytes":114768,"author":"linux@linux.cn (linux)","articleImgCdnMap":{"https://img.linux.net.cn/data/attachment/album/202008/21/005134nctawqncaclwi2ni.jpg":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn25@2020_3/2020/08/22/17-41-43-201_5be923aed2ab604b.webp"},"publishedOrCreatedDate":1598118098223},{"createdTime":"2020-08-23 01:41:38","updatedTime":"2020-08-23 01:41:38","title":"合并和排序 Linux 上的文件","link":"https://linux.cn/article-12539-1.html?utm_source=rss&utm_medium=rss","description":"<p><img src=\"https://img.linux.net.cn/data/attachment/album/202008/22/102250i3943is48r34w4nz.jpg\" /></p>\n<p>在 Linux 上合并和排序文本的方法有很多种，但如何去处理它取决于你试图做什么：你是只想将多个文件的内容放入一个文件中，还是以某种方式组织它，让它更易于使用。在本文中，我们将查看一些用于排序和合并文件内容的命令，并重点介绍结果有何不同。</p>\n<h3 id=\"%E4%BD%BF%E7%94%A8-cat\" class=\"mume-header\">使用 cat</h3>\n<p>如果你只想将一组文件放到单个文件中，那么&#160;<code>cat</code>&#160;命令是一个容易的选择。你所要做的就是输入&#160;<code>cat</code>，然后按你希望它们在合并文件中的顺序在命令行中列出这些文件。将命令的输出重定向到要创建的文件。如果指定名称的文件已经存在，那么文件将被覆盖。例如：</p>\n<pre class=\"prettyprint linenums\"><code>$ cat firstfile secondfile thirdfile &#62; newfile\n</code></pre>\n<p>如果要将一系列文件的内容添加到现有文件中，而不是覆盖它，只需将&#160;<code>&#62;</code>&#160;变成&#160;<code>&#62;&#62;</code>。</p>\n<pre class=\"prettyprint linenums\"><code>$ cat firstfile secondfile thirdfile &#62;&#62; updated_file\n</code></pre>\n<p>如果你要合并的文件遵循一些方便的命名约定，那么任务可能更简单。如果可以使用正则表达式指定所有文件名，那就不必列出所有文件。例如，如果文件全部以&#160;<code>file</code>&#160;结束，如上所示，你可以进行如下操作：</p>\n<pre class=\"prettyprint linenums\"><code>$ cat *file &#62; allfiles\n</code></pre>\n<p>请注意，上面的命令将按字母数字顺序添加文件内容。在 Linux 上，一个名为&#160;<code>filea</code>&#160;的文件将排在名为&#160;<code>fileA</code>&#160;的文件的前面，但会在&#160;<code>file7</code>&#160;的后面。毕竟，当我们处理字母数字序列时，我们不仅需要考虑&#160;<code>ABCDE</code>，还需要考虑&#160;<code>0123456789aAbBcCdDeE</code>。你可以使用&#160;<code>ls *file</code>&#160;这样的命令来查看合并文件之前文件的顺序。</p>\n<p>注意：首先确保你的命令包含合并文件中所需的所有文件，而不是其他文件，尤其是你使用&#160;<code>*</code>&#160;等通配符时。不要忘记，用于合并的文件仍将单独存在，在确认合并后，你可能想要删除这些文件。</p>\n<h3 id=\"%E6%8C%89%E6%97%B6%E9%97%B4%E6%9C%9F%E9%99%90%E5%90%88%E5%B9%B6%E6%96%87%E4%BB%B6\" class=\"mume-header\">按时间期限合并文件</h3>\n<p>如果要基于每个文件的时间期限而不是文件名来合并文件，请使用以下命令：</p>\n<pre class=\"prettyprint linenums\"><code>$ for file in `ls -tr myfile.*`; do  cat $file &#62;&#62; BigFile.$$; done\n</code></pre>\n<p>使用&#160;<code>-tr</code>&#160;选项（<code>t</code>&#160;= 时间，<code>r</code>&#160;= 反向）将产生按照最早的在最前排列的文件列表。例如，如果你要保留某些活动的日志，并且希望按活动执行的顺序添加内容，则这非常有用。</p>\n<p>上面命令中的&#160;<code>$$</code>&#160;表示运行命令时的进程 ID。不是很必要使用此功能，但它几乎不可能会无意添加到现有的文件，而不是创建新文件。如果使用&#160;<code>$$</code>，那么生成的文件可能如下所示：</p>\n<pre class=\"prettyprint linenums\"><code>$ ls -l BigFile.*\n-rw-rw-r-- 1 justme justme   931725 Aug  6 12:36 BigFile.582914\n</code></pre>\n<h3 id=\"%E5%90%88%E5%B9%B6%E5%92%8C%E6%8E%92%E5%BA%8F%E6%96%87%E4%BB%B6\" class=\"mume-header\">合并和排序文件</h3>\n<p>Linux 提供了一些有趣的方式来对合并之前或之后的文件内容进行排序。</p>\n<h4 id=\"%E6%8C%89%E5%AD%97%E6%AF%8D%E5%AF%B9%E5%86%85%E5%AE%B9%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F\" class=\"mume-header\">按字母对内容进行排序</h4>\n<p>如果要对合并的文件内容进行排序，那么可以使用以下命令对整体内容进行排序：</p>\n<pre class=\"prettyprint linenums\"><code>$ cat myfile.1 myfile.2 myfile.3 | sort &#62; newfile\n</code></pre>\n<p>如果要按文件对内容进行分组，请使用以下命令对每个文件进行排序，然后再将它添加到新文件中：</p>\n<pre class=\"prettyprint linenums\"><code>$ for file in `ls myfile.?`; do sort $file &#62;&#62; newfile; done\n</code></pre>\n<h4 id=\"%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%97%E6%8E%92%E5%BA%8F\" class=\"mume-header\">对文件进行数字排序</h4>\n<p>要对文件内容进行数字排序，请在&#160;<code>sort</code>&#160;中使用&#160;<code>-n</code>&#160;选项。仅当文件中的行以数字开头时，此选项才有用。请记住，按照默认顺序，<code>02</code>&#160;将小于&#160;<code>1</code>。当你要确保行以数字排序时，请使用&#160;<code>-n</code>&#160;选项。</p>\n<pre class=\"prettyprint linenums\"><code>$ cat myfile.1 myfile.2 myfile.3 | sort -n &#62; xyz\n</code></pre>\n<p>如果文件中的行以&#160;<code>2020-11-03</code>&#160;或&#160;<code>2020/11/03</code>（年月日格式）这样的日期格式开头，<code>-n</code>&#160;选项还能让你按日期对内容进行排序。其他格式的日期排序将非常棘手，并且将需要更复杂的命令。</p>\n<h3 id=\"%E4%BD%BF%E7%94%A8-paste\" class=\"mume-header\">使用 paste</h3>\n<p><code>paste</code>&#160;命令允许你逐行连接文件内容。使用此命令时，合并文件的第一行将包含要合并的每个文件的第一行。以下是示例，其中我使用了大写字母以便于查看行的来源：</p>\n<pre class=\"prettyprint linenums\"><code>$ cat file.a\nA one\nA two\nA three\n\n$ paste file.a file.b file.c\nA one   B one   C one\nA two   B two   C two\nA three B three C thee\n        B four  C four\n                C five\n</code></pre>\n<p>将输出重定向到另一个文件来保存它：</p>\n<pre class=\"prettyprint linenums\"><code>$ paste file.a file.b file.c &#62; merged_content\n</code></pre>\n<p>或者，你可以将每个文件的内容在同一行中合并，然后将文件粘贴在一起。这需要使用&#160;<code>-s</code>（序列）选项。注意这次的输出如何显示每个文件的内容：</p>\n<pre class=\"prettyprint linenums\"><code>$ paste -s file.a file.b file.c\nA one   A two   A three\nB one   B two   B three B four\nC one   C two   C thee  C four  C five\n</code></pre>\n<h3 id=\"%E4%BD%BF%E7%94%A8-join\" class=\"mume-header\">使用 join</h3>\n<p>合并文件的另一个命令是&#160;<code>join</code>。<code>join</code>&#160;命令让你能基于一个共同字段合并多个文件的内容。例如，你可能有一个包含一组同事的电话的文件，其中，而另一个包含了同事的电子邮件地址，并且两者均按个人姓名列出。你可以使用&#160;<code>join</code>&#160;创建一个包含电话和电子邮件地址的文件。</p>\n<p>一个重要的限制是文件的行必须是相同的顺序，并在每个文件中包括用于连接的字段。</p>\n<p>这是一个示例命令：</p>\n<pre class=\"prettyprint linenums\"><code>$ join phone_numbers email_addresses\nSandra 555-456-1234 bugfarm@gmail.com\nPedro 555-540-5405\nJohn 555-333-1234 john_doe@gmail.com\nNemo 555-123-4567 cutie@fish.com\n</code></pre>\n<p>在本例中，即使缺少附加信息，第一个字段（名字）也必须存在于每个文件中，否则命令会因错误而失败。对内容进行排序有帮助，而且可能更容易管理，但只要顺序一致，就不需要这么做。</p>\n<h3 id=\"%E6%80%BB%E7%BB%93\" class=\"mume-header\">总结</h3>\n<p>在 Linux 上，你有很多可以合并和排序存储在单独文件中的数据的方式。这些方法可以使原本繁琐的任务变得异常简单。</p>\n<hr />\n<p>via:&#160;<a href=\"https://www.networkworld.com/article/3570508/merging-and-sorting-files-on-linux.html\">https://www.networkworld.com/article/3570508/merging-and-sorting-files-on-linux.html</a></p>\n<p>作者：<a href=\"https://www.networkworld.com/author/Sandra-Henry_Stocker/\">Sandra Henry-Stocker</a>&#160;选题：<a href=\"https://github.com/lujun9972\">lujun9972</a>&#160;译者：<a href=\"https://github.com/geekpi\">geekpi</a>&#160;校对：<a href=\"https://github.com/wxy\">wxy</a></p>\n<p>本文由&#160;<a href=\"https://github.com/LCTT/TranslateProject\">LCTT</a>&#160;原创编译，<a href=\"https://linux.cn/\">Linux中国</a>&#160;荣誉推出</p>","descriptionType":"text/html","publishedDate":"Sat, 22 Aug 2020 02:23:31 +0000","feedId":909,"bgimg":"https://img.linux.net.cn/data/attachment/album/202008/22/102250i3943is48r34w4nz.jpg","linkMd5":"8c73f23886a025cac918a0a0e5ec7b2e","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn36@2020_3/2020/08/22/17-41-42-440_88aa96380e166520.webp","destWidth":1280,"destHeight":720,"sourceBytes":347980,"destBytes":123012,"author":"linux@linux.cn (linux)","articleImgCdnMap":{"https://img.linux.net.cn/data/attachment/album/202008/22/102250i3943is48r34w4nz.jpg":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn36@2020_3/2020/08/22/17-41-42-440_88aa96380e166520.webp"},"publishedOrCreatedDate":1598118098223},{"createdTime":"2020-08-23 01:41:38","updatedTime":"2020-08-23 01:41:38","title":"Photoflare：满足简单编辑需求的开源图像编辑器","link":"https://linux.cn/article-12538-1.html?utm_source=rss&utm_medium=rss","description":"<blockquote>\n<p>Photoflare 是一款可用于 Linux 和 Windows 上的图像编辑器。它有一个免费而开源的社区版本。</p>\n</blockquote>\n<p>在 Linux 上编辑图像时，GIMP 显然是首选。但是，如果你不需要高级编辑功能，GIMP 可能会让人不知所措。这是像 Photoflare 这样的应用立足的地方。</p>\n<h3 id=\"photoflare%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E5%83%8F%E7%BC%96%E8%BE%91%E5%99%A8\" class=\"mume-header\">PhotoFlare：一个简单的图像编辑器</h3>\n<p><img src=\"https://img.linux.net.cn/data/attachment/album/202008/21/233828npoopm43suckztpt.jpg\" alt=\"\" /></p>\n<p>Photoflare 是一个在简单易用的界面里提供了基本的图像编辑功能的编辑器。</p>\n<p>它受流行的 Windows 应用&#160;<a href=\"http://photofiltre.free.fr/frames_en.htm\">PhotoFiltre</a>&#160;的启发。这个程序不是一个克隆品，它是用 C++ 从头开始编写的，并使用 Qt 框架作为界面。</p>\n<p>它的功能包括裁剪、翻转/旋转、调整图像大小。你还可以使用诸如油漆刷、油漆桶、喷雾罐、模糊工具和橡皮擦之类的工具。魔术棒工具可让你选择图像的特定区域。</p>\n<p>你还可以在图像上添加线条和文本。你还可以更改图像的色调。</p>\n<p>你也可以像其他<a href=\"https://itsfoss.com/open-source-paint-apps/\">画图应用</a>一样从头开始创建图像。</p>\n<p>批处理编辑选项可让你同时为多张图片调整大小、转换文件格式和添加滤镜。</p>\n<p><img src=\"https://img.linux.net.cn/data/attachment/album/202008/21/233806a8u8urp9ujj6y9zp.png\" alt=\"Batch Editing Feature in Photoflare | Photo Credit: Photoflare website\" /></p>\n<h3 id=\"photoflare-%E7%9A%84%E5%8A%9F%E8%83%BD\" class=\"mume-header\">Photoflare 的功能</h3>\n<p>为了方便参考，我将列出 Photoflare 的主要功能：</p>\n<ul>\n<li>创建/绘制图像</li>\n<li>裁剪图像</li>\n<li>旋转图像</li>\n<li>调整图像大小</li>\n<li>使用画笔、油漆桶、喷涂、模糊工具和图像等工具编辑图像</li>\n<li>在图像上添加线条和文字</li>\n<li>更改图像的色调</li>\n<li>添加老照片滤镜</li>\n<li>批量调整大小、滤镜等</li>\n</ul>\n<h3 id=\"%E5%9C%A8-linux-%E4%B8%8A%E5%AE%89%E8%A3%85-photflare\" class=\"mume-header\">在 Linux 上安装 Photflare</h3>\n<p><img src=\"https://img.linux.net.cn/data/attachment/album/202008/21/233811cjuu7pdbye2uoqaq.png\" alt=\"\" /></p>\n<p>在 Photoflare 的网站上，你可以找到定价以及每月订阅的选项。但是，该应用是开源的，它的<a href=\"https://github.com/PhotoFlare/photoflare\">源码可在 GitHub 上找到</a>。</p>\n<p>应用也是&#8220;免费&#8221;使用的。<a href=\"https://photoflare.io/pricing/\">定价/订购部分</a>用于该项目的财务支持。你可以免费下载它，如果你喜欢该应用并且会继续使用，请考虑给它捐赠。</p>\n<p>Photoflare 有<a href=\"https://launchpad.net/~photoflare/+archive/ubuntu/photoflare-stable\">官方 PPA</a>，适用于 Ubuntu 和基于 Ubuntu 的发行版。此 PPA 可用于 Ubuntu 18.04 和 20.04 版本。</p>\n<p>打开终端，逐一输入下面的命令安装 Photoflare：</p>\n<pre class=\"prettyprint linenums\"><code>sudo add-apt-repository ppa:photoflare/photoflare-stable\nsudo apt update\nsudo apt install photoflare\n</code></pre>\n<p>要从基于 Ubuntu 的发行版中删除 Photoflare，请使用以下命令：</p>\n<pre class=\"prettyprint linenums\"><code>sudo apt remove photoflare\n</code></pre>\n<p>最好也删除 PPA：</p>\n<pre class=\"prettyprint linenums\"><code>sudo add-apt-repository -r ppa:photoflare/photoflare-stable\n</code></pre>\n<p>Arch Linux 和 Manjaro 用户可以<a href=\"https://aur.archlinux.org/packages/photoflare-git/\">从 AUR 获取</a>。</p>\n<p>Fedora 没有现成的软件包，因此你需要获取源码：</p>\n<ul>\n<li><a href=\"https://github.com/PhotoFlare/photoflare\">Photoflare 源代码</a></li>\n</ul>\n<h3 id=\"photoflare-%E7%9A%84%E7%BB%8F%E9%AA%8C\" class=\"mume-header\">Photoflare 的经验</h3>\n<p>我发现它与&#160;<a href=\"https://itsfoss.com/pinta-new-release/\">Pinta</a>&#160;有点相似，但功能更多。它是用于基本图像编辑的简单工具。批处理功能是加分项。</p>\n<p>我注意到图像在打开编辑时看起来不够清晰。我打开一张截图进行编辑，字体看起来很模糊。但是，保存图像并在<a href=\"https://itsfoss.com/image-viewers-linux/\">图像查看器</a>中打开后，没有显示此问题。</p>\n<p>总之，如果你不需要专业级的图像编辑，它是一个不错的工具。</p>\n<p>如果你曾经使用过或会去尝试它，请分享你的 Photoflare 使用经验。</p>\n<hr />\n<p>via:&#160;<a href=\"https://itsfoss.com/photoflare/\">https://itsfoss.com/photoflare/</a></p>\n<p>作者：<a href=\"https://itsfoss.com/author/abhishek/\">Abhishek Prakash</a>&#160;选题：<a href=\"https://github.com/lujun9972\">lujun9972</a>&#160;译者：<a href=\"https://github.com/geekpi\">geekpi</a>&#160;校对：<a href=\"https://github.com/wxy\">wxy</a></p>\n<p>本文由&#160;<a href=\"https://github.com/LCTT/TranslateProject\">LCTT</a>&#160;原创编译，<a href=\"https://linux.cn/\">Linux中国</a>&#160;荣誉推出</p>","descriptionType":"text/html","publishedDate":"Fri, 21 Aug 2020 15:37:00 +0000","feedId":909,"bgimg":"https://img.linux.net.cn/data/attachment/album/202008/21/233828npoopm43suckztpt.jpg","linkMd5":"a84243237277ad8925c9f33ad74dcc83","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn57@2020_5/2020/08/22/17-41-41-040_60df35e2bd53f5c6.webp","destWidth":800,"destHeight":450,"sourceBytes":20909,"destBytes":19426,"author":"linux@linux.cn (linux)","articleImgCdnMap":{"https://img.linux.net.cn/data/attachment/album/202008/21/233828npoopm43suckztpt.jpg":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn57@2020_5/2020/08/22/17-41-41-040_60df35e2bd53f5c6.webp","https://img.linux.net.cn/data/attachment/album/202008/21/233806a8u8urp9ujj6y9zp.png":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn81@2020_6/2020/08/22/17-41-59-824_67137ccb6bc14cea.webp","https://img.linux.net.cn/data/attachment/album/202008/21/233811cjuu7pdbye2uoqaq.png":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn87@2020_6/2020/08/22/17-41-58-940_7ea2b196e625aa12.webp"},"publishedOrCreatedDate":1598118098223},{"createdTime":"2020-08-23 01:41:38","updatedTime":"2020-08-23 01:41:38","title":"快来测试 Python 开发工具 pipenv 的新版本","link":"https://linux.cn/article-12540-1.html?utm_source=rss&utm_medium=rss","description":"<p><img src=\"https://img.linux.net.cn/data/attachment/album/202008/22/104612gfgllhf85mahvm3j.jpg\" alt=\"\" /></p>\n<p><a href=\"https://github.com/pypa/pipenv\">pipenv</a>&#160;是一个可帮助 Python 开发人员维护具有特定一组依赖关系的隔离虚拟环境，以实现可重新复制的开发和部署环境的工具。它类似于其他编程语言中的工具如 bundler、composer、npm、cargo、yarn 等。</p>\n<p>最近发布了新版本的 pipenv 2020.6.2。现在可以在 Fedora 33 和 Rawhide 中使用它。对于较旧的 Fedora，维护人员决定打包到&#160;<a href=\"https://copr.fedorainfracloud.org/coprs/g/python/pipenv/\">COPR</a>&#160;中来先进行测试。所以在他们把它推送到稳定的Fedora版本之前，来试试吧。新版本没有带来任何新颖的功能，但是经过两年的开发，它解决了许多问题，并且在底层做了很多不同的事情。之前可以正常工作的应该可以继续工作，但是可能会略有不同。</p>\n<h3 id=\"%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96\" class=\"mume-header\">如何获取</h3>\n<p>如果你已经在运行 Fedora 33 或 Rawhide，请运行&#160;<code>$ sudo dnf upgrade pipenv</code>&#160;或者&#160;<code>$ sudo dnf install pipenv</code>，你将获得新版本。</p>\n<p>在 Fedora 31 或 Fedora 32 上，你需要使用&#160;<a href=\"https://copr.fedorainfracloud.org/coprs/g/python/pipenv/\">copr 仓库</a>，直到经过测试的包出现在官方仓库中为止。要启用仓库，请运行：</p>\n<pre class=\"prettyprint linenums\"><code>$ sudo dnf copr enable @python/pipenv\n</code></pre>\n<p>然后将&#160;<code>pipenv</code>&#160;升级到新版本，运行：</p>\n<pre class=\"prettyprint linenums\"><code>$ sudo dnf upgrade pipenv\n</code></pre>\n<p>或者，如果尚未安装，请通过以下方式安装：</p>\n<pre class=\"prettyprint linenums\"><code>$ sudo dnf install pipenv\n</code></pre>\n<p>如果你需要回滚到官方维护的版本，可以运行：</p>\n<pre class=\"prettyprint linenums\"><code>$ sudo dnf copr disable @python/pipenv\n$ sudo dnf distro-sync pipenv\n</code></pre>\n<p><em>COPR 不受 Fedora 基础架构的官方支持。使用软件包需要你自担风险。</em></p>\n<h3 id=\"%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8\" class=\"mume-header\">如何使用</h3>\n<p>如果你有用旧版本&#160;<code>pipenv</code>&#160;管理的项目，你应该可以毫无问题地使用新版本。如果有问题请让我们知道。</p>\n<p>如果你还不熟悉&#160;<code>pipenv</code>&#160;或想开始一个新项目，请参考以下快速指南：</p>\n<p>创建一个工作目录：</p>\n<pre class=\"prettyprint linenums\"><code>$ mkdir new-project &#38;&#38; cd new-project\n</code></pre>\n<p>使用 Python 3 初始化&#160;<code>pipenv</code>：</p>\n<pre class=\"prettyprint linenums\"><code>$ pipenv --three\n</code></pre>\n<p>安装所需的软件包，例如：</p>\n<pre class=\"prettyprint linenums\"><code>$ pipenv install six\n</code></pre>\n<p>生成&#160;<code>Pipfile.lock</code>&#160;文件：</p>\n<pre class=\"prettyprint linenums\"><code>$ pipenv lock\n</code></pre>\n<p>现在，你可以将创建的&#160;<code>Pipfile</code>&#160;和&#160;<code>Pipfile.lock</code>&#160;文件提交到版本控制系统（例如 git）中，其他人可以在克隆的仓库中使用此命令来获得相同的环境：</p>\n<pre class=\"prettyprint linenums\"><code>$ pipenv install\n</code></pre>\n<p>有关更多示例，请参见&#160;<a href=\"https://pipenv.pypa.io/en/latest/install/\">pipenv 的文档</a>。</p>\n<h3 id=\"%E5%A6%82%E4%BD%95%E6%8A%A5%E5%91%8A%E9%97%AE%E9%A2%98\" class=\"mume-header\">如何报告问题</h3>\n<p>如果你使用新版本的&#160;<code>pipenv</code>&#160;遇到任何问题，请<a href=\"https://bugzilla.redhat.com/enter_bug.cgi?product=Fedora&#38;component=pipenv\">在 Fedora 的 Bugzilla中 报告问题</a>。Fedora 官方仓库和 copr 仓库中&#160;<code>pipenv</code>&#160;软件包的维护者是相同的人。请在报告中指出是新版本。</p>\n<hr />\n<p>via:&#160;<a href=\"https://fedoramagazine.org/come-test-a-new-release-of-pipenv-the-python-development-tool/\">https://fedoramagazine.org/come-test-a-new-release-of-pipenv-the-python-development-tool/</a></p>\n<p>作者：<a href=\"https://fedoramagazine.org/author/torsava/\">torsava</a>&#160;选题：<a href=\"https://github.com/lujun9972\">lujun9972</a>&#160;译者：<a href=\"https://github.com/geekpi\">geekpi</a>&#160;校对：<a href=\"https://github.com/wxy\">wxy</a></p>\n<p>本文由&#160;<a href=\"https://github.com/LCTT/TranslateProject\">LCTT</a>&#160;原创编译，<a href=\"https://linux.cn/\">Linux中国</a>&#160;荣誉推出</p>","descriptionType":"text/html","publishedDate":"Sat, 22 Aug 2020 02:46:00 +0000","feedId":909,"bgimg":"https://img.linux.net.cn/data/attachment/album/202008/22/104612gfgllhf85mahvm3j.jpg","linkMd5":"910f844c141fbd9f08e35ec2530bf6af","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx/cdn38@2020_5/2020/08/22/17-41-41-567_15561dd5e7baf80d.webp","destWidth":816,"destHeight":345,"sourceBytes":19039,"destBytes":10066,"author":"linux@linux.cn (linux)","articleImgCdnMap":{"https://img.linux.net.cn/data/attachment/album/202008/22/104612gfgllhf85mahvm3j.jpg":"https://cdn.jsdelivr.net/gh/myreaderx/cdn38@2020_5/2020/08/22/17-41-41-567_15561dd5e7baf80d.webp"},"publishedOrCreatedDate":1598118098223},{"createdTime":"2020-08-23 01:41:38","updatedTime":"2020-08-23 01:41:38","title":"《代码英雄》第一季（5）：容器竞赛","link":"https://linux.cn/article-12535-1.html?utm_source=rss&utm_medium=rss","description":"<blockquote>\n<p>代码英雄讲述了开发人员、程序员、黑客、极客和开源反叛者如何彻底改变技术前景的真实史诗。</p>\n</blockquote>\n<blockquote>\n<p><strong>什么是《代码英雄》</strong></p>\n<p><ruby>代码英雄<rt>Command Line Heroes</rt></ruby>是世界领先的企业开源软件解决方案供应商红帽（Red Hat）精心制作的原创音频播客，讲述开发人员、程序员、黑客、极客和开源反叛者如何彻底改变技术前景的真实史诗。该音频博客邀请到了谷歌、NASA 等重量级企业的众多技术大牛共同讲述开源、操作系统、容器、DevOps、混合云等发展过程中的动人故事。</p>\n</blockquote>\n<p><img src=\"https://img.linux.net.cn/data/attachment/album/202008/21/000308a577z40hqta5qhpg.png\" alt=\"\" /></p>\n<p>本文是《<a href=\"https://www.redhat.com/en/command-line-heroes\">代码英雄</a>》系列播客<a href=\"https://www.redhat.com/en/command-line-heroes/season-1/the-containers-derby\">第一季（5）：容器竞赛</a>的<a href=\"https://dts.podtrac.com/redirect.mp3/audio.simplecast.com/3aed4d5c.mp3\">音频</a>脚本。</p>\n<p><audio src=\"https://dts.podtrac.com/redirect.mp3/audio.simplecast.com/3aed4d5c.mp3\" controls=\"controls\"></audio></p>\n<p>容器的兴起为开发者们打开了一道新的大门，它简化了在机器与机器之间传递项目的成本。随着它变得广受欢迎，一场大战也悄悄拉开帷幕。这场战斗的奖品是容器编排的控制权，参赛者包括这个行业最快最强的玩家。</p>\n<p>容器是开源运动中最重要的一项突破之一。在这一集里，特邀嘉宾 Kelsey Hightower、Laura Frank 和 Clayton Coleman 将告诉我们容器如何为未来添砖加瓦，以及编排技术为何如此重要。</p>\n<p><strong>Saron Yitbarek</strong>：</p>\n<p>你有看过赛马吗？赛马们排成一行，蹄子刨着脚下的土壤。你可以想象出这么一副画面。比赛即将开始，在这些竞争者中脱颖而出的将是优胜者。</p>\n<p><strong>00:00:30</strong>：</p>\n<p>不同的是，比赛的不是马。而是科技世界的诸侯。那么是什么让比赛如此重要？是怎样的珍贵的奖励，才会让这些参赛者们排着队，迫不及待地想要得到它? 这是一场赢家将掌握容器编排技术规则的竞赛，而且胜利者只有一个。重要的是，不同于其他的比赛，赢得这场比赛，你不仅仅会成为今天的冠军，更有可能在来持续领先。</p>\n<p><strong>00:01:30</strong>:</p>\n<p>我是 Saron Yitbarek，这里是代码英雄，一款红帽公司原创的博客。</p>\n<p>第五集，容器竞赛。<a href=\"https://linux.cn/article-12529-1.html\">上一集</a>我们见证了 DevOps 的崛起，以及一组新工具如何影响了其他人对开发者这一概念的看法。在这一集栏目中，我们会追溯容器技术崛起的历史，讲述容器技术如何通过拥有支持全新工作的可能性，来进一步扩展开发者这一角色的概念。然后我们会一起见证容器标准化是如何为容器编排奠定比赛基础的。</p>\n<p><strong>00:01:30</strong>：</p>\n<p>这是一场严肃的比赛，也是一场全球性的比赛，吸引了行业里最快，最强大的选手。他们都准备好了为冲刺终点线而奋力一搏。准备好了吗? 比赛开始了！</p>\n<p>现在，随着这些&#8220;赛马&#8221;离开起点，也许我们应该弄清楚为什么这场比赛如此重要。谁会关心容器呢？好吧，算我一个。但是实际上，一开始我也并不知道容器是什么。以下我将讲述一个小故事 &#8212;&#8212; 我是如何醒悟容器之美的。</p>\n<p><strong>00:02:00</strong>：</p>\n<p>不久之前，我还在为我网站写代码，然后有天我让我的朋友 Nadia 过来实现一些新的功能。我在保持代码干爽和可读性方面做得很好，当然，代码也经过了很好的测试。所以再加入一个新的网站开发者也不是一件难事。对吗？如果你也这样以为，那就错了。这是一个非常繁琐的过程，特别是当我们跑规范化测试时，这个问题尤为明显。</p>\n<p><strong>00:02:30</strong>：</p>\n<p>代码运行正常，但我们不能在两台电脑上同时通过所有测试。我们有很奇怪的电脑时区设置问题，而且她的 Ruby on Rails 版本跟我的不同。就是一个很经典的问题：&#8220;我的电脑上可以代码运行&#8221;，&#8220;可是在我的电脑上就是不行&#8221;。我只好对代码做一些修改，直到它在我这里正常运行，但当我把它发送给 Nadia 时，程序又会崩溃。</p>\n<p><strong>00:03:00</strong>：</p>\n<p>我很清楚，我和 Nadia 所碰到的这些问题，对于所有的开发者来说都或多或少经历过，甚至他们把这种经历当作玩笑来讲。有时候，我只能把这个当做是在我工作时必须要忍受的一部分。我没有意识到的是，这个问题有个最终解决办法。想象有一种方式可以降低人与人之间的隔阂；想象有一种方法可以让我们在开发中使用任意喜欢的工具，并且在传递工作成果时毫无阻碍；想象一下有一种办法，无论有多少人同时进行一个项目的开发，不管这些人散布在世界何地，都可以让项目从开发到测试，再到生产环境，保持连贯性。如果在我浪费好几周，用最笨的方式传递工作成果前就想到了容器该多好。</p>\n<p><strong>00:03:30 - Liz Rice</strong>：</p>\n<p>一个容器实际上就是一个进程。</p>\n<p><strong>Saron Yitbarek</strong>：</p>\n<p>Liz Rice 是 Aqua Security 的一名技术布道师。她描述了为何容器会如此实用。事实上容器把一切打包到了一个整洁、并且可以迁移的包中。</p>\n<p><strong>00:04:00 - Liz Rice</strong>：</p>\n<p>这就像任何其他的进程一样，不同的是容器的世界非常小。比如，如果你启动一个容器，进程会被授予它自己的根目录。然后它认为自己在查看的是整台计算机的根目录，但实际上它只是在查看这个文件系统很小的一个子集。</p>\n<p><strong>00:04:30 - Saron Yitbarek</strong>：</p>\n<p>通过打包一个可执行文件及其所有的依赖，容器可以在任何笔记本或者云中的虚拟机上运行。带着它自己的执行文件、库和依赖。所有的一切都包含在了容器中。所以，这就是容器神奇之处，容器在每个环境中的运行都会完全一样。这也就意味着开发者可以轻松地分享并协作应用开发，而不用担心计算机之间相互不兼容这个老问题。</p>\n<p><strong>00:05:00</strong>：</p>\n<p>举一个类比的例子希望能够帮助你理解。你有听说过<ruby>蓝围裙<rt>Blue Apron</rt></ruby>这个服务吗？该服务提供你做饭所需的一切，包括精心按照菜谱卡片搭配好的，所有做饭需要的原料。好的，想象一下如果蓝围裙所能带给你的不仅仅只是还没有处理过的食材，而是一整个厨房，有煤气灶，还有你所需要的全部餐具，一切你需要的都会装到小盒子里，放在门阶上。这就是一个容器。在我提到的那种情况下，容器技术就可以很好地解决 Nadia 加入进来时所碰到的问题，简单到像使用蓝围裙服务做一顿晚餐一样。虚拟机同样也可以提供一个预装好的环境。但要解释这个，我们就不得不抛弃蓝围裙这个比喻，让我们来看一看具体的细节。</p>\n<p><strong>00:05:30 - Liz Rice</strong>：</p>\n<p>许多人都认为容器是某种轻量级的虚拟化技术、轻量级的虚拟机，事实上并不是。容器与虚拟机有很大不同。虚拟机有独属于自己的一整个操作系统，相比起来容器是共享操作系统的。一个计算机上的所有容器共享同一个操作系统的。</p>\n<p><strong>00:06:00 - Saron Yitbarek</strong>：</p>\n<p>最后一点，容器和虚拟机可以并肩工作。容器不能替代虚拟机。虚拟化技术仍然可以提高过时系统的效率，并且对于服务器整合非常关键。但容器技术的兴起也为我们打开了新的大门。不妨这样想，如果我们全部依靠虚拟机的话，运行所有仿真服务器将产生大量的额外负担。</p>\n<p><strong>00:06:30</strong>：</p>\n<p>一台虚拟机的大小至少是以 G 为单位的，然而一个容器可能也就只有 20 M 左右。一台虚拟机可能会需要若干分钟来启动，如果我尝试用它部署一个网页应用的话，这可不是一个好消息。很长时间以来，人们都期盼一个轻量级的、更快速的完整机器虚拟化替代方案出现。</p>\n<p><strong>00:00:07</strong>：</p>\n<p>回顾一下历史，1979 年就出现了容器的原型。Unix V7 的开发者们设计了一种根系统调用，使环境中只包括特定的程序。该突破为我们现在看到的容器技术指明了道路。另一个巨大的进展来源于 2008 年的 Linux 容器技术。现在，我们有了操作系统级的虚拟化技术。</p>\n<p><strong>00:07:30</strong>：</p>\n<p>我们终于可以在一个单独的 Linux 内核上运行多个容器，而无需使用完整的虚拟机。这也就意味着程序对于基础架构的需求逐渐减少，但不是每一个人都能立马看到容器技术的潜力。</p>\n<p><strong>Laura Frank</strong>：</p>\n<p>容器化真的是前所未有的、崭新的一个天才般的想法。</p>\n<p><strong>Saron Yitbarek</strong>：</p>\n<p>Laura Frank 是 CloudBees 的技术总监。</p>\n<p><strong>00:08:00 - Laura Frank</strong>：</p>\n<p>只有少部分人了解容器技术的来龙去脉，并可以运用它。不过相信随着时间的推移越来越多的人会接触到容器化的概念，随着越来越多的人开始使用这项技术，并且这些知识通过工程团队和工程组织，通过社区进行传播，就会变得更容易获得。</p>\n<p><strong>Saron Yitbarek</strong>：</p>\n<p>因为和我们之前提到的与虚拟机的相似性，Laura 认为，因为我们之前提到的容器技术与虚拟机的相似性，容器的潜力被低估了。</p>\n<p><strong>00:08:30 - Laura Frank</strong>：</p>\n<p>我在回想我的职业生涯，那是我还只是个普通的日常技术人员。如果你不是一个系统管理员或者 Linux 资深用户的话，容器还是一个你刚刚了解到的全新概念。我把它理解为使用一台虚拟机模式类似的东西，我可以去建立一个可以用完即弃的环境，而且这个环境完全独立，清理之后不留痕迹。</p>\n<p><strong>Saron Yitbarek</strong>：</p>\n<p>容器除了能保持系统整洁之外，其实还大有可为。容器将会革新整个行业，并且随着开源项目和社区的兴起，在不久之后，容器标准化的充分实施将变为可能。</p>\n<p><strong>00:09:00 - Scott McCarty</strong>：</p>\n<p>整个界面已经变得非常简单。</p>\n<p><strong>Saron Yitbarek</strong>：</p>\n<p>Scott McCarty 是红帽的一名资深的容器策略顾问。他称得上是这个行业的资深人士，他在容器出现前，甚至是虚拟机出现前，就在做这方面的工作了。</p>\n<p><strong>00:09:30 - Scott McCarty</strong>：</p>\n<p>在互联网 1.0 时代，我在一家线上零售商工作，我们有上千台实体机，我们用不同的方式，在所有这些不同的服务器上一遍又一遍地安装相同的软件。我们尝试了所有的方法。当你从原始的操作系统迁移到虚拟机，然后再到 Linux 容器、Solaris 容器，同样的问题一再出现，你仍然不得不在不同的虚拟机，或者类似操作系统实例的结构体之间管理配置。</p>\n<p><strong>Saron Yitbarek</strong>：</p>\n<p>一旦容器变的规范化，一切都将改变。</p>\n<p><strong>00:10:00 - Scott McCarty</strong>：</p>\n<p>比如，有了很多非常标准化的方式可以去处理现在这些打包好的应用，我认为容器技术的出现，从根本上改变了一切。它使得那些应用非常容易使用，而且容器还不会对系统本身造成损害，同时相比虚拟机更加小巧快捷。</p>\n<p><strong>00:10:30 - Saron Yitbarek</strong>：</p>\n<p>借助 Linux 容器带来的进步，这些新的开源项目和社区使得开发者们可以更好地携手合作。很多我们对于后端的焦虑都被一扫而光。突然间，容器和由它促进的微服务变得十分有吸引力。一旦一种共同的容器语言出现了，障碍就消失了，与此同时容器技术改变了我们的工作方式，也改变了我们学习新技术的步伐。</p>\n<p><strong>00:11:00</strong>：</p>\n<p>还记得之前我和同事 Nadia 遇到的反复出现的问题吗？&#8220;在我这代码能跑&#8221;的场景？在容器的世界，这个问题将不复存在。相比于我们之前使用的标准的操作系统，开发者社区见证了容器是如何变得更加快速，成本低廉，并且容易使用的 &#8212;&#8212; 比传统操作系统更加容易。容器技术被采纳的速度十分惊人。但是要记得：容器标准的出现仅仅是容器编排这场竞赛的热身。</p>\n<p>赛马们已经整齐排列好，随着信号枪一声令下，它们为了这场比赛的冠军而拼尽全力。竞争的不是容器本身，而是我们部署和管理容器所使用的工具。</p>\n<p><strong>00:11:30</strong>：</p>\n<p>我是 Saron Yitbarek，这里是代码英雄。在这场标准容器编排竞赛中，哪位会胜出成为管理所有容器的平台呢？起初有两位竞争者处于领先地位。</p>\n<p><strong>00:12:00</strong>：</p>\n<p>由 Apache 驾驭的 Swarm，和 Docker 驾驭的 Mesos。但是等等，怎么？现在出现了一匹黑马改变了这个格局，那就是谷歌。Linux 设立了云原生计算基金会（CNCF），随后 CNCF 推动了谷歌开源的编排引擎 Kubernetes。</p>\n<p><strong>00:12:30</strong>：</p>\n<p>现在，相比 Kubernetes，Mesos 和 Swarm 已经抢占了先机，对吗？它们得到了 Apache 和 Docker 的支持，已经入场了一段时间了。但是 Kubernetes 有其他的&#8220;赛马&#8221;所不具备的优势。Clayton Coleman 会告诉我们这个秘密是什么。Clayton 是红帽负责 Kubernetes 和 OpenShift 的一名架构师。</p>\n<p><strong>00:13:00 - Clayton Coleman</strong>：</p>\n<p>在 Kubernetes 诞生之初，谷歌就在项目的开放上做的很好，它降低了项目的贡献和参与的难度。谷歌极其关注让开发者和运维人员能更加容易地开展工作。有这样一个强烈的关注点，就是要做一个能让大多数开发者和运维的生活更轻松的东西。我觉得 Kubernetes 和围绕着Kubernetes 的社区找到了一个足够好的方式，让大部分人参与进来，他们让 Kubernetes 具有足够的可扩展性，还可以解决一些极端的用例。</p>\n<p><strong>Saron Yitbarek</strong>：</p>\n<p>在早期，来自于红帽、CoreOS 和谷歌的工程师们都参与到了 Kubernetes 的开发中。随着 Kubernetes 开发到 1.0，不管是初创公司还是大公司都参与其中，一起构建和完善它。关键的是，所有这些增长从来都不是只归功于谷歌或者任何一方。</p>\n<p><strong>00:13:30 - Clayton Coleman</strong>：</p>\n<p>在这个例子中，我喜欢以 Linux 打比方。Linux 并不是始于 Linus 开始编写内核，然后告诉所有人，在用户空间如何写 GCC，如何去建立 NGINX 或者 Apache。相反，内核团队专注于建立一个高效的操作系统内核，并与其他诸如 GNU 项目的开源社区合作，并且将可以在其他 Unix 系统上工作的工具引入 Linux。</p>\n<p><strong>00:14:00</strong>：</p>\n<p>因此，我们如今所使用的许多工具，都不是 Linux 核心团队交付的。</p>\n<p>但是 Linux 作为一个整体，相比于其内核涵盖的范围要宽泛得多，而且我认为这种模式的优势是 Kubernetes 取得现在成就所不可或缺的。当我们建立社区并且专注于 Kubernetes 范围时，我们可以试图从&#8220;Kubernetes 内核&#8221;的角度来考虑它，这是分布式集群操作系统的内核。</p>\n<p><strong>00:14:30 - Saron Yitbarek</strong>：</p>\n<p>Kubernetes 证明了自己在开源世界中建立社区的能力，令人难以置信。正如我们在操作系统之战中谈到的 Linux 崛起一样，现如今这场关于容器的战争中，获胜者往往懂得如何借助社区力量。事实上，尽管谷歌可能开创了 Kubernetes，但目前它属于每一位开发者，并由云原生计算基金会（CNCF）管理。</p>\n<p><strong>00:15:00</strong>：</p>\n<p>在 GitHub 上，Kubernetes 有大约 3 万的星标数，而 Swarm 和 Mesos 只有数千，这已经很能说明问题了。这就是由社区所生，为社区所用的技术。</p>\n<p>我想了解谷歌的态度，一个如此庞大并且以效益为导向的大公司，是怎么做到如此擅长跟其他开发者合作的呢？我找到了很适合回答这个问题的人 &#8212;&#8212; Kelsey Hightower，他是谷歌负责容器技术支持的技术专家。</p>\n<p><strong>00:15:30</strong>：</p>\n<p>想想谷歌的地位：它在分布式系统领域具备丰富的经验，还运行着分布在世界各地的许许多多的服务器，因此它开发的 Kubernetes 似乎有着很大的优势，并且有信心一定能在这场容器竞赛中胜出。那么，当你想到 Kubernetes 和开源时，你是如何看待这种关系的？</p>\n<p><strong>00:16:00 - Kelsey Hightower</strong>：</p>\n<p>我想当谈到基础架构工具，甚至编程语言时，大家没有什么选择 &#8212;&#8212; 你不可能用个专有工具，即使它很棒。如果它不是开源的，大多数人可能甚至都不会想去了解。而且我认为这也是大多数人会采用像 Kubernetes 这样的基础架构工具的原因，你可能会对自己说：&#8220;好吧，我们就要坚持使用这个版本四、五年，也可能我们需要根据自己的一些独特需求来对其进行修改。&#8221;</p>\n<p><strong>00:16:30</strong>：</p>\n<p>一旦走到这一步，就很难说服企业接受，&#8220;嘿，每台服务器使用程序的价格是 200 美元，而且你看不到源代码，所以有需要的话也必须等我们来修改&#8221;。</p>\n<p>那样的日子一去不复返了，所以我不确定是否真的可以在没有开源的情况下建立基础架构。开源的另一个意味是拥有一个与项目紧密联合的社区，所以我认为 Kubernetes 一开始就锁定了胜利。</p>\n<p><strong>Saron Yitbarek</strong>：</p>\n<p>让我们回到这场容器竞赛。在这里不仅仅有你提到的 Kubernetes，还有 Docker 的 Swarm Apache 的 Mesos&#8230;&#8230;</p>\n<p><strong>00:17:00 - Kelsey Hightower</strong>：</p>\n<p>所以，我想当人们谈论容器竞赛时，我不确定竞争是否发生在我们和 Mesos、Docker 使用者之间。我认为，真正的竞争发生在争取目前没有使用容器的潜在用户身上。是的，你还在使用原生 Bash 脚本，你迷茫着，不知道自己该归属何方。这些尚未选择编排工具和平台之人的市场，比起已选择了 Mesos 或 Swarm 的一方，要多得多。</p>\n<p><strong>00:17:30</strong>：</p>\n<p>这就是容器战争存在并将继续的原因，真正的关键点在于如何帮助最终用户。Mesos、Kubernetes 或 Docker Swarm 是否会成为寻求更好解决方案的人们的首选？这一切都还悬而未决（SIG 译注：现在已经尘埃落定，Kubernetes 取得了全胜），但我会告诉你，像我一样，在这个领域工作的工程师来说，如果你不考虑市场营销和供应商，我会使用这个短语&#8220;不同的公司，相同的团队。&#8221;</p>\n<p><strong>00:18:00</strong>：</p>\n<p>我们为彼此开发了许多工具，最终以某种方式出现在其他产品中。没错吧？好主意就是好主意。没有理由说，&#8220;哦，这是 Mesos 的人正在做的事情，那就忽略吧&#8221;，这有点愚蠢。所以从技术和社区的角度来看，我们的想法需要交流。同时也需要竞争来迫使我们来进行独立思考，然后最棒的点子就会浮出水面，接着我们再选择采用哪种方式来正确满足用户的需要。</p>\n<p><strong>00:18:30</strong>：</p>\n<p>因此，就这场竞赛而言，仍处于初期阶段，而且这个事情本身不会带来利润。明白我的意思吗？我们不是直接向任何人销售这个产品，这更像是一个平台之间的游戏，对所有人开放，然后用户会选择满足他们需求的那个，这就是我认为 Kubernetes 在社区方面做得很好的地方，真正开放，真正能解决实际问题。</p>\n<p><strong>Saron Yitbarek</strong>：</p>\n<p>听起来很棒啊。我喜欢这个想法：在同一个球队踢球，而不要管球队是在什么地方。你对于容器和编排工具，还有 Kbubernetes 的未来有什么展望吗？</p>\n<p><strong>00:19:00 - Kelsey Hightower</strong>：</p>\n<p>是的，我在 KubeCon 上做了一次主题演讲。所有这些工具都很棒，它们就像是乐高积木，我们有 Kubernetes，你可以选择一种产品用于安全，选择另一种产品用于网络，但最终，作为开发人员而言，你所想要的只是检查你的代码，并希望你的代码可以某种方式以呈现在客户面前。而我认为 Kubernetes 还有容器都会作为底层技术或者成为类似 Serverless 这种技术的基础平台。</p>\n<p><strong>00:19:30</strong>：</p>\n<p>这是我的代码片段，已经打包完毕了。所有的平台都会把你的代码片段，用容器包装起来，然后帮你运行，但是不需要向你公开所有这些过程。因此，在未来，我认为随着 Kubernetes 变得普及，容器的应用场景将从大大小小的供应商或个人，提升到云供应商，因为这些事情往往需要专业知识和软件投资。容器将会遍布各个角落，但同时也就此隐藏起来。它会随着应用场景的扩展而渐渐隐形。</p>\n<p><strong>00:20:00 - Saron Yitbarek</strong>：</p>\n<p>Kelsey Hightower 是 Google 的员工开发人员。在 2017 年秋天，Docker 宣布支持 Kubernetes。他们并不是说就放弃 Swarm 了，只是决定与容器编排竞赛的明显赢家和解。</p>\n<p><strong>00:20:30</strong>：</p>\n<p>并不只有它一方，Azure 和 AWS 都宣布了对 Kubernetes 的支持。与此同时，像 OpenShift 这样的 Kubernetes 发行版仍在不断发展。我们得到的是一个可以扩展，支持新的用例的 Kubernetes 内核，这些用例包括微服务或持续集成项目。</p>\n<p><strong>00:21:00 - Clayton Coleman</strong>：</p>\n<p>这个生态系统在类似 Linux 的模式下能得到最好的发展，而且我认为我们正朝着这条道路迈进。因此，就像所有优秀的开源项目一样，相对于单打独斗，让每个人都能够参与进来构建更好的东西，那就算是成功了。</p>\n<p><strong>00:21:30 - Saron Yitbarek</strong>:</p>\n<p>所有这一切都在快速发生着，毕竟，这是一场竞赛，而这正是我们期望能从开源中获得的东西。在我们才刚刚理解什么是容器时，第一轮几乎就结束了，</p>\n<p>这是来自 Red Hat 的 Scott McCarty。</p>\n<p><strong>Scott McCarty</strong>：</p>\n<p>回想一下两年前，容器镜像格式还是一个巨大的战场，然后回到六个月至一年前，容器编排就成为了下一个巨大的战场。紧接着，如果你看看 2017 年的 KubeCon 及前几周，几乎每个主要供应商都宣布支持 Kubernetes。因此，很明显 Kubernetes 在这一方面上获胜了。</p>\n<p><strong>00:22:00 - Saron Yitbarek</strong>：</p>\n<p>这章关于容器战争的故事即将结束。就像容器技术的开始一样迅速。</p>\n<p><strong>Scott McCarty</strong>：</p>\n<p>因此，Kubernetes 已经成为标准，其美妙之处是，现在的应用定义已经变得标准化了。因此，任何人都可以在这些 YAML 文件中使用 Kubernetes 对象并定义应用，这就是我们共同所追求的事情。事实上，对于容器技术足够处理处理大型扩展系统这件事，我已经期待了 20 年。</p>\n<p><strong>00:22:30 - Saron Yitbarek</strong>：</p>\n<p>Kubernetes 的成功看起来板上钉钉，但即使竞赛尘埃落定，我们仍然面临更大的一些问题。容器是否会成为未来几年的默认选择？是否会促使更多的云原生开发？这些转变将促生哪些工具和服务上？以下是我们目前所知道的。</p>\n<p><strong>00:23:00</strong>：</p>\n<p>社区将通过 CNCF 继续改进 Kubernetes，并作为它最重要的使命之一，我们将建立一套全新的容器技术。</p>\n<p>容器已经催生了大量新的基础设施，伴随而来的是全新的服务的需求。举个例子让你感受下容器的整合程度和发展速度，仅 Netflix 每周就运行超过一百万个容器。毫不夸张得说，容器是未来的构件。</p>\n<p><strong>00:23:30</strong>：</p>\n<p>这一整季的栏目中，我们一直在追踪开源运动的演变。首先看到 Linux 如何主导战场，以及开源理念是如何改变商业、工作流程和每日使用的工具。容器真的是开源运动中最重要的里程碑之一。它们具有很好的迁移性、轻量、易于扩展。</p>\n<p><strong>00:24:00</strong>：</p>\n<p>容器技术很好地体现了开源的优势，开源项目自然而然也推动了容器技术的发展。这是一个全新的世界，我们不用再担心从不同计算机或者云间的迁移产生的隔阂。</p>\n<p><strong>00:24:30</strong>：</p>\n<p>容器的标准化比任何人预测的都要快。接下来的一集，我们将转向另一场悬而未决的战争。这场云间战争史无前例地催生者行业重量级人物。微软、阿里巴巴、谷歌和亚马逊四家云供应商的摩擦正在升温，随之而来的将是一场暴风骤雨。我们将会追随它们激发的闪电，和广受欢迎的几位代码英雄一起探讨云间战争。</p>\n<p><strong>00:25:00</strong>：</p>\n<p>《代码英雄》是红帽公司推出的原创播客栏目。想要了解更多关于本期节目和以往节目的信息，请访问&#160;<a href=\"http://redhat.com/commandlineheroes\">redhat.com/commandlineheroes</a>&#160;。在那里，你还可以注册我们的新闻资讯。想免费获得新剧集的自动推送，请务必订阅该节目。</p>\n<p>只要在苹果播客、Spotify、Google Play、CastBox 中搜索 &#8220;Command Line Heroes&#8221;，或者通过其他方式收听，并点击订阅，这样你就能在第一时间知道最新剧集。我是 Saron Yitbarek。感谢您的收听，编程不止。</p>\n<hr />\n<p>via:&#160;<a href=\"https://www.redhat.com/en/command-line-heroes/season-1/the-containers-derby\">https://www.redhat.com/en/command-line-heroes/season-1/the-containers-derby</a></p>\n<p>作者：<a href=\"https://www.redhat.com/en/command-line-heroes\">Red Hat</a>&#160;选题：<a href=\"https://github.com/bestony\">bestony</a>&#160;译者：<a href=\"https://github.com/lujun9972\">lujun9972</a>&#160;校对：<a href=\"https://github.com/acyanbird\">acyanbird</a></p>\n<p>本文由&#160;<a href=\"https://github.com/LCTT/LCRH\">LCRH</a>&#160;原创编译，<a href=\"https://linux.cn/\">Linux中国</a>&#160;荣誉推出</p>","descriptionType":"text/html","publishedDate":"Thu, 20 Aug 2020 16:02:00 +0000","feedId":909,"bgimg":"https://img.linux.net.cn/data/attachment/album/202008/21/000308a577z40hqta5qhpg.png","linkMd5":"d2fa99f329c78a141630b4928f070df2","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn52@2020_4/2020/08/22/17-41-53-489_29109883ee980232.webp","destWidth":2000,"destHeight":1125,"sourceBytes":310153,"destBytes":138302,"author":"linux@linux.cn (linux)","articleImgCdnMap":{"https://img.linux.net.cn/data/attachment/album/202008/21/000308a577z40hqta5qhpg.png":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn52@2020_4/2020/08/22/17-41-53-489_29109883ee980232.webp"},"publishedOrCreatedDate":1598118098225},{"createdTime":"2020-08-23 01:41:38","updatedTime":"2020-08-23 01:41:38","title":"5 个开源的 Java IDE 工具","link":"https://linux.cn/article-12542-1.html?utm_source=rss&utm_medium=rss","description":"<blockquote>\n<p>Java IDE 工具提供了大量的方法来根据你的独特需求和偏好创建一个编程环境。</p>\n</blockquote>\n<p><img src=\"https://img.linux.net.cn/data/attachment/album/202008/22/235441wnnorcvo4olasv8o.jpg\" /></p>\n<p>通过简化程序员的工作，<a href=\"https://opensource.com/resources/java\">Java</a>&#160;框架可以使他们的生活更加轻松。这些框架是为了在各种服务器环境上运行各种应用程序而设计开发的；这包括解析注解、扫描描述符、加载配置以及在 Java 虚拟机（JVM）上启动实际的服务等方面的动态行为。控制这么多的任务需要更多的代码，这就很难降低内存占用、加快新应用的启动时间。无论如何，据&#160;<a href=\"https://www.tiobe.com/tiobe-index/\">TIOBE 指数</a>，在当今使用的编程语言中 Java 一直排名前三，拥有着 700 万到 1000 万开发者的社区。</p>\n<p>有这么多用 Java 编写的代码，这意味着有一些很好的集成开发环境（IDE）可供选择，可以为开发人员提供有效地编写、整理、测试和运行 Java 应用程序所需的所有工具。</p>\n<p>下面，我将按字母顺序介绍五个我最喜欢的用于编写 Java 的开源 IDE 工具，以及如何配置它们的基本功能。</p>\n<h3 id=\"bluej\" class=\"mume-header\">BlueJ</h3>\n<p><a href=\"https://www.bluej.org/about.html\">BlueJ</a>&#160;为 Java 初学者提供了一个集成的教育性 Java 开发环境。它也可以使用 Java 开发工具包（JDK）开发小型软件。各种版本和操作系统的安装方式都可以在<a href=\"https://www.bluej.org/versions.html\">这里</a>找到。</p>\n<p>在笔记本电脑上安装 BlueJ IDE 后，启动一个新项目，点击<ruby>项目<rt>Project</rt></ruby>菜单中的<ruby>新项目<rt>New Project</rt></ruby>，然后从创建一个<ruby>新类<rt>New Class</rt></ruby>开始编写 Java 代码。生成的示例方法和骨架代码如下所示：</p>\n<p><img title=\"BlueJ IDE screenshot\" src=\"https://img.linux.net.cn/data/attachment/album/202008/22/235549gxbh4zo0szvtzxsx.png\" alt=\"BlueJ IDE screenshot\" /></p>\n<p>BlueJ 不仅为学校的 Java 编程课的教学提供了一个交互式的图形用户界面（GUI），而且可以让开发人员在不编译源代码的情况下调用函数（即对象、方法、参数）。</p>\n<h3 id=\"eclipse\" class=\"mume-header\">Eclipse</h3>\n<p><a href=\"https://www.eclipse.org/ide/\">Eclipse</a>&#160;是桌面计算机上最著名的 Java IDE 之一，它支持 C/C++、JavaScript 和 PHP 等多种编程语言。它还允许开发者从 Eclipse 市场中的添加无穷无尽的扩展，以获得更多的开发便利。<a href=\"https://www.eclipse.org/\">Eclipse 基金会</a>提供了一个名为&#160;<a href=\"https://opensource.com/article/19/10/cloud-ide-che\">Eclipse Che</a>&#160;的 Web IDE，供 DevOps 团队在多个云平台上用托管的工作空间创建出一个敏捷软件开发环境。</p>\n<p><a href=\"https://www.eclipse.org/downloads/\">可以在这里下载</a>；然后你可以创建一个新的项目或从本地目录导入一个现有的项目。在<a href=\"https://opensource.com/article/19/10/java-basics\">本文</a>中找到更多 Java 开发技巧。</p>\n<p><img title=\"Eclipse IDE screenshot\" src=\"https://img.linux.net.cn/data/attachment/album/202008/22/235606vcjq3h4n0qjilqqw.png\" alt=\"Eclipse IDE screenshot\" /></p>\n<h3 id=\"intellij-idea\" class=\"mume-header\">IntelliJ IDEA</h3>\n<p><a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA CE（社区版）</a>是 IntelliJ IDEA 的开源版本，为 Java、Groovy、Kotlin、Rust、Scala 等多种编程语言提供了 IDE。IntelliJ IDEA CE 在有经验的开发人员中也非常受欢迎，可以用它来对现有源码进行重构、代码检查、使用 JUnit 或 TestNG 构建测试用例，以及使用 Maven 或 Ant 构建代码。可在<a href=\"https://www.jetbrains.org/display/IJOS/Download\">这里</a>下载它。</p>\n<p>IntelliJ IDEA CE 带有一些独特的功能；我特别喜欢它的 API 测试器。例如，如果你用 Java 框架实现了一个 REST API，IntelliJ IDEA CE 允许你通过 Swing GUI 设计器来测试 API 的功能。</p>\n<p><img title=\"IntelliJ IDEA screenshot\" src=\"https://img.linux.net.cn/data/attachment/album/202008/22/235634skhtta9tnnhxkrok.png\" alt=\"IntelliJ IDEA screenshot\" /></p>\n<p>IntelliJ IDEA CE 是开源的，但其背后的公司也提供了一个商业的终极版。可以在<a href=\"https://www.jetbrains.com/idea/features/editions_comparison_matrix.html\">这里</a>找到社区版和终极版之间的更多差异。</p>\n<h3 id=\"netbeans-ide\" class=\"mume-header\">Netbeans IDE</h3>\n<p><a href=\"https://netbeans.org/\">NetBeans IDE</a>&#160;是一个 Java 的集成开发环境，它允许开发人员利用 HTML5、JavaScript 和 CSS 等支持的 Web 技术为独立、移动和网络架构制作模块化应用程序。NetBeans IDE 允许开发人员就如何高效管理项目、工具和数据设置多个视图，并帮助他们在新开发人员加入项目时使用 Git 集成进行软件协作开发。</p>\n<p><a href=\"https://netbeans.org/downloads/8.2/rc/\">这里</a>下载的二进制文件支持 Windows、macOS、Linux 等多个平台。在本地环境中安装了 IDE 工具后，新建项目向导可以帮助你创建一个新项目。例如，向导会生成骨架代码（有部分需要填写，如&#160;<code>// TODO 代码应用逻辑在此</code>），然后你可以添加自己的应用代码。</p>\n<h3 id=\"vscodium\" class=\"mume-header\">VSCodium</h3>\n<p><a href=\"https://vscodium.com/\">VSCodium</a>&#160;是一个轻量级、自由的源代码编辑器，允许开发者在 Windows、macOS、Linux 等各种操作系统平台上安装，是基于&#160;<a href=\"https://opensource.com/article/20/6/open-source-alternatives-vs-code\">Visual Studio Code</a>&#160;的开源替代品。其也是为支持包括 Java、C++、C#、PHP、Go、Python、.NET 在内的多种编程语言的丰富生态系统而设计开发的。Visual Studio Code 默认提供了调试、智能代码完成、语法高亮和代码重构功能，以提高开发的代码质量。</p>\n<p>在其<a href=\"https://github.com/VSCodium/vscodium#downloadinstall\">资源库</a>中有很多下载项。当你运行 Visual Studio Code 时，你可以通过点击左侧活动栏中的&#8220;扩展&#8221;图标或按下&#160;<code>Ctrl+Shift+X</code>&#160;键来添加新的功能和主题。例如，当你在搜索框中输入 &#8220;quarkus&#8221; 时，就会出现 Visual Studio Code 的 Quarkus 工具，该扩展允许你<a href=\"https://opensource.com/article/20/4/java-quarkus-vs-code\">在 VS Code 中使用 Quarkus 编写 Java</a>：</p>\n<p><img title=\"VSCodium IDE screenshot\" src=\"https://img.linux.net.cn/data/attachment/album/202008/22/235658ea227wtkrngif2cr.png\" alt=\"VSCodium IDE screenshot\" /></p>\n<h3 id=\"%E6%80%BB%E7%BB%93\" class=\"mume-header\">总结</h3>\n<p>Java 作为最广泛使用的编程语言和环境之一，这五种只是 Java 开发者可以使用的各种开源 IDE 工具的一小部分。可能很难知道哪一个是正确的选择。和以往一样，这取决于你的具体需求和目标 &#8212;&#8212; 你想实现什么样的工作负载（Web、移动应用、消息传递、数据交易），以及你将使用 IDE 扩展功能部署什么样的运行时（本地、云、Kubernetes、无服务器）。虽然丰富的选择可能会让人不知所措，但这也意味着你可能可以找到一个适合你的特殊情况和偏好的选择。</p>\n<p>你有喜欢的开源 Java IDE 吗？请在评论中分享吧。</p>\n<hr />\n<p>via:&#160;<a href=\"https://opensource.com/article/20/7/ide-java\">https://opensource.com/article/20/7/ide-java</a></p>\n<p>作者：<a href=\"https://opensource.com/users/daniel-oh\">Daniel Oh</a>&#160;选题：<a href=\"https://github.com/lujun9972\">lujun9972</a>&#160;译者：<a href=\"https://github.com/wxy\">wxy</a>&#160;校对：<a href=\"https://github.com/wxy\">wxy</a></p>\n<p>本文由&#160;<a href=\"https://github.com/LCTT/TranslateProject\">LCTT</a>&#160;原创编译，<a href=\"https://linux.cn/\">Linux中国</a>&#160;荣誉推出</p>","descriptionType":"text/html","publishedDate":"Sat, 22 Aug 2020 15:55:12 +0000","feedId":909,"bgimg":"https://img.linux.net.cn/data/attachment/album/202008/22/235441wnnorcvo4olasv8o.jpg","linkMd5":"65c9069483f00ab0b119d0821164eec7","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn47@2020_2/2020/08/22/17-41-41-630_7928f44c13002b00.webp","destWidth":1280,"destHeight":720,"sourceBytes":220696,"destBytes":66564,"author":"linux@linux.cn (linux)","articleImgCdnMap":{"https://img.linux.net.cn/data/attachment/album/202008/22/235441wnnorcvo4olasv8o.jpg":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn47@2020_2/2020/08/22/17-41-41-630_7928f44c13002b00.webp","https://img.linux.net.cn/data/attachment/album/202008/22/235549gxbh4zo0szvtzxsx.png":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn72@2020_2/2020/08/22/17-41-59-359_46f05b147866dfba.webp","https://img.linux.net.cn/data/attachment/album/202008/22/235606vcjq3h4n0qjilqqw.png":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn75@2020_4/2020/08/22/17-41-57-810_fb1b5e6ef9c1439e.webp","https://img.linux.net.cn/data/attachment/album/202008/22/235634skhtta9tnnhxkrok.png":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn69@2020_3/2020/08/22/17-41-58-107_82a33e17fe5856b2.webp","https://img.linux.net.cn/data/attachment/album/202008/22/235658ea227wtkrngif2cr.png":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn84@2020_5/2020/08/22/17-41-59-030_642963500ec099ed.webp"},"publishedOrCreatedDate":1598118098227},{"createdTime":"2020-08-23 01:41:38","updatedTime":"2020-08-23 01:41:38","title":"使用微软的 ProcDump 调试 Linux","link":"https://linux.cn/article-12533-1.html?utm_source=rss&utm_medium=rss","description":"<blockquote>\n<p>用这个微软的开源工具，获取进程信息。</p>\n</blockquote>\n<p><img src=\"https://img.linux.net.cn/data/attachment/album/202008/20/095646k5wz7cd11vyc7lhr.jpg\" /></p>\n<p>微软越来越心仪 Linux 和开源，这并不是什么秘密。在过去几年中，该公司稳步地增加了对开源的贡献，包括将其部分软件和工具移植到 Linux。2018 年底，微软<a href=\"https://www.zdnet.com/article/microsoft-working-on-porting-sysinternals-to-linux/\">宣布</a>将其&#160;<a href=\"https://docs.microsoft.com/en-us/sysinternals/\">Sysinternals</a>&#160;的部分工具以开源的方式移植到 Linux，<a href=\"https://github.com/Microsoft/ProcDump-for-Linux\">Linux 版的 ProcDump</a>是其中的第一个。</p>\n<p>如果你在 Windows 上从事过调试或故障排除工作，你可能听说过 Sysinternals，它是一个&#8220;瑞士军刀&#8221;工具集，可以帮助系统管理员、开发人员和 IT 安全专家监控和排除 Windows 环境的故障。</p>\n<p>Sysinternals 最受欢迎的工具之一是&#160;<a href=\"https://docs.microsoft.com/en-us/sysinternals/downloads/procdump\">ProcDump</a>。顾名思义，它用于将正在运行的进程的内存转储到磁盘上的一个核心文件中。然后可以用调试器对这个核心文件进行分析，了解转储时进程的状态。因为之前用过 Sysinternals，所以我很想试试 ProcDump 的 Linux 移植版。</p>\n<h3 id=\"%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-linux-%E4%B8%8A%E7%9A%84-procdump\" class=\"mume-header\">开始使用 Linux 上的 ProcDump</h3>\n<p>要试用 Linux 上的 ProcDump，你需要下载该工具并编译它。（我使用的是 Red Hat Enterprise Linux，尽管这些步骤在其他 Linux 发行版上应该是一样的）：</p>\n<pre class=\"prettyprint linenums\"><code>$ cat /etc/redhat-release\nRed Hat Enterprise Linux release 8.2 (Ootpa)\n$\n$ uname -r\n4.18.0-193.el8.x86_64\n$\n</code></pre>\n<p>首先，克隆 Linux 版 ProcDump 的版本库。</p>\n<pre class=\"prettyprint linenums\"><code>$ git clone https://github.com/microsoft/ProcDump-for-Linux.git\nCloning into 'ProcDump-for-Linux'...\nremote: Enumerating objects: 40, done.\nremote: Counting objects: 100% (40/40), done.\nremote: Compressing objects: 100% (33/33), done.\nremote: Total 414 (delta 14), reused 14 (delta 6), pack-reused 374\nReceiving objects: 100% (414/414), 335.28 KiB | 265.00 KiB/s, done.\nResolving deltas: 100% (232/232), done.\n$\n$ cd ProcDump-for-Linux/\n$\n$ ls\nazure-pipelines.yml &#160;CONTRIBUTING.md &#160;docs &#160; &#160; INSTALL.md &#160;Makefile &#160; &#160;procdump.gif &#160;src\nCODE_OF_CONDUCT.md &#160; dist &#160; &#160; &#160; &#160; &#160; &#160; include &#160;LICENSE &#160; &#160; procdump.1 &#160;README.md &#160; &#160; tests\n$\n</code></pre>\n<p>接下来，使用&#160;<code>make</code>&#160;构建程序。它能准确地输出编译源文件所需的&#160;<a href=\"https://gcc.gnu.org/\">GCC</a>&#160;命令行参数。</p>\n<pre class=\"prettyprint linenums\"><code>$ make\nrm -rf obj\nrm -rf bin\nrm -rf /root/ProcDump-for-Linux/pkgbuild\ngcc -c -g -o obj/Logging.o src/Logging.c -Wall -I ./include -pthread -std=gnu99\ngcc -c -g -o obj/Events.o src/Events.c -Wall -I ./include -pthread -std=gnu99\ngcc -c -g -o obj/ProcDumpConfiguration.o src/ProcDumpConfiguration.c -Wall -I ./include -pthread -std=gnu99\ngcc -c -g -o obj/Handle.o src/Handle.c -Wall -I ./include -pthread -std=gnu99\ngcc -c -g -o obj/Process.o src/Process.c -Wall -I ./include -pthread -std=gnu99\ngcc -c -g -o obj/Procdump.o src/Procdump.c -Wall -I ./include -pthread -std=gnu99\ngcc -c -g -o obj/TriggerThreadProcs.o src/TriggerThreadProcs.c -Wall -I ./include -pthread -std=gnu99\ngcc -c -g -o obj/CoreDumpWriter.o src/CoreDumpWriter.c -Wall -I ./include -pthread -std=gnu99\ngcc -o bin/procdump obj/Logging.o obj/Events.o obj/ProcDumpConfiguration.o obj/Handle.o obj/Process.o obj/Procdump.o obj/TriggerThreadProcs.o obj/CoreDumpWriter.o -Wall -I ./include -pthread -std=gnu99\ngcc -c -g -o obj/ProcDumpTestApplication.o tests/integration/ProcDumpTestApplication.c -Wall -I ./include -pthread -std=gnu99\ngcc -o bin/ProcDumpTestApplication obj/ProcDumpTestApplication.o -Wall -I ./include -pthread -std=gnu99\n$\n</code></pre>\n<p>编译过程中会创建两个新的目录。第一个是&#160;<code>obj/</code>&#160;目录，存放编译期间创建的对象文件。第二个（也是更重要的）目录是&#160;<code>bin/</code>，它是存储编译出的&#160;<code>procdump</code>&#160;程序的地方。它还会编译另一个名为&#160;<code>ProcDumpTestApplication</code>&#160;的测试二进制文件：</p>\n<pre class=\"prettyprint linenums\"><code>$ ls obj/\nCoreDumpWriter.o &#160;Handle.o &#160; ProcDumpConfiguration.o &nbsp<img src=\"https://img.linux.net.cn/static/image/smiley/default/titter.gif\" smilieid=\"9\" border=\"0\" alt=\"\" />rocDumpTestApplication.o &#160;TriggerThreadProcs.o\nEvents.o &#160; &#160; &#160; &#160; &#160;Logging.o &nbsp<img src=\"https://img.linux.net.cn/static/image/smiley/default/titter.gif\" smilieid=\"9\" border=\"0\" alt=\"\" />rocdump.o &#160; &#160; &#160; &#160; &#160; &#160; &#160; Process.o\n$\n$\n$ ls bin/\nprocdump &nbsp<img src=\"https://img.linux.net.cn/static/image/smiley/default/titter.gif\" smilieid=\"9\" border=\"0\" alt=\"\" />rocDumpTestApplication\n$\n$ file bin/procdump\nbin/procdump: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=6e8827db64835ea0d1f0941ac3ecff9ee8c06e6b, with debug_info, not stripped\n$\n$ file bin/ProcDumpTestApplication\nbin/ProcDumpTestApplication: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=c8fd86f53c07df142e52518815b2573d1c690e4e, with debug_info, not stripped\n$\n</code></pre>\n<p>在此情况下，每次运行&#160;<code>procdump</code>&#160;实用程序时，你都必须移动到&#160;<code>bin/</code>&#160;文件夹中。要使它在系统中的任何地方都可以使用，运行&#160;<code>make install</code>。这将这个二进制文件复制到通常的&#160;<code>bin/</code>&#160;目录中，它是你的 shell&#160;<code>$PATH</code>&#160;的一部分：</p>\n<pre class=\"prettyprint linenums\"><code>$ which procdump\n/usr/bin/which: no procdump in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin)\n$\n$ make install\nmkdir -p //usr/bin\ncp bin/procdump //usr/bin\nmkdir -p //usr/share/man/man1\ncp procdump.1 //usr/share/man/man1\n$\n$ which procdump\n/usr/bin/procdump\n$\n</code></pre>\n<p>安装时，ProcDump 提供了一个手册页，你可以用&#160;<code>man procdump</code>&#160;访问：</p>\n<pre class=\"prettyprint linenums\"><code>$ man procdump\n$\n</code></pre>\n<h3 id=\"%E8%BF%90%E8%A1%8C-procdump\" class=\"mume-header\">运行 ProcDump</h3>\n<p>要转储一个进程的内存，你需要向 ProcDump 提供它的进程 ID（PID）。你可以使用机器上任何正在运行的程序或守护进程。在这个例子中，我将使用一个永远循环的小 C 程序。编译程序并运行它（要退出程序，按&#160;<code>Ctrl+C</code>，如果程序在后台运行，则使用&#160;<code>kill</code>&#160;命令并输入 PID）：</p>\n<pre class=\"prettyprint linenums\"><code>$ cat progxyz.c\n#include &#60;stdio.h&#62;\n\nint main() {\n&#160; &#160; &#160; &#160; for (;;)\n&#160; &#160; &#160; &#160; {\n&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; printf(\".\");\n&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; sleep(1);\n&#160; &#160; &#160; &#160; }\n&#160; &#160; &#160; &#160; return 0;\n}\n$\n$ gcc progxyz.c -o progxyz\n$\n$ ./progxyz &#38;\n[1] 350498\n$\n</code></pre>\n<p>运行该程序，你可以使用&#160;<code>pgrep</code>&#160;或&#160;<code>ps</code>&#160;找到它的 PID。记下 PID：</p>\n<pre class=\"prettyprint linenums\"><code>$ pgrep progxyz\n350498\n$\n$ ps -ef | grep progxyz\nroot &#160; &#160; &#160;350498 &#160;345445 &#160;0 03:29 pts/1 &#160; &#160;00:00:00 ./progxyz\nroot &#160; &#160; &#160;350508 &#160;347350 &#160;0 03:29 pts/0 &#160; &#160;00:00:00 grep --color=auto progxyz\n$\n</code></pre>\n<p>当测试进程正在运行时，调用&#160;<code>procdump</code>&#160;并提供 PID。下面的输出表明了该进程的名称和 PID，并报告它生成了一个核心转储文件，并显示其文件名：</p>\n<pre class=\"prettyprint linenums\"><code>$ procdump -p 350498\n\nProcDump v1.1.1 - Sysinternals process dump utility\nCopyright (C) 2020 Microsoft Corporation. All rights reserved. Licensed under the MIT license.\nMark Russinovich, Mario Hewardt, John Salem, Javid Habibi\nMonitors a process and writes a dump file when the process exceeds the\nspecified criteria.\n\nProcess:&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; progxyz (350498)\nCPU Threshold:&#160; &#160; &#160; &#160; &#160; n/a\nCommit Threshold: &#160; &#160; &#160; n/a\nPolling interval (ms):&#160; 1000\nThreshold (s):&#160; 10\nNumber of Dumps:&#160; &#160; &#160; &#160; 1\n\nPress Ctrl-C to end monitoring without terminating the process.\n\n[03:30:00 - INFO]: Timed:\n[03:30:01 - INFO]: Core dump 0 generated: progxyz_time_2020-06-24_03:30:00.350498\n$\n</code></pre>\n<p>列出当前目录的内容，你应该可以看到新的核心文件。文件名与&#160;<code>procdump</code>&#160;命令显示的文件名一致，日期、时间、PID 都会附加在文件名上：</p>\n<pre class=\"prettyprint linenums\"><code>$ ls -l progxyz_time_2020-06-24_03\\:30\\:00.350498\n-rw-r--r--. 1 root root 356848 Jun 24 03:30 progxyz_time_2020-06-24_03:30:00.350498\n$\n$ file progxyz_time_2020-06-24_03\\:30\\:00.350498\nprogxyz_time_2020-06-24_03:30:00.350498: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from './progxyz', real uid: 0, effective uid: 0, real gid: 0, effective gid: 0, execfn: './progxyz', platform: 'x86_64'\n$\n</code></pre>\n<h3 id=\"%E7%94%A8-gnu-%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95%E5%99%A8%E5%88%86%E6%9E%90%E6%A0%B8%E5%BF%83%E6%96%87%E4%BB%B6\" class=\"mume-header\">用 GNU 项目调试器分析核心文件。</h3>\n<p>要查看是否可以读取该转储文件，调用&#160;<a href=\"https://www.gnu.org/software/gdb/\">GNU 项目调试器</a>（<code>gdb</code>）。记得提供测试二进制文件的路径，这样你就可以看到堆栈上所有的函数名。在这里，<code>bt</code>（回溯）表明，当转储被采集时，<code>sleep()</code>&#160;函数正在执行：</p>\n<pre class=\"prettyprint linenums\"><code>$ gdb -q ./progxyz ./progxyz_time_2020-06-24_03\\:30\\:00.350498\nReading symbols from ./progxyz...(no debugging symbols found)...done.\n[New LWP 350498]\nCore was generated by `./progxyz'.\n#0 &#160;0x00007fb6947e9208 in nanosleep () from /lib64/libc.so.6\nMissing separate debuginfos, use: yum debuginfo-install glibc-2.28-101.el8.x86_64\n(gdb) bt\n#0 &#160;0x00007fb6947e9208 in nanosleep () from /lib64/libc.so.6\n#1 &#160;0x00007fb6947e913e in sleep () from /lib64/libc.so.6\n#2 &#160;0x00000000004005f3 in main ()\n(gdb)\n</code></pre>\n<h3 id=\"gcore-%E6%80%8E%E4%B9%88%E6%A0%B7\" class=\"mume-header\">gcore 怎么样？</h3>\n<p>Linux 用户会很快指出，Linux 已经有一个叫&#160;<code>gcore</code>&#160;的命令，大多数 Linux 发行版都有这个命令，它的作用和 ProcDump 完全一样。你说的对。如果你从来没有使用过它，可以尝试用&#160;<code>gcore</code>&#160;来转储一个进程的核心。再次运行测试程序，然后运行&#160;<code>gcore</code>，并提供 PID 作为参数：</p>\n<pre class=\"prettyprint linenums\"><code>$ ./progxyz &#38;\n[1] 350664\n$\n$\n$ pgrep progxyz\n350664\n$\n$\n$ gcore 350664\n0x00007fefd3be2208 in nanosleep () from /lib64/libc.so.6\nSaved corefile core.350664\n[Inferior 1 (process 350664) detached]\n$\n</code></pre>\n<p><code>gcore</code>&#160;打印一条消息，说它已将核心文件保存到一个特定的文件中。检查当前目录，找到这个核心文件，然后再次使用&#160;<code>gdb</code>&#160;加载它：</p>\n<pre class=\"prettyprint linenums\"><code>$\n$ ls -l &#160;core.350664\n-rw-r--r--. 1 root root 356848 Jun 24 03:34 core.350664\n$\n$\n$ file core.350664\ncore.350664: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from './progxyz', real uid: 0, effective uid: 0, real gid: 0, effective gid: 0, execfn: './progxyz', platform: 'x86_64'\n$\n$ gdb -q ./progxyz ./core.350664\nReading symbols from ./progxyz...(no debugging symbols found)...done.\n[New LWP 350664]\nCore was generated by `./progxyz'.\n#0 &#160;0x00007fefd3be2208 in nanosleep () from /lib64/libc.so.6\nMissing separate debuginfos, use: yum debuginfo-install glibc-2.28-101.el8.x86_64\n(gdb) bt\n#0 &#160;0x00007fefd3be2208 in nanosleep () from /lib64/libc.so.6\n#1 &#160;0x00007fefd3be213e in sleep () from /lib64/libc.so.6\n#2 &#160;0x00000000004005f3 in main ()\n(gdb) q\n$\n</code></pre>\n<p>为了使&#160;<code>gcore</code>&#160;可以工作，你需要确保以下设置到位。首先，确保为核心文件设置了&#160;<code>ulimit</code>，如果设置为&#160;<code>0</code>，核心文件将不会被生成。第二，确保&#160;<code>/proc/sys/kernel/core_pattern</code>&#160;有正确的设置来指定核心模式：</p>\n<pre class=\"prettyprint linenums\"><code>$ ulimit -c\nunlimited\n$\n</code></pre>\n<h3 id=\"%E4%BD%A0%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8-procdump-%E8%BF%98%E6%98%AF-gcore\" class=\"mume-header\">你应该使用 ProcDump 还是 gcore？</h3>\n<p>有几种情况下，你可能更喜欢使用 ProcDump 而不是 gcore，ProcDump 有一些内置的功能，在一些情况下可能很有用。</p>\n<h4 id=\"%E7%AD%89%E5%BE%85%E6%B5%8B%E8%AF%95%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C\" class=\"mume-header\">等待测试二进制文件的执行</h4>\n<p>无论是使用 ProcDump 还是 gcore，测试进程必须被执行并处于运行状态，这样才能提供一个 PID 来生成核心文件。但 ProcDump 有一个功能，就是等待特定的二进制文件运行，一旦发现运行的测试二进制文件与给定的名称相匹配，它就会为该测试二进制文件生成一个核心文件。它可以使用&#160;<code>-w</code>&#160;参数和程序名称而不是 PID 来启用。这个功能在测试程序快速退出的情况下很有用。</p>\n<p>下面是它的工作原理。在这个例子中，没有名为&#160;<code>progxyz</code>&#160;的进程在运行：</p>\n<pre class=\"prettyprint linenums\"><code>$ pgrep progxyz\n$\n</code></pre>\n<p>用&#160;<code>-w</code>&#160;参数调用&#160;<code>procdump</code>，让它保持等待。在另一个终端，调用测试二进制&#160;<code>progxyz</code>：</p>\n<pre class=\"prettyprint linenums\"><code>$ procdump -w progxyz\n\nProcDump v1.1.1 - Sysinternals process dump utility\nCopyright (C) 2020 Microsoft Corporation. All rights reserved. Licensed under the MIT license.\nMark Russinovich, Mario Hewardt, John Salem, Javid Habibi\nMonitors a process and writes a dump file when the process exceeds the\nspecified criteria.\n\nProcess:&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; progxyz (pending)\nCPU Threshold:&#160; &#160; &#160; &#160; &#160; n/a\nCommit Threshold: &#160; &#160; &#160; n/a\nPolling interval (ms):&#160; 1000\nThreshold (s):&#160; 10\nNumber of Dumps:&#160; &#160; &#160; &#160; 1\n\nPress Ctrl-C to end monitoring without terminating the process.\n\n[03:39:23 - INFO]: Waiting for process 'progxyz' to launch...\n</code></pre>\n<p>然后，从另一个终端调用测试二进制&#160;<code>progxyz</code>：</p>\n<pre class=\"prettyprint linenums\"><code>$ ./progxyz &#38;\n[1] 350951\n$\n</code></pre>\n<p>ProcDump 立即检测到该二进制正在运行，并转储这个二进制的核心文件：</p>\n<pre class=\"prettyprint linenums\"><code>[03:39:23 - INFO]: Waiting for process 'progxyz' to launch...\n[03:43:22 - INFO]: Found process with PID 350951\n[03:43:22 - INFO]: Timed:\n[03:43:23 - INFO]: Core dump 0 generated: progxyz_time_2020-06-24_03:43:22.350951\n$\n\n$ ls -l progxyz_time_2020-06-24_03\\:43\\:22.350951\n-rw-r--r--. 1 root root 356848 Jun 24 03:43 progxyz_time_2020-06-24_03:43:22.350951\n$\n$ file progxyz_time_2020-06-24_03\\:43\\:22.350951\nprogxyz_time_2020-06-24_03:43:22.350951: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from './progxyz', real uid: 0, effective uid: 0, real gid: 0, effective gid: 0, execfn: './progxyz', platform: 'x86_64'\n$\n</code></pre>\n<h4 id=\"%E5%A4%9A%E4%B8%AA%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8\" class=\"mume-header\">多个核心转储</h4>\n<p>另一个重要的 ProcDump 功能是，你可以通过使用命令行参数&#160;<code>-n &#60;count&#62;</code>&#160;指定要生成多少个核心文件。核心转储之间的默认时间间隔是&#160;<code>10</code>&#160;秒，但你可以使用&#160;<code>-s &#60;sec&#62;</code>&#160;参数修改。这个例子使用 ProcDump 对测试二进制文件进行了三次核心转储：</p>\n<pre class=\"prettyprint linenums\"><code>$ ./progxyz &#38;\n[1] 351014\n$\n$ procdump -n 3 -p 351014\n\nProcDump v1.1.1 - Sysinternals process dump utility\nCopyright (C) 2020 Microsoft Corporation. All rights reserved. Licensed under the MIT license.\nMark Russinovich, Mario Hewardt, John Salem, Javid Habibi\nMonitors a process and writes a dump file when the process exceeds the\nspecified criteria.\n\nProcess:&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; progxyz (351014)\nCPU Threshold:&#160; &#160; &#160; &#160; &#160; n/a\nCommit Threshold: &#160; &#160; &#160; n/a\nPolling interval (ms):&#160; 1000\nThreshold (s):&#160; 10\nNumber of Dumps:&#160; &#160; &#160; &#160; 3\n\nPress Ctrl-C to end monitoring without terminating the process.\n\n[03:45:20 - INFO]: Timed:\n[03:45:21 - INFO]: Core dump 0 generated: progxyz_time_2020-06-24_03:45:20.351014\n[03:45:31 - INFO]: Timed:\n[03:45:32 - INFO]: Core dump 1 generated: progxyz_time_2020-06-24_03:45:31.351014\n[03:45:42 - INFO]: Timed:\n[03:45:44 - INFO]: Core dump 2 generated: progxyz_time_2020-06-24_03:45:42.351014\n$\n$ ls -l progxyz_time_2020-06-24_03\\:45\\:*\n-rw-r--r--. 1 root root 356848 Jun 24 03:45 progxyz_time_2020-06-24_03:45:20.351014\n-rw-r--r--. 1 root root 356848 Jun 24 03:45 progxyz_time_2020-06-24_03:45:31.351014\n-rw-r--r--. 1 root root 356848 Jun 24 03:45 progxyz_time_2020-06-24_03:45:42.351014\n$\n</code></pre>\n<h4 id=\"%E5%9F%BA%E4%BA%8E-cpu-%E5%92%8C%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E7%9A%84%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8\" class=\"mume-header\">基于 CPU 和内存使用情况的核心转储</h4>\n<p>ProcDump 还可以让你在测试二进制或进程达到一定的 CPU 或内存阈值时触发核心转储。ProcDump 的手册页显示了调用 ProcDump 时使用的命令行参数：</p>\n<ul>\n<li><code>-C</code>：当 CPU 超过或等于指定值时，触发核心转储生成（0 到 100 * nCPU）。</li>\n<li><code>-c</code>：当 CPU 小于指定值时，触发核心转储生成（0 到 100 * nCPU）。</li>\n<li><code>-M</code>：当内存提交超过或等于指定值（MB）时，触发核心转储生成。</li>\n<li><code>-m</code>：当内存提交小于指定值（MB）时，触发核心转储生成。</li>\n<li><code>-T</code>：当线程数超过或等于指定值时触发。</li>\n<li><code>-F</code>：当文件描述符数量超过或等于指定值时触发。</li>\n<li><code>-I</code>：轮询频率，单位为毫秒（默认为 1000）。</li>\n</ul>\n<p>例如，当给定 PID 的 CPU 使用率超过 70% 时，可以要求 ProcDump 转储核心：</p>\n<pre class=\"prettyprint linenums\"><code>procdump -C 70 -n 3 -p 351014\n</code></pre>\n<h3 id=\"%E7%BB%93%E8%AE%BA\" class=\"mume-header\">结论</h3>\n<p>ProcDump 是一长串被移植到 Linux 的 Windows 程序中的一个有趣的补充。它不仅为 Linux 用户提供了额外的工具选择，而且可以让 Windows 用户在 Linux 上工作时更有熟悉的感觉。</p>\n<hr />\n<p>via:&#160;<a href=\"https://opensource.com/article/20/7/procdump-linux\">https://opensource.com/article/20/7/procdump-linux</a></p>\n<p>作者：<a href=\"https://opensource.com/users/gkamathe\">Gaurav Kamathe</a>&#160;选题：<a href=\"https://github.com/lujun9972\">lujun9972</a>&#160;译者：<a href=\"https://github.com/wxy\">wxy</a>&#160;校对：<a href=\"https://github.com/wxy\">wxy</a></p>\n<p>本文由&#160;<a href=\"https://github.com/LCTT/TranslateProject\">LCTT</a>&#160;原创编译，<a href=\"https://linux.cn/\">Linux中国</a>&#160;荣誉推出</p>","descriptionType":"text/html","publishedDate":"Thu, 20 Aug 2020 01:57:30 +0000","feedId":909,"bgimg":"https://img.linux.net.cn/data/attachment/album/202008/20/095646k5wz7cd11vyc7lhr.jpg","linkMd5":"5266a4e1a9b01945d164183aa9775558","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn29@2020_3/2020/08/22/17-41-42-369_b51e92ddeef01594.webp","destWidth":1280,"destHeight":720,"sourceBytes":281416,"destBytes":54736,"author":"linux@linux.cn (linux)","articleImgCdnMap":{"https://img.linux.net.cn/data/attachment/album/202008/20/095646k5wz7cd11vyc7lhr.jpg":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn29@2020_3/2020/08/22/17-41-42-369_b51e92ddeef01594.webp","https://img.linux.net.cn/static/image/smiley/default/titter.gif":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn80@2020_5/2020/08/22/17-41-57-974_d1846d40b9a3e697.webp"},"publishedOrCreatedDate":1598118098225},{"createdTime":"2020-08-23 01:41:38","updatedTime":"2020-08-23 01:41:38","title":"#新闻拍一拍# 微软：IE11 之后再无 IE","link":"https://linux.cn/article-12534-1.html?utm_source=rss&utm_medium=rss","description":"<p><img src=\"https://img.linux.net.cn/data/attachment/album/202008/20/103513lz7gy2qjzqjqoqjw.jpg\" /></p>\n<h4 id=\"%E5%BE%AE%E8%BD%AFie11-%E4%B9%8B%E5%90%8E%E5%86%8D%E6%97%A0-ie\" class=\"mume-header\">微软：IE11 之后再无 IE</h4>\n<p>1995 年 8 月 16 日，微软推出了第一代 Internet Explore 浏览器。2013 年 IE11 发布后，微软开发了浏览器 Edge。今年 1 月 15 日微软新版 Edge 浏览器正式发布，它基于 Chromium 内核。在微软官方 IE 和 Edge 生命周期问答<a href=\"https://docs.microsoft.com/en-us/lifecycle/faq/internet-explorer-microsoft-edge\">文档</a>中称：是的，IE11 是 Internet Explorer 浏览器的最后一个重大版本。</p>\n<p>来源：<a href=\"https://www.cnbeta.com/articles/tech/1017697.htm\">快科技</a></p>\n<blockquote>\n<p>拍一拍：那个糟糕的、曾经统治了浏览器市场的 IE 终于要退场了，但是我觉得也要感谢 IE 为互联网的发展做出的贡献。从另一个方面来看，新的浏览器巨头在制霸，谁是下一个打倒恶龙的勇士呢？</p>\n</blockquote>\n<h4 id=\"zorin-os%E6%96%B0%E7%BA%BF%E7%B4%A2%E8%A1%A8%E6%98%8E%E6%9C%89%E6%9B%B4%E5%A4%9A-windows-%E7%94%A8%E6%88%B7%E6%8B%A5%E6%8A%B1-linux\" class=\"mume-header\">Zorin OS：新线索表明有更多 Windows 用户拥抱 Linux</h4>\n<p>自 9 个月前的 Zorin OS 15 大版本更新以来，其已迎来超过 90 万的下载量。其称，&#8220;值得一提的是，在每 3 个下载中、就有 2 个来自 Windows 和 macOS，表明最终用户对 Zorin OS 很是认可。&#8221;</p>\n<p>来源：<a href=\"https://www.cnbeta.com/articles/tech/1017673.htm\">cnBeta.COM</a></p>\n<blockquote>\n<p>拍一拍：Zorin，加油！</p>\n</blockquote>\n<h4 id=\"rust-%E8%AF%AD%E8%A8%80%E6%88%90%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%BA%E9%87%91%E4%BC%9A\" class=\"mume-header\">Rust 语言成立自己的基金会</h4>\n<p>Rust 语言项目宣布成立自己的基金会，基金会的第一项任务就是接管所有权。与 Rust、Cargo、<a href=\"http://crates.io/\">crates.io</a>&#160;相关的商标和域名将转移到基金会名下，而基金会也将承担相应的财务责任。Rust 最初是 Mozilla 的一个研究项目，2015 年发布了 1.0 版本，此后它确立了项目方向，独立于 Mozilla 组织进行治理。</p>\n<p>来源：<a href=\"https://www.solidot.org/story?sid=65289\">solidot</a></p>\n<blockquote>\n<p>拍一拍：在 Mozilla 裁员的背景之下，被业界热捧的 Rust 积极展开自救。Mozilla 大家庭的其它兄弟姐妹纷纷侧目。</p>\n</blockquote>","descriptionType":"text/html","publishedDate":"Thu, 20 Aug 2020 02:35:00 +0000","feedId":909,"bgimg":"https://img.linux.net.cn/data/attachment/album/202008/20/103513lz7gy2qjzqjqoqjw.jpg","linkMd5":"be1f87611fb76151e28b78cc62920f8b","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn33@2020_6/2020/08/22/17-41-42-342_9d7a00bdcb38f874.webp","destWidth":1280,"destHeight":720,"sourceBytes":387651,"destBytes":107308,"author":"linux@linux.cn (linux)","articleImgCdnMap":{"https://img.linux.net.cn/data/attachment/album/202008/20/103513lz7gy2qjzqjqoqjw.jpg":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn33@2020_6/2020/08/22/17-41-42-342_9d7a00bdcb38f874.webp"},"publishedOrCreatedDate":1598118098223}],"record":{"createdTime":"2020-08-23 01:41:38","updatedTime":"2020-08-23 01:41:38","feedId":909,"fetchDate":"Sat, 22 Aug 2020 17:41:38 +0000","fetchMs":2474,"handleMs":3673,"totalMs":28832,"newArticles":0,"totalArticles":11,"status":1,"type":0,"ip":"52.207.163.84","hostName":"us-018.herokuapp.com","requestId":"f2b680b846a749e7bf59ae2da533f495_909","contentType":"application/xml","totalBytes":976436,"bgimgsTotal":11,"bgimgsGithubTotal":11,"articlesImgsTotal":18,"articlesImgsGithubTotal":18,"successGithubMap":{"myreaderx14":1,"myreaderx25":1,"myreaderx7":1,"myreaderx27":1,"myreaderx4":1,"myreaderx10":1,"myreaderx21":1,"myreaderx32":1,"myreaderx11":1,"myreaderx3":1,"myreaderx23":1,"myreaderx12":1,"myreaderx2":1,"myreaderx1":1,"myreaderx13":1,"myreaderx5oss":1,"myreaderx29":1,"myreaderx":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-16 17:44:30","updatedTime":"2020-08-23 00:48:17","id":909,"name":"Linux 中国◆开源社区","url":"https://linux.cn/rss.xml","subscriber":null,"website":null,"icon":"https://img.linux.net.cn/static/image/common/linuxcn_logo_64.gif","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn38@2020_4/2020/08/22/17-41-37-361_65d5a34039131f77.gif","description":"Linux 中国◆开源社区","weekly":null,"link":"https://linux.cn"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":811030,"tmpBodyImgCdnBytes":165406,"tmpBgImgCdnBytes":0,"extra4":{"start":1598118091827,"total":0,"statList":[{"spend":2727,"msg":"获取xml内容"},{"spend":3673,"msg":"解释文章"},{"spend":1,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":5715,"msg":"正文链接上传到cdn"}]},"extra5":18,"extra6":18,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-006.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-037.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-001.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe69.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-002.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-030.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe70.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/20/085634ureka5kh9vmt36h9.jpg","sourceStatusCode":200,"destWidth":1280,"destHeight":720,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn31@2020_1/2020/08/22/17-41-41-453_e255e34f9592c3d5.webp","sourceBytes":181759,"destBytes":51890,"targetWebpQuality":75,"feedId":909,"totalSpendMs":4084,"convertSpendMs":31,"createdTime":"2020-08-23 01:41:38","host":"us-015.herokuapp.com","referer":"https://linux.cn/article-12532-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"41fdf0b897c10a186e51a610d6c066f5,41fdf0b897c10a186e51a610d6c066f5","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"177.5 KB","destSize":"50.7 KB","compressRate":"28.5%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/21/233828npoopm43suckztpt.jpg","sourceStatusCode":200,"destWidth":800,"destHeight":450,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn57@2020_5/2020/08/22/17-41-41-040_60df35e2bd53f5c6.webp","sourceBytes":20909,"destBytes":19426,"targetWebpQuality":75,"feedId":909,"totalSpendMs":4016,"convertSpendMs":22,"createdTime":"2020-08-23 01:41:38","host":"europe61.herokuapp.com","referer":"https://linux.cn/article-12538-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"a84243237277ad8925c9f33ad74dcc83,a84243237277ad8925c9f33ad74dcc83","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"20.4 KB","destSize":"19 KB","compressRate":"92.9%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/22/104612gfgllhf85mahvm3j.jpg","sourceStatusCode":200,"destWidth":816,"destHeight":345,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn38@2020_5/2020/08/22/17-41-41-567_15561dd5e7baf80d.webp","sourceBytes":19039,"destBytes":10066,"targetWebpQuality":75,"feedId":909,"totalSpendMs":4182,"convertSpendMs":10,"createdTime":"2020-08-23 01:41:38","host":"europe65.herokuapp.com","referer":"https://linux.cn/article-12540-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"910f844c141fbd9f08e35ec2530bf6af,910f844c141fbd9f08e35ec2530bf6af","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.6 KB","destSize":"9.8 KB","compressRate":"52.9%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/22/235441wnnorcvo4olasv8o.jpg","sourceStatusCode":200,"destWidth":1280,"destHeight":720,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn47@2020_2/2020/08/22/17-41-41-630_7928f44c13002b00.webp","sourceBytes":220696,"destBytes":66564,"targetWebpQuality":75,"feedId":909,"totalSpendMs":4578,"convertSpendMs":34,"createdTime":"2020-08-23 01:41:38","host":"europe-58.herokuapp.com","referer":"https://linux.cn/article-12542-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"65c9069483f00ab0b119d0821164eec7,65c9069483f00ab0b119d0821164eec7","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"215.5 KB","destSize":"65 KB","compressRate":"30.2%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/20/095646k5wz7cd11vyc7lhr.jpg","sourceStatusCode":200,"destWidth":1280,"destHeight":720,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn29@2020_3/2020/08/22/17-41-42-369_b51e92ddeef01594.webp","sourceBytes":281416,"destBytes":54736,"targetWebpQuality":75,"feedId":909,"totalSpendMs":5031,"convertSpendMs":31,"createdTime":"2020-08-23 01:41:38","host":"us-017.herokuapp.com","referer":"https://linux.cn/article-12533-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"5266a4e1a9b01945d164183aa9775558,5266a4e1a9b01945d164183aa9775558","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"274.8 KB","destSize":"53.5 KB","compressRate":"19.5%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/22/102250i3943is48r34w4nz.jpg","sourceStatusCode":200,"destWidth":1280,"destHeight":720,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn36@2020_3/2020/08/22/17-41-42-440_88aa96380e166520.webp","sourceBytes":347980,"destBytes":123012,"targetWebpQuality":75,"feedId":909,"totalSpendMs":5209,"convertSpendMs":70,"createdTime":"2020-08-23 01:41:38","host":"us-010.herokuapp.com","referer":"https://linux.cn/article-12539-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"8c73f23886a025cac918a0a0e5ec7b2e,8c73f23886a025cac918a0a0e5ec7b2e","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"339.8 KB","destSize":"120.1 KB","compressRate":"35.4%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/20/103513lz7gy2qjzqjqoqjw.jpg","sourceStatusCode":200,"destWidth":1280,"destHeight":720,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn33@2020_6/2020/08/22/17-41-42-342_9d7a00bdcb38f874.webp","sourceBytes":387651,"destBytes":107308,"targetWebpQuality":75,"feedId":909,"totalSpendMs":5405,"convertSpendMs":44,"createdTime":"2020-08-23 01:41:38","host":"europe-59.herokuapp.com","referer":"https://linux.cn/article-12534-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"be1f87611fb76151e28b78cc62920f8b,be1f87611fb76151e28b78cc62920f8b","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"378.6 KB","destSize":"104.8 KB","compressRate":"27.7%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/21/005134nctawqncaclwi2ni.jpg","sourceStatusCode":200,"destWidth":1280,"destHeight":720,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn25@2020_3/2020/08/22/17-41-43-201_5be923aed2ab604b.webp","sourceBytes":364169,"destBytes":114768,"targetWebpQuality":75,"feedId":909,"totalSpendMs":5946,"convertSpendMs":51,"createdTime":"2020-08-23 01:41:38","host":"us-014.herokuapp.com","referer":"https://linux.cn/article-12537-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"93ddb03a8f56bdb16f711b876c4b21de,93ddb03a8f56bdb16f711b876c4b21de","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"355.6 KB","destSize":"112.1 KB","compressRate":"31.5%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/21/002323xqslvqnnmdz487dq.jpg","sourceStatusCode":200,"destWidth":1280,"destHeight":720,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn54@2020_4/2020/08/22/17-41-43-634_a73e02f5dec8692f.webp","sourceBytes":261151,"destBytes":83688,"targetWebpQuality":75,"feedId":909,"totalSpendMs":6630,"convertSpendMs":35,"createdTime":"2020-08-23 01:41:38","host":"europe62.herokuapp.com","referer":"https://linux.cn/article-12536-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"8ab8e81e111e7caf03040c31b9f63006,8ab8e81e111e7caf03040c31b9f63006","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"255 KB","destSize":"81.7 KB","compressRate":"32%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/22/112939cruoxn2uj8vn8ul0.jpg","sourceStatusCode":200,"destWidth":1280,"destHeight":720,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn27@2020_5/2020/08/22/17-41-44-992_5a947636d69cdca0.webp","sourceBytes":178706,"destBytes":41270,"targetWebpQuality":75,"feedId":909,"totalSpendMs":7644,"convertSpendMs":28,"createdTime":"2020-08-23 01:41:38","host":"us-016.herokuapp.com","referer":"https://linux.cn/article-12541-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"68776af40d6c29fa0bd21789f5063bbd,68776af40d6c29fa0bd21789f5063bbd","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"174.5 KB","destSize":"40.3 KB","compressRate":"23.1%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/21/000308a577z40hqta5qhpg.png","sourceStatusCode":200,"destWidth":2000,"destHeight":1125,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn52@2020_4/2020/08/22/17-41-53-489_29109883ee980232.webp","sourceBytes":310153,"destBytes":138302,"targetWebpQuality":75,"feedId":909,"totalSpendMs":16525,"convertSpendMs":78,"createdTime":"2020-08-23 01:41:38","host":"europe-60.herokuapp.com","referer":"https://linux.cn/article-12535-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"d2fa99f329c78a141630b4928f070df2,d2fa99f329c78a141630b4928f070df2","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"302.9 KB","destSize":"135.1 KB","compressRate":"44.6%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/22/235606vcjq3h4n0qjilqqw.png","sourceStatusCode":200,"destWidth":675,"destHeight":315,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn75@2020_4/2020/08/22/17-41-57-810_fb1b5e6ef9c1439e.webp","sourceBytes":158181,"destBytes":22258,"targetWebpQuality":75,"feedId":909,"totalSpendMs":3673,"convertSpendMs":18,"createdTime":"2020-08-23 01:41:54","host":"us-006.herokuapp.com","referer":"https://linux.cn/article-12542-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"65c9069483f00ab0b119d0821164eec7","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"154.5 KB","destSize":"21.7 KB","compressRate":"14.1%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/static/image/smiley/default/titter.gif","sourceStatusCode":200,"destWidth":20,"destHeight":20,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn80@2020_5/2020/08/22/17-41-57-974_d1846d40b9a3e697.webp","sourceBytes":1398,"destBytes":780,"targetWebpQuality":75,"feedId":909,"totalSpendMs":3808,"convertSpendMs":5,"createdTime":"2020-08-23 01:41:55","host":"europe70.herokuapp.com","referer":"https://linux.cn/article-12533-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"5266a4e1a9b01945d164183aa9775558,5266a4e1a9b01945d164183aa9775558,5266a4e1a9b01945d164183aa9775558","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"1.4 KB","destSize":"780 B","compressRate":"55.8%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/22/235634skhtta9tnnhxkrok.png","sourceStatusCode":200,"destWidth":675,"destHeight":440,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn69@2020_3/2020/08/22/17-41-58-107_82a33e17fe5856b2.webp","sourceBytes":188780,"destBytes":15252,"targetWebpQuality":75,"feedId":909,"totalSpendMs":3966,"convertSpendMs":22,"createdTime":"2020-08-23 01:41:55","host":"us-037.herokuapp.com","referer":"https://linux.cn/article-12542-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"65c9069483f00ab0b119d0821164eec7","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"184.4 KB","destSize":"14.9 KB","compressRate":"8.1%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/21/233811cjuu7pdbye2uoqaq.png","sourceStatusCode":200,"destWidth":800,"destHeight":580,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn87@2020_6/2020/08/22/17-41-58-940_7ea2b196e625aa12.webp","sourceBytes":83859,"destBytes":52296,"targetWebpQuality":75,"feedId":909,"totalSpendMs":4841,"convertSpendMs":22,"createdTime":"2020-08-23 01:41:55","host":"us-002.herokuapp.com","referer":"https://linux.cn/article-12538-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"a84243237277ad8925c9f33ad74dcc83","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"81.9 KB","destSize":"51.1 KB","compressRate":"62.4%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/22/235658ea227wtkrngif2cr.png","sourceStatusCode":200,"destWidth":675,"destHeight":380,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn84@2020_5/2020/08/22/17-41-59-030_642963500ec099ed.webp","sourceBytes":175581,"destBytes":26036,"targetWebpQuality":75,"feedId":909,"totalSpendMs":5033,"convertSpendMs":22,"createdTime":"2020-08-23 01:41:55","host":"europe69.herokuapp.com","referer":"https://linux.cn/article-12542-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"65c9069483f00ab0b119d0821164eec7","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"171.5 KB","destSize":"25.4 KB","compressRate":"14.8%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/22/235549gxbh4zo0szvtzxsx.png","sourceStatusCode":200,"destWidth":675,"destHeight":598,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn72@2020_2/2020/08/22/17-41-59-359_46f05b147866dfba.webp","sourceBytes":195777,"destBytes":25888,"targetWebpQuality":75,"feedId":909,"totalSpendMs":5277,"convertSpendMs":41,"createdTime":"2020-08-23 01:41:54","host":"us-030.herokuapp.com","referer":"https://linux.cn/article-12542-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"65c9069483f00ab0b119d0821164eec7","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"191.2 KB","destSize":"25.3 KB","compressRate":"13.2%"},{"code":1,"isDone":false,"source":"https://img.linux.net.cn/data/attachment/album/202008/21/233806a8u8urp9ujj6y9zp.png","sourceStatusCode":200,"destWidth":777,"destHeight":427,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn81@2020_6/2020/08/22/17-41-59-824_67137ccb6bc14cea.webp","sourceBytes":18966,"destBytes":22896,"targetWebpQuality":75,"feedId":909,"totalSpendMs":5622,"convertSpendMs":15,"createdTime":"2020-08-23 01:41:55","host":"us-001.herokuapp.com","referer":"https://linux.cn/article-12538-1.html?utm_source=rss&utm_medium=rss","linkMd5ListStr":"a84243237277ad8925c9f33ad74dcc83","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.5 KB","destSize":"22.4 KB","compressRate":"120.7%"}],"successGithubMap":{"myreaderx14":1,"myreaderx25":1,"myreaderx7":1,"myreaderx27":1,"myreaderx4":1,"myreaderx10":1,"myreaderx21":1,"myreaderx32":1,"myreaderx11":1,"myreaderx3":1,"myreaderx23":1,"myreaderx12":1,"myreaderx2":1,"myreaderx1":1,"myreaderx13":1,"myreaderx5oss":1,"myreaderx29":1,"myreaderx":1},"failGithubMap":{}}