{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2022-03-14 17:24:40","updatedTime":"2022-03-14 17:24:40","title":"Exploiting a use-after-free in Windows Common Logging File System (CLFS)","link":"https://blog.exodusintel.com/?p=1931","description":"<p>By Arav Garg</p> \n<h2>Overview</h2> \n<p>This post analyzes a use-after-free vulnerability in <tt>clfs.sys</tt>, the kernel driver that implements the <a href=\"https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-the-common-log-file-system\" target=\"_blank\" rel=\"noreferrer noopener\">Common Logging File System</a>, a general-purpose logging service that can be used by user-space and kernel-space processes in Windows. A method to exploit this vulnerability to achieve privilege escalation in Windows is also outlined.</p> \n<p>Along with two other similar vulnerabilities, Microsoft patched this vulnerability in September 2021 and assigned the CVEs <a href=\"https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-36955\" target=\"_blank\" rel=\"noreferrer noopener\">CVE-2021-36955</a>, <a href=\"https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-36963\" target=\"_blank\" rel=\"noreferrer noopener\">CVE-2021-36963</a>, and <a href=\"https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-38633\" target=\"_blank\" rel=\"noreferrer noopener\">CVE-2021-38633</a> to them. In the absence of any public information separating the three CVEs, we’ve decided to use CVE-2021-36955 to refer to the vulnerability described herein.</p> \n<p>The <a href=\"https://blog.exodusintel.com/?p=1931#section-preliminaries\">Preliminaries</a> section describes CLFS structures, <a href=\"https://blog.exodusintel.com/?p=1931#section-code_analysis\">Code Analysis</a> explains the vulnerability with the help of code snippets, and the <a href=\"https://blog.exodusintel.com/?p=1931#section-exploitation\">Exploitation</a> section outlines the steps that lead to a functional exploit.</p> \n<h2 id=\"section-preliminaries\">Preliminaries</h2> \n<p>Common Log File System (CLFS) provides a high-performance, general-purpose log file subsystem that dedicated client applications can use and multiple clients can share to optimize log access. Any user-mode application that needs logging or recovery support can use CLFS. The following structures are taken from both the <a href=\"https://docs.microsoft.com/en-us/previous-versions/windows/desktop/clfs/common-log-file-system-portal\" target=\"_blank\" rel=\"noreferrer noopener\">official documentation</a> and a third-party’s <a href=\"https://web.archive.org/web/20211026115228/https://github.com/ionescu007/clfs-docs/blob/main/README.md\" target=\"_blank\" rel=\"noreferrer noopener\">unofficial documentation</a>.</p> \n<p>Every Base Log File is made up various <em>records</em>. These records are stored in <em>sectors</em>, which are written to in units of I/O called <em>log blocks</em>. These log blocks are always read and written in an atomic fashion to guarantee consistency.</p> \n<h3>Metadata Blocks</h3> \n<p>Every Base Log File is made up of various records. These records are stored in sectors, which are written to in units of I/O called log blocks. The Base Log File is composed of 6 different metadata blocks (3 of which are shadows), which are all examples of log blocks.</p> \n<p>The three types of records that exist in such blocks are:</p> \n<ul>\n <li><strong>Control Record</strong> that contains info about layout, extend area and truncate area.</li>\n <li><strong>Base Record</strong> that contains symbol tables and info about the client, container and security contexts.</li>\n <li><strong>Truncate Record</strong> that contains info on every client that needs to have sectors changed as a result of a truncate operation.</li>\n</ul> \n<h3>Shadow Blocks</h3> \n<p>Three metadata records were defined above, yet six metadata blocks exist (and each metadata block only contains one record). This is due to <em>shadow blocks</em>, which are yet another technique used for consistency. Shadow blocks contain the previous copy of the metadata that was written, and by using the dump count in the record header, can be used to restore previously known good data in case of torn writes.</p> \n<p>The following enumeration describes the six types of metadata blocks.</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\ntypedef enum _CLFS_METADATA_BLOCK_TYPE\n{\n    ClfsMetaBlockControl,\n    ClfsMetaBlockControlShadow,\n    ClfsMetaBlockGeneral,\n    ClfsMetaBlockGeneralShadow,\n    ClfsMetaBlockScratch,\n    ClfsMetaBlockScratchShadow\n} CLFS_METADATA_BLOCK_TYPE, *PCLFS_METADATA_BLOCK_TYPE;\n</pre>\n</div> \n<h3>Control Record</h3> \n<p>The <em>Control Record</em> is always composed of two sectors, as defined by the constant below:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nconst USHORT CLFS_CONTROL_BLOCK_RAW_SECTORS = 2;\n</pre>\n</div> \n<p>The Control Record is defined by the structure <tt>CLFS_CONTROL_RECORD</tt>, which is shown below:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\ntypedef struct _CLFS_CONTROL_RECORD\n{\n    CLFS_METADATA_RECORD_HEADER hdrControlRecord;\n    ULONGLONG ullMagicValue;\n    UCHAR Version;\n    CLFS_EXTEND_STATE eExtendState;\n    USHORT iExtendBlock;\n    USHORT iFlushBlock;\n    ULONG cNewBlockSectors;\n    ULONG cExtendStartSectors;\n    ULONG cExtendSectors;\n    CLFS_TRUNCATE_CONTEXT cxTruncate;\n    USHORT cBlocks;\n    ULONG cReserved;\n    CLFS_METADATA_BLOCK rgBlocks[ANYSIZE_ARRAY];\n} CLFS_CONTROL_RECORD, *PCLFS_CONTROL_RECORD;\n</pre>\n</div> \n<p>After <em>Version</em>, the next set of fields are all related to CLFS Log Extension. This data could potentially be non-zero in memory, but for a stable Base Log File on disk, all of these fields are expected to be zero. This does not, of course, imply the CLFS driver or code necessarily makes this assumption.</p> \n<p>The first CLFS Log Extension field, <tt><strong>eExtendState</strong></tt>, identifies the current <em>extend state</em> for the file using the enumeration below:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\ntypedef enum _CLFS_EXTEND_STATE\n{\n    ClfsExtendStateNone,\n    ClfsExtendStateExtendingFsd,\n    ClfsExtendStateFlushingBlock\n} CLFS_EXTEND_STATE, *PCLFS_EXTEND_STATE;\n</pre>\n</div> \n<p>The next two values <tt><strong>iExtendBlock</strong></tt> and <tt><strong>iFlushBlock</strong></tt> identify the index of the block being extended, followed by the block being flushed, the latter of which will normally be the shadow block. Next, the sector size of the <em>new block</em> is stored in <tt><strong>cNewBlockSectors</strong></tt> and the original sector size before the extend operation is stored in <tt><strong>cExtendStartSectors</strong></tt>. Finally, the number of sectors that were added is saved in <tt><strong>cExtendSectors</strong></tt>.</p> \n<ul>\n <li><tt><strong>Block Context</strong></tt>: The control record ends with the <tt>rgBlocks</tt> array, which defines the set of metadata blocks that exist in the Base Log File. Although this is expected to be 6, there could potentially exist additional metadata blocks, and so for forward support, the <tt>cBlocks</tt> field<br>indicates the number of blocks in the array.</br></li>\n</ul> \n<p>Each array entry is identified by the <tt>CLFS_METADATA_BLOCK</tt> structure, shown below:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\ntypedef struct _CLFS_METADATA_BLOCK\n{\n    union\n    {\n        PUCHAR pbImage;\n        ULONGLONG ullAlignment;\n    };\n    ULONG cbImage;\n    ULONG cbOffset;\n    CLFS_METADATA_BLOCK_TYPE eBlockType;\n} CLFS_METADATA_BLOCK, *PCLFS_METADATA_BLOCK;\n</pre>\n</div> \n<p>On disk, the <tt>cbOffset</tt> field indicates the offset, starting from the control metadata block (i.e.: the first sector in the Base Log File). Of where the metadata block can be found. The <tt>cbImage</tt> field, on the other hand, contains the size of the corresponding block, while the <tt>eBlockType</tt><br>corresponds to the previously shown enumeration of possible metadata block types.</br></p> \n<p>In memory, an additional field, <tt>pbImage</tt>, is used to store a pointer to the data in kernel-mode memory.</p> \n<h3>CLFS In-Memory Class</h3> \n<p>Once in memory, a CLFS Base Log File is represented by a <tt>CClfsBaseFile</tt> class, which can be further extended by a <tt>CClfsBaseFilePersisted</tt>. The definition for the former can be found in public symbols and is shown below:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nstruct _CClfsBaseFile\n{\n    ULONG m_cRef;\n    PUCHAR m_pbImage;\n    ULONG m_cbImage;\n    PERESOURCE m_presImage;\n    USHORT m_cBlocks;\n    PCLFS_METADATA_BLOCK m_rgBlocks;\n    PUSHORT m_rgcBlockReferences;\n    CLFSHASHTBL m_symtblClient;\n    CLFSHASHTBL m_symtblContainer;\n    CLFSHASHTBL m_symtblSecurity;\n    ULONGLONG m_cbContainer;\n    ULONG m_cbRawSectorSize;\n    BOOLEAN m_fGeneralBlockReferenced;\n} CClfsBaseFile, *PCLFSBASEFILE;\n</pre>\n</div> \n<p>These fields mainly represent data seen earlier, such as the size of the container, the sector size, the array of metadata blocks and their number, as well as the size of the whole Base Log File and its location in kernel mode memory. Additionally, the class is reference counted, and almost any access to any of its fields is protected by the <tt>m_presImage</tt> lock, which is an <em>executive resource</em> accessed in either shared or exclusive mode. Finally, each block itself is also referenced in the <tt>m_rgcBlockReferences</tt> array, noting there’s a limit of <tt>65535</tt> references. When the general block has been referenced at least once, the <tt>m_fGeneralBlockReferenced</tt> boolean is used to indicate the fact.</p> \n<h2 id=\"section-code_analysis\">Code Analysis</h2> \n<p>All code listings show decompiled C code; source code is not available in the affected product.<br>Structure definitions are obtained by reverse engineering and may not accurately reflect structures defined in the source code.</br></p> \n<h3>Opening a Log File</h3> \n<p>The <tt><a href=\"https://docs.microsoft.com/en-us/windows/win32/api/clfsw32/nf-clfsw32-createlogfile\">CreateLogFile()</a></tt> function in the Win32 API can be used to open an existing log. This function triggers a call to<tt> CClfsBaseFilePersisted::OpenImage()</tt> in <em>clfs.sys</em>. The pseudocode of <tt>CClfsBaseFilePersisted::OpenImage()</tt> is listed below:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nlong __thiscall\nCClfsBaseFilePersisted::OpenImage\n          (CClfsBaseFilePersisted *this,_UNICODE_STRING *ExtFileName,_CLFS_FILTER_CONTEXT *ClfsFilterContext,\n          unsigned_char param_3,unsigned_char *param_4)\n\n{\n\n[Truncated]\n\n[1]\n\n    Status = CClfsContainer::Open(this-&gt;CclfsContainer,ExtFileName,ClfsFilterContext,param_3,local_48);\n    if ((int)Status &lt; 0) {\nLAB_fffff801226897c8:\n        StatusDup = Status;\n        if (Status != 0xc0000011) goto LAB_fffff80122689933;\n    }\n    else {\n        StatusDup = Status;\n        UVar4 = CClfsContainer::GetRawSectorSize(this-&gt;field_0x98_CclfsContainer);\n        this-&gt;rawsectorSize = UVar4;\n        if ((0xfff &lt; UVar4 - 1) || ((UVar4 &amp; 0x1ff) != 0)) {\n            Status = 0xc0000098;\n            StatusDup = Status;\n            goto LAB_fffff80122689933;\n        }\n\n[2]\n\n        Status = ReadImage(this,&amp;ClfsControlRecord);\n        if ((int)Status &lt; 0) goto LAB_fffff801226897c8;\n        StatusDup = Status;\n        Status = CClfsContainer::GetContainerSize(this-&gt;CclfsContainer,&amp;this-&gt;ContainerSize);\n        StatusDup = Status;\n        if ((int)Status &lt; 0) goto LAB_fffff80122689933;\n        ClfsBaseLogRecord = CClfsBaseFile::GetBaseLogRecord((CClfsBaseFile *)this);\n        ControlRecord = ClfsControlRecord;\n        if (ClfsBaseLogRecord != NULL) {\n\n[Truncated]\n\n[3]\n\n            if (ClfsControlRecord-&gt;eExtendState == 0) goto LAB_fffff80122689933;\n            Block = ClfsControlRecord-&gt;iExtendBlock;\n            if (((((Block != 0) &amp;&amp; (Block &lt; this-&gt;m_cBlocks)) &amp;&amp; (Block &lt; 6)) &amp;&amp;\n                ((Block = ClfsControlRecord-&gt;iFlushBlock, Block != 0 &amp;&amp; (Block &lt; this-&gt;m_cBlocks)))) &amp;&amp;\n               ((Block &lt; 6 &amp;&amp;\n                (m_cbContainer = CClfsBaseFile::GetSize((CClfsBaseFile *)this),\n                ControlRecord-&gt;cExtendStartSectors &lt; m_cbContainer &gt;&gt; 9 ||\n                ControlRecord-&gt;cExtendStartSectors == m_cbContainer &gt;&gt; 9)))) {\n                cExtendSectors&gt;&gt;1 = ControlRecord-&gt;cExtendSectors &gt;&gt; 1;\n                uVar8 = (this-&gt;m_rgBlocks[ControlRecord-&gt;iExtendBlock].cbImage &gt;&gt; 9) + cExtendSectors&gt;&gt;1;\n                if (ControlRecord-&gt;cNewBlockSectors &lt; uVar8 || ControlRecord-&gt;cNewBlockSectors == uVar8) {\n\n[4]\n\n                    Status = ExtendMetadataBlock(this,(uint)ControlRecord-&gt;iExtendBlock,cExtendSectors&gt;&gt;1);\n                    StatusDup = Status;\n                    goto LAB_fffff80122689933;\n                }\n            }\n        }\n    }\n\n[Truncated]\n\n}\n\n</pre>\n</div> \n<p>After initializing some in-memory data structures, <tt>CClfsContainer:Open()</tt> is called to open the existing <em>Base Log File</em> at [1]. <tt>ReadImage()</tt> is then called to read the <em>Base Log File</em> at [2]. If the <em>current extend state</em> in the <em>Extend Context</em> is not <tt>ClfsExtendStateNone</tt>(<em>0</em>) at [3], the<br>possibility to expand the <em>Base Log File</em> is explored.</br></p> \n<p>If the original sector size before the previous extension (<tt>ControlRecord-&gt;cExtendStartSectors</tt>) is less than or equal to the current sector size of<br>the <em>Base Log File</em> (<tt>m_cbContainer</tt>), and the sector size of the Block (to be expanded) after the previous extension (<tt>ControlRecord-&gt;cNewBlockSectors</tt>) is less than or equal to the latest required sector size (current sector size of the Block to be expanded <tt>this-&gt;m_rgBlocks[ControlRecord-&gt;iExtendBlock].cbImage &gt;&gt; 9</tt> plus the number of sectors previously added <tt>cExtendSectors &gt;&gt; 1</tt>), the <em>Base Log File</em> needs expansion. <tt>ExtendMetadataBlock()</tt> is duly called at [4].</br></p> \n<p>Note:</p> \n<ul>\n <li>In all non-malicious cases, the <em>current extend state</em> is expected to be <tt>ClfsExtendStateNone</tt>(<em>0</em>) when the log file is written to disk.</li>\n <li>Since the <em>Extend Context</em> is under attacker control (described below), all the fields discussed above can be set by the attacker.</li>\n</ul> \n<h3>Reading Base Log File</h3> \n<p>The <tt>CClfsBaseFilePersisted::ReadImage()</tt> function called at [2] is responsible for reading the <em>Base Log File</em> from disk. The pseudocode of this function is listed below:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nint CClfsBaseFilePersisted::ReadImage\n              (CClfsBaseFilePersisted *BaseFilePersisted,_CLFS_CONTROL_RECORD **ClfsControlRecordPtr)\n\n{\n\n[Truncated]\n\n[5]\n\n    BaseFilePersisted-&gt;m_cBlocks = 6;\n    m_rgBlocks = (CLFS_METADATA_BLOCK *)ExAllocatePoolWithTag(0x200,0x90,0x73666c43);\n    BaseFilePersisted-&gt;m_rgBlocks = m_rgBlocks;\n\n[Truncated]\n\n[6]\n\n        memset(BaseFilePersisted-&gt;m_rgBlocks,0,(ulonglong)BaseFilePersisted-&gt;m_cBlocks * 0x18);\n        memset(BaseFilePersisted-&gt;m_rgcBlockReferences,0,(ulonglong)BaseFilePersisted-&gt;m_cBlocks * 2);\n\n[7]\n\n        BaseFilePersisted-&gt;m_rgBlocks-&gt;cbOffset = 0;\n        BaseFilePersisted-&gt;m_rgBlocks-&gt;cbImage = BaseFilePersisted-&gt;m_cbRawSectorSize * 2;\n        BaseFilePersisted-&gt;m_rgBlocks[1].cbOffset = BaseFilePersisted-&gt;m_cbRawSectorSize * 2;\n        BaseFilePersisted-&gt;m_rgBlocks[1].cbImage = BaseFilePersisted-&gt;m_cbRawSectorSize * 2;\n\n[8]\n\n        local_48 = CClfsBaseFile::GetControlRecord((CClfsBaseFile *)BaseFilePersisted,ClfsControlRecordPtr);\n\n[9]\n\n                        p_Var2 = BaseFilePersisted-&gt;m_rgBlocks-&gt;pbImage;\n                        for (; (uint)indexIter &lt; (uint)BaseFilePersisted-&gt;m_cBlocks;\n                            indexIter = (ulonglong)((uint)indexIter + 1)) {\n                            ControlRecorD = *ClfsControlRecordPtr;\n                            pCVar3 = BaseFilePersisted-&gt;m_rgBlocks;\n                            pCVar1 = ControlRecorD-&gt;rgBlocks + indexIter;\n                            uVar6 = *(undefined4 *)((longlong)&amp;pCVar1-&gt;pbImage + 4);\n                            uVar5 = pCVar1-&gt;cbImage;\n                            uVar7 = pCVar1-&gt;cbOffset;\n                            m_rgBlocks = pCVar3 + indexIter;\n                            *(undefined4 *)&amp;m_rgBlocks-&gt;pbImage = *(undefined4 *)&amp;pCVar1-&gt;pbImage;\n                            *(undefined4 *)((longlong)&amp;m_rgBlocks-&gt;pbImage + 4) = uVar6;\n                            m_rgBlocks-&gt;cbImage = uVar5;\n                            m_rgBlocks-&gt;cbOffset = uVar7;\n                            pCVar3[indexIter].eBlockType = ControlRecorD-&gt;rgBlocks[indexIter].eBlockType;\n                            BaseFilePersisted-&gt;m_rgBlocks[indexIter].pbImage = NULL;\n                        }\n                        BaseFilePersisted-&gt;m_rgBlocks-&gt;pbImage = p_Var2;\n                        BaseFilePersisted-&gt;m_rgBlocks[1].pbImage = p_Var2;\n\n[10]\n\n                        local_48 = CClfsBaseFile::AcquireMetadataBlock(BaseFilePersisted,ClfsMetaBlockGeneral);\n                        if (-1 &lt; (int)local_48) {\n                            BaseFilePersisted-&gt;field_0x94 = '\\x01';\n                        }\n                        goto LAB_fffff80654e09f9e;\n\n[Truncated]\n\n}\n\n</pre>\n</div> \n<p>The in-memory buffer of the <tt>rgBlocks</tt> array, which defines the set of metadata blocks that exist in the <em>Base Log File</em>, is allocated (<tt>m_rgBlocks</tt>) at [5]. Each array entry is identified by the <tt>CLFS_METADATA_BLOCK</tt> structure, which is of size <em>0x18</em>. The <tt>cBlocks</tt> field, which indicates the number of blocks in the array, is set to the default value <em>6</em> (Hence, the size of allocation for <tt>m_rgBlocks</tt> is <tt>0x18 * 6 = 0x90</tt>).</p> \n<p>The content in <tt>m_rgBlocks</tt> is initialized to <em>0</em> at [6]. The first two entries in <tt>m_rgBlocks</tt> are for the <em>Control Record</em> and its shadow, both of which have a fixed size of <em>0x400</em>. The sizes and offsets for these blocks are duly set at [7].</p> \n<p>At this stage, <tt>m_rgBlocks</tt> looks like the following in memory:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nffffc60c`53904380  00000000`00000000 00000000`00000400\nffffc60c`53904390  00000000`00000000 00000000`00000000\nffffc60c`539043a0  00000400`00000400 00000000`00000000\nffffc60c`539043b0  00000000`00000000 00000000`00000000\nffffc60c`539043c0  00000000`00000000 00000000`00000000\nffffc60c`539043d0  00000000`00000000 00000000`00000000\nffffc60c`539043e0  00000000`00000000 00000000`00000000\nffffc60c`539043f0  00000000`00000000 00000000`00000000\nffffc60c`53904400  00000000`00000000 00000000`00000000\n\n</pre>\n</div> \n<p><tt>CClfsBaseFile::GetControlRecord()</tt> is called to retrieve the <em>Control Record</em> from the <em>Base Log File</em> at [8]. The <tt>pbImage</tt> field in the first two entries in <tt>m_rgBlocks</tt> are duly populated. More on this below.</p> \n<p>At this stage, <tt>m_rgBlocks</tt> contains the following values:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nffffc60c`53904380  ffffb60a`b7c79b40 00000000`00000400\nffffc60c`53904390  00000000`00000000 ffffb60a`b7c79b40\nffffc60c`539043a0  00000400`00000400 00000000`00000000\nffffc60c`539043b0  00000000`00000000 00000000`00000000\nffffc60c`539043c0  00000000`00000000 00000000`00000000\nffffc60c`539043d0  00000000`00000000 00000000`00000000\nffffc60c`539043e0  00000000`00000000 00000000`00000000\nffffc60c`539043f0  00000000`00000000 00000000`00000000\nffffc60c`53904400  00000000`00000000 00000000`00000000\n\n</pre>\n</div> \n<p>The <tt>rgBlocks</tt> array from the <em>Control Record</em> is copied into <tt>m_rgBlocks</tt> at [9]. Thus, the sizes and corresponding offsets of each of the metadata blocks is saved.</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nffffc60c`53904380  ffffb60a`b7c79b40 00000000`00000400\nffffc60c`53904390  00000000`00000000 ffffb60a`b7c79b40\nffffc60c`539043a0  00000400`00000400 00000000`00000001\nffffc60c`539043b0  00000000`00000000 00000800`00007a00\nffffc60c`539043c0  00000000`00000002 00000000`00000000\nffffc60c`539043d0  00008200`00007a00 00000000`00000003\nffffc60c`539043e0  00000000`00000000 0000fc00`00000200\nffffc60c`539043f0  00000000`00000004 00000000`00000000\nffffc60c`53904400  0000fe00`00000200 00000000`00000005\n\n</pre>\n</div> \n<p><tt>AcquireMetadataBlock()</tt> is called with the second parameter set to <em>ClfsMetaBlockGeneral</em> to read in the <em>General Metadata Block</em> from the<em> Base Log File</em> at [10]. The <tt>pbImage</tt> field for the corresponding entry and its shadow in <tt>m_rgBlocks</tt> are duly populated. More on this below.</p> \n<p>At this stage, <tt>m_rgBlocks</tt> looks like the following in memory:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nffffc60c`53904380  ffffb60a`b7c79b40 00000000`00000400\nffffc60c`53904390  00000000`00000000 ffffb60a`b7c79b40\nffffc60c`539043a0  00000400`00000400 00000000`00000001\nffffc60c`539043b0  ffffb60a`b9ead000 00000800`00007a00\nffffc60c`539043c0  00000000`00000002 ffffb60a`b9ead000\nffffc60c`539043d0  00008200`00007a00 00000000`00000003\nffffc60c`539043e0  00000000`00000000 0000fc00`00000200\nffffc60c`539043f0  00000000`00000004 00000000`00000000\nffffc60c`53904400  0000fe00`00000200 00000000`00000005\n\n</pre>\n</div> \n<p>It is important to note that the <tt>pbImage</tt> field for the <em>General Metadata Block</em> and its shadow point to the same memory (refer [17] and [20]).</p> \n<h3>Reading Control Record</h3> \n<p>Internally, <tt>CClfsBaseFilePersisted::ReadImage()</tt> calls<tt> CClfsBaseFile::GetControlRecord()</tt> to retrieve the <em>Control Record</em>. The pseudocode of<br><tt>CClfsBaseFile::GetControlRecord()</tt> is listed below:</br></p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nlong __thiscall CClfsBaseFile::GetControlRecord(CClfsBaseFile *this,_CLFS_CONTROL_RECORD **ClfsControlRecordptr)\n\n{\n    uint iVar4;\n    astruct_12 *lVar3;\n    _CLFS_LOG_BLOCK_HEADER *pbImage;\n    uint RecordOffset;\n    uint cbImage;\n\n    *ClfsControlRecordptr = NULL;\n\n[11]\n\n    iVar4 = AcquireMetadataBlock((CClfsBaseFilePersisted *)this,0);\n    if (-1 &lt; (int)iVar4) {\n        cbImage = this-&gt;m_rgBlocks-&gt;cbImage;\n        ControlMetadataBlock = this-&gt;m_rgBlocks-&gt;pbImage;\n        RecordOffset = pbImage-&gt;RecordOffsets[0];\n        if (((RecordOffset &lt; cbImage) &amp;&amp; (0x6f &lt; RecordOffset)) &amp;&amp; (0x67 &lt; cbImage - RecordOffset)) {\n\n[12]\n\n            *ClfsControlRecordptr =\n                 (_CLFS_CONTROL_RECORD *)((longlong)ControlMetadataBlock-&gt;RecordOffsets + ((ulonglong)RecordOffset - 0x28));\n        }\n        else {\n            iVar4 = 0xc01a000d;\n        }\n    }\n    return (long)iVar4;\n}\n\n</pre>\n</div> \n<p><tt>AcquireMetadataBlock()</tt> is called with the second parameter of type <tt>_CLFS_METADATA_BLOCK_TYPE</tt> set to <em>ClfsMetaBlockControl</em> (<em>0</em>) to acquire the<br><em>Control MetaData Block</em> at [11]. The record offset is retrieved and used to calculate the address of the <em>Control Record</em>, which is saved at [12].</br></p> \n<h3>Acquiring Metadata Block</h3> \n<p>The <tt>CClfsBaseFile::AcquireMetadataBlock()</tt> function is used to acquire a metadata block. The pseudocode of this function is listed below:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nint CClfsBaseFile::AcquireMetadataBlock\n              (CClfsBaseFilePersisted *ClfsBaseFilePersisted,_CLFS_METADATA_BLOCK_TYPE BlockType)\n\n{\n    ulong lVar1;\n    longlong BlockTypeDup;\n\n    lVar1 = 0;\n    if (((int)BlockType &lt; 0) || ((int)(uint)ClfsBaseFilePersisted-&gt;m_cBlocks &lt;= (int)BlockType)) {\n        lVar1 = 0xc0000225;\n    }\n    else {\n        BlockTypeDup = (longlong)(int)BlockType;\n\n[13]\n\n        ClfsBaseFilePersisted-&gt;m_rgcBlockReferences[BlockTypeDup] =\n             ClfsBaseFilePersisted-&gt;m_rgcBlockReferences[BlockTypeDup] + 1;\n\n[14]\n\n        if ((ClfsBaseFilePersisted-&gt;m_rgcBlockReferences[BlockTypeDup] == 1) &amp;&amp;\n           (lVar1 = (*ClfsBaseFilePersisted-&gt;vftable-&gt;field_0x8)(ClfsBaseFilePersisted,BlockType), (int)lVar1 &lt; 0))\n        {\n            ClfsBaseFilePersisted-&gt;m_rgcBlockReferences[BlockTypeDup] =\n                 ClfsBaseFilePersisted-&gt;m_rgcBlockReferences[BlockTypeDup] - 1;\n        }\n    }\n    return (int)lVar1;\n}\n\n</pre>\n</div> \n<p>The <tt>m_rgcBlockReferences</tt> entry for the <em>Control Metadata Block</em> is increased by <em>1</em> to signal its usage at [13].</p> \n<p>If the reference count is <em>1</em>, it is clear the <em>Control Metadata Block</em> was not being actively used (prior to this). In this case, it needs to be read from disk. The second entry in the virtual function table is set to <tt>CClfsBaseFilePersisted::ReadMetadataBlock()</tt>, which is duly called at [14].</p> \n<h3>Read Metadata Block</h3> \n<p>The <tt>CClfsBaseFilePersisted::ReadMetadataBlock()</tt> function is used to read a metadata block from disk. The pseudocode of this function is listed below:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nulong __thiscall\nCClfsBaseFilePersisted::ReadMetadataBlock(CClfsBaseFilePersisted *this,_CLFS_METADATA_BLOCK_TYPE BlockType)\n\n{\n\n[Truncated]\n\n[15]\n\n    cbImage = this-&gt;m_rgBlocks[(longlong)_BlockTypeDup].cbImage;\n    cbOffset = (PIRP)(ulonglong)this-&gt;m_rgBlocks[(longlong)_BlockTypeDup].cbOffset;\n    if (cbImage == 0) {\n        uVar3 = 0;\n    }\n    else {\n        if (0x6f &lt; cbImage) {\n\n[16]\n\n            ClfsMetadataBlock =\n                 (_CLFS_LOG_BLOCK_HEADER *)ExAllocatePoolWithTag(PagedPoolCacheAligned,(ulonglong)cbImage,0x73666c43);\n            if (ClfsMetadataBlock == NULL) {\n                uVar1 = 0xc000009a;\n            }\n            else {\n\n[17]\n\n                this-&gt;m_rgBlocks[(longlong)_BlockTypeDup].pbImage = ClfsMetadataBlock;\n                memset(ClfsMetadataBlock,0,(ulonglong)cbImage);\n                *(undefined4 *)&amp;this-&gt;field_0xc8 = 0;\n                this-&gt;field_0xd0 = 0;\n                local_40 = local_40 &amp; 0xffffffff00000000;\n                local_50 = CONCAT88(local_50._8_8_,ClfsMetadataBlock);\n\n[18]\n\n                uVar5 = CClfsContainer::ReadSector\n                                  ((ULONG_PTR)this-&gt;CclfsContainer,this-&gt;ObjectBody,NULL,(longlong *)local_50,\n                                   cbImage &gt;&gt; 9,&amp;cbOffset);\n                uVar3 = (ulong)uVar5;\n                if (((int)uVar3 &lt; 0) ||\n                   (uVar3 = KeWaitForSingleObject(this-&gt;ObjectBody,Executive,'\\0','\\0',NULL), (int)uVar3 &lt; 0))\n                goto LAB_fffff801226841ad;\n                this_00 = (CClfsBaseFilePersisted *)ClfsMetadataBlock;\n\n[19]\n\n                uVar3 = ClfsDecodeBlock(ClfsMetadataBlock,cbImage &gt;&gt; 9,*(unsigned_char *)&amp;ClfsMetadataBlock-&gt;UpdateCount\n                                        ,(unsigned_char)0x10,local_res20);\n\n[Truncated]\n\n                    ShadowBlockType = BlockType + ClfsMetaBlockControlShadow;\n                    uVar6 = (ulonglong)ShadowBlockType;\n\n                            this-&gt;m_rgBlocks[ShadowBlockTypeDup].pbImage = NULL;\n                            this-&gt;m_rgBlocks[ShadowBlockTypeDup].cbImage =\n                                 this-&gt;m_rgBlocks[(longlong)_BlockTypeDup].cbImage;\n\n[20]\n\n                            this-&gt;m_rgBlocks[ShadowBlockTypeDup].pbImage =\n                                 this-&gt;m_rgBlocks[(longlong)_BlockTypeDup].pbImage;\n\n[Truncated]\n\n</pre>\n</div> \n<p>The size of the Metadata block to be read is retrieved and saved in <tt>cbImage</tt>. Note that these sizes are stored in the <em>Control Record</em> of the <em>Base Log File</em>.</p> \n<p>To read the <em>Control Record</em>, the hardcoded value is taken at [15], as the <em>Control Record</em> is of a fixed size. Memory (<tt>ClfsMetadataBlock</tt>) is allocated to read the metadata block from disk at [16]. The corresponding <tt>pbImage</tt> entry in <tt>m_rgBlocks</tt> is filled in and<tt> ClfsMetadataBlock</tt> is initialized to <em>0</em> at [17]. The function <tt>CClfsContainer::ReadSector()</tt> is called to read the specified number of sectors from disk at [18].</p> \n<p><tt>ClfsMetadataBlock</tt> now contains the exact contents of the metadata Block as present in the file. It is important to note that the <em>Control Metadata Block</em> contains the <em>Control Context</em> as described earlier. Thus, the contents of the <em>Control Context</em> are fully controlled by the attacker.<br><tt>ClfsMetadataBlock</tt> is decoded via a call to <tt>ClfsDecodeBlock</tt> at [19]. It is also important to note that in the case of the <em>Control Metadata Block</em>, this does not modify any field in the <em>Control Context</em>. The corresponding shadow <tt>pbImage</tt> entry in <tt>m_rgBlocks</tt> is also set to <tt>ClfsMetadataBlock</tt> at [20].</br></p> \n<h3>Extending Metadata Block</h3> \n<p>The call to <tt>ExtendMetadataBlock()</tt> at [4] is used to extend the size of a particular metadata block in the <em>Base Log File</em>. The pseudocode of this function pertaining to when the <em>current extend state</em> is <tt>ClfsExtendStateFlushingBlock</tt>(<em>2</em>) is listed below:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nlong __thiscall\nCClfsBaseFilePersisted::ExtendMetadataBlock\n          (CClfsBaseFilePersisted *this,_CLFS_METADATA_BLOCK_TYPE BlockType,unsigned_long cExtendSectors&gt;&gt;1)\n{\n\n[Truncated]\n\n    do {\n        ret = retDup;\n        if (*ExtendPhasePtr != 2) break;\n        iFlushBlockPtr = &amp;ClfsControlRecordDup-&gt;iFlushBlock;\n        iExtendBlockPtr = &amp;ClfsControlRecordDup-&gt;iExtendBlock;\n\n[21]\n\n        iFlushBlock = *iFlushBlockPtr;\n        iFlushBlockDup = (ulonglong)iFlushBlock;\n        iExtendBlock = *iExtendBlockPtr;\n        iFlushBlockDup2 = (uint)iFlushBlock;\n\n[22]\n\n        if (((iFlushBlock == iExtendBlock) ||\n            (uVar4 = IsShadowBlock(this_00,iFlushBlockDup2,(uint)iExtendBlock),\n            uVar4 != (unsigned_char)0x0)) &amp;&amp;\n           (this-&gt;m_rgBlocks[iFlushBlockDup].cbImage &gt;&gt; 9 &lt;\n            ClfsControlRecordDup-&gt;cNewBlockSectors)) {\n            ExtendMetadataBlockDescriptor\n                      (this,iFlushBlockDup2,\n                       ClfsControlRecordDup-&gt;cExtendSectors &gt;&gt; 1);\n            iFlushBlockDup = (ulonglong)*iFlushBlockPtr;\n        }\n        WriteMetadataBlock(this,(uint)iFlushBlockDup &amp; 0xffff,(unsigned_char)0x0);\n        if (*puVar1 == *puVar2) {\n            *ExtendPhasePtr = 0;\n        }\n        else {\n            *puVar1 = *puVar1 - 1;\n\n[23]\n\n            ret = ProcessCurrentBlockForExtend(this,ClfsControlRecordDup);\n            retDup = ret;\n            if ((int)ret &lt; 0) break;\n        }\n\n[Truncated]\n\n</pre>\n</div> \n<p>The index of the block being extended (<tt>iFlushBlock</tt>) and the block being flushed (<tt>iExtendBlock</tt>) are extracted from the <em>Extend Context</em> in the<em> Control Record</em> of the <em>Base Log File</em> at [21]. With specially crafted values of the above fields and <tt>cNewBlockSectors</tt> at [22], code execution reaches <tt>ProcessCurrentBlockForExtend()</tt> at [23]. <tt>ProcessCurrentBlockForExtend()</tt> internally calls<tt> ExtendMetadataBlockDescriptor()</tt>, whose pseudocode is listed below:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nlong __thiscall\nCClfsBaseFilePersisted::ExtendMetadataBlockDescriptor\n          (CClfsBaseFilePersisted *this,_CLFS_METADATA_BLOCK_TYPE iFlushBlock,unsigned_long cExtendSectors&gt;&gt;1)\n\n{\n\n[Truncated]\n\n    iFlushBlockDup = (ulonglong)iFlushBlock;\n    NewMetadataBlock = NULL;\n    RecordHeader = NULL;\n    iVar13 = 0;\n    uVar3 = this-&gt;m_cbRawSectorSize;\n    if (uVar3 == 0) {\n        NewSize = 0;\n    }\n    else {\n        NewSize = (uVar3 - 1) + this-&gt;m_rgBlocks[iFlushBlockDup].cbImage + cExtendSectors&gt;&gt;1 * 0x200 &amp; -uVar3;\n    }\n    RecordsParamsPtr = this-&gt;m_rgBlocks;\n    pCVar1 = RecordsParamsPtr + iFlushBlockDup;\n    uVar4 = *(undefined4 *)&amp;pCVar1-&gt;pbImage;\n    uVar5 = *(undefined4 *)((longlong)&amp;pCVar1-&gt;pbImage + 4);\n    uVar3 = pCVar1-&gt;cbImage;\n    uVar6 = pCVar1-&gt;cbOffset;\n    CVar2 = RecordsParamsPtr[iFlushBlockDup].eBlockType;\n    ShadowIndex._0_4_ = iFlushBlock + ClfsMetaBlockControlShadow;\n    ShadowIndex = (ulonglong)(uint)ShadowIndex;\n    uVar7 = IsShadowBlock((CClfsBaseFilePersisted *)ShadowIndex,iFlushBlock,(uint)ShadowIndex);\n    if ((uVar7 == (unsigned_char)0x0) &amp;&amp;\n       (uVar7 = IsShadowBlock((CClfsBaseFilePersisted *)ShadowIndex,(unsigned_long)ShadowIndex,iFlushBlock),\n       uVar7 != (unsigned_char)0x0)) {\n        if (RecordsParamsPtr[iFlushBlockDup].pbImage != NULL) {\n\n[24]\n\n            ExFreePoolWithTag(RecordsParamsPtr[iFlushBlockDup].pbImage,0);\n            this-&gt;m_rgBlocks[iFlushBlockDup].pbImage = NULL;\n            RecordsParamsPtr = this-&gt;m_rgBlocks;\n            ShadowIndex = (ulonglong)(iFlushBlock + ClfsMetaBlockControlShadow);\n        }\n\n[25]\n\n        RecordsParamsPtr[iFlushBlockDup].cbImage = RecordsParamsPtr[ShadowIndex].cbImage;\n        m_rgBlocksDup = this-&gt;m_rgBlocks;\n        m_rgBlocksDup[iFlushBlockDup].pbImage = m_rgBlocks[ShadowIndex].pbImage;\n\n[Truncated]\n\n\n</pre>\n</div> \n<p>With carefully crafted values in the <em>Control Record</em> of the <em>Base Log File</em>, code execution reaches [24].</p> \n<p>At this stage, <tt>m_rgBlocks</tt> looks like the following in memory:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nffffc60c`53904380  ffffb60a`b7c79b40 00000000`00000400\nffffc60c`53904390  00000000`00000000 ffffb60a`b7c79b40\nffffc60c`539043a0  00000400`00000400 00000000`00000001\nffffc60c`539043b0  ffffb60a`b9ead000 00000800`00007a00\nffffc60c`539043c0  00000000`00000002 ffffb60a`b9ead000\nffffc60c`539043d0  00008200`00007a00 00000000`00000003\nffffc60c`539043e0  00000000`00000000 0000fc00`00000200\nffffc60c`539043f0  00000000`00000004 00000000`00000000\nffffc60c`53904400  0000fe00`00000200 00000000`00000005\n\n</pre>\n</div> \n<p>It is important to note that the <tt>pbImage</tt> field for the <em>General Metadata Block</em> and its shadow point to the same memory (refer to [17] and [20]). The <tt>pbImage</tt> field of the <tt>iFlushBlock</tt> index in <tt>m_rgBlocks</tt> is freed, and the corresponding entry is cleared at [24]. For example, if <tt>iFlushBlock</tt> is set to <em>2</em>, <tt>m_rgBlocks</tt> looks like the following in memory:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nffffc60c`53904380  ffffb60a`b7c79b40 00000000`00000400\nffffc60c`53904390  00000000`00000000 ffffb60a`b7c79b40\nffffc60c`539043a0  00000400`00000400 00000000`00000001\nffffc60c`539043b0  00000000`00000000 00000800`00007a00\nffffc60c`539043c0  00000000`00000002 ffffb60a`b9ead000\nffffc60c`539043d0  00008200`00007a00 00000000`00000003\nffffc60c`539043e0  00000000`00000000 0000fc00`00000200\nffffc60c`539043f0  00000000`00000004 00000000`00000000\nffffc60c`53904400  0000fe00`00000200 00000000`00000005\n\n</pre>\n</div> \n<p>The entry is then repopulated with the shadow index entry at [25].</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nffffc60c`53904380  ffffb60a`b7c79b40 00000000`00000400\nffffc60c`53904390  00000000`00000000 ffffb60a`b7c79b40\nffffc60c`539043a0  00000400`00000400 00000000`00000001\nffffc60c`539043b0  ffffb60a`b9ead000 00000800`00007a00\nffffc60c`539043c0  00000000`00000002 ffffb60a`b9ead000\nffffc60c`539043d0  00008200`00007a00 00000000`00000003\nffffc60c`539043e0  00000000`00000000 0000fc00`00000200\nffffc60c`539043f0  00000000`00000004 00000000`00000000\nffffc60c`53904400  0000fe00`00000200 00000000`00000005\n\n</pre>\n</div> \n<p>Since the original entry and the shadow index entry pointed to the same memory, the repopulation leaves a reference to freed memory. Any use of the <em>General Metadata Block</em> will refer to this freed memory, resulting in a Use After Free.</p> \n<p>The vulnerability can be converted to a double free by closing the handle to the <em>Base Log File</em>. This will trigger a call to <tt>FreeMetadataBlock</tt>, which will free all <tt>pbImage</tt> entries in <tt>m_rgBlocks</tt>.</p> \n<h2 id=\"section-exploitation\">Exploitation</h2> \n<p>A basic understanding of the segment heap in the windows kernel introduced since the <em>19H1</em> update is required to understand the exploit mechanism. The paper titled <a href=\"https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf\" target=\"_blank\" rel=\"noreferrer noopener\">“Scoop the Windows 10 pool!”</a> from SSTIC 2020 describes this mechanism in detail.</p> \n<h3>Windows Notification Facility</h3> \n<p>Objects from Windows Notification Facility (<em>WNF</em>) are used to groom the heap and convert the use after free into a full exploit. A good understanding of <em>WNF</em> is thus required to understand the exploit. The details about <em>WNF</em> described below are taken from the following sources:</p> \n<ul>\n <li><a href=\"https://docplayer.net/145030841-The-windows-notification-facility.html\" target=\"_blank\" rel=\"noreferrer noopener\">The Windows Notification Facility The Most Undocumented Kernel Attack Surface Yet</a> </li>\n <li><a href=\"https://blog.quarkslab.com/playing-with-the-windows-notification-facility-wnf.html\" target=\"_blank\" rel=\"noreferrer noopener\">Playing with the Windows Notification Facility (WNF)</a></li>\n <li><a href=\"https://research.nccgroup.com/2021/07/15/cve-2021-31956-exploiting-the-windows-kernel-ntfs-with-wnf-part-1/\" target=\"_blank\" rel=\"noreferrer noopener\">CVE-2021-31956 Exploiting the Windows Kernel (NTFS with WNF) Part 1</a></li>\n</ul> \n<h3>Creating WNF State Name</h3> \n<p>When a <em>WNF</em> State Name is created via a call to <tt>NtCreateWnfStateName()</tt>, <tt>ExpWnfCreateNameInstance()</tt> is called internally to create a name<br>instance. The pseudocode of <tt>ExpWnfCreateNameInstance()</tt> is listed below:</br></p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nExpWnfCreateNameInstance\n          (_WNF_SCOPE_INSTANCE *ScopeInstance,_WNF_STATE_NAME *StateName,undefined4 *param_3,_KPROCESS *param_4,\n          _EX_RUNDOWN_REF **param_5)\n\n{\n\n[Truncated]\n\n    uVar23 = (uint)((ulonglong)StateName &gt;&gt; 4) &amp; 3;\n    if ((PsInitialSystemProcess == Process) || (uVar23 != 3)) {\n        SVar20 = 0xb8;\n        if (*(longlong *)(param_3 + 2) == 0) {\n            SVar20 = 0xa8;\n        }\n        NameInstance = (_WNF_NAME_INSTANCE *)ExAllocatePoolWithTag(PagedPool,SVar20,0x20666e57);\n    }\n    else {\n        SVar20 = 0xb8;\n        if (*(longlong *)(param_3 + 2) == 0) {\n\n[1]\n\n            SVar20 = 0xa8;\n        }\n\n[2]\n\n        NameInstance = (_WNF_NAME_INSTANCE *)ExAllocatePoolWithQuotaTag(9,SVar20,0x20666e57);\n    }\n\n\n</pre>\n</div> \n<p>A chunk of size <em>0xa8</em> (as seen at [1]) is allocated from the <em>Paged Pool</em> at [2] as a structure of type <tt>_WNF_NAME_INSTANCE</tt>. This results in an allocation of size <em>0xc0</em> from the LFH. This structure is listed below:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: plain; title: ; notranslate\">\nstruct _WNF_NAME_INSTANCE\n{\n    struct _WNF_NODE_HEADER Header;                                         //0x0\n    struct _EX_RUNDOWN_REF RunRef;                                          //0x8\n    struct _RTL_BALANCED_NODE TreeLinks;                                    //0x10\n\n    // [3]\n\n    struct _WNF_STATE_NAME_STRUCT StateName;                                //0x28\n    struct _WNF_SCOPE_INSTANCE* ScopeInstance;                              //0x30\n    struct _WNF_STATE_NAME_REGISTRATION StateNameInfo;                      //0x38\n    struct _WNF_LOCK StateDataLock;                                         //0x50\n\n    // [4]\n\n    struct _WNF_STATE_DATA* StateData;                                      //0x58\n    ULONG CurrentChangeStamp;                                               //0x60\n    VOID* PermanentDataStore;                                               //0x68\n    struct _WNF_LOCK StateSubscriptionListLock;                             //0x70\n    struct _LIST_ENTRY StateSubscriptionListHead;                           //0x78\n    struct _LIST_ENTRY TemporaryNameListEntry;                              //0x88\n\n    // [5]\n\n    struct _EPROCESS* CreatorProcess;                                       //0x98\n    LONG DataSubscribersCount;                                              //0xa0\n    LONG CurrentDeliveryCount;                                              //0xa4\n}; \n</pre>\n</div> \n<p>Relevant entries in the <tt>_WNF_NAME_INSTANCE</tt> structure include:</p> \n<ul>\n <li><tt>StateName</tt>: Uniquely identifies the name instance, shown at [3].</li>\n <li><tt>StateData</tt>: Stores the data associated with the instance, shown at [4].</li>\n <li><tt>CreatorProcess</tt>: Stores the address of the <tt>_EPROCESS</tt> structure of the process that created the name instance, shown at [5].</li>\n</ul> \n<p>The <tt>StateData</tt> is headed by a structure of type <tt>_WNF_STATE_DATA</tt>. This structure is listed below:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: plain; title: ; notranslate\">\nstruct _WNF_STATE_DATA\n{\n    // [6]\n\n    struct _WNF_NODE_HEADER Header;                                         //0x0\n\n    // [7]\n\n    ULONG AllocatedSize;                                                    //0x4\n    ULONG DataSize;                                                         //0x8\n    ULONG ChangeStamp;                                                      //0xc\n}; \n</pre>\n</div> \n<p>The <tt>StateData</tt> pointer is referred to when the <em>WNF</em> State Data is updated and queried. The variable-size data immediately follows the<tt> _WNF_STATE_DATA</tt> structure.</p> \n<h3>Updating WNF State Data</h3> \n<p>When the <em>WNF</em> State Data is updated via a call to <tt>NtUpdateWnfStateData()</tt>,<tt> ExpWnfWriteStateData()</tt> is called internally to write to the <tt>StateData</tt> pointer. The pseudocode of <tt>ExpWnfWriteStateData()</tt> is listed below.</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nvoid ExpWnfWriteStateData\n               (_WNF_NAME_INSTANCE *NameInstance,void *InputBuffer,ulonglong Length,int MatchingChangeStamp,\n               int CheckStamp)\n\n{\n\n[Truncated]\n\n    if (NameInstance-&gt;StateData != (_WNF_STATE_DATA *)0x1) {\n\n[8]\n\n        StateData = NameInstance-&gt;StateData;\n    }\n    LengtH = (uint)(Length &amp; 0xffffffff);\n\n[9]\n\n    if (((StateData == NULL) &amp;&amp; ((NameInstance-&gt;PermanentDataStore != NULL || (LengtH != 0)))) ||\n\n[10]\n\n       ((StateData != NULL &amp;&amp; (StateData-&gt;AllocatedSize &lt; LengtH)))) {\n\n[Truncated]\n\n[11]\n\n            StateData = (_WNF_STATE_DATA *)ExAllocatePoolWithQuotaTag(9,(ulonglong)(LengtH + 0x10),0x20666e57);\n\n[Truncated]\n\n[12]\n\n        StateData-&gt;Header = (_WNF_NODE_HEADER)0x100904;\n        StateData-&gt;AllocatedSize = LengtH;\n\n[Truncated]\n\n[13]\n\n        RtlCopyMemory(StateData + 1,InputBuffer,Length &amp; 0xffffffff);\n        StateData-&gt;DataSize = LengtH;\n        StateData-&gt;ChangeStamp = uVar5;\n\n[Truncated]\n\n    __security_check_cookie(local_30 ^ (ulonglong)&amp;stack0xffffffffffffff08);\n    return;\n}\n\n</pre>\n</div> \n<p>The <tt>InputBuffer</tt> and <tt>Length</tt> parameters to the function contain the contents and size of the data. It is important to note that these can be controlled by a user.</p> \n<p>The <tt>StateData</tt> pointer is first retrieved from the related name instance of type <tt>_WNF_NAME_INSTANCE</tt> at [8]. If the <tt>StateData</tt> pointer is <em>NULL</em> (as is the case initially) at [9], or if the current size is lesser than the size of the new data at [10], memory is allocated from the <em>Paged Pool</em> for the new <tt>StateData</tt> pointer at [11]. It important to note that the size of allocation is the size of the new data (<tt>Length</tt>) plus <em>0x10</em>, to account for the <tt>_WNF_STATE_DATA</tt> header. The <tt>Header</tt> and <tt>AllocateSize</tt> fields shown at [6] and [7] of the <tt>_WNF_STATE_DATA</tt> header are then initialized at [12].</p> \n<p>Note that if the current <tt>StateData</tt> pointer is large enough for the new data, code execution from [8] jumps directly to [13]. <tt>Length</tt> bytes from the <tt>InputBuffer</tt> parameter are then copied into the <tt>StateData</tt> pointer at [13]. The <tt>DataSize</tt> field in the <tt>_WNF_STATE_DATA</tt> header is also filled at [13].</p> \n<h3>Deleting WNF State Name</h3> \n<p>A <em>WNF</em> State Name can be deleted via a call to <tt>NtDeleteWnfStateName()</tt>. Among other things, this function frees the associated name instance and<tt> StateData</tt> buffers described above.</p> \n<h3>Querying WNF State Data</h3> \n<p>When <em>WNF</em> State Data is queried via a call to <tt>NtQueryWnfStateData()</tt>,<tt> ExpWnfReadStateData()</tt> is called internally to read from the <tt>StateData</tt> pointer. The pseudocode of <tt>ExpWnfReadStateData()</tt> is listed below.</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nundefined4\nExpWnfReadStateData(_WNF_NAME_INSTANCE *NameInstance,undefined4 *param_2,void *OutBuf,uint OutBufSize,undefined4 *param_5)\n\n{\n\n[Truncated]\n\n[14]\n\n    StateData = NameInstance-&gt;StateData;\n    if (StateData == NULL) {\n        *param_2 = 0;\n    }\n    else {\n        if (StateData != (_WNF_STATE_DATA *)0x1) {\n            *param_2 = StateData-&gt;ChangeStamp;\n            *param_5 = StateData-&gt;DataSize;\n\n[15]\n\n            if (OutBufSize &lt; StateData-&gt;DataSize) {\n                local_48 = 0xc0000023;\n            }\n            else {\n\n[16]\n\n                RtlCopyMemory(OutBuf,StateData + 1,(ulonglong)StateData-&gt;DataSize);\n                local_48 = 0;\n            }\n            goto LAB_fffff8054ce2383f;\n        }\n        *param_2 = NameInstance-&gt;CurrentChangeStamp;\n    }\n\n\n</pre>\n</div> \n<p>The <tt>OutBuf</tt> and <tt>OutBufSize</tt> parameters to the function are provided by the user to store the queried data. The <tt>StateData</tt> pointer is first retrieved from the related name instance of type <tt>_WNF_NAME_INSTANCE</tt> at [14]. If the output buffer is large enough to store the data (which is checked at [15]), <tt>StateData-&gt;DataSize</tt> bytes starting right after the <tt>StateData</tt> header are copied into the output buffer at [16].</p> \n<h3>Pipe Attributes</h3> \n<p><a href=\"https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe\" target=\"_blank\" rel=\"noreferrer noopener\">After the creation of a <em>pipe</em></a>, a user has the ability to add attributes to the <em>pipe</em>. The attributes are a key-value pair, and are stored into a <em>linked list</em>. The <em>PipeAttribute</em> object is allocated in the <em>PagedPool</em>, and has the following structure:</p> \n<div class=\"wp-block-syntaxhighlighter-code \">\n <pre class=\"brush: cpp; title: ; notranslate\">\nstruct PipeAttribute {\n    LIST_ENTRY list;\n    char * AttributeName;\n    uint64_t AttributeValueSize;\n    char * AttributeValue;\n    char data[0];\n};\n\n</pre>\n</div> \n<p>The size of the allocation and the data is fully controlled by an attacker. The <em>AttributeName</em> and <em>AttributeValue</em> are pointers pointing at different offsets of the data field. A <em>pipe attribute</em> can be created on a <em>pipe</em> using the <a href=\"https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntfscontrolfile\" target=\"_blank\" rel=\"noreferrer noopener\"><em>NtFsControlFile</em></a> syscall, and the <em>0x11003C</em> control code.</p> \n<p>The attribute’s value can then be read using the <em>0x110038</em> control code. The <em>AttributeValue</em> pointer and the <em>AttributeValueSize</em> will be used to read the attribute value and return it to the user.</p> \n<h3>Steps for Exploitation</h3> \n<p>Exploitation of the vulnerability involves the following steps:</p> \n<ol>\n <li>Spray large number of <em>Pipe Attributes</em> of size <em>0x7a00</em> to use up all fragmented chunks in <em>VS backend</em> and allocate new ones. The last few will each be allocated on separate segments of size <em>0x11000</em>, with the last <em>(0x11000-0x7a00)</em> bytes of each segment unused.</li>\n <li>Delete one of the later <em>Pipe Attributes</em>. This will consolidate the first <em>0x7a00</em> bytes with the remaining bytes in the rest of the segment, and put the entire segment back in the <em>VS backend</em>.</li>\n <li>Allocate the vulnerable chunk of size <em>0x7a00</em> by opening the malicious <em>Base Log File</em>. This will get allocated from the freed segment in <em>Step 2</em>. Similar to <em>Step 1</em>, the last <em>(0x11000-0x7a00)</em> bytes will be unused. The vulnerable chunk will be freed for the first time shortly afterwards. Similar to <em>Step 2</em>, the entire segment will be back in the <em>VS backend</em>.</li>\n <li>Spray large number of <em>WNF_STATE_DATA</em> objects of size <em>0x1000</em>. This will first use up fragmented chunks in <em>VS backend</em> and then the entire freed segment in <em>Step 3</em>. Note that no size lesser than <em>0x1000</em> (and maximum is <em>0x1000</em> for <em>WNF_STATE_DATA</em> objects) can be used because that will have an additional header that will corrupt the header in the vulnerable chunk, blocking a double free.</li>\n <li>Free the vulnerable chunk for the second time. This will end up freeing the memory of one of the <em>WNF_STATE_DATA</em> objects allocated in <em>Step 4</em>, without actually releasing the object.</li>\n <li>Allocate a <em>WNF_STATE_DATA</em> object of size <em>0x1000</em> over the freed chunk in <em>Step 5</em>. This will create <em>2</em> entirely overlapping <em>WNF_STATE_DATA</em> objects of size <em>0x1000</em>.</li>\n <li>Free all the <em>WNF_STATE_DATA</em> objects allocated in <em>Step 4</em>. This will once again put the entire vulnerable segment (of size <em>0x11000</em>) back in the <em>VS backend</em>.</li>\n <li>Spray large number of <em>WNF_STATE_DATA</em> objects of size <em>0x700</em>, each with unique data. This will first use up fragmented chunks in <em>VS backend</em> and then the entire freed segment in <em>Step </em>7. Each page in the freed segment is now split as (0x700,0x700,0x1d0 (remaining)). Note, here size <em>0x700</em> can be used because the rest of the exploit doesn’t require any more freeing of the vulnerable chunk. This now creates <em>2</em> overlapping <em>WNF_STATE_DATA</em> objects, one of size <em>0x1000</em> (allocated in <em>Step 6</em>) and other of size <em>0x700</em> (allocated here). Size <em>0x700</em> is specifically chosen for <em>2</em> reasons. The first reason being that the additional chunk header (of size <em>0x10</em>) in the <em>0x700</em>-sized object means that the <tt>StateData</tt> header of the <em>0x1000</em>-sized object is <em>0x10</em> bytes before the <tt>StateData</tt> header of the <em>0x700</em>-sized object. Thus, the <tt>StateData</tt> header of the <em>0x700</em>-sized object overlaps with the <tt>StateData</tt> data of the <em>0x1000</em>-sized object.</li>\n <li>Update the <tt>StateData</tt> of the <em>0x1000</em>-sized object to corrupt the <tt>StateData</tt> header of the <em>0x700</em>-sized object such that the <tt>AllocatedSize</tt> and <tt>DataSize</tt> fields of the <em>0x700</em>-sized object is increased from <em>0x6c0</em> (<em>0x700-0x40</em>) to <em>0x7000</em> each. Now, querying or updating the <em>0x700</em>-sized object will result in an out-of-bounds read/write into adjacent <em>0x700</em>-sized <em>WNF_STATE_DATA</em> objects allocated in <em>Step 8</em>.</li>\n <li>Identify the corrupted <em>0x700</em>-sized <em>WNF_STATE_DATA</em> object by querying all of them with a Buffer size of <em>0x700</em>. All will return successfully except for the corrupted one, which will return with an error indicating that the buffer size is too small. This is because the <tt>DataSize</tt> field was increased (refer to <em>Step 9</em>).</li>\n <li>Query the corrupted <em>0x700</em>-sized <em>WNF_STATE_DATA</em> object (identified in <em>Step 10</em>) to further identify the next <em>2</em> adjacent <em>WNF_STATE_DATA</em> objects using the OOB read. The first of these will be at offset <em>0x710</em> and the second will be at offset <em>0x1000</em> from the corrupted <em>0x700</em>-sized <em>WNF_STATE_DATA</em> object.</li>\n <li>Free the second newly identified <em>WNF_STATE_DATA</em> object of size <em>0x700</em>.</li>\n <li>Create a new process, which will run with the same privileges as the exploit process. The <em>token</em> of this new process is allocated over the freed <em>WNF_STATE_DATA</em> object in Step 12. This is the second reason for choosing size <em>0x700</em>, as the size of the <em>token</em> object is also <em>0x700</em>.</li>\n <li>Query the corrupted <em>0x700</em>-sized <em>WNF_STATE_DATA</em> object (identified in <em>Step 10</em>) to identify the contents of the <em>token</em> allocated in <em>Step 13</em> using the OOB read. Calculate the offset to the <tt>Privileges.Enabled</tt> and <tt>Privileges.Present</tt> fields in the <em>token</em>*object.</li>\n <li>Update the corrupted <em>0x700</em>-sized <em>WNF_STATE_DATA</em> object to corrupt the first adjacent object (identified in <em>Step 11</em>) using the OOB write. Increase the <tt>AllocatedSize</tt> and <tt>DataSize</tt> fields in the <tt>StateData</tt> pointer (refer to <em>Step 9</em>).</li>\n <li>Update the most recent corrupted <em>WNF_STATE_DATA</em> object (<em>Step 15</em>) to corrupt the adjacent token object using the OOB write. Overwrite the<tt> Privileges.Enabled</tt> and <tt>Privileges.Present</tt>fields in the token object to <tt>0xffffffffffffffff</tt>, thereby setting all the privileges. This completes the LPE.</li>\n</ol> \n<h2>Conclusion</h2> \n<p>We hope you enjoyed reading the deep dive into a use-after-free in CLFS, and if you did, go ahead and check out our other blog posts on <a href=\"https://blog.exodusintel.com/category/vulnerability-analysis/\" target=\"_blank\" rel=\"noreferrer noopener\">vulnerability analysis and exploitation</a>. If you haven’t already, make sure to follow us on <a href=\"https://twitter.com/XI_Research\" target=\"_blank\" rel=\"noreferrer noopener\">Twitter</a> to keep up to date with our work. Happy hacking!</p> \n<figure class=\"wp-block-image size-full\">\n <a href=\"https://blog.exodusintel.com/wp-content/uploads/2022/03/output.gif\"><img loading=\"lazy\" width=\"1020\" height=\"533\" src=\"https://blog.exodusintel.com/wp-content/uploads/2022/03/output.gif\" alt=\"\" class=\"wp-image-1941\" /></a>\n</figure> \n<p>The post <a rel=\"nofollow\" href=\"https://blog.exodusintel.com/2022/03/10/exploiting-a-use-after-free-in-windows-common-logging-file-system-clfs/\">Exploiting a use-after-free in Windows Common Logging File System (CLFS)</a> appeared first on <a rel=\"nofollow\" href=\"https://blog.exodusintel.com\">Exodus Intelligence</a>.</p>","descriptionType":"html","publishedDate":"Thu, 10 Mar 2022 17:47:04 +0000","feedId":7912,"bgimg":"https://blog.exodusintel.com/wp-content/uploads/2022/03/output.gif","linkMd5":"b08b41a1e312aa97f7564488fc191b39","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn93@2020_2/2022/03/14/09-25-07-580_c3deade31c09aa7d.webp","destWidth":1020,"destHeight":533,"sourceBytes":19255746,"destBytes":5308228,"author":"Exodus Intel VRT","articleImgCdnMap":{"https://blog.exodusintel.com/wp-content/uploads/2022/03/output.gif":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn93@2020_2/2022/03/14/09-25-07-580_c3deade31c09aa7d.webp"},"publishedOrCreatedDate":1647249880034}],"record":{"createdTime":"2022-03-14 17:24:40","updatedTime":"2022-03-14 17:24:40","feedId":7912,"fetchDate":"Mon, 14 Mar 2022 09:24:40 +0000","fetchMs":188,"handleMs":34,"totalMs":28633,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"f306b40366a93aa712f78b685bea0f01","hostName":"us-55*","requestId":"95628849197e489c972b0c05bb14be2b_7912","contentType":"application/rss+xml; charset=UTF-8","totalBytes":5308228,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":1,"articlesImgsGithubTotal":1,"successGithubMap":{"myreaderx27":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:34:00","updatedTime":"2020-09-05 15:44:09","id":7912,"name":"Exodus Intelligence","url":"https://blog.exodusintel.com/feed/","subscriber":null,"website":null,"icon":"https://blog.exodusintel.com/wp-content/uploads/2020/01/cropped-ExodusX-fav-32x32.png","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx64/cdn29@2020_1/2020/09/05/07-44-09-992_d4cf08015f8ea35b.png","description":"","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":5308228,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1647249879808,"total":0,"statList":[{"spend":192,"msg":"获取xml内容"},{"spend":34,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":0,"msg":"正文链接上传到cdn"}]},"extra5":1,"extra6":1,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{"https://blog.exodusintel.com/?p=1931_#section-exploitation":"https://blog.exodusintel.com/?p=1931#section-exploitation","https://blog.exodusintel.com/?p=1931_#section-preliminaries":"https://blog.exodusintel.com/?p=1931#section-preliminaries","https://blog.exodusintel.com/?p=1931_#section-code_analysis":"https://blog.exodusintel.com/?p=1931#section-code_analysis"},"extra111_proxyServerAndStatMap":{},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://blog.exodusintel.com/wp-content/uploads/2022/03/output.gif","sourceStatusCode":200,"destWidth":1020,"destHeight":533,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn93@2020_2/2022/03/14/09-25-07-580_c3deade31c09aa7d.webp","sourceBytes":19255746,"destBytes":5308228,"targetWebpQuality":4,"feedId":7912,"totalSpendMs":28387,"convertSpendMs":26970,"createdTime":"2022-03-14 17:24:40","host":"us-51*","referer":"https://blog.exodusintel.com/?p=1931","linkMd5ListStr":"b08b41a1e312aa97f7564488fc191b39,b08b41a1e312aa97f7564488fc191b39","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"compressRate":"27.6%","sourceSize":"18.4 MB","destSize":"5.1 MB"}],"successGithubMap":{"myreaderx27":1},"failGithubMap":{}}