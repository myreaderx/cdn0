{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-11-12 13:07:34","updatedTime":"2020-11-12 13:07:34","title":"编译原理实战入门：用 JavaScript 写一个简单的四则运算编译器（修订版）","link":"https://segmentfault.com/a/1190000037786459","description":"<p>编译器是一个程序，作用是<strong>将一门语言翻译成另一门语言</strong>。</p>\n<p>例如 babel 就是一个编译器，它将 es6 版本的 js 翻译成 es5 版本的 js。从这个角度来看，将英语翻译成中文的翻译软件也属于编译器。</p>\n<p>一般的程序，CPU 是无法直接执行的，因为 CPU 只能识别机器指令。所以要想执行一个程序，首先要将高级语言编写的程序翻译为汇编代码（Java 还多了一个步骤，将高级语言翻译成字节码），再将汇编代码翻译为机器指令，这样 CPU 才能识别并执行。</p>\n<p>由于汇编语言和机器语言一一对应，并且汇编语言更具有可读性。所以计算机原理的教材在讲解机器指令时一般会用汇编语言来代替机器语言讲解。</p>\n<p>本文所要写的四则运算编译器需要将 <code>1 + 1</code> 这样的四则运算表达式翻译成机器指令并执行。具体过程请看示例：</p>\n<pre><code class=\"js\">// CPU 无法识别\n10 + 5\n\n// 翻译成汇编语言\npush 10\npush 5\nadd\n\n// 最后翻译为机器指令，汇编代码和机器指令一一对应\n// 机器指令由 1 和 0 组成，以下指令非真实指令，只做演示用\n0011101001010101\n1101010011100101\n0010100111100001</code></pre>\n<p>四则运算编译器，虽然说功能很简单，只能编译四则运算表达式。但是编译原理的前端部分几乎都有涉及：词法分析、语法分析。另外还有编译原理后端部分的代码生成。不管是简单的、复杂的编译器，编译步骤是差不多的，只是复杂的编译器实现上会更困难。</p>\n<p>可能有人会问，<strong>学会编译原理有什么好处</strong>？</p>\n<p>我认为对编译过程内部原理的掌握将会使你成为更好的高级程序员。另外在这引用一下<a href=\"https://www.zhihu.com/question/21755487/answer/623091194\" rel=\"nofollow noreferrer\">知乎网友-随心所往</a>的回答，更加具体：</p>\n<ol>\n <li>可以更加容易的理解在一个语言种哪些写法是等价的，哪些是有差异的</li>\n <li>可以更加客观的比较不同语言的差异</li>\n <li>更不容易被某个特定语言的宣扬者忽悠</li>\n <li>学习新的语言是效率也会更高</li>\n <li>其实从语言a转换到语言b是一个通用的需求，学好编译原理处理此类需求时会更加游刃有余</li>\n</ol>\n<p>好了，下面让我们看一下如何写一个四则运算编译器。</p>\n<h2>词法分析</h2>\n<p>程序其实就是保存在文本文件中的一系列字符，词法分析的作用是将这一系列字符按照某种规则分解成一个个字元（token，也称为终结符），忽略空格和注释。</p>\n<p>示例：</p>\n<pre><code class=\"js\">// 程序代码\n10 + 5 + 6\n\n// 词法分析后得到的 token\n10\n+\n5\n+\n6</code></pre>\n<h3>终结符</h3>\n<p>终结符就是语言中用到的基本元素,它不能再被分解。</p>\n<p>四则运算中的终结符包括符号和整数常量（暂不支持一元操作符和浮点运算）。</p>\n<ol>\n <li><strong>符号</strong>：<code>+ - * / ( )</code></li>\n <li><strong>整数常量</strong>：12、1000、111...</li>\n</ol>\n<h3>词法分析代码实现</h3>\n<pre><code class=\"js\">function lexicalAnalysis(expression) {\n    const symbol = ['(', ')', '+', '-', '*', '/']\n    const re = /\\d/\n    const tokens = []\n    const chars = expression.trim().split('')\n    let token = ''\n    chars.forEach(c =&gt; {\n        if (re.test(c)) {\n            token += c\n        } else if (c == ' ' &amp;&amp; token) {\n            tokens.push(token)\n            token = ''\n        } else if (symbol.includes(c)) {\n            if (token) {\n                tokens.push(token)\n                token = ''\n            } \n\n            tokens.push(c)\n        }\n    })\n\n    if (token) {\n        tokens.push(token)\n    }\n\n    return tokens\n}\n\nconsole.log(lexicalAnalysis('100    +   23   +    34 * 10 / 2')) \n// [\"100\", \"+\", \"23\", \"+\", \"34\", \"*\", \"10\", \"/\", \"2\"]</code></pre>\n<h2>四则运算的语法规则（语法规则是分层的）</h2>\n<ol>\n <li><code>x*</code>， 表示 x 出现零次或多次</li>\n <li><code>x | y</code>， 表示 x 或 y 将出现</li>\n <li><code>( )</code> 圆括号，用于语言构词的分组</li>\n</ol>\n<p>以下规则从左往右看，表示左边的表达式还能继续往下细分成右边的表达式，一直细分到不可再分为止。</p>\n<ul>\n <li><strong>expression</strong>: addExpression</li>\n <li><strong>addExpression</strong>: mulExpression (op mulExpression)*</li>\n <li><strong>mulExpression</strong>: term (op term)*</li>\n <li><strong>term</strong>: '(' expression ')' | integerConstant</li>\n <li><strong>op</strong>: <code>+ - * /</code></li>\n</ul>\n<p><code>addExpression</code> 对应 <code>+</code> <code>-</code> 表达式，<code>mulExpression</code> 对应 <code>*</code> <code>/</code> 表达式。</p>\n<p>如果你看不太懂以上的规则，那就先放下，继续往下看。看看怎么用代码实现语法分析。</p>\n<h2>语法分析</h2>\n<p>对输入的文本按照语法规则进行分析并确定其语法结构的一种过程，称为语法分析。</p>\n<p>一般语法分析的输出为抽象语法树（AST）或语法分析树（parse tree）。但由于四则运算比较简单，所以这里采取的方案是即时地进行代码生成和错误报告，这样就不需要在内存中保存整个程序结构。</p>\n<p>先来看看怎么分析一个四则运算表达式 <code>1 + 2 * 3</code>。</p>\n<p>首先匹配的是 <code>expression</code>，由于目前 <code>expression</code> 往下分只有一种可能，即 <code>addExpression</code>，所以分解为 <code>addExpression</code>。<br>依次类推，接下来的顺序为 <code>mulExpression</code>、<code>term</code>、<code>1</code>（integerConstant）、<code>+</code>（op）、<code>mulExpression</code>、<code>term</code>、<code>2</code>（integerConstant）、<code>*</code>（op）、<code>mulExpression</code>、<code>term</code>、<code>3</code>（integerConstant）。</br></p>\n<p>如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000037786463\" alt=\"\" title=\"\" /></p>\n<p>这里可能会有人有疑问，为什么一个表达式搞得这么复杂，<code>expression</code> 下面有 <code>addExpression</code>，<code>addExpression</code> 下面还有 <code>mulExpression</code>。<br>其实这里是为了考虑运算符优先级而设的，<code>mulExpr</code> 比 <code>addExpr</code> 表达式运算级要高。</br></p>\n<pre><code>1 + 2 * 3\ncompileExpression\n   | compileAddExpr\n   |  | compileMultExpr\n   |  |  | compileTerm\n   |  |  |  |_ matches integerConstant        push 1\n   |  |  |_\n   |  | matches '+'\n   |  | compileMultExpr\n   |  |  | compileTerm\n   |  |  |  |_ matches integerConstant        push 2\n   |  |  | matches '*'\n   |  |  | compileTerm\n   |  |  |  |_ matches integerConstant        push 3\n   |  |  |_ compileOp('*')                      *\n   |  |_ compileOp('+')                         +\n   |_</code></pre>\n<p>有很多算法可用来构建语法分析树，这里只讲两种算法。</p>\n<h3>递归下降分析法</h3>\n<p>递归下降分析法，也称为自顶向下分析法。按照语法规则一步步递归地分析 token 流，如果遇到非终结符，则继续往下分析，直到终结符为止。</p>\n<h3>LL(0)分析法</h3>\n<p>递归下降分析法是简单高效的算法，LL(0)在此基础上多了一个步骤，当第一个 token 不足以确定元素类型时，对下一个字元采取“提前查看”，有可能会解决这种不确定性。</p>\n<p>以上是对这两种算法的简介，具体实现请看下方的代码实现。</p>\n<h3>表达式代码生成</h3>\n<p>我们通常用的四则运算表达式是中缀表达式，但是对于计算机来说中缀表达式不便于计算。所以在代码生成阶段，要将中缀表达式转换为后缀表达式。</p>\n<h4>后缀表达式</h4>\n<p>后缀表达式，又称逆波兰式，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。</p>\n<p>示例：</p>\n<p>中缀表达式： <code>5 + 5</code> 转换为后缀表达式：<code>5 5 +</code>，然后再根据后缀表达式生成代码。</p>\n<pre><code class=\"js\">// 5 + 5 转换为 5 5 + 再生成代码\npush 5\npush 5\nadd</code></pre>\n<h3>代码实现</h3>\n<p>编译原理的理论知识像天书，经常让人看得云里雾里，但真正动手做起来，你会发现，其实还挺简单的。</p>\n<p>如果上面的理论知识看不太懂，没关系，先看代码实现，然后再和理论知识结合起来看。</p>\n<p>注意：这里需要引入刚才的词法分析代码。</p>\n<pre><code class=\"js\">// 汇编代码生成器\nfunction AssemblyWriter() {\n    this.output = ''\n}\n\nAssemblyWriter.prototype = {\n    writePush(digit) {\n        this.output += `push ${digit}\\r\\n`\n    },\n\n    writeOP(op) {\n        this.output += op + '\\r\\n'\n    },\n\n    //输出汇编代码\n    outputStr() {\n        return this.output\n    }\n}\n\n// 语法分析器\nfunction Parser(tokens, writer) {\n    this.writer = writer\n    this.tokens = tokens\n    // tokens 数组索引\n    this.i = -1\n    this.opMap1 = {\n        '+': 'add',\n        '-': 'sub',\n    }\n\n    this.opMap2 = {\n        '/': 'div',\n        '*': 'mul'\n    }\n\n    this.init()\n}\n\nParser.prototype = {\n    init() {\n        this.compileExpression()\n    },\n\n    compileExpression() {\n        this.compileAddExpr()\n    },\n\n    compileAddExpr() {\n        this.compileMultExpr()\n        while (true) {\n            this.getNextToken()\n            if (this.opMap1[this.token]) {\n                let op = this.opMap1[this.token]\n                this.compileMultExpr()\n                this.writer.writeOP(op)\n            } else {\n                // 没有匹配上相应的操作符 这里为没有匹配上 + - \n                // 将 token 索引后退一位\n                this.i--\n                break\n            }\n        }\n    },\n\n    compileMultExpr() {\n        this.compileTerm()\n        while (true) {\n            this.getNextToken()\n            if (this.opMap2[this.token]) {\n                let op = this.opMap2[this.token]\n                this.compileTerm()\n                this.writer.writeOP(op)\n            } else {\n                // 没有匹配上相应的操作符 这里为没有匹配上 * / \n                // 将 token 索引后退一位\n                this.i--\n                break\n            }\n        }\n    },\n\n    compileTerm() {\n        this.getNextToken()\n        if (this.token == '(') {\n            this.compileExpression()\n            this.getNextToken()\n            if (this.token != ')') {\n                throw '缺少右括号：)'\n            }\n        } else if (/^\\d+$/.test(this.token)) {\n            this.writer.writePush(this.token)\n        } else {\n            throw '错误的 token：第 ' + (this.i + 1) + ' 个 token (' + this.token + ')'\n        }\n    },\n\n    getNextToken() {\n        this.token = this.tokens[++this.i]\n    },\n\n    getInstructions() {\n        return this.writer.outputStr()\n    }\n}\n\nconst tokens = lexicalAnalysis('100+10*10')\nconst writer = new AssemblyWriter()\nconst parser = new Parser(tokens, writer)\nconst instructions = parser.getInstructions()\nconsole.log(instructions) // 输出生成的汇编代码\n/*\npush 100\npush 10\npush 10\nmul\nadd\n*/</code></pre>\n<h2>模拟执行</h2>\n<p>现在来模拟一下 CPU 执行机器指令的情况，由于汇编代码和机器指令一一对应，所以我们可以创建一个直接执行汇编代码的模拟器。<br>在创建模拟器前，先来讲解一下相关指令的操作。</br></p>\n<h4>栈</h4>\n<p>在内存中，栈的特点是只能在同一端进行插入和删除的操作，即只有 push 和 pop 两种操作。</p>\n<h4>push</h4>\n<p>push 指令的作用是将一个操作数推入栈中。</p>\n<h4>pop</h4>\n<p>pop 指令的作用是将一个操作数弹出栈。</p>\n<h4>add</h4>\n<p>add 指令的作用是执行两次 pop 操作，弹出两个操作数 a 和 b，然后执行 a + b，再将结果 push 到栈中。</p>\n<h4>sub</h4>\n<p>sub 指令的作用是执行两次 pop 操作，弹出两个操作数 a 和 b，然后执行 a - b，再将结果 push 到栈中。</p>\n<h4>mul</h4>\n<p>mul 指令的作用是执行两次 pop 操作，弹出两个操作数 a 和 b，然后执行 a * b，再将结果 push 到栈中。</p>\n<h4>div</h4>\n<p>sub 指令的作用是执行两次 pop 操作，弹出两个操作数 a 和 b，然后执行 a / b，再将结果 push 到栈中。</p>\n<p>四则运算的所有指令已经讲解完毕了，是不是觉得很简单？</p>\n<h3>代码实现</h3>\n<p>注意：需要引入词法分析和语法分析的代码</p>\n<pre><code class=\"js\">function CpuEmulator(instructions) {\n    this.ins = instructions.split('\\r\\n')\n    this.memory = []\n    this.re = /^(push)\\s\\w+/\n    this.execute()\n}\n\nCpuEmulator.prototype = {\n    execute() {\n        this.ins.forEach(i =&gt; {\n            switch (i) {\n                case 'add':\n                    this.add()\n                    break\n                case 'sub':\n                    this.sub()\n                    break\n                case 'mul':\n                    this.mul()\n                    break\n                case 'div':\n                    this.div()\n                    break                \n                default:\n                    if (this.re.test(i)) {\n                        this.push(i.split(' ')[1])\n                    }\n            }\n        })\n    },\n\n    add() {\n        const b = this.pop()\n        const a = this.pop()\n        this.memory.push(a + b)\n    },\n\n    sub() {\n        const b = this.pop()\n        const a = this.pop()\n        this.memory.push(a - b)\n    },\n\n    mul() {\n        const b = this.pop()\n        const a = this.pop()\n        this.memory.push(a * b)\n    },\n\n    div() {\n        const b = this.pop()\n        const a = this.pop()\n        // 不支持浮点运算，所以在这要取整\n        this.memory.push(Math.floor(a / b))\n    },\n\n    push(x) {\n        this.memory.push(parseInt(x))\n    },\n\n    pop() {\n        return this.memory.pop()\n    },\n\n    getResult() {\n        return this.memory[0]\n    }\n}\n\nconst tokens = lexicalAnalysis('(100+  10)*  10-100/  10      +8*  (4+2)')\nconst writer = new AssemblyWriter()\nconst parser = new Parser(tokens, writer)\nconst instructions = parser.getInstructions()\nconst emulator = new CpuEmulator(instructions)\nconsole.log(emulator.getResult()) // 1138</code></pre>\n<p>一个简单的四则运算编译器已经实现了。我们再来写一个测试函数跑一跑，看看运行结果是否和我们期待的一样：</p>\n<pre><code class=\"js\">function assert(expression, result) {\n    const tokens = lexicalAnalysis(expression)\n    const writer = new AssemblyWriter()\n    const parser = new Parser(tokens, writer)\n    const instructions = parser.getInstructions()\n    const emulator = new CpuEmulator(instructions)\n    return emulator.getResult() == result\n}\n\nconsole.log(assert('1 + 2 + 3', 6)) // true\nconsole.log(assert('1 + 2 * 3', 7)) // true\nconsole.log(assert('10 / 2 * 3', 15)) // true\nconsole.log(assert('(10 + 10) / 2', 10)) // true</code></pre>\n<p>测试全部正确。另外附上<a href=\"https://github.com/woai3c/Front-end-articles/blob/master/code/four-operations/code.js\" rel=\"nofollow noreferrer\">完整的源码</a>，建议没看懂的同学再看多两遍。</p>\n<h2>更上一层楼</h2>\n<p>对于工业级编译器来说，这个四则运算编译器属于玩具中的玩具。但是人不可能一口吃成个胖子，所以学习编译原理最好采取循序渐进的方式去学习。下面来介绍一个高级一点的编译器，这个编译器可以编译一个 Jack 语言（类 Java 语言），它的语法大概是这样的：</p>\n<pre><code class=\"java\">class Generate {\n    field String str;\n    static String str1;\n    constructor Generate new(String s) {\n        let str = s;\n        return this;\n    }\n\n    method String getString() {\n        return str;\n    }\n}\n\nclass Main {\n    function void main() {\n        var Generate str;\n        let str = Generate.new(\"this is a test\");\n        do Output.printString(str.getString());\n        return;\n    }\n}</code></pre>\n<p>上面代码的输出结果为：<code>this is a test</code>。</p>\n<p>想不想实现这样的一个编译器？</p>\n<p>这个编译器出自一本书<a href=\"https://book.douban.com/subject/1998341/\" rel=\"nofollow noreferrer\">《计算机系统要素》</a>，它从第 6 章开始，一直到第 11 章讲解了汇编编译器（将汇编语言转换为机器语言）、VM 编译器（将类似于字节码的 VM 语言翻译成汇编语言）、Jack 语言编译器（将高级语言 Jack 翻译成 VM 语言）。每一章都有详细的知识点讲解和实验，只要你一步一步跟着做实验，就能最终实现这样的一个编译器。</p>\n<p>如果编译器写完了，最后机器语言在哪执行呢？</p>\n<p>这本书已经为你考虑好了，它从第 1 章到第 5 章，一共五章的内容。教你从逻辑门开始，逐步组建出算术逻辑单元 ALU、CPU、内存，最终搭建出一个现代计算机。然后让你用编译器编译出来的程序运行在这台计算机之上。</p>\n<p>另外，这本书的第 12 章会教你写操作系统的各种库函数，例如 Math 库（包含各种数学运算）、Keyboard 库（按下键盘是怎么输出到屏幕上的）、内存管理等等。</p>\n<p>想看一看全书共 12 章的实验做完之后是怎么样的吗？我这里提供几张这台模拟计算机运行程序的 DEMO GIF，供大家参考参考。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000037786462\" alt=\"\" title=\"\" /></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000037786464\" alt=\"\" title=\"\" /></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000037786465\" alt=\"\" title=\"\" /></p>\n<p>这几张图中的右上角是“计算机”的屏幕，其他部分是“计算机”的堆栈区和指令区。</p>\n<p>这本书的所有实验我都已经做完了（每天花 3 小时，两个月就能做完），答案放在我的 <a href=\"https://github.com/woai3c/nand2tetris\" rel=\"nofollow noreferrer\">github</a> 上，有兴趣的话可以看看。</p>\n<h2>参考资料</h2>\n<ul>\n <li><a href=\"https://book.douban.com/subject/1998341/\" rel=\"nofollow noreferrer\">《计算机系统要素》</a></li>\n</ul>","descriptionType":"html","publishedDate":"Tue, 10 Nov 2020 07:00:09 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000037786463","linkMd5":"0a7b3084a9ae71248e41f6648ce42587","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn61@2020_6/2020/11/12/05-07-43-972_6581060da8870493.webp","destWidth":252,"destHeight":397,"sourceBytes":8170,"destBytes":8170,"author":"谭光志","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000037786463":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn61@2020_6/2020/11/12/05-07-43-972_6581060da8870493.webp","https://segmentfault.com/img/remote/1460000037786462":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn65@2020_5/2020/11/12/05-07-49-165_f4ecad8f3a05c62a.webp","https://segmentfault.com/img/remote/1460000037786464":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn68@2020_5/2020/11/12/05-08-12-506_58a5a28598ee1a39.webp","https://segmentfault.com/img/remote/1460000037786465":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn69@2020_6/2020/11/12/05-07-48-882_cf3139d743d1e5a1.webp"},"publishedOrCreatedDate":1605157654039}],"record":{"createdTime":"2020-11-12 13:07:34","updatedTime":"2020-11-12 13:07:34","feedId":6615,"fetchDate":"Thu, 12 Nov 2020 05:07:34 +0000","fetchMs":7339,"handleMs":12369,"totalMs":60519,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"3793e6bfd414607e5a3772214aeb628d","hostName":"us-004*","requestId":"0c4a1155a26e4fe7a59b6c39689c6a2d_6615","contentType":"application/atom+xml; charset=UTF-8","totalBytes":7008562,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":4,"articlesImgsGithubTotal":4,"successGithubMap":{"myreaderx27":1,"myreaderx22":1,"myreaderx13":1,"myreaderx30":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:33:08","updatedTime":"2020-11-03 15:53:30","id":6615,"name":"SegmentFault 最新的文章","url":"http://segmentfault.com/feeds/blogs","subscriber":null,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"https://segmentfault.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":8170,"tmpBodyImgCdnBytes":7000392,"tmpBgImgCdnBytes":0,"extra4":{"start":1605157633459,"total":0,"statList":[{"spend":8211,"msg":"获取xml内容"},{"spend":12369,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":1,"msg":"修正封面图上传失败重新上传"},{"spend":29214,"msg":"正文链接上传到cdn"}]},"extra5":4,"extra6":4,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-038.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-037.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-036.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000037786463","sourceStatusCode":200,"destWidth":252,"destHeight":397,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn61@2020_6/2020/11/12/05-07-43-972_6581060da8870493.webp","sourceBytes":8170,"destBytes":8170,"feedId":6615,"totalSpendMs":3635,"convertSpendMs":0,"createdTime":"2020-11-12 13:07:41","host":"us-010*","referer":"https://segmentfault.com/a/1190000037786459","linkMd5ListStr":"0a7b3084a9ae71248e41f6648ce42587,0a7b3084a9ae71248e41f6648ce42587","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"8 KB","destSize":"8 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000037786465","sourceStatusCode":200,"destWidth":800,"destHeight":613,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn69@2020_6/2020/11/12/05-07-48-882_cf3139d743d1e5a1.webp","sourceBytes":1116360,"destBytes":1116360,"feedId":6615,"totalSpendMs":5637,"convertSpendMs":0,"createdTime":"2020-11-12 13:07:44","host":"us-038*","referer":"https://segmentfault.com/a/1190000037786459","linkMd5ListStr":"0a7b3084a9ae71248e41f6648ce42587","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"1.1 MB","destSize":"1.1 MB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000037786462","sourceStatusCode":200,"destWidth":800,"destHeight":613,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn65@2020_5/2020/11/12/05-07-49-165_f4ecad8f3a05c62a.webp","sourceBytes":3984364,"destBytes":3984364,"feedId":6615,"totalSpendMs":6028,"convertSpendMs":0,"createdTime":"2020-11-12 13:07:44","host":"us-036*","referer":"https://segmentfault.com/a/1190000037786459","linkMd5ListStr":"0a7b3084a9ae71248e41f6648ce42587","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"3.8 MB","destSize":"3.8 MB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000037786464","sourceStatusCode":200,"destWidth":1033,"destHeight":792,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn68@2020_5/2020/11/12/05-08-12-506_58a5a28598ee1a39.webp","sourceBytes":14367722,"destBytes":1899668,"targetWebpQuality":7,"feedId":6615,"totalSpendMs":29202,"convertSpendMs":20620,"createdTime":"2020-11-12 13:07:44","host":"us-037*","referer":"https://segmentfault.com/a/1190000037786459","linkMd5ListStr":"0a7b3084a9ae71248e41f6648ce42587","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"13.7 MB","destSize":"1.8 MB","compressRate":"13.2%"}],"successGithubMap":{"myreaderx27":1,"myreaderx22":1,"myreaderx13":1,"myreaderx30":1},"failGithubMap":{}}