{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-12-11 16:40:09","updatedTime":"2020-12-11 16:40:09","title":"Combinators and the Story of Computation","link":"https://writings.internal.stephenwolfram.com/?p=27614","description":"<span class=\"thumbnail\"><img width=\"128\" height=\"108\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/combinators-significance-1.1.png\" class=\"attachment-thumbnail wp-post-image\" alt=\"combinators-significance-1.1\" title=\"combinators-significance-1.1\" /></span>\n<style type=\"text/css\"> div.purplestripe { max-width:620px; background-color: #E6E6FA; padding-left:10px; margin-bottom:10px; } #blog .post_content .purplestripe a,#blog .post_content .purplestripe a:link,#blog .post_content .purplestripe a:visited { font-family:\"Fira Sans\",Arial,Sans Serif; font-size:11pt; color:#3d137d;} </style> \n<div class=\"purplestripe\" style=\"line-height: 1.4; font-size: 15px; padding: 5px 10px 5px 10px;\"> \n <em>Preliminary</em> \n</div> \n<h2 id=\"the-abstract-representation-of-things\">The Abstract Representation of Things</h2> \n<p>“In principle you could use combinators,” some footnote might say. But the implication tends to be “But you probably don’t want to.” And, yes, combinators are deeply abstract—and in many ways hard to understand. But tracing their history over the hundred years since they were invented, I’ve come to realize just how critical they’ve actually been to the development of our modern conception of computation—and indeed my own contributions to it.<span id=\"more-27614\"></span></p> \n<p>The idea of representing things in a formal, symbolic way has a long history. In antiquity there was <a href=\"https://writings.stephenwolfram.com/2018/11/logic-explainability-and-the-future-of-understanding/\">Aristotle’s logic</a> and <a href=\"https://writings.stephenwolfram.com/2020/09/the-empirical-metamathematics-of-euclid-and-beyond/\">Euclid’s geometry</a>. By the 1400s there was algebra, and in the <a href=\"https://writings.stephenwolfram.com/2015/11/george-boole-a-200-year-view/\">1840s Boolean algebra</a>. Each of these was a formal system that allowed one to make deductions purely within the system. But each, in a sense, ultimately viewed itself as being set up to model something specific. Logic was for modeling the structure of arguments, Euclid’s geometry the properties of space, algebra the properties of numbers; Boolean algebra aspired to model the “laws of thought”.</p> \n<p>But was there perhaps some more general and fundamental infrastructure: some kind of abstract system that could ultimately model or represent anything? Today we understand that’s what computation is. And it’s becoming clear that the modern conception of computation is one of the single most powerful ideas in all of intellectual history—whose implications are only just beginning to unfold.</p> \n<p>But how did we finally get to it? Combinators had an important role to play, woven into a complex tapestry of ideas stretching across more than a century.</p> \n<p>The main part of the story begins in the 1800s. Through the course of the 1700s and 1800s mathematics had developed a more and <a href=\"https://www.wolframscience.com/nks/notes-12-9--history-of-concept-of-mathematics/\">more elaborate formal structure</a> that seemed to be reaching ever further. But what really was mathematics? Was it a formal way of describing the world, or was it something else—perhaps something that could exist without any reference to the world?</p> \n<p>Developments like non-Euclidean geometry, group theory and transfinite numbers made it seem as if meaningful mathematics could indeed be done just by positing abstract axioms from scratch and then following a process of deduction. But could all of mathematics actually just be a story of deduction, perhaps even ultimately derivable from something seemingly lower level—like logic?</p> \n<p>But if so, what would things like numbers and arithmetic be? Somehow they would have to be “constructed out of pure logic”. Today we would recognize these efforts as “writing programs” for numbers and arithmetic in a “machine code” based on certain “instructions of logic”. But back then, everything about this and the ideas around it had to be invented.</p> \n<h2 id=\"what-is-mathematics-and-logic-made-of\">What Is Mathematics—and Logic—Made Of?</h2> \n<p>Before one could really dig into the idea of “building mathematics from logic” one had to have ways to “write mathematics” and “write logic”. At first, everything was just words and ordinary language. But by the end of the 1600s <a href=\"https://www.stephenwolfram.com/publications/mathematical-notation-past-future/\">mathematical notation</a> like +, =, &gt; had been established. For a while new concepts—like <a href=\"https://writings.stephenwolfram.com/2015/11/george-boole-a-200-year-view/\">Boolean algebra</a>—tended to just piggyback on existing notation. By the end of the 1800s, however, there was a clear need to extend and generalize how one wrote mathematics. </p> \n<p>In addition to algebraic variables like <em>x</em>, there was the notion of symbolic functions <em>f</em>, as in <em>f</em>(<em>x</em>). In logic, there had long been the idea of letters (<em>p</em>, <em>q</em>, …) standing for propositions (“it is raining now”). But now there needed to be notation for quantifiers (“for all <em>x</em> such-and-such”, or “there exists <em>x</em> such that…”). In addition, in analogy to symbolic functions in mathematics, there were symbolic logical predicates: not just explicit statements like <em>x</em>&nbsp;&gt;&nbsp;<em>y</em> but also ones like <span class=\"traditional-math\"><em>p</em>(<em>x</em>, <em>y</em>)</span> for symbolic <em>p</em>.</p> \n<p>The first full effort to set up the necessary notation and come up with an actual scheme for constructing arithmetic from logic was <a href=\"https://www.wolframalpha.com/input/?i=gottlob+frege\">Gottlob Frege</a>’s 1879 <em>Begriffsschrift</em> (“concept script”):</p> \n<p><a class=\"magnific image\" alt=\"Frege’s Begriffsschrift\" title=\"Frege’s Begriffsschrift\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/001-concept-script-a-left.png\"><img alt=\"Frege’s Begriffsschrift—click to enlarge\" title=\"Frege’s Begriffsschrift—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/001-concept-script-a-left.png\" width=\"253\" height=\"412\" /></a> <a class=\"magnific image\" alt=\"Frege’s Begriffsschrift\" title=\"Frege’s Begriffsschrift\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/001-concept-script-b-right.png\"><img alt=\"Frege’s Begriffsschrift—click to enlarge\" title=\"Frege’s Begriffsschrift—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/001-concept-script-b-right.png\" width=\"253\" height=\"412\" /></a></p> \n<p>And, yes, it was not so easy to read, or to typeset—and at first it didn’t make much of an impression. But the notation got more streamlined with <a href=\"https://www.wolframalpha.com/input/?i=giuseppe+peano\">Giuseppe Peano</a>’s <em>Formulario</em> project in the 1890s—which wasn’t so concerned with starting from logic as starting from some specified set of axioms (the “<a href=\"https://www.wolframscience.com/nks/notes-12-9--axioms-for-arithmetic/\">Peano axioms</a>”):</p> \n<p><a class=\"magnific image\" alt=\"Peano’s Formulario project\" title=\"Peano’s Formulario project\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/002-forumlario-mathematico-peano-120.png\"><img alt=\"GPeano’s Formulario project—click to enlarge\" title=\"Peano’s Formulario project—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/002-forumlario-mathematico-peano-120.png\" width=\"253\" /></a> <a class=\"magnific image\" alt=\"Peano’s Formulario project\" title=\"Peano’s Formulario project\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/002-forumlario-mathematico-peano-127.png\"><img alt=\"Peano’s Formulario project—click to enlarge\" title=\"Peano’s Formulario project—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/002-forumlario-mathematico-peano-127.png\" width=\"253\" /></a></p> \n<p>And then in 1910 <a href=\"https://www.wolframalpha.com/input/?i=alfred+whitehead\">Alfred Whitehead</a> and <a href=\"https://www.wolframalpha.com/input/?i=bertrand+russell\">Bertrand Russell</a> began publishing their 2000-page <em><a href=\"https://writings.stephenwolfram.com/2010/11/100-years-since-principia-mathematica/\">Principia Mathematica</a></em>—which pretty much by its sheer weight and ambition (and notwithstanding what I would today consider grotesque errors of language design)—popularized the possibility of building up “the complexity of mathematics” from “the simplicity of logic”:</p> \n<p><a class=\"magnific image\" alt=\"Whitehead and Russell’s Principia Mathematica\" title=\"Whitehead and Russell’s Principia Mathematica\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/002-principia-mathematica-whitehead-russell-spread.png\"><img alt=\"Whitehead and Russell’s Principia Mathematica—click to enlarge\" title=\"Whitehead and Russell’s Principia Mathematica—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/002-principia-mathematica-whitehead-russell-spread.png\" width=\"507\" height=\"408\" /></a></p> \n<p>It was one thing to try to represent the content of mathematics, but there was also the question of representing the infrastructure and processes of mathematics. Let’s say one picks some axioms. How can one know if they’re consistent? What’s involved in proving everything one can prove from them?</p> \n<p>In the 1890s <a href=\"https://writings.stephenwolfram.com/2020/12/where-did-combinators-come-from-hunting-the-story-of-moses-schonfinkel/#gottingen-center-of-the-mathematical-universe\">David Hilbert</a> began to develop ideas about this, particularly in the context of tightening up the formalism of Euclid’s geometry and its axioms. And after <em>Principia Mathematica</em>, Hilbert turned more seriously to the use of logic-based ideas to develop “metamathematics”—notably leading to the formulation of things like the “decision problem” (<em>Entscheidungsproblem</em>) of asking whether, given an axiom system, there’s a definite procedure to prove or disprove any statement with respect to it.</p> \n<p>But while connections between logic and mathematics were of great interest to people concerned with the philosophy of mathematics, a more obviously mathematical development was <a href=\"https://www.wolframscience.com/nks/notes-12-9--history-of-models-of-mathematics/\">universal algebra</a>—in which axioms for different areas of mathematics were specified just by giving appropriate algebraic-like relations. (As it happens, universal algebra was launched under that name by the 1898 book <a href=\"https://projecteuclid.org/euclid.chmm/1263316509\" target=\"_blank\"><em>A Treatise on Universal Algebra</em></a> by Alfred Whitehead, later of <em>Principia Mathematica</em> fame.)</p> \n<p>But there was one area where ideas about algebra and logic intersected: the tightening up of Boolean algebra, and in particular the finding of simpler foundations for it. Logic had pretty much always been formulated in terms of <span style=\"font-variant: small-caps\"><tt><a href=\"https://reference.wolfram.com/language/ref/And.html\">And</a></tt></span>, <span style=\"font-variant: small-caps\"><tt><a href=\"https://reference.wolfram.com/language/ref/Or.html\">Or</a></tt></span> and <span style=\"font-variant: small-caps\"><tt><a href=\"https://reference.wolfram.com/language/ref/Not.html\">Not</a></tt></span>. But in 1912 <a href=\"https://en.wikipedia.org/wiki/Henry_M._Sheffer\" target=\"_blank\">Henry Sheffer</a>—attempting to simplify <em>Principia Mathematica</em>—showed that just <span style=\"font-variant: small-caps\"><tt><a href=\"https://reference.wolfram.com/language/ref/Nand.html\">Nand</a></tt></span> (or <span style=\"font-variant: small-caps\"><tt><a href=\"https://reference.wolfram.com/language/ref/Nor.html\">Nor</a></tt></span>) <a href=\"https://www.wolframscience.com/nks/notes-12-9--universal-logical-functions/\">were sufficient</a>. (It turned out that <a href=\"https://www.wolframalpha.com/input/?i=charles+peirce\">Charles Peirce</a> had already noted the same thing in the 1880s.)</p> \n<p>So that established that the notation of logic could be made basically as simple as one could imagine. But what about its actual structure, and axioms? Sheffer talked about needing five “algebra-style” axioms. But by going to axioms based on logical inferences <a href=\"https://www.wolframscience.com/nks/notes-12-9--basic-logic-and-axioms/\">Jean Nicod managed in 1917 to get it down to just one axiom</a>. (And, as it happens, I finally <a href=\"https://writings.stephenwolfram.com/2018/11/logic-explainability-and-the-future-of-understanding/\">finished the job in 2000</a> by finding the very simplest “algebra-style” axioms for logic—the <a href=\"https://www.wolframscience.com/nks/p808--implications-for-mathematics-and-its-foundations/\">single axiom: <span class=\"traditional-math\">((<em>p</em>·<em>q</em>)·<em>r</em>)·(<em>p</em>·((<em>p</em>·<em>r</em>)·<em>p</em>))<span class=\"special-character LongEqual\"></span><em>r</em></span></a>.)</p> \n<p>The big question had in a sense been “What is mathematics ultimately made of?”. Well, now it was known that ordinary propositional logic could be built up from very simple elements. So what about the other things used in mathematics—like functions and predicates? Was there a simple way of building these up too?</p> \n<p>People like Frege, Whitehead and Russell had all been concerned with constructing specific things—like sets or numbers—that would have immediate mathematical meaning. But Hilbert’s work in the late 1910s began to highlight the idea of looking instead at metamathematics and the “mechanism of mathematics”—and in effect at how the pure symbolic infrastructure of mathematics fits together (through proofs, etc.), independent of any immediate “external” mathematical meaning. </p> \n<p>Much as <a href=\"https://www.wolframscience.com/nks/notes-10-12--history-of-ideas-about-thinking/\">Aristotle and subsequent logicians</a> had used (propositional) logic to define a “symbolic structure” for arguments, independent of their subject matter, so too did Hilbert’s program imagine a general “symbolic structure” for mathematics, independent of particular mathematical subject matter.</p> \n<p>And this is what finally set the stage for the invention of combinators.</p> \n<h2 id=\"combinators-arrive\">Combinators Arrive</h2> \n<p>We don’t know how long it took <a href=\"https://www.wolframalpha.com/input/?i=moses+sch%C3%B6nfinkel\">Moses Schönfinkel</a> to come up with combinators. From what we <a href=\"https://writings.stephenwolfram.com/2020/12/where-did-combinators-come-from-hunting-the-story-of-moses-schonfinkel/\">know of his personal history</a>, it could have been as long as a decade. But it could also have been as short as a few weeks. </p> \n<p>There’s no advanced math or advanced logic involved in defining combinators. But to drill through the layers of technical detail of mathematical logic to realize that it’s even conceivable that everything can be defined in terms of them is a supreme achievement of a kind of abstract reductionism.</p> \n<p>There is <a href=\"https://writings.stephenwolfram.com/2020/12/where-did-combinators-come-from-hunting-the-story-of-moses-schonfinkel/\">much we don’t know</a> about Schönfinkel as a person. But the 11-page paper he wrote on the basis of his December 7, 1920, talk in which he introduced combinators is extremely clear. </p> \n<p>The paper is entitled “On the Building Blocks of Mathematical Logic” (in the original German, “Über die Bausteine der mathematischen Logik”.) In other words, its goal is to talk about “atoms” from which mathematical logic can be built. Schönfinkel explains that it’s “in the spirit of” Hilbert’s axiomatic method to build everything from as few notions as possible; then he says that what he wants to do is to “seek out those notions from which we shall best be able to construct all other notions of the branch of science in question”.</p> \n<p>His first step is to explain that Hilbert, Whitehead, Russell and Frege all set up mathematical logic in terms of standard <span style=\"font-variant: small-caps\">And</span>, <span style=\"font-variant: small-caps\">Or</span>, <span style=\"font-variant: small-caps\">Not</span>, etc. connectives—but that Sheffer had recently been able to show that just a single connective (indicated by a stroke “|”—and what we would now call <span style=\"font-variant: small-caps\">Nand</span>) was sufficient:</p> \n<p><a class=\"magnific image\" alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/002-single-connective-nand-stroke.png\"><img alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/002-single-connective-nand-stroke.png\" width=\"426\" height=\"169\" /></a></p> \n<p>But in addition to the “content” of these relations, I think Schönfinkel was trying to communicate by example something else: that all these logical connectives can ultimately be thought of just as examples of “abstract symbolic structures” with a certain “function of arguments” (i.e. <em>f</em>[<em>x</em>,<em>y</em>]) form.</p> \n<p>The next couple of paragraphs talk about how the quantifiers “for all” (∀) and “there exists” (∃) can also be simplified in terms of the Sheffer stroke (i.e. <span style=\"font-variant: small-caps\">Nand</span>). But then comes the rallying cry: “The successes that we have encountered thus far… encourage us to attempt further progress.” And then he’s ready for the big idea—which he explains “at first glance certainly appears extremely bold”. He proposes to “eliminate by suitable reduction the remaining fundamental concepts of proposition, function and variable”.</p> \n<p>He explains that this only makes sense for “arbitrary, logically general propositions”, or, as we’d say now, for purely symbolic constructs without specific meanings yet assigned. In other words, his goal is to create a general framework for operating on arbitrary symbolic expressions independent of their interpretation.</p> \n<p>He explains that this is valuable both from a “methodological point of view” in achieving “the greatest possible conceptual uniformity”, but also from a certain philosophical or perhaps aesthetic point of view.</p> \n<p>And in a sense what he was explaining—back in 1920—was something that’s been a core part of the <a href=\"https://writings.stephenwolfram.com/2019/05/what-weve-built-is-a-computational-language-and-thats-very-important/\">computational language design</a> that I’ve done for the past 40 years: that everything can be represented as a symbolic expression, and that there’s <a href=\"https://reference.wolfram.com/language/\">tremendous value</a> to this kind of uniformity.</p> \n<p>But as a “language designer” Schönfinkel was an ultimate minimalist. He wanted to get rid of as many notions as possible—and in particular he didn’t want variables, which he explained were “nothing but tokens that characterize certain argument places and operators as belonging together”; “mere auxiliary notions”.</p> \n<p>Today we have all sorts of mathematical notation that’s at least somewhat “variable free” (think coordinate-free notation, category theory, etc.) But in 1920 mathematics as it was written was full of variables. And it needed a serious idea to see how to get rid of them. And that’s where Schönfinkel starts to go “even more symbolic”.</p> \n<p>He explains that he’s going to make a kind of “functional calculus” (<em>Funktionalkalkül</em>). He says that normally functions just define a certain correspondence between the domain of their arguments, and the domain of their values. But he says he’s going to generalize that—and allow (“disembodied”) functions to appear as arguments and values of functions. In other words, he’s inventing what we’d now call higher-order functions, where functions can operate “symbolically” on other functions.</p> \n<p>In the context of traditional calculus-and-algebra-style mathematics it’s a bizarre idea. But really it’s an idea about computation and computational structures—that’s more abstract and ultimately much more general than the mathematical objectives that inspired it. </p> \n<p>But back to Schönfinkel’s paper. His next step is to explain that once functions can have other functions as arguments, functions only ever need to take a single argument. In modern (<a href=\"https://www.wolfram.com/language/\">Wolfram Language</a>) notation he says that you never need <tt>f[x,y]</tt>; you can always do everything with <tt>f[x][y]</tt>. </p> \n<p>In something of a sleight of hand, he sets up his notation so that <em>fxyz</em> (which might look like a function of three arguments <tt>f[x,y,z]</tt>) actually means (((<em>fx</em>)<em>y</em>)<em>z</em>) (i.e. <tt>f[x][y][z]</tt>). (In other words—somewhat confusingly with respect to modern standard functional notation—he takes <a href=\"https://reference.wolfram.com/language/ref/Application.html\">function application to be left associative</a>.)</p> \n<p>Again, it’s a bizarre idea—though actually Frege had had a similar idea many years earlier (and now the idea is usually called currying, after <a href=\"https://www.wolframalpha.com/input/?i=haskell+curry\">Haskell Curry</a>, who we’ll be talking about later). But with his “functional calculus” set up, and all functions needing to take only one argument, Schönfinkel is ready for his big result.</p> \n<p>He’s effectively going to argue that by combining a small set of particular functions he can construct any possible symbolic function—or at least anything needed for predicate logic. He calls them a “sequence of particular functions of a very general nature”. Initially there are five of them: the identity function (<em>Identitätsfunktion</em>) <em>I</em>, the constancy function (<em>Konstanzfunktion</em>) <em>C</em> (which we now call <em>K</em>), the interchange function (<em>Vertauschungsfunktion</em>) <em>T</em>, the composition function (<em>Zusammensetzungsfunktion</em>) <em>Z</em>, and the fusion function (<em>Verschmelzungsfunktion</em>) <em>S</em>.</p> \n<p><a class=\"magnific image\" alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/003-very-generally-natured-sequence-of-particular-functions.png\"><img alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/003-very-generally-natured-sequence-of-particular-functions.png\" width=\"426\" height=\"475\" /></a></p> \n<p>And then he’s off and running defining what we <a href=\"https://writings.stephenwolfram.com/2020/12/combinators-a-centennial-view/\">now call combinators</a>. The definitions look simple and direct. But to get to them Schönfinkel effectively had to cut away all sorts of conceptual baggage that had come with the historical development of logic and mathematics.</p> \n<p>Even talking about the identity combinator isn’t completely straightforward. Schönfinkel carefully explains that in <em>I x = x</em>, equality is direct symbolic or structural equality, or as he puts it “the equal sign is not to be taken to represent logical equivalence as it is ordi­narily defined in the propositional calculus of logic but signifies that the expressions on the left and on the right mean the same thing, that is, that the function value <em>lx</em> is always the same as the argument value <em>x</em>, whatever we may substitute for <em>x</em>.” He then adds parenthetically, “Thus, for instance, <em>I I</em> would be equal to <em>I</em>”. And, yes, to someone used to the mathematical idea that a function takes values like numbers, and gives back numbers, this is a bit mind-blowing.</p> \n<p>Next he explains the constancy combinator, that he called <em>C</em> (even though the German word for it starts with <em>K</em>), and that we now call <em>K</em>. He says “let us assume that the argument value is again arbitrary without restric­tion, while, regardless of what this value is, the function value will always be the fixed value <em>a</em>”. And when he says “arbitrary” he really means it: it’s not just a number or something; it’s what we would now think of as any symbolic expression. </p> \n<p>First he writes (<em>C a</em>)<em>y</em> = <em>a</em>, i.e. the value of the “constancy function <em>C a</em> operating on any <em>y</em> is <em>a</em>”, then he says to “let <em>a</em> be variable too”, and defines (<em>C x</em>)<em>y </em>= <em>x</em> or <em>Cxy</em> = <em>x</em>. Helpfully, almost as if he were writing computer documentation, he adds: “In practical applications <em>C</em> serves to permit the introduction of a quantity <em>x</em> as a ‘blind’ variable.”</p> \n<p>Then he’s on to <em>T</em>. In modern notation the definition is <em>T</em>[<em>f</em>][<em>x</em>][<em>y</em>]&nbsp;=&nbsp;<em>f</em>[<em>y</em>][<em>x</em>] (i.e. <em>T</em> is essentially <tt><a href=\"https://reference.wolfram.com/language/ref/ReverseApplied.html\">ReverseApplied</a></tt>). (He wrote the definition as (<em>T</em><span class=\"special-character Phi\">ϕ</span>)<em>xy</em>&nbsp;=&nbsp;<span class=\"special-character Phi\">ϕ</span><em>yx</em>, explaining that the parentheses can be omitted.) He justifies the idea of <em>T</em> by saying that “The function <em>T</em> makes it possible to alter the order of the terms of an expression, and in this way it compensates to a certain extent for the lack of a commutative law.” </p> \n<p>Next comes the composition combinator <em>Z</em>. He explains that “In [mathematical] analysis, as is well known, we speak loosely of a ‘function of a function’...”, by which he meant that it was pretty common then (and now) to write something like <em>f</em>(<em>g</em>(<em>x</em>)). But then he “went symbolic”—and defined a composition function that could symbolically act on any two functions <em>f</em> and <em>g</em>: <em>Z</em>[<em>f</em>][<em>g</em>][<em>x</em>]&nbsp;=&nbsp;<em>f</em>[<em>g</em>[<em>x</em>]]. He explains that <em>Z</em> allows one to “shift parentheses” in an expression: i.e. whatever the objects in an expression might be, <em>Z</em> allows one to transform [][][] to [[]] etc. But in case this might have seemed too abstract and symbolic, he then attempted to explain in a more “algebraic” way that the effect of <em>Z</em> is “somewhat like that of the associative law” (though, he added, the actual associative law is not satisfied). </p> \n<p>Finally comes the <em>pièce de résistance</em>: the <em>S</em> combinator (that Schönfinkel calls the “fusion function”):</p> \n<p><a class=\"magnific image\" alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/004-the-s-combinator-fusion-function.png\"><img alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/004-the-s-combinator-fusion-function.png\" width=\"426\" height=\"456\" /></a></p> \n<p>He doesn’t take too long to define it. He basically says: consider (<em>fx</em>)(<em>gx</em>) (i.e. <em>f</em>[<em>x</em>][<em>g</em>[<em>x</em>]]). This is really just “a function of <em>x</em>”. But what function? It’s not a composition of <em>f</em> and <em>g</em>; he calls it a “fusion”, and he defines the <em>S</em> combinator to create it: <em>S</em>[<em>f</em>][<em>g</em>][<em>x</em>]&nbsp;=&nbsp;<em>f</em>[<em>x</em>][<em>g</em>[<em>x</em>]]. </p> \n<p>It’s pretty clear Schönfinkel knew this kind of “symbolic gymnastics” would be hard for people to understand. He continues: “It will be advisable to make this function more intelligible by means of a practical example.” He says to take <em>fxy</em> (i.e. <em>f</em>[<em>x</em>][<em>y</em>]) to be log<sub><em>x</em></sub><em>y</em> (i.e. <tt><a href=\"https://reference.wolfram.com/language/ref/Log.html\">Log</a>[x,y]</tt>), and <em>gz</em> (i.e. <tt>g[z]</tt>) to be 1&nbsp;+&nbsp;<em>z</em>. Then <em>Sfgx</em>&nbsp;=&nbsp;(<em>fx</em>)(<em>gx</em>)&nbsp;=&nbsp;log<sub><em>x</em></sub>(1&nbsp;+&nbsp;<em>x</em>) (i.e. <tt>S[f][g][x]=f[x][g[x]]=<a href=\"https://reference.wolfram.com/language/ref/Log.html\">Log</a>[x,1+x]</tt>). And, OK, it’s not obvious why one would want to do that, and I’m not rushing to make <em>S</em> a <a href=\"https://reference.wolfram.com/language/guide/FunctionalProgramming.html\">built-in function in the Wolfram Language</a>.</p> \n<p>But Schönfinkel explains that for him “the practical use of the function <em>S</em> will be to enable us to reduce the number of occurrences of a variable—and to some extent also of a particular function—from several to a single one”.</p> \n<p>Setting up everything in terms of five basic objects <em>I</em>, <em>C</em> (now <em>K</em>), <em>T</em>, <em>Z</em> and <em>S</em> might already seem impressive and minimalist enough. But Schönfinkel realized that he could go even further: </p> \n<p><a class=\"magnific image\" alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/005-five-basic-objects-further-part-a.png\"><img alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/005-five-basic-objects-further-part-a.png\" width=\"426\" height=\"531\" /></a><br /> <a class=\"magnific image\" alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/005-five-basic-objects-further-part-b.png\"><img alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/005-five-basic-objects-further-part-b.png\" width=\"426\" height=\"531\" /></a></p> \n<p>First, he says that actually <em>I</em>&nbsp;=&nbsp;<em>SCC</em> (or, in modern notation, <tt>s[k][k]</tt>). In other words, <tt>s[k][k][x]</tt> for symbolic <em>x</em> is just equal to <em>x</em> (since <tt>s[k][k][x]</tt> becomes <tt>k[x][k[x]]</tt> by using the definition of <em>S</em>, and this becomes <em>x</em> by using the definition of <em>C</em>). He notes that this particular reduction was communicated to him by a certain <a href=\"https://writings.stephenwolfram.com/2020/12/where-did-combinators-come-from-hunting-the-story-of-moses-schonfinkel/#alfred-boskovitz\">Alfred Boskowitz</a> (who we know to have been a student at the time); he says that <a href=\"https://www.wolframalpha.com/input/?i=paul+bernays\">Paul Bernays</a> (who was more of a colleague) had “some time before” noted that <em>I</em>&nbsp;=&nbsp;(<em>SC</em>)(<em>CC</em>) (i.e. <span class=\"clipboard-inline\"><tt>s[k][k[k]]</tt></span>). Today, of course, we can use a computer to just enumerate all possible combinator expressions of a particular size, and find what the smallest reduction is. But in Schönfinkel’s day, it would have been more like solving a puzzle by hand.</p> \n<p>Schönfinkel goes on, and proves that <em>Z</em> can also be reduced: <em>Z</em>&nbsp;=&nbsp;<em>S</em>(<em>CS</em>)<em>C</em> (i.e. <span class=\"clipboard-inline\"><tt>s[k[s]][k]</tt></span>). And, yes, a very simple Wolfram Language program can verify in a few milliseconds that that is the simplest form.</p> \n<p>OK, what about <em>T</em>? Schönfinkel gives 8 steps of reduction to prove that <em>T</em>&nbsp;=&nbsp;<em>S</em>(<em>ZZS</em>)(<em>CC</em>) (i.e. <span class=\"clipboard-inline\"><tt>s[s[k[s]][k][s[k[s]][k]][s]][k[k]]</tt></span>). But is this the simplest possible form for <em>T</em>? Well, no. But (with the very straightforward 2-line Wolfram Language program I wrote) it did take my modern computer a number of minutes to determine what the simplest form is.</p> \n<p>The answer is that it doesn't have size 12, like Schönfinkel’s, but rather size 9. Actually, there are 6 cases of size 9 that all work: <span class=\"clipboard-inline\"><tt>s[s[k[s]][s[k[k]][s]]][k[k]]</tt></span> (<em>S</em>(<em>S</em>(<em>KS</em>)(<em>S</em>(<em>KK</em>)<em>S</em>))(<em>KK</em>))) and five others. And, yes, it takes a few steps of reduction to prove that they work (the other size-9 cases <span class=\"clipboard-inline\" data-copy=\"{s[s[s][k][k[s[s][k[k]]]]][s],s[s[k[s]][s[k[k]][s]]][k[k]],s[s[k[s[k[s]][k]]][s]][k[k]],s[k[s[s[k[s]][k]][k[k]]]][s],s[k[s[s][k[k]]]][s[k[k]][s]],s[k[s[k[s[s][k[k]]]][k]]][s]}\"><em>S</em>(<em>SSK</em>(<em>K</em>(<em>SS</em>(<em>KK</em>))))<em>S</em>, <em>S</em>(<em>S</em>(<em>K</em>(<em>S</em>(<em>KS</em>)<em>K</em>))<em>S</em>)(<em>KK</em>), <em>S</em>(<em>K</em>(<em>S</em>(<em>S</em>(<em>KS</em>)<em>K</em>)(<em>KK</em>)))<em>S</em>, <em>S</em>(<em>K</em>(<em>SS</em>(<em>KK</em>)))(<em>S</em>(<em>KK</em>)<em>S</em>), <em>S</em>(<em>K</em>(<em>S</em>(<em>K</em>(<em>SS</em>(<em>KK</em>)))<em>K</em>))<em>S</em></span> all have more complicated reductions):</p> \n<table class=\"InCell\"> \n <tbody> \n  <tr> \n   <td colspan=\"1\" rowspan=\"1\" class=\"Input\"> \n    <div> \n     <img class=\"\" src=\"https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img3.png\" alt=\"CombinatorEvolutionPlot\" width=\"316\" height=\"214\" /> \n    </div> \n    <div class=\"IFL\"> \n     <span class=\"close\" id=\"3_out\">&amp;#10005</span> \n     <pre class=\"text\" id=\"3_out_text\">CloudGet[\"https://www.wolframcloud.com/obj/sw-blog/Combinators/\\\nPrograms.wl\"]; CombinatorEvolutionPlot[\n CombinatorFixedPointList[\n  s[s[k[s]][s[k[k]][s]]][k[k]][f][g][x]], \"StatesDisplay\"]</pre> \n    </div> </td> \n  </tr> \n </tbody> \n</table> \n<p>But, OK, what did Schönfinkel want to do with these objects he’d constructed? As the title of his paper suggests, he wanted to use them as building blocks for mathematical logic. He begins: “Let us now apply our results to a special case, that of the calculus of logic in which the basic elements are individuals and the functions are propositional functions.” I consider this sentence significant. Schönfinkel didn’t have a way to express it (the <a href=\"https://www.wolframscience.com/nks/notes-11-3--history-of-universality/\">concept of universal computation</a> hadn’t been invented yet), but he seems to have realized that what he’d done was quite general, and went even beyond being able to represent a particular kind of logic.</p> \n<p>Still, he went on to give his example. He’d explained at the beginning of the paper that the quantifiers we now call ∀ and ∃ could both be represented in terms of a kind of “quantified <span style=\"font-variant: small-caps\">Nand</span>” that he wrote <span class=\"InlineFormula\"><img src=\"https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img4.png\" width=\"11\" height=\"23\" align=\"absmiddle\" class=\"inline-img\" /></span>:</p> \n<p><a class=\"magnific image\" alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/006-kind-of-quantified-nand.png\"><img alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/006-kind-of-quantified-nand.png\" width=\"426\" height=\"337\" /></a></p> \n<p>But now he wanted to “combinator-ify” everything. So he introduced a new combinator <em>U</em>, and defined it to represent his “quantified <span style=\"font-variant: small-caps\">Nand</span>”: <em>Ufg</em>&nbsp;=&nbsp;<em>fx</em> <span class=\"InlineFormula\"><img src=\"https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img5.png\" width=\"11\" height=\"23\" align=\"absmiddle\" class=\"inline-img\" /></span> <em>gx</em> (he called <em>U</em> the “incompatibility function”—an interesting <a href=\"https://www.wolframscience.com/nks/notes-12-9--logic-in-languages/\">linguistic description</a> of <span style=\"font-variant: small-caps\">Nand</span>): </p> \n<p><a class=\"magnific image\" alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/007-incompatibility-function-a.png\"><img alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/007-incompatibility-function-a.png\" width=\"310\" /></a> <a class=\"magnific image\" alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/007-incompatibility-function-b.png\"><img alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/007-incompatibility-function-b.png\" width=\"310\" /></a></p> \n<p>“It is a remarkable fact”, he says, “that every formula of logic can now be expressed by means... solely of <em>C</em>, <em>S</em> and <em>U</em>.” So he’s saying that any expression from mathematical logic can be written out as some combinator expression in terms of <em>S</em>, <em>C</em> (now <em>K</em>) and <em>U</em>. He says that when there are quantifiers like “for all <em>x</em>...” it’s always possible to use combinators to get rid of the “bound variables” <em>x</em>, etc. He says that he “will not give the complete demonstration here”, but rather content himself with an example. (Unfortunately—for reasons of the trajectory of his life that are still quite unclear—he never published his “complete demonstration”.)</p> \n<p>But, OK, so what had he achieved? He’d basically shown that any expression that might appear in predicate logic (with logical connectives, quantifiers, variables, etc.) could be reduced to an expression purely in terms of the combinators <em>S</em>, <em>C</em> (now <em>K</em>) and <em>U</em>.</p> \n<p>Did he need the <em>U</em>? Not really. But he had to have some way to represent the thing with mathematical or logical “meaning” on which his combinators would be acting. Today the obvious thing to do would be to have a representation for true and false. And what’s more, to <a href=\"https://writings.stephenwolfram.com/2020/12/combinators-a-centennial-view/#historical-and-other-notes\">represent these purely in terms of combinators</a>. For example, if we took <em>K</em> to represent true, and <em>SK</em> (<span class=\"clipboard-inline\"><tt>s[k]</tt></span>) to represent false, then <span style=\"font-variant: small-caps\">Or</span> can be represented as <em>SSK</em> (<span class=\"clipboard-inline\"><tt>s[s][k]</tt></span>), <span style=\"font-variant: small-caps\">And</span> as <span class=\"traditional-math\"><em>S</em>(<em>SS</em>)<em>S</em>(<em>SK</em>)</span> <span class=\"traditional-math\">(<span class=\"clipboard-inline\"><tt>s[s[s]][s][s[k]]</tt></span>)</span> and <span style=\"font-variant: small-caps\">Nand</span> as <span class=\"traditional-math\"><em>S</em>(<em>S</em>(<em>S</em>(<em>SS</em>(<em>K</em>(<em>K</em>(<em>KK</em>)))))(<em>KS</em>))</span> <span class=\"traditional-math\">(<span class=\"clipboard-inline\"><tt>s[s[s[s[s][k[k[k[k]]]]]][k[s]]</tt></span>)</span>. Schönfinkel got amazingly far in reducing everything to his “building blocks”. But, yes, he missed this final step.</p> \n<p>But given that he’d managed to reduce everything to <em>S</em>, <em>C</em> and <em>U</em> he figured he should try to go further. So he considered <a href=\"https://www.wolframscience.com/nks/notes-11-12--single-universal-combinators/\">an object <em>J</em></a> that would be a single building block of <em>S</em> and <em>C</em>: <em>JJ</em>&nbsp;=&nbsp;<em>S</em> and <em>J</em>(<em>JJ</em>)&nbsp;=&nbsp;<em>C</em>.</p> \n<p><a class=\"magnific image\" alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/008-reduced-everything-to-scu.png\"><img alt=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" title=\"Schönfinkel’s “Über die Bausteine der mathematischen Logik”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/008-reduced-everything-to-scu.png\" width=\"426\" height=\"219\" /></a></p> \n<p>With <em>S</em> and <em>K</em> one can just point to any piece of an expression and see if it reduces. With <em>J</em> it’s a bit more complicated. In modern Wolfram Language terms one can <a href=\"https://www.wolframscience.com/nks/notes-11-12--single-universal-combinators/\">state the rules as</a> <span class=\"clipboard-inline\"><tt>{j[j][x_][y_][z_]<span class=\"special-character RightArrow\">→</span>x[z][y[z]], j[j[j]][x_][y_]<span class=\"special-character RightArrow\">→</span>x}</tt></span> (where order matters) but to apply these requires pattern matching “clusters of <em>J</em>’s” rather than just looking at single <em>S</em>’s and <em>K</em>’s at a time.</p> \n<p>But even though—as Schönfinkel observed—this “final reduction” to <em>J</em> didn’t work out, getting everything down to <em>S</em> and <em>K</em> was already amazing. At the beginning of the paper, Schönfinkel had described his objectives. And then he says “It seems to me remarkable in the extreme that the goal we have just set can be realized also; as it happens, it can be done by a reduction to three fundamental signs.” (The paper does say three fundamental signs, presumably counting <em>U</em> as well as <em>S</em> and <em>K</em>.)</p> \n<p>I’m sure Schönfinkel expected that to reproduce all the richness of mathematical logic he’d need quite an elaborate set of building blocks. And certainly people like Frege, Whitehead and Russell had used what were eventually very complicated setups. Schönfinkel managed to cut through all the complexity to show that simple building blocks were all that was needed. But then he found something else: that actually just two building blocks (<em>S</em> and <em>K</em>) were enough. </p> \n<p>In modern terms, we’d say that Schönfinkel managed to construct a system capable of universal computation. And that’s amazing in itself. But even more amazing is that he found he could do it with such a simple setup. </p> \n<p>I’m sure Schönfinkel was extremely surprised. And here I personally feel a certain commonality with him. Because in my own explorations of the computational universe, what I’ve found over and over again is that it takes only remarkably simple systems to be capable of highly complex behavior—and of universal computation. And even after exploring the computational universe for four decades, I’m still continually surprised at just how simple the systems can be.</p> \n<p>For me, this has turned into a general principle—the <a href=\"https://www.wolframscience.com/nks/chap-12--the-principle-of-computational-equivalence/\">Principle of Computational Equivalence</a>—and a whole conceptual framework around it. Schönfinkel didn’t have anything like that to think in terms of. But he was in a sense a good enough scientist that he still managed to discover what he discovered—that many decades later we can see fits in as another piece of evidence for the Principle of Computational Equivalence. </p> \n<p>Looking at Schönfinkel’s paper a century later, it’s remarkable not only for what it discovers, but also for the clarity and simplicity with which it is presented. A little of the notation is now dated (and of course the original paper is written in German, which is no longer the kind of leading language of scholarship it once was). But for the most part, the paper still seems perfectly modern. Except, of course, that now it could be couched in terms of symbolic expressions and computation, rather than mathematical logic. </p> \n<h2 id=\"what-is-their-mathematics\">What Is Their Mathematics?</h2> \n<p>Combinators are hard to understand, and it’s not clear how many people understood them when they were first introduced—let alone understood their implications. It’s not a good sign that when <a href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/Schonfinkel-OnTheBuildingBlocksOfMathematicalLogic.pdf\">Schönfinkel’s paper</a> appeared in 1924 the person who helped prepare it for final publication (<a href=\"https://en.wikipedia.org/wiki/Heinrich_Behmann\" target=\"_blank\" rel=\"noopener\">Heinrich Behmann</a>) added his own three paragraphs at the end, that were quite confused. And Schönfinkel’s <a href=\"https://gdz.sub.uni-goettingen.de/download/pdf/PPN235181684_0099/LOG_0022.pdf\" target=\"_blank\" rel=\"noopener\">sole other published paper</a>—coauthored with Paul Bernays in 1927—didn’t even mention combinators, even though they could have very profitably been used to discuss the subject at hand (decision problems in mathematical logic).</p> \n<p>But in 1927 combinators (if not perhaps Schönfinkel’s recognition for them) had a remarkable piece of good fortune. Schönfinkel’s paper was discovered by a certain <a href=\"https://writings.stephenwolfram.com/2020/12/where-did-combinators-come-from-hunting-the-story-of-moses-schonfinkel/#haskell-curry\">Haskell Curry</a>—who would then devote more than 50 years to studying what he named “combinators”, and to spreading the word about them.</p> \n<p>At some level I think one can view the main thrust of what Curry and his disciples did with combinators as an effort to “mathematicize” them. Schönfinkel had presented combinators in a rather straightforward “structural” way. But what was the mathematical interpretation of what he did, and of how combinators work in general? What mathematical formalism could capture Schönfinkel’s structural idea of substitution? Just what, for example, was the true notion of equality for combinators?</p> \n<p>In the end, combinators are fundamentally computational constructs, full of all the <a href=\"https://www.wolframscience.com/nks/chap-12--the-principle-of-computational-equivalence/\">phenomena of “unbridled computation”</a>—like <a href=\"https://www.wolframscience.com/nks/p753--undecidability-and-intractability/\">undecidability</a> and <a href=\"https://www.wolframscience.com/nks/p737--computational-irreducibility/\">computational irreducibility</a>. And it’s inevitable that mathematics as normally conceived can only go so far in “cracking” them. </p> \n<p>But back in the 1920s and 1930s the concept and power of computation was not yet understood, and it was assumed that the ideas and tools of mathematics would be the ones to use in analyzing a formal system like combinators. And it wasn’t that mathematical methods got absolutely nowhere with combinators.</p> \n<p>Unlike <a href=\"https://www.wolframscience.com/nks/p24--how-do-simple-programs-behave/\">cellular automata</a>, or even <a href=\"https://www.wolframscience.com/nks/p78--turing-machines/\">Turing machines</a>, there’s a certain immediate <a href=\"https://writings.stephenwolfram.com/2020/12/combinators-a-centennial-view/\">structural complexity to combinators</a>, with their elaborate tree structures, equivalences and so on. And so there was progress to be made—and years of work to be done—in untangling this, without having to face the raw features of full-scale computation, like computational irreducibility. </p> \n<p>In the end, combinators are full of computational irreducibility. But they also have layers of computational reducibility, some of which are aligned with the kinds of things mathematics and mathematical logic have been set up to handle. And in this there’s a curious resonance with our recent <a href=\"https://www.wolframphysics.org/\" target=\"_blank\" rel=\"noopener\">Physics Project</a>.</p> \n<p>In our models based on hypergraph rewriting there’s also a kind of bedrock of computational irreducibility. But as with combinators, there’s a certain immediate structural complexity to what our models do. And there are layers of computational reducibility associated with this. But the remarkable thing with our models is that some of those layers—and the formalisms one can build to understand them—have an immediate interpretation: they are basically the <a href=\"https://writings.stephenwolfram.com/2020/04/finally-we-may-have-a-path-to-the-fundamental-theory-of-physics-and-its-beautiful/\">core theories of twentieth-century physics</a>, namely general relativity and quantum mechanics.</p> \n<p>Combinators work sufficiently differently that they don’t immediately align with that kind of interpretation. But it’s still true that one of the important properties discovered in combinators (namely <a href=\"https://www.wolframphysics.org/technical-introduction/the-updating-process-for-string-substitution-systems/the-phenomenon-of-causal-invariance/\">confluence, related to our idea of causal invariance</a>) turns out to be crucial to our models, their correspondence with physics, and in the end our whole ability to perceive regularity in the universe, even in the face of computational irreducibility.</p> \n<p>But let’s get back to the story of combinators as it played out after Schönfinkel’s paper. Schönfinkel had basically set things up in a novel, very direct, structural way. But Curry wanted to connect with more traditional ideas in mathematical logic, and mathematics in general. And after a <a href=\"https://writings.stephenwolfram.com/2020/12/where-did-combinators-come-from-hunting-the-story-of-moses-schonfinkel/#curry-1929-paper\">first paper (published in 1929)</a> which pretty much just recorded his first thoughts, and his efforts to understand what Schönfinkel had done, Curry was by 1930 starting to do things like formulate axioms for combinators, and hoping to prove general theorems about mathematical properties like equality.</p> \n<p>Without the understanding of universal computation and their relationship to it, it wasn’t clear yet how complicated it might ultimately be to deal with combinators. And Curry pushed forward, publishing more papers and trying to do things like define set theory using his axioms for combinators. But in 1934 disaster struck. It wasn’t something about computation or undecidability; instead it was that <a href=\"https://en.wikipedia.org/wiki/Stephen_Cole_Kleene\" target=\"_blank\" rel=\"noopener\">Stephen Kleene</a> and <a href=\"https://en.wikipedia.org/wiki/J._Barkley_Rosser\" target=\"_blank\" rel=\"noopener\">J. Barkley Rosser</a> showed the axioms Curry had come up to try and “tighten up Schönfinkel” with were just plain inconsistent.</p> \n<p>To Kleene and Rosser it provided more evidence of the need for Russell’s (originally quite hacky) idea of types—and led them to more complicated axiom systems, and away from combinators. But Curry was undeterred. He revised his axiom system and continued—ultimately for many decades—to see what could be proved about combinators and things like them using mathematical methods. </p> \n<p>But already at the beginning of the 1930s there were bigger things afoot around mathematical logic—which would soon intersect with combinators.</p> \n<h2 id=\"godels-theorem-and-computability\">Gödel’s Theorem and Computability</h2> \n<p>How should one represent the fundamental constructs of mathematics? Back in the 1920s nobody thought seriously about using combinators. And instead there were basically three “big brands”: <em>Principia Mathematica</em>, set theory and Hilbert’s program. Relations were being found, details were being filled in, and issues were being found. But there was a general sense that progress was being made.</p> \n<p>Quite where the boundaries might lie wasn’t clear. For example, could one specify a way to “construct any function” from lower-level primitives? The basic idea of recursion was very old (think: <a href=\"https://www.wolframscience.com/nks/notes-3-5--fibonacci-numbers/\">Fibonacci</a>). But by the early 1920s there was a fairly well-formalized notion of “<a href=\"https://www.wolframscience.com/nks/notes-4-3--primitive-recursive-functions/\">primitive recursion</a>” in which functions always found their values from earlier values. But could all “mathematical” functions be constructed this way? </p> \n<p>By 1926 it was known that this wouldn’t work: the <a href=\"https://www.wolframscience.com/nks/notes-4-3--ackermann-functions/\">Ackermann function</a> was a reasonable “mathematical” function, but it wasn’t primitive recursive. It meant that definitions had to be generalized (e.g. to “<a href=\"https://www.wolframscience.com/nks/notes-4-3--primitive-recursive-functions/\">general recursive functions</a>” that didn’t just look back at earlier values, but could “look forward until...” as well). But there didn’t seem to be any fundamental problem with the idea that mathematics could just “mechanistically” be built out forever from appropriate primitives.</p> \n<p>But in 1931 came <a href=\"https://www.wolframscience.com/nks/notes-12-9--godels-theorem/\">Gödel’s theorem</a>. There’d been a long tradition of identifying paradoxes and inconsistencies, and finding ways to patch them by changing axioms. But Gödel’s theorem was based on <a href=\"https://www.wolframscience.com/nks/notes-12-9--axioms-for-arithmetic/\">Peano’s by-then-standard axioms</a> for arithmetic (branded by Gödel as a fragment of <em>Principia Mathematica</em>). And it showed there was a fundamental problem.</p> \n<p>In essence, Gödel took the paradoxical statement “this statement is unprovable” and showed that it could be expressed purely as a statement of arithmetic—roughly a statement about the existence of solutions to appropriate integer equations. And basically what Gödel had to do to achieve this was to create a “compiler” capable of compiling things like “this statement is unprovable” into arithmetic. </p> \n<p>In his paper one can basically see him building up different capabilities (e.g. representing arbitrary expressions as numbers through Gödel numbering, checking conditions using general recursion, etc.)—eventually getting to a “high enough level” to represent the statement he wanted:</p> \n<p><a class=\"magnific image\" alt=\"Gödel’s “On Undecidable Propositions of Principia Mathematica and Related Systems”\" title=\"Gödel’s “On Undecidable Propositions of Principia Mathematica and Related Systems”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/009-godel-arbitrary-expressions-general-recursion-a-left.png\"><img alt=\"Gödel’s “On Undecidable Propositions of Principia Mathematica and Related Systems”—click to enlarge\" title=\"Gödel’s “On Undecidable Propositions of Principia Mathematica and Related Systems”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/009-godel-arbitrary-expressions-general-recursion-a-left.png\" width=\"291\" height=\"457\" /></a> <a class=\"magnific image\" alt=\"Gödel’s “On Undecidable Propositions of Principia Mathematica and Related Systems”\" title=\"Gödel’s “On Undecidable Propositions of Principia Mathematica and Related Systems”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/009-godel-arbitrary-expressions-general-recursion-b-right.png\"><img alt=\"Gödel’s “On Undecidable Propositions of Principia Mathematica and Related Systems”—click to enlarge\" title=\"Gödel’s “On Undecidable Propositions of Principia Mathematica and Related Systems”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/009-godel-arbitrary-expressions-general-recursion-b-right.png\" width=\"291\" height=\"457\" /></a></p> \n<p>What did Gödel’s theorem mean? For the foundations of mathematics it meant that the idea of mechanically proving “all true theorems of mathematics” wasn’t going to work. Because it showed that there was at least one statement that by its own admission couldn’t be proved, but was still a “statement about arithmetic”, in the sense that it could be “compiled into arithmetic”.</p> \n<p>That was a big deal for the foundations of mathematics. But actually there was something much more significant about Gödel’s theorem, even though it wasn’t recognized at the time. Gödel had used the primitives of number theory and logic to build what amounted to a computational system—in which one could take things like “this statement is unprovable”, and “<a href=\"https://www.wolframscience.com/nks/p786--implications-for-mathematics-and-its-foundations/\">run them in arithmetic</a>”. </p> \n<p>What Gödel had, though, wasn’t exactly a streamlined general system (after all, it only really needed to handle one statement). But the immediate question then was: if there’s a problem with this statement in arithmetic, what about Hilbert’s general “decision problem” (<em>Entscheidungsproblem</em>) for any axiom system?</p> \n<p>To discuss the “general decision problem”, though, one needed some kind of general notion of how one could decide things. What ultimate primitives should one use? Schönfinkel (with Paul Bernays)—in his sole other published paper—wrote about a restricted case of the decision problem in 1927, but doesn’t seem to have had the idea of using combinators to study it. </p> \n<p>By 1934 Gödel was talking about general recursiveness (i.e. definability through general recursion). And <a href=\"https://www.wolframscience.com/nks/notes-11-12--lambda-calculus/\">Alonzo Church</a> and Stephen Kleene were introducing <a href=\"https://www.wolframscience.com/nks/notes-11-12--lambda-calculus/\"><span class=\"special-character Lambda\">λ</span> definability</a>. Then in 1936 <a href=\"https://writings.stephenwolfram.com/2012/06/happy-100th-birthday-alan-turing/\">Alan Turing</a> introduced <a href=\"https://www.wolframscience.com/nks/notes-3-4--history-of-turing-machines/\">Turing machines</a>. All these approaches involved setting up certain primitives, then showing that a large class of things could be “compiled” to those primitives. And that—in effect by thinking about having it compile itself—Hilbert’s <em>Entscheidungsproblem</em> couldn’t be solved.</p> \n<p>Perhaps no single result along these lines would have been so significant. But it was soon established that all three kinds of systems were exactly equivalent: the set of computations they could represent were the same, as established by showing that one system could emulate another. And from that discovery eventually emerged the modern notion of universal computation—and all its implications for technology and science.</p> \n<p>In the early days, though, there was actually a fourth equivalent kind of system—based on string rewriting—that had been <a href=\"https://www.wolframscience.com/nks/notes-3-7--history-of-tag-systems/\">invented by Emil Post</a> in 1920–1. Oh, and then there were combinators.</p> \n<h2 id=\"lambda-calculus\">Lambda Calculus</h2> \n<p>What was the right “language” to use for setting up mathematical logic? There’d been gradual improvement since the complexities of <em>Principia Mathematica</em>. But around 1930 Alonzo Church wanted a new and cleaner setup. And he needed to have a way (as Frege and <em>Principia Mathematica</em> had done before him) to represent “<a href=\"https://www.wolfram.com/language/elementary-introduction/2nd-ed/26-pure-anonymous-functions.html\">pure functions</a>”. And that’s how he came to invent <span class=\"special-character Lambda\">λ</span>. </p> \n<p>Today in the Wolfram Language we have <tt><a href=\"https://reference.wolfram.com/language/ref/Function.html\">Function</a>[x,f[x]]</tt> or <tt>x<span class=\"special-character Function\"></span>f[x]</tt> (or various shorthands). Church originally had <span class=\"special-character Lambda\">λ</span><em>x</em>[<strong>M</strong>]:</p> \n<p><a class=\"magnific image\" alt=\"Church’s “A Set of Postulates for the Foundation of Logic”\" title=\"Church’s “A Set of Postulates for the Foundation of Logic”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/010-church-lambda-calculus-original.png\"><img alt=\"Church’s “A Set of Postulates for the Foundation of Logic”—click to enlarge\" title=\"Church’s “A Set of Postulates for the Foundation of Logic”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/010-church-lambda-calculus-original.png\" width=\"291\" height=\"441\" /></a></p> \n<p>But what’s perhaps most notable is that on the very first page he defines <span class=\"special-character Lambda\">λ</span>, he’s referencing Schönfinkel’s combinator paper. (Well, specifically, he’s referencing it because he wants to use the device Schönfinkel invented that we now call currying—<tt>f[x][y]</tt> in place of <tt>f[x,y]</tt>—though ironically he doesn’t mention Curry.) In his 1932 paper (apparently based on work in 1928–9) <span class=\"special-character Lambda\">λ</span> is almost a sideshow—the main event being the introduction of 37 formal postulates for mathematical logic: </p> \n<p><a class=\"magnific image\" alt=\"Introduction of 37 formal postulates\" title=\"Introduction of 37 formal postulates\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/011-church-37-formal-postulates.png\"><img alt=\"Introduction of 37 formal postulates—click to enlarge\" title=\"Introduction of 37 formal postulates—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/011-church-37-formal-postulates.png\" width=\"291\" height=\"441\" /></a></p> \n<p>By the next year J. Barkley Rosser is trying to retool Curry’s “combinatory logic” with combinators of his own—and showing how they correspond to lambda expressions:</p> \n<p><a class=\"magnific image\" alt=\"J. Barkley Rosser’s combinators\" title=\"J. Barkley Rosser’s combinators\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/012-rosser-retool-curry-combinatory-logic.png\"><img alt=\"J. Barkley Rosser’s combinators—click to enlarge\" title=\"J. Barkley Rosser’s combinators—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/012-rosser-retool-curry-combinatory-logic.png\" width=\"387\" height=\"157\" /></a></p> \n<p>Then in 1935 lambda calculus has its big “coming out” in Church’s “<a href=\"https://www.fermatslibrary.com/p/d3c45049\" target=\"_blank\">An Unsolvable Problem of Elementary Number Theory</a>”, in which he introduces the idea that any “effectively calculable” function should be “<span class=\"special-character Lambda\">λ</span> definable”, then defines integers in terms of <span class=\"special-character Lambda\">λ</span>’s (“<a href=\"https://www.wolframscience.com/nks/notes-11-12--combinators/\">Church numerals</a>”)</p> \n<p><a class=\"magnific image\" alt=\"Church’s “An Unsolvable Problem of Elementary Number Theory”\" title=\"Church’s “An Unsolvable Problem of Elementary Number Theory”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/013-church-numerals.png\"><img alt=\"Church’s “An Unsolvable Problem of Elementary Number Theory”—click to enlarge\" title=\"Church’s “An Unsolvable Problem of Elementary Number Theory”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/013-church-numerals.png\" width=\"334\" height=\"69\" /></a></p> \n<p>and then shows that the problem of determining equivalence for <span class=\"special-character Lambda\">λ</span> expressions is undecidable.</p> \n<p>Very soon thereafter <a href=\"https://writings.stephenwolfram.com/2012/06/happy-100th-birthday-alan-turing/\">Turing</a> publishes his “On Computable Numbers, with an Application to the <em>Entscheidungsproblem</em>” in which he introduces his much more manifestly mechanistic <a href=\"https://writings.stephenwolfram.com/2012/06/happy-100th-birthday-alan-turing/\">Turing machine model</a> of computation. In the main part of the paper there are no lambdas—or combinators—to be seen. But by late 1936 Turing had gone to Princeton to be a student with Church—and added a note showing the correspondence between his Turing machines and Church’s lambda calculus.</p> \n<p>By the next year, when Turing is writing his rather abstruse “Systems of Logic Based on Ordinals” he’s using lambda calculus all over the place. Early in the document he writes <em>I</em>&nbsp;<span class=\"special-character RightArrow\">→</span>&nbsp;<span class=\"special-character Lambda\">λ</span><em>x</em>[<em>x</em>], and soon he’s mixing lambdas and combinators with wild abandon—and in fact he’d already published a one-page paper which introduced the fixed-point combinator <span class=\"special-character CapitalTheta\">Θ</span> (and, yes, the <em>K</em> in the title refers to Schönfinkel’s <em>K</em> combinator):</p> \n<p><a class=\"magnific image\" alt=\"Turing’s “The p-function in lambda-K-conversion”\" title=\"Turing’s “The p-function in lambda-K-conversion”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/014-turing-function-k-conversion.png\"><img alt=\"Turing’s “The p-function in lambda-K-conversion”—click to enlarge\" title=\"Turing’s “The p-function in lambda-K-conversion”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/014-turing-function-k-conversion.png\" width=\"345\" height=\"408\" /></a></p> \n<p>When Church summarized the state of lambda calculus in 1941 in his “The Calculi of Lambda-Conversion” he again made extensive use of combinators. Schönfinkel’s <em>K</em> is prominent. But Schönfinkel’s <em>S</em> is nowhere to be seen—and in fact Church has his own <em>S</em> combinator <span class=\"traditional-math\"><em>S</em>[<em>n</em>][<em>f</em>][<em>x</em>]<span class=\"special-character RightArrow\">→</span><em>f</em>[<em>n</em>[<em>f</em>][<em>x</em>]]</span> which implements successors in Church’s numeral system. And he has also has a few other “basic combinators” that he routinely uses.</p> \n<p>In the end, combinators and lambda calculus are completely equivalent, and it’s quite easy to convert between them—but there’s a curious tradeoff. In lambda calculus one names variables, which is good for human readability, but can lead to problems at a formal level. In combinators, things are formally much cleaner, but the expressions one gets can be completely incomprehensible to humans.</p> \n<p>The point is that in a lambda expression like <span class=\"special-character Lambda\">λ</span><em>x</em>&nbsp;<span class=\"special-character Lambda\">λ</span><em>y</em>&nbsp;<em>x</em>[<em>y</em>] one’s naming the variables (here <em>x</em> and <em>y</em>), but really these names are just placeholders: what they are doesn’t matter; they’re just showing where different arguments go. And in a simple case like this, everything is fine. But what happens if one substitutes for <em>y</em> another lambda expression, say <span class=\"special-character Lambda\">λ</span><em>x</em> <em>f</em>[<em>x</em>]? What is that <em>x</em>? Is it the same <em>x</em> as the one outside, or something different? In practice, there are all sorts of renaming schemes that can be used, but they tend to be quite hacky, and things can quickly get tangled up. And if one wants to make formal proofs about lambda calculus, this can potentially be a big problem, and indeed at the beginning it wasn’t clear it wouldn’t derail the whole idea of lambda calculus.</p> \n<p>And that’s part of why the correspondence between lambda calculus and combinators was important. With combinators there are no variables, and so no variable names to get tangled up. So if one can show that something can be converted to combinators—even if one never looks at the potentially very long and ugly combinator expression that’s generated—one knows one’s safe from issues about variable names.</p> \n<p>There are still plenty of other complicated issues, though. Prominent among them are questions about when combinator expressions can be considered equal. Let’s say you have a combinator expression, like <span class=\"clipboard-inline\"><tt>s[s[s[s][k]]][k]</tt></span>. Well, you can repeatedly apply the rules for combinators to transform and reduce it. And it’ll often end up at a fixed point, where no rules apply anymore. But a basic question is whether it matters in which order the rules are applied. And in 1936 Church and Rosser <a href=\"https://www.wolframscience.com/nks/notes-11-12--combinator-properties/\">proved it doesn’t</a>.</p> \n<p>Actually, what they specifically proved was the analogous result for lambda calculus. They drew a picture to indicate different possible orders in which lambdas could be reduced out, and showed it didn’t matter which path one takes:</p> \n<p><img src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/015-church-rosser-possible-lambda-orders-b.png\" alt=\"The analogous result for lambda calculus\" title=\"The analogous result for lambda calculus\" width=\"405\" height=\"177\" /></p> \n<p>This all might seem like a detail. But it turns out that generalizations of their result apply to all sorts of systems. In doing computations (or <a href=\"https://writings.stephenwolfram.com/2018/11/logic-explainability-and-the-future-of-understanding/\">automatically proving theorems</a>) it’s all about “it doesn’t matter what path you take; you’ll always get the same result”. And that’s important. But recently there’s been another important application that’s shown up. It turns out that a generalization of the “Church–Rosser property” is what we call <a href=\"https://www.wolframscience.com/nks/p503--the-sequencing-of-events-in-the-universe/\">causal invariance</a> in our <a href=\"https://www.wolframphysics.org/\">Physics Project</a>. </p> \n<p>And it’s causal invariance that leads in our models to relativistic invariance, general covariance, objective reality in quantum mechanics, and other central features of physics. </p> \n<h2 id=\"practical-computation\">Practical Computation</h2> \n<p>In retrospect, one of the great achievements of the 1930s was the inception of what ended up being the idea of universal computation. But at the time what was done was couched in terms of mathematical logic and it was far from obvious that any of the theoretical structures being built would have any real application beyond thinking about the foundations of mathematics. But even as people like Hilbert were talking in theoretical terms about the mechanization of mathematics, more and more there were actual machines being built for doing mathematical calculations.</p> \n<p>We know that even in antiquity (at least one) simple <a href=\"https://writings.stephenwolfram.com/2017/08/when-exactly-will-the-eclipse-happen-a-multimillenium-tale-of-computation/\">gear-based mechanical calculational devices</a> existed. In the mid-1600s arithmetic calculators started being constructed, and by the late 1800s they were in widespread use. At first they were mechanical, but by the 1930s most were electromechanical, and there started to be systems where units for carrying out different arithmetic operations could be chained together. And by the end of the 1940s fairly elaborate such systems based on electronics were being built.</p> \n<p>Already in the 1830s <a href=\"https://www.wolframscience.com/nks/notes-11-1--history-of-computing/\">Charles Babbage had imagined an “analytical engine”</a> which could do different operations depending on a “program” specified by punch cards—and <a href=\"https://writings.stephenwolfram.com/2015/12/untangling-the-tale-of-ada-lovelace/\">Ada Lovelace</a> had realized that such a machine had broad “computational” potential. But by the 1930s a century had passed and nothing like this was connected to the theoretical developments that were going on—and the actual engineering of computational systems was done without any particular overarching theoretical framework.</p> \n<p>Still, as electronic devices got more complicated and scientific interest in psychology intensified, something else happened: there started to be the idea (sometimes associated with the name cybernetics) that somehow electronics might reproduce how things like brains work. In the mid-1930s <a href=\"https://www.wolframalpha.com/input/?i=claude+shannon\">Claude Shannon</a> had shown that Boolean algebra could represent how switching circuits work, and in 1943 <a href=\"https://en.wikipedia.org/wiki/Warren_Sturgis_McCulloch\" target=\"_blank\" rel=\"noopener\">Warren McCulloch</a> and <a href=\"https://en.wikipedia.org/wiki/Walter_Pitts\" target=\"_blank\" rel=\"noopener\">Walter Pitts</a> proposed a model of idealized neural networks formulated in something close to mathematical logic terms.</p> \n<p>Meanwhile by the mid-1940s <a href=\"https://writings.stephenwolfram.com/2003/12/john-von-neumanns-100th-birthday/\">John von Neumann</a>—who had worked extensively on mathematical logic—had started suggesting math-like specifications for practical electronic computers, including the way their programs might be stored electronically. At first he made lots of brain-like references to “organs” and “inhibitory connections”, and essentially no mention of ideas from mathematical logic. But by the end of the 1940s von Neumann was talking at least conceptually about connections to Gödel’s theorem and Turing machines, Alan Turing had become involved with actual electronic computers, and there was the beginning of widespread understanding of the notion of general-purpose computers and universal computation.</p> \n<p>In the 1950s there was an explosion of interest in what would now be called the theory of computation—and great optimism about its relevance to artificial intelligence. There was all sorts of “interdisciplinary work” on fairly “concrete” models of computation, like finite automata, Turing machines, <a href=\"https://www.wolframscience.com/nks/notes-2-3--history-of-cellular-automata/\">cellular automata</a> and idealized neural networks. More “abstract” approaches, like recursive functions, lambda calculus—and combinators—remained, however, pretty much restricted to researchers in mathematical logic.</p> \n<p>When early programming languages started to appear in the latter part of the 1950s, thinking about practical computers began to become a bit more abstract. It was understood that the grammars of languages could be specified recursively—and actual recursion (of functions being able to call themselves) just snuck into the specification of <a href=\"https://en.wikipedia.org/wiki/ALGOL_60\" target=\"_blank\" rel=\"noopener\">ALGOL 60</a>. But what about the structures on which programs operated? Most of the concentration was on arrays (sometimes rather elegantly, as in <a href=\"https://en.wikipedia.org/wiki/APL_(programming_language)\" target=\"_blank\" rel=\"noopener\">APL</a>) and, occasionally, character strings.</p> \n<p>But a notable exception was <a href=\"https://www.wolframalpha.com/input/?i=lisp+language\">LISP</a>, described in <a href=\"https://www.wolframalpha.com/input/?i=john+mccarthy\">John McCarthy</a>’s 1960 paper “Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I” (part 2 was not written). There was lots of optimism about AI at the time, and the idea was to create a language to “implement AI”—and do things like “mechanical theorem proving”. A key idea—that McCarthy described as being based on “recursive function formalism”—was to have tree-structured symbolic expressions (“<em>S</em> expressions”). (In the original paper, what’s now Wolfram Language–style <tt>f[g[x]]</tt> “<em>M</em> expression” notation, complete with square brackets, was used as part of the specification, but the quintessential-LISP-like (<em>f</em> (<em>g x</em>)) notation won out when LISP was actually implemented.)</p> \n<p><a class=\"magnific image\" alt=\"McCarthy’s “Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I”\" title=\"McCarthy’s “Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/016-mccarthy-paper-recursive-function.png\"><img alt=\"McCarthy’s “Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I”—click to enlarge\" title=\"McCarthy’s “Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/016-mccarthy-paper-recursive-function.png\" width=\"568\" height=\"723\" /></a></p> \n<p>An issue in LISP was how to take “expressions” (which were viewed as representing things) and turn them into functions (which do things). And the basic plan was to use Church’s idea of <span class=\"special-character Lambda\">λ</span> notation. But when it came time to implement this, there was, of course, trouble with name collisions, which ended up getting handled in quite hacky ways. So did McCarthy know about combinators? The answer is yes, as his 1960 paper shows:</p> \n<p><a class=\"magnific image\" alt=\"McCarthy’s “Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I”\" title=\"McCarthy’s “Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I”\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/017-mccarthy-combinator-mention.png\"><img alt=\"McCarthy’s “Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I”—click to enlarge\" title=\"McCarthy’s “Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I”—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/017-mccarthy-combinator-mention.png\" width=\"322\" height=\"136\" /></a></p> \n<p>I actually didn’t know until just now that McCarthy had ever even considered combinators, and in the years I knew him I don’t think I ever personally talked to him about them. But it seems that for McCarthy—as for Church—combinators were a kind of “comforting backstop” that ensured that it was OK to use lambdas, and that if things went too badly wrong with variable naming, there was at least in principle always a way to untangle everything.</p> \n<p>In the practical development of computers and computer languages, even lambdas—let alone combinators—weren’t really much heard from again (except in a small AI circle) until the 1980s. And even then it didn’t help that in an effort variously to stay close to hardware and to structure programs there tended to be a desire to give everything a “data type”—which was at odds with the “consume any expression” approach of standard combinators and lambdas. But beginning in the 1980s—particularly with the progressive rise of <a href=\"https://reference.wolfram.com/language/guide/FunctionalProgramming.html\">functional programming</a>—lambdas, at least, have steadily gained in visibility and practical application. </p> \n<p>What of combinators? Occasionally as a proof of principle there’ll be a <a href=\"https://dl.acm.org/doi/10.1145/800087.802798\" target=\"_blank\">hardware system</a> developed that natively implements Schönfinkel’s combinators. Or—particularly in modern times—there’ll be an <a href=\"http://www.madore.org/~david/programs/unlambda/\">esoteric language</a> that uses combinators in some kind of purposeful effort at obfuscation. Still, a remarkable cross-section of notable people concerned with the foundations of computing have—at one time or another—taught about combinators or written a paper about them. And in recent years the term “combinator” has become more popular as a way to describe a “purely applicative” function.</p> \n<p>But by and large the important ideas that first arose with combinators ended up being absorbed into practical computing by quite circuitous routes, without direct reference to their origins, or to the specific structure of combinators.</p> \n<h2 id=\"combinators-in-culture\">Combinators in Culture</h2> \n<p>For 100 years combinators have mostly been an obscure academic topic, studied particularly in connection with lambda calculus, at borders between theoretical computer science, mathematical logic and to some extent mathematical formalisms like category theory. Much of the work that’s been done can be traced in one way or another to the influence of Haskell Curry or Alonzo Church—particularly through <a href=\"https://www.genealogy.math.ndsu.nodak.edu/id.php?id=7398&amp;fChrono=1\" target=\"_blank\">their students</a>, <a href=\"https://www.genealogy.math.ndsu.nodak.edu/id.php?id=7398&amp;fChrono=1\" target=\"_blank\">grandstudents</a>, <a href=\"https://www.genealogy.math.ndsu.nodak.edu/id.php?id=7398&amp;fChrono=1\" target=\"_blank\">great-grandstudents</a>, etc. Partly in the early years, most of the work was centered in the US, but by the 1960s there was a strong migration to Europe and especially the Netherlands.</p> \n<p>But even with all their abstractness and obscurity, on a few rare occasions combinators have broken into something closer to the mainstream. One such time was with the popular logic-puzzle book <em><a href=\"https://www.amazon.com/Mock-Mockingbird-Raymond-Smullyan/dp/0192801422\" target=\"_blank\" rel=\"noopener\">To Mock a Mockingbird</a></em>, published in 1985 by <a href=\"https://en.wikipedia.org/wiki/Raymond_Smullyan\" target=\"_blank\" rel=\"noopener\">Raymond Smullyan</a>—a former student of Alonzo Church’s. It begins: “A certain enchanted forest is inhabited by talking birds” and goes on to tell a story that's basically about combinators “dressed up” as birds calling each other (<em>S</em> is the “starling”, <em>K</em> the “kestrel”)—with a convenient “bird who’s who” at the end. The book is dedicated “To the memory of Haskell Curry—an early pioneer in combinatory logic and an avid bird-watcher”.</p> \n<p><a class=\"magnific image\" alt=\"To Mock a Mockingbird by Raymond Smullyan\" title=\"To Mock a Mockingbird by Raymond Smullyan\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/018-mockingbird-r-smullyan-a-left.png\"><img alt=\"To Mock a Mockingbird by Raymond Smullyan—click to enlarge\" title=\"To Mock a Mockingbird by Raymond Smullyan—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/018-mockingbird-r-smullyan-a-left.png\" width=\"262\" height=\"414\" /></a> <a class=\"magnific image\" alt=\"To Mock a Mockingbird by Raymond Smullyan\" title=\"To Mock a Mockingbird by Raymond Smullyan\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/018-mockingbird-r-smullyan-b-right.png\"><img alt=\"To Mock a Mockingbird by Raymond Smullyan—click to enlarge\" title=\"To Mock a Mockingbird by Raymond Smullyan—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/018-mockingbird-r-smullyan-b-right.png\" width=\"262\" height=\"414\" /></a></p> \n<p>And then there’s <a href=\"https://www.ycombinator.com/\">Y Combinator</a>. The original <em>Y</em> combinator arose out of work that Curry did in the 1930s on the consistency of axiom systems for combinators, and it appeared explicitly in his 1958 classic book:</p> \n<p><a class=\"magnific image\" alt=\"Combinatory Logic by Haskell B. Curry and Robert Feys\" title=\"Combinatory Logic by Haskell B. Curry and Robert Feys\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/019-combinatory-logic-curry-a-left.png\"><img alt=\"Combinatory Logic by Haskell B. Curry and Robert Feys—click to enlarge\" title=\"Combinatory Logic by Haskell B. Curry and Robert Feys—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/019-combinatory-logic-curry-a-left.png\" width=\"271\" height=\"388\" /></a> <a class=\"magnific image\" alt=\"Combinatory Logic by Haskell B. Curry and Robert Feys\" title=\"Combinatory Logic by Haskell B. Curry and Robert Feys\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/019-combinatory-logic-curry-b-right.png\"><img alt=\"Combinatory Logic by Haskell B. Curry and Robert Feys—click to enlarge\" title=\"Combinatory Logic by Haskell B. Curry and Robert Feys—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/019-combinatory-logic-curry-b-right.png\" width=\"271\" height=\"388\" /></a></p> \n<p>He called it the “paradoxical combinator” because it was recursively defined in a kind of self-referential way analogous to various paradoxes. Its explicit form is <em>SSK</em>(<em>S</em>(<em>K</em>(<em>SS</em>(<em>S</em>(<em>SSK</em>))))<em>K</em>) and its most immediately notable feature is that under Schönfinkel’s combinator transformation rules it never settles down to a particular “value” but just keeps growing forever.</p> \n<p>Well, in 2005 <a href=\"https://www.wolframalpha.com/input/?i=paul+graham\">Paul Graham</a>—who had long been an enthusiast of functional programming and LISP—decided to name his <a href=\"https://www.stephenwolfram.com/publications/starting-long-term-company/\">new (and now very famous) startup accelerator</a> “Y Combinator”. I remember asking him why he’d called it that. “Because,” he said, “nobody understands the <em>Y</em> combinator”. </p> \n<p>Looking in my own archives from that time I find an email I sent a <a href=\"http://www.szudzik.com/\" target=\"_blank\">combinator enthusiast</a> who was working with me:</p> \n<p><img src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/020-combinator-email.png\" alt=\"Email to Matthew Szudzik\" title=\"Email to Matthew Szudzik\" width=\"330\" height=\"178\" /></p> \n<p>Followed by, basically, “Yes our theorem prover can prove the basic property of the <em>Y</em> combinator” (<a href=\"https://www.wolfram.com/mathematica/newin6/\">V6</a> sounds so ancient; we’re now just about to release V12.2):</p> \n<p><img src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/021-combinator-equation-email.png\" alt=\"Proving the basic property of the Y combinator\" title=\"Proving the basic property of the Y combinator\" width=\"330\" height=\"130\" /></p> \n<p>I had another unexpected encounter with combinators last year. I had been <a href=\"https://writings.stephenwolfram.com/2019/08/a-book-from-alan-turing-and-a-mysterious-piece-of-paper/\">given a book</a> that was once owned by Alan Turing, and in it I found a piece of paper—that I recognized as being covered with none other than lambdas and combinators (but that’s not <em>the</em> <em>Y</em> combinator):</p> \n<p><a class=\"magnific image\" alt=\"Note in Alan Turing’s book\" title=\"Note in Alan Turing’s book\" href=\"https://writings.stephenwolfram.com/data/uploads/2019/08/front-page_420_544@2x1.jpg\"><img alt=\"Note in Alan Turing’s book—click to enlarge\" title=\"Note in Alan Turing’s book—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2019/08/front-page_420_544@2x1.jpg\" width=\"450\" /></a></p> \n<p>It took quite a bit of sleuthing (<a href=\"https://writings.stephenwolfram.com/2019/08/a-book-from-alan-turing-and-a-mysterious-piece-of-paper/\">that I wrote extensively about</a>)—but I eventually discovered that the piece of paper was written by Turing’s student <a href=\"https://en.wikipedia.org/wiki/Robin_Gandy\" target=\"_blank\" rel=\"noopener\">Robin Gandy</a>. But I never figured out why he was doing combinators....</p> \n<h2 id=\"designing-symbolic-language\">Designing Symbolic Language</h2> \n<p>I think I first found out about combinators around 1979 by seeing Schönfinkel’s original paper in a book called <em>From Frege to Gödel: A Source Book in Mathematical Logic</em> (by a certain <a href=\"https://en.wikipedia.org/wiki/Jean_van_Heijenoort\" target=\"_blank\" rel=\"noopener\">Jean van Heijenoort</a>). How Schönfinkel’s paper ended up being in that book is an interesting question, which <a href=\"https://writings.stephenwolfram.com/2020/12/where-did-combinators-come-from-hunting-the-story-of-moses-schonfinkel/#schonfinkel-rediscovered\">I’ll write about elsewhere</a>. The spine of my copy of the book has long been broken at the location of Schönfinkel’s paper, and at different times I’ve come back to the paper, always thinking there was more to understand about it.</p> \n<p>But <a href=\"https://writings.stephenwolfram.com/2016/04/my-life-in-technology-as-told-at-the-computer-history-museum/\">why was I even studying things like this back in 1979</a>? I guess in retrospect I can say I was engaged in an activity that goes back to Frege or even <a href=\"https://writings.stephenwolfram.com/2013/05/dropping-in-on-gottfried-leibniz/\">Leibniz</a>: I was trying to find a fundamental framework for representing mathematics and beyond. But my goal wasn’t a philosophical one; it was a very practical one: I was trying to build a computer language that could do general computations in mathematics and beyond.</p> \n<p>My immediate applications were in physics, and it was from physics that my main methodological experience came. And the result was that—like trying to understand the world in terms of elementary particles—I wanted to understand computation in terms of its most fundamental elements. But I also had lots of practical experience in using computers to do mathematical computation. And I soon developed a theory about how I thought computation could fundamentally be done. </p> \n<p>It started from the practical issue of transformations on algebraic expressions (turn sin(2<em>x</em>) into 2 sin(<em>x</em>)&nbsp;cos(<em>x</em>), etc.). But it soon became a general idea: compute by doing transformations on symbolic expressions. Was this going to work? I wanted to understand as fundamentally as possible what computation really was—and from that I was led to its history in mathematical logic. Much of what I saw in books and papers about mathematical logic I found abstruse and steeped in sometimes horrendous notational complexity. But what were these people really doing? It made it much easier that I had a definite theory, against which I could essentially do reductionist science. That stuff in <em>Principia Mathematica</em>? Those ideas about rewriting systems? Yup, I could see how to represent them as rules for transformations on symbolic expressions. </p> \n<p>And so it was that <a href=\"https://writings.stephenwolfram.com/2013/06/there-was-a-time-before-mathematica/\">I came to design SMP</a>: “<a href=\"https://content.wolfram.com/uploads/sites/34/2020/07/smp-reference-manual.pdf\" target=\"_blank\" rel=\"noopener\">A Symbolic Manipulation Program</a>”—all based on transformation rules for symbolic expressions. It was easy to represent mathematical relations (<span style=\"font-weight:Regular;font-family:Arial\">$x</span> is a pattern variable that would now in the Wolfram Language be <tt>x_</tt> on the left-hand side only):</p> \n<p><img src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/smp-01.png\" alt=\"A Symbolic Manipulation Program\" title=\"A Symbolic Manipulation Program\" width=\"620\" height=\"101\" /></p> \n<p>Or basic logic:</p> \n<p><img src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/smp-02.png\" alt=\"A Symbolic Manipulation Program\" title=\"A Symbolic Manipulation Program\" width=\"606\" height=\"448\" /></p> \n<p>Or, for that matter, predicate logic of the kind Schönfinkel wanted to capture:</p> \n<p><img src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/smp-03.png\" alt=\"A Symbolic Manipulation Program\" title=\"A Symbolic Manipulation Program\" width=\"620\" height=\"115\" /></p> \n<p>And, yes, it could emulate a Turing machine (note the tape-as-transformation-rules representation that appears at the end):</p> \n<p><img src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/smp-04.png\" alt=\"A Symbolic Manipulation Program\" title=\"A Symbolic Manipulation Program\" width=\"589\" height=\"442\" /></p> \n<p>But the most important thing I realized is that it really worked to represent basically anything in terms of symbolic expressions, and transformation rules on them. Yes, it was quite often useful to think of “applying functions to things” (and SMP had its version of lambda, for example), but it was much more powerful to think about symbolic expressions as just “being there” (“<em>x</em> doesn’t have to have a value”)—like things in the world—with the language being able to define how things should transform. </p> \n<p>In retrospect this all seems awfully like the core idea of combinators, but with one important exception: that instead of everything being built from “purely structural elements” with names like <em>S</em> and <em>K</em>, there was a whole collection of “primitive objects” that were intended to have direct understandable meanings (like <tt><a href=\"https://reference.wolfram.com/language/ref/Plus.html\">Plus</a></tt>, <tt><a href=\"https://reference.wolfram.com/language/ref/Times.html\">Times</a></tt>, etc.). And indeed I saw a large part of my task in language design as being to think about computations one might want to do, and then try to “drill down” to find the “elementary particles”—or primitive objects—from which these computations might be built up. </p> \n<p>Over time I’ve come to realize that doing this is less about what one can in principle use to construct computations, and more about <a href=\"https://writings.stephenwolfram.com/2019/05/what-weve-built-is-a-computational-language-and-thats-very-important/\">making a bridge to the way humans think about things</a>. It’s crucial that there’s an underlying structure—symbolic expressions—that can represent anything. But increasingly I’ve come to realize that what we need from a computational language is to have a way to encapsulate in precise computational form the kinds of things we humans think about—in a way that we humans can understand. And a crucial part of being able to do that is to leverage what has ultimately been at the core of making our whole intellectual development as a species possible: the idea of human language.</p> \n<p>Human language has given us a way to talk symbolically about the world: to give symbolic names to things, and then to build things up using these. In <a href=\"https://writings.stephenwolfram.com/2017/12/what-do-i-do-all-day-livestreamed-technology-ceoing/\">designing a computational language</a> the goal is to leverage this: to use what humans already know and understand, but be able to represent it in a precise computational way that is amenable to actual computation that can be done automatically by computer.</p> \n<p>It’s probably no coincidence that the tree structure of symbolic expressions that I have found to be such a successful foundation for computational language is a bit like an idealized version of the kind of tree structure (think parse trees or sentence diagramming) that one can view human language as following. There are other ways to set up universal computation, but this is the one that seems to fit most directly with our way of thinking about things.</p> \n<p>And, yes, in the end all those symbolic expressions could be constructed like combinators from objects—like <em>S</em> and <em>K</em>—with no direct human meaning. But that would be like having a world without nouns—a world where there’s no name for anything—and the representation of everything has to be built from scratch. But the crucial idea that’s central to human language—and now to computational language—is to be able to have layers of abstraction, where one can name things and then refer to them just by name without having to think about how they’re built up “inside”. </p> \n<p>In some sense one can see the goal of people like Frege—and Schönfinkel—as being to “reduce out” what exists in mathematics (or the world) and turn it into something like “pure logic”. And the structural part of that is exactly what makes computational language possible. But in my conception of computational language the whole idea is to have content that relates to the world and the way we humans think about it.</p> \n<p>And over the decades I’ve continually been amazed at just how strong and successful the idea of representing things in terms of symbolic expressions and transformations on them is. Underneath everything that’s going on in the Wolfram Language—and in all the many systems that now use it—it’s all ultimately just symbolic expressions being transformed according to particular rules, and reaching fixed points that represent results of computations, just like in those examples in Schönfinkel’s original paper.</p> \n<p>One important feature of Schönfinkel’s setup is the idea that one doesn’t just have “functions” like <em>f</em>[<em>x</em>], or even just nested functions, like <em>f</em>[<em>g</em>[<em>x</em>]]. Instead one can have constructs where instead of the “name of a function” (like <em>f</em>) one can have a whole complex symbolic structure. And while this was certainly possible in SMP, not too much was built around it. But when I came to <a href=\"https://writings.stephenwolfram.com/2016/04/my-life-in-technology-as-told-at-the-computer-history-museum/\">start designing what’s now the Wolfram Language</a> in 1986, I made sure that the “head” (as I called it) of an expression could itself be an arbitrary expression.</p> \n<p>And when Mathematica was <a href=\"https://www.wolframalpha.com/input/?i=June+23%2C+1988\">first launched in 1988</a> I was charmed to see more than one person from mathematical logic immediately think of implementing combinators. Make the definitions: </p> \n<table class=\"InCell\"> \n <tbody> \n  <tr> \n   <td colspan=\"1\" rowspan=\"1\" class=\"Input\"> \n    <div> \n     <img class=\"\" src=\"https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img6.png\" alt=\"s[x_][y_][z_] := x[z][y[z]]\" width=\"207\" height=\"21\" /> \n    </div> \n    <div class=\"IFL\"> \n     <span class=\"close\" id=\"6_out\">&amp;#10005</span> \n     <pre class=\"text\" id=\"6_out_text\">Clear[s,k];\n\t\t\t\t\ts[x_][y_][z_] := x[z][y[z]]</pre> \n    </div> </td> \n  </tr> \n </tbody> \n</table> \n<table class=\"InCell\"> \n <tbody> \n  <tr> \n   <td colspan=\"1\" rowspan=\"1\" class=\"Input\"> \n    <div> \n     <img class=\"\" src=\"https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img7.png\" alt=\"k[x_][y_] := x\" width=\"130\" height=\"21\" /> \n    </div> \n    <div class=\"IFL\"> \n     <span class=\"close\" id=\"7_out\">&amp;#10005</span> \n     <pre class=\"text\" id=\"7_out_text\">k[x_][y_] := x</pre> \n    </div> </td> \n  </tr> \n </tbody> \n</table> \n<p>Then combinators “just work” (at least if they reach a fixed point):</p> \n<table class=\"InCell\"> \n <tbody> \n  <tr> \n   <td colspan=\"1\" rowspan=\"1\" class=\"Input\"> \n    <div> \n     <img class=\"\" src=\"https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img8.png\" alt=\"s[s[k[s]][s[k[k]][s[k[s]][k]]]][s[k[s[s[k][k]]]][k]][a][b][c]\" width=\"407\" height=\"51\" /> \n    </div> \n    <div class=\"IFL\"> \n     <span class=\"close\" id=\"8_out\">&amp;#10005</span> \n     <pre class=\"text\" id=\"8_out_text\">s[s[k[s]][s[k[k]][s[k[s]][k]]]][s[k[s[s[k][k]]]][k]][a][b][c]</pre> \n    </div> </td> \n  </tr> \n </tbody> \n</table> \n<p>But what about the idea of “composite symbolic heads”? Already in SMP I’d used them to do simple things like represent derivatives (and in Wolfram Language <tt>f'[x]</tt> is <tt><a href=\"https://reference.wolfram.com/language/ref/Derivative.html\">Derivative</a>[1][f][x]</tt>). But something that’s been interesting to me to see is that as the decades have gone by, more and more gets done with “<a href=\"https://reference.wolfram.com/language/guide/FunctionCompositionAndOperatorForms.html\">composite heads</a>”. Sometimes one thinks of them as some kind of nesting of operations, or nesting of modifiers to a symbolic object. But increasingly they end up being a way to represent “higher-order constructs”—in effect things that produce things that produce things etc. that eventually give a concrete object one wants.</p> \n<p>I don’t think most of us humans are particularly good at following this kind of chain of abstraction, at least without some kind of “guide rails”. And it’s been interesting for me to see over the years how we’ve been able to progressively build up guide rails for longer and longer chains of abstraction. First there were things like <tt><a href=\"https://reference.wolfram.com/language/ref/Function.html\">Function</a></tt>, <tt><a href=\"https://reference.wolfram.com/language/ref/Apply.html\">Apply</a></tt>, <tt><a href=\"https://reference.wolfram.com/language/ref/Map.html\">Map</a></tt>. Then <tt><a href=\"https://reference.wolfram.com/language/ref/Nest.html\">Nest</a></tt>, <tt><a href=\"https://reference.wolfram.com/language/ref/Fold.html\">Fold</a></tt>, <tt><a href=\"https://reference.wolfram.com/language/ref/FixedPoint.html\">FixedPoint</a></tt>, <tt><a href=\"https://reference.wolfram.com/language/ref/MapThread.html\">MapThread</a></tt>. But only quite recently <tt><a href=\"https://reference.wolfram.com/language/ref/NestGraph.html\">NestGraph</a></tt>, <tt><a href=\"https://reference.wolfram.com/language/ref/FoldPair.html\">FoldPair</a></tt>, <tt><a href=\"https://reference.wolfram.com/language/ref/SubsetMap.html\">SubsetMap</a></tt>, etc. Even from the beginning there were direct “head manipulation” functions like <tt><a href=\"https://reference.wolfram.com/language/ref/Operate.html\">Operate</a></tt> and <tt><a href=\"https://reference.wolfram.com/language/ref/Through.html\">Through</a></tt>. But unlike more <a href=\"https://reference.wolfram.com/language/guide/HandlingArraysOfData.html\">“array-like” operations</a> for list manipulation they’ve been slow to catch on.</p> \n<p>In a sense combinators are an ultimate story of “symbolic head manipulation”: everything can get applied to everything before it’s applied to anything. And, yes, it’s very hard to keep track of what’s going on—which is why “named guide rails” are so important, and also why they’re challenging to devise. But it seems as if, as we progressively evolve our understanding, we’re slowly able to get a little further, in effect building towards the kind of structure and power that combinators—in their very non-human-relatable way—first showed us was possible a century ago.</p> \n<h2 id=\"combinators-in-the-computational-universe\">Combinators in the Computational Universe</h2> \n<p>Combinators were invented for a definite purpose: to provide building blocks, as Schönfinkel put it, for logic. It was the same kind of thing with other models of what we now know of as computation. All of them were “constructed for a purpose”. But in the end computation—and programs—are abstract things, that can in principle be studied without reference to any particular purpose. One might have some particular reason to be looking at how fast programs of some kind can run, or what can be proved about them. But what about the analog of pure natural science: of studying what programs just “naturally do”?</p> \n<p><a href=\"https://www.wolframscience.com/nks/p17--the-personal-story-of-the-science-in-this-book/\">At the beginning of the 1980s I got very interested</a> in what one can think of as the “natural science of programs”. My interest originally arose out of a question about ordinary natural science. One of the very noticeable features of the natural world is how much in it seems to us highly complex. But where does this complexity really come from? Through what kind of mechanism does nature produce it? I quickly realized that in trying to address that question, I needed as general a foundation for making models of things as possible. And for that I turned to programs, and began to study just what “programs in the wild” might do.</p> \n<p>Ever since the time of <a href=\"https://www.wolframalpha.com/input/?i=galileo\">Galileo</a> and <a href=\"https://www.wolframalpha.com/input/?i=isaac+newton\">Newton</a> mathematical equations had been the main way that people ultimately imagined making models of nature. And on the face of it—with their real numbers and continuous character—these seemed quite different from the usual setup for computation, with its discrete elements and discrete choices. But perhaps in part through my own experience in doing mathematics symbolically on computers, I didn’t see a real conflict, and I began to think of programs as a kind of generalization of the traditional approach to modeling in science.</p> \n<p>But what kind of programs might nature use? I decided to just start exploring all the possibilities: the whole “computational universe” of programs—starting with the simplest. I came up with a particularly simple setup involving a row of cells with values 0 or 1 updated in parallel based on the values of their neighbors. I soon learned that systems like this had actually been <a href=\"https://www.wolframscience.com/nks/notes-2-3--history-of-cellular-automata/\">studied under the name “cellular automata”</a> in the 1950s (particularly in 2D) as potential models of computation, though had fallen out of favor mainly through not having seemed very “human programmable”. </p> \n<p>My initial assumption was that with simple programs I’d only see simple behavior. But with my cellular automata it was very easy to do actual computer experiments, and to visualize the results. And though in many cases what I saw was simple behavior, I also saw something very surprising: that in some cases—<a href=\"https://www.wolframscience.com/nks/p23--how-do-simple-programs-behave/\">even though the rules were very simple</a>—the <a href=\"https://www.wolframscience.com/nks/p27--how-do-simple-programs-behave/\">behavior that was generated could be immensely complex:</a> </p> \n<table class=\"InCell\"> \n <tbody> \n  <tr> \n   <td colspan=\"1\" rowspan=\"1\" class=\"Input\"> \n    <div> \n     <img class=\"\" src=\"https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img91.png\" alt=\"GraphicsRow\" width=\"586\" height=\"138\" /> \n    </div> \n    <div class=\"IFL\"> \n     <span class=\"close\" id=\"9_out\">&amp;#10005</span> \n     <pre class=\"text\" id=\"9_out_text\">GraphicsRow[\n Labeled[ArrayPlot[CellularAutomaton[#, {{1}, 0}, {80, All}]], \n    RulePlot[CellularAutomaton[#]]] &amp; /@ {150, 30, 73}, \n ImageSize -&gt; {Full, Automatic}, Spacings -&gt; 0]</pre> \n    </div> </td> \n  </tr> \n </tbody> \n</table> \n<p>It took me years to come to terms with this phenomenon, and it’s gradually informed the way I think about science, computation and many other things. At first I studied it almost exclusively in cellular automata. I made connections to actual systems in nature that cellular automata could model. I tried to understand what existing mathematical and other methods could say about what I’d seen. And slowly I began to formulate general ideas to explain what was going on—like computational irreducibility and the <a href=\"https://www.wolframscience.com/nks/chap-12--the-principle-of-computational-equivalence/\">Principle of Computational Equivalence</a>.</p> \n<p>But at the beginning of the 1990s—now armed with what would become the Wolfram Language—I decided I should try to see just how the phenomenon I had found in cellular automata would play it in other kinds of computational systems. And <a href=\"https://writings.stephenwolfram.com/2019/02/seeking-the-productive-life-some-details-of-my-personal-infrastructure/\">my archives</a> record that on April 4, 1992, I started looking at combinators.</p> \n<p>I seem to have come back to them several times, but in a notebook from July 10, 1994 (which, yes, still runs just fine), there it is:</p> \n<p><img src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/023-july-10-1994-notebook.png\" alt=\"Mathematica notebook from July 10, 1994\" title=\"Mathematica notebook from July 10, 1994\" width=\"496\" height=\"483\" /></p> \n<p>A randomly chosen combinator made of Schönfinkel’s <em>S</em>’s and <em>K</em>’s starting to show complex behavior. I seem to have a lot of notebooks that start with the simple combinator definitions—and then start exploring:</p> \n<p><img src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/024-sk-1-simple-combinator-exploration.png\" alt=\"Starting with the simple combinator definitions—and exploring\" title=\"Starting with the simple combinator definitions—and exploring\" width=\"620\" height=\"278\" /></p> \n<p>There are what seem like they could be pages from a “computational naturalist’s field notebook”:</p> \n<p><img src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/025-computational-naturalist-field-notebook.png\" alt=\"Pages from a “computational naturalist’s field notebook”\" title=\"Pages from a “computational naturalist’s field notebook”\" width=\"435\" height=\"382\" /></p> \n<p>Then there are attempts to visualize combinators in the same kind of way as cellular automata:</p> \n<p><img src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/026-combinators-visualized-ca.png\" alt=\"ttempts to visualize combinators in the same kind of way as cellular automata\" title=\"Attempts to visualize combinators in the same kind of way as cellular automata\" width=\"442\" height=\"322\" /></p> \n<p>But the end result was that, yes, like Turing machines, string substitution systems and all the other systems I explored in the computational universe, combinators did exactly the same kinds of things I’d originally discovered in cellular automata. Combinators weren’t just systems that could be set up to do things. Even “in the wild” they could spontaneously do very interesting and complex things.</p> \n<p>I included <a href=\"https://www.wolframscience.com/nks/p102--symbolic-systems/\">a few pages</a> on what I called “symbolic systems” (essentially lambdas) at the end of my chapter on “<a href=\"https://www.wolframscience.com/nks/chap-3--the-world-of-simple-programs/\">The World of Simple Programs</a>” in <em>A New Kind of Science</em> (and, yes, reading particularly <a href=\"https://www.wolframscience.com/nks/sect-3-10--symbolic-systems--notes/\">the notes</a> again now, I realize there are still many more things to explore...):</p> \n<p><a class=\"magnific image\" alt=\"“Symbolic systems” in A New Kind of Science\" title=\"“Symbolic systems” in A New Kind of Science\" href=\"https://writings.stephenwolfram.com/data/uploads/2020/12/022-nks-grid.png\"><img alt=\"“Symbolic systems” in A New Kind of Science—click to enlarge\" title=\"“Symbolic systems” in A New Kind of Science—click to enlarge\" src=\"https://writings.stephenwolfram.com/data/uploads/2020/12/022-nks-grid.png\" width=\"604\" height=\"465\" /></a></p> \n<p><a href=\"https://www.wolframscience.com/nks/p711--universality-in-turing-machines-and-other-systems/\">Later in the book I talk specifically</a> about Schönfinkel’s combinators in connection with the threshold of computation universality. But before showing examples of what they do, I remark: </p> \n<blockquote>\n <p>“Originally intended as an idealized way to represent structures of functions defined in logic, combinators were actually first introduced in 1920—sixteen years before Turing machines. But although they have been investigated somewhat over the past eighty years, they have for the most part been viewed as rather obscure and irrelevant constructs”</p>\n</blockquote> \n<p>How “irrelevant” should they be seen as being? Of course it depends on what for. As things to explore in the computational universe, cellular automata have the great advantage of allowing immediate visualization. With combinators it’s a challenge to find any way to translate their behavior at all faithfully into something suitable for human perception. And since the Principle of Computational Equivalence implies that general computational features won’t depend on the particulars of different systems, there’s a tendency to feel that even in studying the computational universe, combinators “aren’t worth the trouble”.</p> \n<p>Still, one thing that’s been prominently on display with cellular automata over the past 20 or so years is the idea that any sufficiently simple system will eventually end up being a <a href=\"https://www.wolframscience.com/nks/chap-8--implications-for-everyday-systems/\">useful model for something</a>. Mollusc pigmentation. Catalysis processes. Road traffic flow. There are simple cellular automaton models for all of these. What about combinators? Without good visualization it’s harder to say “that looks like combinator behavior”. And even after 100 years they’re still a bit too unfamiliar. But when it comes to capturing some large-scale expression or tree behavior of some system, I won’t be surprised if combinators are a good fit.</p> \n<p>When one looks at the computational universe, one of the important ideas is “mining” it not just for programs that can serve as models for things, but also for programs that are somehow useful for some technological purpose. Yes, one can imagine specifically “compiling” some known program to combinators. But the question is whether “naturally occurring combinators” can somehow be identified as useful for some particular purpose. Could they deliver some new kind of distributed cryptographic protocol? Could they be helpful in mapping out distributed computing systems? Could they serve as a base for setting up molecular-scale computation, say with tree-like molecules? I don’t know. But it will be interesting to find out. And as combinators enter their second century they provide a unique kind of “computational raw material” to mine from the computational universe.</p> \n<h2 id=\"combinators-all-the-way-down\">Combinators All the Way Down?</h2> \n<p>What is the universe fundamentally made of? For a long time the assumption was that it must be described by something fundamentally mathematical. And indeed right around the time combinators were being invented the two great theories of general relativity and quantum mechanics were just developing. And in fact it seemed as if both physics and mathematics were going so well that people like <a href=\"https://writings.stephenwolfram.com/2020/12/where-did-combinators-come-from-hunting-the-story-of-moses-schonfinkel/#gottingen-center-of-the-mathematical-universe\">David Hilbert imagined</a> that perhaps both might be completely solved—and that there might be a mathematics-like axiomatic basis for physics that could be “mechanically explored” as he imagined mathematics could be.</p> \n<p>But it didn’t work out that way. <a href=\"https://www.wolframscience.com/nks/notes-12-9--godels-theorem/\">Gödel’s theorem</a> appeared to shatter the idea of a “complete mechanical exploration” of mathematics. And while there was immense technical progress in working out the consequences of general relativity and quantum mechanics little was discovered about what might lie underneath. Computers (including things like <a href=\"https://www.wolfram.com/mathematica/\">Mathematica</a>) were certainly useful in exploring the existing theories of physics. But physics didn’t show any particular signs of being “fundamentally computational”, and indeed the existing theories seemed structurally not terribly compatible with computational processes.</p> \n<p>But as I explored the computational universe and saw just what rich and complex behavior could arise even from very simple rules, <a href=\"https://writings.stephenwolfram.com/2020/04/how-we-got-here-the-backstory-of-the-wolfram-physics-project/\">I began to wonder whether maybe</a>, far below the level of existing physics, the universe might be fundamentally computational. I began to <a href=\"https://www.wolframscience.com/nks/chap-9--fundamental-physics/\">make specific models</a> in which space and time were formed from an evolving network of discrete points. And I realized that some of the <a href=\"https://www.wolframscience.com/nks/p497--the-sequencing-of-events-in-the-universe/\">ideas that had arisen</a> in the study of things like combinators and lambda calculus from the 1930s and 1940s might have direct relevance.</p> \n<p>Like combinators (or lambda calculus) my models had the feature that they allowed many possible paths of evolution. And like combinators (or lambda calculus) at least some of my models had the remarkable feature that in some sense it didn’t matter what path one took; the final result would always be the same. For combinators this “Church–Rosser” or “confluence” feature was what allowed one to have a definite fixed point that could be considered the result of a computation. In my models of the universe that doesn’t just stop—things are a bit more subtle—but the generalization to what I call causal invariance is precisely what leads to relativistic invariance and the validity of general relativity.</p> \n<p>For many years my work on fundamental physics languished—a victim of other priorities and the uphill effort of introducing new paradigms into a well-established field. But just over a year ago—<a href=\"https://writings.stephenwolfram.com/2020/04/how-we-got-here-the-backstory-of-the-wolfram-physics-project/#two-young-physicists-and-a-little-idea\">with help from two very talented young physicists</a>—I started again, <a href=\"https://writings.stephenwolfram.com/2020/04/finally-we-may-have-a-path-to-the-fundamental-theory-of-physics-and-its-beautiful/\">with unexpectedly spectacular results</a>. </p> \n<p>I had never been quite satisfied with my idea of everything in the universe being represented as a particular kind of giant graph. But now I imagined that perhaps it was more like a giant symbolic expression, or, specifically, like an expression consisting of a huge collection of relations between elements—in effect, a certain kind of giant hypergraph. It was, in a way, a very combinator-like concept.</p> \n<p>At a <a href=\"https://writings.stephenwolfram.com/2020/12/combinators-a-centennial-view/#causal-graphs-and-the-physicalization-of-combinators\">technical level, it’s not the same as a general combinator expression</a>: it’s basically just a single layer, not a tree. And in fact that’s what seems to allow the physical universe to consist of something that approximates uniform (manifold-like) space, rather than showing some kind of hierarchical tree-like structure everywhere.</p> \n<p>But when it comes to the progression of the universe through time, it’s basically just like the transformation of combinator expressions. And what’s become clear is that the existence of different paths—and their ultimate equivalences—is exactly what’s responsible not only for the phenomena of relativity, but also for quantum mechanics. And what’s remarkable is that many of the concepts that were first discovered in the context of combinators and lambda calculus now directly inform the theory of physics. Normal forms (basically fixed points) are related to <a href=\"https://www.wolframphysics.org/bulletins/2020/05/event-horizons-singularities-and-other-exotic-spacetime-phenomena/\">black holes where “time stops”</a>. Critical pair lemmas are related to measurement in quantum mechanics. And so on.</p> \n<p>In practical computing, and in the creation of computational language, it was the addition of “meaningful names” to the raw structure of combinators that turned them into the powerful symbolic expressions we use. But in understanding the “data structure of the universe” we’re in a sense going back to something much more like “raw combinators”. Because now all those “atoms of space” that make up the universe don’t have meaningful names; they’re more like <em>S</em>’s and <em>K</em>’s in a giant combinator expression, distinct but yet all the same.</p> \n<p>In the traditional, mathematical view of physics, there was always some sense that by “appropriately clever mathematics” it would be possible to “figure out what will happen” in any physical system. But once one imagines that physics is fundamentally computational, that’s not what one can expect.</p> \n<p>And just like combinators—with their capability for universal computation—can’t in a sense be “cracked” using mathematics, so also that’ll be true of the universe. And indeed in our model that’s what the progress of time is about: it’s the inexorable, irreducible process of computation, associated with the repeated transformation of the symbolic expression that represents the universe. </p> \n<p>When Hilbert first imagined that physics could be reduced to mathematics he probably thought that meant that physics could be “solved”. But with Gödel’s theorem—which is a reflection of universal computation—it became clear that mathematics itself couldn’t just be “solved”. But now in effect we have a theory that “reduces physics to mathematics”, and the result of the Gödel’s theorem phenomenon is something very important in our universe: it’s what leads to a meaningful notion of time.</p> \n<p>Moses Schönfinkel imagined that with combinators he was finding “building blocks for logic”. And perhaps the very simplicity of what he came up with makes it almost inevitable that it wasn’t just about logic: it was something much more general. Something that can represent computations. Something that has the germ of how we can represent the “machine code” of the physical universe.</p> \n<p>It took in a sense “humanizing” combinators to make them useful for things like computational language whose very purpose is to connect with humans. But there are other places where inevitably we’re dealing with something more like large-scale “combinators in the raw”. Physics is one of them. But there are others. In distributed computing. And perhaps in biology, in economics and in other places. </p> \n<p>There are specific issues of whether one’s dealing with trees (like combinators), or hypergraphs (like our model of physics), or something else. But what’s important is that many of the ideas—particularly around what we call <a href=\"https://www.wolframscience.com/nks/p204--multiway-systems/\">multiway systems</a>—show up with combinators. And yes, combinators often aren’t the easiest places for us humans to understand the ideas in. But the remarkable fact is that they exist in combinators—and that combinators are now a century old.</p> \n<p>I’m not sure if there’ll ever be a significant area where combinators alone will be the dominant force. But combinators have—for a century—had the essence of many important ideas. Maybe as such they are at some level destined forever to be footnotes. But in sense they are also seeds or roots—from which remarkable things have grown. And as <a href=\"https://writings.stephenwolfram.com/2020/12/combinators-a-centennial-view/\">combinators enter their second century</a> it seems quite certain that there is still much more that will grow from them.</p>","descriptionType":"html","publishedDate":"Mon, 07 Dec 2020 16:35:08 +0000","feedId":2198,"bgimg":"","linkMd5":"38c6a5708d16a269902d782d4d2544f3","bgimgJsdelivr":"","metaImg":"","author":"Stephen Wolfram","articleImgCdnMap":{"https://writings.stephenwolfram.com/data/uploads/2020/12/combinators-significance-1.1.png":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn96@2020_5/2020/12/11/08-54-11-556_6704142e1a62bac7.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/001-concept-script-a-left.png":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn15@2020_6/2020/12/11/08-54-12-378_27b502a9d6932117.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/001-concept-script-b-right.png":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn80@2020_5/2020/12/11/08-54-10-866_e2235f012cf70c24.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/002-forumlario-mathematico-peano-120.png":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn16@2020_2/2020/12/11/08-54-10-748_b053d4a95c5f020d.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/002-forumlario-mathematico-peano-127.png":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn23@2020_1/2020/12/11/08-54-13-164_5812c13ff11999e6.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/002-principia-mathematica-whitehead-russell-spread.png":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn44@2020_5/2020/12/11/08-54-11-017_9354bceb0e7c259f.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/002-single-connective-nand-stroke.png":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn51@2020_4/2020/12/11/08-54-11-448_f27918d22bbbfcac.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/003-very-generally-natured-sequence-of-particular-functions.png":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn55@2020_5/2020/12/11/08-54-11-711_2a9d0db6b9497ced.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/004-the-s-combinator-fusion-function.png":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn35@2020_4/2020/12/11/08-54-10-833_ca562f36aed8d506.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/005-five-basic-objects-further-part-a.png":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn63@2020_6/2020/12/11/08-54-10-799_32e07b77fa8f501a.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/005-five-basic-objects-further-part-b.png":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn68@2020_5/2020/12/11/08-54-11-698_898529a673c99019.webp","https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img3.png":null,"https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img4.png":null,"https://writings.stephenwolfram.com/data/uploads/2020/12/006-kind-of-quantified-nand.png":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn36@2020_4/2020/12/11/08-54-10-916_ffcc0b9a48203644.webp","https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img5.png":null,"https://writings.stephenwolfram.com/data/uploads/2020/12/007-incompatibility-function-a.png":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn43@2020_2/2020/12/11/08-54-11-937_fab9dbc31018d6e2.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/007-incompatibility-function-b.png":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn59@2020_3/2020/12/11/08-54-10-949_d8aaa7d63634ade4.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/008-reduced-everything-to-scu.png":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn99@2020_4/2020/12/11/08-54-10-836_a94891831b974b51.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/009-godel-arbitrary-expressions-general-recursion-a-left.png":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn11@2020_5/2020/12/11/08-54-12-194_946b0c36cebcb392.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/009-godel-arbitrary-expressions-general-recursion-b-right.png":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn72@2020_4/2020/12/11/08-54-10-772_1e1381eaa637dd85.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/010-church-lambda-calculus-original.png":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn67@2020_4/2020/12/11/08-54-10-729_be698d7d581d0b7a.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/011-church-37-formal-postulates.png":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn32@2020_3/2020/12/11/08-54-11-340_86bf2cc797d43539.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/012-rosser-retool-curry-combinatory-logic.png":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn84@2020_2/2020/12/11/08-54-10-801_b952e28d93554b7e.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/013-church-numerals.png":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn4@2020_4/2020/12/11/08-54-12-467_783d10429a6afad2.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/014-turing-function-k-conversion.png":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn88@2020_5/2020/12/11/08-54-11-505_09c29305ede41f7c.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/015-church-rosser-possible-lambda-orders-b.png":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn7@2020_6/2020/12/11/08-54-11-442_423433b69877284c.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/016-mccarthy-paper-recursive-function.png":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn48@2020_6/2020/12/11/08-54-11-979_d37f1274dfd67914.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/017-mccarthy-combinator-mention.png":null,"https://writings.stephenwolfram.com/data/uploads/2020/12/018-mockingbird-r-smullyan-a-left.png":null,"https://writings.stephenwolfram.com/data/uploads/2020/12/018-mockingbird-r-smullyan-b-right.png":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn95@2020_1/2020/12/11/08-54-10-836_048752bbf3d5271a.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/019-combinatory-logic-curry-a-left.png":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn7@2020_2/2020/12/11/08-54-12-390_c07428e04aa37bf9.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/019-combinatory-logic-curry-b-right.png":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn19@2020_5/2020/12/11/08-54-10-890_fbfab273a6cdda16.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/020-combinator-email.png":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn55@2020_1/2020/12/11/08-54-10-748_c5abfa2b410f7089.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/021-combinator-equation-email.png":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn80@2020_3/2020/12/11/08-54-10-640_c8ea25af45812ea0.webp","https://writings.stephenwolfram.com/data/uploads/2019/08/front-page_420_544@2x1.jpg":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn76@2020_2/2020/12/11/08-54-10-888_49e2d3c010a0f5f0.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/smp-01.png":"https://cdn.jsdelivr.net/gh/myreaderx/cdn100@2020_3/2020/12/11/08-54-12-844_6a7307ec5f11e498.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/smp-02.png":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn88@2020_1/2020/12/11/08-54-11-055_ca1af317850be22c.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/smp-03.png":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn71@2020_6/2020/12/11/08-54-11-775_45b81b0c4021763e.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/smp-04.png":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn48@2020_6/2020/12/11/08-54-10-888_38416357ec222d30.webp","https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img6.png":null,"https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img7.png":null,"https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img8.png":null,"https://writings.internal.stephenwolfram.com/data/uploads/2020/12/sw1206img91.png":null,"https://writings.stephenwolfram.com/data/uploads/2020/12/023-july-10-1994-notebook.png":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn32@2020_6/2020/12/11/08-54-10-703_9b77d1f37c41d849.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/024-sk-1-simple-combinator-exploration.png":null,"https://writings.stephenwolfram.com/data/uploads/2020/12/025-computational-naturalist-field-notebook.png":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn4@2020_5/2020/12/11/08-54-10-806_bbfcc99d3b3691d9.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/026-combinators-visualized-ca.png":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn20@2020_2/2020/12/11/08-54-13-331_6acc6977c858a24b.webp","https://writings.stephenwolfram.com/data/uploads/2020/12/022-nks-grid.png":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn60@2020_6/2020/12/11/08-54-10-950_3fe154848b27a31f.webp"},"publishedOrCreatedDate":1607676009172}],"record":{"createdTime":"2020-12-11 16:40:09","updatedTime":"2020-12-11 16:40:09","feedId":2198,"fetchDate":"Fri, 11 Dec 2020 08:40:09 +0000","fetchMs":642,"handleMs":142,"totalMs":966249,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"d01126ad4678a8e169f9117eff8589f2","hostName":"us-033*","requestId":"7f78dcad1bc546889c225ba63f40290a_2198","contentType":"text/html","totalBytes":2727558,"bgimgsTotal":0,"bgimgsGithubTotal":0,"articlesImgsTotal":48,"articlesImgsGithubTotal":38,"successGithubMap":{"myreaderx8":2,"myreaderx15":2,"myreaderx7":1,"myreaderx6":2,"myreaderx32":2,"myreaderx4":1,"myreaderx10":2,"myreaderx3":1,"myreaderx11":1,"myreaderx33":1,"myreaderx2":2,"myreaderx12":2,"myreaderx13":1,"myreaderx31":2,"myreaderx18":2,"myreaderx19":2,"myreaderx":1,"myreaderx25":2,"myreaderx27":2,"myreaderx21":2,"myreaderx22":1,"myreaderx24":1,"myreaderx5oss":1,"myreaderx29":2},"failGithubMap":{"myreaderx14":2,"myreaderx23":1}},"feed":{"createdTime":"2020-08-24 21:31:37","updatedTime":"2020-09-06 22:44:28","id":2198,"name":"Stephen Wolfram Blog","url":"http://blog.stephenwolfram.com/feed/","subscriber":null,"website":null,"icon":"https://writings.stephenwolfram.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn85@2020_5/2020/09/06/14-44-24-020_af5ff1652ce9083d.ico","description":"Stephen Wolfram's Personal Blog","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2020-12-11 16:56:14","updatedTime":"2020-12-11 16:56:14","id":null,"feedId":2198,"linkMd5":"38c6a5708d16a269902d782d4d2544f3"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":2727558,"tmpBgImgCdnBytes":0,"extra4":{"start":1607676008049,"total":0,"statList":[{"spend":981,"msg":"获取xml内容"},{"spend":142,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":124037,"msg":"正文链接上传到cdn"}]},"extra5":48,"extra6":41,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/017-mccarthy-combinator-mention.png","sourceStatusCode":200,"destWidth":644,"destHeight":272,"sourceBytes":83307,"destBytes":40654,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":548,"convertSpendMs":22,"createdTime":"2020-12-11 16:54:10","host":"us-004*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn64/contents/2020/12/11/08-54-10-716_440f1fcfa34df835.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 11 Dec 2020 08:54:10 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["E698:6301:94084E:147C8C6:5FD333B2"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1607677226"],"x-ratelimit-used":["64"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn64/contents/2020/12/11/08-54-10-716_440f1fcfa34df835.webp","historyStatusCode":[],"spendMs":114},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"81.4 KB","destSize":"39.7 KB","compressRate":"48.8%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/024-sk-1-simple-combinator-exploration.png","sourceStatusCode":200,"destWidth":1240,"destHeight":556,"sourceBytes":201363,"destBytes":144740,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":647,"convertSpendMs":53,"createdTime":"2020-12-11 16:54:10","host":"us-004*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn28/contents/2020/12/11/08-54-10-824_5c97bca898a6fe5d.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 11 Dec 2020 08:54:10 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["E69A:2861:8DA822:147CC9E:5FD333B2"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1607677215"],"x-ratelimit-used":["64"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn28/contents/2020/12/11/08-54-10-824_5c97bca898a6fe5d.webp","historyStatusCode":[],"spendMs":110},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"196.6 KB","destSize":"141.3 KB","compressRate":"71.9%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/017-mccarthy-combinator-mention.png","sourceStatusCode":200,"destWidth":644,"destHeight":272,"sourceBytes":83307,"destBytes":40654,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":391,"convertSpendMs":26,"createdTime":"2020-12-11 16:54:10","host":"us-004*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn64/contents/2020/12/11/08-54-11-187_440f1fcfa34df835.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 11 Dec 2020 08:54:11 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["E698:6301:940874:147C8C9:5FD333B2"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1607677226"],"x-ratelimit-used":["64"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn64/contents/2020/12/11/08-54-11-187_440f1fcfa34df835.webp","historyStatusCode":[],"spendMs":41},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"81.4 KB","destSize":"39.7 KB","compressRate":"48.8%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/024-sk-1-simple-combinator-exploration.png","sourceStatusCode":200,"destWidth":1240,"destHeight":556,"sourceBytes":201363,"destBytes":144740,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":507,"convertSpendMs":60,"createdTime":"2020-12-11 16:54:10","host":"us-004*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn28/contents/2020/12/11/08-54-11-391_5c97bca898a6fe5d.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 11 Dec 2020 08:54:11 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["E698:6301:940887:147C911:5FD333B3"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1607677215"],"x-ratelimit-used":["64"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn28/contents/2020/12/11/08-54-11-391_5c97bca898a6fe5d.webp","historyStatusCode":[],"spendMs":57},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"196.6 KB","destSize":"141.3 KB","compressRate":"71.9%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/018-mockingbird-r-smullyan-a-left.png","sourceStatusCode":200,"destWidth":524,"destHeight":828,"sourceBytes":812878,"destBytes":70708,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":2537,"convertSpendMs":42,"createdTime":"2020-12-11 16:54:10","host":"europe63*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn76/contents/2020/12/11/08-54-12-441_957d022382310bfc.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 11 Dec 2020 08:54:12 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["DBF4:8211:327BFFB:3A39237:5FD333B4"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1607677226"],"x-ratelimit-used":["64"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn76/contents/2020/12/11/08-54-12-441_957d022382310bfc.webp","historyStatusCode":[],"spendMs":495},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"793.8 KB","destSize":"69.1 KB","compressRate":"8.7%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/018-mockingbird-r-smullyan-a-left.png","sourceStatusCode":200,"destWidth":524,"destHeight":828,"sourceBytes":812878,"destBytes":70708,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":655,"convertSpendMs":48,"createdTime":"2020-12-11 16:54:12","host":"us-020*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn76/contents/2020/12/11/08-54-13-589_957d022382310bfc.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 11 Dec 2020 08:54:13 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["C0C4:5F5A:133766B:203F535:5FD333B3"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1607677226"],"x-ratelimit-used":["64"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn76/contents/2020/12/11/08-54-13-589_957d022382310bfc.webp","historyStatusCode":[],"spendMs":45},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"793.8 KB","destSize":"69.1 KB","compressRate":"8.7%"},null,null,null,null,null,null,null,null,null,null,null,null,null,null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-032.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,null]},"http://us-037.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://europe63.herokuapp.com/":{"failCount":2,"successCount":2,"resultList":[200,200,null,null]},"http://us-028.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-024.herokuapp.com/":{"failCount":1,"successCount":3,"resultList":[200,200,200,null]},"http://us-020.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://europe69.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-23.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe21.herokuapp.com/":{"failCount":1,"successCount":2,"resultList":[200,200,null]},"http://us-004.herokuapp.com/":{"failCount":0,"successCount":4,"resultList":[200,200,200,200]},"http://europe-57.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-008.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,null]},"http://us-016.herokuapp.com/":{"failCount":1,"successCount":2,"resultList":[200,200,null]},"http://us-012.herokuapp.com/":{"failCount":1,"successCount":2,"resultList":[200,200,null]},"http://us-55.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-035.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe61.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,null]},"http://us-022.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-006.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,null]},"http://europe-25.herokuapp.com/":{"failCount":1,"successCount":3,"resultList":[200,200,200,null]},"http://us-010.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-59.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,null]},"http://us-51.herokuapp.com/":{"failCount":1,"successCount":2,"resultList":[200,200,null]},"http://europe67.herokuapp.com/":{"failCount":1,"successCount":2,"resultList":[200,200,null]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/021-combinator-equation-email.png","sourceStatusCode":200,"destWidth":660,"destHeight":260,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn80@2020_3/2020/12/11/08-54-10-640_c8ea25af45812ea0.webp","sourceBytes":42475,"destBytes":13116,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1236,"convertSpendMs":10,"createdTime":"2020-12-11 16:54:10","host":"us-51*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"41.5 KB","destSize":"12.8 KB","compressRate":"30.9%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/020-combinator-email.png","sourceStatusCode":200,"destWidth":660,"destHeight":356,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn55@2020_1/2020/12/11/08-54-10-748_c5abfa2b410f7089.webp","sourceBytes":158550,"destBytes":15004,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1365,"convertSpendMs":51,"createdTime":"2020-12-11 16:54:10","host":"us-028*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"154.8 KB","destSize":"14.7 KB","compressRate":"9.5%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/012-rosser-retool-curry-combinatory-logic.png","sourceStatusCode":200,"destWidth":774,"destHeight":314,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn84@2020_2/2020/12/11/08-54-10-801_b952e28d93554b7e.webp","sourceBytes":76601,"destBytes":27498,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1381,"convertSpendMs":117,"createdTime":"2020-12-11 16:54:10","host":"us-028*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"74.8 KB","destSize":"26.9 KB","compressRate":"35.9%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/009-godel-arbitrary-expressions-general-recursion-b-right.png","sourceStatusCode":200,"destWidth":582,"destHeight":914,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn72@2020_4/2020/12/11/08-54-10-772_1e1381eaa637dd85.webp","sourceBytes":167022,"destBytes":64852,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1415,"convertSpendMs":26,"createdTime":"2020-12-11 16:54:10","host":"us-55*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"163.1 KB","destSize":"63.3 KB","compressRate":"38.8%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/002-forumlario-mathematico-peano-120.png","sourceStatusCode":200,"destWidth":432,"destHeight":710,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn16@2020_2/2020/12/11/08-54-10-748_b053d4a95c5f020d.webp","sourceBytes":220664,"destBytes":44588,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1408,"convertSpendMs":24,"createdTime":"2020-12-11 16:54:10","host":"us-51*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"215.5 KB","destSize":"43.5 KB","compressRate":"20.2%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/025-computational-naturalist-field-notebook.png","sourceStatusCode":200,"destWidth":870,"destHeight":764,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn4@2020_5/2020/12/11/08-54-10-806_bbfcc99d3b3691d9.webp","sourceBytes":193193,"destBytes":75696,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1452,"convertSpendMs":70,"createdTime":"2020-12-11 16:54:10","host":"us-012*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"188.7 KB","destSize":"73.9 KB","compressRate":"39.2%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/018-mockingbird-r-smullyan-b-right.png","sourceStatusCode":200,"destWidth":524,"destHeight":828,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn95@2020_1/2020/12/11/08-54-10-836_048752bbf3d5271a.webp","sourceBytes":489787,"destBytes":24332,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1478,"convertSpendMs":53,"createdTime":"2020-12-11 16:54:10","host":"us-037*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"478.3 KB","destSize":"23.8 KB","compressRate":"5%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/010-church-lambda-calculus-original.png","sourceStatusCode":200,"destWidth":582,"destHeight":882,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn67@2020_4/2020/12/11/08-54-10-729_be698d7d581d0b7a.webp","sourceBytes":68573,"destBytes":119068,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1489,"convertSpendMs":53,"createdTime":"2020-12-11 16:54:10","host":"us-012*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"67 KB","destSize":"116.3 KB","compressRate":"173.6%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/005-five-basic-objects-further-part-a.png","sourceStatusCode":200,"destWidth":852,"destHeight":312,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn63@2020_6/2020/12/11/08-54-10-799_32e07b77fa8f501a.webp","sourceBytes":140451,"destBytes":45988,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1511,"convertSpendMs":62,"createdTime":"2020-12-11 16:54:10","host":"us-024*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"137.2 KB","destSize":"44.9 KB","compressRate":"32.7%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/008-reduced-everything-to-scu.png","sourceStatusCode":200,"destWidth":852,"destHeight":438,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn99@2020_4/2020/12/11/08-54-10-836_a94891831b974b51.webp","sourceBytes":214480,"destBytes":66148,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1512,"convertSpendMs":66,"createdTime":"2020-12-11 16:54:10","host":"us-024*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"209.5 KB","destSize":"64.6 KB","compressRate":"30.8%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/019-combinatory-logic-curry-b-right.png","sourceStatusCode":200,"destWidth":542,"destHeight":776,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn19@2020_5/2020/12/11/08-54-10-890_fbfab273a6cdda16.webp","sourceBytes":320151,"destBytes":44482,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1540,"convertSpendMs":73,"createdTime":"2020-12-11 16:54:10","host":"us-028*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"312.6 KB","destSize":"43.4 KB","compressRate":"13.9%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2019/08/front-page_420_544@2x1.jpg","sourceStatusCode":200,"destWidth":840,"destHeight":1088,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn76@2020_2/2020/12/11/08-54-10-888_49e2d3c010a0f5f0.webp","sourceBytes":35116,"destBytes":41366,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1643,"convertSpendMs":72,"createdTime":"2020-12-11 16:54:10","host":"us-032*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"34.3 KB","destSize":"40.4 KB","compressRate":"117.8%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/001-concept-script-b-right.png","sourceStatusCode":200,"destWidth":506,"destHeight":824,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn80@2020_5/2020/12/11/08-54-10-866_e2235f012cf70c24.webp","sourceBytes":429706,"destBytes":34766,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1645,"convertSpendMs":37,"createdTime":"2020-12-11 16:54:10","host":"us-020*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"419.6 KB","destSize":"34 KB","compressRate":"8.1%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/smp-04.png","sourceStatusCode":200,"destWidth":1178,"destHeight":884,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn48@2020_6/2020/12/11/08-54-10-888_38416357ec222d30.webp","sourceBytes":757615,"destBytes":39454,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1642,"convertSpendMs":70,"createdTime":"2020-12-11 16:54:10","host":"us-008*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"739.9 KB","destSize":"38.5 KB","compressRate":"5.2%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/006-kind-of-quantified-nand.png","sourceStatusCode":200,"destWidth":852,"destHeight":674,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn36@2020_4/2020/12/11/08-54-10-916_ffcc0b9a48203644.webp","sourceBytes":232837,"destBytes":86398,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1649,"convertSpendMs":112,"createdTime":"2020-12-11 16:54:10","host":"us-024*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"227.4 KB","destSize":"84.4 KB","compressRate":"37.1%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/004-the-s-combinator-fusion-function.png","sourceStatusCode":200,"destWidth":852,"destHeight":912,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn35@2020_4/2020/12/11/08-54-10-833_ca562f36aed8d506.webp","sourceBytes":201959,"destBytes":114484,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1681,"convertSpendMs":62,"createdTime":"2020-12-11 16:54:10","host":"us-55*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"197.2 KB","destSize":"111.8 KB","compressRate":"56.7%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/023-july-10-1994-notebook.png","sourceStatusCode":200,"destWidth":992,"destHeight":966,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn32@2020_6/2020/12/11/08-54-10-703_9b77d1f37c41d849.webp","sourceBytes":77685,"destBytes":191298,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1716,"convertSpendMs":90,"createdTime":"2020-12-11 16:54:10","host":"us-037*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"75.9 KB","destSize":"186.8 KB","compressRate":"246.2%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/002-principia-mathematica-whitehead-russell-spread.png","sourceStatusCode":200,"destWidth":1014,"destHeight":816,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn44@2020_5/2020/12/11/08-54-11-017_9354bceb0e7c259f.webp","sourceBytes":1088094,"destBytes":91826,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1769,"convertSpendMs":57,"createdTime":"2020-12-11 16:54:10","host":"us-020*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"1 MB","destSize":"89.7 KB","compressRate":"8.4%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/smp-02.png","sourceStatusCode":200,"destWidth":1212,"destHeight":896,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn88@2020_1/2020/12/11/08-54-11-055_ca1af317850be22c.webp","sourceBytes":1141059,"destBytes":56306,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1772,"convertSpendMs":93,"createdTime":"2020-12-11 16:54:10","host":"us-016*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"1.1 MB","destSize":"55 KB","compressRate":"4.9%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/022-nks-grid.png","sourceStatusCode":200,"destWidth":1208,"destHeight":930,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn60@2020_6/2020/12/11/08-54-10-950_3fe154848b27a31f.webp","sourceBytes":456515,"destBytes":125110,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1788,"convertSpendMs":131,"createdTime":"2020-12-11 16:54:10","host":"us-037*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"445.8 KB","destSize":"122.2 KB","compressRate":"27.4%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/007-incompatibility-function-b.png","sourceStatusCode":200,"destWidth":852,"destHeight":1304,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn59@2020_3/2020/12/11/08-54-10-949_d8aaa7d63634ade4.webp","sourceBytes":397812,"destBytes":164058,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1791,"convertSpendMs":116,"createdTime":"2020-12-11 16:54:10","host":"us-016*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"388.5 KB","destSize":"160.2 KB","compressRate":"41.2%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/combinators-significance-1.1.png","sourceStatusCode":200,"destWidth":128,"destHeight":108,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn96@2020_5/2020/12/11/08-54-11-556_6704142e1a62bac7.webp","sourceBytes":13680,"destBytes":5662,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1171,"convertSpendMs":14,"createdTime":"2020-12-11 16:54:11","host":"us-006*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"13.4 KB","destSize":"5.5 KB","compressRate":"41.4%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/015-church-rosser-possible-lambda-orders-b.png","sourceStatusCode":200,"destWidth":810,"destHeight":354,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn7@2020_6/2020/12/11/08-54-11-442_423433b69877284c.webp","sourceBytes":79060,"destBytes":16610,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":2211,"convertSpendMs":16,"createdTime":"2020-12-11 16:54:10","host":"europe-25*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"77.2 KB","destSize":"16.2 KB","compressRate":"21%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/002-single-connective-nand-stroke.png","sourceStatusCode":200,"destWidth":852,"destHeight":338,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn51@2020_4/2020/12/11/08-54-11-448_f27918d22bbbfcac.webp","sourceBytes":89120,"destBytes":34496,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":2272,"convertSpendMs":26,"createdTime":"2020-12-11 16:54:10","host":"europe21*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"87 KB","destSize":"33.7 KB","compressRate":"38.7%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/011-church-37-formal-postulates.png","sourceStatusCode":200,"destWidth":582,"destHeight":882,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn32@2020_3/2020/12/11/08-54-11-340_86bf2cc797d43539.webp","sourceBytes":36308,"destBytes":61476,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":2481,"convertSpendMs":20,"createdTime":"2020-12-11 16:54:10","host":"europe67*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"35.5 KB","destSize":"60 KB","compressRate":"169.3%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/014-turing-function-k-conversion.png","sourceStatusCode":200,"destWidth":690,"destHeight":816,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn88@2020_5/2020/12/11/08-54-11-505_09c29305ede41f7c.webp","sourceBytes":126882,"destBytes":82886,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":2598,"convertSpendMs":30,"createdTime":"2020-12-11 16:54:10","host":"europe21*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"123.9 KB","destSize":"80.9 KB","compressRate":"65.3%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/smp-03.png","sourceStatusCode":200,"destWidth":1240,"destHeight":230,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn71@2020_6/2020/12/11/08-54-11-775_45b81b0c4021763e.webp","sourceBytes":295118,"destBytes":19740,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":2614,"convertSpendMs":17,"createdTime":"2020-12-11 16:54:10","host":"europe-25*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"288.2 KB","destSize":"19.3 KB","compressRate":"6.7%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/009-godel-arbitrary-expressions-general-recursion-a-left.png","sourceStatusCode":200,"destWidth":582,"destHeight":914,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn11@2020_5/2020/12/11/08-54-12-194_946b0c36cebcb392.webp","sourceBytes":185192,"destBytes":75584,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1511,"convertSpendMs":44,"createdTime":"2020-12-11 16:54:11","host":"us-022*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"180.9 KB","destSize":"73.8 KB","compressRate":"40.8%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/005-five-basic-objects-further-part-b.png","sourceStatusCode":200,"destWidth":852,"destHeight":1062,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn68@2020_5/2020/12/11/08-54-11-698_898529a673c99019.webp","sourceBytes":345677,"destBytes":97428,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":2826,"convertSpendMs":75,"createdTime":"2020-12-11 16:54:10","host":"europe67*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"337.6 KB","destSize":"95.1 KB","compressRate":"28.2%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/001-concept-script-a-left.png","sourceStatusCode":200,"destWidth":506,"destHeight":824,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn15@2020_6/2020/12/11/08-54-12-378_27b502a9d6932117.webp","sourceBytes":428658,"destBytes":23464,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1558,"convertSpendMs":81,"createdTime":"2020-12-11 16:54:11","host":"us-010*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"418.6 KB","destSize":"22.9 KB","compressRate":"5.5%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/019-combinatory-logic-curry-a-left.png","sourceStatusCode":200,"destWidth":542,"destHeight":776,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn7@2020_2/2020/12/11/08-54-12-390_c07428e04aa37bf9.webp","sourceBytes":755671,"destBytes":35454,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1588,"convertSpendMs":34,"createdTime":"2020-12-11 16:54:11","host":"us-035*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"738 KB","destSize":"34.6 KB","compressRate":"4.7%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/003-very-generally-natured-sequence-of-particular-functions.png","sourceStatusCode":200,"destWidth":852,"destHeight":950,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn55@2020_5/2020/12/11/08-54-11-711_2a9d0db6b9497ced.webp","sourceBytes":324113,"destBytes":142032,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":2955,"convertSpendMs":76,"createdTime":"2020-12-11 16:54:10","host":"europe-59*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"316.5 KB","destSize":"138.7 KB","compressRate":"43.8%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/013-church-numerals.png","sourceStatusCode":200,"destWidth":668,"destHeight":138,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn4@2020_4/2020/12/11/08-54-12-467_783d10429a6afad2.webp","sourceBytes":28609,"destBytes":12012,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":1938,"convertSpendMs":10,"createdTime":"2020-12-11 16:54:11","host":"europe-57*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"27.9 KB","destSize":"11.7 KB","compressRate":"42%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/007-incompatibility-function-a.png","sourceStatusCode":200,"destWidth":852,"destHeight":1304,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn43@2020_2/2020/12/11/08-54-11-937_fab9dbc31018d6e2.webp","sourceBytes":455861,"destBytes":206006,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":3246,"convertSpendMs":77,"createdTime":"2020-12-11 16:54:10","host":"europe-25*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"445.2 KB","destSize":"201.2 KB","compressRate":"45.2%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/016-mccarthy-paper-recursive-function.png","sourceStatusCode":200,"destWidth":1136,"destHeight":1446,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn48@2020_6/2020/12/11/08-54-11-979_d37f1274dfd67914.webp","sourceBytes":499841,"destBytes":225828,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":3241,"convertSpendMs":117,"createdTime":"2020-12-11 16:54:10","host":"europe63*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"488.1 KB","destSize":"220.5 KB","compressRate":"45.2%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/smp-01.png","sourceStatusCode":200,"destWidth":1240,"destHeight":202,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn100@2020_3/2020/12/11/08-54-12-844_6a7307ec5f11e498.webp","sourceBytes":330285,"destBytes":27374,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":2455,"convertSpendMs":20,"createdTime":"2020-12-11 16:54:11","host":"europe69*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"322.5 KB","destSize":"26.7 KB","compressRate":"8.3%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/002-forumlario-mathematico-peano-127.png","sourceStatusCode":200,"destWidth":432,"destHeight":710,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn23@2020_1/2020/12/11/08-54-13-164_5812c13ff11999e6.webp","sourceBytes":240496,"destBytes":46840,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":2624,"convertSpendMs":47,"createdTime":"2020-12-11 16:54:11","host":"europe61*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"234.9 KB","destSize":"45.7 KB","compressRate":"19.5%"},{"code":1,"isDone":false,"source":"https://writings.stephenwolfram.com/data/uploads/2020/12/026-combinators-visualized-ca.png","sourceStatusCode":200,"destWidth":884,"destHeight":644,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn20@2020_2/2020/12/11/08-54-13-331_6acc6977c858a24b.webp","sourceBytes":476335,"destBytes":128828,"targetWebpQuality":75,"feedId":2198,"totalSpendMs":3063,"convertSpendMs":49,"createdTime":"2020-12-11 16:54:11","host":"europe-23*","referer":"https://writings.internal.stephenwolfram.com/?p=27614","linkMd5ListStr":"38c6a5708d16a269902d782d4d2544f3","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"465.2 KB","destSize":"125.8 KB","compressRate":"27%"}],"successGithubMap":{"myreaderx8":2,"myreaderx15":2,"myreaderx7":1,"myreaderx6":2,"myreaderx32":2,"myreaderx4":1,"myreaderx10":2,"myreaderx3":1,"myreaderx11":1,"myreaderx33":1,"myreaderx2":2,"myreaderx12":2,"myreaderx13":1,"myreaderx31":2,"myreaderx18":2,"myreaderx19":2,"myreaderx":1,"myreaderx25":2,"myreaderx27":2,"myreaderx21":2,"myreaderx22":1,"myreaderx24":1,"myreaderx5oss":1,"myreaderx29":2},"failGithubMap":{"myreaderx14":2,"myreaderx23":1}}