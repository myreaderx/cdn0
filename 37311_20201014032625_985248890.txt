{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-14 11:25:19","updatedTime":"2020-10-14 11:25:19","title":"谈谈 Nginx 的 HTTP/2 POST Bug","link":"https://imququ.com/post/nginx-http2-post-bug.html","description":"<p>几个月前，我发现在某些情况下，使用 Safari 无法登录我的博客后台。当时研究了一下，发现这是 Nginx 处理 HTTP/2 POST 请求的一个 Bug。由于随后发布的 Nginx 1.11.0 修复了这个 Bug，我没有再持续关注。直到今天看到 <a href=\"http://v2ex.com/t/300566\">v2ex 这个帖子</a>，我才发现 Nginx <strong>并没有</strong>将修复代码合并到当前稳定版中。所以，<strong>如果你在使用 Nginx 1.9.15~1.10.x 部署 HTTP/2 服务，请务必看完本文</strong>。</p>\n<h3 id=\"bug-\">Bug 复现</h3>\n<p>复现这个 Bug 需要同时满足以下几个条件：</p>\n<ul>\n<li>使用 Nginx 特定版本（1.9.15~1.10.x）部署 HTTP/2 服务；</li>\n<li>使用特定的 HTTP/2 客户端，例如 OSX/iOS Safari、iOS 客户端、OkHttp 等（Chrome 没问题，MS IE/Edge 据说也有问题，但我没测试）；</li>\n<li>只有 POST 场景才有问题（也就是说必须存在 DATA 帧）；</li>\n<li>需要在建立 HTTP/2 连接后立即 POST（例如打开表单页面，再断网重连或重启 Nginx，不刷新页面直接提交）；</li>\n</ul>\n<p>我用 OSX 10.11.6 自带的 Safari 9.1.2 可以稳定复现这个 Bug。触发 Bug 后，Safari 会提示无法连接到服务器。如下图：</p>\n<p><img src=\"https://st.imququ.com/static/uploads/2016/08/nginx-http2-bug.gif\" width=\"631\" alt=\"nginx http/2 post bug\" itemprop=\"image\" height=\"471\"></p>\n<p>如果事先开启了 Nginx 的 debug 日志，可以找到类似这样的记录：</p>\n<pre><code>client sent stream with data before settings were acknowledged while processing HTTP/2 connection\n</code></pre><h3 id=\"-\">产生原因</h3>\n<p>为了减少网络时延，不少 HTTP/2 客户端会在建立 HTTP/2 连接时同时发送其它帧，包括用来 POST 数据的 DATA 帧。而 Nginx 在客户端接受到 SETTINGS 帧之前，一直将初始窗口大小（initial window size）设置为 0。也就是说，客户端收到 SETTINGS 帧之前发送的 DATA 帧，会被 Nginx 以 REFUSED_STREAM 帧拒绝。而部分客户端在收到 REFUSED_STREAM 帧之后，会提示连接失败，而不是发起重试，这就是产生 Bug 的原因。</p>\n<p>那么，Nginx 这个逻辑合理吗，客户端提前发送 DATA 帧符合 HTTP/2 协议规定吗？HTTP/2 协议中的「HTTP/2 Connection Preface」章节有以下描述：</p>\n<blockquote>\n<p>To avoid unnecessary latency, clients are permitted to send additional frames to the server immediately after sending the client connection preface, without waiting to receive the server connection preface. It is important to note, however, that the server connection preface SETTINGS frame might include parameters that necessarily alter how a client is expected to communicate with the server. Upon receiving the SETTINGS frame, the client is expected to honor any parameters established. In some configurations, it is possible for the server to transmit SETTINGS before the client sends additional frames, providing an opportunity to avoid this issue. <a href=\"https://http2.github.io/http2-spec/#ConnectionHeader\">via</a></p>\n</blockquote>\n<p>出于减少时延的目的，HTTP/2 协议允许客户端在发送连接序言（connection preface）之后，立即发送其它帧，无需等待来自服务端的 SETTTINGS 帧。</p>\n<p>而 Nginx 能够正常处理客户端提前发送的其它帧，唯独 DATA 帧不行。因为客户端尚未收到 SETTINGS 帧之前，Nginx 将初始窗口大小设置为 0。</p>\n<p>那么 Nginx 的初始窗口大小应该设置为多少才合理呢？以下这段内容来自于 HTTP/2 协议的「Initial Flow-Control Window Size」章节：</p>\n<blockquote>\n<p>Prior to receiving a SETTINGS frame that sets a value for SETTINGS_INITIAL_WINDOW_SIZE, an endpoint can only use the default initial window size when sending flow-controlled frames. Similarly, the connection flow-control window is set to the default initial window size until a WINDOW_UPDATE frame is received. <a href=\"https://http2.github.io/http2-spec/#InitialWindowSize\">via</a></p>\n</blockquote>\n<p>也就是说 Nginx 应该将默认的初始窗口大小设置为 64KB。</p>\n<h3 id=\"-\">如何解决</h3>\n<p>我猜测 Nginx 这么做是为了减少被攻击的风险，但无论如何这不符合 HTTP/2 协议规定，也造成了特定场景下 POST 请求不可用。<strong>Nginx 在 1.11.0 中解决了这一问题</strong>，并增加了一个配置项：</p>\n<blockquote>\n<p>Syntax:    http2_body_preread_size size; <br>\nDefault:    http2_body_preread_size 64k; <br>\nContext:    http, server <br>\nThis directive appeared in version 1.11.0. <br>\n <br>\nSets the size of the buffer per each request in which the request body may be saved before it is started to be processed. <a href=\"https://nginx.org/en/docs/http/ngx_http_v2_module.html#http2_body_preread_size\">via</a></p>\n</blockquote>\n<p><code>http2_body_preread_size</code> 用来定义 Nginx 在客户端收到 SETTINGS 帧之前可以接受多大的 DATA 帧，默认为 64KB。如果将这个值设置为 0，那就跟之前版本的 Nginx 变得一样。</p>\n<p>需要特别注意的是，<strong>这个 Bug 由 Nginx 1.9.15 引入，而官方表示修复方案不会被移植到当前稳定版中，也就是对于 Nginx 1.9.15~1.10.x，这个问题将始终存在</strong>。对此，Nginx 有如下解释：</p>\n<blockquote>\n<p>We don&#39;t backport features to the stable branch (that&#39;s what we call stable, no enhancements). It receives only critical bug fixes. If you use such new, very complicated and actively developing protocol as HTTP/2 then it&#39;s naturally that you have to stay with the mainline branch.\n<a href=\"https://trac.nginx.org/nginx/ticket/959#comment:25\">via</a></p>\n</blockquote>\n<p>简而言之，Nginx 认为 HTTP/2 功能本身尚未稳定，要部署 HTTP/2 就应该使用 Nginx 主线版，而不是稳定版。从更新日志来看，Nginx 最近几个主线版本也一直在修复与 HTTP/2 有关的问题，印证了这一说法。</p>\n<p>HTTP/2 是一项年轻的技术，也是 HTTP 历史上最大的一次革新。在实践 HTTP/2 过程中，一定要有时刻踩坑的心理准备，更要时刻关注 HTTP/2 协议和实现者的最新动态。对于重要业务，一定要在充分测试和评估之后再推进 HTTP/2。</p>\n<blockquote>\n<p>Update @ 2016.10.21，Nginx 最终还是在 <a href=\"http://nginx.org/en/CHANGES-1.10\">1.10.2</a> 也修复了这个 Bug，使用稳定版的同学可以考虑升级了。感谢 @ZE3kr 的反馈。</p>\n</blockquote>\n<p>本文链接：<a href=\"https://imququ.com/post/nginx-http2-post-bug.html\">https://imququ.com/post/nginx-http2-post-bug.html</a>，<a href=\"https://imququ.com/post/nginx-http2-post-bug.html#comments\" target=\"_blank\">参与讨论</a></p>","descriptionType":"text/html","publishedDate":"Sat, 20 Aug 2016 06:03:03 +0000","feedId":37311,"bgimg":"https://st.imququ.com/static/uploads/2016/08/nginx-http2-bug.gif","linkMd5":"4de8b8633af7e4ea32f98c353dede7e7","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn43@2020_2/2020/10/14/03-26-24-414_ad00a88e9b911a9d.webp","destWidth":631,"destHeight":471,"sourceBytes":76195,"destBytes":44276,"author":"","articleImgCdnMap":{"https://st.imququ.com/static/uploads/2016/08/nginx-http2-bug.gif":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn43@2020_2/2020/10/14/03-26-24-414_ad00a88e9b911a9d.webp"},"publishedOrCreatedDate":1602645919666}],"record":{"createdTime":"2020-10-14 11:25:19","updatedTime":"2020-10-14 11:25:19","feedId":37311,"fetchDate":"Wed, 14 Oct 2020 03:25:19 +0000","fetchMs":5698,"handleMs":50,"totalMs":72155,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"ac7a0c7ef634bc8118941a5bc33d39c6","hostName":"europe-24*","requestId":"a9d09dc1e9a04ba58953c5384b52368f_37311","contentType":"text/xml; charset=utf-8","totalBytes":44276,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":1,"articlesImgsGithubTotal":1,"successGithubMap":{"myreaderx16":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 03:10:30","updatedTime":"2020-09-07 05:25:13","id":37311,"name":"JerryQu 的小站","url":"https://www.imququ.com/rss.html","subscriber":86,"website":null,"icon":"https://imququ.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn4@2020_4/2020/09/06/21-25-12-964_b1fd447bfd3d253e.ico","description":"专注 WEB 端开发，关注 WEB 性能。","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":44276,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1602645913522,"total":0,"statList":[{"spend":6094,"msg":"获取xml内容"},{"spend":50,"msg":"解释文章"},{"spend":0,"msg":"正文链接上传到cdn"},{"spend":1,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"}]},"extra5":1,"extra6":1,"extra7ImgCdnFailResultVector":[null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://st.imququ.com/static/uploads/2016/08/nginx-http2-bug.gif","sourceStatusCode":200,"destWidth":631,"destHeight":471,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn43@2020_2/2020/10/14/03-26-24-414_ad00a88e9b911a9d.webp","sourceBytes":76195,"destBytes":44276,"targetWebpQuality":75,"feedId":37311,"totalSpendMs":5790,"convertSpendMs":463,"createdTime":"2020-10-14 11:26:19","host":"europe64*","referer":"https://imququ.com/post/nginx-http2-post-bug.html","linkMd5ListStr":"4de8b8633af7e4ea32f98c353dede7e7,4de8b8633af7e4ea32f98c353dede7e7","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"43.2 KB","compressRate":"58.1%","sourceSize":"74.4 KB"}],"successGithubMap":{"myreaderx16":1},"failGithubMap":{}}