{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-11-12 14:15:36","updatedTime":"2020-11-12 14:15:36","title":"关于Cosocket的SocketBusy报错","link":"https://blog.huoding.com/?p=795","description":"<p>关于 OpenResty 的 <a href=\"https://github.com/openresty/lua-nginx-module#ngxsockettcp\" target=\"_blank\" rel=\"noopener noreferrer\">cosocket</a>，文档里有如下一段描述：</p>\n<blockquote><p>the cosocket object here is full-duplex, that is, a reader &#8220;light thread&#8221; and a writer &#8220;light thread&#8221; can operate on a single cosocket object simultaneously (both &#8220;light threads&#8221; must belong to the same Lua handler though, see reasons above). But you cannot have two &#8220;light threads&#8221; both reading (or writing or connecting) the same cosocket, otherwise you might get an error like &#8220;socket busy reading&#8221; when calling the methods of the cosocket object.</p></blockquote>\n<p>简单点儿说，cosocket 是全双工的，如果同一个 lua handler 有一个读线程和一个写线程的话，那么它们可以同时操作一个 cosocket 对象，但是如果两个线程一起读或者写一个 cosocket 对象的话，那么会触发「socket busy」错误。</p>\n<p><span id=\"more-795\"></span></p>\n<p>测试需要，我用「nc -l 1111」命令启动了一个 TCP 服务，监听 1111 端口，如果手头没有 linux 环境，不能使用 nc 命令的话，那么你随便用某个网址的 80 端口也是一样的。</p>\n<p>首先让我们编程复现一下「socket busy」错误，代码逻辑很简单，就是让两个线程对同一个 cosocket 一起发出写操作。通过 <a href=\"https://github.com/openresty/resty-cli\" target=\"_blank\" rel=\"noopener noreferrer\">resty</a> 运行如下代码：</p>\n<pre>local sock = ngx.socket.tcp()\nsock:connect(\"127.0.0.1\", 1111) -- shell: nc -l 1111\n\nlocal data = {}\n\nfor i = 1, 1024 do\n    data[i] = \"data\"\nend\n\ndata = table.concat(data) .. \"\\n\"\n\nlocal function test(worker)\n    for i = 1, 9999 do\n        ngx.log(ngx.ERR, worker, \": \", i)\n\n        local _, err = sock:send(data)\n        -- ngx.sleep(0)\n\n        if err then\n            ngx.log(ngx.ERR, worker, \": \", i, \" err: \", err)\n            break\n        end\n    end\nend\n\nlocal a = ngx.thread.spawn(test, \"a\")\nlocal b = ngx.thread.spawn(test, \"b\")\n\nngx.thread.wait(a, b)\n\nngx.thread.kill(a)\nngx.thread.kill(b)\n</pre>\n<p>结果如下，确实出现了错误「socket busy」：</p>\n<div id=\"attachment_797\" style=\"width: 1008px\" class=\"wp-caption alignnone\"><a href=\"https://blog.huoding.com/wp-content/uploads/2020/01/socket1.png\"><img aria-describedby=\"caption-attachment-797\" loading=\"lazy\" class=\"size-full wp-image-797\" src=\"https://blog.huoding.com/wp-content/uploads/2020/01/socket1.png\" alt=\"并发出错\" width=\"998\" height=\"518\" /></a><p id=\"caption-attachment-797\" class=\"wp-caption-text\">并发出错</p></div>\n<p>我在做实验的时候遇到了两个问题需要说明一下：</p>\n<ul>\n<li>问题一：测试数据（本例中 data 为 4k）最好大一点，否则可能无法复现错误。</li>\n<li>问题二：从结果看，线程 a 运行了几百次后，线程 b 才开始运行，也就是说线程 a 得到了 CPU 就不愿意撒手，此时可以通过 ngx.sleep(0) 主动交出 CPU 控制权。</li>\n</ul>\n<p>接下来看看如何解决「socket busy」错误，既然出现「socket busy」错误的原因是多线程一起读或者写同一个 cosocket 对象，那我们只要加一把锁让操作串行就行了，不过需要注意的是，这里不要通过 <a href=\"https://github.com/openresty/lua-resty-lock\" target=\"_blank\" rel=\"noopener noreferrer\">lua-resty-lock</a> 来加锁，而应该通过 <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/semaphore.md\" target=\"_blank\" rel=\"noopener noreferrer\">semaphore</a> 来加锁，这是因为 lua-resty-lock 的控制粒度比较粗，适合请求在多个 worker 时的情况，而 semaphore 的控制粒度比较细，适合请求在单个 worker 时的情况。通过 <a href=\"https://github.com/openresty/resty-cli\" target=\"_blank\" rel=\"noopener noreferrer\">resty</a> 运行如下代码：</p>\n<pre>local semaphore = require \"ngx.semaphore\"\nlocal sema = semaphore.new()\n\nlocal sock = ngx.socket.tcp()\nsock:connect(\"127.0.0.1\", 1111) -- shell: nc -l 1111\n\nlocal data = {}\n\nfor i = 1, 1024 do\n    data[i] = \"data\"\nend\n\ndata = table.concat(data) .. \"\\n\"\n\nlocal function test(worker)\n    for i = 1, 9999 do\n        ngx.log(ngx.ERR, worker, \": \", i)\n\n        local ok, _ = sema:wait(1)\n\n        if not ok then\n            break\n        end\n\n        local _, err = sock:send(data)\n        sema:post()\n\n        if err then\n            ngx.log(ngx.ERR, worker, \": \", i, \" err: \", err)\n            break\n        end\n    end\nend\n\nlocal a = ngx.thread.spawn(test, \"a\")\nlocal b = ngx.thread.spawn(test, \"b\")\n\nsema:post()\n\nngx.thread.wait(a, b)\n\nngx.thread.kill(a)\nngx.thread.kill(b)\n</pre>\n<p>结果如下，你会发现请求完全执行完了，整个过程中没有出错：</p>\n<div id=\"attachment_798\" style=\"width: 1010px\" class=\"wp-caption alignnone\"><a href=\"https://blog.huoding.com/wp-content/uploads/2020/01/socket2.png\"><img aria-describedby=\"caption-attachment-798\" loading=\"lazy\" class=\"size-full wp-image-798\" src=\"https://blog.huoding.com/wp-content/uploads/2020/01/socket2.png\" alt=\"并发未出错\" width=\"1000\" height=\"518\" /></a><p id=\"caption-attachment-798\" class=\"wp-caption-text\">并发未出错</p></div>\n<p>和前一个图相比较，你会发现本图中，线程 a 和线程 b 交错执行，不再需要通过 ngx.sleep(0) 来主动交出 CPU 控制权，这是因为 semo:wait 完成了类似的操作。</p>\n<p>以后使用 OpenResty 的时候，如果多个线程要同时读或者写同一个 cosocket 对象，那么切记要用 semaphore 控制一下，避免出现「socket busy」错误。当然了，最理想的情况是不用引入 semaphore，每个 cosocket 对象都有一个专门的读线程，一个专门的写线程，此时如果读线程需要写操作，可以考虑通过队列把写操作转给写线程去完成，如此一来既避免使用 semaphore，又充分发挥了全双工的效率，爽歪歪。</p>\n","descriptionType":"html","publishedDate":"Wed, 15 Jan 2020 06:06:40 +0000","feedId":35112,"bgimg":"https://blog.huoding.com/wp-content/uploads/2020/01/socket1.png","linkMd5":"c7c3866d35ab3953e9b89f16537d6ebb","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn85@2020_5/2020/11/12/06-15-38-820_74aecf53a728c223.webp","destWidth":998,"destHeight":518,"sourceBytes":89491,"destBytes":33896,"author":"老王","articleImgCdnMap":{"https://blog.huoding.com/wp-content/uploads/2020/01/socket1.png":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn85@2020_5/2020/11/12/06-15-38-820_74aecf53a728c223.webp","https://blog.huoding.com/wp-content/uploads/2020/01/socket2.png":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn90@2020_4/2020/11/12/06-15-48-844_0de2f6c81094f1ac.webp"},"publishedOrCreatedDate":1605161736130}],"record":{"createdTime":"2020-11-12 14:15:36","updatedTime":"2020-11-12 14:15:36","feedId":35112,"fetchDate":"Thu, 12 Nov 2020 06:15:36 +0000","fetchMs":10429,"handleMs":16,"totalMs":26570,"newArticles":0,"totalArticles":20,"status":1,"type":0,"ip":"10453b4ea40236af920fff4f414aa727","hostName":"us-037*","requestId":"5b4ca6cc02c84693979106aa08f56f35_35112","contentType":"application/rss+xml; charset=UTF-8","totalBytes":71744,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":2,"articlesImgsGithubTotal":2,"successGithubMap":{"myreaderx11":1,"myreaderx13":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 03:03:37","updatedTime":"2020-09-07 05:16:15","id":35112,"name":"火丁笔记","url":"https://huoding.com/feed","subscriber":92,"website":null,"icon":"https://blog.huoding.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx63/cdn2@2020_1/2020/09/06/21-16-05-583_06b87c40543d862c.ico","description":"多研究些问题，少谈些主义。","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":33896,"tmpBodyImgCdnBytes":37848,"tmpBgImgCdnBytes":0,"extra4":{"start":1605161723103,"total":0,"statList":[{"spend":13011,"msg":"获取xml内容"},{"spend":16,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":10019,"msg":"正文链接上传到cdn"}]},"extra5":2,"extra6":2,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-003.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://blog.huoding.com/wp-content/uploads/2020/01/socket1.png","sourceStatusCode":200,"destWidth":998,"destHeight":518,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn85@2020_5/2020/11/12/06-15-38-820_74aecf53a728c223.webp","sourceBytes":89491,"destBytes":33896,"targetWebpQuality":75,"feedId":35112,"totalSpendMs":3497,"convertSpendMs":138,"createdTime":"2020-11-12 14:15:36","host":"us-015*","referer":"https://blog.huoding.com/?p=795","linkMd5ListStr":"c7c3866d35ab3953e9b89f16537d6ebb,c7c3866d35ab3953e9b89f16537d6ebb","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"33.1 KB","compressRate":"37.9%","sourceSize":"87.4 KB"},{"code":1,"isDone":false,"source":"https://blog.huoding.com/wp-content/uploads/2020/01/socket2.png","sourceStatusCode":200,"destWidth":1000,"destHeight":518,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn90@2020_4/2020/11/12/06-15-48-844_0de2f6c81094f1ac.webp","sourceBytes":88035,"destBytes":37848,"targetWebpQuality":75,"feedId":35112,"totalSpendMs":9988,"convertSpendMs":34,"createdTime":"2020-11-12 14:15:39","host":"us-003*","referer":"https://blog.huoding.com/?p=795","linkMd5ListStr":"c7c3866d35ab3953e9b89f16537d6ebb","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"37 KB","compressRate":"43%","sourceSize":"86 KB"}],"successGithubMap":{"myreaderx11":1,"myreaderx13":1},"failGithubMap":{}}