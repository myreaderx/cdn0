{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-09-07 04:08:05","updatedTime":"2020-09-07 04:08:05","title":"华为手机刷微博体验更好？技术角度的一些分析和思考","link":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/","description":"<h1 id=\"背景\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1> \n<p>技术群里的小伙伴发了一条微博， <a href=\"https://weibo.com/1808884742/IApbpEVQr\" target=\"_blank\" rel=\"noopener\">https://weibo.com/1808884742/IApbpEVQr</a>， 博主 @王波粒 发现， Mate 30 Pro 有个很特别的现象（建议先去看一下视频） </p> \n<p><img src=\"https://androidperformance.com/images/15979019506115.jpg\" alt=\"\" /></p> \n<p>这个视频描述和底下的猜测都不对，我这边总结一下这个现象： <strong>微博这个 App 在华为的手机上，在主页列表上下滑动的情况下依然可以流畅加载图片，而同一个版本的微博客户端，安装到其他手机上，在主页列表上下滑动的情况下，则必须要等到滑动停止之后才会加载图片</strong> </p> \n<p><strong>这个现象有什么特别呢 ？</strong> </p> \n<ol> \n <li>从技术上讲，滑动列表停止后再加载图片是目前列表滑动优化中一个比较常见的优化项，很多主流 App 也都是这么做的 ，做这种处理主要是因为 <strong>如果在列表滑动的时候，碰到图片视频就加载，那么会加载很多无用的图片&amp;&amp;视频，浪费资源不说，还可能会影响真正用户看到的图片的加载速度</strong> （加载一般都有并行上限和队列，队列里面无效的图片太多，后来的图片就得排队等待）。 这里比较 <strong>特别的就是同一个版本的微博 APK，在华为的机型上与在其他机型上表现不一致，作为一个系统优化工程师，这个还是值得去搞清楚的（大胆猜测是微博针对华为的机型做了优化），那么这个优化的内容是什么？</strong> </li> \n <li>从用户体验的角度来讲，列表滑动的同时加载图片，用户可以更早地看到图片，减少图片占位白图的显示时间，可以提升滑动的体验 </li> \n <li>第三个现象就得认真体验才会感觉到： <strong>华为手机上的微博在松手后的滑动曲线和其他手机上的微博在松手后的滑动曲线是不一样的，华为的微博列表松手后的滑动曲线速度更慢，更柔和，结束的时候也不会太突兀，与系统默认的列表滑动曲线明显不一样</strong> </li> \n</ol> \n<p>上面三个是从现象上来说的，下面就从技术上来验证，从最后的结果来看，华为和微博的合作毫无疑问是很成功的，可以作为一个案例推广到其他头部 App，同时作为 Android 开发者，对华为这种非常细致的体验优化真的是非常敬佩 </p> \n<h2 id=\"背景备注\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#背景备注\" class=\"headerlink\" title=\"背景备注\"></a>背景备注</h2> \n<ol> \n <li><strong>由于 “列表滑动的同时加载图片” 这个功能由微博官方服务器控制，可以随时开启或者关闭，所以文章中所说的 “同一个版本的微博客户端，安装到其他手机上，在主页列表上下滑动的情况下，则必须要等到滑动停止之后才会加载图片” 这个现象在 “列表滑动的同时加载图片” 这个功能开启后，现象就会变成 “主页列表上下滑动的时候就会加载图片”</strong> </li> \n <li><strong>在 2020-6 月左右分析这个问题的时候，“列表滑动的同时加载图片” 这个功能还是关闭的，只有华为手机做了优化才有效果，其他手机是 “滑动停止之后才会加载图片”</strong> </li> \n <li><strong>在 2020-8 月再看这个问题的时候，“列表滑动的同时加载图片” 这个功能在其他手机上已经开启</strong> </li> \n <li><strong>华为的 PerfSDK 还有效果么？答案是有，具体分析可以看下文，因为有了这个 SDK，不仅对微博有好处(减少图片加载个数)，对华为也有好处(提升微博主页列表在华为手机上的滑动体验，即 Fling 曲线优化) ；而粗暴开启 “列表滑动的同时加载图片” 的其他手机，如果性能不足，开启后反而会增加卡顿出现的概率(微博官方应该有性能监控数据可以看到)</strong> </li> \n <li><strong>反编译的微博版本：10.8.1</strong> </li> \n</ol> \n<h2 id=\"结论先行\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#结论先行\" class=\"headerlink\" title=\"结论先行\"></a>结论先行</h2> \n<p><strong>‘’微博这个 App 在华为的手机上，在主页列表上下滑动的情况下依然可以流畅加载图片 ‘’这个现象是因为华为和微博做了联合优化，主要是为了优化微博列表滑动时候的用户体验，其优化点如下</strong> </p> \n<ol> \n <li>华为提供了一个简单的接口打包成 SDK 提供给微博，这个接口可以让微博的列表监听到列表的当前速度（Velocity），在速度高于阈值或者低于阈值的时候，都会及时通知 App </li> \n <li>微博拿到这个速度回调之后，就可以根据列表的滑动速度来决定是否要在滑动过程中加载图片，一旦列表的滑动速度低于设定的阈值，就开启图片加载；一旦列表的滑动速度高于设定的阈值，就关闭图片加载 </li> \n <li>华为检测到这个应用使用了 SDK，就可以将优化过后的滑动曲线应用在这个 App 的列表 Fling 阶段，提升用户体验 </li> \n</ol> \n<p>对细节感兴趣的同学可以继续阅读，有能力的同学看完后可以修改 Framework 相关代码，编译一个 SDK，然后自己写个 Demo 接入 SDK，就可以打通我下面所说的所有内容了，我自己在 AOSP 的代码上实现了一遍，Demo 也可以正常运行，有兴趣可以跟我私下交流 </p> \n<h1 id=\"微博-华为是怎么优化？\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#微博-华为是怎么优化？\" class=\"headerlink\" title=\"微博+华为是怎么优化？\"></a>微博+华为是怎么优化？</h1> \n<h2 id=\"现象分析\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#现象分析\" class=\"headerlink\" title=\"现象分析\"></a>现象分析</h2> \n<p>我们在滑动微博列表的时候，一个滑动操作主要由下面三部分组成 </p> \n<ol> \n <li>手指接触屏幕，上下滑动微博主页列表，但是手指 <strong>没有离开屏幕</strong> ，这个阶段我们称之为阶段一，技术术语为 SCROLL_STATE_TOUCH_SCROLL </li> \n <li>手指上下滑动的时候 <strong>离开屏幕</strong> (必须有一个上滑或者下滑的速度)，微博列表有了一个惯性，根据惯性的方向继续滑动，这个阶段我们称之为阶段二，技术术语为 SCROLL_STATE_FLING </li> \n <li>列表惯性滑动后停止，这 个 阶段我们称之为阶段三 ， 技术术语为 SCROLL_STATE_I DLE </li> \n</ol> \n<p>而华为和微博的优化主要在阶段一和阶段二 </p> \n<h3 id=\"阶段一优化\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#阶段一优化\" class=\"headerlink\" title=\"阶段一优化\"></a>阶段一优化</h3> \n<ol> \n <li>优化前：只要手指不离开屏幕，图片加载功能关闭 </li> \n <li>优化后：只要手指不离开屏幕，列表就不会滑动太快，这时候图片加载功能开启 </li> \n</ol> \n<h3 id=\"阶段二优化\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#阶段二优化\" class=\"headerlink\" title=\"阶段二优化\"></a>阶段二优化</h3> \n<ol> \n <li><strong>滑动图片加载优化</strong> \n  <ol> \n   <li>优化前：只要列表滑动不停止，图片加载功能关闭 </li> \n   <li>优化后：图片加载功能是否开启取决于当前列表滑动的速度 \n    <ol> \n     <li>列表滑动速度太快，这时候图片加载功能关闭 </li> \n     <li>列表滑动速度掉落到一个阈值，图片加载功能开启 </li> \n    </ol></li> \n  </ol></li> \n <li><strong>列表 Fling 曲线优化</strong> \n  <ol> \n   <li>优化前：列表滑动的曲线是默认值，滑动时间比较短，停止的时候比较突兀，不柔和 </li> \n   <li>优化后：列表滑动的曲线是华为经过优化的，滑动时间比较长，停止的时候比较柔，不突兀，比较接近 iPhone 的列表滑动曲线 </li> \n  </ol></li> \n</ol> \n<h2 id=\"技术分析\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#技术分析\" class=\"headerlink\" title=\"技术分析\"></a>技术分析</h2> \n<p>技术分析的代码主要来源于微博 apk 的反编译，微博版本 10.8.1，通过反编译的代码可以看到， <strong>微博主页在初始化的时候，会接入华为提供的 PerfSDK，从而获得监听列表滑动速度的能力</strong> </p> \n<h3 id=\"阶段一优化的技术分析\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#阶段一优化的技术分析\" class=\"headerlink\" title=\"阶段一优化的技术分析\"></a>阶段一优化的技术分析</h3> \n<p>列表的 ScrollStateChange 是标识列表状态的一个回调，微博在 ScrollStateChange 这个回调中会根据当前的状态来决定是否加载图片， 从下面的代码逻辑来看 </p> \n<ol> \n <li>当 <strong>滑动图片加载优化生效</strong> 的时候，如果 State != 2，那么就允许 ImageLoader 加载图片，State 为 2 也就是 SCROLL_STATE_FLING，熟悉列表滑动的同学应该知道，SCROLL_STATE_FLING 就是 <strong>滑动列表的时候手指松手后列表继续滑动的那一段</strong> ，叫 fling，毕竟只有 fling 的时候才有 Velocity，松手后会根据这个值的大小计算滑动曲线和滑动时长 </li> \n <li>当 <strong>滑动图片加载优化不生效</strong> 的时候，就到了常规的列表滑动优化：即列表停止之后才开始加载图片 ：State !=0，0 即 SCROLL_STATE_IDLE </li> \n</ol> \n<p><img src=\"https://androidperformance.com/images/15979019763546.jpg\" alt=\"\" /></p> \n<h3 id=\"阶段二优化的技术分析\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#阶段二优化的技术分析\" class=\"headerlink\" title=\"阶段二优化的技术分析\"></a>阶段二优化的技术分析</h3> \n<p>微博的主页在初始化的时候，会给首页的 ListView 注册一个 HwPerfVelocityCallback，从名字可以看出来，这个回调是监听 Velocity 的，也就是滑动的速度，两个回调： </p> \n<ol> \n <li>HwPerfonVelocityDownToThreshold : 当速度降低到阈值之后，打开 ImageLoader 的图片加载功能 </li> \n <li>HwPerfonVelocityUpToThreshold： 当速度升高到阈值之后，关闭 ImageLoader 的图片加载功能 </li> \n</ol> \n<p>下图为反编译后的源码 </p> \n<p><img src=\"https://androidperformance.com/images/15979019932037.jpg\" alt=\"\" /></p> \n<p>至于滑动曲线，则需要查看华为的 Framework 的代码，由于代码量比较大，这里只贴一下 OverScroller.java 中的 update 方法，具体感兴趣的可以自己去翻一番华为的 Framework 代码<br><img src=\"https://androidperformance.com/images/15979020033894.jpg\" alt=\"\" /></br></p> \n<p>计算 Distance 的代码 </p> \n<p><img src=\"https://androidperformance.com/images/15979020127885.jpg\" alt=\"\" /></p> \n<p>计算 Velocity 的代码 </p> \n<p><img src=\"https://androidperformance.com/images/15979020218054.jpg\" alt=\"\" /></p> \n<p>关于滑动曲线的解释，大家可以看这一篇知乎回答，其中对比了 iOS 和 Android 的滑动曲线的不同 ：<a href=\"https://www.zhihu.com/question/291779390/answer/484881732\" target=\"_blank\" rel=\"noopener\">为什么 iOS 的过渡动画看起来很舒服？</a></p> \n<h2 id=\"其他厂商处理\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#其他厂商处理\" class=\"headerlink\" title=\"其他厂商处理\"></a>其他厂商处理</h2> \n<p>上面图中代码最后一段还有一个判断开关， 如果 boolean a = HwPerfUtil.m14290a 这个返回的是 false，这就是说有可能华为这个优化关闭了，有可能是非华为机器，那么会 <strong>判断 Android 版本号和全局 Feature 开关</strong> </p> \n<p><img src=\"https://androidperformance.com/images/15979020689139.jpg\" alt=\"\" /></p> \n<p>对应的 FeedAbManager 就是一个 Feature 管理器，可以在线开关某些 Feature<br><img src=\"https://androidperformance.com/images/15979020809489.jpg\" alt=\"\" /></br></p> \n<p>而 m52580k 的实现如下 </p> \n<p><img src=\"https://androidperformance.com/images/15979020905125.jpg\" alt=\"\" /></p> \n<p>可以看到这里还受到一个全局的 Feature 配置：feed_scroll_loadimage_enable，这个 Feature 是服务端可以配置的<br><img src=\"https://androidperformance.com/images/15979021040883.jpg\" alt=\"\" /></br></p> \n<p>这里就是处理其他厂商的逻辑 </p> \n<h1 id=\"最后一个问题：滑动点击\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#最后一个问题：滑动点击\" class=\"headerlink\" title=\"最后一个问题：滑动点击\"></a>最后一个问题：滑动点击</h1> \n<p>滑动点击是个什么问题呢？列表在滑动的过程中，如果用户点击列表的某一个 Item，那么根据 Android 的事件分发机制，这时候列表的 Item 并不会被点击到，而是整个列表先收到点击事件，然后 <strong>触发列表滑动停止；列表停止的时候点击 Item 才会触发 Item 的点击</strong> </p> \n<p>上面阶段二的优化中，在优化了滑动曲线之后，列表处于 Fling 状态的时间变长，如果用户想点击去某一个 Item 查看详情，那么需要先点击一下让列表停止，然后再点击一下才能进去，这就是这一节想说的 ：滑动点击问题 </p> \n<p>滑动(Fling 状态)和点击其实是需要一个平衡的，这个平衡需要开发者自己去把控： </p> \n<p>滑动(Fling 状态)的时间越短，列表越容易停下，用户点击列表越容易触发 Item 的点击，但是容易停止带来的问题就是不够柔和。想象你在粗糙的水泥地上滑出去一块石头，这石头没有滑动多久就会停止，不管是扔石头的你还是旁边看你扔石头的我，都不会觉得这有什么美感，但是没得选。这个的 <strong>代表其实就是 Android 原生的 Fling 曲线</strong> </p> \n<p>滑动(Fling 状态)的时间越长，滑动(Fling 状态)的时间越长，列表越不容易停下，用户点击列表越不容易触发 Item 的点击，如果曲线优化的好，给人的感觉就是很柔和，符合物理规律，想象你在光滑的冰面上滑出去一块冰，冰面越滑，冰块滑动的时间就越长，越不容易停下。这其中的极端代表就是 iOS 的 Fling 曲线。说 iOS 极端是因为，iOS 的滑动曲线调的太磨叽了，时间长不说，停的异常慢，很多时候你都需要点击一下列表让他先停止，然后再进行下一步的点击动作。而小米的 MIUI12 对这个也进行了调整，效果要比 iOS 好一些，如果再和三方进行类似华为和微博的合作，体验会更上一层楼 </p> \n<p>滑动点击问题其实也可以通过厂商和 App 合作来解决，比如，当滑动到整个滑动距离的 98%(或者 95%) 之后，用户点击列表不再是让列表停止，而是列表内的 item 响应这个点击。这个思想来源于 Launcher 的代码，Launcher 的每一页在左右滑动的时候，如果滑动还没有停止但是用户比较手速快点击了某个 icon 想启动，那么这时候不会触发 Page 停止，而是直接响应 icon 的点击启动应用操作 </p> \n<h1 id=\"延伸阅读\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#延伸阅读\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h1> \n<h2 id=\"列表滑动图片加载的性能考虑\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#列表滑动图片加载的性能考虑\" class=\"headerlink\" title=\"列表滑动图片加载的性能考虑\"></a>列表滑动图片加载的性能考虑</h2> \n<p>前文有提到这个问题，滑动的时候进行图片加载主要有两个问题： </p> \n<ol> \n <li>如果用户滑动非常快，比如是想找昨天发的某个微博，那么今天发的所有的带图片的微博在用户滑动的时候是没必要加载的，因为用户的目标不是这些图片，而 App 去加载这些图片，而程序员是不会为用户提前加载你未看到的数据，因为加载过多的数据不仅容易发生数据复用、缓存过多、内存溢出等错误，还会对服务器造成不必要的资源请求。 </li> \n <li>如果用户滑动非常快，那么图片加载队列势必有许多无效的资源(对这一刻的用户来说)，而用户真正想看的图片反而排在了加载队列后面，造成加载速度变慢，也会影响用户的体验 </li> \n</ol> \n<p>滑动中加载图片最大的风险其实就是造成卡顿，因为图片加载本身就是一个比较重的操作，而高帧率的手机上，一帧的时间被压缩到很短，任何小的不确定性都有可能造成卡顿 </p> \n<p>所以厂商+应用的这个优化： <strong>快速滑动不加载图片，慢速的时候再加载，然后优化滑动曲线</strong> ，其实对厂商和应用都是非常有益处的 </p> \n<h2 id=\"列表滑动监听背景知识\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#列表滑动监听背景知识\" class=\"headerlink\" title=\"列表滑动监听背景知识\"></a>列表滑动监听背景知识</h2> \n<p>下面的 AbsListView 的 OnScrollListener 里面标注了列表滑动的三个状态 </p> \n<ol> \n <li>滑动停止：SCROLL_STATE_IDLE </li> \n <li>手指在屏幕上滑动：SCROLL_STATE_TOUCH_SCROLL </li> \n <li>手指离开屏幕，列表靠惯性继续滑动：SCROLL_STATE_FLING </li> \n</ol> \n<p>两个回调 </p> \n<ol> \n <li>列表状态变化时的回调 ：onScrollStateChanged </li> \n <li>列表滑动时候的回调：onScroll </li> \n</ol> \n<figure class=\"highlight java\"> \n <table> \n  <tr> \n   <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n   <td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnScrollListener</span> </span>{ </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// The view is not scrolling. Note navigating the list using the trackball counts as being in the idle state since these transitions are not animated. </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> SCROLL_STATE_IDLE = <span class=\"number\">0</span>;      </span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">//The user is scrolling using touch, and their finger is still on the screen </span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> SCROLL_STATE_TOUCH_SCROLL = <span class=\"number\">1</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">//The user had previously been scrolling using touch and had performed a fling. The animation is now coasting to a stop </span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> SCROLL_STATE_FLING = <span class=\"number\">2</span>; </span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// Callback method to be invoked while the list view or grid view is being scrolled. If the view is being scrolled, this method will be called before the next frame of the scroll is rendered. In particular, it will be called before any calls to </span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onScrollStateChanged</span><span class=\"params\">(AbsListView view, <span class=\"keyword\">int</span> scrollState)</span></span>; </span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// Callback method to be invoked when the list or grid has been scrolled. This will be called after the scroll has completed </span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onScroll</span><span class=\"params\">(AbsListView view, <span class=\"keyword\">int</span> firstVisibleItem, <span class=\"keyword\">int</span> visibleItemCount, <span class=\"keyword\">int</span> totalItemCount)</span></span>; </span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n  </tr> \n </table> \n</figure> \n<h2 id=\"列表滑动状态的变化\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#列表滑动状态的变化\" class=\"headerlink\" title=\"列表滑动状态的变化\"></a>列表滑动状态的变化</h2> \n<p>TOUCH_SCROLL、FLING、IDLE 三个状态对应的列表滑动操作如下 </p> \n<ol> \n <li>TOUCH_SCROLL： 手指滑动 List 阶段，但是手指没有离开屏幕，这时候上下滑动都是 TOUCH_SCROLL </li> \n <li>FLING： 手指滑动 List 后抬手到 List 停止的阶段（必须有一个上滑或者下滑的速度，否则不会进入 Fling） </li> \n <li>IDLE：List 停止阶段 </li> \n</ol> \n<p>这三个状态的变化情况如下 </p> \n<ol> \n <li>手指滑动列表，停止后松手：IDLE -&gt; TOUCH_SCROLL -&gt; IDLE </li> \n <li>手指滑动列表，松手后列表继续滑动，然后停止：IDLE -&gt; TOUCH_SCROLL -&gt; FLING -&gt; IDLE </li> \n</ol> \n<h2 id=\"列表的-Fling-曲线计算\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#列表的-Fling-曲线计算\" class=\"headerlink\" title=\"列表的 Fling 曲线计算\"></a>列表的 Fling 曲线计算</h2> \n<p>Fling 触发之后，每一帧都会调用 update 函数来更新 distance 和 mCurrVelocity，所以我们只需要监听 mCurrVelocity 的值，超过一定的阈值，就可以回调给 App </p> \n<p>frameworks/base/core/java/android/widget/OverScroller.java </p> \n<figure class=\"highlight java\"> \n <table> \n  <tr> \n   <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n   <td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">update</span><span class=\"params\">()</span> </span>{ </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> time = AnimationUtils.currentAnimationTimeMillis(); </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentTime = time - mStartTime; </span><br><span class=\"line\">    <span class=\"keyword\">double</span> distance = <span class=\"number\">0.0</span>; </span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (mState) { </span><br><span class=\"line\"> <span class=\"keyword\">case</span> SPLINE: { <span class=\"comment\">// Fling 状态 </span></span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> t = (<span class=\"keyword\">float</span>) currentTime / mSplineDuration; </span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index = (<span class=\"keyword\">int</span>) (NB_SAMPLES * t); </span><br><span class=\"line\"> <span class=\"keyword\">float</span> distanceCoef = <span class=\"number\">1</span>.f; </span><br><span class=\"line\"> <span class=\"keyword\">float</span> velocityCoef = <span class=\"number\">0</span>.f; </span><br><span class=\"line\"> <span class=\"keyword\">if</span> (index &lt; NB_SAMPLES) { </span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> t_inf = (<span class=\"keyword\">float</span>) index / NB_SAMPLES; </span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> t_sup = (<span class=\"keyword\">float</span>) (index + <span class=\"number\">1</span>) / NB_SAMPLES; </span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> d_inf = SPLINE_POSITION[index]; </span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> d_sup = SPLINE_POSITION[index + <span class=\"number\">1</span>]; </span><br><span class=\"line\"> velocityCoef = (d_sup - d_inf) / (t_sup - t_inf); </span><br><span class=\"line\"> distanceCoef = d_inf + (t - t_inf) * velocityCoef; </span><br><span class=\"line\"> } </span><br><span class=\"line\"> distance = distanceCoef * mSplineDistance; </span><br><span class=\"line\"> mCurrVelocity = velocityCoef * mSplineDistance / mSplineDuration * <span class=\"number\">1000.0f</span>; </span><br><span class=\"line\"> <span class=\"keyword\">break</span>; </span><br><span class=\"line\"> } </span><br><span class=\"line\"> <span class=\"keyword\">case</span> BALLISTIC: { <span class=\"comment\">// 列表滑到 底 之后的 拉伸阶段 </span></span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> t = currentTime / <span class=\"number\">1000.0f</span>; </span><br><span class=\"line\"> mCurrVelocity = mVelocity + mDeceleration * t; </span><br><span class=\"line\"> distance = mVelocity * t + mDeceleration * t * t / <span class=\"number\">2.0f</span>; </span><br><span class=\"line\"> <span class=\"keyword\">break</span>; </span><br><span class=\"line\"> } </span><br><span class=\"line\"> <span class=\"keyword\">case</span> CUBIC: { <span class=\"comment\">// 列表滑到底拉伸 之后的 回弹阶段 </span></span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> t = (<span class=\"keyword\">float</span>) (currentTime) / mDuration; </span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> t2 = t * t; </span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> sign = Math.signum(mVelocity); </span><br><span class=\"line\"> distance = sign * mOver * (<span class=\"number\">3.0f</span> * t2 - <span class=\"number\">2.0f</span> * t * t2); </span><br><span class=\"line\"> mCurrVelocity = sign * mOver * <span class=\"number\">6.0f</span> * (- t + t2); </span><br><span class=\"line\"> <span class=\"keyword\">break</span>; </span><br><span class=\"line\"> } </span><br><span class=\"line\"> } </span><br><span class=\"line\"> mCurrentPosition = mStart + (<span class=\"keyword\">int</span>) Math.round(distance); </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; </span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n  </tr> \n </table> \n</figure> \n<h1 id=\"厂商应用联合优化\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#厂商应用联合优化\" class=\"headerlink\" title=\"厂商应用联合优化\"></a>厂商应用联合优化</h1> \n<p>微博这个优化就是厂商和应用之间联合优化的一个案例，应用对用户体验的极致追求，让这种合作在未来会变得更加频繁，像微信、快手、抖音这些… </p> \n<p>下面这个招聘是拼多多的一个 JD，看职位描述是专门对接厂商的优化，也可以看出应用对厂商的合作越来越重视。之前厂商和应用是魔高一尺道高一丈的关系，互相攻防导致最终体验受损的还是用户；而现在这种厂商和应用合作的关系，不仅提升了双方的体验，也会带动 Android 生态圈向好的方面去发展 </p> \n<p><img src=\"https://androidperformance.com/images/15979021330055.jpg\" alt=\"\" /></p> \n<h1 id=\"本文其他地址\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#本文其他地址\" class=\"headerlink\" title=\"本文其他地址\"></a>本文其他地址</h1> \n<p>微信公众号 - <a href=\"https://mp.weixin.qq.com/s/wJKOvU7CqP3vM0TG7rO66g\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/wJKOvU7CqP3vM0TG7rO66g</a><br>知乎专栏（求个赞） - <a href=\"https://zhuanlan.zhihu.com/p/191460094\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/191460094</a></br></p> \n<h1 id=\"关于我-amp-amp-博客\"><a href=\"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#关于我-amp-amp-博客\" class=\"headerlink\" title=\"关于我 &amp;&amp; 博客\"></a>关于我 &amp;&amp; 博客</h1> \n<ol> \n <li><a href=\"https://www.androidperformance.com/about/\" target=\"_blank\" rel=\"noopener\">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li> \n <li><a href=\"https://androidperformance.com/2019/12/01/BlogMap/\">博客内容导航</a></li> \n <li><a href=\"https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/\">优秀博客文章记录 - Android 性能优化必知必会</a></li> \n</ol> \n<p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p> \n<p><img src=\"https://androidperformance.com/images/WechatIMG581.png\" alt=\"微信扫一扫\" /></p>","descriptionType":"html","publishedDate":"Thu, 20 Aug 2020 05:17:26 +0000","feedId":20007,"bgimg":"https://androidperformance.com/images/15979019506115.jpg","linkMd5":"628e98df667defccd25b43c00f4d4d1c","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn4@2020_5/2020/09/06/20-08-06-911_f16cb4cef99b0b62.webp","destWidth":1178,"destHeight":844,"sourceBytes":253249,"destBytes":86486,"author":"","articleImgCdnMap":{"https://androidperformance.com/images/15979019506115.jpg":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn4@2020_5/2020/09/06/20-08-06-911_f16cb4cef99b0b62.webp","https://androidperformance.com/images/15979019763546.jpg":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn7@2020_3/2020/09/06/20-08-09-168_6342919c62431c5c.webp","https://androidperformance.com/images/15979019932037.jpg":"https://cdn.jsdelivr.net/gh/myreaderx/cdn39@2020_3/2020/09/06/20-08-09-158_ebba37ee0700d79f.webp","https://androidperformance.com/images/15979020033894.jpg":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn36@2020_6/2020/09/06/20-08-08-975_95e219003523594e.webp","https://androidperformance.com/images/15979020127885.jpg":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn16@2020_2/2020/09/06/20-08-17-288_09fffc1979d7fa7e.webp","https://androidperformance.com/images/15979020218054.jpg":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn47@2020_6/2020/09/06/20-08-08-981_3946e260e3129d90.webp","https://androidperformance.com/images/15979020689139.jpg":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn12@2020_3/2020/09/06/20-08-25-456_d37fbf4e8da344e0.webp","https://androidperformance.com/images/15979020809489.jpg":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn10@2020_4/2020/09/06/20-08-09-107_7967952761ace71e.webp","https://androidperformance.com/images/15979020905125.jpg":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn13@2020_6/2020/09/06/20-08-08-972_6a4fc49a511a7074.webp","https://androidperformance.com/images/15979021040883.jpg":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn43@2020_1/2020/09/06/20-08-09-336_e555998f6d15cb67.webp","https://androidperformance.com/images/15979021330055.jpg":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn17@2020_3/2020/09/06/20-08-09-074_383f49ad0e26c6f6.webp","https://androidperformance.com/images/WechatIMG581.png":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn28@2020_2/2020/09/06/20-08-09-007_107c8d57a4a8b452.webp"},"publishedOrCreatedDate":1599422885631}],"record":{"createdTime":"2020-09-07 04:08:05","updatedTime":"2020-09-07 04:08:05","feedId":20007,"fetchDate":"Sun, 06 Sep 2020 20:08:05 +0000","fetchMs":504,"handleMs":6173,"totalMs":27833,"newArticles":0,"totalArticles":85,"status":1,"type":0,"ip":"ce1fe846654e0cdaedad8edf35059015","hostName":"us-033*","requestId":"b1cd1d982efe44f2949ee8a6160b8a44_20007","contentType":"application/xml","totalBytes":559724,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":12,"articlesImgsGithubTotal":12,"successGithubMap":{"myreaderx14":1,"myreaderx25":1,"myreaderx15":1,"myreaderx6":1,"myreaderx32":1,"myreaderx4":1,"myreaderx33":1,"myreaderx22":1,"myreaderx2":1,"myreaderx23":1,"myreaderx12":1,"myreaderx":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:21:19","updatedTime":"2020-09-07 02:21:19","id":20007,"name":"Android Performance","url":"http://androidperformance.com/atom.xml","subscriber":166,"website":null,"icon":"https://androidperformance.com/assets/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx61/cdn8@2020_2/2020/09/06/20-08-04-754_6701d3843a82708b.png","description":"闻道有先后,术业有专攻,如是而已","weekly":null,"link":"https://androidperformance.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":86486,"tmpBodyImgCdnBytes":473238,"tmpBgImgCdnBytes":0,"extra4":{"start":1599422878753,"total":0,"statList":[{"spend":710,"msg":"获取xml内容"},{"spend":6173,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":4,"msg":"修正封面图上传失败重新上传"},{"spend":18014,"msg":"正文链接上传到cdn"}]},"extra5":12,"extra6":12,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#其他厂商处理":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#其他厂商处理","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#列表滑动状态的变化":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#列表滑动状态的变化","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#关于我-amp-amp-博客":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#关于我-amp-amp-博客","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#结论先行":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#结论先行","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#延伸阅读":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#延伸阅读","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#阶段一优化的技术分析":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#阶段一优化的技术分析","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#列表滑动监听背景知识":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#列表滑动监听背景知识","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#阶段二优化":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#阶段二优化","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#背景":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#背景","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#最后一个问题：滑动点击":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#最后一个问题：滑动点击","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#背景备注":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#背景备注","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#技术分析":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#技术分析","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#阶段二优化的技术分析":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#阶段二优化的技术分析","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#现象分析":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#现象分析","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#微博-华为是怎么优化？":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#微博-华为是怎么优化？","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#阶段一优化":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#阶段一优化","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#本文其他地址":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#本文其他地址","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#列表的-Fling-曲线计算":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#列表的-Fling-曲线计算","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#列表滑动图片加载的性能考虑":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#列表滑动图片加载的性能考虑","https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/_#厂商应用联合优化":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/#厂商应用联合优化"},"extra111_proxyServerAndStatMap":{"http://us-038.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-037.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-039.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-55.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-036.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-004.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-028.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe67.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-016.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-026.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-027.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://androidperformance.com/images/15979019506115.jpg","sourceStatusCode":200,"destWidth":1178,"destHeight":844,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn4@2020_5/2020/09/06/20-08-06-911_f16cb4cef99b0b62.webp","sourceBytes":253249,"destBytes":86486,"targetWebpQuality":75,"feedId":20007,"totalSpendMs":2363,"convertSpendMs":45,"createdTime":"2020-09-07 04:08:06","host":"europe-59*","referer":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/","linkMd5ListStr":"628e98df667defccd25b43c00f4d4d1c,628e98df667defccd25b43c00f4d4d1c","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"247.3 KB","destSize":"84.5 KB","compressRate":"34.2%"},{"code":1,"isDone":false,"source":"https://androidperformance.com/images/15979020218054.jpg","sourceStatusCode":200,"destWidth":1123,"destHeight":76,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn47@2020_6/2020/09/06/20-08-08-981_3946e260e3129d90.webp","sourceBytes":35427,"destBytes":11608,"targetWebpQuality":75,"feedId":20007,"totalSpendMs":1201,"convertSpendMs":10,"createdTime":"2020-09-07 04:08:08","host":"us-55*","referer":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/","linkMd5ListStr":"628e98df667defccd25b43c00f4d4d1c","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"34.6 KB","destSize":"11.3 KB","compressRate":"32.8%"},{"code":1,"isDone":false,"source":"https://androidperformance.com/images/15979020905125.jpg","sourceStatusCode":200,"destWidth":898,"destHeight":100,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn13@2020_6/2020/09/06/20-08-08-972_6a4fc49a511a7074.webp","sourceBytes":41171,"destBytes":13502,"targetWebpQuality":75,"feedId":20007,"totalSpendMs":1234,"convertSpendMs":7,"createdTime":"2020-09-07 04:08:08","host":"us-037*","referer":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/","linkMd5ListStr":"628e98df667defccd25b43c00f4d4d1c","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"40.2 KB","destSize":"13.2 KB","compressRate":"32.8%"},{"code":1,"isDone":false,"source":"https://androidperformance.com/images/15979020033894.jpg","sourceStatusCode":200,"destWidth":1249,"destHeight":292,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn36@2020_6/2020/09/06/20-08-08-975_95e219003523594e.webp","sourceBytes":121805,"destBytes":38000,"targetWebpQuality":75,"feedId":20007,"totalSpendMs":1322,"convertSpendMs":18,"createdTime":"2020-09-07 04:08:08","host":"us-016*","referer":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/","linkMd5ListStr":"628e98df667defccd25b43c00f4d4d1c","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"119 KB","destSize":"37.1 KB","compressRate":"31.2%"},{"code":1,"isDone":false,"source":"https://androidperformance.com/images/WechatIMG581.png","sourceStatusCode":200,"destWidth":726,"destHeight":218,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn28@2020_2/2020/09/06/20-08-09-007_107c8d57a4a8b452.webp","sourceBytes":51369,"destBytes":16940,"targetWebpQuality":75,"feedId":20007,"totalSpendMs":1313,"convertSpendMs":20,"createdTime":"2020-09-07 04:08:08","host":"us-026*","referer":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/","linkMd5ListStr":"628e98df667defccd25b43c00f4d4d1c","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"50.2 KB","destSize":"16.5 KB","compressRate":"33%"},{"code":1,"isDone":false,"source":"https://androidperformance.com/images/15979021330055.jpg","sourceStatusCode":200,"destWidth":1230,"destHeight":664,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn17@2020_3/2020/09/06/20-08-09-074_383f49ad0e26c6f6.webp","sourceBytes":197254,"destBytes":71226,"targetWebpQuality":75,"feedId":20007,"totalSpendMs":1442,"convertSpendMs":42,"createdTime":"2020-09-07 04:08:08","host":"us-028*","referer":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/","linkMd5ListStr":"628e98df667defccd25b43c00f4d4d1c","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"192.6 KB","destSize":"69.6 KB","compressRate":"36.1%"},{"code":1,"isDone":false,"source":"https://androidperformance.com/images/15979019932037.jpg","sourceStatusCode":200,"destWidth":1105,"destHeight":565,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn39@2020_3/2020/09/06/20-08-09-158_ebba37ee0700d79f.webp","sourceBytes":207817,"destBytes":60476,"targetWebpQuality":75,"feedId":20007,"totalSpendMs":1397,"convertSpendMs":27,"createdTime":"2020-09-07 04:08:08","host":"us-004*","referer":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/","linkMd5ListStr":"628e98df667defccd25b43c00f4d4d1c","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"202.9 KB","destSize":"59.1 KB","compressRate":"29.1%"},{"code":1,"isDone":false,"source":"https://androidperformance.com/images/15979019763546.jpg","sourceStatusCode":200,"destWidth":1174,"destHeight":730,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn7@2020_3/2020/09/06/20-08-09-168_6342919c62431c5c.webp","sourceBytes":193109,"destBytes":68036,"targetWebpQuality":75,"feedId":20007,"totalSpendMs":1489,"convertSpendMs":29,"createdTime":"2020-09-07 04:08:08","host":"us-036*","referer":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/","linkMd5ListStr":"628e98df667defccd25b43c00f4d4d1c","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"188.6 KB","destSize":"66.4 KB","compressRate":"35.2%"},{"code":1,"isDone":false,"source":"https://androidperformance.com/images/15979020809489.jpg","sourceStatusCode":200,"destWidth":896,"destHeight":379,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn10@2020_4/2020/09/06/20-08-09-107_7967952761ace71e.webp","sourceBytes":135665,"destBytes":46250,"targetWebpQuality":75,"feedId":20007,"totalSpendMs":1513,"convertSpendMs":79,"createdTime":"2020-09-07 04:08:08","host":"us-039*","referer":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/","linkMd5ListStr":"628e98df667defccd25b43c00f4d4d1c","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"132.5 KB","destSize":"45.2 KB","compressRate":"34.1%"},{"code":1,"isDone":false,"source":"https://androidperformance.com/images/15979021040883.jpg","sourceStatusCode":200,"destWidth":997,"destHeight":474,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn43@2020_1/2020/09/06/20-08-09-336_e555998f6d15cb67.webp","sourceBytes":167006,"destBytes":48696,"targetWebpQuality":75,"feedId":20007,"totalSpendMs":1832,"convertSpendMs":28,"createdTime":"2020-09-07 04:08:08","host":"europe67*","referer":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/","linkMd5ListStr":"628e98df667defccd25b43c00f4d4d1c","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"163.1 KB","destSize":"47.6 KB","compressRate":"29.2%"},{"code":1,"isDone":false,"source":"https://androidperformance.com/images/15979020127885.jpg","sourceStatusCode":200,"destWidth":1115,"destHeight":253,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn16@2020_2/2020/09/06/20-08-17-288_09fffc1979d7fa7e.webp","sourceBytes":102995,"destBytes":31996,"targetWebpQuality":75,"feedId":20007,"totalSpendMs":1614,"convertSpendMs":21,"createdTime":"2020-09-07 04:08:16","host":"us-027*","referer":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/","linkMd5ListStr":"628e98df667defccd25b43c00f4d4d1c","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"100.6 KB","destSize":"31.2 KB","compressRate":"31.1%"},{"code":1,"isDone":false,"source":"https://androidperformance.com/images/15979020689139.jpg","sourceStatusCode":200,"destWidth":1120,"destHeight":555,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn12@2020_3/2020/09/06/20-08-25-456_d37fbf4e8da344e0.webp","sourceBytes":194262,"destBytes":66508,"targetWebpQuality":75,"feedId":20007,"totalSpendMs":1574,"convertSpendMs":27,"createdTime":"2020-09-07 04:08:24","host":"us-038*","referer":"https://androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/","linkMd5ListStr":"628e98df667defccd25b43c00f4d4d1c","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"189.7 KB","destSize":"64.9 KB","compressRate":"34.2%"}],"successGithubMap":{"myreaderx14":1,"myreaderx25":1,"myreaderx15":1,"myreaderx6":1,"myreaderx32":1,"myreaderx4":1,"myreaderx33":1,"myreaderx22":1,"myreaderx2":1,"myreaderx23":1,"myreaderx12":1,"myreaderx":1},"failGithubMap":{}}