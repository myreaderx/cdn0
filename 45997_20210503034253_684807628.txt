{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2021-05-03 11:42:47","updatedTime":"2021-05-03 11:42:47","title":"多値について本気で考えてみた","link":"https://bleis-tift.hatenablog.com/entry/multiple-values","description":"<p><a href=\"http://bleis-tift.hatenablog.com/entry/go-the-bad-parts\">先日のエントリ</a>の反応として、多値の批判をしているように受け取られた方がいました。 実際には、多値の批判をしているのではなく、Go言語の「多値とそう見えるけど違うものがある」という仕様を批判したものでした。</p> \n<p>また、タプルにこだわっているという受け取り方をした方もいました。 このエントリでは、「タプルにこだわっているのではない、多値にこだわっているのだ」ということを説明しようと思います。 このエントリで出てくるコードは言及がない限り妄想上のもので、実際の言語のコードではありません。</p> \n<p>長いから3行で。</p> \n<ul> \n <li>スタックマシンと多値は仲良し。継続と多値も仲良し。</li> \n <li>多値は多値、タプルはタプル、みんなちがってみんないい。</li> \n <li>多値とは、カンマで区切られた単なる複数の値だよ。妄想だけどね。</li> \n</ul> \n<p>これで満足して仕事に戻っていただいて構いません。以下オマケ。</p> \n<h2>多値とタプルの違い</h2> \n<p>まず、多値とタプルの意味的な違いについてをはっきりさせておきましょう。 ただし、多値はタプルと違って扱える言語が少ない<a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#f-3d7100dc\" name=\"fn-3d7100dc\" title=\"メジャーな言語だとScheme/Common LispとGoくらいではないでしょうか。何をメジャーに入れるかという問題はありますが。※Luaも多値を持っているようです。Twitterで教えてもらいました。※GHC拡張にもUnboxed Tuplesという構文拡張があるようです。これもTwitterで教えてもらいました。\">*1</a>うえ、各言語での違いもそれなりに大きいため、ここで紹介する違いは参考程度に考えてください。</p> \n<h3>他の値の一部になれるかどうか</h3> \n<p>タプルは何の制約もない、単なる値です。 そのため、他の値の一部になれます<a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#f-c88d3592\" name=\"fn-c88d3592\" title=\"クラスのフィールドとして持たせられる。\">*2</a>。 当然、タプルの要素にタプルを入れるという風に、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C6%FE%A4%EC%BB%D2\">入れ子</a>構造も取れます。</p> \n<p>それに対して、多値は他の値の一部にはなれません。 例えば、クラスのフィールドに多値を含むこともできませんし、多値の要素として多値を含むこともできません。 これを、制約の付いた型と見なすこともできますが、単に多値はファーストクラスのオブジェクトではないと考えてもよいでしょう。</p> \n<h3>多値は制限されたタプルなのか</h3> \n<p>ここまででは、多値は制限されたタプルであり、多値には何のメリットもないとしか思えないかもしれません。 しかし、多値には効率という大きなメリットがあるのです。 その話に入る前に、多値と相性のよいものについて見ていきましょう。 スタックマシンと、継続です。</p> \n<h2>スタックマシンと多値</h2> \n<p>まずはスタックマシンです。 スタックマシンというのは、スタックを用いて計算を行う計算機のことを言いますが、ここでは詳細には踏み込みません。 <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%BE%C1%DB%A5%DE%A5%B7%A5%F3\">仮想マシン</a>や、.NETの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLR\">CLR</a>や、RubyVM(旧称<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/YARV\">YARV</a>)などもスタックマシンをベースにしています。少なくとも30億のデ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%B9\">バイス</a>でスタックマシンは動いていることになりますね。すごい。</p> \n<h3>スタックマシンでの関数呼び出し</h3> \n<p>スタックマシンでは、引数をスタックに積んでから関数に処理を移すだけで関数呼び出しができます。 例えば、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a>で次のようなメソッドを書いたとしましょう。</p> \n<pre class=\"code lang-java\" data-lang=\"java\" data-unlink=\"\"><span class=\"synType\">public</span> <span class=\"synType\">static</span> <span class=\"synType\">int</span> add(<span class=\"synType\">int</span> a, <span class=\"synType\">int</span> b) {\n    <span class=\"synStatement\">return</span> a + b;\n}\n</pre> \n<p>このメソッドを <code>add(10, 20)</code> のように呼び出した場合、以下のような<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\">バイトコード</a>が出力されます。</p> \n<pre class=\"code\" data-lang=\"\" data-unlink=\"\">bipush 10           // byte範囲に収まる数値10をpush\nbipush 20           // byte範囲に収まる数値20をpush\ninvokestatic add    // addメソッドを呼び出す</pre> \n<p>これをスタックの状態を含めて図にすると、このような感じになります。</p> \n<pre class=\"code\" data-lang=\"\" data-unlink=\"\">|    | bipush 10 |    | bipush 20 | 20 | invokestatic add |    |\n|    |----------&gt;| 10 |----------&gt;| 10 |-----------------&gt;| 30 |\n+----+           +----+           +----+                  +----+</pre> \n<p>まさに、スタックに引数を積んでから関数が呼び出されています。 そして、結果はスタックに積まれます。</p> \n<p>関数から戻る場合はどうでしょうか。 上で作った <code>add</code> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\">バイトコード</a>を見てみましょう。</p> \n<pre class=\"code\" data-lang=\"\" data-unlink=\"\">iload_0 // 0番目の引数を整数としてpush\niload_1 // 1番目の引数を整数としてpush\niadd    // スタックに積まれた2つの整数を加算、結果をpush\nireturn // スタックに積まれた数値を戻り値としてメソッドからreturn</pre> \n<p><code>add(10, 20)</code> で呼び出された場合のスタックの移り変わりはこのようになります。</p> \n<pre class=\"code\" data-lang=\"\" data-unlink=\"\">|    | iload_0 |    | iload_1 | 20 | iadd |    | ireturn\n|    |--------&gt;| 10 |--------&gt;| 10 |-----&gt;| 30 |--------&gt;\n+----+         +----+         +----+      +----+</pre> \n<h3>スタックマシン上での多値の表現</h3> \n<p>スタックマシンでは、多値はスタック上に積まれた(複数の)値でしかありません。 n個の値を積んで関数を呼び出すということは、n値を入力にする関数を呼び出すということですし、 m個の値を積んだ状態で関数からreturnするということは、m値を出力として関数を終えた、ということです<a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#f-f2b77382\" name=\"fn-f2b77382\" title=\"ただし、上で例に挙げたJava仮想マシン(や、他の仮想マシン)では、m個の値を積んだ状態で関数からreturnすることを許していません。\">*3</a>。</p> \n<p>これはとてもきれいですよね。 例えばGo言語がスタックマシン上で実装されているとしたら、</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\"><span class=\"synStatement\">func</span> add(a <span class=\"synType\">int</span>, b <span class=\"synType\">int</span>) <span class=\"synType\">int</span> {\n    <span class=\"synStatement\">return</span> a + b\n}\n\n<span class=\"synStatement\">func</span> f(a <span class=\"synType\">int</span>) (<span class=\"synType\">int</span>, <span class=\"synType\">int</span>) {\n    <span class=\"synStatement\">return</span> a, a * <span class=\"synConstant\">2</span>\n}\n\nadd(f(<span class=\"synConstant\">3</span>))\n</pre> \n<p>は、</p> \n<pre class=\"code\" data-lang=\"\" data-unlink=\"\">push 3\ncall f      // 3が積まれた状態でfを呼び出す。実行が終わるとスタックに値が2つ積まれている。\ncall add    // 3と6がスタックに積まれた状態でaddを呼び出す。</pre> \n<p>と表現されていることでしょう。</p> \n<h2>継続と多値</h2> \n<p>継続について説明しだすと延々と横道にそれていってしまうので、 <a href=\"http://practical-scheme.net/docs/cont-j.html\">解説ページ</a> へのリンクだけ置いておきます。 未完成部分が埋められることはもはやないと思われます。残念。</p> \n<p>さて、継続と多値の関係ですが、継続とはつまるところ「関数からのreturnを、returnした後の処理を表す関数呼び出し」と考えてしまおう、ということです<a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#f-46c2aa22\" name=\"fn-46c2aa22\" title=\"http://www.kmonos.net/wlog/95.html#_1109090307 という記事を思い出したので置いておきます。この記事では、returnを関数と見なすとどうなるだろう、という思考実験をしています。\">*4</a>。 このとき、「継続に渡される引数が複数個ある」ということの意味を考えてみましょう。 「継続に渡される引数」は、「returnされた値」に対応しますので、これが複数個あるということは「複数の結果が関数から返ってきた」ことを意味します。 つまりは多値です。</p> \n<p>すべてを継続で考えれば、returnはすべて関数の引数になります。 その世界においては、多値とは単に継続(もしくは関数)に渡す引数が複数あるというだけとなります。 これもとてもきれいですね。</p> \n<p>ちょっと無理やりですが、Go言語であればこのようなイメージの世界です。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\"><span class=\"synComment\">// スタックマシン上での多値の表現で使ったプログラムをreturnやGo言語の多値なしに表現してみた例</span>\n<span class=\"synStatement\">func</span> add(a <span class=\"synType\">int</span>, b <span class=\"synType\">int</span>, k <span class=\"synType\">func</span>(<span class=\"synType\">int</span>)) {\n    k(a + b) <span class=\"synComment\">// returnの代わりに継続を呼び出す</span>\n}\n\n<span class=\"synStatement\">func</span> f(a <span class=\"synType\">int</span>, k <span class=\"synType\">func</span>(<span class=\"synType\">int</span>, <span class=\"synType\">int</span>)) {\n    k(a, a * <span class=\"synConstant\">2</span>) <span class=\"synComment\">// returnの代わりに継続を呼び出す(多値！)</span>\n}\n\n<span class=\"synStatement\">func</span> main() {\n    f(<span class=\"synConstant\">3</span>, <span class=\"synType\">func</span>(a <span class=\"synType\">int</span>, b <span class=\"synType\">int</span>) { <span class=\"synComment\">// fは多値を関数の引数として渡してくる</span>\n        add(a, b, <span class=\"synType\">func</span>(x <span class=\"synType\">int</span>) {\n            fmt.Println(x)\n        })\n    })\n}\n</pre> \n<p>returnもGo言語の多値も使っていませんが、やっていることはGo言語の多値を使ったコードと同じです。</p> \n<p>ちなみに、継続を扱える言語である<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a>では、多値を作る関数をこう定義できます。</p> \n<pre class=\"code lang-scheme\" data-lang=\"scheme\" data-unlink=\"\"><span class=\"synSpecial\">(</span><span class=\"synStatement\">define</span> <span class=\"synSpecial\">(</span><span class=\"synIdentifier\">values</span> <span class=\"synSpecial\">.</span> xs<span class=\"synSpecial\">)</span>\n  <span class=\"synSpecial\">(</span><span class=\"synIdentifier\">call/cc</span> <span class=\"synSpecial\">(</span><span class=\"synStatement\">lambda</span> <span class=\"synSpecial\">(</span>k<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">(</span><span class=\"synIdentifier\">apply</span> k xs<span class=\"synSpecial\">))))</span>\n</pre> \n<p><code>call/cc</code> で <code>values</code> 呼び出し以降の処理を切り取って <code>k</code> とし、その継続に <code>values</code> の引数を入れるという、まさに「継続の引数が多値である」をそのまま表したコードになっています。 きれいだ・・・！</p> \n<h2>関数</h2> \n<p>さて、ここまでは多値と相性のよいものを見てきました。 ここからは、関数について少し考えてみます。</p> \n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B4%D8%BF%F4%B7%BF%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0\">関数型プログラミング</a>言語と関数</h3> \n<p>メジャーな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B4%D8%BF%F4%B7%BF%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0\">関数型プログラミング</a>言語では、関数は1入力1出力というモデルです。</p> \n<p>多入力したい場合は「関数を返す関数」のように関数を値として扱えるようにしたことで解決しています(カリー化というやつ)。</p> \n<pre class=\"code lang-fsharp\" data-lang=\"fsharp\" data-unlink=\"\"><span class=\"synComment\">// F#</span>\n<span class=\"synComment\">// let add x y = x + yと同じ</span>\n<span class=\"synStatement\">let</span> <span class=\"synIdentifier\">add</span> <span class=\"synStatement\">=</span> <span class=\"synStatement\">fun</span> x <span class=\"synStatement\">-&gt;</span> <span class=\"synStatement\">fun</span> y <span class=\"synStatement\">-&gt;</span> x <span class=\"synStatement\">+</span> y\n</pre> \n<p>多出力したい場合はどうでしょうか。 これも、「関数を受け取る関数」により実現できます。 これはつまり、継続で見た方法です<a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#f-d7de6de9\" name=\"fn-d7de6de9\" title=\"多入力と多出力で戻り値の位置に関数がくるか、引数の位置に関数がくるかが入れ替わるのも面白いですね。双対性というやつでしょうか。\">*5</a>。</p> \n<pre class=\"code lang-fsharp\" data-lang=\"fsharp\" data-unlink=\"\"><span class=\"synComment\">// F#</span>\n<span class=\"synStatement\">let</span> <span class=\"synIdentifier\">f</span> <span class=\"synStatement\">=</span> <span class=\"synStatement\">fun</span> x <span class=\"synStatement\">-&gt;</span> <span class=\"synStatement\">fun</span> k <span class=\"synStatement\">-&gt;</span>\n  k x <span class=\"synStatement\">(</span>x <span class=\"synStatement\">*</span> <span class=\"synConstant\">2</span><span class=\"synStatement\">)</span> <span class=\"synComment\">// (k x)で返ってきた関数に(x * 2)を適用</span>\n\n<span class=\"synComment\">// シンタックスシュガーを使うと、</span>\n<span class=\"synComment\">// f 3 (fun x y -&gt; add x y)</span>\n<span class=\"synComment\">// とか</span>\n<span class=\"synComment\">// f 3 add</span>\n<span class=\"synComment\">// とか書ける</span>\nf <span class=\"synConstant\">3</span> <span class=\"synStatement\">(fun</span> x <span class=\"synStatement\">-&gt;</span> <span class=\"synStatement\">fun</span> y <span class=\"synStatement\">-&gt;</span>\n  add x y <span class=\"synComment\">// (add x)で返ってきた関数にyを適用</span>\n<span class=\"synStatement\">)</span>\n</pre> \n<p>このように、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B4%D8%BF%F4%B7%BF%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0\">関数型プログラミング</a>言語では1入力1出力の関数だけですべてを表せる世界を作っているわけです<a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#f-c5d123b0\" name=\"fn-c5d123b0\" title=\"念のため: 実際にこんなコードは書きません。\">*6</a>。 これはこれできれいですね。</p> \n<h3>手続き型<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>と関数</h3> \n<p>Go言語を除いた多くの手続き型<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>では、関数は多入力1出力です。 なぜ入力は複数許すのに、出力は1つか許してないのでしょうか。 自分は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>が1つの戻り値しか許さないようになっていたのをずっと引きずってきたのではないか、と考えています。</p> \n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%BB%A5%F3%A5%D6%A5%EA\">アセンブリ</a>レベルまで降りていけば、そもそも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EC%A5%B8%A5%B9%A5%BF\">レジスタ</a>を使って複数の値を返すようなサブルーチンなんかは普通に書けるわけです。 <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/x86\">x86</a>であれば、divはeaxに商を、edxに余りを格納しますが、これも多値を返していると見なせます。</p> \n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%BB%A5%F3%A5%D6%A5%EA\">アセンブリ</a>レベルまで降りれば多値が使えるのに、今までの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>ではそれを有効活用してこなかったことになります。 これは、手続き型<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>が計算機を効率よく使えるように進化してきたことを考えると、少し不幸な感じがします。 Go言語は、そういった世界をぶち壊す<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%D1%A5%AF\">インパク</a>トを持った言語だと思います<a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#f-3ceae65c\" name=\"fn-3ceae65c\" title=\"しかし、前のエントリでも書いたように、Go言語は多値っぽいけど多値じゃないものを入れてしまったのでそこはすごく残念。\">*7</a>。</p> \n<h3>タプルと多値(と手続き型<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>)</h3> \n<p>多値はネストができません。他の値の要素となることもできません。 この制約によって多値は何を手に入れたのでしょうか。</p> \n<p>それは、効率です。 多値と同じようなものとみられることもあるタプルですが、タプルはあくまで1つの値に複数の値をパックしたものです。 パックする処理(タプルの構築)も、アンパックする処理(タプルの分解)も、どれもタダというわけではありません。 言語処理系において、タプルの効率を上げようとする試みはいくつもありますが、タプルが値である以上、すべてのタプルを最適化できるわけではありません。</p> \n<p>それに対し、多値は単なる複数の値であり、それ自体は値ではありません(スタックに積んであるだけ、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EC%A5%B8%A5%B9%A5%BF\">レジスタ</a>に並んでいるだけ)。 そのため、パックやアンパックなどとは無縁の世界で生きていられます。</p> \n<p>手続き型<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>でも関数がファーストクラスの値として使えるような言語が増えてきましたが、 手続き型<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>は本来、計算機を効率を程よく保ったまま抽象的に扱えるようにした言語であるべきではないでしょうか(ただし異論は認める)。 その場合、関数だのタプルだのをファーストクラスで扱えることにこだわらず、効率よく扱えるものを扱うにとどめるという割り切った言語があってもいいと思います。</p> \n<p>ただ、ユーザー定義できる型と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>があるとそれだけでタプルが作れてしまうので、多値がないがしろにされがち、というのはあるかもしれません。</p> \n<h2>多値とは</h2> \n<p>さて、多値とは何者でしょうか。</p> \n<ul> \n <li>「単なるスタックに積まれた値だよ」</li> \n <li>「単なる継続の引数だよ」</li> \n <li>「Go言語の多値が多値だよ」</li> \n</ul> \n<p>色々と意見はあるでしょうが、ここからは「カンマで区切られた単なる複数の値だよ」という妄想の世界の話です。 ちなみに、上の3つだと一番下が一番近いです(が、別物です)。</p> \n<h3>多値かくあるべし！</h3> \n<p>架空の言語(WillGoとでもしておきましょう)を考えます。 この言語では、多値はカンマで区切られた単なる複数の値です。 どういうことか見てみましょう。 まずは、多値を返す関数です。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\"><span class=\"synComment\">// 型と値の間にはコロンを置く(趣味)</span>\n<span class=\"synComment\">// 多値を出力する関数は、出力する型をそれぞれカンマで区切って表現する</span>\n<span class=\"synStatement\">func</span> f(a: <span class=\"synType\">int</span>): <span class=\"synType\">int</span>, <span class=\"synType\">int</span> {\n    <span class=\"synStatement\">return</span> a, a * <span class=\"synConstant\">2</span> <span class=\"synComment\">// 多値を返している。</span>\n}\n\nx, y := f(<span class=\"synConstant\">3</span>) <span class=\"synComment\">// x, yというのは多値を表している。</span>\n</pre> \n<p>多値はカンマで区切られたものとして表現されていますね。</p> \n<p>多値を受け取る関数も見てみましょう。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\"><span class=\"synComment\">// a: int, b: int というのは、多値を受け取る関数であることを表している。</span>\n<span class=\"synComment\">// 関数の出力で多値を表す場合と同じ表現であることが分かる。</span>\n<span class=\"synStatement\">func</span> add(a: <span class=\"synType\">int</span>, b: <span class=\"synType\">int</span>): <span class=\"synType\">int</span> {\n    <span class=\"synStatement\">return</span> a + b\n}\n\nresult := add(<span class=\"synConstant\">1</span>, <span class=\"synConstant\">2</span>) <span class=\"synComment\">// 1, 2というのは多値を表している。</span>\n</pre> \n<p>当然、多値を返す関数の結果をそのまま多値を渡す関数に渡せます。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\">result := add(f(<span class=\"synConstant\">3</span>)) <span class=\"synComment\">// 多値を渡す関数に多値を返す関数の結果をそのまま渡している。</span>\n</pre> \n<p>ここまではいい感じですね。</p> \n<h3>多値かくあるべし・・・？</h3> \n<p>さて、多値は「カンマで区切られた単なる複数の値」でした。 ここから、妄想らしくなっていきます。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\"><span class=\"synComment\">// 4引数版addを定義。</span>\n<span class=\"synStatement\">func</span> add4(a: <span class=\"synType\">int</span>, b: <span class=\"synType\">int</span>, c: <span class=\"synType\">int</span>, d: <span class=\"synType\">int</span>): <span class=\"synType\">int</span> {\n    <span class=\"synStatement\">return</span> a + b + c + d\n}\n\nresult := add4(<span class=\"synConstant\">1</span>, <span class=\"synConstant\">2</span>, <span class=\"synConstant\">3</span>, <span class=\"synConstant\">4</span>) <span class=\"synComment\">// 1, 2, 3, 4は多値。</span>\n</pre> \n<p>この <code>add4</code> に対して、こんな呼び出しはどうでしょうか。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\">res1 := add4(<span class=\"synConstant\">1</span>, <span class=\"synConstant\">2</span>, f(<span class=\"synConstant\">3</span>))\nres2 := add4(<span class=\"synConstant\">1</span>, f(<span class=\"synConstant\">2</span>), <span class=\"synConstant\">3</span>)\nres3 := add4(f(<span class=\"synConstant\">1</span>), f(<span class=\"synConstant\">2</span>))\n</pre> \n<p>くどいようですが、多値は「カンマで区切られた単なる複数の値」でした。 であるならば、「そこに展開した結果がvalidであればvalidとする」としてもいいと思いませんか。 きれいだ・・・！</p> \n<h3>きれいな多値の分かりにくさ</h3> \n<p>さて、この架空の言語ですが、関数呼び出しを見ても引数の個数が分からないという問題があります。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\">res3 := add4(f(<span class=\"synConstant\">1</span>), f(<span class=\"synConstant\">2</span>)) <span class=\"synComment\">// 2引数関数に見える</span>\n</pre> \n<p>今どきの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/IDE\">IDE</a>なら、コード上に書かれていない文字列を表示するくらいやってのけるので、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/IDE\">IDE</a>前提であれば使えるかもしれません。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\"><span class=\"synComment\">// 上のコードは、IDEで開くとこう見える(実際に書いてない部分はグレーアウト)。</span>\nres3 := add4(a, b=f(x=<span class=\"synConstant\">1</span>), c,d=f(x=<span class=\"synConstant\">2</span>))\n</pre> \n<p>もしくは、関数名さえ気を付ければそれほど問題にはならないかもしれません。</p> \n<p>ちなみに、実在するGoという言語はこの問題に足を片方入れています。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\"><span class=\"synComment\">// Go言語</span>\nres := f(g()) <span class=\"synComment\">// さて、fは何引数関数でしょう？</span>\n</pre> \n<p>そこまでやったのであれば、きれいな多値が欲しくなりませんか？</p> \n<h3>可変長引数と多値、もしくは可変長戻り値と多値</h3> \n<p>ここまでくると、行くところまで行ってみたい気がしますね。 引数を何個でも指定できる関数というものがあります。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\"><span class=\"synStatement\">func</span> sum(xs: ...<span class=\"synType\">int</span>): <span class=\"synType\">int</span> {\n    res := <span class=\"synConstant\">0</span>\n    <span class=\"synStatement\">for</span> _, x <span class=\"synStatement\">range</span> xs {\n        res += x\n    }\n    <span class=\"synStatement\">return</span> res\n}\n\nresult := sum(<span class=\"synConstant\">1</span>, <span class=\"synConstant\">2</span>, <span class=\"synConstant\">3</span>)\n</pre> \n<p>では、戻り値を何個でも指定できる関数というのはどうでしょうか。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\"><span class=\"synStatement\">func</span> f(b: <span class=\"synType\">bool</span>): ...<span class=\"synType\">int</span> {\n    <span class=\"synStatement\">if</span> b {\n        <span class=\"synStatement\">return</span> <span class=\"synConstant\">1</span>, <span class=\"synConstant\">2</span>\n    } <span class=\"synStatement\">else</span> {\n        <span class=\"synStatement\">return</span> <span class=\"synConstant\">4</span>, <span class=\"synConstant\">5</span>, <span class=\"synConstant\">6</span>\n    }\n}\n</pre> \n<p>これは、通常の手段では受け取れない関数となります。 この結果を使うためには、可変長引数の関数が必要です。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\">result := sum(f(<span class=\"synStatement\">true</span>))\n</pre> \n<p>または、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時定数が渡された場合のみ受け取れるようにするのも面白そうです<a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#f-5b8239b8\" name=\"fn-5b8239b8\" title=\"ただし、コンパイル時間は無視するものとする。\">*8</a>。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\">a, b, c := sum(f(<span class=\"synStatement\">false</span>)) <span class=\"synComment\">// OK</span>\nd, e, f := sum(f(<span class=\"synStatement\">true</span>)) <span class=\"synComment\">// コンパイルエラー</span>\n</pre> \n<p>スライスに変換する組み込み関数があれば(効率以外は)問題ありません。</p> \n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink=\"\">xs := valuesToSlice(f(<span class=\"synStatement\">true</span>))\nys := valuesToSlice(f(<span class=\"synStatement\">false</span>))\n</pre> \n<p>これで、多値を「カンマで区切られた単なる複数の値」としてみなしても成り立ちそうだということがなんとなくわかっていただけたかと思います(便利だとは言っていない)。</p> \n<p>このように、多値は多値で面白い世界が広がっているのです。 Go言語の多値は始まりでしかありません。 みなさんも自分だけの多値の世界を考えて、どんどん多値のすばらしさを世界に発信していきましょう！</p> \n<h2>参考ページ</h2> \n<ul> \n <li><a href=\"https://practical-scheme.net/wiliki/wiliki.cgi?Scheme%3A%E5%A4%9A%E5%80%A4\">Scheme:多値</a>: <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a>での多値についての解説ページ。</li> \n <li><a href=\"http://practical-scheme.net/docs/cont-j.html\">なんでも継続</a>: 継続についての解説ページ。未完。</li> \n <li><a href=\"http://www.kmonos.net/wlog/95.html#_1109090307\">思考実験: returnを関数と思ってみる話</a>: <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>風言語でreturnを関数と思ったらどういう世界があるのか考察したページ。</li> \n <li><a href=\"http://d.hatena.ne.jp/m-hiyama/20060209/1139450736\">なぜ、多値関数は人気がないのだろう - 檜山正幸のキマイラ飼育記</a>: 多値が流行っていない理由の考察ページ。</li> \n <li>他にもあったけど忘れた・・・</li> \n</ul> \n<div class=\"footnote\"> \n <p class=\"footnote\"><a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-3d7100dc\" name=\"f-3d7100dc\" class=\"footnote-number\">*1</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">メジャーな言語だと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a>/<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Common%20Lisp\">Common Lisp</a>とGoくらいではないでしょうか。何をメジャーに入れるかという問題はありますが。※<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Lua\">Lua</a>も多値を持っているようです。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Twitter\">Twitter</a>で教えてもらいました。※<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GHC\">GHC</a>拡張にもUnboxed Tuplesという構文拡張があるようです。これも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Twitter\">Twitter</a>で教えてもらいました。</span></p> \n <p class=\"footnote\"><a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-c88d3592\" name=\"f-c88d3592\" class=\"footnote-number\">*2</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">クラスのフィールドとして持たせられる。</span></p> \n <p class=\"footnote\"><a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-f2b77382\" name=\"f-f2b77382\" class=\"footnote-number\">*3</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">ただし、上で例に挙げた<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%BE%C1%DB%A5%DE%A5%B7%A5%F3\">仮想マシン</a>(や、他の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%BE%C1%DB%A5%DE%A5%B7%A5%F3\">仮想マシン</a>)では、m個の値を積んだ状態で関数からreturnすることを許していません。</span></p> \n <p class=\"footnote\"><a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-46c2aa22\" name=\"f-46c2aa22\" class=\"footnote-number\">*4</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\"><a href=\"http://www.kmonos.net/wlog/95.html#_1109090307\">http://www.kmonos.net/wlog/95.html#_1109090307</a> という記事を思い出したので置いておきます。この記事では、returnを関数と見なすとどうなるだろう、という思考実験をしています。</span></p> \n <p class=\"footnote\"><a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-d7de6de9\" name=\"f-d7de6de9\" class=\"footnote-number\">*5</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">多入力と多出力で戻り値の位置に関数がくるか、引数の位置に関数がくるかが入れ替わるのも面白いですね。双対性というやつでしょうか。</span></p> \n <p class=\"footnote\"><a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-c5d123b0\" name=\"f-c5d123b0\" class=\"footnote-number\">*6</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">念のため: 実際にこんなコードは書きません。</span></p> \n <p class=\"footnote\"><a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-3ceae65c\" name=\"f-3ceae65c\" class=\"footnote-number\">*7</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">しかし、前のエントリでも書いたように、Go言語は多値っぽいけど多値じゃないものを入れてしまったのでそこはすごく残念。</span></p> \n <p class=\"footnote\"><a href=\"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-5b8239b8\" name=\"f-5b8239b8\" class=\"footnote-number\">*8</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">ただし、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間は無視するものとする。</span></p> \n</div>","descriptionType":"html","publishedDate":"Mon, 12 Nov 2018 04:00:00 +0000","feedId":45997,"bgimg":"https://cdn.blog.st-hatena.com/images/theme/og-image-1500.png","linkMd5":"209a1a0b477cb353b3cb37fa15d38099","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn64@2020_5/2021/05/03/03-42-49-750_826ddd244d633277.webp","destWidth":1500,"destHeight":1051,"sourceBytes":70050,"destBytes":47840,"author":"bleis-tift","enclosureType":"image/png","enclosureUrl":"https://cdn.blog.st-hatena.com/images/theme/og-image-1500.png","publishedOrCreatedDate":1620013367313}],"record":{"createdTime":"2021-05-03 11:42:47","updatedTime":"2021-05-03 11:42:47","feedId":45997,"fetchDate":"Mon, 03 May 2021 03:42:47 +0000","fetchMs":6097,"handleMs":20306,"totalMs":34480,"newArticles":0,"totalArticles":30,"status":1,"type":0,"ip":"bc1eecef1292254c09de6c1e66b750f3","hostName":"europe62*","requestId":"7060c64a7af84773832123e1742b63fa_45997","contentType":"application/atom+xml; charset=utf-8","totalBytes":0,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":0,"articlesImgsGithubTotal":0,"successGithubMap":{"myreaderx11":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 03:40:13","updatedTime":"2021-04-10 19:07:19","id":45997,"name":"ぐるぐる～","url":"http://bleis-tift.hatenablog.com/feed","subscriber":69,"website":null,"icon":"https://bleis-tift.hatenablog.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"https://bleis-tift.hatenablog.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1620013335963,"total":0,"statList":[{"spend":11044,"msg":"获取xml内容"},{"spend":20306,"msg":"解释文章"},{"spend":0,"msg":"正文链接上传到cdn"},{"spend":3123,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"}]},"extra5":0,"extra6":0,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{"https://bleis-tift.hatenablog.com/entry/multiple-values_#f-3d7100dc":"https://bleis-tift.hatenablog.com/entry/multiple-values#f-3d7100dc","https://bleis-tift.hatenablog.com/entry/multiple-values_#f-d7de6de9":"https://bleis-tift.hatenablog.com/entry/multiple-values#f-d7de6de9","https://bleis-tift.hatenablog.com/entry/multiple-values_#fn-c5d123b0":"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-c5d123b0","https://bleis-tift.hatenablog.com/entry/multiple-values_#fn-3d7100dc":"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-3d7100dc","https://bleis-tift.hatenablog.com/entry/multiple-values_#fn-c88d3592":"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-c88d3592","https://bleis-tift.hatenablog.com/entry/multiple-values_#fn-46c2aa22":"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-46c2aa22","https://bleis-tift.hatenablog.com/entry/multiple-values_#f-3ceae65c":"https://bleis-tift.hatenablog.com/entry/multiple-values#f-3ceae65c","https://bleis-tift.hatenablog.com/entry/multiple-values_#fn-f2b77382":"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-f2b77382","https://bleis-tift.hatenablog.com/entry/multiple-values_#f-5b8239b8":"https://bleis-tift.hatenablog.com/entry/multiple-values#f-5b8239b8","https://bleis-tift.hatenablog.com/entry/multiple-values_#f-f2b77382":"https://bleis-tift.hatenablog.com/entry/multiple-values#f-f2b77382","https://bleis-tift.hatenablog.com/entry/multiple-values_#f-c88d3592":"https://bleis-tift.hatenablog.com/entry/multiple-values#f-c88d3592","https://bleis-tift.hatenablog.com/entry/multiple-values_#fn-5b8239b8":"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-5b8239b8","https://bleis-tift.hatenablog.com/entry/multiple-values_#fn-d7de6de9":"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-d7de6de9","https://bleis-tift.hatenablog.com/entry/multiple-values_#f-46c2aa22":"https://bleis-tift.hatenablog.com/entry/multiple-values#f-46c2aa22","https://bleis-tift.hatenablog.com/entry/multiple-values_#f-c5d123b0":"https://bleis-tift.hatenablog.com/entry/multiple-values#f-c5d123b0","https://bleis-tift.hatenablog.com/entry/multiple-values_#fn-3ceae65c":"https://bleis-tift.hatenablog.com/entry/multiple-values#fn-3ceae65c"},"extra111_proxyServerAndStatMap":{},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://cdn.blog.st-hatena.com/images/theme/og-image-1500.png","sourceStatusCode":200,"destWidth":1500,"destHeight":1051,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn64@2020_5/2021/05/03/03-42-49-750_826ddd244d633277.webp","sourceBytes":70050,"destBytes":47840,"targetWebpQuality":75,"feedId":45997,"totalSpendMs":866,"convertSpendMs":93,"createdTime":"2021-05-03 11:42:49","host":"europe21*","referer":"https://bleis-tift.hatenablog.com/entry/multiple-values","linkMd5ListStr":"209a1a0b477cb353b3cb37fa15d38099","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"68.4 KB","destSize":"46.7 KB","compressRate":"68.3%"}],"successGithubMap":{"myreaderx11":1},"failGithubMap":{}}