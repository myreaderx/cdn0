{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-08-26 15:05:04","updatedTime":"2020-08-26 15:05:04","title":"10分钟搞定 Java 并发队列好吗？好的","link":"https://segmentfault.com/a/1190000023769855","description":"<p>| <strong>好看请赞，养成习惯</strong></p>\n<blockquote>\n <ul>\n  <li>你有一个思想，我有一个思想，我们交换后，一个人就有两个思想</li>\n  <li>If you can NOT explain it simply, you do NOT understand it well enough</li>\n </ul>\n</blockquote>\n<p>现陆续将Demo代码和技术文章整理在一起 <a href=\"https://github.com/FraserYu/learnings\" rel=\"nofollow noreferrer\">Github实践精选</a> ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star</p>\n<hr>\n <h2>前言</h2>\n <p>如果按照用途与特性进行粗略的划分，JUC 包中包含的工具大体可以分为 6 类：</p>\n <ol>\n  <li>执行者与线程池</li>\n  <li>并发队列</li>\n  <li>同步工具</li>\n  <li>并发集合</li>\n  <li>锁</li>\n  <li>原子变量</li>\n </ol>\n <p>在<a href=\"https://dayarch.top/categories/Coding/Java-Concurrency/\" rel=\"nofollow noreferrer\">并发系列</a>中，主要讲解了 <code>执行者与线程池</code>，<code>同步工具</code>，<code>锁</code> ， 在分析源码时，或多或少的提及到了「队列」，队列在 JUC 中也是多种多样存在，所以本文就以「远看」视角，帮助大家快速了解与区分这些看似「杂乱」的队列</p>\n <h2>并发队列</h2>\n <p>Java 并发队列按照实现方式来进行划分可以分为 2 种：</p>\n <ol>\n  <li>阻塞队列</li>\n  <li>非阻塞队列</li>\n </ol>\n <p>如果你已经看完并发系列锁的实现，你已经能够知道他们实现的区别：</p>\n <blockquote>\n  前者就是基于锁实现的，后者则是基于 CAS 非阻塞算法实现的\n </blockquote>\n <p>常见的队列有下面这几种：</p>\n <p><img src=\"https://segmentfault.com/img/bVbLTMx\" alt=\"\" title=\"\" /></p>\n <p>瞬间懵逼？看到这个没有人性的图想直接走人？ 客观先别急，一会就柳暗花明了</p>\n <p>当下你也许有个问题：</p>\n <p><strong>为什么会有这么多种队列的存在</strong>？</p>\n <blockquote>\n  锁有应对各种情形的锁，队列也自然有应对各种情形的队列了, 是不是也有点单一职责原则的意思呢？\n </blockquote>\n <p>所以我们要了解这些队列到底是怎么设计的？以及用在了哪些地方？</p>\n <p>先来看下图</p>\n <p><img src=\"https://segmentfault.com/img/bVbLTMy\" alt=\"\" title=\"\" /></p>\n <p>如果你在 IDE 中打开以上非阻塞队列和阻塞队列，查看其实现方法，你就会发现，<code>阻塞队列</code>较<code>非阻塞队列</code> <strong>额外支持两种操作</strong>：</p>\n <ol>\n  <li><strong>阻塞的插入</strong><p>当队列满时，队列会阻塞插入元素的线程，直到队列不满</p></li>\n  <li><strong>阻塞的移除</strong><p>当队列为空时，获取元素的线程会阻塞，直到队列变为非空</p></li>\n </ol>\n <p>综合说明入队/出队操作，看似杂乱的方法，用一个表格就能概括了</p>\n <p><img src=\"https://segmentfault.com/img/bVbLTMz\" alt=\"\" title=\"\" /></p>\n <p><strong>抛出异常</strong></p>\n <ul>\n  <li>当队列满时，此时如果再向队列中插入元素，会抛出 IllegalStateException （这很好理解）</li>\n  <li>当队列空时，此时如果再从队列中获取元素，会抛出 NoSuchElementException （这也很好理解）</li>\n </ul>\n <p><strong>返回特殊值</strong></p>\n <ul>\n  <li>当向队列插入元素时，会返回元素是否插入成功，成功则返回 true</li>\n  <li>当从队列移除元素时，如果没有则返回 null</li>\n </ul>\n <p><strong>一直阻塞</strong></p>\n <ul>\n  <li>当队列满时，如果<strong>生产者线程</strong>向队列 put 元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出</li>\n  <li>当队列为空时，如果<strong>消费者线程</strong> 从队列里面 take 元素，队列会阻塞消费者线程，直到队列不为空</li>\n </ul>\n <p>关于阻塞，我们其实早在 <a href=\"https://dayarch.top/p/waiting-notification-mechanism.html\" rel=\"nofollow noreferrer\">并发编程之等待通知机制</a> 就已经充分说明过了，你还记得下面这张图吗？原理其实是一样一样滴</p>\n <p><img src=\"https://segmentfault.com/img/bVbEDzY\" alt=\"\" title=\"\" /></p>\n <p><strong>超时退出</strong></p>\n <p>和锁一样，因为有阻塞，为了灵活使用，就一定支持超时退出，阻塞时间达到超时时间，就会直接返回</p>\n <p>至于为啥插入和移除这么多种单词表示形式，我也不知道，为了方便记忆，只需要记住阻塞的方法形式即可：</p>\n <blockquote>\n  单词 \n  <code>put</code> 和 \n  <code>take</code> 字母 \n  <code>t</code> 首位相连，一个放，一个拿\n </blockquote>\n <p>到这里你应该对 Java 并发队列有了个初步的认识了，原来看似杂乱的方法貌似也有了规律。接下来就到了疯狂串知识点的时刻了，借助前序章节的知识，分分钟就理解全部队列了</p>\n <p><img src=\"https://segmentfault.com/img/bVbLTMC\" alt=\"\" title=\"\" /></p>\n <h3>ArrayBlockingQueue</h3>\n <p>之前也说过，JDK中的命名还是很讲究滴，一看这名字，底层就是数组实现了，是否有界，那就看在构造的时候是否需要指定 capacity 值了</p>\n <p>填鸭式的说明也容易忘，这些都是哪看到的呢？在所有队列的 Java docs 的第一段，一句话就概括了该队列的主要特性，所以强烈建议大家自己在看源码时，简单<strong>瞄一眼</strong> docs 开头，心中就有多半个数了</p>\n <p><img src=\"https://segmentfault.com/img/bVbLTMD\" alt=\"\" title=\"\" /></p>\n <p>在讲 <a href=\"https://dayarch.top/p/java-aqs-and-reentrantlock.html\" rel=\"nofollow noreferrer\">Java AQS队列同步器以及ReentrantLock的应用</a> 时我们介绍了公平锁与非公平锁的概念，ArrayBlockingQueue 也有同样的概念，看它的构造方法，就有 ReentrantLock 来辅助实现</p>\n <pre><code class=\"java\">public ArrayBlockingQueue(int capacity, boolean fair) {\n    if (capacity &lt;= 0)\n        throw new IllegalArgumentException();\n    this.items = new Object[capacity];\n    lock = new ReentrantLock(fair);\n    notEmpty = lock.newCondition();\n    notFull =  lock.newCondition();\n}</code></pre>\n <p>默认情况下，依旧是不保证线程公平访问队列（公平与否是指阻塞的线程能否按照阻塞的先后顺序访问队列，先阻塞线访问，后阻塞后访问）</p>\n <p>到这我也要临时问一个说过多次的面试送分题了：</p>\n <blockquote>\n  为什么默认采用非公平锁的方式？它较公平锁方式有什么好处，又可能带来哪些问题？\n </blockquote>\n <p>知道了以上内容，结合上面表格中的方法，ArrayBlockingQueue 就可以轻松过关了</p>\n <p><img src=\"https://segmentfault.com/img/bVbLTME\" alt=\"\" title=\"\" /></p>\n <p>和数组相对的自然是链表了</p>\n <h3>LinkedBlockingQueue</h3>\n <p><img src=\"https://segmentfault.com/img/bVbLTMI\" alt=\"\" title=\"\" /></p>\n <p>LinkedBlockingQueue 也算是一个有界阻塞队列 ，从下面的构造函数中你也可以看出，该队列的默认和最大长度为 Integer.MAX_VALUE ，这也就 docs 说 optionally-bounded 的原因了</p>\n <pre><code class=\"java\">public LinkedBlockingQueue() {\n    this(Integer.MAX_VALUE);\n}\n\npublic LinkedBlockingQueue(int capacity) {\n  if (capacity &lt;= 0) throw new IllegalArgumentException();\n  this.capacity = capacity;\n  last = head = new Node&lt;E&gt;(null);\n}</code></pre>\n <blockquote>\n  正如 Java 集合一样，链表形式的队列，其存取效率要比数组形式的队列高。但是在一些并发程序中，数组形式的队列由于具有一定的可预测性，因此可以在某些场景中获得更高的效率\n </blockquote>\n <p>看到 LinkedBlockingQueue 是不是也有些熟悉呢？ <a href=\"https://dayarch.top/p/why-we-need-to-use-threadpool.html\" rel=\"nofollow noreferrer\">为什么要使用线程池?</a> 就已经和它多次照面了</p>\n <p><strong>创建单个线程池</strong></p>\n <pre><code class=\"java\">public static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue&lt;Runnable&gt;()));\n}</code></pre>\n <p><strong>创建固定个数线程池</strong></p>\n <pre><code class=\"java\">public static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue&lt;Runnable&gt;());\n}</code></pre>\n <p>面试送分题又来了</p>\n <blockquote>\n  使用 Executors 创建线程池很简单，为什么大厂严格要求禁用这种创建方式呢？\n </blockquote>\n <h3>PriorityBlockingQueue</h3>\n <p>PriorityBlockingQueue 是一个支持优先级的无界的阻塞队列，默认情况下采用自然顺序升序排列，当然也有非默认情况自定义优先级，需要排序，那自然要用到 Comparator 来定义排序规则了</p>\n <p><img src=\"https://segmentfault.com/img/bVbLTMJ\" alt=\"\" title=\"\" /></p>\n <p>可以定义优先级，自然也就有相应的限制，以及使用的注意事项</p>\n <ul>\n  <li>按照上图说明，队列中不允许存在 null 值，也不允许存在不能排序的元素</li>\n  <li><p>对于排序值相同的元素，其序列是不保证的，但你可以继续自定义其他可以区分出来优先级的值，如果你有严格的优先级区分，建议有更完善的比较规则，就像 Java docs 这样</p><pre><code class=\"java\"> class FIFOEntry&lt;E extends Comparable&lt;? super E&gt;&gt;\n     implements Comparable&lt;FIFOEntry&lt;E&gt;&gt; {\n   static final AtomicLong seq = new AtomicLong(0);\n   final long seqNum;\n   final E entry;\n   public FIFOEntry(E entry) {\n     seqNum = seq.getAndIncrement();\n     this.entry = entry;\n   }\n   public E getEntry() { return entry; }\n   public int compareTo(FIFOEntry&lt;E&gt; other) {\n     int res = entry.compareTo(other.entry);\n     if (res == 0 &amp;&amp; other.entry != this.entry)\n       res = (seqNum &lt; other.seqNum ? -1 : 1);\n     return res;\n   }\n }</code></pre></li>\n  <li>队列容量是没有上限的，但是如果插入的元素超过负载，有可能会引起OutOfMemory异常（这是肯定的），这也是为什么我们通常所说，队列无界，心中有界</li>\n  <li><p>PriorityBlockingQueue 也有 put 方法，这是一个阻塞的方法，因为它是无界的，自然不会阻塞，所以就有了下面比较聪明的做法</p><pre><code class=\"java\">public void put(E e) {\n    offer(e); // never need to block  请自行对照上面表格\n}</code></pre></li>\n  <li><p>可以给定初始容量，这个容量会按照一定的算法自动扩充</p><pre><code class=\"java\">// Default array capacity.\nprivate static final int DEFAULT_INITIAL_CAPACITY = 11;\n\npublic PriorityBlockingQueue() {\n    this(DEFAULT_INITIAL_CAPACITY, null);\n}</code></pre><p>这里默认的容量是 11，由于也是基于数组，那面试送分题又来了</p>\n   <blockquote>\n    你通常是怎样定义容器/集合初始容量的？有哪些依据？\n   </blockquote></li>\n </ul>\n <h3>DelayQueue</h3>\n <p>DelayQueue 是一个支持延时获取元素的无界阻塞队列</p>\n <ul>\n  <li>是否延时肯定是和某个时间(通常和当前时间) 进行<strong>比较</strong></li>\n  <li>比较过后还要进行排序，所以也是存在一定的<strong>优先级</strong></li>\n </ul>\n <p>看到这也许觉得这有点和 <code>PriorityBlockingQueue</code> 很像，没错，<code>DelayQueue</code> 的内部也是使用 <code>PriorityQueue</code></p>\n <p><img src=\"https://segmentfault.com/img/bVbLTMK\" alt=\"\" title=\"\" /></p>\n <p>上图绿色框线也告诉你，DelayQueue 队列的元素必须要实现 Depayed 接口：</p>\n <p><img src=\"https://segmentfault.com/img/bVbLTML\" alt=\"\" title=\"\" /></p>\n <p>所以从上图可以看出使用 DelayQueue 非常简单，只需要两步：</p>\n <blockquote>\n  实现 getDelay() 方法，返回元素要延时多长时间\n </blockquote>\n <pre><code class=\"java\">public long getDelay(TimeUnit unit) {\n      // 最好采用纳秒形式，这样更精确\n    return unit.convert(time - now(), NANOSECONDS);\n}</code></pre>\n <blockquote>\n  实现 compareTo() 方法，比较元素顺序\n </blockquote>\n <pre><code class=\"java\">public int compareTo(Delayed other) {\n    if (other == this) // compare zero if same object\n        return 0;\n    if (other instanceof ScheduledFutureTask) {\n        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;\n        long diff = time - x.time;\n        if (diff &lt; 0)\n            return -1;\n        else if (diff &gt; 0)\n            return 1;\n        else if (sequenceNumber &lt; x.sequenceNumber)\n            return -1;\n        else\n            return 1;\n    }\n    long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);\n    return (diff &lt; 0) ? -1 : (diff &gt; 0) ? 1 : 0;\n}</code></pre>\n <p>上面的代码哪来的呢？如果你打开 ScheduledThreadPoolExecutor 里的 ScheduledFutureTask，你就看到了 （ScheduledThreadPoolExecutor 内部就是应用 DelayQueue）</p>\n <p>所以综合来说，下面两种情况非常适合使用 DelayQueue</p>\n <ul>\n  <li>缓存系统的设计：用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，如果能从 DelayQueue 中获取元素，说明缓存有效期到了</li>\n  <li>定时任务调度：用 DelayQueue 保存当天会执行的任务以及时间，如果能从 DelayQueue 中获取元素，任务就可以开始执行了。比如 TimerQueue 就是这样实现的</li>\n </ul>\n <h3>SynchronousQueue</h3>\n <p><img src=\"https://segmentfault.com/img/bVbLTMR\" alt=\"\" title=\"\" /></p>\n <p>这是一个<strong>不存储元素</strong>的阻塞队列，不存储元素还叫队列？</p>\n <p><img src=\"https://segmentfault.com/img/bVbLTMS\" alt=\"\" title=\"\" /></p>\n <p>没错，SynchronousQueue 直译过来叫<strong>同步队列</strong>，如果在队列里面呆久了应该就算是“异步”了吧</p>\n <p>所以使用它，每个put() 操作必须要等待一个 take() 操作，反之亦然，否则不能继续添加元素</p>\n <p>实际中怎么用呢？假如你需要两个线程之间同步共享变量，如果不用 SynchronousQueue 你可能会选择用 CountDownLatch 来完成，就像这样：</p>\n <pre><code class=\"java\">ExecutorService executor = Executors.newFixedThreadPool(2);\nAtomicInteger sharedState = new AtomicInteger();\nCountDownLatch countDownLatch = new CountDownLatch(1);\n\n\n\nRunnable producer = () -&gt; {\n    Integer producedElement = ThreadLocalRandom\n      .current()\n      .nextInt();\n    sharedState.set(producedElement);\n    countDownLatch.countDown();\n};\n\n\n\nRunnable consumer = () -&gt; {\n    try {\n        countDownLatch.await();\n        Integer consumedElement = sharedState.get();\n    } catch (InterruptedException ex) {\n        ex.printStackTrace();\n    }\n};</code></pre>\n <p>这点小事就用计数器来实现，显然很不合适，用 SynchronousQueue 改造一下，感觉瞬间就不一样了</p>\n <pre><code class=\"java\">ExecutorService executor = Executors.newFixedThreadPool(2);\nSynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;&gt;();\n\nRunnable producer = () -&gt; {\n    Integer producedElement = ThreadLocalRandom\n      .current()\n      .nextInt();\n    try {\n        queue.put(producedElement);\n    } catch (InterruptedException ex) {\n        ex.printStackTrace();\n    }\n};\n\nRunnable consumer = () -&gt; {\n    try {\n        Integer consumedElement = queue.take();\n    } catch (InterruptedException ex) {\n        ex.printStackTrace();\n    }\n};</code></pre>\n <p>其实 <strong>Executors.newCachedThreadPool()</strong> 方法里面使用的就是 SynchronousQueue</p>\n <pre><code class=\"java\">public static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue&lt;Runnable&gt;());\n}</code></pre>\n <blockquote>\n  看到前面 \n  <code>LinkedBlockingQueue</code> 用在 \n  <code>newSingleThreadExecutor</code> 和 \n  <code>newFixedThreadPool</code> 上，而\n  <code>newCachedThreadPool</code> 却用 \n  <code>SynchronousQueue</code>，这是为什么呢？\n </blockquote>\n <p>因为单线程池和固定线程池中，线程数量是有限的，因此提交的任务需要在<code>LinkedBlockingQueue</code>队列中等待空余的线程；</p>\n <p>而缓存线程池中，线程数量几乎无限（上限为<code>Integer.MAX_VALUE</code>），因此提交的任务只需要在<code>SynchronousQueue</code> 队列中同步移交给空余线程即可, 所以有时也会说 <code>SynchronousQueue</code> 的吞吐量要高于 <code>LinkedBlockingQueue</code> 和 <code>ArrayBlockingQueue</code></p>\n <h3>LinkedTransferQueue</h3>\n <p>简单来说，TransferQueue提供了一个场所，生产者线程使用 <code>transfer</code> 方法传入一些对象并阻塞，直至这些对象被消费者线程全部取出。</p>\n <blockquote>\n  你有没有觉得，刚刚介绍的 \n  <strong>SynchronousQueue</strong> 是否很像一个容量为 0 的 \n  <strong>TransferQueue</strong>。\n </blockquote>\n <p>但 LinkedTransferQueue 相比其他阻塞队列多了三个方法</p>\n <ul>\n  <li><strong>transfer(E e)</strong> <p>如果当前有消费者正在等待消费元素，transfer 方法就可以直接将生产者传入的元素立刻 transfer (传输) 给消费者；如果没有消费者等待消费元素，那么 transfer 方法会把元素放到队列的 tail(尾部) </p><p>节点，一直阻塞，直到该元素被消费者消费才返回</p></li>\n  <li><strong>tryTransfer(E e)</strong><p>tryTransfer，很显然是一种尝试，如果没有消费者等待消费元素，则马上返回 false ，程序不会阻塞</p></li>\n  <li><strong>tryTransfer(E e, long timeout, TimeUnit unit)</strong><p>带有超时限制，尝试将生产者传入的元素 transfer 给消费者，如果超时时间到，还没有消费者消费元素，则返回 false</p></li>\n </ul>\n <p>你瞧，所有阻塞的方法都是一个套路：</p>\n <ol>\n  <li>阻塞方式</li>\n  <li>带有 try 的非阻塞方式</li>\n  <li>带有 try 和超时时间的非阻塞方式</li>\n </ol>\n <p>看到这你也许感觉 LinkedTransferQueue 没啥特点，其实它和其他阻塞队列的差别还挺大的：</p>\n <blockquote>\n  BlockingQueue 是如果队列满了，线程才会阻塞；但是 TransferQueue 是如果没有消费元素，则会阻塞 （transfer 方法）\n </blockquote>\n <p>这也就应了 Doug Lea 说的那句话：</p>\n <blockquote>\n  <code>LinkedTransferQueue</code> is actually a superset of \n  <code>ConcurrentLinkedQueue</code>, \n  <code>SynchronousQueue</code> (in “fair” mode), and unbounded\n  <br><code>LinkedBlockingQueues</code>. And it’s made better by allowing you to mix and<br>match those features as well as take advantage of higher-performance i<br>mplementation techniques.<p><strong>简单翻译：</strong></p><p><code>LinkedTransferQueue</code> 是<code>ConcurrentLinkedQueue</code>, <code>SynchronousQueue</code> (在公平模式下), 无界的<code>LinkedBlockingQueues</code>等的超集; 允许你混合使用阻塞队列的多种特性</p><p><strong>所以，在合适的场景中，请尽量使用<code>LinkedTransferQueue</code></strong></p></br></br></br>\n </blockquote>\n <p>上面都看的是单向队列 FIFO，接下来我们看看双向队列</p>\n <h3>LinkedBlockingDeque</h3>\n <p><code>LinkedBlockingDeque</code> 是一个由链表结构组成的双向阻塞队列，凡是后缀为 Deque 的都是双向队列意思，后缀的发音为<code>deck——/dek/</code>, 刚接触它时我以为是这个冰激凌的发音</p>\n <p><img src=\"https://segmentfault.com/img/bVbLTMT\" alt=\"\" title=\"\" /></p>\n <p>所谓双向队列值得就是可以从队列的两端插入和移除元素。所以：</p>\n <blockquote>\n  双向队列因为多了一个操作队列的入口，在多线程同时入队是，也就会减少一半的竞争\n </blockquote>\n <p>队列有头，有尾，因此它又比其他阻塞队列多了几个特殊的方法</p>\n <ul>\n  <li>addFirst</li>\n  <li>addLast</li>\n  <li>xxxxFirst</li>\n  <li>xxxxLast</li>\n  <li>... ...</li>\n </ul>\n <p><img src=\"https://segmentfault.com/img/bVbLTMU\" alt=\"\" title=\"\" /></p>\n <p>这么一看，双向阻塞队列确实很高效，</p>\n <blockquote>\n  那双向阻塞队列应用在什么地方了呢？\n </blockquote>\n <p>不知道你是否听过 “<strong>工作窃取</strong>”模式，看似不太厚道的一种方法，实则是高效利用线程的好办法。下一篇文章，我们就来看看 ForkJoinPool 是如何应用 “<strong>工作窃取</strong>”模式的</p>\n <h2>总结</h2>\n <p>到这关于 Java 队列（其实主要介绍了阻塞队列）就快速的区分完了，将看似杂乱的方法做了分类整理，方便快速理解其用途，同时也说明了这些队列的实际用途。相信你带着更高的视角来阅读源码会更加轻松，最后也希望大家认真看两个队列的源码实现，在遇到队列的问题，脑海中的画面分分钟就可以搞定了</p>\n <h2>参考</h2>\n <ol>\n  <li>Java 并发编程的艺术</li>\n  <li>Java 并发编程之美</li>\n  <li><a href=\"https://zhuanlan.zhihu.com/p/27148381\" rel=\"nofollow noreferrer\">https://zhuanlan.zhihu.com/p/...</a></li>\n </ol>\n <p>日拱一兵 ｜ 原创</p>\n</hr>","descriptionType":"html","publishedDate":"Wed, 26 Aug 2020 02:45:52 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLTMx","linkMd5":"9c3b09b7b3a439d2eecc3a77bb5d5df1","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn21@2020_6/2020/08/26/07-05-20-087_c15342b0eb94a58b.webp","destWidth":800,"destHeight":498,"sourceBytes":92093,"destBytes":66646,"author":"日拱一兵","articleImgCdnMap":{"https://segmentfault.com/img/bVbLTMx":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn21@2020_6/2020/08/26/07-05-20-087_c15342b0eb94a58b.webp","https://segmentfault.com/img/bVbLTMy":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn2@2020_3/2020/08/26/07-05-24-359_aceb5a25e60de04f.webp","https://segmentfault.com/img/bVbLTMz":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn97@2020_2/2020/08/26/07-05-25-502_459fb3ef1e9e57c7.webp","https://segmentfault.com/img/bVbEDzY":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn6@2020_4/2020/08/26/07-05-25-480_29e4764d69dfabe1.webp","https://segmentfault.com/img/bVbLTMC":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn61@2020_6/2020/08/26/07-05-24-437_ff4472783ef723d7.webp","https://segmentfault.com/img/bVbLTMD":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn58@2020_4/2020/08/26/07-05-26-816_5b9d829a3c8d3cc1.webp","https://segmentfault.com/img/bVbLTME":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn53@2020_5/2020/08/26/07-05-26-440_fb90d9bb0972662e.webp","https://segmentfault.com/img/bVbLTMI":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn68@2020_4/2020/08/26/07-05-25-443_46af042654132ee8.webp","https://segmentfault.com/img/bVbLTMJ":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn66@2020_6/2020/08/26/07-05-25-384_ffe94cfa1aa215dd.webp","https://segmentfault.com/img/bVbLTMK":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn76@2020_4/2020/08/26/07-05-25-477_9602d32b8493caf0.webp","https://segmentfault.com/img/bVbLTML":"https://cdn.jsdelivr.net/gh/myreaderx/cdn71@2020_3/2020/08/26/07-05-23-562_3e4534db9ccd187b.webp","https://segmentfault.com/img/bVbLTMR":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn86@2020_4/2020/08/26/07-05-22-480_1ef721406618543b.webp","https://segmentfault.com/img/bVbLTMS":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn93@2020_2/2020/08/26/07-05-24-473_1674f4434d96f31b.webp","https://segmentfault.com/img/bVbLTMT":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn89@2020_4/2020/08/26/07-05-26-501_e7b9a96dc8b09fb3.webp","https://segmentfault.com/img/bVbLTMU":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn82@2020_3/2020/08/26/07-05-26-677_2a441441c99bd9fc.webp"},"publishedOrCreatedDate":1598425504662},{"createdTime":"2020-08-26 15:05:04","updatedTime":"2020-08-26 15:05:04","title":"思否独立开发者丨@卢灿伟：做死三个项目，累到生了一场大病，为何还要做独立开发者","link":"https://segmentfault.com/a/1190000023757704","description":"<p><img src=\"https://segmentfault.com/img/bVbLQng\" alt=\"思否独立开发者\" title=\"思否独立开发者\" /></p>\n<p>独立项目名称：说两句圈子</p>\n<p>思否社区ID：<a href=\"https://segmentfault.com/u/lucanwei\">@卢灿伟</a></p>\n<hr>\n <p>今天我们要介绍的独立开发者是@卢灿伟，他是一名从业13年的老开发者。没有上过大学也没有参加过成人高考，一直以高中毕业身份在职场中闯荡的他职业经历颇为艰难。</p>\n <p>2005年，他开始自学编程，2007年，他准备正式进入开发者行业，但因为学历低，投递的简历基本上都石沉大海。最后他想了个办法，通过传真机投递简历，这次灵机一动让一家公司的技术负责人注意到他的简历，并在后来成功入职这家公司。</p>\n <p>工作一年后，他觉得在这家本地海关软件公司已经没办法提升自己的技术了。正巧当时国内互联网技术正在飞快的发展，那一年京东还是叫「360buy」，看到同事从京东买了一台电脑后，他大为触动，觉得外面发展的很快，有很多机会，是时候离开这里，去一片更大的舞台。</p>\n <p>没有丝毫犹豫，@卢灿伟买了一张上海的单程票，开启了自己的沪漂生涯。接下来的2年时间，他不断提升着自己的技术能力，那一年安卓刚发布了1.5版本，他开始走向全栈工程师之路。也是那一段时间，他追赶了很多热点，做了很多项目，例如外卖、优惠券等，不幸的是这些项目都死掉了。</p>\n <p>他开始反思：「技术对于项目来说，短期时间内是否真的重要？」这次思考让他对技术的态度有了一个新的定义：「需要什么学什么，要根据不同情况选择当前最优方案。」</p>\n <h2>回归初心做一名独立开发者</h2>\n <p>随后他决定去深圳开始创业，事实证明对于任何资源都没有的他来说，这是十分困难的。</p>\n <p>创业期间他做死了三个项目，也让自己累到生了一场大病。不过最终有了不错的结果，新的项目得到了曝光，也有资金进来。</p>\n <p>但项目最终还是失败了，总结经验时他说自己「输给了人心」。当然这次失败经验不足也是重要原因，他决定去不同类型的公司看看，顺便学习经验。</p>\n <p>因为之前投资都是来自上海，所以他决定回到上海工作。之后的一段时间里，他去了一些天使轮，pre-A轮的公司工作，发现一个有意思的现象是「有的公司看起来非常不靠谱，却能以一种微妙的平衡状态维持着，而有的公司看起来很靠谱，却因为不为五斗米折腰导致公司倒闭。」随后他开始选择一些规模比较大的公司去工作，发现这些公司内耗极高，但是公司的业务却蒸蒸日上。</p>\n <p>有一次他发现公司楼下某商店的支付体验非常好，随即对这家支付公司产生了兴趣，了解到朋友是那家公司的，就决定「跳槽」过去。在经历了小型公司和大型公司后，这次他陪着这家公司从preA一直成长到C轮，期间经历了很多事情，也学习了很多。在经历一段时间组织架构调整和公司内部的一些问题后，他收到一封信，是5年前自己在厦门寄出的，收件人是5年后的自己。上面写道：「不忘初心。」</p>\n <p>之后赶上了疫情爆发，他选择了离开这家公司，并思考自己未来的方向——继续做一名独立开发者。</p>\n <p>@卢灿伟说：其实我觉得所谓的独立开发者，只是一个名词。你也可以叫他创业者、自由职业者。我觉得更重要的是你的选择。如果你在某个公司，那么你不能选择和你共事的人。但是你作为独立开发者你可以选择自己单干，或者你自己接项目做，选择你的合作伙伴。</p>\n <p>就算合作中有一些不愉快，那也是短期的。当然本质上还是希望自己做出来的产品能被大众认可，并且付费以此来达到养活自己。</p>\n <h2>说两句圈子</h2>\n <p>这个项目最初的出发点是年底有人找我帮他们介绍工作，我帮着内推了，最后他们也进到自己心仪的公司。我发现这里存在一个信息不对称的问题，你总不能在朋友圈发我要换工作，大家谁介绍一下。你可能会找你平时聊的还行的朋友问下，但是他们不一定能帮到你。</p>\n <p>所以我希望把线下的人脉搬到线上，建立一个虚拟社区。</p>\n <blockquote>\n  项目介绍：我希望打造一款可以让自由职业者、自媒体、小微品牌一个可以展示自己信息的平台，通过说两句你可以拥有一个属于你的多媒体名片，在这里你可以和你的粉丝、朋友在圈子进行互动，你也可以丰富你的信息，作为你的名片使用。如果你是一个群管理者，你还可以在这里添加你的群信息，让你的用户通过群信息入群。当然你还可能拥有自己的产品，你可以通过产品图册进行的产品展现，更多功能，敬请期待。\n  <br>立项日期：2019年12月<br>项目背景：因为我希望每个人都拥有属于他自己的迪士尼，让他的朋友们在这里收获快乐，谁都可以来说两句。<br>面向群体：自由职业者、自媒体、小微品牌等等</br></br></br>\n </blockquote>\n <p>“一千个人眼里有一千个哈姆雷特 ”</p>\n <p>如果你无法描述清楚你的产品，那么就做出来，告诉他们，你的产品长这样。</p>\n <p>第一件事，把你的产品具象化，比如你的产品长啥样，流程是什么。当然你可以直接从纸上画出来，不过我个人还是推荐figma，虽然最终界面可能跟界面会有一些出入，但原型最主要是的给你理清流程。</p>\n <p><img src=\"https://segmentfault.com/img/bVbLQoj\" alt=\"思否独立开发者\" title=\"思否独立开发者\" /></p>\n <p>然后用mindnode大概写了一下所包含的功能点，这里主要是想让你确认你的产品MVP到底是怎么样？不要把你的产品想得太大，没有什么产品是能一步到位的，都是一步步迭代过来的。虽然我上面写的我也感觉多了，但总比没局限的扩散好。</p>\n <p><img src=\"https://segmentfault.com/img/bVbLQom\" alt=\"思否独立开发者\" title=\"思否独立开发者\" /></p>\n <p>在确认后，就是开始编码的工作了。篇幅原因这里就不细谈了。</p>\n <h2>快问快答-产品相关问题</h2>\n <p><strong>1. 独立开发过程中遇到过哪些困难？最难搞定的是什么？</strong></p>\n <p>最困难的应该是作息和外部项目协调吧，如果你的项目不能给你带来收入，你就得通过其他手段去获取收入，但这样做就会挤占你的时间，导致你的项目停滞。</p>\n <p>另外就是需求验证的问题，你会发现你做之前的调研基本上没有用处，或者说你调研的方向不对，导致你做出的产品没人使用，或者你找不到你的使用人群。你只能不断的快速试错，一直找到那个可以持续迭代的方向。</p>\n <p><strong>2、项目目前取得了哪些成就？项目为你带来了什么？</strong></p>\n <p>目前最大的应该是认识了一批相同处境的人，项目也给自己带来了更多方面的思考，学习更多的东西，这些东西都是你处于一个标准的工作环境中无法学习到的。</p>\n <p><img src=\"https://segmentfault.com/img/bVbLQoQ\" alt=\"思否独立开发者\" title=\"思否独立开发者\" /></p>\n <p><strong>3、你的商业模式是什么？是如何增长的？</strong></p>\n <p>其实商业模式有很多种，但你还是得找到适合你的那一种。对于这类产品来说，在没有用户的加持下，一切的商业模式都是白谈。</p>\n <p>在做用户增长前，我觉得还是需要做好用户的验证，找到真正有需求的那批用户，去满足他们。</p>\n <p><strong>4、近阶段项目有哪些更新，未来会做什么变动？</strong></p>\n <p>最初的想法是从社区出发，但是实践下来发现对于大众来说并不会特意去维护一个社区，就算要做社区也会考虑现有的社区工具，比如微信圈子，除了基础的功能来说，还有一个天然的原因，有外部流量导入，作为一款新产品，就算功能上一模一样，但是缺少这块一样很难吸引用户。</p>\n <p>未来会持续加强个人信息这块，希望能给所有跟我处于一个阶段的独立开发者们提供一个展示面，方便大家去介绍自己，然后在建立自己的产品反馈社区。</p>\n <p><strong>5、如果项目重来一次你会做哪些改变？</strong></p>\n <p>并不会，人总是在不断学习，吸取教训。就算我避免了这些错误，将来的某一天他还是会出现，可能到时的代价就更大了。</p>\n <h2>快问快答-个人相关问题</h2>\n <p><strong>1、推荐你最喜欢的一款产品 / 游戏 / App？并说明原因</strong></p>\n <p>微信读书吧，我是个不爱看书的人，但是微信读书以朋友圈作为扩散，免费的模式。并且你能看到其他人的对书中内容的点评，对于内容来说，更多是讨论才能对书中内容有更深刻的了解，不会读完就忘。推荐可以让你找到更多优质图书，从而形成一个正向循环。</p>\n <p>而我的kindle只能拿来压泡面。</p>\n <p><strong>2、分享一下你的技术栈和你日常的工作流？</strong></p>\n <p>目前主要是Ruby on Rails和Java来做后端，看项目大小，自己的项目都偏向用Ruby on Rails来开发。</p>\n <p>前端主要用Taro + typescript来开发小程序</p>\n <p>移动端已经有蛮长时间没写了，之前安卓主要是Java和Kotlin，ios不是特别熟悉，小项目能用swift，如果有新的项目会考虑用Flutter去实现。</p>\n <ul>\n  <li>会用Timing去记录自己的工作时间</li>\n  <li>Api调试工具主要用Paw</li>\n  <li>数据库的话用TablePlus</li>\n  <li>原型制作主要用Figma</li>\n  <li>代码管理主要用Sourcetree，我个人不是特别喜欢用命令行去操作git</li>\n  <li>写作相关用Bear去管理所有文本和记录</li>\n  <li>滴答清单去记录一些待办事项</li>\n </ul>\n <p><img src=\"https://segmentfault.com/img/bVbLQo5\" alt=\"思否独立开发者\" title=\"思否独立开发者\" /></p>\n <p>3、对独立开发者或编程初学者有什么建议？</p>\n <p>如果你是希望在技术领域成为大牛，那么就不要考虑成为独立开发，专心在某一个领域加深经验和能力。</p>\n <p>独立开发更多的是技术以外的事情，全栈只是独立开发的起步。</p>\n <p>你可能还需要自己设计软件，做产品需求，推广产品，运营等等。这个时候技术反而不是最重要的。</p>\n <p>对于编程初学者来说，有目标的去学习。比如你要完成一个什么东西，比如我说要做一个app，然后跟着这个目标去学习，然后多看别人的代码，并尝试去改到符合你的需求。</p>\n <hr>\n  <p><img src=\"https://segmentfault.com/img/bVbI0cI\" alt=\"独立开发者支持计划-1.png\" title=\"独立开发者支持计划-1.png\" /></p>\n  <p>该内容栏目为「SFIDSP - 思否独立开发者支持计划」。为助力独立开发者营造更好的行业环境， SegmentFault 思否社区作为服务于开发者的技术社区，正式推出「思否独立开发者支持计划」，我们希望借助社区的资源为独立开发者提供相应的个人品牌、独立项目的曝光推介。</p>\n  <p>有意向的独立开发者或者独立项目负责人，可通过邮箱提供相应的信息（个人简介、独立项目简介、联系方式等），以便提升交流的效率。</p>\n  <p>联系邮箱：pr@segmentfault.com</p>\n  <p><img src=\"https://segmentfault.com/img/bVbLdWb\" alt=\"独立开发者\" title=\"独立开发者\" /></p>\n </hr>\n</hr>","descriptionType":"html","publishedDate":"Tue, 25 Aug 2020 07:08:46 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLQng","linkMd5":"a46a88887a82575a4b94ef2b05d0039a","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn25@2020_4/2020/08/26/07-05-16-721_7dc9b670912dae43.webp","destWidth":800,"destHeight":533,"sourceBytes":140743,"destBytes":61316,"author":"宗恩","articleImgCdnMap":{"https://segmentfault.com/img/bVbLQng":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn25@2020_4/2020/08/26/07-05-16-721_7dc9b670912dae43.webp","https://segmentfault.com/img/bVbLQoj":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn42@2020_4/2020/08/26/07-05-25-481_7b10e2b347bf6ff9.webp","https://segmentfault.com/img/bVbLQom":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn46@2020_1/2020/08/26/07-05-25-642_e74e9d57e6e307b1.webp","https://segmentfault.com/img/bVbLQoQ":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn37@2020_2/2020/08/26/07-05-24-244_6fec84a0b1b16266.webp","https://segmentfault.com/img/bVbLQo5":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn48@2020_3/2020/08/26/07-05-24-102_47f6ade666da5352.webp","https://segmentfault.com/img/bVbI0cI":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn34@2020_2/2020/08/26/07-05-25-483_798e5167cf3865a4.webp","https://segmentfault.com/img/bVbLdWb":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn29@2020_5/2020/08/26/07-05-24-495_9cb2807ae485c12a.webp"},"publishedOrCreatedDate":1598425504662}],"record":{"createdTime":"2020-08-26 15:05:04","updatedTime":"2020-08-26 15:05:04","feedId":6615,"fetchDate":"Wed, 26 Aug 2020 07:05:04 +0000","fetchMs":5065,"handleMs":6724,"totalMs":36120,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"c38726fefc3aa4445f75f64d0364b5db","hostName":"europe-23*","requestId":"cc7bc9be9d3d4e509363a769f911d2d9_6615","contentType":"application/atom+xml; charset=UTF-8","totalBytes":964802,"bgimgsTotal":2,"bgimgsGithubTotal":2,"articlesImgsTotal":22,"articlesImgsGithubTotal":22,"successGithubMap":{"myreaderx14":1,"myreaderx25":1,"myreaderx8":1,"myreaderx15":1,"myreaderx6":1,"myreaderx27":1,"myreaderx10":1,"myreaderx21":1,"myreaderx4":1,"myreaderx32":1,"myreaderx22":1,"myreaderx3":1,"myreaderx33":1,"myreaderx12":1,"myreaderx2":1,"myreaderx23":1,"myreaderx13":1,"myreaderx24":1,"myreaderx5oss":1,"myreaderx29":1,"myreaderx19":1,"myreaderx":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:33:08","updatedTime":"2020-08-25 07:11:24","id":6615,"name":"SegmentFault 最新的文章","url":"http://segmentfault.com/feeds/blogs","subscriber":null,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"https://segmentfault.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":127962,"tmpBodyImgCdnBytes":836840,"tmpBgImgCdnBytes":0,"extra4":{"start":1598425491703,"total":0,"statList":[{"spend":6235,"msg":"获取xml内容"},{"spend":6724,"msg":"解释文章"},{"spend":1,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":6800,"msg":"正文链接上传到cdn"}]},"extra5":22,"extra6":22,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-032.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe65.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-028.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-035.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe66.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-024.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-020.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-25.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe69.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-54.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe62.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-036.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-57.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-016.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-040.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-012.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLQng","sourceStatusCode":200,"destWidth":800,"destHeight":533,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn25@2020_4/2020/08/26/07-05-16-721_7dc9b670912dae43.webp","sourceBytes":140743,"destBytes":61316,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3561,"convertSpendMs":20,"createdTime":"2020-08-26 15:05:14","host":"europe-25*","referer":"https://segmentfault.com/a/1190000023757704","linkMd5ListStr":"a46a88887a82575a4b94ef2b05d0039a,a46a88887a82575a4b94ef2b05d0039a","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"137.4 KB","destSize":"59.9 KB","compressRate":"43.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTMx","sourceStatusCode":200,"destWidth":800,"destHeight":498,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn21@2020_6/2020/08/26/07-05-20-087_c15342b0eb94a58b.webp","sourceBytes":92093,"destBytes":66646,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":6463,"convertSpendMs":43,"createdTime":"2020-08-26 15:05:14","host":"us-012*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1,9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"89.9 KB","destSize":"65.1 KB","compressRate":"72.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTMR","sourceStatusCode":200,"destWidth":800,"destHeight":309,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn86@2020_4/2020/08/26/07-05-22-480_1ef721406618543b.webp","sourceBytes":126470,"destBytes":46384,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2299,"convertSpendMs":26,"createdTime":"2020-08-26 15:05:21","host":"us-012*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"123.5 KB","destSize":"45.3 KB","compressRate":"36.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTML","sourceStatusCode":200,"destWidth":800,"destHeight":410,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn71@2020_3/2020/08/26/07-05-23-562_3e4534db9ccd187b.webp","sourceBytes":33154,"destBytes":37838,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3596,"convertSpendMs":32,"createdTime":"2020-08-26 15:05:21","host":"europe-57*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"32.4 KB","destSize":"37 KB","compressRate":"114.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLQoQ","sourceStatusCode":200,"destWidth":800,"destHeight":567,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn37@2020_2/2020/08/26/07-05-24-244_6fec84a0b1b16266.webp","sourceBytes":101191,"destBytes":41482,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3971,"convertSpendMs":24,"createdTime":"2020-08-26 15:05:21","host":"us-028*","referer":"https://segmentfault.com/a/1190000023757704","linkMd5ListStr":"a46a88887a82575a4b94ef2b05d0039a","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"98.8 KB","destSize":"40.5 KB","compressRate":"41%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTMC","sourceStatusCode":200,"destWidth":160,"destHeight":100,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn61@2020_6/2020/08/26/07-05-24-437_ff4472783ef723d7.webp","sourceBytes":4711,"destBytes":4738,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4010,"convertSpendMs":32,"createdTime":"2020-08-26 15:05:21","host":"us-020*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"4.6 KB","destSize":"4.6 KB","compressRate":"100.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLQo5","sourceStatusCode":200,"destWidth":800,"destHeight":600,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn48@2020_3/2020/08/26/07-05-24-102_47f6ade666da5352.webp","sourceBytes":217560,"destBytes":62520,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4238,"convertSpendMs":23,"createdTime":"2020-08-26 15:05:21","host":"europe66*","referer":"https://segmentfault.com/a/1190000023757704","linkMd5ListStr":"a46a88887a82575a4b94ef2b05d0039a","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"212.5 KB","destSize":"61.1 KB","compressRate":"28.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTMy","sourceStatusCode":200,"destWidth":800,"destHeight":473,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn2@2020_3/2020/08/26/07-05-24-359_aceb5a25e60de04f.webp","sourceBytes":276399,"destBytes":90700,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4162,"convertSpendMs":39,"createdTime":"2020-08-26 15:05:21","host":"us-028*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"269.9 KB","destSize":"88.6 KB","compressRate":"32.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTMS","sourceStatusCode":200,"destWidth":240,"destHeight":240,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx23/cdn93@2020_2/2020/08/26/07-05-24-473_1674f4434d96f31b.webp","sourceBytes":19386,"destBytes":28378,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4487,"convertSpendMs":38,"createdTime":"2020-08-26 15:05:21","host":"europe62*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx23","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.9 KB","destSize":"27.7 KB","compressRate":"146.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLdWb","sourceStatusCode":200,"destWidth":800,"destHeight":340,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn29@2020_5/2020/08/26/07-05-24-495_9cb2807ae485c12a.webp","sourceBytes":205827,"destBytes":64422,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4646,"convertSpendMs":18,"createdTime":"2020-08-26 15:05:21","host":"europe62*","referer":"https://segmentfault.com/a/1190000023757704","linkMd5ListStr":"a46a88887a82575a4b94ef2b05d0039a","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"201 KB","destSize":"62.9 KB","compressRate":"31.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTMz","sourceStatusCode":200,"destWidth":800,"destHeight":245,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn97@2020_2/2020/08/26/07-05-25-502_459fb3ef1e9e57c7.webp","sourceBytes":73867,"destBytes":37136,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":5119,"convertSpendMs":17,"createdTime":"2020-08-26 15:05:21","host":"us-040*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"72.1 KB","destSize":"36.3 KB","compressRate":"50.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTMJ","sourceStatusCode":200,"destWidth":800,"destHeight":318,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn66@2020_6/2020/08/26/07-05-25-384_ffe94cfa1aa215dd.webp","sourceBytes":154649,"destBytes":52030,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":5110,"convertSpendMs":35,"createdTime":"2020-08-26 15:05:21","host":"us-035*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"151 KB","destSize":"50.8 KB","compressRate":"33.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbEDzY","sourceStatusCode":200,"destWidth":800,"destHeight":704,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn6@2020_4/2020/08/26/07-05-25-480_29e4764d69dfabe1.webp","sourceBytes":169066,"destBytes":22000,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":5150,"convertSpendMs":41,"createdTime":"2020-08-26 15:05:21","host":"us-016*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"165.1 KB","destSize":"21.5 KB","compressRate":"13%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbI0cI","sourceStatusCode":200,"destWidth":800,"destHeight":189,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn34@2020_2/2020/08/26/07-05-25-483_798e5167cf3865a4.webp","sourceBytes":60294,"destBytes":60294,"feedId":6615,"totalSpendMs":5221,"convertSpendMs":0,"createdTime":"2020-08-26 15:05:21","host":"us-040*","referer":"https://segmentfault.com/a/1190000023757704","linkMd5ListStr":"a46a88887a82575a4b94ef2b05d0039a","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"58.9 KB","destSize":"58.9 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLQoj","sourceStatusCode":200,"destWidth":800,"destHeight":508,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn42@2020_4/2020/08/26/07-05-25-481_7b10e2b347bf6ff9.webp","sourceBytes":261057,"destBytes":27472,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":5216,"convertSpendMs":42,"createdTime":"2020-08-26 15:05:21","host":"us-016*","referer":"https://segmentfault.com/a/1190000023757704","linkMd5ListStr":"a46a88887a82575a4b94ef2b05d0039a","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"254.9 KB","destSize":"26.8 KB","compressRate":"10.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTMK","sourceStatusCode":200,"destWidth":800,"destHeight":274,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn76@2020_4/2020/08/26/07-05-25-477_9602d32b8493caf0.webp","sourceBytes":103508,"destBytes":43342,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":5267,"convertSpendMs":37,"createdTime":"2020-08-26 15:05:21","host":"us-036*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"101.1 KB","destSize":"42.3 KB","compressRate":"41.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTMI","sourceStatusCode":200,"destWidth":800,"destHeight":195,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn68@2020_4/2020/08/26/07-05-25-443_46af042654132ee8.webp","sourceBytes":69006,"destBytes":25410,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":5551,"convertSpendMs":15,"createdTime":"2020-08-26 15:05:21","host":"europe69*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"67.4 KB","destSize":"24.8 KB","compressRate":"36.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLQom","sourceStatusCode":200,"destWidth":596,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn46@2020_1/2020/08/26/07-05-25-642_e74e9d57e6e307b1.webp","sourceBytes":66604,"destBytes":30342,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":5583,"convertSpendMs":21,"createdTime":"2020-08-26 15:05:21","host":"europe65*","referer":"https://segmentfault.com/a/1190000023757704","linkMd5ListStr":"a46a88887a82575a4b94ef2b05d0039a","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"65 KB","destSize":"29.6 KB","compressRate":"45.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTME","sourceStatusCode":200,"destWidth":240,"destHeight":193,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn53@2020_5/2020/08/26/07-05-26-440_fb90d9bb0972662e.webp","sourceBytes":74222,"destBytes":8544,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":6182,"convertSpendMs":6,"createdTime":"2020-08-26 15:05:21","host":"us-54*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"72.5 KB","destSize":"8.3 KB","compressRate":"11.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTMU","sourceStatusCode":200,"destWidth":536,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn82@2020_3/2020/08/26/07-05-26-677_2a441441c99bd9fc.webp","sourceBytes":207369,"destBytes":59216,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":6364,"convertSpendMs":261,"createdTime":"2020-08-26 15:05:21","host":"us-024*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"202.5 KB","destSize":"57.8 KB","compressRate":"28.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTMD","sourceStatusCode":200,"destWidth":800,"destHeight":288,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn58@2020_4/2020/08/26/07-05-26-816_5b9d829a3c8d3cc1.webp","sourceBytes":124400,"destBytes":43096,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":6516,"convertSpendMs":241,"createdTime":"2020-08-26 15:05:21","host":"us-032*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"121.5 KB","destSize":"42.1 KB","compressRate":"34.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLTMT","sourceStatusCode":200,"destWidth":800,"destHeight":537,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn89@2020_4/2020/08/26/07-05-26-501_e7b9a96dc8b09fb3.webp","sourceBytes":182670,"destBytes":51496,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":6791,"convertSpendMs":42,"createdTime":"2020-08-26 15:05:21","host":"europe-25*","referer":"https://segmentfault.com/a/1190000023769855","linkMd5ListStr":"9c3b09b7b3a439d2eecc3a77bb5d5df1","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"178.4 KB","destSize":"50.3 KB","compressRate":"28.2%"}],"successGithubMap":{"myreaderx14":1,"myreaderx25":1,"myreaderx8":1,"myreaderx15":1,"myreaderx6":1,"myreaderx27":1,"myreaderx10":1,"myreaderx21":1,"myreaderx4":1,"myreaderx32":1,"myreaderx22":1,"myreaderx3":1,"myreaderx33":1,"myreaderx12":1,"myreaderx2":1,"myreaderx23":1,"myreaderx13":1,"myreaderx24":1,"myreaderx5oss":1,"myreaderx29":1,"myreaderx19":1,"myreaderx":1},"failGithubMap":{}}