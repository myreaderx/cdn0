{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-08-26 15:23:34","updatedTime":"2020-08-26 15:23:34","title":"从API网关的去中心化到ServiceMesh分布式服务治理(200826)","link":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","description":"<a HREF=\"http://album.sina.com.cn/pic/001l8XD7zy7FVHnKRnIf2\" TARGET=\"_blank\"><img SRC=\"http://s3.sinaimg.cn/mw690/001l8XD7zy7FVHnKRnIf2&#38;690\" NAME=\"image_operate_34721598400426364\" /></A>\n<div><br /></DIV>\n<div>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在前面文章我们已经介绍到，API网关本身仍然是中心化的，那么对API网关是否可能进一步去中心化处理，当我们对该点进行思考的时候，发现去中心化后的API网关核心能力，更多的会迁移到ServiceMesh服务网格里面去实现。</P>\n<h1 STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-size: 24px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding: 0px; border: 0px; line-height: 32px; color: rgb(34, 34, 34); position: relative; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\" MARGIN-TOP:=\"\">\nAPI网关概述</H1>\n<div STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 16px; line-height: 28px; color: rgb(34, 34, 34); overflow-wrap: break-word; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\"><img SRC=\"https://p1-tt.byteimg.com/origin/pgc-image/47666275792a4d8f9a61cca916ef0be7?from=pc\" IMG_WIDTH=\"725\" IMG_HEIGHT=\"392\" ALT=\"从API网关的去中心化到ServiceMesh分布式服务治理\" INLINE=\"0\" STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 10px auto; padding: 0px; max-width: 100%; display: block;\" />\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px;\">\n&#160;</P>\n</DIV>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在微服务架构体系里面，我们一般会使用到微服务网关或叫API网关。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n大家都比较清楚，在微服务架构体系下本身是去中心化的架构，通过服务注册中心来实现服务注册发现和消费调用，那么为何又需要使用API网关？</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在传统的ESB总线进行服务集成的时候我们就经常谈到一个概念就是位置透明，即需要屏蔽底的业务模块提供API接口服务地址信息，并实现多个微服务API接口的统一出口。即类似设计模式里面经常谈到的门面模式。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n如何给API网关一个定义？</SPAN></P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n简单来说API网关就是将所有的微服务提供的API接口服务能力全部汇聚进来，统一接入进行管理，也正是通过统一拦截，就可以通过网关实现对API接口的安全，日志，限流熔断等共性需求。如果再简单说下，通过网关实现了几个关键能力。</P>\n<ul STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 20px 30px; padding: 0px; list-style-position: outside; list-style-image: initial; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n内部的微服务对外部访问来说位置透明，外部应用只需和网关交互</SPAN></LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n统一拦截接口服务，实现安全，日志，限流熔断等需求</SPAN></LI>\n</UL>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n从这里，我们就可以看到API网关本身仍然是中心化的架构，由于需要实现统一的日志，安全和限流熔断处理，那么所有的请求，消息输入输出全部需要进入API网格的总线管道。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n那么对于微服务架构，为何我们经常会谈到是一种去中心化架构。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在前面我们也谈到过，微服务架构体系里面，API接口交互实际提供两种方式，一种是走服务注册中心的注册发现，一种是走API网格。而对于服务注册中心方式本身是一种完全去中心化的架构模式，即使注册中心宕机，往往也不会直接影响到API接口交互和服务运行。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n对于API网关的详细描述可以参考前面的一篇文章：</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<a HREF=\"https://www.toutiao.com/i6862494582203122189/?group_id=6862494582203122189\" TARGET=\"_blank\">\n一文详细讲解API网关核心功能和API管理扩展</A></P>\n<h1 STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-size: 24px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding: 0px; border: 0px; line-height: 32px; color: rgb(34, 34, 34); position: relative; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\" MARGIN-TOP:=\"\">\n服务注册中心和API网关实现对比</H1>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在这里，我们还是举例来说明两种方式的区别点。</P>\n<blockquote STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 1em 0px; padding: 0px 0px 0px 16px; border-top: none; border-right: none; border-bottom: none; border-left: 4px solid rgb(232, 232, 232); border-image: initial; quotes: none; position: relative; font-size: 16px; line-height: 1.5; color: rgb(112, 112, 112); background: rgb(255, 255, 255); border-radius: 4px; text-align: justify; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\">\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px;\">\n比如我们当前有两个微服务模块，一个是订单中心，一个是供应商中心，订单中心在订单制作的过程中需要访问供应商中心提供的API接口服务获取供应商信息。</P>\n</BLOCKQUOTE>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在这种场景下，如果是采用注册中心，整个交互过程如下。</P>\n<div STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 16px; line-height: 28px; color: rgb(34, 34, 34); overflow-wrap: break-word; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\"><img SRC=\"https://p6-tt.byteimg.com/origin/pgc-image/fe32e7034e264589891e8b2250f9b9d0?from=pc\" IMG_WIDTH=\"778\" IMG_HEIGHT=\"371\" ALT=\"从API网关的去中心化到ServiceMesh分布式服务治理\" INLINE=\"0\" STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 10px auto; padding: 0px; max-width: 100%; display: block;\" />\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px;\">\n&#160;</P>\n</DIV>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在该图上可以看到，服务注册中心核心能力为服务注册和发现，最多再承担一个负载均衡能力，而实际的接口服务调用仍然是点对点调用，即我们常说的整个消息的输入和输出数据流没有通过服务注册中心。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n由于消息报文没有过注册中心，那么我们前面谈到的需要通过拦截实现的安全，流控，日志审计等能力自然无法实现。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在这种架构下为何可以称为去中心化的架构，主要体现在两点。</P>\n<ul STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 20px 30px; padding: 0px; list-style-position: outside; list-style-image: initial; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n注册中心本身不走数据流，其性能负荷很小，能够承担高并发访问</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n地址信息往往可以在消费端缓存，因此注册中心短暂宕机并不影响接口访问</LI>\n</UL>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n如果要对API接口实现更加完全的管控能力，即我们需要将API接口服务注册到API网关进行管理，通过API网关来进行日志，安全，限流熔断的统一管控治理。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n还是基于上面的场景，通过API网关接入和访问示意如下：</P>\n<div STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 16px; line-height: 28px; color: rgb(34, 34, 34); overflow-wrap: break-word; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\"><img SRC=\"https://p1-tt.byteimg.com/origin/pgc-image/5dfee33e43324044ace6260790444d96?from=pc\" IMG_WIDTH=\"775\" IMG_HEIGHT=\"340\" ALT=\"从API网关的去中心化到ServiceMesh分布式服务治理\" INLINE=\"0\" STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 10px auto; padding: 0px; max-width: 100%; display: block;\" />\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px;\">\n&#160;</P>\n</DIV>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n从这个图可以看到最大的一个变化就是所有的数据流全部都会经过API网关的管道，因此我们才能够实现服务访问代理，各种安全，日志，流控的插件能力。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n即在API网关中心化的架构下，最核心的即是上图里面的黄色小方块。这些黄色小方块可以理解为一个个的独立拦截插件，通过这些插件来实现进一步的管控治理能力。</P>\n<h1 STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-size: 24px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding: 0px; border: 0px; line-height: 32px; color: rgb(34, 34, 34); position: relative; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\" MARGIN-TOP:=\"\">\n对API网关的去中心化处理</H1>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n通过前面分析可以看到，服务注册中心本身是去中心化的，但是API网关本身是中心化，而API网关本身的中心化最重要的又是对API接口报文的消息拦截，来实现安全，日志，限流等各种接口管控要求。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n那么如何既能够实现去中心化，又能够满足对API接口的治理管控要求？</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n自然，我们最重要想到的就是将服务注册中心和API网关两者的能力结合，既我们可以将上图API网关中各种拦截插件的能力下沉到微服务模块中去实现，在各个微服务模块中配置一个SDK包来完成各种管控能力。</P>\n<blockquote STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 1em 0px; padding: 0px 0px 0px 16px; border-top: none; border-right: none; border-bottom: none; border-left: 4px solid rgb(232, 232, 232); border-image: initial; quotes: none; position: relative; font-size: 16px; line-height: 1.5; color: rgb(112, 112, 112); background: rgb(255, 255, 255); border-radius: 4px; text-align: justify; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\">\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px;\">\n讲到这里，大家可能会看到，这个实际和ServiceMesh里面谈到的SideCar完全是一个道理，既管控能力下沉到各个微服务模块中去，实现彻底的去中心化。</P>\n</BLOCKQUOTE>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n基于以上思考，我们对整个过程实现构图进行修改如下：</P>\n<div STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 16px; line-height: 28px; color: rgb(34, 34, 34); overflow-wrap: break-word; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\"><img SRC=\"https://p3-tt.byteimg.com/origin/pgc-image/f2e93b9d6a0a49ed813cce4747536b58?from=pc\" IMG_WIDTH=\"779\" IMG_HEIGHT=\"350\" ALT=\"从API网关的去中心化到ServiceMesh分布式服务治理\" INLINE=\"0\" STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 10px auto; padding: 0px; max-width: 100%; display: block;\" />\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px;\">\n&#160;</P>\n</DIV>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n基于上图可以看到，我们将API网关的核心能力打包为一个独立的SDK包，类似SideCar的方式下沉到各个微服务模块中去。在前面的文章里面我们曾经谈到过，去中心化的一个核心思路就是在微服务架构实施过程中，结合容器化自动化部署过去，在微服务模块部署的时候，自动在容器里面同时部署相应的SDK代理包。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n这个SDK代理包将传统的服务网关能力下沉到微服务模块本地化容器中去实现和执行。在这个构图中我们仍然保留服务注册中心来实现服务注册发现，同时本地的SDK服务代理包具备相应的缓存能力，即在服务注册中心宕机的时候仍然可以读取本地缓存信息进行服务地址获取和访问。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n本地的SDK包是一个本地化的JAR包，我们可以在JAR包里面对Http\nRest接口的访问和消费进一步封装，将其封装为本地API方法，同时在本地API方法中进行类似安全，日志等方面内容的拦截处理。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在这种实现方法下，我们可以看下整个服务调用过程。</P>\n<ol START=\"1\" STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 20px 30px; padding: 0px; list-style-position: outside; list-style-image: initial; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n订单中心微服务调用服务代理SDK包中的GetVendorInfo方法</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\nSDK包获取到调用请求后，调用服务注册中心，获取GetVendorInfo的Rest接口地址</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\nSDK包发起对远程Http Rest API接口方法的调用并返回结果</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\nSDK包模块对返回的结果进行序列化或反序列化处理。</LI>\n</OL>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在整个过程中还可以在SDK包中添加安全，日志，流控等各种拦截器插件实现进一步的控制和处理。基于这个基础流程，我们来看实际的服务网关的关键能力实现。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n服务代理能力</SPAN></P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n订单中心微服务模块只能看到本地SDK包的查询供应商API方法，而看不到具体的远程调用地址，而远程调用地址是SDK包通过动态查询服务注册库获取到后，再发起的调用。也就是说在去中心化架构下，传统服务网关的服务代理层前置到了本地微服务模块容器中的SDK代理包。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n负载均衡和路由转发能力</SPAN></P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\nSDK包中本身也不存储具体的远程服务访问地址，而是告诉服务中心我们需要访问哪个服务，服务中心根据服务编码或名称返回具体服务的访问地址，如果一个服务在服务中心注册有多个可访问地址，那么服务中心就可以实现最简单的负载均衡能力。即实际的负载均衡在服务注册中心实现。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n第二种方法是SDK包调用服务注册中心后，服务注册中心把所有可访问的服务地址全部返回给SDK包，由SDK包在进行负载均衡算法选择和路由。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n可以看到第一种方法往往更好，因为一个接口服务往往有多个微服务模块都在消费和调用，第二种方法是无法真正做到完全的负载均衡的。但是第一种方法仍然存在问题就是会增加服务注册中心的计算负荷。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n日志和监控能力</SPAN></P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在这种架构下，本地的SDK包是完全可以拦截到具体的服务输入和服务输出信息的，而且在这种去中心化的架构下还可以做到对于A模块和B模块各自本地的SDK包分别拦截到服务的输入和输出，以方面后续的日志审计。在SDK包拦截到服务日志后，在这里需要通过另外一个JMS\nAPI接口，将日志信息通过异步消息的模式写入到JMS消息中间件中，然后再通过消息中间件对日志进行相关的持久化处理。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n如果写JMS消息中间件报错，我们可以对异常信息直接写入到本地的磁盘文件中，在JMS消息中间件恢复后再重新写回到消息中间件中。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n限流和流量控制</SPAN></P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n首先还是需要在服务注册中心设置相应的限流策略，然后将限流策略分发到本地的SDK包中，本地的SDK包对服务调用次数，时间等信息进行计算统计，并将计算统计信息仅缓存，同时对缓存的数据进行实时计算，当满足流量控制策略的时候，则对服务进行限流。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n由于在订单中心，供应商中心两个微服务模块我们都部署了服务代理SDK包，因此也很容易实现类似服务总线的输入端限流和提供端限流的双向限流能力。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n服务访问安全控制</SPAN></P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n如果一个服务没有进行授权，首先可以做到SDK包在获取服务地址信息的时候就返回安全校验不通过，实现最基本的服务访问鉴权。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n那我们再来看额外的服务访问控制场景，基础的需要做到的就是基于IP地址的服务访问控制，只有授权的IP地址才能够访问服务。在这里也是同样的道理，需要将IP访问控制策略信息下发到服务代理SDK包中。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n同时在去中心化的架构下我们也很容易实现类似动态Token的访问安全控制，比如在A模块，我们完全可以在A模块发起调用的时候通过传递业务系统ID，日期，再传递一个计算出来的MD5码值到服务提供端。提供端根据通用的算法也计算MD5码值，只有当两个值匹配的时候才认为校验通过。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在去中心化的架构下，可以看到仍然保留了中心化的服务注册中心，同时对于一些管控需要的基础配置元数据也需要在服务注册中心完成。对于各种配置元数据，我们需要实时下发到各个微服务模块。因此最好的做法技术在各个微服务模块都实现一个JMS消息订阅接口，通过消息发布订阅的模式实时下发消息。</P>\n<h1 STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-size: 24px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding: 0px; border: 0px; line-height: 32px; color: rgb(34, 34, 34); position: relative; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\" MARGIN-TOP:=\"\">\n将去中心化的注册中心提升为控制中心</H1>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n结合上个小节的内容，在去中心化的架构下，原来API网关中的各种拦截插件能力全部下沉到了各个微服务模块的SDK包中。但是SDK包中的日志，安全，限流等各种插件拦截能力，仍然还是需要有一个集中化的控制中心实现集中管控。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n即我们常说的虽然数据流实现点对点，但是控制流仍然需要集中化。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n其次，如果我们在去中心化的架构下仍然需要实现对Log日志的Trace监控能力，那么就需要对日志进行集中化的采集和存储，这个看起来好像破坏了前面谈到的去中心化思路，但是里面最关键的一点就是日志信息的采集本身通过消息中间件进行。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n而我们常说的控制能力有哪些呢？</P>\n<ul STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 20px 30px; padding: 0px; list-style-position: outside; list-style-image: initial; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n服务注册和发现能力</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n日志拦截和日志查询，审计能力</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n访问安全和安全管控能力</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n限流熔断能力</LI>\n</UL>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n而这些能力也就是我们常说的API网关核心的能力。在这里我们看到一个关键点，即下沉到微服务模块里面的SDK包更多的是进行执行和控制，但是相关规则策略的提供仍然是需要有一个统一的控制中心来进行提供。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n控制中心提供这些能力，返回相应的控制策略给SDK包，SDK包执行控制。而控制中心提供这些能力本身即需要提供相应的元数据配置库，规则策略库。而对于日志审计的功能，还需要提供相应的分布式日志存储库。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n因此我们重新构图如下：</P>\n<div STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 16px; line-height: 28px; color: rgb(34, 34, 34); overflow-wrap: break-word; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\"><img SRC=\"https://p6-tt.byteimg.com/origin/pgc-image/79fd8c88f83a405e9c32e6a2a51c5fc2?from=pc\" IMG_WIDTH=\"774\" IMG_HEIGHT=\"380\" ALT=\"从API网关的去中心化到ServiceMesh分布式服务治理\" INLINE=\"0\" STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 10px auto; padding: 0px; max-width: 100%; display: block;\" />\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px;\">\n&#160;</P>\n</DIV>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n到了这里我们基本形成一个去中心化的API网关雏形。</P>\n<blockquote STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 1em 0px; padding: 0px 0px 0px 16px; border-top: none; border-right: none; border-bottom: none; border-left: 4px solid rgb(232, 232, 232); border-image: initial; quotes: none; position: relative; font-size: 16px; line-height: 1.5; color: rgb(112, 112, 112); background: rgb(255, 255, 255); border-radius: 4px; text-align: justify; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\">\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px;\">\n注：对于常规的微服务架构，比如SpringCloud整个架构体系，可以看到由于存在zuul等中心化的网关导致整个微服务架构仍然不是完全去中心化的。而到了SericeMesh服务化网关阶段，真正实现了完全的去中心化，包括SericeMesh思想实现的分布式微服务架构体系Istio，也可以看到上图已经和Istio整个架构思路很类似。</P>\n</BLOCKQUOTE>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n为了真正实现完全的去中心化，我们再来看下几个关键点。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n消息日志的存储和查询</SPAN></P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n消息日志在微服务模块获取后通过消息中间件异步写入到持久化存储。如果消息中间件本身不可用，那么消息日志可以先写入到本地存储文件，待恢复后再重试写入。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n限流和熔断</SPAN></P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在前面我们谈到过限流熔断实现思路和滑动时间窗口，在去中心化架构下，可以是1到2小时的最终统计数据全部缓存在本地用于限流熔断控制规则计算，那么这种情况下即使控制中心出现问题也不会影响到限流熔断规则的执行。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n安全策略控制</SPAN></P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n安全策略控制在通过API接口获取后，可以设置具体的失效时间，在失效前仍然是可以通过缓存获取，或者安全策略本身也可以在微服务模块本地存储文件进行临时存储。</P>\n<h1 STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-size: 24px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding: 0px; border: 0px; line-height: 32px; color: rgb(34, 34, 34); position: relative; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\" MARGIN-TOP:=\"\">\n完全去中心化的ServiceMesh</H1>\n<div STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 16px; line-height: 28px; color: rgb(34, 34, 34); overflow-wrap: break-word; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\"><img SRC=\"https://p3-tt.byteimg.com/origin/pgc-image/f65f02c9a1484afda58cabdf89058076?from=pc\" IMG_WIDTH=\"781\" IMG_HEIGHT=\"495\" ALT=\"从API网关的去中心化到ServiceMesh分布式服务治理\" INLINE=\"0\" STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 10px auto; padding: 0px; max-width: 100%; display: block;\" />\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px;\">\n&#160;</P>\n</DIV>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n根据Linkerd CEO William Morgan定义，Service\nMesh是用于处理服务间通信的基础设施层，用于在云原生应用复杂的服务拓扑中实现可靠的请求传递。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在实践中，Service Mesh通常是一组与应用一起部署，但对应用透明的轻量级网络代理。Service\nMesh与传统基础设施的不同之处在于，它形成了一个分布式的互连代理网络，以sidecar形式部署在服务两侧，服务对于代理无感知，且服务间所有通信都由代理进行路由。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n为什么需要Service Mesh</SPAN></P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n首先我们看下服务和进程间通信，除了完成基本的消息交互外，还需要关注服务注册发现，代理，路由，流量控制，安全，日志等共性的技术问题。而这些共性技术问题，在前面我们谈微服务架构的时候谈到过，这些不是服务注册中心能够全部解决的，更多的是依赖于微服务网关或API网关来解决这些共性问题。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n通过API网关解决这些共性问题是当前的一种主流做法，而这种做法唯一的问题点在哪里呢？即API网关本身又变成了我们微服务架构中的一个中心点，即整个架构体系不再是完全去中心化的架构体系，API网关变成了一个中心点，那么就存在单点故障可能，存在性能瓶颈可能等。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n而Service\nMesh服务网格可以理解为API网关能力本身下沉到我们实际的服务两侧进行部署，即在部署微服务模块的机器上同时部署ServiceMesh服务网格能力，以达到完全去中心化的目的。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在服务发现模式我们曾经谈到过，一种是类似API网关来实现完全的集中化管理，还有就是客户端嵌入代理和主机独立进程代理模式。而Service\nMesh网格是主机独立进程代理模式，即虽然和微服务模块一样部署在服务两侧，但是并不和微服微模块一起打包进行部署，是独立进程部署。即在一个Server上，可以多个微服务共享一个Service\nMesh网格代理端。</P>\n<div STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 16px; line-height: 28px; color: rgb(34, 34, 34); overflow-wrap: break-word; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\"><img SRC=\"https://p6-tt.byteimg.com/origin/pgc-image/6f5579c0d3ba44b5b27e8dead11ceab7?from=pc\" IMG_WIDTH=\"851\" IMG_HEIGHT=\"403\" ALT=\"从API网关的去中心化到ServiceMesh分布式服务治理\" INLINE=\"0\" STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 10px auto; padding: 0px; max-width: 100%; display: block;\" />\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px;\">\n&#160;</P>\n</DIV>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\nService Mesh由data\nplane构成，其中所有服务通过sidecar代理进行服务通信。（所有代理相互连接形成一个Mesh，Service\nMesh由此得名）网格同时包含一个control\nplane——可以将所有独立的sidecar代理连接到一个分布式网络中，并设置网格还包括一个控制平面——它将所有独立的sidecar代理连接到一个分布式网络中，并设置由data\nplane指定的策略。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n对于ServiceMesh可以理解为在我们部署一个或多个微服务模块的独立Server上，都会同时部署一个Sidecar代理，可以一个业务模块或多个业务模块共享一个代理。代理除了负责服务发现和负载均衡，还负责动态路由、容错限流、监控度量和安全日志等功能，这些功能是具体业务无关的。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n可以看到ServiceMesh思路完全和我们前面谈到的API网关的去中心化思路是一致的，即将各种拦截插件能力下沉到微服务模块的SideCar里面。具体如下：</P>\n<div STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 16px; line-height: 28px; color: rgb(34, 34, 34); overflow-wrap: break-word; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\"><img SRC=\"https://p1-tt.byteimg.com/origin/pgc-image/db81873265e2459eaa8ebd016f69e352?from=pc\" IMG_WIDTH=\"771\" IMG_HEIGHT=\"400\" ALT=\"从API网关的去中心化到ServiceMesh分布式服务治理\" INLINE=\"0\" STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 10px auto; padding: 0px; max-width: 100%; display: block;\" />\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px;\">\n&#160;</P>\n</DIV>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n如果微服务模块全部是通过Kubernetes部署到Docker容器里面，那么我们可以看到完全可以在k8s进行镜像制作和容器部署的时候将SideCar的内容附加到具体的部署包里面实现集成。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n简单来说，就是：</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n我们在开发微服务模块的时候完全不需要考虑太多的分布式API接口集成交互，但是和Kubernetes和Service\nMesh集成后就具备了分布式接口调用和集成的能力。同时也具备了对API接口的安全，日志，限流熔断的管理能力。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n因此也常说，Service Mesh是Kubernetes支撑微服务能力拼图的最后一块。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n&#160;</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在为什么 kubernetes\n天然适合微服务中我们提到，Kubernetes是一个奇葩所在，他的组件复杂，概念复杂，在没有实施微服务之前，你可能会觉得为什么Kubernetes要设计的这么复杂，但是一旦你要实施微服务，你会发现Kubernetes中的所有概念，都是有用的。在我们微服务设计的是个要点中，我们会发现Kubernetes都能够有相应的组件和概念，提供相应的支持。</P>\n<div STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 16px; line-height: 28px; color: rgb(34, 34, 34); overflow-wrap: break-word; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\"><img SRC=\"https://p6-tt.byteimg.com/origin/pgc-image/99957830919c424a90837e691fcfdd72?from=pc\" IMG_WIDTH=\"698\" IMG_HEIGHT=\"291\" ALT=\"从API网关的去中心化到ServiceMesh分布式服务治理\" INLINE=\"0\" STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 10px auto; padding: 0px; max-width: 100%; display: block;\" />\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px;\">\n&#160;</P>\n</DIV>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n其中最后的一块拼图就是服务发现，与熔断限流降级。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n众所周知，Kubernetes的服务发现是通过Service来实现的，服务之间的转发是通过kube-proxy下发iptables规则来实现的，这个只能实现最基本的服务发现和转发能力，不能满足高并发应用下的高级的服务特性，比较SpringCloud和Dubbo有一定的差距，于是Service\nMesh诞生了，他期望将熔断，限流，降级等特性，从应用层，下沉到基础设施层去实现，从而使得Kubernetes和容器全面接管微服务。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n在实施微服务架构中，如果需要对外暴露能力和交互，我们谈到了必须要使用API网关来实现能力的暴露以实现服务代理和服务透明。但是如果一个微服务架构不需要和外部打交道，同时仍然需要实现安全，日志和服务限流能力，那么我们就完全可以考虑采用ServiceMesh服务网格能力来实现，同时和Kubernetes和容器化技术实现集成。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\nServiceMesh的开源实现Istio</SPAN></P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\nIstio 是一个由谷歌、IBM 与 Lyft\n共同开发的开源项目，旨在提供一种统一化的微服务连接、安全保障、管理与监控方式。Istio\n项目能够为微服务架构提供流量管理机制，同时亦为其它增值功能（包括安全性、监控、路由、连接管理与策略等）创造了基础。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n这款软件利用久经考验的 Lyft Envoy 代理进行构建，可在无需对应用程序代码作出任何发动的前提下实现可视性与控制能力。Istio\n项目是一款强大的工具，可帮助 CTO/CIO 们立足企业内部实施整体性安全、政策与合规性要求。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">官方对\nIstio 的介绍浓缩成了一句话：</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\nAn open platform to connect, secure, control and observe\nservices.</SPAN></P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n翻译过来，就是”连接、安全加固、控制和观察服务的开放平台“。开放平台就是指它本身是开源的，服务对应的是微服务，也可以粗略地理解为单个应用。中间的四个动词就是\nIstio 的主要功能，官方也各有一句话的说明。这里再阐释一下：</P>\n<ul STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 20px 30px; padding: 0px; list-style-position: outside; list-style-image: initial; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n连接（Connect）：</SPAN>智能控制服务之间的调用流量，能够实现灰度发布等功能</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n安全加固（Secure）：</SPAN>自动为服务之间的调用提供认证、授权和加密。</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n控制（Control）：</SPAN>应用用户定义的 policy，保证资源在消费者中公平分配。</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n观察（Observe）：</SPAN>查看服务运行期间的各种数据，比如日志、监控和 tracing</LI>\n</UL>\n<div STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 16px; line-height: 28px; color: rgb(34, 34, 34); overflow-wrap: break-word; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\"><img SRC=\"https://p3-tt.byteimg.com/origin/pgc-image/56532bc0cd9a4bf8b659ee9dea7a07e7?from=pc\" IMG_WIDTH=\"674\" IMG_HEIGHT=\"630\" ALT=\"从API网关的去中心化到ServiceMesh分布式服务治理\" INLINE=\"0\" STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 10px auto; padding: 0px; max-width: 100%; display: block;\" />\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px;\">\n&#160;</P>\n</DIV>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n可以看到，Istio 就是我们上述提到的 Service Mesh 架构的一种实现，服务之间的通信（比如这里的 Service A\n访问 Service B）会通过代理（默认是 Envoy）来进行。而且中间的网络协议支持 HTTP/1.1，HTTP/2，gRPC\n或者 TCP，可以说覆盖了主流的通信协议。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n控制中心做了进一步的细分，分成了 Pilot、Mixer 和 Citadel，它们的各自功能如下：</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\nPilot：</SPAN>为 Envoy 提供了服务发现，流量管理和智能路由（AB\n测试、金丝雀发布等），以及错误处理（超时、重试、熔断）功能。 用户通过 Pilot 的 API 管理网络相关的资源对象，Pilot\n会根据用户的配置和服务的信息把网络流量管理变成 Envoy 能识别的格式分发到各个 Sidecar 代理中。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\nMixer：</SPAN>为整个集群执行访问控制（哪些用户可以访问哪些服务）和 Policy 管理（Rate Limit，Quota\n等），并且收集代理观察到的服务之间的流量统计数据。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\nCitadel：</SPAN>为服务之间提供认证和证书管理，可以让服务自动升级成 TLS 协议。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n代理会和控制中心通信，一方面可以获取需要的服务之间的信息，另一方面也可以汇报服务调用的 Metrics 数据。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<span STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-weight: 700; margin: 0px; padding: 0px; border: 0px;\">\n为什么使用 Istio？</SPAN></P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n通过负载均衡、服务间的身份验证、监控等方法，Istio\n可以轻松地创建一个已经部署了服务的网络，而服务的代码只需很少更改甚至无需更改。通过在整个环境中部署一个特殊的 sidecar\n代理为服务添加 Istio 的支持，而代理会拦截微服务之间的所有网络通信，然后使用其控制平面的功能来配置和管理\nIstio，这包括：</P>\n<ul STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 20px 30px; padding: 0px; list-style-position: outside; list-style-image: initial; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n为 HTTP、gRPC、WebSocket 和 TCP 流量自动负载均衡。</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n通过丰富的路由规则、重试、故障转移和故障注入对流量行为进行细粒度控制。</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n可插拔的策略层和配置 API，支持访问控制、速率限制和配额。</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n集群内（包括集群的入口和出口）所有流量的自动化度量、日志记录和追踪。</LI>\n<li STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; list-style: inherit;\">\n在具有强大的基于身份验证和授权的集群中实现安全的服务间通信。</LI>\n</UL>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\nIstio 为可扩展性而设计，可以满足不同的部署需求。</P>\n<div STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 16px; line-height: 28px; color: rgb(34, 34, 34); overflow-wrap: break-word; font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" BACKGROUND-COLOR:=\"\"><img SRC=\"https://p1-tt.byteimg.com/origin/pgc-image/6b04ab1189944385b243b19de751a259?from=pc\" IMG_WIDTH=\"859\" IMG_HEIGHT=\"610\" ALT=\"从API网关的去中心化到ServiceMesh分布式服务治理\" INLINE=\"0\" STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 10px auto; padding: 0px; max-width: 100%; display: block;\" NAME=\"image_operate_93231598400420985\" />\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px;\">\n&#160;</P>\n</DIV>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\nIstio 独立于平台，被设计为可以在各种环境中运行，包括跨云、内部环境、Kubernetes、Mesos 等等。您可以在\nKubernetes 或是装有 Consul 的 Nomad 环境上部署 Istio。</P>\n<p STYLE=\"-webkit-tap-highlight-color: transparent; box-sizing: border-box; margin: 16px 0px; padding: 0px; border: 0px; color: rgb(34, 34, 34); font-family:\" PINGFANG=\"\" SANS=\"\" MICRO=\"\" FONT-SIZE:=\"\" BACKGROUND-COLOR:=\"\">\n可以看到，Istio是一个与Kubernetes紧密结合的适用于云原生场景的Service\nMesh形态的用于服务治理的开放平台。在我们实施微服务+DevOps+容器云的过程中，为了实现完全的去中心化，并增加对微服务模块，API接口服务的治理管控能力，和ServiceMesh思路进行结合是一个必然的发展趋势。</P>\n<br /></DIV><br /><img src=\"http://simg.sinajs.cn/blog7style/images/special/1265.gif\">&#160;","descriptionType":"text/html","publishedDate":"Wed, 26 Aug 2020 00:06:20 +0000","feedId":7662,"bgimg":"http://s3.sinaimg.cn/mw690/001l8XD7zy7FVHnKRnIf2&690","linkMd5":"e6ac6f75790c217c416d5a1e198eec17","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn30@2020_5/2020/08/26/07-23-37-434_a68a737abb92a26c.webp","destWidth":360,"destHeight":360,"sourceBytes":7092,"destBytes":2404,"author":"人月神话","articleImgCdnMap":{"http://s3.sinaimg.cn/mw690/001l8XD7zy7FVHnKRnIf2&690":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn30@2020_5/2020/08/26/07-23-37-434_a68a737abb92a26c.webp","https://p1-tt.byteimg.com/origin/pgc-image/47666275792a4d8f9a61cca916ef0be7?from=pc":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn43@2020_5/2020/08/26/07-23-39-074_639f764ef6d6ccd5.webp","https://p6-tt.byteimg.com/origin/pgc-image/fe32e7034e264589891e8b2250f9b9d0?from=pc":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn74@2020_5/2020/08/26/07-23-41-459_b5c320f9fbf35cb7.webp","https://p1-tt.byteimg.com/origin/pgc-image/5dfee33e43324044ace6260790444d96?from=pc":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn50@2020_4/2020/08/26/07-23-39-485_403fbfb84ac5ee11.webp","https://p3-tt.byteimg.com/origin/pgc-image/f2e93b9d6a0a49ed813cce4747536b58?from=pc":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn54@2020_6/2020/08/26/07-23-38-797_8f6a9a272fb49540.webp","https://p6-tt.byteimg.com/origin/pgc-image/79fd8c88f83a405e9c32e6a2a51c5fc2?from=pc":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn41@2020_1/2020/08/26/07-24-49-698_a0898fbe2611099f.webp","https://p3-tt.byteimg.com/origin/pgc-image/f65f02c9a1484afda58cabdf89058076?from=pc":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn69@2020_6/2020/08/26/07-23-39-064_b5e47abb60746f50.webp","https://p6-tt.byteimg.com/origin/pgc-image/6f5579c0d3ba44b5b27e8dead11ceab7?from=pc":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn55@2020_1/2020/08/26/07-23-41-642_09a9acabc71624a8.webp","https://p1-tt.byteimg.com/origin/pgc-image/db81873265e2459eaa8ebd016f69e352?from=pc":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn61@2020_3/2020/08/26/07-23-38-970_0c6e49e0dd90ac08.webp","https://p6-tt.byteimg.com/origin/pgc-image/99957830919c424a90837e691fcfdd72?from=pc":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn34@2020_3/2020/08/26/07-23-41-113_1681dc9326ffdfe5.webp","https://p3-tt.byteimg.com/origin/pgc-image/56532bc0cd9a4bf8b659ee9dea7a07e7?from=pc":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn63@2020_1/2020/08/26/07-23-39-050_873af41d3fb306d6.webp","https://p1-tt.byteimg.com/origin/pgc-image/6b04ab1189944385b243b19de751a259?from=pc":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn37@2020_4/2020/08/26/07-23-38-969_a4bbd7c15953aded.webp","http://simg.sinajs.cn/blog7style/images/special/1265.gif":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn78@2020_6/2020/08/26/07-23-40-734_66e9c83d813b7958.webp"},"publishedOrCreatedDate":1598426614538}],"record":{"createdTime":"2020-08-26 15:23:34","updatedTime":"2020-08-26 15:23:34","feedId":7662,"fetchDate":"Wed, 26 Aug 2020 07:23:34 +0000","fetchMs":1376,"handleMs":24,"totalMs":79667,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"40ace73c106547fe13d820d5a8d040ba","hostName":"us-012*","requestId":"b9c4594b32674cf1a17fa54b1bb09fe4_7662","contentType":"text/xml; charset=utf-8","totalBytes":297004,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":13,"articlesImgsGithubTotal":13,"successGithubMap":{"myreaderx8":1,"myreaderx7":1,"myreaderx6":1,"myreaderx16":1,"myreaderx21":1,"myreaderx11":1,"myreaderx3":1,"myreaderx33":1,"myreaderx2":1,"myreaderx13":1,"myreaderx30":1,"myreaderx29":1,"myreaderx19":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:33:49","updatedTime":"2020-08-25 07:40:53","id":7662,"name":"人月神话的BLOG","url":"http://blog.sina.com.cn/rss/1228571733.xml","subscriber":null,"website":null,"icon":"http://blog.sina.com.cn/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx61/cdn37@2020_3/2020/08/24/23-37-31-159_08bc756793a1bd4b.ico","description":"","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":2404,"tmpBodyImgCdnBytes":294600,"tmpBgImgCdnBytes":0,"extra4":{"start":1598426611057,"total":0,"statList":[{"spend":3457,"msg":"获取xml内容"},{"spend":24,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":72107,"msg":"正文链接上传到cdn"}]},"extra5":13,"extra6":13,"extra7ImgCdnFailResultVector":[null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://europe-56.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-013.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-037.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-034.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-009.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-52.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-038.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-001.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe64.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-22.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-008.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://us-014.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"http://s3.sinaimg.cn/mw690/001l8XD7zy7FVHnKRnIf2&690","sourceStatusCode":200,"destWidth":360,"destHeight":360,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn30@2020_5/2020/08/26/07-23-37-434_a68a737abb92a26c.webp","sourceBytes":7092,"destBytes":2404,"targetWebpQuality":75,"feedId":7662,"totalSpendMs":3920,"convertSpendMs":10,"createdTime":"2020-08-26 15:23:34","host":"europe68*","referer":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","linkMd5ListStr":"e6ac6f75790c217c416d5a1e198eec17,e6ac6f75790c217c416d5a1e198eec17","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"6.9 KB","destSize":"2.3 KB","compressRate":"33.9%"},{"code":1,"isDone":false,"source":"https://p3-tt.byteimg.com/origin/pgc-image/f2e93b9d6a0a49ed813cce4747536b58?from=pc","sourceStatusCode":200,"destWidth":779,"destHeight":350,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn54@2020_6/2020/08/26/07-23-38-797_8f6a9a272fb49540.webp","sourceBytes":32904,"destBytes":26132,"targetWebpQuality":75,"feedId":7662,"totalSpendMs":941,"convertSpendMs":16,"createdTime":"2020-08-26 15:23:38","host":"us-037*","referer":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","linkMd5ListStr":"e6ac6f75790c217c416d5a1e198eec17","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"32.1 KB","destSize":"25.5 KB","compressRate":"79.4%"},{"code":1,"isDone":false,"source":"https://p1-tt.byteimg.com/origin/pgc-image/db81873265e2459eaa8ebd016f69e352?from=pc","sourceStatusCode":200,"destWidth":771,"destHeight":400,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn61@2020_3/2020/08/26/07-23-38-970_0c6e49e0dd90ac08.webp","sourceBytes":39699,"destBytes":24446,"targetWebpQuality":75,"feedId":7662,"totalSpendMs":1164,"convertSpendMs":13,"createdTime":"2020-08-26 15:23:38","host":"us-013*","referer":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","linkMd5ListStr":"e6ac6f75790c217c416d5a1e198eec17","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"38.8 KB","destSize":"23.9 KB","compressRate":"61.6%"},{"code":1,"isDone":false,"source":"https://p1-tt.byteimg.com/origin/pgc-image/6b04ab1189944385b243b19de751a259?from=pc","sourceStatusCode":200,"destWidth":859,"destHeight":610,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn37@2020_4/2020/08/26/07-23-38-969_a4bbd7c15953aded.webp","sourceBytes":37136,"destBytes":23744,"targetWebpQuality":75,"feedId":7662,"totalSpendMs":1221,"convertSpendMs":26,"createdTime":"2020-08-26 15:23:38","host":"us-034*","referer":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","linkMd5ListStr":"e6ac6f75790c217c416d5a1e198eec17","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"36.3 KB","destSize":"23.2 KB","compressRate":"63.9%"},{"code":1,"isDone":false,"source":"https://p3-tt.byteimg.com/origin/pgc-image/56532bc0cd9a4bf8b659ee9dea7a07e7?from=pc","sourceStatusCode":200,"destWidth":674,"destHeight":630,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn63@2020_1/2020/08/26/07-23-39-050_873af41d3fb306d6.webp","sourceBytes":35162,"destBytes":27518,"targetWebpQuality":75,"feedId":7662,"totalSpendMs":1238,"convertSpendMs":17,"createdTime":"2020-08-26 15:23:38","host":"us-014*","referer":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","linkMd5ListStr":"e6ac6f75790c217c416d5a1e198eec17","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"34.3 KB","destSize":"26.9 KB","compressRate":"78.3%"},{"code":1,"isDone":false,"source":"https://p1-tt.byteimg.com/origin/pgc-image/47666275792a4d8f9a61cca916ef0be7?from=pc","sourceStatusCode":200,"destWidth":725,"destHeight":392,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn43@2020_5/2020/08/26/07-23-39-074_639f764ef6d6ccd5.webp","sourceBytes":179412,"destBytes":21850,"targetWebpQuality":75,"feedId":7662,"totalSpendMs":1233,"convertSpendMs":22,"createdTime":"2020-08-26 15:23:38","host":"us-009*","referer":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","linkMd5ListStr":"e6ac6f75790c217c416d5a1e198eec17","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"175.2 KB","destSize":"21.3 KB","compressRate":"12.2%"},{"code":1,"isDone":false,"source":"https://p3-tt.byteimg.com/origin/pgc-image/f65f02c9a1484afda58cabdf89058076?from=pc","sourceStatusCode":200,"destWidth":781,"destHeight":495,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn69@2020_6/2020/08/26/07-23-39-064_b5e47abb60746f50.webp","sourceBytes":60253,"destBytes":39898,"targetWebpQuality":75,"feedId":7662,"totalSpendMs":1284,"convertSpendMs":32,"createdTime":"2020-08-26 15:23:38","host":"us-001*","referer":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","linkMd5ListStr":"e6ac6f75790c217c416d5a1e198eec17","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"58.8 KB","destSize":"39 KB","compressRate":"66.2%"},{"code":1,"isDone":false,"source":"https://p1-tt.byteimg.com/origin/pgc-image/5dfee33e43324044ace6260790444d96?from=pc","sourceStatusCode":200,"destWidth":775,"destHeight":340,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn50@2020_4/2020/08/26/07-23-39-485_403fbfb84ac5ee11.webp","sourceBytes":33462,"destBytes":21552,"targetWebpQuality":75,"feedId":7662,"totalSpendMs":1823,"convertSpendMs":10,"createdTime":"2020-08-26 15:23:38","host":"europe-22*","referer":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","linkMd5ListStr":"e6ac6f75790c217c416d5a1e198eec17","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"32.7 KB","destSize":"21 KB","compressRate":"64.4%"},{"code":1,"isDone":false,"source":"http://simg.sinajs.cn/blog7style/images/special/1265.gif","sourceStatusCode":200,"destWidth":20,"destHeight":12,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn78@2020_6/2020/08/26/07-23-40-734_66e9c83d813b7958.webp","sourceBytes":2095,"destBytes":2844,"targetWebpQuality":75,"feedId":7662,"totalSpendMs":2874,"convertSpendMs":7,"createdTime":"2020-08-26 15:23:38","host":"us-52*","referer":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","linkMd5ListStr":"e6ac6f75790c217c416d5a1e198eec17","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"2 KB","destSize":"2.8 KB","compressRate":"135.8%"},{"code":1,"isDone":false,"source":"https://p6-tt.byteimg.com/origin/pgc-image/99957830919c424a90837e691fcfdd72?from=pc","sourceStatusCode":200,"destWidth":698,"destHeight":291,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn34@2020_3/2020/08/26/07-23-41-113_1681dc9326ffdfe5.webp","sourceBytes":38426,"destBytes":33808,"targetWebpQuality":75,"feedId":7662,"totalSpendMs":3666,"convertSpendMs":13,"createdTime":"2020-08-26 15:23:38","host":"europe-56*","referer":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","linkMd5ListStr":"e6ac6f75790c217c416d5a1e198eec17","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"37.5 KB","destSize":"33 KB","compressRate":"88%"},{"code":1,"isDone":false,"source":"https://p6-tt.byteimg.com/origin/pgc-image/6f5579c0d3ba44b5b27e8dead11ceab7?from=pc","sourceStatusCode":200,"destWidth":851,"destHeight":403,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn55@2020_1/2020/08/26/07-23-41-642_09a9acabc71624a8.webp","sourceBytes":33569,"destBytes":18408,"targetWebpQuality":75,"feedId":7662,"totalSpendMs":3821,"convertSpendMs":536,"createdTime":"2020-08-26 15:23:38","host":"us-038*","referer":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","linkMd5ListStr":"e6ac6f75790c217c416d5a1e198eec17","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"32.8 KB","destSize":"18 KB","compressRate":"54.8%"},{"code":1,"isDone":false,"source":"https://p6-tt.byteimg.com/origin/pgc-image/fe32e7034e264589891e8b2250f9b9d0?from=pc","sourceStatusCode":200,"destWidth":778,"destHeight":371,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn74@2020_5/2020/08/26/07-23-41-459_b5c320f9fbf35cb7.webp","sourceBytes":29619,"destBytes":23562,"targetWebpQuality":75,"feedId":7662,"totalSpendMs":3763,"convertSpendMs":14,"createdTime":"2020-08-26 15:23:38","host":"europe64*","referer":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","linkMd5ListStr":"e6ac6f75790c217c416d5a1e198eec17","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"28.9 KB","destSize":"23 KB","compressRate":"79.6%"},{"code":1,"isDone":false,"source":"https://p6-tt.byteimg.com/origin/pgc-image/79fd8c88f83a405e9c32e6a2a51c5fc2?from=pc","sourceStatusCode":200,"destWidth":774,"destHeight":380,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn41@2020_1/2020/08/26/07-24-49-698_a0898fbe2611099f.webp","sourceBytes":39275,"destBytes":30838,"targetWebpQuality":75,"feedId":7662,"totalSpendMs":11796,"convertSpendMs":46,"createdTime":"2020-08-26 15:24:38","host":"us-034*","referer":"http://blog.sina.com.cn/s/blog_493a84550102z8z0.html","linkMd5ListStr":"e6ac6f75790c217c416d5a1e198eec17","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"38.4 KB","destSize":"30.1 KB","compressRate":"78.5%"}],"successGithubMap":{"myreaderx8":1,"myreaderx7":1,"myreaderx6":1,"myreaderx16":1,"myreaderx21":1,"myreaderx11":1,"myreaderx3":1,"myreaderx33":1,"myreaderx2":1,"myreaderx13":1,"myreaderx30":1,"myreaderx29":1,"myreaderx19":1},"failGithubMap":{}}