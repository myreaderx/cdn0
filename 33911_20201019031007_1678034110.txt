{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-19 11:09:49","updatedTime":"2020-10-19 11:09:49","title":"React+Reduxアプリケーション テスト戦略","link":"https://recruit-tech.co.jp/blog/?p=8726","description":"<h2>はじめに</h2>\n<p>このエントリは全5回を予定する19卒新人ブログリレーの第4回目です。</p>\n<p>はじめまして、リクルートテクノロジーズ新卒2年目の高橋 勇人です。</p>\n<p>現在は不動産検索サービスSUUMOのフロントエンドエンジニアとして働いています。新卒入社してからの1年間、SUUMOの新機能開発に携わり、物件を地図から探す機能の開発を進めてきました。</p>\n<p>SUUMOではこれまでJavaScript+jQueryで開発されてきましたが、SPサイト上で地図による物件探し機能を実現するために、React+Reduxという技術スタックが採用されました。<br />\n<span style=\"font-size: 10pt;\"><strong>（※SP＝スマートフォン）</strong></span></p>\n<p>長期的な開発がされてきたプロダクトで、これまで使ってきていなかった技術スタックでの開発を推し進めるにあたり、継続的な保守性を向上するための取り組みの一環としてテストの整備が進められました。</p>\n<p>本記事では、React+Reduxでの地図機能の開発において採用されたテスト戦略について紹介します。</p>\n<h2>想定読者</h2>\n<ul style=\"list-style-type: disc;\">\n<li><strong>React+Redux経験者でアプリケーションを構築したことがある人</strong></li>\n<li><strong>テストを書くことでサービスの品質を向上させたいと思っている人</strong></li>\n</ul>\n<p>&#160;</p>\n<h2>地図検索機能(横断地図)について</h2>\n<p>今回開発したのは、SUUMOの物件を地図から探す機能です。この機能は2020年6月24日にリリースされました(<a href=\"https://suumo.jp/sp/chizu/#/\">地図検索機能ページ</a>)。</p>\n<p>SUUMOで取り扱っている賃貸・新築マンション・中古マンション・新築一戸建て・中古一戸建て・土地をまとめて地図から探すことができ、検索条件を変更しながら、住みたい場所を起点として物件を見つけることができます。</p>\n<img class=\"size-full wp-image-8740 aligncenter\" src=\"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191439/SUUMOMapDemo1.gif\" alt=\"\" width=\"374\" height=\"664\" />\n<p>このように、様々な物件の種別を横断的に探せることから、横断地図と呼ばれています(以下、横断地図)。</p>\n<p>SUUMOでは既に同様の機能がPC版に実装されていましたが、今回新たにSP Web上で地図によるスムーズな物件探し体験を実現するため、React+Reduxの技術構成で構築を行いました。</p>\n<h2>React+Reduxアプリケーションのテスト戦略</h2>\n<h3>Reactについて</h3>\n<p><a href=\"https://reactjs.org\">React</a>はFacebookによって開発が行われているViewライブラリで、コンポーネントベースであることが特徴です。</p>\n<p>ReactコンポーネントでインタラクティブなUIを作成していく際には、propsを通じて状態を受け取り、各状態に対応するViewを設計していくことでアプリケーションを作り上げていきます。</p>\n<p></p><pre class=\"crayon-plain-tag\">import React from 'react'\nimport ReactDOM from 'react-dom'\n\nconst HelloMessage: React.FC&#60;{ name: string }&#62; = props =&#62; (\n  &#60;div&#62;Hello {props.name}&#60;/div&#62;\n)\n\nReactDOM.render(\n  &#60;HelloMessage name=\"SUUMO\" /&#62;,\n  document.getElementById('hello-example'),\n);</pre><p></p>\n<p>一方でReactは、基本的にはViewのライブラリであり、状態管理が複雑化していくとどのコンポーネントで状態を持っているのか分かりにくく、全体の見通しが悪くなってしまいます。そのため、Reactはよく状態管理を行うライブラリと組み合わせて使われます。</p>\n<h3>Reduxについて</h3>\n<p>Reactの状態管理によく使われているライブラリの一つが<a href=\"https://redux.js.org\">Redux</a>です。</p>\n<p>ReduxはFluxアーキテクチャに加えて、関数型プログラミングの原理に基づいています。Fluxアーキテクチャには単方向データフローというコンセプトがあり、状態変更は必ずActionのDispatchによって行われます。また、Reduxにおいて状態変更を行うReducerは純粋関数によって記述され、副作用処理はMiddlewareに分離されます。</p>\n<p>Reduxにおける状態変更のフローは以下の図のようになります。</p>\n<img class=\"wp-image-8734 size-large aligncenter\" src=\"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175509/ReduxActionFlow-1024x576.png\" alt=\"\" width=\"680\" height=\"383\" srcset=\"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175509/ReduxActionFlow-1024x576.png 1024w, https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175509/ReduxActionFlow-500x281.png 500w, https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175509/ReduxActionFlow-768x432.png 768w, https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175509/ReduxActionFlow.png 1546w\" sizes=\"(max-width: 680px) 100vw, 680px\" />\n<p>Reduxの各要素は以下のような役割を持っています。</p>\n<ul>\n<li>Singleton Store：アプリケーション全体のデータを持つ。</li>\n<li>Reducer：Dispatchされたアクションと現在のStateの内容をもとに、Stateを更新する純粋関数。</li>\n<li>Middleware：アクションがDispatchされてからStateの更新を行うまでに処理を挟み込むことができる。非同期処理などの副作用のある処理はMiddlewareに分離する。</li>\n<li>Selector：StateからViewに渡すPropsを生成する。(<a href=\"https://redux.js.org/recipes/computing-derived-data\">Redux公式Document</a>)</li>\n</ul>\n<p>このような状態変更のデータフローの特性と、Reactコンポーネントの特性をもとにテスト戦略を考えていきます。</p>\n<h3>テスト戦略</h3>\n<p>先述したように、Reactコンポーネントは外部からpropsとして受け取った状態に対してのViewを返します。つまり、コンポーネントがローカルState等の内部状態を持たなければ、同じStateをPropsとして受け取ったときに、同じViewになることを保証することができます。</p>\n<p>そのため、ReduxのState変更ロジックをテストによって保証することでStateの内容の正しさを担保すれば、Stateに基づいているViewまでを演繹的に保証することができるといえます。</p>\n<p>この戦略によってReact+Reduxアプリケーションに対して効果的にテストを行なっていくために重要なのは、以下の2点です。</p>\n<ul>\n<li>コンポーネントが生成するView(HTML)がRedux Stateの中身と一対一で対応する状態を作ること（≒内部に状態を持たないこと）</li>\n<li>アプリケーションの状態変更が必ずActionのDispatchによって行われること（≒Redux以外の部分にロジックを持たないこと）</li>\n</ul>\n<p>アプリケーションにおける状態管理・ロジックをRedux側に寄せることで上記の2点を達成しつつ、Reduxに対してテストを拡充していくことによってView→Action→Reducer→Stateの動作を保証してゆくことで、アプリケーション全体のロジック部分をテストによって担保しつつ、ReduxのStateに基づいているViewも演繹的に保証されていくという戦略が効果的です。</p>\n<p>上記の2点は完全に達成することは難しいかもしれませんが、できる限り守った上で、そこから外れるコンポーネントの動作については手動での検証を含め、違った形で担保していくこととなります。コンポーネントに対するテストを効果的に行う方法については記事の後半で紹介します。</p>\n<p>Reduxの状態変更・ロジックを保証するためには、Reduxにおける一連のフローに対してテストを書いていくこととなります。</p>\n<p>テストを行なっていく対象は以下になります。<br />\n1.Action Creator<br />\n2.Reducer<br />\n3.Selector<br />\n4.Middleware<br />\n5.API通信処理</p>\n<p>この戦略におけるテスト対象を示したのが以下の図です。</p>\n<img class=\"wp-image-8735 size-large aligncenter\" src=\"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175511/ReduxTestTarget-1024x576.png\" alt=\"\" width=\"680\" height=\"383\" srcset=\"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175511/ReduxTestTarget-1024x576.png 1024w, https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175511/ReduxTestTarget-500x281.png 500w, https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175511/ReduxTestTarget-768x432.png 768w, https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175511/ReduxTestTarget.png 1600w\" sizes=\"(max-width: 680px) 100vw, 680px\" />\n<p>各要素に対するテストの書き方は<a href=\"https://redux.js.org/recipes/writing-tests\">Reduxの公式Document</a>にありますが、この記事では横断地図での実例をもとに、どのようなテストを書くべきかについて説明していきます。</p>\n<h2>テスト例</h2>\n<h3>Action Creator</h3>\n<p>Action Creatorのテストでは、返すActionの中身が正しいことを担保していきます。</p>\n<p>返されるActionの中身をテストすることで、Reducerに渡されるアクションが想定通りになっていることを担保することができます。</p>\n<p>また、テストとして書いておくことでActionの設計を変える際にも意図しない変更に気付けたり、複雑なPayloadを受け取るActionの場合にはサンプルコード的な役割も果たす等のメリットがあります。</p>\n<p>テストの書き方は<a href=\"https://redux.js.org/recipes/writing-tests#action-creators\">Redux公式Document</a>を参照してください。</p>\n<h3>Reducer Test</h3>\n<p>Reducerのテストでは、初期Stateが正しく返されることや、アクションを処理した結果のStateが正しいことを担保していきます。</p>\n<p>基本的にはStateの書き換えが正しく行われているかをテストしていけばよいのですが、Reducer内にロジックを持っている場合には、関数に対するテストと同様に正常系・異常系・境界値に対してテストしていきます。</p>\n<p>例えば、横断地図では以下のように、マーカー選択された際に対象のマーカーが地図の中央より下にあった時に、UIの表示に被らずマーカーが中央に来るよう、地図の中央位置を変更するロジックを持っていました。</p>\n<p></p><pre class=\"crayon-plain-tag\">// Map Reducer\nconst reducer = (state = initialState, action) =&#62; {\n  switch (action.type) {\n    case 'SELECT_MARKER':\n      return {\n        ...state,\n        center: {\n          lat: Math.min(state.center.lat, action.payload.marker.lat),\n          lng: state.center.lng,\n        },\n      };\n    default:\n      return state;\n  }\n};</pre><p></p>\n<p>このReducerに対しては、以下のようにテストしていきました。</p>\n<p></p><pre class=\"crayon-plain-tag\">import reducer, { INITIAL_STATE, selectMarker } from '../mapReducer'\n\ndescribe('State: sealectMarker', () =&#62; {\n  const marker: Marker = { lng: 100, lat: 100 }\n  const selectMarkerAction = selectMarker(marker)\n\n  test(\"returns marker's latitude smaller than state's\", () =&#62; {\n    const initialCenter = { lat: 101, lng: 101 }\n    const state = {\n      ...INITIAL_STATE,\n      center: initialCenter,\n    }\n    const actual = reducer(state, selectMarkerAction)\n\n    // latがマーカーの値に置き換わっていることをアサート\n    expect(actual).toEqual({\n      ...state,\n      center: {\n        lat: marker.lat,\n        lng: initialCenter.lng,\n      },\n    })\n  })\n\n  test(\"returns state's latitude\", () =&#62; {\n    const initialCenter = { lat: 99, lng: 99 }\n    const state = {\n      ...INITIAL_STATE,\n      center: initialCenter,\n    }\n    const actual = reducer(state, selectMarkerAction)\n\n    // latの値が置き換わっていないことをアサート\n    expect(actual).toEqual({\n      ...state,\n      center: {\n        ...initialCenter,\n      },\n    })\n  })\n})</pre><p></p>\n<p>このように、Reducerが持っているロジックに対して他にもパターン網羅を意識しながらテストを書いていきました。</p>\n<p>Reducerに対してしっかりとしたテストを拡充することで、State変更の挙動の正しさを担保することができます。</p>\n<p>State変更の挙動の正しさはテスト戦略上でも重要な部分なので、Reducer内にロジックを持っている場合は特に、しっかりとしたテストを書くことでアプリケーションとしての動作をより確かなものにしていくことができます。</p>\n<h3>Selector Test</h3>\n<p>Selectorのテストでは、Stateを与えた時に、期待する形に加工されていることを担保していきます。</p>\n<p>Selectorは、Stateの値をもとに計算する処理を行います。<a href=\"https://github.com/reduxjs/reselect\">Reselect</a>を使ってSelectorを実装することで、計算のメモ化も行うことができるため、パフォーマンス観点でも有効です。</p>\n<p>横断地図では、表示される地図のマーカーが多い時に複数のマーカーをまとめる処理を施しています。当初はGoogle Maps APIのMarker Clusterer機能を使っていたのですが、マーカーの数が数十件を超えたあたりからパフォーマンスに甚大な影響が出ていました。</p>\n<p>そのAPIでは一度マーカー全部を地図上にレンダリング→レンダリングされた結果をもとにクラスタリング処理→クラスタリングしたマーカーをレンダリングし直す、という流れで処理が行われていたため、マーカーの数に対して指数関数的にパフォーマンスに影響がありました。</p>\n<p>そこで、クラスタリングアルゴリズムについては、今回は厳密にクラスタリングする必要はなかったため、大まかなグリッド分割による実装に切り替えることで、O(n) で処理が完了するよう改良しました。</p>\n<p>更に、地図にレンダリングされる前にSelectorを使って予めクラスタリングしたものをViewに渡す実装に変更しました。これによって、最初に全部のマーカーをレンダリングすることなくクラスタリングされた状態にできたため、マーカーの数が大きくてもパフォーマンス上問題なく動作させることができました。</p>\n<p>このようにSelectorによってパフォーマンスの問題を解決したのですが、自前実装でクラスタリング処理を行なっているため、動作保証をしっかりとやるべき箇所となります。また、クラスタリングの結果が想定通りになっているかはGoogle Mapsにレンダリングされたものを確認しても判別しにくいため、その点でも動作をテストケースによって担保していくべき箇所です。</p>\n<p>クラスタリング処理の内容は大幅に簡略化していますが、Selectorの実装は以下のようなイメージです。</p>\n<p></p><pre class=\"crayon-plain-tag\">// Marker Reducer - Selector\nimport { createSelector } from 'reselect'\n\nconst getMarkers = (state: State): Marker[] =&#62; state.markers\nconst getGridSize = (state: State): { horizontal: number vertical: number } =&#62; state.gridSize\n\nexport const clusteredMarkerSelector = createSelector(\n  [getMarkers, getGridSize],\n  (\n    markers: Marker[],\n    gridSize: { horizontal: number vertical: number },\n  ): Marker[] =&#62; {\n    const grid: Array&#60;Marker[]&gt; = []\n    // マーカーをクラスターごとにGridに格納\n    markers.forEach((marker: Marker) =&#62; {\n      addToGrid(marker, grid, gridSize)\n    })\n    // GridごとにマーカーをマージしてGridで一つのマーカーに集約する\n    const clusteredMarkers: Marker[] = grid.map(\n      (markerItems: Marker[]): Marker =&#62; merge(markerItems),\n    )\n    return clusteredMarkers\n  },\n)</pre><p></p>\n<p>このSelectorに対して、Stateを与えた時に、期待するようにクラスタリングされた値になっていることをテストしていきました。</p>\n<p></p><pre class=\"crayon-plain-tag\">import { clusteredMarkerSelector } from '../markerReducer'\n\ndescribe('Clustering', () =&#62; {\n  const testGridSize = { horizontal: 1.0, vertical: 1.0 }\n  const getState = (markers: Marker[]): State =&#62; {\n    // 受け取ったmarkersをセットしたテスト用Stateを設定\n    const state = {\n      markers,\n      gridSize: testGridSize,\n    }\n    ........\n    return state\n  }\n\n  test('Cluster two markers', () =&#62; {\n    const markers: Marker[] = [\n      { lat: 1.0, lng: 1.0 },\n      { lat: 1.5, lng: 1.5 },\n    ]\n    const state = getState(markers)\n    const expectedMarkers: Marker[] = [{ lat: 1.25, lng: 1.25 }]\n\n    const clusteredMarkers = clusteredMarkerSelector(state)\n\n    expect(clusteredMarkers).toEqual(expectedMarkers)\n  })\n  ........\n})</pre><p></p>\n<p>この部分はロジックが多いため、実際のテストコードでは、細かいエッジケースについてもカバーするようテストケースを拡充していきました。</p>\n<p>クラスタリング処理の結果は、まとめられてGoogle Maps上にレンダリングされた結果が、どの程度正しいのかを確認するのが難しい部分です。そのため、この処理に対してテストケースを手厚く書くことで、実装の担保及びデグレード検知を行なっています。</p>\n<p>実際、実装していく中で何度かクラスタリング処理のアルゴリズムを改良していったのですが、意図した挙動になっているか、デグレードが起きていないかをテストによって確認しながら進めることができたため、自信を持ってリファクタリングしていくことができました。</p>\n<h3>Middleware Test</h3>\n<p>Middlewareのテストでは、対象のアクションが流れた際にMiddlewareの処理が実行されていること、副作用処理等が正しく動作していることを担保していきます。</p>\n<p>Middlewareは副作用処理も含めた様々な処理を受け持つことになります。特に、横断地図ではイベントに紐づいたログ送信のアクションをMiddlewareに分離していたので、ビジネスロジック的にも重要な部分を担っていました。</p>\n<p>どの程度テストを書くべきかについては、担保したい内容と重要度によって決めるべきところですが、特に重要な処理であるログ送信に関しては、手厚くテストケースが追加されています。</p>\n<p>もう一つ、Middlewareの処理でテストケースが有効に働いた箇所として、時間経過によって分岐する処理があります。</p>\n<p>前回アクセスからの経過時間を判定して、それをもとに分岐する処理をMiddlewareに実装していましたが、手動で確認すると経過時間を待ってから確認する方法やアクセス時間の書き換えなどが必要になるので、手間がかかる部分です。</p>\n<p>処理の概要としては以下のようになります。</p>\n<p></p><pre class=\"crayon-plain-tag\">// Restore Middleware\nimport { restoreConditions } from '../modules/restore'\n\nconst getLastAccessTime = (state: State) =&#62; state.lastAccessTime\n\nconst restoreMiddleware = (): Middleware =&#62; {\n  return &#60;D extends Dispatch = Dispatch&#62;({\n    dispatch,\n    getState,\n  }: MiddlewareAPI&#60;D&#62;) =&#62; (next: Dispatch&#60;AnyAction&#62;) =&#62; (\n    action: any,\n  ): Dispatch&#60;AnyAction&#62; =&#62; {\n    if (action.type !== INIT_ON_ACCESS) {\n      return next(action)\n    }\n\n    const lastAccessTime = getLastAccessTime(getState())\n    const elapsedTime = new Date().getTime() - lastAccessTime\n    // 前回のアクセスから7日以内であればアクションがdispatchされる\n    if (elapsedTime &#60; SEVEN_DAYS) {\n      dispatch(restoreConditions())\n    }\n\n    return next(action)\n  }\n}\n\nexport default restoreMiddleware()</pre><p></p>\n<p>このようなMiddlewareに対するテストでは、日付をモックしてやる必要があります。日付の取得をMiddleware内部でやっているため、今回はJestでDateオブジェクトをモックすることでテストしていきました。</p>\n<p></p><pre class=\"crayon-plain-tag\">import { initOnAccess, restoreConditions } from '../../modules/restore'\nimport restoreMiddleware from '../restoreMiddleware'\nimport { INITIAL_STATE } from '../../reducer'\n\n// Middlewareに対してテストするための関数を返却する\nconst create = (state: any = INITIAL_STATE): any =&#62; {\n  const store = {\n    dispatch: jest.fn(),\n    getState: jest.fn(() =&#62; state),\n  }\n  const next = jest.fn()\n  const invoke = () =&#62; (action: AnyAction): any =&#62; {\n    restoreMiddleware()(store)(next)(action)\n  }\n  return { store, next, invoke }\n}\n\ndescribe('restoreMiddleware', () =&#62; {\n  beforeAll(() =&#62; {\n    // Middleware内で使われるDateオブジェクトをモック\n    const OriginalDate = Date\n    const mockDate = new Date('2020-01-01T12:00Z')\n    // Dateに明示的に値が渡された場合以外の日付をmockedDateに差し替え\n    jest.spyOn(global, 'Date').mockImplementation((arg?: any): any =&#62; {\n      return arg ? new OriginalDate(arg) : mockDate\n    })\n  })\n\n  test('dispatch action within 6 days', () =&#62; {\n    const sixDaysAgo = new Date('2019-12-26T12:00Z')\n    const state = {\n      ...INITIAL_STATE,\n      lastAccessTime: sixDaysAgo,\n    }\n    const initOnAccessAction = initOnAccess()\n\n    const { store, next, invoke } = create(state)\n\n    invoke()(initOnAccessAction)\n\n    // 次のMiddlewareへとアクションが渡されていることのアサート\n    expect(next).toHaveBeenCalled()\n    // アクションがDispatchされていることのアサート\n    expect(store.dispatch).toHaveBeenCalledWith(restoreConditions())\n  })\n\n  test('does not dispatch action after 7 days', () =&#62; {\n    const sevenDaysAgo = new Date('2019-12-25T12:00Z')\n    const state = {\n      ...INITIAL_STATE,\n      lastAccessTime: sevenDaysAgo,\n    }\n    const initOnAccessAction = initOnAccess()\n\n    const { store, next, invoke } = create(state)\n\n    invoke()(initOnAccessAction)\n\n    // 次のMiddlewareへとアクションが渡されていることのアサート\n    expect(next).toHaveBeenCalled()\n    // アクションがDispatchされていないことのアサート\n    expect(store.dispatch).not.toHaveBeenCalledWith(restoreConditions())\n  })\n})\n\n........</pre><p></p>\n<p>経過時間などに紐づいた処理を行う部分は、特に手動での確認に手間がかかる部分なので、Unitテストによってロジックが保証されることの恩恵が大きいところです。</p>\n<p>今後ロジックに変更が入った場合でも、デグレードの確認をテストによって行うことができるので、アプリケーションをエンハンスしていく際もテストによる恩恵が受けられます。</p>\n<h3>API Test</h3>\n<p>API等の非同期処理アクションのテストでは、実行されるアクションの順番と内容が正しいことを担保していきます。</p>\n<p>Middlewareが担う主な副作用処理に、APIへの非同期通信処理があります。</p>\n<p>非同期通信処理の実行には<a href=\"https://github.com/reduxjs/redux-thunk\">Redux Thunk</a>、<a href=\"https://github.com/redux-saga/redux-saga/\">Redux-Saga</a>、<a href=\"https://github.com/recruit-tech/redux-effects-steps\">redux-effects-steps</a>等のMiddlewareを使って実装していくことが多いです。</p>\n<p>横断地図では、redux-effects-stepsを使用しました。redux-effects-stepsはアクションの実行順序を制御するもので、Request開始アクション→Fetch処理→Success/Failアクションの流れを定義する形で使用します。</p>\n<p>実際のFetch処理についてはredux-effects-stepsライブラリ自体は機能を持っていないため、他のMiddlewareライブラリ等によって実現します。横断地図では、レスポンスからの値をもとにSuccess/Failを決める処理等を行うために、Fetch用のMiddlewareを実装する形としました。</p>\n<p>redux-efects-stepsを使用したアクションの定義は以下のようになります。</p>\n<p></p><pre class=\"crayon-plain-tag\">// Marker Reducer - async action creator\nimport { steps } from 'redux-effects-steps'\nimport actionCreatorFactory from 'typescript-fsa'\nimport fetchMarkerFromAPI from '../middleware/markerFetcherMiddleware'\n\nconst actionCreator = actionCreatorFactory()\n\nexport const fetchMarkerRequest = actionCreator('FETCH_MARKER_REQUEST')\nexport const fetchMarkerSuccess = actionCreator&#60;Marker[]&gt;(\n  'FETCH_MARKER_SUCCESS',\n)\nexport const fetchMarkerFail = actionCreator&#60;ErrorType&#62;('FETCH_MARKER_FAIL')\n\nexport const fetchMarker = (searchConditions: SearchConditions) =&#62; {\n  return steps(fetchMarkerRequest(), fetchMarkerFromAPI(searchConditions), [\n    fetchMarkerSuccess,\n    fetchMarkerFail,\n  ])\n}</pre><p></p>\n<p>fetchMarkerActionsをDispatchすることで一連のFetch処理がredux-effects-stepsのMiddlewareによってハンドリングされます。fetchMarkerFromAPIアクションから返ってきたPromiseがresolveされている場合はSuccess、rejectされている場合はFailが実行されます。</p>\n<p>実際にFetch処理を行うMiddlewareは、例えば以下のような実装です。</p>\n<p></p><pre class=\"crayon-plain-tag\">// Marker Fetcher Middleware\nimport actionCreatorFactory from 'typescript-fsa'\n\nconst actionCreator = actionCreatorFactory()\n\nconst FETCH_MARKER_FROM_API = 'FETCH_MARKER_FROM_API'\nexport const fetchMarkerFromAPI = actionCreator&#60;SearchConditions&#62;(\n  FETCH_MARKER_FROM_API,\n)\n\nexport const fetchMakerFunction = async (\n  searchCondition: SearchCondition,\n): Promise&#60;Marker[] | ErrorType&#62; =&#62; {\n  // Fetch処理, エラーハンドリング\n  ........\n\n  return markers\n}\n\nconst markerFetcherMiddleware = (): Middleware =&#62; {\n  return () =&#62; (next: Dispatch&#60;AnyAction&#62;) =&#62; (\n    action: any,\n  ): Promise&#60;Marker[] | ErrorType&#62; =&#62; {\n    if (action.type !== FETCH_MARKER_FROM_API) {\n      return next(action)\n    }\n\n    const { searchConditions } = action.payload\n    return fetchMarkerFunction(searchConditions)\n  }\n}\n\nexport default markerFetcherMiddleware()</pre><p></p>\n<p>このような非同期通信アクションに対しては、Dispatchされるアクションの実行内容が正しいかをテストしていきます。Fetch処理を行うMiddlewareに対しては別でテストを書くことになります。</p>\n<p>テストにおいては通信処理をモックする必要があるため、Jestのモック機能によって関数単位でのモックを行うか、<a href=\"http://www.wheresrhys.co.uk/fetch-mock/\">fetch-mock</a>などを使って通信をモックします。</p>\n<p>非同期アクションに対してのテストでは、Fetch処理を行う関数ごとモックしてテストを行いました。</p>\n<p></p><pre class=\"crayon-plain-tag\">import steps from 'redux-effects-steps'\nimport configureMockStore from 'redux-mock-store'\nimport markerFetcherMiddleware, * as module from '../../middleware/markerFetcherMiddleware'\nimport {\n  fetchMarker,\n  fetchMarkerRequest,\n  fetchMarkerSuccess,\n  fetchMarkerFail,\n} from '../markerReducer'\n\nconst mockStore = configureMockStore([markerFetcherMiddleware, steps])\n\ndescribe('async actions', () =&#62; {\n  test('creates FETCH_MARKER_SUCCESS when fetching markers has been done', async () =&#62; {\n    const searchConditions: SearchConditions = { type: 'ALL' }\n    const markers: Marker[] = [{ lat: 1, lng: 1 }]\n    jest.spyOn(module, 'fetchMarkerFunction').mockImplementationOnce(() =&#62;\n      Promise.resolve(markers),\n    )\n    const expectedActions = [\n      fetchMarkerRequest(),\n      fetchMarkerSuccess(markers),\n    ]\n    const store = mockStore({ markers: [] })\n\n    await store.dispatch(fetchMarker(searchConditions))\n\n    expect(store.getActions()).toEqual(expectedActions)\n  })\n\n  ........\n})</pre><p></p>\n<p>Redux Thunkなどを使用している場合は、<a href=\"https://redux.js.org/recipes/writing-tests#async-action-creators\">Redux公式Document</a>にもテスト例が紹介されているため、参考にしながらテストを拡充していくと良いと思います。</p>\n<p>&#160;</p>\n<p>このように、Reduxにおける一連のフローに対してテストを書いていくことでReduxの状態変更・ロジックを保証していきます。</p>\n<p>アプリケーションにおける状態管理・ロジックをRedux側に寄せた上で、Reduxにおける一連のフローに対してテストを拡充していくことによって、アプリケーション全体のロジック部分をテストによって担保しつつ、ReduxのStateに基づいているViewも演繹的に保証することができます。</p>\n<p>しかし、Reduxによって保証できるのはあくまでStateに基づく部分のみで、アプリケーションの重要な部分として、Viewやコード全体の整合性などもあります。次の章ではそのようなアプリケーション全体に対してテストしていくための方法を紹介していきます。</p>\n<h2>アプリケーション全体でのテストについて</h2>\n<p>ここまでに紹介してきたように、React+Reduxの構成においては、Reduxのテストを書くことでアプリケーション全体のロジック・振る舞いに対するテストをしています。</p>\n<p>一方で、コンポーネントの表示やユーザーインタラクションに対するイベントの処理などは別の方法でテストしていく必要があります。</p>\n<h3>アプリケーションテストの考え方</h3>\n<p>フロントエンドアプリケーションに対してテストする上では、Viewをどの程度までテストによって保証するべきか決める必要があります。</p>\n<p>この考え方の一つにTesting Pyramidがあり、これはテストを走らせた時のスピードとテストを書くコストはトレードオフであるという考えをもとに、書くべきテストの比率を示したものです。</p>\n<img class=\"aligncenter wp-image-8743\" src=\"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191517/TestPyramid1.png\" alt=\"\" width=\"622\" height=\"350\" srcset=\"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191517/TestPyramid1.png 800w, https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191517/TestPyramid1-500x281.png 500w, https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191517/TestPyramid1-768x432.png 768w\" sizes=\"(max-width: 622px) 100vw, 622px\" />\n<p>Testing Pyramidでは、コストも安く、実行速度も速いUnit Testが最も多く書くべきテストであることが示されています。</p>\n<p>一方でフロントエンドアプリケーションにおいてはテストによって何が保証できているかを考える必要があります。実装の詳細をテストしすぎても（例えばボタンの色が緑色であることをテストしても）テストによって保証できることよりもコストの方が大きくなってしまいます。</p>\n<p>そのようなフロントエンド開発におけるテストの課題に対して、<a href=\"https://testingjavascript.com\">Testing Trophy</a> というコンセプトがKent C.Doddsにより提唱されています。</p>\n<img class=\"wp-image-8778 size-medium aligncenter\" src=\"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/14194111/74158a07b141a5dc143ba6c6af1afba7-402x500.png\" alt=\"\" width=\"402\" height=\"500\" srcset=\"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/14194111/74158a07b141a5dc143ba6c6af1afba7-402x500.png 402w, https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/14194111/74158a07b141a5dc143ba6c6af1afba7.png 480w\" sizes=\"(max-width: 402px) 100vw, 402px\" />\n<p>(引用元: <a href=\"https://testingjavascript.com/\">https://testingjavascript.com</a>)</p>\n<p>Testing Trophyでは、Testing Pyramidにはなかった「Static」の項目が追加されており、それぞれのテストの比率も大きく変わっています。</p>\n<p>Testing Trophyには、「自信係数」という考えがあり、上に行くほどそのテストがアプリケーションが正しく動くことへの自信を与えるものである、という点を考慮しています。</p>\n<p>Testing PyramidではUnitテストの方がコストも小さく実行速度も速いので、この点だけを考えると、Unitテストを書くという方向性になります。</p>\n<p>しかしTesting Trophyの自信係数が示すように、「テストによってどれだけソフトウェアがちゃんと動くことを担保できるのか」という観点が、テストを考える上では重要です。</p>\n<p>Trophyの各項目の大きさが書くべきテストの総量を示しており、Kentは自信係数、スピード、コストを考慮した際に最もトレードオフのバランスが良いIntegration Testを書くべきと提唱しています。</p>\n<p>これまで挙げてきたReduxテストはUnit Testであるとともに、Integration Testの部分も担っています。Reduxが扱っているのはViewによるイベントが発火した際の状態変更であり、複数のコンポーネントにまたがった変更に対してのテストであるため、Integration Testの役割も内包しています。</p>\n<p>そのため、Reducer等に対してテストすることで、複数コンポーネントの結合部分をテストしているのに近い結果が得られます。</p>\n<p>ここまで見てきたのはReduxに対してのテストによるアプリケーション動作の担保についてでしたが、実際のアプリケーションとしてテストすべき対象には、UI表示やユーザーインタラクションに対するイベント処理などのView側のテストなどがあります。そしてそれ以外にも静的解析によって実装の正しさの担保を行うことができます。</p>\n<p>これらに関しても、スピード、コスト、そして自信係数のトレードオフを考慮しながら、アプリケーション全体のテスト戦略を決めていくのが重要になります。</p>\n<p>この章では、Reactコンポーネントに対してのテストを書くのに使えるライブラリと、静的解析のための仕組みを紹介します。</p>\n<h3>Enzyme, React Testing Library</h3>\n<p>React コンポーネントにテストを記述するためのライブラリとして <a href=\"https://enzymejs.github.io/enzyme/\">Enzyme</a> と <a href=\"https://testing-library.com\">React Testing Library</a> があります。</p>\n<p>これらはどちらが明確に良いというものではなく、どのようなテストを書きやすいようにデザインされているかという点に違いがあります。</p>\n<p>EnzymeはReactコンポーネントの出力についてアサートや操作を行う、いわゆるUnitテスト的な書き方に適しています。一方でReact Testing Libraryは、ユーザーが使う際の操作をコンポーネントに適用していくような形で記述していく、E2Eテスト的な書き方に適しています。</p>\n<p>そのため両者は、アプリケーションのViewに対してどのような内容を保証したいかによって使い分けるべきものです。Viewについてもコンポーネントレベルで動作を保証するテストを書きたい場合にはEnzyme、重要な画面やコンポーネントに対してユーザー操作に対する挙動を保証したい場合にはReact Testing Libraryを導入するとよいです。</p>\n<p>横断地図では、React Testing LibraryによるE2Eテストを導入しており、ユーザーがランディングした際の導線のテストなどを追加しています。</p>\n<h3>Storybook</h3>\n<p>Viewコンポーネントのレンダリング結果を確認しやすくするためのライブラリとして<a href=\"https://storybook.js.org\">Storybook</a>があります。</p>\n<p>Storybookはコンポーネントのカタログのように使えますが、propsに渡す値を変えて表示することで、アプリケーションを起動せずとも各状態の時のコンポーネントの表示を確認することができるので便利です。</p>\n<p>他のコンポーネントとの相互作用を切り離せる上に、アプリケーションで所定の状態を再現しなくてもViewを確認できるため、コンポーネントのスタイルを実装する際に使うことで実装の助けにもなります。</p>\n<p>ViewのUnitテストのような、他のコンポーネントの実装と切り離したViewを確認する用途でも、Storybookを使うことができます。</p>\n<p>横断地図でも、Reactコンポーネントを実装する際にStorybookを活用して、画面とのつなぎ込みを行う前から表示を確認・調整したり、各propsに対するViewの内容を確認したりしています。</p>\n<img class=\"wp-image-8742 aligncenter\" src=\"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191510/Storybook1-500x228.png\" alt=\"\" width=\"700\" height=\"319\" srcset=\"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191510/Storybook1-500x228.png 500w, https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191510/Storybook1-768x350.png 768w, https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191510/Storybook1.png 943w\" sizes=\"(max-width: 700px) 100vw, 700px\" />\n<h3>TypeScript</h3>\n<p><a href=\"https://www.typescriptlang.org\">TypeScript</a>を使うことで、JavaScriptに対して型を書くことができます。</p>\n<p>これまでに挙げた、テストケースを書くようなものとは違いますが、型も実装の正しさを担保する上では非常に有用です。</p>\n<p>TypeScriptを導入することによって、各コンポーネント間のPropsの受け渡しやコンポーネントがReduxから受け取るStateの値の想定が実装として正しいかを型によって検査することができます。</p>\n<p>型による恩恵は非常に大きく、IDEによるサジェストも充実する上、テストケースなどとは違った側面から、実装の正しさを強力に担保してくれる仕組みとなります。</p>\n<p>特にReduxのStateの設計が変更された場合などには、型によって変更が波及している範囲を型チェックによって追うことができるため、設計の変更を行った際に不整合を残してしまうリスクを低減することもできます。</p>\n<p>TypeScriptによって担保できる内容はReduxテストとは異なり、型レベルでの整合性です。これにより、主にコンポーネント間の値の受け渡しや、Storeで持っている状態が他の部分の実装と乖離していないか等を、開発中に知ることができます。</p>\n<p>型との不整合が起きればIDEによる警告が出るためすぐに実装の間違いに気づくことができ、これを型による一つの自動テストと考えることもできます。</p>\n<p>型をしっかりと書くことはコストがかかりますが、単体テストを充実させるのと同等か、それ以上に恩恵を受けることができます。</p>\n<h3>ESLint / Prettier</h3>\n<p><a href=\"https://eslint.org\">ESLint</a>はJavaScriptのLinter、<a href=\"https://prettier.io\">Prettier</a>はコードフォーマッターです。</p>\n<p>これもテストケースを書くようなものとは違いますが、適切に運用することで実装ルールを徹底することができたり、記述上のミスを編集中に防ぐことができるため、実装の正しさを支えてくれるものです。</p>\n<p>ESLintには<a href=\"https://github.com/yannickcr/eslint-plugin-react\">React用のプラグイン</a>のようにReact特有のベストプラクティスを運用するための追加ルールなどもあり、こういった細かいながらチームで統一していきたいようなルールを、機械的に適用していくことができます。</p>\n<p>細かい記述の正しさやベストプラクティスは、テストケースや型で保証しにくい部分ですが、ESLint / Prettierを適切に運用することでそれらの部分を補うことができます。</p>\n<h2>テストを活用した開発の円滑化</h2>\n<p>横断地図では、Reduxの実装部分には全てテストを書くこと、Reactコンポーネントには基本的にStorybookを書くこと、TypeScriptの型を基本的に書くこと(no implicit anyを適用)をルールとして運用しました。これによって、レビュアーの負担を大幅に減らしながら開発することができました。</p>\n<p>これらがないと、レビュアーはPull Requestが挙がってきた時点で書かれているコードが正しく動くのか、また書かれているロジックの挙動が正しいのかをコードを読み解いて確認する必要に迫られます。</p>\n<p>特にビジネスロジックは複雑なものであるほど不具合を見逃しやすく、確認自体の負担も大きくなります。<br />\nReduxのテストケースがしっかりと書かれていることで、挙動が正しいかどうかはテストケースの内容から確認できるため、わざわざアプリケーションを起動して落ちそうなケースを再現して確認するという必要がなくなります。</p>\n<p>実装が変わった時やリファクタリングを行った時にも、デグレードが起きていないか否かは、テストケースが落ちていないことや型に不整合が起きていないことから確認できます。また、型チェックが行われていることによって、設計を変更した場合にも、受け渡す値に型レベルでの不整合が起きてないかといった内容を検証してレビューする手間も減ります。</p>\n<p>Jenkinsを使って、リポジトリにpushされたタイミングでテスト・Lint・型をチェックし、失敗している場合にはSlack通知を流すというフローも運用することで、レビューする前には基本的なチェックが終わった状態になっています。</p>\n<p>実装の中で変更を加えた際にデグレードが起きた場合でも、Failしたテストケースの内容や型のアサートの内容を見れば修正対象や修正方針が分かるため、その後の修正も行いやすいです。</p>\n<p>TypeScriptの型をしっかりと書いておくことで、テストと合わせて、開発の中でデグレが起きた際にバグが発生するという形ではなく型コンパイル/テストケースの失敗という形で、事前に検知できることになります。</p>\n<p>細かい記述スタイルや記述ルールについてはESLint / Prettier / <a href=\"https://stylelint.io\">Stylelint</a>を使い、push前にチェック・修正を自動的に行うことにより、細かい記述スタイルに関する指摘・議論を行う必要がなくなります。</p>\n<p>このような仕組みによって運用することによって、実装にバグがないかの検証も、型やテストによって補完しながら見ていくことができます。</p>\n<p>結果としてレビュアーの負担を減らすことができ、レビューでは実装の方針や設計についての議論に集中しやすくなります。</p>\n<h2>横断地図での取り組みとその成果</h2>\n<p>横断地図では、これまでに述べたようなテスト戦略のもと、Redux側の処理部分に対してテストを拡充しながら開発を進めていった結果、テストカバレッジとして90％以上の水準でテストを整備することができました。</p>\n<p>カバレッジを目標においていたわけではないのですが、テスト戦略としてReduxを手厚くテストすること、実装の担保としてのテストにすることを目標にしたことで、結果的に高いカバレッジを達成することができました。</p>\n<img class=\"size-full wp-image-8752 aligncenter\" src=\"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/14133504/CoverageResultUpdated.png\" alt=\"\" width=\"680\" height=\"257\" srcset=\"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/14133504/CoverageResultUpdated.png 680w, https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/14133504/CoverageResultUpdated-500x189.png 500w\" sizes=\"(max-width: 680px) 100vw, 680px\" />\n<p>その結果として、コード規模2万6千行程(テストコード除く)に対して、テストフェーズにおけるバグ発生件数は、軽微なものも含めると50件程度という形で開発を完了することができました。</p>\n<p>その内訳としては以下のような結果でした。</p>\n<ul>\n<li>デザインのずれや表示崩れなど：十数件</li>\n<li>実装上の不備があったもの：十数件</li>\n<li>挙動にバグがあったもの：20件弱</li>\n</ul>\n<p>このうち、多くはコンポーネント側の挙動に起因しているもので、軽微なものも多く、テスト戦略において重点的に保証していたReduxの実装に起因したバグは3件程度でした。</p>\n<p>これは、テスト戦略の狙いとしてはある程度達成していると言えます。結果的に、テストフェーズにおいて重大な手戻りや遅れなども発生せず開発を完了することができました。</p>\n<p>横断地図の初期開発においては、テストによってStateを保証することで、Viewを保証していくという方針のもと、Reduxテストを拡充してきました。</p>\n<p>今後機能のエンハンスを進めていく上で継続的に開発しやすい仕組みを作るために、E2Eテストの拡充や、Visual Regressionテストなども取り入れることで、アプリケーション全体でのテストによって保証できる範囲を広げてゆき、自信を持ってアプリケーションを変更していけるような仕組みを整えていければと考えています。</p>\n<h2>最後に</h2>\n<p>この記事では、横断地図の開発で採用したReact+Reduxアプリケーションにおけるテスト戦略について紹介しました。</p>\n<p>Reduxに状態管理を寄せた上でReduxに対してテストを拡充していく方針を取る際に、React Reduxの状態変更によるパフォーマンス影響は気をつける必要があります。<br />\nReactにおけるパフォーマンスチューニングについては辻健人さんによる<a href=\"https://recruit-tech.co.jp/blog/2018/09/19/react_spa_performance_tuning/\">こちらの記事</a>を参考にしました。</p>\n<p>Selectorの章で紹介したGoogleMaps上のマーカーの例を含め、横断地図ではパフォーマンスでボトルネックになっている点を分析して改善を行いながら開発を進めてきました。</p>\n<p>そういったパフォーマンスチューニングのための変更を行う際も、テストと型があることによって自信を持ってアプリケーションを変更していくことができました。</p>\n<p>テストを書くことはそれ自体もコストがかかる上、どこまでをテストするのかはフロントエンドアプリケーションの難しい部分ではありますが、テストがあることによる恩恵は初期開発に限ったものではなく、エンハンスを続けていく上での資産となると思います。</p>\n<p>この記事が、React+Reduxアプリケーションのテストを書く上で少しでも参考になれば幸いです。</p>\n","descriptionType":"html","publishedDate":"Wed, 15 Jul 2020 06:44:34 +0000","feedId":33911,"bgimg":"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191439/SUUMOMapDemo1.gif","linkMd5":"da1936c63488aefaac0d31a66b55d373","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn1@2020_1/2020/10/19/03-10-01-745_6c5705f5c6201363.webp","destWidth":374,"destHeight":664,"sourceBytes":4962895,"destBytes":7646912,"author":"高橋勇人","articleImgCdnMap":{"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191439/SUUMOMapDemo1.gif":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn1@2020_1/2020/10/19/03-10-01-745_6c5705f5c6201363.webp","https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175509/ReduxActionFlow-1024x576.png":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn11@2020_1/2020/10/19/03-10-06-495_a6620121117cbd0f.webp","https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175511/ReduxTestTarget-1024x576.png":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn30@2020_1/2020/10/19/03-10-06-098_8d462c2fc75854a0.webp","https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191517/TestPyramid1.png":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn20@2020_2/2020/10/19/03-10-06-107_6e5419df4dcb7ce0.webp","https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/14194111/74158a07b141a5dc143ba6c6af1afba7-402x500.png":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn23@2020_4/2020/10/19/03-10-06-125_dd13d1e200888397.webp","https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191510/Storybook1-500x228.png":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn27@2020_1/2020/10/19/03-10-06-086_9b04097c500f1eff.webp","https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/14133504/CoverageResultUpdated.png":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn13@2020_4/2020/10/19/03-10-05-857_1bd779ecaa179f62.webp"},"publishedOrCreatedDate":1603076989257}],"record":{"createdTime":"2020-10-19 11:09:49","updatedTime":"2020-10-19 11:09:49","feedId":33911,"fetchDate":"Mon, 19 Oct 2020 03:09:49 +0000","fetchMs":1334,"handleMs":6682,"totalMs":27154,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"71aab6be87ca2a527ee0da8dd54c34d1","hostName":"europe69*","requestId":"0fded3768a6543abb1294d34b6842f9a_33911","contentType":"application/rss+xml; charset=UTF-8","totalBytes":7744226,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":7,"articlesImgsGithubTotal":7,"successGithubMap":{"myreaderx25":1,"myreaderx32":1,"myreaderx3":1,"myreaderx12":1,"myreaderx2":1,"myreaderx13":1,"myreaderx29":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:59:59","updatedTime":"2020-09-07 02:59:59","id":33911,"name":"リクルートテクノロジーズ　メンバーズブログ","url":"https://recruit-tech.co.jp/blog/feed/","subscriber":95,"website":null,"icon":"https://recruit-tech.co.jp/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"https://recruit-tech.co.jp"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":7646912,"tmpBodyImgCdnBytes":97314,"tmpBgImgCdnBytes":0,"extra4":{"start":1603076980374,"total":0,"statList":[{"spend":2201,"msg":"获取xml内容"},{"spend":6682,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":2974,"msg":"正文链接上传到cdn"}]},"extra5":7,"extra6":7,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-013.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-038.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-23.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-22.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-60.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-014.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191439/SUUMOMapDemo1.gif","sourceStatusCode":200,"destWidth":374,"destHeight":664,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn1@2020_1/2020/10/19/03-10-01-745_6c5705f5c6201363.webp","sourceBytes":4962895,"destBytes":7646912,"targetWebpQuality":75,"feedId":33911,"totalSpendMs":15117,"convertSpendMs":8057,"createdTime":"2020-10-19 11:09:49","host":"us-033*","referer":"https://recruit-tech.co.jp/blog/?p=8726","linkMd5ListStr":"da1936c63488aefaac0d31a66b55d373,da1936c63488aefaac0d31a66b55d373","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"4.7 MB","destSize":"7.3 MB","compressRate":"154.1%"},{"code":1,"isDone":false,"source":"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191510/Storybook1-500x228.png","sourceStatusCode":200,"destWidth":500,"destHeight":228,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn27@2020_1/2020/10/19/03-10-06-086_9b04097c500f1eff.webp","sourceBytes":124601,"destBytes":12890,"targetWebpQuality":75,"feedId":33911,"totalSpendMs":2158,"convertSpendMs":10,"createdTime":"2020-10-19 11:10:04","host":"us-013*","referer":"https://recruit-tech.co.jp/blog/?p=8726","linkMd5ListStr":"da1936c63488aefaac0d31a66b55d373","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"121.7 KB","destSize":"12.6 KB","compressRate":"10.3%"},{"code":1,"isDone":false,"source":"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/14194111/74158a07b141a5dc143ba6c6af1afba7-402x500.png","sourceStatusCode":200,"destWidth":402,"destHeight":500,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn23@2020_4/2020/10/19/03-10-06-125_dd13d1e200888397.webp","sourceBytes":138992,"destBytes":12310,"targetWebpQuality":75,"feedId":33911,"totalSpendMs":2221,"convertSpendMs":16,"createdTime":"2020-10-19 11:10:04","host":"us-038*","referer":"https://recruit-tech.co.jp/blog/?p=8726","linkMd5ListStr":"da1936c63488aefaac0d31a66b55d373","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"135.7 KB","destSize":"12 KB","compressRate":"8.9%"},{"code":1,"isDone":false,"source":"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175511/ReduxTestTarget-1024x576.png","sourceStatusCode":200,"destWidth":1024,"destHeight":576,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn30@2020_1/2020/10/19/03-10-06-098_8d462c2fc75854a0.webp","sourceBytes":85663,"destBytes":27338,"targetWebpQuality":75,"feedId":33911,"totalSpendMs":2300,"convertSpendMs":125,"createdTime":"2020-10-19 11:10:04","host":"us-014*","referer":"https://recruit-tech.co.jp/blog/?p=8726","linkMd5ListStr":"da1936c63488aefaac0d31a66b55d373","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"83.7 KB","destSize":"26.7 KB","compressRate":"31.9%"},{"code":1,"isDone":false,"source":"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/14133504/CoverageResultUpdated.png","sourceStatusCode":200,"destWidth":680,"destHeight":257,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn13@2020_4/2020/10/19/03-10-05-857_1bd779ecaa179f62.webp","sourceBytes":32604,"destBytes":12476,"targetWebpQuality":75,"feedId":33911,"totalSpendMs":2509,"convertSpendMs":14,"createdTime":"2020-10-19 11:10:04","host":"europe-23*","referer":"https://recruit-tech.co.jp/blog/?p=8726","linkMd5ListStr":"da1936c63488aefaac0d31a66b55d373","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"31.8 KB","destSize":"12.2 KB","compressRate":"38.3%"},{"code":1,"isDone":false,"source":"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13191517/TestPyramid1.png","sourceStatusCode":200,"destWidth":800,"destHeight":450,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn20@2020_2/2020/10/19/03-10-06-107_6e5419df4dcb7ce0.webp","sourceBytes":87361,"destBytes":13676,"targetWebpQuality":75,"feedId":33911,"totalSpendMs":2549,"convertSpendMs":28,"createdTime":"2020-10-19 11:10:04","host":"europe-60*","referer":"https://recruit-tech.co.jp/blog/?p=8726","linkMd5ListStr":"da1936c63488aefaac0d31a66b55d373","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"85.3 KB","destSize":"13.4 KB","compressRate":"15.7%"},{"code":1,"isDone":false,"source":"https://s3-ap-northeast-1.amazonaws.com/prod-rtc-blog/wp-content/uploads/2020/07/13175509/ReduxActionFlow-1024x576.png","sourceStatusCode":200,"destWidth":1024,"destHeight":576,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn11@2020_1/2020/10/19/03-10-06-495_a6620121117cbd0f.webp","sourceBytes":332225,"destBytes":18624,"targetWebpQuality":75,"feedId":33911,"totalSpendMs":2950,"convertSpendMs":30,"createdTime":"2020-10-19 11:10:04","host":"europe-22*","referer":"https://recruit-tech.co.jp/blog/?p=8726","linkMd5ListStr":"da1936c63488aefaac0d31a66b55d373","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"324.4 KB","destSize":"18.2 KB","compressRate":"5.6%"}],"successGithubMap":{"myreaderx25":1,"myreaderx32":1,"myreaderx3":1,"myreaderx12":1,"myreaderx2":1,"myreaderx13":1,"myreaderx29":1},"failGithubMap":{}}