{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2021-09-28 20:15:29","updatedTime":"2021-09-28 20:15:29","title":"面试官让我手写队列，差点点没写出来 ","link":"https://segmentfault.com/a/1190000040689400","description":"<h3>前言</h3>\n<p>栈和队列是一对好兄弟，前面我们介绍过一篇栈的文章(栈，不就后进先出)，栈的机制相对简单，后入先出，就像进入一个狭小的山洞，山洞只有一个出入口，只能<strong>后进先出(在外面的先出去，堵在里面先进去的就有点倒霉)</strong>。而队列就好比是一个隧道，后面的人跟着前面走，<strong>前面人先出去(先入先出)</strong>。日常的排队就是队列运转形式的一个描述！</p>\n<p>栈是一种喜新厌旧的数据结构，来了新的就会处理新的把老的先停滞在这(我们找人、约人办事最讨厌这种人)，队列就是大公无私的一种数据结构，排队先来先得，讲究<strong>顺序</strong>性，所以这种数据结构在程序设计、中间件等都非常广泛的应用，例如消息队列、FIFO磁盘调度、二叉树层序遍历、BFS宽度优先搜索等等。</p>\n<p>队列的核心理念就是：<strong>先进先出！</strong></p>\n<p><strong>队列的概念</strong>：队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>\n<p>同时，阅读本篇文章最好先弄懂<a href=\"https://segmentfault.com/a/1190000039993567\">顺序表的基本操作</a>和<a href=\"https://segmentfault.com/a/1190000040217883\">栈的数据结构</a>！学习效果更佳！<br><img src=\"https://segmentfault.com/img/remote/1460000020600434\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\" /></br></p>\n<h3>队列介绍</h3>\n<p>我们设计队列时候可以选择一个标准，这里就拿<a href=\"https://leetcode-cn.com/problems/design-circular-queue/\" rel=\"nofollow noreferrer\">力扣622设计循环队列</a>作为队列设计的标准。</p>\n<p><strong>队头front：</strong>删除数据的一端。</p>\n<p><strong>队尾rear：</strong> 插入数据的一端。</p>\n<p><strong>对于数组</strong>，从数组后面插入更容易，数组前面插入较困难，所以一般用数组实现的队列队头在数组前面，队尾在数组后面；而对于<strong>链表</strong>，插入删除在两头分别进行那么头部(前面)删除尾部插入最方便的选择。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000040689402\" alt=\"image-20210506164342258\" title=\"image-20210506164342258\" /></p>\n<p>实现方法：</p>\n<ul>\n <li>MyCircularQueue(k): 构造器，设置队列长度为 k 。</li>\n <li>Front: 从队首获取元素。如果队列为空，返回 -1 。</li>\n <li>Rear: 获取队尾元素。如果队列为空，返回 -1 。</li>\n <li>enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。</li>\n <li>deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。</li>\n <li>isEmpty(): 检查循环队列是否为空。</li>\n <li>isFull(): 检查循环队列是否已满。</li>\n</ul>\n<h3>普通队列</h3>\n<p>按照上述的介绍，我们很容易知道数组实现的方式。用数组模拟表示队列。要考虑初始化，插入，问题。<br><img src=\"https://segmentfault.com/img/remote/1460000040689403\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\" /></br></p>\n<p>在这个普通队列一些操作需要注意的有：</p>\n<p><strong>初始化</strong>：数组的front和rear都指向0. (front和rear下标相等的时候说明队列为空)</p>\n<p>入队：队不满，数组不越界，先队尾位置传值，再队尾下标+1(队尾rear实际上超前一位，为了区分空队列情况)</p>\n<p>出队：队不空，先取队头位置元素，在队头+1。</p>\n<p>但是很容易发现<strong>问题</strong>，每个空间域只能利用一次，造成空间极度浪费，非常容易越界！<br><img src=\"https://segmentfault.com/img/remote/1460000040689404\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\" /></br></p>\n<h3>循环队列(数组实现)</h3>\n<blockquote>\n 针对上述的问题。有个较好的解决方法！就是对\n <strong>已经申请</strong>的(数组)内存重复利用。这就是我们所说的循环队列。循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。\n</blockquote>\n<p>数组实现的循环队列就是在<strong>逻辑上</strong>作修改。因为我们队列中只需要front和rear两个指针。rear在逻辑上在后面，front在逻辑上是在前面的，但实际上它们不一定谁在前谁在后，在计算距离的时候需要给rear先补上数组长度减去front，然后求余即可。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000040689405\" alt=\"image-20210829093903850\" title=\"image-20210829093903850\" /></p>\n<p><strong>初始化</strong>：数组的front和rear都指向0. 这里需要注意的是：front和rear位于同一个位置时候，证明队列里面是空的。还有在这里我具体实现时候将数组申请大了一个位置空出来，防止队列满的情况又造成front和rear在同一个位置。</p>\n<p><strong>入队</strong>：队不满，先队尾位置传值，再<code>rear=(rear + 1) % maxsize;</code></p>\n<p><strong>出队</strong>：队不空，先取队头位置元素，<code>front=(front + 1)% maxsize;</code></p>\n<p>这里出队入队指标相加如果遇到最后需要转到头位置，这里直接+1求余找到位置(相比判断是否在最后更加简洁)，其中<strong>maxsize</strong>是数组实际大小。</p>\n<p><strong>是否为空</strong>：<code>return rear == front;</code></p>\n<p><strong>大小</strong>：<code>return (rear+maxsize-front)%maxsize;</code> 这里很容易理解，一张图就能解释清楚，无论是front实际在前在后都能满足要求。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000040689406\" alt=\"image-20210506121914099\" title=\"image-20210506121914099\" /></p>\n<p>这里面有几个大家需要注意的，就是指标相加如果遇到最后需要转到头的话。可以判断是否到数组末尾位置。也可以直接+1求余。其中<strong>maxsize</strong>是数组实际大小。</p>\n<p>具体实现：</p>\n<pre><code class=\"java\">public class MyCircularQueue {\n    private int data[];// 数组容器\n    private int front;// 头\n    private int rear;// 尾\n    private int maxsize;// 最大长度\n    public MyCircularQueue(int k) {\n        data = new int[k+1];\n        front = 0;\n        rear = 0;\n        maxsize = k+1;\n    }\n\n    public boolean enQueue(int value)  {\n        if (isFull())\n            return  false;\n        else {\n            data[rear] = value;\n            rear=(rear + 1) % maxsize;\n        }\n        return  true;\n    }\n\n    public boolean deQueue() {\n        if (isEmpty())\n            return false;\n        else {\n            front=(front+1)%maxsize;\n        }\n        return  true;\n    }\n\n    public int Front() {\n        if(isEmpty())\n            return -1;\n        return data[front];\n    }\n\n    public int Rear() {\n        if(isEmpty())\n            return -1;\n        return data[(rear-1+maxsize)%maxsize];\n    }\n\n    public boolean isEmpty() {\n        return rear == front;\n    }\n\n    public boolean isFull() {\n        return (rear + 1) % maxsize == front;\n    }\n}</code></pre>\n<h3>循环队列(链表实现)</h3>\n<blockquote>\n 对于链表实现的队列，要根据先进先出的规则考虑头和尾的位置\n</blockquote>\n<p>我们知道队列是先进先出的，对于链表，我们能采用单链表尽量采用单链表，能方便尽量方便，同时还要兼顾效率。使用链表大概有两个实现方案：</p>\n<p><strong>方案一</strong> 如果队列头设在链表尾，队列尾设在链表头。那么<strong>队尾进队插入</strong>在链表头部插入没问题，容易实现，但是如果<strong>队头删除</strong>在链表尾部进行，如果不设置尾指针要遍历到队尾，但是设置尾指针删除需要将它前驱节点<strong>需要双向链表</strong>，都挺麻烦的。</p>\n<p><strong>方案二</strong>如果队列头设在链表头，队列尾设在链表尾，那么<strong>队尾进队插入</strong>在链表尾部插入没问题(用尾指针可以直接指向next)，容易实现，如果<strong>队头删除</strong>在链表头部进行也很容易，就是我们前面常说的<strong>头节点删除节点</strong>。</p>\n<p>所以我们最终采取的是方案2的带头节点、带尾指针的单链表!</p>\n<p>主要操作为：</p>\n<p><strong>初始化</strong>：设立一个头结点，是front和rear都先指向它。</p>\n<p><strong>入队</strong>：<code>rear.next=va;rear=va</code>;（va为被插入节点）<br><img src=\"https://segmentfault.com/img/remote/1460000040689407\" alt=\"image-20210506152016164\" title=\"image-20210506152016164\" /></br></p>\n<p><strong>出队</strong>：队不空，<code>front.next=front.next.next;</code>经典带头节点删除，但是如果仅有一个节点删除时候，需要多加一个rear=front，不然rear就失联啦。<br><img src=\"https://segmentfault.com/img/remote/1460000040689408\" alt=\"image-20210506152501663\" title=\"image-20210506152501663\" /></br></p>\n<p><strong>是否为空</strong>：<code>return rear == front;</code> 或者自定义维护len判断<code>return len==0</code></p>\n<p><strong>大小</strong>：节点front遍历到rear的个数，或者自定义维护len直接返回(这里并没实现)。</p>\n<p>实现代码：</p>\n<pre><code class=\"java\">public class MyCircularQueue{\n     class node {\n        int data;// 节点的结果\n        node next;// 下一个连接的节点\n        public node() {}\n        public node(int data) {\n            this.data = data;\n        }\n    }\n    node front;//相当于head 带头节点的\n    node rear;//相当于tail/end\n    int maxsize;//最大长度\n    int len=0;\n    public MyCircularQueue(int k) {\n        front=new node(0);\n        rear=front;\n        maxsize=k;\n        len=0;\n    }\n    public boolean enQueue(int value)  {\n        if (isFull())\n            return  false;\n        else {\n            node va=new node(value);\n            rear.next=va;\n            rear=va;\n            len++;\n        }\n        return  true;\n    }\n    public boolean deQueue() {\n        if (isEmpty())\n            return false;\n        else {\n            front.next=front.next.next;\n            len--;\n            //注意 如果被删完 需要将rear指向front\n            if(len==0)\n                rear=front;\n        }\n        return  true;\n    }\n\n    public int Front() {\n        if(isEmpty())\n            return -1;\n        return front.next.data;\n    }\n\n    public int Rear() {\n        if(isEmpty())\n            return -1;\n        return rear.data;\n    }\n\n    public boolean isEmpty() {\n        return  len==0;\n        //return rear == front;\n    }\n\n    public boolean isFull() {\n        return len==maxsize;\n    }    \n}</code></pre>\n<h3>双向队列(加餐)</h3>\n<p>设计实现双端队列，其实你经常使用的ArrayDeque就是一个经典的双向队列，其基于数组实现，效率非常高。我们这里实现的双向队列模板基于<a href=\"https://leetcode-cn.com/problems/design-circular-deque/\" rel=\"nofollow noreferrer\">力扣641 设计循环双端队列 </a> 。<br>你的实现需要支持以下操作：</br></p>\n<ul>\n <li>MyCircularDeque(k)：构造函数,双端队列的大小为k。</li>\n <li>insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</li>\n <li>insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</li>\n <li>deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</li>\n <li>deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</li>\n <li>getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</li>\n <li>getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</li>\n <li>isEmpty()：检查双端队列是否为空。</li>\n <li>isFull()：检查双端队列是否满了。</li>\n</ul>\n<p>其实有了上面的基础，实现一个双端队列非常容易，有很多操作和单端的循环队列是一致的，只有多了一个<strong>队头插入</strong>和<strong>队尾删除</strong>的操作，两个操作分别简单的分析一下：</p>\n<p><strong>队头插入</strong>：队友front下标位置本身是有值的，所以要将front退后一位然后再赋值，不过要考虑是否为满或者数组越界情况。</p>\n<p><strong>队尾删除</strong>：只需要rear位置减1，同时也要考虑是否为空和越界情况。</p>\n<p>具体实现代码：</p>\n<pre><code class=\"java\">public class MyCircularDeque {\n    private int data[];// 数组容器\n    private int front;// 头\n    private int rear;// 尾\n    private int maxsize;// 最大长度\n    /*初始化 最大大小为k */\n    public MyCircularDeque(int k) {\n        data = new int[k+1];\n        front = 0;\n        rear = 0;\n        maxsize = k+1;\n    }\n\n    /** 头部插入 */\n    public boolean insertFront(int value) {\n        if(isFull())\n            return false;\n        else {\n            front=(front+maxsize-1)%maxsize;\n            data[front]=value;\n        }\n        return  true;\n    }\n\n    /** 尾部插入 */\n    public boolean insertLast(int value) {\n        if(isFull())\n            return  false;\n        else{\n            data[rear]=value;\n            rear=(rear+1)%maxsize;\n        }\n        return  true;\n    }\n\n    /** 正常头部删除 */\n    public boolean deleteFront() {\n        if (isEmpty())\n            return false;\n        else {\n            front=(front+1)%maxsize;\n        }\n        return  true;\n    }\n\n    /** 尾部删除 */\n    public boolean deleteLast() {\n        if(isEmpty())\n            return false;\n        else {\n            rear=(rear+maxsize-1)%maxsize;\n        }\n        return true;\n    }\n\n    /** Get the front item  */\n    public int getFront() {\n        if(isEmpty())\n            return -1;\n        return data[front];\n    }\n\n    /** Get the last item from the deque. */\n    public int getRear() {\n        if(isEmpty())\n            return -1;\n        return  data[(rear-1+maxsize)%maxsize];\n    }\n\n    /** Checks whether the circular deque is empty or not. */\n    public boolean isEmpty() {\n        return front==rear;\n    }\n\n    /** Checks whether the circular deque is full or not. */\n    public boolean isFull() {\n        return (rear+1)%maxsize==front;\n    }\n}</code></pre>\n<h3>总结</h3>\n<p>对于队列来说数据结构相比栈复杂一些，但是也不是很难，搞懂先进先出然后用数组或者链表实现即可。</p>\n<p>对于数组，队尾tail指向的位置是空的，而链表的front（head一样）为头指针为空的，所以在不同结构实现相同效果的方法需要注意一下。</p>\n<p>数组实现的循环队列能够很大程度利用数组空间，而双向队列则是既能当队列又能当栈的一种高效数据结构，掌握还是很有必要的。</p>\n<p>最后，笔者水平有限，如果有纰漏和不足之处<strong>还请指出</strong>。另外，如果感觉不错可以点个赞，关注<strong>个人公众号</strong>：<code>bigsai</code> 更多经常与你分享，关注回复<code>bigsai</code>获取精心准备的学习资料一份！</p>","descriptionType":"html","publishedDate":"Wed, 15 Sep 2021 08:08:47 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000020600434","linkMd5":"37a85d0700f234d7451d86edfdb73ecc","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn83@2020_6/2021/09/28/12-15-37-606_8f267521a23d69c5.webp","destWidth":732,"destHeight":563,"sourceBytes":24300,"destBytes":24300,"author":"bigsai","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000020600434":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn83@2020_6/2021/09/28/12-15-37-606_8f267521a23d69c5.webp","https://segmentfault.com/img/remote/1460000040689402":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn88@2020_2/2021/09/28/12-15-40-896_9c7116c11f37cb05.webp","https://segmentfault.com/img/remote/1460000040689403":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn100@2020_2/2021/09/28/12-15-40-281_6990a42ce7338aed.webp","https://segmentfault.com/img/remote/1460000040689404":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn4@2020_4/2021/09/28/12-15-40-672_063d203952a1046a.webp","https://segmentfault.com/img/remote/1460000040689405":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn92@2020_4/2021/09/28/12-15-40-556_e5dc54dcbef6cc5a.webp","https://segmentfault.com/img/remote/1460000040689406":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn93@2020_6/2021/09/28/12-15-40-766_b66dd156b0a31366.webp","https://segmentfault.com/img/remote/1460000040689407":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn8@2020_4/2021/09/28/12-15-40-900_55369820d55e2ddf.webp","https://segmentfault.com/img/remote/1460000040689408":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn10@2020_5/2021/09/28/12-15-40-894_b1865fb2905bfdaa.webp"},"publishedOrCreatedDate":1632831329779}],"record":{"createdTime":"2021-09-28 20:15:29","updatedTime":"2021-09-28 20:15:29","feedId":6615,"fetchDate":"Tue, 28 Sep 2021 12:15:29 +0000","fetchMs":3601,"handleMs":66,"totalMs":26312,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"245d88d7b2d8f26704713c23b090d029","hostName":"us-011*","requestId":"36c6c7b69595488ea124753da0a7b3d3_6615","contentType":"application/atom+xml; charset=UTF-8","totalBytes":126850,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":8,"articlesImgsGithubTotal":8,"successGithubMap":{"myreaderx8":1,"myreaderx27":1,"myreaderx21":1,"myreaderx32":1,"myreaderx22":1,"myreaderx12":1,"myreaderx2":1,"myreaderx29":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:33:08","updatedTime":"2021-04-03 14:32:14","id":6615,"name":"SegmentFault 最新的文章","url":"http://segmentfault.com/feeds/blogs","subscriber":null,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx63/cdn75@2020_2/2021/04/03/06-32-08-760_eb238dca7c8e9f0e.jpg","description":"","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":24300,"tmpBodyImgCdnBytes":102550,"tmpBgImgCdnBytes":0,"extra4":{"start":1632831315151,"total":0,"statList":[{"spend":14562,"msg":"获取xml内容"},{"spend":66,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":3483,"msg":"正文链接上传到cdn"}]},"extra5":8,"extra6":8,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-006.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-56.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-031.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe65.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-019.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-57.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-030.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000020600434","sourceStatusCode":200,"destWidth":732,"destHeight":563,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn83@2020_6/2021/09/28/12-15-37-606_8f267521a23d69c5.webp","sourceBytes":24300,"destBytes":24300,"feedId":6615,"totalSpendMs":3003,"convertSpendMs":0,"createdTime":"2021-09-28 20:15:34","host":"us-002*","referer":"https://segmentfault.com/a/1190000040689400","linkMd5ListStr":"37a85d0700f234d7451d86edfdb73ecc,37a85d0700f234d7451d86edfdb73ecc","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23.7 KB","destSize":"23.7 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000040689403","sourceStatusCode":200,"destWidth":732,"destHeight":402,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn100@2020_2/2021/09/28/12-15-40-281_6990a42ce7338aed.webp","sourceBytes":15774,"destBytes":15774,"feedId":6615,"totalSpendMs":2585,"convertSpendMs":0,"createdTime":"2021-09-28 20:15:37","host":"us-019*","referer":"https://segmentfault.com/a/1190000040689400","linkMd5ListStr":"37a85d0700f234d7451d86edfdb73ecc","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"15.4 KB","destSize":"15.4 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000040689405","sourceStatusCode":200,"destWidth":732,"destHeight":279,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn92@2020_4/2021/09/28/12-15-40-556_e5dc54dcbef6cc5a.webp","sourceBytes":19676,"destBytes":19676,"feedId":6615,"totalSpendMs":2799,"convertSpendMs":0,"createdTime":"2021-09-28 20:15:37","host":"us-030*","referer":"https://segmentfault.com/a/1190000040689400","linkMd5ListStr":"37a85d0700f234d7451d86edfdb73ecc","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"19.2 KB","destSize":"19.2 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000040689404","sourceStatusCode":200,"destWidth":732,"destHeight":389,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn4@2020_4/2021/09/28/12-15-40-672_063d203952a1046a.webp","sourceBytes":15086,"destBytes":15086,"feedId":6615,"totalSpendMs":2954,"convertSpendMs":0,"createdTime":"2021-09-28 20:15:37","host":"us-006*","referer":"https://segmentfault.com/a/1190000040689400","linkMd5ListStr":"37a85d0700f234d7451d86edfdb73ecc","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"14.7 KB","destSize":"14.7 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000040689406","sourceStatusCode":200,"destWidth":732,"destHeight":300,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn93@2020_6/2021/09/28/12-15-40-766_b66dd156b0a31366.webp","sourceBytes":15856,"destBytes":15856,"feedId":6615,"totalSpendMs":3038,"convertSpendMs":0,"createdTime":"2021-09-28 20:15:37","host":"us-031*","referer":"https://segmentfault.com/a/1190000040689400","linkMd5ListStr":"37a85d0700f234d7451d86edfdb73ecc","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"15.5 KB","destSize":"15.5 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000040689407","sourceStatusCode":200,"destWidth":732,"destHeight":276,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn8@2020_4/2021/09/28/12-15-40-900_55369820d55e2ddf.webp","sourceBytes":9956,"destBytes":9956,"feedId":6615,"totalSpendMs":3199,"convertSpendMs":0,"createdTime":"2021-09-28 20:15:38","host":"europe-56*","referer":"https://segmentfault.com/a/1190000040689400","linkMd5ListStr":"37a85d0700f234d7451d86edfdb73ecc","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"9.7 KB","destSize":"9.7 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000040689408","sourceStatusCode":200,"destWidth":732,"destHeight":336,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn10@2020_5/2021/09/28/12-15-40-894_b1865fb2905bfdaa.webp","sourceBytes":18506,"destBytes":18506,"feedId":6615,"totalSpendMs":3247,"convertSpendMs":0,"createdTime":"2021-09-28 20:15:38","host":"europe-57*","referer":"https://segmentfault.com/a/1190000040689400","linkMd5ListStr":"37a85d0700f234d7451d86edfdb73ecc","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.1 KB","destSize":"18.1 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000040689402","sourceStatusCode":200,"destWidth":732,"destHeight":245,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn88@2020_2/2021/09/28/12-15-40-896_9c7116c11f37cb05.webp","sourceBytes":7696,"destBytes":7696,"feedId":6615,"totalSpendMs":3340,"convertSpendMs":0,"createdTime":"2021-09-28 20:15:38","host":"europe65*","referer":"https://segmentfault.com/a/1190000040689400","linkMd5ListStr":"37a85d0700f234d7451d86edfdb73ecc","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"7.5 KB","destSize":"7.5 KB","compressRate":"100%"}],"successGithubMap":{"myreaderx8":1,"myreaderx27":1,"myreaderx21":1,"myreaderx32":1,"myreaderx22":1,"myreaderx12":1,"myreaderx2":1,"myreaderx29":1},"failGithubMap":{}}