{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2021-10-01 10:20:33","updatedTime":"2021-10-01 10:20:33","title":"用Java轻松完成一个分布式事务TCC，保姆级教程","link":"https://segmentfault.com/a/1190000040735898","description":"<p>什么是TCC，TCC是Try、Confirm、Cancel三个词语的缩写，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。</p>\n<h2>TCC组成</h2>\n<p>TCC分为3个阶段</p>\n<ul>\n <li>Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）</li>\n <li>Confirm 阶段：如果所有分支的Try都成功了，则走到Confirm阶段。Confirm真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源</li>\n <li>Cancel 阶段：如果所有分支的Try有一个失败了，则走到Cancel阶段。Cancel释放 Try 阶段预留的业务资源。</li>\n</ul>\n<p>TCC分布式事务里，有3个角色，与经典的XA分布式事务一样：</p>\n<ul>\n <li>AP/应用程序，发起全局事务，定义全局事务包含哪些事务分支</li>\n <li>RM/资源管理器，负责分支事务各项资源的管理</li>\n <li>TM/事务管理器，负责协调全局事务的正确执行，包括Confirm，Cancel的执行，并处理网络异常</li>\n</ul>\n<p>如果我们要进行一个类似于银行跨行转账的业务，转出（TransOut）和转入（TransIn）分别在不同的微服务里，一个成功完成的TCC事务典型的时序图如下：</p>\n<p><img src=\"https://segmentfault.com/img/bVcUubG\" alt=\"image.png\" title=\"image.png\" /></p>\n<h2>TCC实践</h2>\n<p>下面我们进行一个TCC事务的具体开发</p>\n<p>我们的例子使用的分布式事务框架为dtm，它对分布式事务的支持非常优雅。下面来详细讲解TCC的组成</p>\n<p>下面我们来编写具体的Try/Confirm/Cancel的处理函数</p>\n<pre><code class=\"java\">@RequestMapping(\"TransOutTry\")\n    public Map&lt;String, String&gt; TransOutTry() {\n        logger.info(\"TransOutTry\");\n        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();\n        result.put(\"dtm_result\", \"SUCCESS\");\n        return result;\n    }\n\n    @RequestMapping(\"TransOutConfirm\")\n    public Map&lt;String, String&gt; TransOutConfirm(HttpServerResponse response) {\n        logger.info(\"TransOutConfirm\");\n        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();\n        result.put(\"dtm_result\", \"SUCCESS\");\n        return result;\n    }\n\n    @RequestMapping(\"TransOutCancel\")\n    public Map&lt;String, String&gt; TransOutCancel() {\n        logger.info(\"TransOutCancel\");\n        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();\n        result.put(\"dtm_result\", \"SUCCESS\");\n        return result;\n    }\n\n    @RequestMapping(\"TransInTry\")\n    public Map&lt;String, String&gt; TransInTry() {\n        logger.info(\"TransInTry\");\n        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();\n        result.put(\"dtm_result\", \"SUCCESS\");\n        return result;\n    }\n\n    @RequestMapping(\"TransInConfirm\")\n    public Map&lt;String, String&gt; TransInConfirm() {\n        logger.info(\"TransInConfirm\");\n        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();\n        result.put(\"dtm_result\", \"SUCCESS\");\n        return result;\n    }\n\n    @RequestMapping(\"TransInCancel\")\n    public Map&lt;String, String&gt; TransInCancel() {\n        logger.info(\"TransInCancel\");\n        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();\n        result.put(\"dtm_result\", \"SUCCESS\");\n        return result;\n    }</code></pre>\n<p>到此各个子事务的处理函数已经OK了，然后是开启TCC事务，进行分支调用</p>\n<pre><code class=\"java\">       @RequestMapping(\"fireTcc\")\n    public String fireTcc() {\n        Function&lt;Tcc, Boolean&gt; function = TccController::tccTrans;\n        return tcc.tccGlobalTransaction(function);\n    }\n\n    public static Boolean tccTrans(Tcc tcc) {\n        try {\n            boolean a = tcc.callBranch(\"\", svc + \"/TransOutTry\", svc + \"/TransOutConfirm\", svc + \"/TransOutCancel\");\n            boolean b = tcc.callBranch(\"\", svc + \"/TransInTry\", svc + \"/TransInConfirm\", svc + \"/TransInCancel\");\n            return a &amp;&amp; b;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return false;\n    }</code></pre>\n<p>至此，一个完整的TCC分布式事务编写完成。</p>\n<p>如果您想要完整运行一个成功的示例，那么参考这个例子yedf/dtmcli-java-sample，将它运行起来非常简单</p>\n<pre><code class=\"bash\"># 部署启动dtm\n# 需要docker版本18以上\ngit clone https://github.com/yedf/dtm\ncd dtm\ndocker-compose up\n\n# 另起一个命令行\ngit clone https://github.com/yedf/dtmcli-java-sample.git\ncd dtmcli-java-sample\n# 编译运行例子 main/src/main/java/com/github/viticis/dtmclijavaexamples/DtmcliJavaSampleApplication</code></pre>\n<h2>TCC的回滚</h2>\n<p>假如银行将金额准备转入用户2时，发现用户2的账户异常，返回失败，会怎么样？我们可以让TransIn返回失败来模拟这种情况</p>\n<pre><code class=\"java\">    @RequestMapping(\"TransInTry\")\n    public Map&lt;String, String&gt; TransInTry() {\n        logger.info(\"TransInTry\");\n        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();\n        result.put(\"dtm_result\", \"FAILURE\");\n        return result;\n    }</code></pre>\n<p>我们给出事务失败交互的时序图</p>\n<p><img src=\"https://segmentfault.com/img/bVcUubP\" alt=\"image.png\" title=\"image.png\" /></p>\n<p>这个跟成功的TCC差别就在于，当某个子事务返回失败后，后续就回滚全局事务，调用各个子事务的Cancel操作，保证全局事务全部回滚。</p>\n<p>在TCC事务模式上，有不少的读者会问，如果Confirm/Cancel失败会怎么样？这是一个好问题，代表您正在深入思考TCC事务模式。第一种情况是临时失败，例如网络故障、应用或数据库宕机，这类错误进行重试，最后会返回成功；另一种情况为业务失败，按照TCC的协议，第一阶段锁定资源，保证足够的资源能够让Confirm/Cancel执行，也就是说，程序逻辑上，Confirm/Cancel是不允许返回业务失败的，如果出现业务失败，那么是bug，需要开发人员手动修复bug。</p>\n<h2>小结</h2>\n<p>在这篇文章里，我们介绍了TCC的理论知识，也通过一个例子，完整给出了编写一个TCC事务的过程，涵盖了正常成功完成，以及成功回滚的情况。相信读者通过这边文章，对TCC已经有了深入的理解。</p>\n<p>关于分布式事务更多更全面的知识，请参考<a href=\"https://segmentfault.com/a/1190000040321750\">《分布式事务最经典的七种解决方案》</a></p>\n<p>文中使用的例子节选自<a href=\"https://github.com/yedf/dtm\" rel=\"nofollow noreferrer\">yedf/dtm</a>，它支持多种事务模式：TCC、SAGA、XA、事务消息 跨语言支持，已支持 golang、python、Java、PHP、nodejs等语言的客户端，参考<a href=\"https://dtm.pub/summary/code.html#go\" rel=\"nofollow noreferrer\">各语言SDK</a>。提供子事务屏障功能，优雅解决幂等、悬挂、空补偿等问题。</p>\n<p>阅读完此篇干货，欢迎大家访问<a href=\"https://github.com/yedf/dtm\" rel=\"nofollow noreferrer\">https://github.com/yedf/dtm</a>项目，给颗星星支持！</p>","descriptionType":"html","publishedDate":"Sun, 26 Sep 2021 01:47:58 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVcUubG","linkMd5":"cdd3b6dd2553e6fcb2581627b0e1ac41","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn88@2020_4/2021/10/01/02-20-39-305_6126a8f68daed454.webp","destWidth":626,"destHeight":732,"sourceBytes":25650,"destBytes":25650,"author":"叶东富","articleImgCdnMap":{"https://segmentfault.com/img/bVcUubG":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn88@2020_4/2021/10/01/02-20-39-305_6126a8f68daed454.webp","https://segmentfault.com/img/bVcUubP":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn96@2020_5/2021/10/01/02-20-42-648_bd0d79e4ec77cc8c.webp"},"publishedOrCreatedDate":1633054833398}],"record":{"createdTime":"2021-10-01 10:20:33","updatedTime":"2021-10-01 10:20:33","feedId":6615,"fetchDate":"Fri, 01 Oct 2021 02:20:33 +0000","fetchMs":4084,"handleMs":78,"totalMs":30814,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"af6ca12eefe249e94a3f077d15d7c168","hostName":"europe-25*","requestId":"fd8974dfca7048888e5d34161c01249b_6615","contentType":"application/atom+xml; charset=UTF-8","totalBytes":51750,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":2,"articlesImgsGithubTotal":2,"successGithubMap":{"myreaderx8":1,"myreaderx32":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:33:08","updatedTime":"2021-04-03 14:32:14","id":6615,"name":"SegmentFault 最新的文章","url":"http://segmentfault.com/feeds/blogs","subscriber":null,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx63/cdn75@2020_2/2021/04/03/06-32-08-760_eb238dca7c8e9f0e.jpg","description":"","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":25650,"tmpBodyImgCdnBytes":26100,"tmpBgImgCdnBytes":0,"extra4":{"start":1633054812294,"total":0,"statList":[{"spend":21037,"msg":"获取xml内容"},{"spend":78,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":3361,"msg":"正文链接上传到cdn"}]},"extra5":2,"extra6":2,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://europe21.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcUubG","sourceStatusCode":200,"destWidth":626,"destHeight":732,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn88@2020_4/2021/10/01/02-20-39-305_6126a8f68daed454.webp","sourceBytes":25650,"destBytes":25650,"feedId":6615,"totalSpendMs":3468,"convertSpendMs":0,"createdTime":"2021-10-01 10:20:36","host":"us-021*","referer":"https://segmentfault.com/a/1190000040735898","linkMd5ListStr":"cdd3b6dd2553e6fcb2581627b0e1ac41,cdd3b6dd2553e6fcb2581627b0e1ac41","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25 KB","destSize":"25 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcUubP","sourceStatusCode":200,"destWidth":600,"destHeight":732,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn96@2020_5/2021/10/01/02-20-42-648_bd0d79e4ec77cc8c.webp","sourceBytes":26100,"destBytes":26100,"feedId":6615,"totalSpendMs":3338,"convertSpendMs":0,"createdTime":"2021-10-01 10:20:39","host":"europe21*","referer":"https://segmentfault.com/a/1190000040735898","linkMd5ListStr":"cdd3b6dd2553e6fcb2581627b0e1ac41","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.5 KB","destSize":"25.5 KB","compressRate":"100%"}],"successGithubMap":{"myreaderx8":1,"myreaderx32":1},"failGithubMap":{}}