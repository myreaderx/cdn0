{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2021-09-28 19:53:33","updatedTime":"2021-09-28 19:53:33","title":"Designing C++ functions to write/save to any storage mechanism","link":"https://insanecoding.blogspot.com/2013/04/designing-c-functions-to-writesave-to.html","description":"<h3 style=\"text-align: center;\">Problem</h3>A common issue when dealing with a custom object or any kind of data is to create some sort of save functionality with it, perhaps writing some text or binary to a file. So what is the correct C++ method to allow an object to save its data <u>anywhere</u>?<br /><br />An initial approach to allow some custom object to be able to save its data to a file is to create a member function like so: <br /><blockquote><pre>void save(const char *filename);</pre></blockquote>While this is perfectly reasonable, what if I want something more advanced than that? Say I don't want the data to be saved as its own separate file, but would rather the data be written to some file that is already open, to a particular location within it? What if I'd rather save the data to a database? How about send the data over the network?<br /><br /><h3 style=\"text-align: center;\">Naive Approach</h3><br />When C++ programmers hear the initial set of requirements, they generally look to one of two solutions:<br /><br />The first is to allow for a save function which can take an <i>std::ostream</i>, like so: <br /><blockquote><pre>void save(std::ostream &amp;stream);</pre></blockquote>C++ out of the box offers <i>std::cout</i> as an instance of an <i>std::ostream</i> which writes to the screen. C++ offers a derived class <i>std::ofstream</i> (<i>std::fstream</i>) which can save to files on disk. C++ also offers a derived class <a href=\"http://en.cppreference.com/w/cpp/io/basic_ostringstream\" target=\"_blank\">std::ostringstream</a> which saves file to a C++ string.<br /><br />With these options, you can display the data on the screen, save it to an actual file, or save it to a string, which you can then in turn save it wherever you want.<br /><br />The next option programmers look to is to overload&nbsp; <a href=\"http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt\" target=\"_blank\"><i>std::basic_ostream::operator&lt;&lt;</i></a> for the custom object. This way one can simply write:<br /><blockquote><pre>mystream &lt;&lt; myobject;</pre></blockquote>And then the object can be written to any C++ stream.<br /><br />Either of these techniques pretty much work, but can be a bit annoying when you want a lot of flexibility <b>and</b> performance.<br /><br />Say I wanted to save my object over the network, what do I do? I could save it to a string stream, grab the string, and then send that over the network, even though that seems a bit wasteful.<br /><br />And for a similar case, say I have an already open <a href=\"http://en.wikipedia.org/wiki/File_descriptor\" target=\"_blank\">file descriptor</a>, and wish to save my object to it, do I also use a string stream as an intermediary?<br /><br />Since C++ is extensible, one could actually create their own <a href=\"http://en.cppreference.com/w/cpp/io/basic_streambuf\" target=\"_blank\">std::basic_streambuf</a> derived class which works with file descriptors, and attach it to an std::ostream, which can then be used with anything that works with a stream for output. I'm not going to go into the details how to do that here, but <a href=\"http://www.amazon.com/gp/product/0321623215/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321623215&amp;linkCode=as2&amp;tag=insacodi-20\">The C++ Standard Library</a><img alt=\"\" border=\"0\" class=\"hioyqmdriwomkxxppfkw\" height=\"1\" src=\"http://www.assoc-amazon.com/e/ir?t=insacodi-20&amp;l=as2&amp;o=1&amp;a=0321623215\" style=\"border: none !important; margin: 0px !important;\" width=\"1\" /> explains the general idea, and provides a working <i>file descriptor streambuf</i> example and shows how to use it with stream functions. You can also find some ready made implementations online with a bit of searching, and some compilers may even include a solution out of the box in their C++ extensions.<br /><br />On UNIX systems, once you have a stream which works with file descriptors, you can now send data over the network, as sockets themselves are file descriptors. On Windows, you'll need a separate class which works with <i>SOCKET</i>s. Of course to turn a <i>file descriptor streambuf</i> into a <i>SOCKET</i> <i>streambuf</i> is trivial, and can probably be done with a few well crafted search and replace commands.<br /><br />Now this may have solved the extra string overhead with file descriptors and networking, but what about if I want to save to a database? What about if I'm working with C's <i>FILE *</i>? Does one now have to implement a new wrapper for each of these (or pray the compiler offers an extension, or one can be found online)? The C++ stream library is actually a bit bloaty, and creating your own streambufs is somewhat annoying, especially if you want to do it right and allow for buffering. Many stream related library code you find online are also of poor quality. Surely there must be a better option, right?<br /><br /><h3 style=\"text-align: center;\">Solution</h3><br />If we look back at how C handles this problem, it uses <a href=\"http://insanecoding.blogspot.com/2007/05/secrets-to-optimization-function.html\" target=\"_blank\">function pointers</a>, where the function doing the writing receives a callback to use for the actual writing, and the programmer using it can make the writing go anywhere. C++ of course includes this ability, and even takes it much further, in the form of <a href=\"http://en.wikipedia.org/wiki/Function_object\" target=\"_blank\">function objects</a>, and even further in C++ 2011.<br /><br />Let's start with an example.<br /><blockquote><pre>template&lt;typename WriteFunction&gt;<br />void world(WriteFunction func)<br />{<br />  //Do some stuff...<br />  //Do some more stuff...<br />  func(\"World\", 5); //Write 5 characters via callback<br />  //Do some more stuff...<br />  unsigned char *data = ...;<br />  func(data, data_size); //Write some bytes<br />}<br /></pre></blockquote>The template function above is expecting any function pointer which can be used to write data by passing it a pointer and a length. A proper signature would be something like the following: <br /><blockquote><pre>void func(const void *data, size_t length);</pre></blockquote>Creating such a function is trivial. However, to be useful, writing needs to also include a destination of some sort, a device, a file, a database row, and so on, which makes function objects more powerful.<br /><blockquote><pre>#include &lt;cstdio&gt;<br /><br />class writer_file<br />{<br />  std::FILE *handle;<br />  public:<br />  writer_file(std::FILE *handle) : handle(handle) {}<br />  inline void operator()(const void *data, size_t length)<br />  {<br />    std::fwrite(data, 1, length, handle);<br />  }<br />};<br /></pre></blockquote>Which can be used as follows: <br /><blockquote><pre>world(writer_file(stdout));<br /></pre></blockquote>Or perhaps: <br /><blockquote><pre>std::FILE *fp = fopen(\"somefile.bin\", \"wb\");<br />world(writer_file(fp));<br />std::close(fp);<br /></pre></blockquote>As can be seen, our World function can write to any <i>FILE *</i>.<br /><br />To allow any <i>char-based</i> stream to be written, the following function object will do the trick:<br /><blockquote><pre>#include &lt;ostream&gt;<br /><br />class writer_stream<br />{<br />  std::ostream *handle;<br />  public:<br />  writer_stream(std::ostream &amp;handle) : handle(&amp;handle) {}<br />  inline void operator()(const void *data, size_t length)<br />  {<br />    handle-&gt;write(reinterpret_cast&lt;const char *&gt;(data), length);<br />  }<br />};<br /></pre></blockquote>You can call this with: <br /><blockquote><pre>world(writer_stream(std::cout));</pre></blockquote>Or anything in the <a href=\"http://www.cplusplus.com/reference/ostream/ostream/\" target=\"_blank\">ostream family</a>.<br /><br />If for some reason we wanted to write to strings, it's easy to create a function object for them too, and we can use the string directly without involving a string stream.<br /><blockquote><pre>#include &lt;string&gt;<br /><br />class writer_string<br />{<br />  std::string *handle;<br />  public:<br />  writer_string(std::string &amp;handle) : handle(&amp;handle) {}<br />  inline void operator()(const void *data, size_t length)<br />  {<br />    handle-&gt;append(reinterpret_cast&lt;const char *&gt;(data), length);<br />  }<br />};<br /></pre></blockquote>If you're worried about function objects being slow, then don't. Passing a function object like this to a template function has no overhead. The compiler is able to see a series of direct calls, and throws all the extraneous details away. It is as if the body of World is calling the write function to the handle passed to it directly. For more information, see <a href=\"http://www.amazon.com/gp/product/0201749629/ref=as_li_tf_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201749629&amp;linkCode=as2&amp;tag=insacodi-20\">Effective STL</a><img alt=\"\" border=\"0\" class=\"hioyqmdriwomkxxppfkw\" height=\"1\" src=\"http://www.assoc-amazon.com/e/ir?t=insacodi-20&amp;l=as2&amp;o=1&amp;a=0201749629\" style=\"border: none !important; margin: 0px !important;\" width=\"1\" /> Item 46.<br /><br />If you're wondering why developers forgo function pointers and function objects for situations like this, it is because  C++ offers so much with its stream classes, which are also very  extensible (and are often extended), they completely forget there are  other options. The stream classes are also designed for formatting output, and working with all kinds of special objects. But if you just need raw writing or saving of data, the stream classes are overkill.<br /><br /><h3 style=\"text-align: center;\">C++ 2011</h3><br />Now C++ 2011 extends all this further in a multiple of ways.<br /><br /><h4 style=\"text-align: center;\">std::bind()</h4><br />First of all, C++ 2011 offers <a href=\"http://en.cppreference.com/w/cpp/utility/functional/bind\" target=\"_blank\">std::bind()</a> which allows for creating function object adapters on the fly. std::bind() can take an unlimited amount of parameters. The first must be a function pointer of some sort, the next is optionally an object to work on in the case of a <a href=\"http://www.parashift.com/c++-faq/pointers-to-members.html\" target=\"_blank\">member function pointer</a>, followed by the parameters to the function. These parameters can be hard coded by the caller, or bound via placeholders by the callee.<br /><br />Here's how you would use std::bind() for using fwrite():<br /><blockquote><pre>#include &lt;functional&gt;<br />world(std::bind(std::fwrite, std::placeholders::_1, 1, std::placeholders::_2, stdout));<br /></pre></blockquote>Let us understand what is happening here. The function being called is std::fwrite(). It has 4 parameters. It's first parameter is the first parameter by the callee, denoted by <i>std::placeholders::_1</i>. The second parameter is being hard coded to 1 by the caller. The third parameter is the second parameter from the callee denoted by <i>std::placeholders::_2</i>. The fourth parameter is being hardcoded by the caller to stdout. It could be set to any <i>FILE *</i> as needed by the caller.<br /><br />Now we'll see how this works with objects. To use with a stream, the basic approach is as follows:<br /><blockquote><pre>world(std::bind(&amp;std::ostream::write, &amp;std::cout, std::placeholders::_1, std::placeholders::_2));<br /></pre></blockquote>Note how we're turning a member function into a pointer, and we're also turning <i>cout</i> into a pointer so it can be passed as <i>std::ostream::write</i>'s <i>this</i> pointer. The callee will pass its first and second parameters as the parameters to the stream write function.  However, the above has a slight flaw, it will only work if writing is done with <i>char *</i> data. We can solve that with casting. <br /><blockquote><pre>world(std::bind(reinterpret_cast&lt;void (std::ostream::*)(const void *, size_t)&gt;(&amp;std::ostream::write), &amp;std::cout, std::placeholders::_1, std::placeholders::_2));<br /></pre></blockquote>Take a moment to notice that we're not just casting it to the needed function pointer, but as a member function pointer of <i>std::ostream</i>.<br /><br />You might find doing this a bit more comfortable than using classical function objects. However, function objects still have their place, wherever functions do. Remember, functions are about re-usability, and some scenarios are complicated enough that you want to pull out a full blown function object.<br /><br />For working with file descriptors, you might be tempted to do the following:<br /><blockquote><pre>world(std::bind(::write, 1, std::placeholders::_1, std::placeholders::_2));</pre></blockquote>This here will have World write to file descriptor 1 - generally standard output. However this simple design is a mistake. <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html\">Write</a> can be interrupted by signals and needs to be resumed manually (by default, except on Solaris), among other issues, especially if the file descriptor is some kind of pipe or a socket. A proper write would be along the following lines: <br /><blockquote><pre>#include &lt;system_error&gt;<br />#include &lt;unistd.h&gt;<br /><br />class writer_fd<br />{<br />  int handle;<br />  public:<br />  writer_fd(int handle) : handle(handle) {}<br />  inline void operator()(const void *data, size_t length)<br />  {<br />    while (length)<br />    {<br />      ssize_t r = ::write(handle, data, length);<br />      if (r &gt; 0) { data = static_cast&lt;const char *&gt;(data)+r; length -= r; }<br />      else if (!r) { break; }<br />      else if (errno != EINTR) { throw std::system_error(errno, std::system_category()); }<br />    }<br />  }<br />};</pre></blockquote><h4 style=\"text-align: center;\">Lambda Functions </h4>Now you might be wondering, why C++ 2011 stopped with std::bind(), what if the function body needs more than just a single function call that can be wrapped up in an adapter? That's where lambda functions come in. <br /><blockquote><pre>world([&amp;](const void *data, size_t length){ std::fwrite(data, 1, length, stdout); });<br />world([&amp;](const void *data, size_t length){ std::cout.write(static_cast&lt;const char *&gt;(data), length); });<br /></pre></blockquote>Note the ridiculous syntax. The <i>[](){}</i> combination signifies we are working with a lambda function. The <i>[]</i> receives a function scope, in this case <i>&amp;</i>, which means that the function operates fully within its parent-scope, and has direct access to all its data. The rest you should already be well familiar with. You can change the <i>stdout</i> or the <i>cout</i> in the body of the lambda function to use your <i>FILE *</i> or <i>ostream</i> as necessary.<br /><br />Let us look at an example of having our World function write directly to a buffer. <br /><blockquote><pre>#include &lt;cstring&gt;<br /><br />void *p = ...; //Point p at some buffer which has enough room to hold the contents needed to be written to it.<br />world([&amp;](const void *data, size_t length){ std::memcpy(p, data, length); p = static_cast&lt;char *&gt;(p) + length; });</pre></blockquote>There's a very important point in this example. There is a pointer which is initialized to where writing should begin. Every time data is written, the pointer is incremented. This ensures that if World calls the passed write function multiple times, it will continue to work correctly. This was not needed for files above, as their write pointer increments automatically, or with <i>std::string</i>, where <i>append</i> always writes to the end, wherever it now is.<br /><br />Be careful writing like this though, you must ensure in advance that your buffer is large enough, perhaps if your object has a way of reporting how much data the next call to its save or write function needs to generate. If it doesn't and you're winging it, something like the following is in order:<br /><blockquote><pre>#include &lt;stdexcept&gt;<br /><br />class writer_buffer<br />{<br />  void *handle, *limit;<br />  public:<br />  writer_buffer(void *handle, size_t limit) : handle(handle), limit(static_cast<char>(handle)+limit) {}<br />  inline void operator()(const void *data, size_t length)<br />  {<br />    if ((static_cast&lt;char *&gt;(handle) + length) &gt; limit) { throw std::out_of_range(\"writer_buffer\"); }<br />    std::memcpy(handle, data, length);<br />    handle = static_cast&lt;char *&gt;(handle) + length;<br />  }<br />};<br /></char></pre></blockquote>You can use it as follows: <br /><blockquote><pre>#include &lt;cstdlib&gt;<br /><br />size_t amount = 1024; //A nice number!<br />void *buffer = std::malloc(amount);<br />world(writer_buffer(buffer, amount));</pre></blockquote>Now an exception will be thrown if the callee tries to write more data than it should.<br /><br /><h4 style=\"text-align: center;\">std::function</h4>Lastly, C++ 2011 added the ability for more verbose type checking on function objects, and the ability to create the save/write function as a normal function as opposed to a template function. That ability is a general reusable function object facade, <a href=\"http://en.cppreference.com/w/cpp/utility/functional/function\" target=\"_blank\">std::function</a>.<br /><br />To rewrite World to use it, we'd do as follows:  <br /><blockquote><pre>void world(std::function&lt;void (const void *, size_t)&gt; func)<br />{<br />  //Do some stuff...<br />  //Do some more stuff...<br />  func(\"World\", 5); //Write 5 characters via callback<br />  //Do some more stuff...<br />  unsigned char *data = ...;<br />  func(data, data_size); //Write some bytes<br />}<br /></pre></blockquote>With <i>std::function</i>, the type is now made explicit instead of being a template. It is anything which receives any kind of buffer and its length, and returns nothing. This can ensure that callers will always use a compatible function as intended by the library designer. For example, in our case, the caller only needs to ensure that data can be passed via a <i>char *</i> and an <i>unsigned char *</i>, based on how World uses the callback function. If World was now modified to also output an <i>int *</i>, less capable callers would now break. std::function can ensure that things are designed properly up front. With <i>std::function</i>, you can now also restructure your code to place various components in different compilation units if you so desire, although perhaps at a performance penalty.<br /><br /><h3 style=\"text-align: center;\">Conclusion</h3>To wrap up, you should now understand some features of C++ that are not as commonly used, or some new features of C++ 2011 that you may not be familiar with. You should now also have some ideas about generic code which should help you improve code you write.<br /><br />Many examples above were given only with one methodology, although they can be implemented with some of the others. For practice, try doing this yourself. Also try applying these ideas to other kinds of storage mechanisms not covered here, doing so should now be rather trivial for you.<br /><br />Remember, while this was done with a few standard examples and for writing, it can be extended to all handles Win32 offers, or for reading, or for anything else.","descriptionType":"html","publishedDate":"Wed, 03 Apr 2013 01:09:00 +0000","feedId":45616,"bgimg":"","linkMd5":"d4d5b3cdfcfa4d33b9ab2970681a28ed","bgimgJsdelivr":"","metaImg":"","author":"insane coder","articleImgCdnMap":{"http://www.assoc-amazon.com/e/ir?t=insacodi-20&l=as2&o=1&a=0321623215":null,"http://www.assoc-amazon.com/e/ir?t=insacodi-20&l=as2&o=1&a=0201749629":null},"publishedOrCreatedDate":1632830013422}],"record":{"createdTime":"2021-09-28 19:53:33","updatedTime":"2021-09-28 19:53:33","feedId":45616,"fetchDate":"Tue, 28 Sep 2021 11:53:33 +0000","fetchMs":219,"handleMs":40,"totalMs":123998,"newArticles":0,"totalArticles":25,"status":1,"type":0,"ip":"245d88d7b2d8f26704713c23b090d029","hostName":"us-023*","requestId":"7d6c4bd75d74484897211441a4a71930_45616","contentType":"application/atom+xml; charset=UTF-8","totalBytes":0,"bgimgsTotal":0,"bgimgsGithubTotal":0,"articlesImgsTotal":2,"articlesImgsGithubTotal":0,"successGithubMap":{},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 03:38:52","updatedTime":"2020-09-07 05:56:59","id":45616,"name":"Insane Coding","url":"http://insanecoding.blogspot.com/feeds/posts/default","subscriber":70,"website":null,"icon":"http://insanecoding.blogspot.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn30@2020_2/2020/09/06/21-56-58-712_6f8a923bdac2ffc4.ico","description":"'coz good thinking requires going outside the box","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2021-09-28 19:55:37","updatedTime":"2021-09-28 19:55:37","id":null,"feedId":45616,"linkMd5":"d4d5b3cdfcfa4d33b9ab2970681a28ed"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1632830013154,"total":0,"statList":[{"spend":228,"msg":"获取xml内容"},{"spend":40,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":123729,"msg":"正文链接上传到cdn"}]},"extra5":2,"extra6":0,"extra7ImgCdnFailResultVector":[null,null,null,null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-006.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://europe-58.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://us-51.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://us-52.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]}},"extra12ImgCdnSuccessResultVector":[],"successGithubMap":{},"failGithubMap":{}}