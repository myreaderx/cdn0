{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2021-04-15 02:39:44","updatedTime":"2021-04-15 02:39:44","title":"Finding Gold in Big Data","link":"https://tech.finn.no/2015/04/27/finding-gold-in-big-data","description":"<p>In the <a href=\"https://tech.finn.no/2012/08/06/foraging-in-the-landscape-of-big-data/\">previous article</a> we introduced our own introduction into the world of Big Data, and explored what it meant for FINN. Here we’ll go into the technical depth about the implementation of our Big Data needs.</p> \n<h2 id=\"rehashing-the-previous-article\">rehashing the previous article</h2> \n<p>FINN is a busy site, the busiest in Norway, and we display over 80 million ad pages each day. Back when it was around 50 million views per day, the old system responsible for collecting statistics was performing up to a thousand database writes per second during peak traffic. Like a lot of web applications we had a modern scalable presentation and logic tier based upon ten tomcat servers but just one not-so-scalable monster database sitting in the data tier. The procedure responsible for writing to the statistics table in the relational database was our biggest thorn. It had indeed gotten so bad that: during peak traffic; operations had to at the first sign of trouble turn off this database procedure – that is when users were getting the most traffic to their ads we had to stop collecting their statistics.</p> \n<p>At this time we were also in the process of modularising the FINN web application. The time was right to turn our statistics system into something modern and modular. We wanted an asynchronous, fault-tolerance, linearly scaling, and durable solution.</p> \n<h2 id=\"the-design\">the design</h2> \n<p>The new design uses the Command Query Separation pattern by using two separate modules: one for the collecting of events and one for displaying statistics. The event collecting system achieves asynchronousity, scalability, and durability by using Scribe. The backend persistence and statistics module achieves all goals by using <a href=\"http://cassandra.apache.org\">Cassandra</a> and Thrift. As an extension of the <a href=\"http://highscalability.com/blog/2009/10/13/why-are-facebook-digg-and-twitter-so-hard-to-scale.html\">push-on-change</a> model: the event collection stores denormalised data and it is later aggregated and normalised to the views the statistics module requires; we use MapReduce jobs within a Hadoop cluster.</p> \n<p><img src=\"https://tech.finn.no/images/2015-04-27-finding-gold-in-big-data/event-collection-overview.png\" alt=\"Event Statistics Overview\" /></p> \n<h2 id=\"the-statistics-module\">the statistics module</h2> \n<p>At FINN all our modular architecture is built either upon REST or interfaces defined by Apache Thrift. We discourage direct database access from any front-end application. So our Statistics module simply exposes the aggregated read-optimised data out of cassandra, with a Thrift IDL like:</p> \n<figure class=\"highlight\"> \n <pre><code class=\"language-java\" data-lang=\"java\"><span class=\"n\">service</span> <span class=\"nc\">AdViewingsService</span> <span class=\"o\">{</span>\n    <span class=\"cm\">/** returns total viewings for a given adId */</span>\n    <span class=\"kt\">long</span> <span class=\"nf\">fetchTotal</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">i64</span> <span class=\"n\">adId</span><span class=\"o\">)</span>\n    <span class=\"cm\">/** returns a list of viewings for the intervals between startTimestamp and endTimestamp **/</span>\n    <span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"kt\">long</span><span class=\"o\">&gt;</span> <span class=\"nf\">fetchRolled</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">i64</span> <span class=\"n\">adId</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"nc\">Interval</span> <span class=\"n\">interval</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">:</span> <span class=\"n\">i64</span> <span class=\"n\">startTimestamp</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">:</span> <span class=\"n\">i64</span> <span class=\"n\">endTimestamp</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">enum</span> <span class=\"nc\">Interval</span> <span class=\"o\">{</span> <span class=\"no\">YEAR</span><span class=\"o\">,</span> <span class=\"no\">MONTH</span><span class=\"o\">,</span> <span class=\"no\">DAY</span><span class=\"o\">,</span> <span class=\"no\">HOUR</span><span class=\"o\">,</span> <span class=\"no\">QUARTER_HOUR</span> <span class=\"o\">}</span></code></pre> \n</figure> \n<h2 id=\"the-event-collection-module\">the event collection module</h2> \n<p>The collecting of events we wanted to happen asynchronously and in a fail-over safe manner so we chose a combination of thrift and <a href=\"https://github.com/facebook/scribe\">Scribe</a> from Facebook. Each event object, or bean, is a thrift defined object, and these are serialised using thrift into Base64 encoded strings and transported through the network via Scribe. The event collection module is nothing more than a Scribe sink and it dumps these Thrift event beans directly into Cassandra.</p> \n<p>Each event is schemaless in its <code>values</code> field, it’s up to the application to decide what data to record, and is defined by Thrift like:</p> \n<figure class=\"highlight\"> \n <pre><code class=\"language-java\" data-lang=\"java\"><span class=\"n\">struct</span> <span class=\"nc\">Event</span> <span class=\"o\">{</span>\n    <span class=\"cm\">/** different categories generally won't be mixed in the normalised views. */</span>\n    <span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">required</span> <span class=\"n\">string</span> <span class=\"n\">category</span><span class=\"o\">;</span>\n    <span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"n\">required</span> <span class=\"n\">string</span> <span class=\"n\">subcategory</span><span class=\"o\">;</span>\n    <span class=\"mi\">3</span><span class=\"o\">:</span> <span class=\"n\">required</span> <span class=\"n\">map</span><span class=\"o\">&lt;</span><span class=\"n\">string</span><span class=\"o\">,</span><span class=\"n\">string</span><span class=\"o\">&gt;</span> <span class=\"n\">values</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre> \n</figure> \n<p>For the persistence of events in Cassandra we store events in rows based on minute by minute buckets. The partition key goes a little further and looks like <code>&lt;minute-bucket&gt;_&lt;random-number&gt;</code>. The reason for the additional column random_number, named “partition” in the CQL (Cassandra Query Language) schema, is it ensures write and read load is distributed around the cluster at all times, rather than one node being a hotspot for any given minute. Then each event is stored within a clustering key “collected_timestamp”. The value columns are essentially the category, the subcategory, and the json map keys_and_values.</p> \n<figure class=\"highlight\"> \n <pre><code class=\"language-sql\" data-lang=\"sql\"><span class=\"k\">CREATE</span> <span class=\"k\">TABLE</span> <span class=\"n\">events</span> <span class=\"p\">(</span>\n  <span class=\"k\">minute</span> <span class=\"nb\">text</span><span class=\"p\">,</span>\n  <span class=\"n\">partition</span> <span class=\"nb\">int</span>\n  <span class=\"k\">type</span> <span class=\"nb\">text</span><span class=\"p\">,</span>\n  <span class=\"n\">collected_timestamp</span> <span class=\"n\">timeuuid</span><span class=\"p\">,</span>\n  <span class=\"n\">collected_minute</span> <span class=\"nb\">bigint</span><span class=\"p\">,</span>\n  <span class=\"n\">subcategory</span> <span class=\"nb\">text</span><span class=\"p\">,</span>\n  <span class=\"n\">keys_and_values</span> <span class=\"nb\">text</span><span class=\"p\">,</span>\n  <span class=\"k\">PRIMARY</span> <span class=\"k\">KEY</span> <span class=\"p\">((</span><span class=\"k\">minute</span><span class=\"p\">,</span> <span class=\"n\">partition</span><span class=\"p\">),</span> <span class=\"k\">type</span><span class=\"p\">,</span> <span class=\"n\">collected_timestamp</span><span class=\"p\">)</span>\n<span class=\"p\">);</span>\n<span class=\"k\">CREATE</span> <span class=\"k\">INDEX</span> <span class=\"n\">collected_minuteIndex</span> <span class=\"k\">ON</span> <span class=\"n\">events</span> <span class=\"p\">(</span><span class=\"n\">collected_minute</span><span class=\"p\">);</span></code></pre> \n</figure> \n<p>We have moved the category column in as the first clustering key since the aggregation jobs typically only scan one type of category at a time. In hindsight we might not have done this as it would be better to be able to use the DateTieredCompactionStrategy. Within this schema there are two timestamp that we have to work with, both the real_timestamp representing when the event happened and the collected_timestamp when the event got stored in Cassandra. Analytical jobs, like “how many bicycles were sold in Oslo on a specific day?”, are interested in the real_timestamp. While the incremental aggregation jobs are interested in aggregating just those events that have come into the system since the last incremental run.</p> \n<h2 id=\"the-technologies\">the technologies</h2> \n<p><span class=\"image-wrap\" style=\"float: left\"><img style=\"margin: 5px; border: 0px solid black\" src=\"http://avatar.identi.ca/8594-96-20100330175539.jpeg\" alt=\"Cassandra\" />&nbsp;</span> Cassandra is truly amazing and refreshingly modern database: linear scalability, decentralised, elastic, fault-tolerant, durable; with a rich datamodel that provides often <a href=\"http://maxgrinev.com/2010/07/12/do-you-really-need-sql-to-do-it-all-in-cassandra/\">superior</a> approaches to joins, grouping, and ordering than traditional sql. The Scribe sink simply stores the Thrift event objects directly into Cassandra. After that we use Apache <a href=\"http://hadoop.apache.org\">Hadoop</a> to then in the background aggregate this denormalised data. The storing of denormalised data in this manner extends the <a href=\"http://highscalability.com/blog/2009/10/13/why-are-facebook-digg-and-twitter-so-hard-to-scale.html\">push-on-change</a> model, an approach far more scalable “in comparison with pull-on-demand model where data is stored normalized and combined by queries on demand – the classical relational approach”<a href=\"http://maxgrinev.com/2010/07/12/do-you-really-need-sql-to-do-it-all-in-cassandra/\"><sup>1</sup></a>. In hadoop our aggregation jobs piece-wise over time scan over the denormalised data, normalising in this case by each ad’s unique identifier, this normalised summation for each ad is then added to a separate table in Cassandra which uses counter columns and is optimised for query performance.</p> \n<p>Many of these incremental aggregation jobs could have been tackled with Spark streaming or Storm today. But 4 years ago when we started this project none of these technologies would have been capable of keeping up with our demands.<span class=\"image-wrap\" style=\"float: right;\"><img style=\"margin: 5px; border: 0px solid black\" width=\"80\" src=\"https://tech.finn.no/images/2015-04-27-finding-gold-in-big-data/scribe.png\" alt=\"Apache Hadoop\" />&nbsp;</span> Even today we’re happy that we have this system as our underlying base design, since there’s always aggregation jobs that can’t be solved with, or better solved with, streaming solutions. Having the raw events stored provides us a greater flexibility and a parallel to partition-tolerance when streaming solutions fail.</p> \n<p>Painting a wonderful picture, hopefully you can see it puts us one foot into an entirely new world of opportunity, but it would be a lie not to say the journey here has also come with its fair share of pain and anguish. The four key technologies we adopted here: Cassandra, Hadoop, Scribe, and Thrift; involve changes in the way we code and design.</p> \n<p>Cassandra, being a <a href=\"http://www.slideshare.net/jericevans/cassandra-not-just-nosql-its-mosql\">noSQL</a> database, or “Not only SQL”, takes some investing in to understand how datamodels are designed to suit queries instead of writes. We also been bitten by an unfortunate bug or two along the way. The first was immediately after the 1.0 release when compression was introduced and before we had a CQL schema and were storing serialised thrift events spearately in individual rows. With the compression we jumped on it a little too quickly, also modifying its default settings for chunk_length_kb to suit out skinny rows for the denormalised data. This hit a <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-3427\">bug</a> leading to excessive memory usage bringing Cassandra nodes down. The Cassandra community was very quickly to the rescue and we were running again with hours. The second bug was again related to skinny rows. Each of our count objects were stored in individual rows resulting in a column family with billions of rows stored on each physical machine. This eventually <a href=\"http://thread.gmane.org/gmane.comp.db.cassandra.user/24052\">blew</a> up in our face and the <a href=\"http://thread.gmane.org/gmane.comp.db.cassandra.user/24052\">fix</a> was to disable bloom filters. It’s obvious to us now that skinny rows should be avoided, and you’ll see in the CQL schema presented above that it isn’t how we do it anymore.</p> \n<p>Hadoop is a beast of a monster, and despite bringing functional programming to a world of its own (don’t go thinking you are anything special because you’re tinkering around with Scala) in many ways much of the joy Cassandra gave us was undermined by having to understand what the heck was going on sometimes in Hadoop. <span class=\"image-wrap\" style=\"float: right;\"><img style=\"margin: 5px; border: 0px solid black\" width=\"80\" src=\"https://tech.finn.no/images/2015-04-27-finding-gold-in-big-data/hadoop-elephant.jpg\" alt=\"Apache Hadoop\" />&nbsp;</span> We were also using Hadoop in a slightly unusual way trying to run small incremental jobs on it with as high frequency as possible. In fact it could be that we have the fastest Hadoop cluster in the world with our set up of a purely volatile HDFS filesystem built solely with SSDs. We’ve also had plenty of headaches due to Hadoop’s centralised setup. Our Cassandra and Hadoop nodes co-existed on the same servers in the one cluster, providing data-locality – a key ingredient to good Hadoop performance. But these servers came with a faulty raid controller locking up the servers many times each day for over a year, it took HP over a year to “look” into the problem. For our Cassandra cluster it successfully proved how rock solid fault-tolerance it really has – just imagine the crisis to the company if your monster relational database was crashing from faulty hardware twice a day. But one of these faulty server was running the hadoop masters: namenode and jobtracker; so aggregation jobs were frequently crashing. Since then we’re moved these services to a small separate virtual server, together they use no more than 600mb memory.</p> \n<p>Using Thrift throughout our modular platform we’d already broken the camel’s back on it. But Scribe has given us plenty of problems. Like most code open sourced from Facebook it seems to be “code thrown over the wall”. It contains traces of private Facebook code, has very little logging+documentation+support, and has settings that rarely work without peculiar and exact combinations with other settings. We believed scribe to be fault tolerant when it simply wasn’t and we lost many eventsc when resending buffers after a downtime or pause period. We have since moved to Kafka, as our general messaging bus for all event driven design throughout our microservices platform.</p> \n<p>These problems have all since been addressed – they are but part of our story. Dealing with each new technology on its own was no big deal but a strong recommendation in hindsight is not to trial multiple new technologies in the one project. The reputation of that project could well fall to that of its weakest link.</p> \n<h2 id=\"a-bright-prosperous-future\">a bright prosperous future</h2> \n<p>Of all these technologies it is Cassandra that has proved the most successful, and today is the essential and fundamental technology to our “big data” capabiilities.</p> \n<p>On top of this platform we’ve come a long way. Today we use predeominantly Spark over Hadoop, with Spark jobs submitted to our YARN cluster. Although more and more use-cases are only requiring Cassandra. Some of these examples are messaging inboxes for each user, storing users search history, fraud detection, mapping probabilities of ipaddresses to geographical locations, and providing collaborative filtering using Spark’s ALS algorithm.</p>","descriptionType":"html","feedId":16243,"bgimg":"https://tech.finn.no2015/images/2015-04-27-finding-gold-in-big-data/event-collection-overview.png","linkMd5":"0f8cf6d6ed39684dd269b5366d5cb2ec","sourceBytes":0,"destBytes":0,"author":"mick","articleImgCdnMap":{"https://tech.finn.no/images/2015-04-27-finding-gold-in-big-data/event-collection-overview.png":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn68@2020_4/2021/04/14/18-39-44-935_509931380ae7659d.webp","http://avatar.identi.ca/8594-96-20100330175539.jpeg":null,"https://tech.finn.no/images/2015-04-27-finding-gold-in-big-data/scribe.png":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn80@2020_6/2021/04/14/18-39-45-135_3164bd7342f9afc1.webp","https://tech.finn.no/images/2015-04-27-finding-gold-in-big-data/hadoop-elephant.jpg":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn71@2020_6/2021/04/14/18-39-44-913_4b132a79f7911f34.webp"},"publishedOrCreatedDate":1618425584719}],"record":{"createdTime":"2021-04-15 02:39:44","updatedTime":"2021-04-15 02:39:44","feedId":16243,"fetchDate":"Wed, 14 Apr 2021 18:39:44 +0000","fetchMs":163,"handleMs":191,"totalMs":120645,"newArticles":0,"totalArticles":86,"status":1,"type":0,"ip":"245d88d7b2d8f26704713c23b090d029","hostName":"us-54*","requestId":"8fab80fdb1e24d30af7272a54f9ccec2_16243","contentType":"application/xml","totalBytes":55910,"bgimgsTotal":1,"bgimgsGithubTotal":0,"articlesImgsTotal":4,"articlesImgsGithubTotal":3,"successGithubMap":{"myreaderx10":1,"myreaderx3":1,"myreaderx13":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:12:24","updatedTime":"2020-09-07 02:12:24","id":16243,"name":"FINN Technology","url":"http://tech.finn.no/atom.xml","subscriber":206,"website":null,"icon":"https://tech.finn.no/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"https://tech.finn.no"},"noPictureArticleList":[{"createdTime":"2021-04-15 02:41:44","updatedTime":"2021-04-15 02:41:44","id":null,"feedId":16243,"linkMd5":"0f8cf6d6ed39684dd269b5366d5cb2ec"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":55910,"tmpBgImgCdnBytes":0,"extra4":{"start":1618425584354,"total":0,"statList":[{"spend":174,"msg":"获取xml内容"},{"spend":191,"msg":"解释文章"},{"spend":74,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":120197,"msg":"正文链接上传到cdn"}]},"extra5":4,"extra6":3,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://tech.finn.no2015/images/2015-04-27-finding-gold-in-big-data/event-collection-overview.png","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":16243,"totalSpendMs":35,"convertSpendMs":0,"createdTime":"2021-04-15 02:39:44","host":"us-55*","referer":"https://tech.finn.no/2015/04/27/finding-gold-in-big-data","linkMd5ListStr":"0f8cf6d6ed39684dd269b5366d5cb2ec","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://tech.finn.no2015/images/2015-04-27-finding-gold-in-big-data/event-collection-overview.png","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":16243,"totalSpendMs":17,"convertSpendMs":0,"createdTime":"2021-04-15 02:39:44","host":"us-030*","referer":"https://tech.finn.no/2015/04/27/finding-gold-in-big-data","linkMd5ListStr":"0f8cf6d6ed39684dd269b5366d5cb2ec","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"},null,null],"extra10_invalidATagHrefValue":{"https://tech.finn.no/2015/04/27/finding-gold-in-big-data_/2012/08/06/foraging-in-the-landscape-of-big-data/":"https://tech.finn.no/2012/08/06/foraging-in-the-landscape-of-big-data/"},"extra111_proxyServerAndStatMap":{"http://us-032.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,null]},"http://us-020.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe21.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-008.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://tech.finn.no/images/2015-04-27-finding-gold-in-big-data/event-collection-overview.png","sourceStatusCode":200,"destWidth":800,"destHeight":650,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn68@2020_4/2021/04/14/18-39-44-935_509931380ae7659d.webp","sourceBytes":94728,"destBytes":37026,"targetWebpQuality":75,"feedId":16243,"totalSpendMs":376,"convertSpendMs":20,"createdTime":"2021-04-15 02:39:44","host":"us-032*","referer":"https://tech.finn.no/2015/04/27/finding-gold-in-big-data","linkMd5ListStr":"0f8cf6d6ed39684dd269b5366d5cb2ec","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"92.5 KB","destSize":"36.2 KB","compressRate":"39.1%"},{"code":1,"isDone":false,"source":"https://tech.finn.no/images/2015-04-27-finding-gold-in-big-data/hadoop-elephant.jpg","sourceStatusCode":200,"destWidth":300,"destHeight":225,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn71@2020_6/2021/04/14/18-39-44-913_4b132a79f7911f34.webp","sourceBytes":16900,"destBytes":10826,"targetWebpQuality":75,"feedId":16243,"totalSpendMs":423,"convertSpendMs":4,"createdTime":"2021-04-15 02:39:44","host":"us-020*","referer":"https://tech.finn.no/2015/04/27/finding-gold-in-big-data","linkMd5ListStr":"0f8cf6d6ed39684dd269b5366d5cb2ec","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"16.5 KB","destSize":"10.6 KB","compressRate":"64.1%"},{"code":1,"isDone":false,"source":"https://tech.finn.no/images/2015-04-27-finding-gold-in-big-data/scribe.png","sourceStatusCode":200,"destWidth":306,"destHeight":304,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn80@2020_6/2021/04/14/18-39-45-135_3164bd7342f9afc1.webp","sourceBytes":38513,"destBytes":8058,"targetWebpQuality":75,"feedId":16243,"totalSpendMs":773,"convertSpendMs":7,"createdTime":"2021-04-15 02:39:44","host":"europe21*","referer":"https://tech.finn.no/2015/04/27/finding-gold-in-big-data","linkMd5ListStr":"0f8cf6d6ed39684dd269b5366d5cb2ec","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"37.6 KB","destSize":"7.9 KB","compressRate":"20.9%"}],"successGithubMap":{"myreaderx10":1,"myreaderx3":1,"myreaderx13":1},"failGithubMap":{}}