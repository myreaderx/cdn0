{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2021-04-03 13:58:56","updatedTime":"2021-04-03 13:58:56","title":"webpack核心模块tapable源码解析","link":"https://segmentfault.com/a/1190000039757900","description":"<p><a href=\"https://segmentfault.com/a/1190000039418800\">上一篇文章我写了<code>tapable</code>的基本用法</a>，我们知道他是一个增强版版的<code>发布订阅模式</code>，本文想来学习下他的源码。<code>tapable</code>的源码我读了一下，发现他的抽象程度比较高，直接扎进去反而会让人云里雾里的，所以本文会从最简单的<code>SyncHook</code>和<code>发布订阅模式</code>入手，再一步一步抽象，慢慢变成他源码的样子。</p>\n<p><strong>本文可运行示例代码已经上传GitHub，大家拿下来一边玩一边看文章效果更佳：<a href=\"https://github.com/dennis-jiang/Front-End-Knowledges/tree/master/Examples/Engineering/tapable-source-code\" rel=\"nofollow noreferrer\">https://github.com/dennis-jiang/Front-End-Knowledges/tree/master/Examples/Engineering/tapable-source-code</a></strong>。</p>\n<h2><code>SyncHook</code>的基本实现</h2>\n<p>上一篇文章已经讲过<code>SyncHook</code>的用法了，我这里就不再展开了，他使用的例子就是这样子：</p>\n<pre><code class=\"javascript\">const { SyncHook } = require(\"tapable\");\n\n// 实例化一个加速的hook\nconst accelerate = new SyncHook([\"newSpeed\"]);\n\n// 注册第一个回调，加速时记录下当前速度\naccelerate.tap(\"LoggerPlugin\", (newSpeed) =&gt;\n  console.log(\"LoggerPlugin\", `加速到${newSpeed}`)\n);\n\n// 再注册一个回调，用来检测是否超速\naccelerate.tap(\"OverspeedPlugin\", (newSpeed) =&gt; {\n  if (newSpeed &gt; 120) {\n    console.log(\"OverspeedPlugin\", \"您已超速！！\");\n  }\n});\n\n// 触发一下加速事件，看看效果吧\naccelerate.call(500);</code></pre>\n<p>其实这种用法就是一个最基本的<code>发布订阅模式</code>，我之前<a href=\"https://segmentfault.com/a/1190000023385521\">讲发布订阅模式的文章</a>讲过，我们可以仿照那个很快实现一个<code>SyncHook</code>：</p>\n<pre><code class=\"javascript\">class SyncHook {\n    constructor(args = []) {\n        this._args = args;       // 接收的参数存下来\n        this.taps = [];          // 一个存回调的数组\n    }\n\n    // tap实例方法用来注册回调\n    tap(name, fn) {\n        // 逻辑很简单，直接保存下传入的回调参数就行\n        this.taps.push(fn);\n    }\n\n    // call实例方法用来触发事件，执行所有回调\n    call(...args) {\n        // 逻辑也很简单，将注册的回调一个一个拿出来执行就行\n        const tapsLength = this.taps.length;\n        for(let i = 0; i &lt; tapsLength; i++) {\n            const fn = this.taps[i];\n            fn(...args);\n        }\n    }\n}</code></pre>\n<p>这段代码非常简单，是一个最基础的<code>发布订阅模式</code>，使用方法跟上面是一样的，将<code>SyncHook</code>从<code>tapable</code>导出改为使用我们自己的：</p>\n<pre><code class=\"javascript\">// const { SyncHook } = require(\"tapable\");\nconst { SyncHook } = require(\"./SyncHook\");</code></pre>\n<p>运行效果是一样的：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039757903\" alt=\"image-20210323153234354\" title=\"image-20210323153234354\" /></p>\n<p><strong>注意：</strong> 我们构造函数里面传入的<code>args</code>并没有用上，<code>tapable</code>主要是用它来动态生成<code>call</code>的函数体的，在后面讲代码工厂的时候会看到。</p>\n<h2><code>SyncBailHook</code>的基本实现</h2>\n<p>再来一个<code>SyncBailHook</code>的基本实现吧，<code>SyncBailHook</code>的作用是当前一个回调返回不为<code>undefined</code>的值的时候，阻止后面的回调执行。基本使用是这样的：</p>\n<pre><code class=\"javascript\">const { SyncBailHook } = require(\"tapable\");    // 使用的是SyncBailHook\n\nconst accelerate = new SyncBailHook([\"newSpeed\"]);\n\naccelerate.tap(\"LoggerPlugin\", (newSpeed) =&gt;\n  console.log(\"LoggerPlugin\", `加速到${newSpeed}`)\n);\n\n// 再注册一个回调，用来检测是否超速\n// 如果超速就返回一个错误\naccelerate.tap(\"OverspeedPlugin\", (newSpeed) =&gt; {\n  if (newSpeed &gt; 120) {\n    console.log(\"OverspeedPlugin\", \"您已超速！！\");\n\n    return new Error('您已超速！！');\n  }\n});\n\n// 由于上一个回调返回了一个不为undefined的值\n// 这个回调不会再运行了\naccelerate.tap(\"DamagePlugin\", (newSpeed) =&gt; {\n  if (newSpeed &gt; 300) {\n    console.log(\"DamagePlugin\", \"速度实在太快，车子快散架了。。。\");\n  }\n});\n\naccelerate.call(500);</code></pre>\n<p>他的实现跟上面的<code>SyncHook</code>也非常像，只是<code>call</code>在执行的时候不一样而已，<code>SyncBailHook</code>需要检测每个回调的返回值，如果不为<code>undefined</code>就终止执行后面的回调，所以代码实现如下：</p>\n<pre><code class=\"javascript\">class SyncBailHook {\n    constructor(args = []) {\n        this._args = args;       \n        this.taps = [];          \n    }\n\n    tap(name, fn) {\n        this.taps.push(fn);\n    }\n\n    // 其他代码跟SyncHook是一样的，就是call的实现不一样\n    // 需要检测每个返回值，如果不为undefined就终止执行\n    call(...args) {\n        const tapsLength = this.taps.length;\n        for(let i = 0; i &lt; tapsLength; i++) {\n            const fn = this.taps[i];\n            const res = fn(...args);\n\n            if( res !== undefined) return res;\n        }\n    }\n}</code></pre>\n<p>然后改下<code>SyncBailHook</code>从我们自己的引入就行：</p>\n<pre><code class=\"javascript\">// const { SyncBailHook } = require(\"tapable\"); \nconst { SyncBailHook } = require(\"./SyncBailHook\"); </code></pre>\n<p>运行效果是一样的：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039757902\" alt=\"image-20210323155857678\" title=\"image-20210323155857678\" /></p>\n<h2>抽象重复代码</h2>\n<p>现在我们只实现了<code>SyncHook</code>和<code>SyncBailHook</code>两个<code>Hook</code>而已，上一篇讲用法的文章里面总共有9个<code>Hook</code>，如果每个<code>Hook</code>都像前面这样实现也是可以的。但是我们再仔细看下<code>SyncHook</code>和<code>SyncBailHook</code>两个类的代码，发现他们除了<code>call</code>的实现不一样，其他代码一模一样，所以作为一个有追求的工程师，我们可以把这部分重复的代码提出来作为一个基类：<code>Hook</code>类。</p>\n<p><code>Hook</code>类需要包含一些公共的代码，<code>call</code>这种不一样的部分由各个子类自己实现。所以<code>Hook</code>类就长这样：</p>\n<pre><code class=\"javascript\">const CALL_DELEGATE = function(...args) {\n    this.call = this._createCall();\n    return this.call(...args);\n};\n\n// Hook是SyncHook和SyncBailHook的基类\n// 大体结构是一样的，不一样的地方是call\n// 不同子类的call是不一样的\n// tapable的Hook基类提供了一个抽象接口compile来动态生成call函数\nclass Hook {\n    constructor(args = []) {\n        this._args = args;       \n        this.taps = [];          \n\n        // 基类的call初始化为CALL_DELEGATE\n        // 为什么这里需要这样一个代理，而不是直接this.call = _createCall()\n        // 等我们后面子类实现了再一起讲\n        this.call = CALL_DELEGATE;\n    }\n\n    // 一个抽象接口compile\n    // 由子类实现，基类compile不能直接调用\n    compile(options) {\n      throw new Error(\"Abstract: should be overridden\");\n    }\n\n    tap(name, fn) {\n        this.taps.push(fn);\n    }\n\n    // _createCall调用子类实现的compile来生成call方法\n    _createCall() {\n      return this.compile({\n        taps: this.taps,\n        args: this._args,\n      });\n    }\n}</code></pre>\n<p>官方对应的源码看这里：<a href=\"https://github.com/webpack/tapable/blob/master/lib/Hook.js\" rel=\"nofollow noreferrer\">https://github.com/webpack/tapable/blob/master/lib/Hook.js</a></p>\n<h3>子类SyncHook实现</h3>\n<p>现在有了<code>Hook</code>基类，我们的<code>SyncHook</code>就需要继承这个基类重写，<code>tapable</code>在这里继承的时候并没有使用<code>class extends</code>，而是手动继承的：</p>\n<pre><code class=\"javascript\">const Hook = require('./Hook');\n\nfunction SyncHook(args = []) {\n    // 先手动继承Hook\n      const hook = new Hook(args);\n    hook.constructor = SyncHook;\n\n    // 然后实现自己的compile函数\n    // compile的作用应该是创建一个call函数并返回\n        hook.compile = function(options) {\n        // 这里call函数的实现跟前面实现是一样的\n        const { taps } = options;\n        const call = function(...args) {\n            const tapsLength = taps.length;\n            for(let i = 0; i &lt; tapsLength; i++) {\n                const fn = this.taps[i];\n                fn(...args);\n            }\n        }\n\n        return call;\n    };\n    \n    return hook;\n}\n\nSyncHook.prototype = null;</code></pre>\n<p><strong>注意</strong>：我们在基类<code>Hook</code>构造函数中初始化<code>this.call</code>为<code>CALL_DELEGATE</code>这个函数，这是有原因的，最主要的原因是<strong>确保<code>this</code>的正确指向</strong>。思考一下假如我们不用<code>CALL_DELEGATE</code>，而是直接<code>this.call = this._createCall()</code>会发生什么？我们来分析下这个执行流程：</p>\n<ol>\n <li>用户使用时，肯定是使用<code>new SyncHook()</code>，这时候会执行<code>const hook = new Hook(args);</code></li>\n <li><code>new Hook(args)</code>会去执行<code>Hook</code>的构造函数，也就是会运行<code>this.call = this._createCall()</code></li>\n <li>这时候的<code>this</code>指向的是基类<code>Hook</code>的实例，<code>this._createCall()</code>会调用基类的<code>this.compile()</code></li>\n <li>由于基类的<code>complie</code>函数是一个抽象接口，直接调用会报错<code>Abstract: should be overridden</code>。</li>\n</ol>\n<p><strong>那我们采用<code>this.call = CALL_DELEGATE</code>是怎么解决这个问题的呢</strong>？</p>\n<ol>\n <li>采用<code>this.call = CALL_DELEGATE</code>后，基类<code>Hook</code>上的<code>call</code>就只是被赋值为一个代理函数而已，这个函数不会立马调用。</li>\n <li>用户使用时，同样是<code>new SyncHook()</code>，里面会执行<code>Hook</code>的构造函数</li>\n <li><code>Hook</code>构造函数会给<code>this.call</code>赋值为<code>CALL_DELEGATE</code>，但是不会立即执行。</li>\n <li><code>new SyncHook()</code>继续执行，新建的实例上的方法<code>hook.complie</code>被覆写为正确方法。</li>\n <li>当用户调用<code>hook.call</code>的时候才会真正执行<code>this._createCall()</code>，这里面会去调用<code>this.complie()</code></li>\n <li>这时候调用的<code>complie</code>已经是被正确覆写过的了，所以得到正确的结果。</li>\n</ol>\n<h3>子类SyncBailHook的实现</h3>\n<p>子类<code>SyncBailHook</code>的实现跟上面<code>SyncHook</code>的也是非常像，只是<code>hook.compile</code>实现不一样而已：</p>\n<pre><code class=\"javascript\">const Hook = require('./Hook');\n\nfunction SyncBailHook(args = []) {\n    // 基本结构跟SyncHook都是一样的\n      const hook = new Hook(args);\n    hook.constructor = SyncBailHook;\n\n    \n    // 只是compile的实现是Bail版的\n        hook.compile = function(options) {\n        const { taps } = options;\n        const call = function(...args) {\n            const tapsLength = taps.length;\n            for(let i = 0; i &lt; tapsLength; i++) {\n                const fn = this.taps[i];\n                const res = fn(...args);\n\n                if( res !== undefined) break;\n            }\n        }\n\n        return call;\n    };\n    \n    return hook;\n}\n\nSyncBailHook.prototype = null;</code></pre>\n<h2>抽象代码工厂</h2>\n<p>上面我们通过对<code>SyncHook</code>和<code>SyncBailHook</code>的抽象提炼出了一个基类<code>Hook</code>，减少了重复代码。基于这种结构子类需要实现的就是<code>complie</code>方法，但是如果我们将<code>SyncHook</code>和<code>SyncBailHook</code>的<code>complie</code>方法拿出来对比下：</p>\n<p><strong>SyncHook</strong>:</p>\n<pre><code class=\"javascript\">hook.compile = function(options) {\n  const { taps } = options;\n  const call = function(...args) {\n    const tapsLength = taps.length;\n    for(let i = 0; i &lt; tapsLength; i++) {\n      const fn = this.taps[i];\n      fn(...args);\n    }\n  }\n\n  return call;\n};</code></pre>\n<p><strong>SyncBailHook</strong>：</p>\n<pre><code class=\"javascript\">hook.compile = function(options) {\n  const { taps } = options;\n  const call = function(...args) {\n    const tapsLength = taps.length;\n    for(let i = 0; i &lt; tapsLength; i++) {\n      const fn = this.taps[i];\n      const res = fn(...args);\n\n      if( res !== undefined) return res;\n    }\n  }\n\n  return call;\n};</code></pre>\n<p>我们发现这两个<code>complie</code>也非常像，有大量重复代码，所以<code>tapable</code>为了解决这些重复代码，又进行了一次抽象，也就是代码工厂<code>HookCodeFactory</code>。<code>HookCodeFactory</code>的作用就是用来生成<code>complie</code>返回的<code>call</code>函数体，而<code>HookCodeFactory</code>在实现时也采用了<code>Hook</code>类似的思路，也是先实现了一个基类<code>HookCodeFactory</code>，然后不同的<code>Hook</code>再继承这个类来实现自己的代码工厂，比如<code>SyncHookCodeFactory</code>。</p>\n<h3>创建函数的方法</h3>\n<p>在继续深入代码工厂前，我们先来回顾下JS里面创建函数的方法。一般我们会有这几种方法：</p>\n<ol>\n <li><p>函数申明</p><pre><code class=\"javascript\">function add(a, b) {\n  return a + b;\n}</code></pre></li>\n <li><p>函数表达式</p><pre><code class=\"javascript\">const add = function(a, b) {\n  return a + b;\n}</code></pre></li>\n</ol>\n<p>但是除了这两种方法外，还有种不常用的方法：<strong>使用Function构造函数</strong>。比如上面这个函数使用构造函数创建就是这样的：</p>\n<pre><code class=\"javascript\">const add = new Function('a', 'b', 'return a + b;');</code></pre>\n<p>上面的调用形式里，最后一个参数是函数的函数体，前面的参数都是函数的形参，最终生成的函数跟用函数表达式的效果是一样的，可以这样调用：</p>\n<pre><code class=\"javascript\">add(1, 2);    // 结果是3</code></pre>\n<p><strong>注意</strong>：上面的<code>a</code>和<code>b</code>形参放在一起用逗号隔开也是可以的：</p>\n<pre><code class=\"javascript\">const add = new Function('a, b', 'return a + b;');    // 这样跟上面的效果是一样的</code></pre>\n<p>当然函数并不是一定要有参数，没有参数的函数也可以这样创建：</p>\n<pre><code class=\"javascript\">const sayHi = new Function('alert(\"Hello\")');\n\nsayHi(); // Hello</code></pre>\n<p>这样创建函数和前面的函数申明和函数表达式有什么区别呢？<strong>使用Function构造函数来创建函数最大的一个特征就是，函数体是一个字符串，也就是说我们可以动态生成这个字符串，从而动态生成函数体</strong>。因为<code>SyncHook</code>和<code>SyncBailHook</code>的<code>call</code>函数很像，我们可以像拼一个字符串那样拼出他们的函数体，为了更简单的拼凑，<code>tapable</code>最终生成的<code>call</code>函数里面并没有循环，而是在拼函数体的时候就将循环展开了，比如<code>SyncHook</code>拼出来的<code>call</code>函数的函数体就是这样的：</p>\n<pre><code class=\"javascript\">\"use strict\";\nvar _x = this._x;\nvar _fn0 = _x[0];\n_fn0(newSpeed);\nvar _fn1 = _x[1];\n_fn1(newSpeed);</code></pre>\n<p>上面代码的<code>_x</code>其实就是保存回调的数组<code>taps</code>，这里重命名为<code>_x</code>，我想是为了节省代码大小吧。这段代码可以看到，<code>_x</code>，也就是<code>taps</code>里面的内容已经被展开了，是一个一个取出来执行的。</p>\n<p>而<code>SyncBailHook</code>最终生成的<code>call</code>函数体是这样的：</p>\n<pre><code class=\"javascript\">\"use strict\";\nvar _x = this._x;\nvar _fn0 = _x[0];\nvar _result0 = _fn0(newSpeed);\nif (_result0 !== undefined) {\n    return _result0;\n    ;\n} else {\n    var _fn1 = _x[1];\n    var _result1 = _fn1(newSpeed);\n    if (_result1 !== undefined) {\n        return _result1;\n        ;\n    } else {\n    }\n}</code></pre>\n<p>这段生成的代码主体逻辑其实跟<code>SyncHook</code>是一样的，都是将<code>_x</code>展开执行了，他们的区别是<code>SyncBailHook</code>会对每次执行的结果进行检测，如果结果不是<code>undefined</code>就直接<code>return</code>了，后面的回调函数就没有机会执行了。</p>\n<h3>创建代码工厂基类</h3>\n<p>基于这个目的，我们的代码工厂基类应该可以生成最基本的<code>call</code>函数体。我们来写个最基本的<code>HookCodeFactory</code>吧，目前他只能生成<code>SyncHook</code>的<code>call</code>函数体：</p>\n<pre><code class=\"javascript\">class HookCodeFactory {\n    constructor() {\n        // 构造函数定义两个变量\n        this.options = undefined;\n        this._args = undefined;\n    }\n\n    // init函数初始化变量\n    init(options) {\n        this.options = options;\n        this._args = options.args.slice();\n    }\n\n    // deinit重置变量\n    deinit() {\n        this.options = undefined;\n        this._args = undefined;\n    }\n\n    // args用来将传入的数组args转换为New Function接收的逗号分隔的形式\n    // ['arg1', 'args'] ---&gt;  'arg1, arg2'\n    args() {\n        return this._args.join(\", \");\n    }\n\n    // setup其实就是给生成代码的_x赋值\n    setup(instance, options) {\n        instance._x = options.taps.map(t =&gt; t);\n    }\n\n    // create创建最终的call函数\n    create(options) {\n        this.init(options);\n        let fn;\n\n        // 直接将taps展开为平铺的函数调用\n        const { taps } = options;\n        let code = '';\n        for (let i = 0; i &lt; taps.length; i++) {\n            code += `\n                var _fn${i} = _x[${i}];\n                _fn${i}(${this.args()});\n            `\n        }\n\n        // 将展开的循环和头部连接起来\n        const allCodes = `\n            \"use strict\";\n            var _x = this._x;\n        ` + code;\n\n        // 用传进来的参数和生成的函数体创建一个函数出来\n        fn = new Function(this.args(), allCodes);\n\n        this.deinit();  // 重置变量\n\n        return fn;    // 返回生成的函数\n    }\n}</code></pre>\n<p>上面代码最核心的其实就是<code>create</code>函数，这个函数会动态创建一个<code>call</code>函数并返回，所以<code>SyncHook</code>可以直接使用这个<code>factory</code>创建代码了：</p>\n<pre><code class=\"javascript\">// SyncHook.js\n\nconst Hook = require('./Hook');\nconst HookCodeFactory = require(\"./HookCodeFactory\");\n\nconst factory = new HookCodeFactory();\n\n// COMPILE函数会去调用factory来生成call函数\nconst COMPILE = function(options) {\n    factory.setup(this, options);\n    return factory.create(options);\n};\n\nfunction SyncHook(args = []) {\n        const hook = new Hook(args);\n    hook.constructor = SyncHook;\n\n    // 使用HookCodeFactory来创建最终的call函数\n    hook.compile = COMPILE;\n\n    return hook;\n}\n\nSyncHook.prototype = null;</code></pre>\n<h3>让代码工厂支持<code>SyncBailHook</code></h3>\n<p>现在我们的<code>HookCodeFactory</code>只能生成最简单的<code>SyncHook</code>代码，我们需要对他进行一些改进，让他能够也生成<code>SyncBailHook</code>的<code>call</code>函数体。你可以拉回前面再仔细观察下这两个最终生成代码的区别：</p>\n<ol>\n <li><code>SyncBailHook</code>需要对每次执行的<code>result</code>进行处理，如果不为<code>undefined</code>就返回</li>\n <li><code>SyncBailHook</code>生成的代码其实是<code>if...else</code>嵌套的，我们生成的时候可以考虑使用一个递归函数</li>\n</ol>\n<p>为了让<code>SyncHook</code>和<code>SyncBailHook</code>的子类代码工厂能够传入差异化的<code>result</code>处理，我们先将<code>HookCodeFactory</code>基类的<code>create</code>拆成两部分，将代码拼装的逻辑单独拆成一个函数：</p>\n<pre><code class=\"javascript\">class HookCodeFactory {\n    // ...\n      // 省略其他一样的代码\n      // ...\n\n    // create创建最终的call函数\n    create(options) {\n        this.init(options);\n        let fn;\n\n        // 拼装代码头部\n        const header = `\n            \"use strict\";\n            var _x = this._x;\n        `;\n\n        // 用传进来的参数和函数体创建一个函数出来\n        fn = new Function(this.args(),\n            header +\n            this.content());         // 注意这里的content函数并没有在基类HookCodeFactory实现，而是子类实现的\n\n        this.deinit();\n\n        return fn;\n    }\n\n    // 拼装函数体\n      // callTapsSeries也没在基类调用，而是子类调用的\n    callTapsSeries() {\n        const { taps } = this.options;\n        let code = '';\n        for (let i = 0; i &lt; taps.length; i++) {\n            code += `\n                var _fn${i} = _x[${i}];\n                _fn${i}(${this.args()});\n            `\n        }\n\n        return code;\n    }\n}</code></pre>\n<p><strong>上面代码里面要特别注意<code>create</code>函数里面生成函数体的时候调用的是<code>this.content</code>，但是<code>this.content</code>并没与在基类实现，这要求子类在使用<code>HookCodeFactory</code>的时候都需要继承他并实现自己的<code>content</code>函数，所以这里的<code>content</code>函数也是一个抽象接口。那<code>SyncHook</code>的代码就应该改成这样：</strong></p>\n<pre><code class=\"javascript\">// SyncHook.js\n\n// ... 省略其他一样的代码 ...\n\n// SyncHookCodeFactory继承HookCodeFactory并实现content函数\nclass SyncHookCodeFactory extends HookCodeFactory {\n    content() {\n        return this.callTapsSeries();    // 这里的callTapsSeries是基类的\n    }\n}\n\n// 使用SyncHookCodeFactory来创建factory\nconst factory = new SyncHookCodeFactory();\n\nconst COMPILE = function (options) {\n    factory.setup(this, options);\n    return factory.create(options);\n};</code></pre>\n<p><strong>注意这里：</strong>子类实现的<code>content</code>其实又调用了基类的<code>callTapsSeries</code>来生成最终的函数体。所以这里这几个函数的调用关系其实是这样的：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039757904\" alt=\"image-20210401111739814\" title=\"image-20210401111739814\" /></p>\n<p><strong>那这样设计的目的是什么呢</strong>？<strong>为了让子类<code>content</code>能够传递参数给基类<code>callTapsSeries</code>，从而生成不一样的函数体</strong>。我们马上就能在<code>SyncBailHook</code>的代码工厂上看到了。</p>\n<p>为了能够生成<code>SyncBailHook</code>的函数体，我们需要让<code>callTapsSeries</code>支持一个<code>onResult</code>参数，就是这样：</p>\n<pre><code class=\"javascript\">class HookCodeFactory {\n    // ... 省略其他相同的代码 ...\n\n    // 拼装函数体，需要支持options.onResult参数\n    callTapsSeries(options) {\n        const { taps } = this.options;\n        let code = '';\n        let i = 0;\n\n        const onResult = options &amp;&amp; options.onResult;\n        \n        // 写一个next函数来开启有onResult回调的函数体生成\n        // next和onResult相互递归调用来生成最终的函数体\n        const next = () =&gt; {\n            if(i &gt;= taps.length) return '';\n\n            const result = `_result${i}`;\n            const code = `\n                var _fn${i} = _x[${i}];\n                var ${result} = _fn${i}(${this.args()});\n                ${onResult(i++, result, next)}\n            `;\n\n            return code;\n        }\n\n        // 支持onResult参数\n        if(onResult) {\n            code = next();\n        } else {\n              // 没有onResult参数的时候，即SyncHook跟之前保持一样\n            for(; i&lt; taps.length; i++) {\n                code += `\n                    var _fn${i} = _x[${i}];\n                    _fn${i}(${this.args()});\n                `\n            }\n        }\n\n        return code;\n    }\n}</code></pre>\n<p>然后我们的<code>SyncBailHook</code>的代码工厂在继承工厂基类的时候需要传一个<code>onResult</code>参数，就是这样：</p>\n<pre><code class=\"javascript\">const Hook = require('./Hook');\nconst HookCodeFactory = require(\"./HookCodeFactory\");\n\n// SyncBailHookCodeFactory继承HookCodeFactory并实现content函数\n// content里面传入定制的onResult函数，onResult回去调用next递归生成嵌套的if...else...\nclass SyncBailHookCodeFactory extends HookCodeFactory {\n    content() {\n        return this.callTapsSeries({\n            onResult: (i, result, next) =&gt;\n                `if(${result} !== undefined) {\\nreturn ${result};\\n} else {\\n${next()}}\\n`,\n        });\n    }\n}\n\n// 使用SyncHookCodeFactory来创建factory\nconst factory = new SyncBailHookCodeFactory();\n\nconst COMPILE = function (options) {\n    factory.setup(this, options);\n    return factory.create(options);\n};\n\n\nfunction SyncBailHook(args = []) {\n    // 基本结构跟SyncHook都是一样的\n    const hook = new Hook(args);\n    hook.constructor = SyncBailHook;\n\n    // 使用HookCodeFactory来创建最终的call函数\n    hook.compile = COMPILE;\n\n    return hook;\n}</code></pre>\n<p>现在运行下代码，效果跟之前一样的，大功告成~</p>\n<h2>其他Hook的实现</h2>\n<p>到这里，<code>tapable</code>的源码架构和基本实现我们已经弄清楚了，但是本文只用了<code>SyncHook</code>和<code>SyncBailHook</code>做例子，其他的，比如<code>AsyncParallelHook</code>并没有展开讲。因为<code>AsyncParallelHook</code>之类的其他<code>Hook</code>的实现思路跟本文是一样的，比如我们可以先实现一个独立的<code>AsyncParallelHook</code>类：</p>\n<pre><code class=\"javascript\">class AsyncParallelHook {\n    constructor(args = []) {\n        this._args = args;\n        this.taps = [];\n    }\n    tapAsync(name, task) {\n        this.taps.push(task);\n    }\n    callAsync(...args) {\n        // 先取出最后传入的回调函数\n        let finalCallback = args.pop();\n\n        // 定义一个 i 变量和 done 函数，每次执行检测 i 值和队列长度，决定是否执行 callAsync 的最终回调函数\n        let i = 0;\n        let done = () =&gt; {\n            if (++i === this.taps.length) {\n                finalCallback();\n            }\n        };\n\n        // 依次执行事件处理函数\n        this.taps.forEach(task =&gt; task(...args, done));\n    }\n}</code></pre>\n<p>然后对他的<code>callAsync</code>函数进行抽象，将其抽象到代码工厂类里面，使用字符串拼接的方式动态构造出来就行了，整体思路跟前面是一样的。具体实现过程可以参考<code>tapable</code>源码：</p>\n<p><a href=\"https://github.com/webpack/tapable/blob/v2.2.0/lib/Hook.js\" rel=\"nofollow noreferrer\">Hook类源码</a></p>\n<p><a href=\"https://github.com/webpack/tapable/blob/v2.2.0/lib/SyncHook.js\" rel=\"nofollow noreferrer\">SyncHook类源码</a></p>\n<p><a href=\"https://github.com/webpack/tapable/blob/v2.2.0/lib/SyncBailHook.js\" rel=\"nofollow noreferrer\">SyncBailHook类源码</a></p>\n<p><a href=\"https://github.com/webpack/tapable/blob/v2.2.0/lib/HookCodeFactory.js\" rel=\"nofollow noreferrer\">HookCodeFactory类源码</a></p>\n<h2>总结</h2>\n<p><strong>本文可运行示例代码已经上传GitHub，大家拿下来一边玩一边看文章效果更佳：<a href=\"https://github.com/dennis-jiang/Front-End-Knowledges/tree/master/Examples/Engineering/tapable-source-code\" rel=\"nofollow noreferrer\">https://github.com/dennis-jiang/Front-End-Knowledges/tree/master/Examples/Engineering/tapable-source-code</a></strong>。</p>\n<p>下面再对本文的思路进行一个总结：</p>\n<ol>\n <li><code>tapable</code>的各种<code>Hook</code>其实都是基于发布订阅模式。</li>\n <li>各个<code>Hook</code>自己独立实现其实也没有问题，但是因为都是发布订阅模式，会有大量重复代码，所以<code>tapable</code>进行了几次抽象。</li>\n <li>第一次抽象是提取一个<code>Hook</code>基类，这个基类实现了初始化和事件注册等公共部分，至于每个<code>Hook</code>的<code>call</code>都不一样，需要自己实现。</li>\n <li>第二次抽象是每个<code>Hook</code>在实现自己的<code>call</code>的时候，发现代码也有很多相似之处，所以提取了一个代码工厂，用来动态生成<code>call</code>的函数体。</li>\n <li>总体来说，<code>tapable</code>的代码并不难，但是因为有两次抽象，整个代码架构显得不那么好读，经过本文的梳理后，应该会好很多了。</li>\n</ol>\n<p><strong>文章的最后，感谢你花费宝贵的时间阅读本文，如果本文给了你一点点帮助或者启发，请不要吝啬你的赞和GitHub小星星，你的支持是作者持续创作的动力。</strong></p>\n<p><strong>欢迎关注我的公众号<a href=\"https://test-dennis.oss-cn-hangzhou.aliyuncs.com/QRCode/QR430.jpg\" rel=\"nofollow noreferrer\">进击的大前端</a>第一时间获取高质量原创~</strong></p>\n<p><strong>“前端进阶知识”系列文章源码地址： <a href=\"https://github.com/dennis-jiang/Front-End-Knowledges\" rel=\"nofollow noreferrer\">https://github.com/dennis-jiang/Front-End-Knowledges</a></strong></p>\n<h2>参考资料</h2>\n<p><code>tapable</code>用法介绍：<a href=\"https://segmentfault.com/a/1190000039418800\">https://segmentfault.com/a/1190000039418800</a></p>\n<p><code>tapable</code>源码地址：<a href=\"https://github.com/webpack/tapable\" rel=\"nofollow noreferrer\">https://github.com/webpack/tapable</a></p>","descriptionType":"html","publishedDate":"Thu, 01 Apr 2021 08:18:05 +0000","feedId":23280,"bgimg":"https://segmentfault.com/img/remote/1460000039757903","linkMd5":"0a51a1e37fc871b7da52703522d5c04c","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn92@2020_4/2021/04/03/05-59-08-710_1fef54573f00fbef.webp","destWidth":342,"destHeight":64,"sourceBytes":6966,"destBytes":6966,"author":"蒋鹏飞","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000039757903":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn92@2020_4/2021/04/03/05-59-08-710_1fef54573f00fbef.webp","https://segmentfault.com/img/remote/1460000039757902":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn99@2020_3/2021/04/03/05-59-12-264_57af7566db0eb8a7.webp","https://segmentfault.com/img/remote/1460000039757904":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn96@2020_4/2021/04/03/05-59-12-736_7fb946170753303b.webp"},"publishedOrCreatedDate":1617429536169}],"record":{"createdTime":"2021-04-03 13:58:56","updatedTime":"2021-04-03 13:58:56","feedId":23280,"fetchDate":"Sat, 03 Apr 2021 05:58:56 +0000","fetchMs":7695,"handleMs":15305,"totalMs":48040,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"35a12d718b8c1c7134db27a83b05145c","hostName":"europe61*","requestId":"9421390cc83f4e5bab1c99afb39ecf54_23280","contentType":"application/atom+xml; charset=UTF-8","totalBytes":26256,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":3,"articlesImgsGithubTotal":3,"successGithubMap":{"myreaderx27":1,"myreaderx4":1,"myreaderx2":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:29:58","updatedTime":"2020-11-12 13:51:25","id":23280,"name":"SegmentFault 最新的文章","url":"https://segmentfault.com/feeds/blogs","subscriber":142,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn43@2020_1/2021/04/03/05-58-55-048_eb238dca7c8e9f0e.jpg","description":"","weekly":null,"link":"https://segmentfault.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":6966,"tmpBodyImgCdnBytes":19290,"tmpBgImgCdnBytes":0,"extra4":{"start":1617429505073,"total":0,"statList":[{"spend":15791,"msg":"获取xml内容"},{"spend":15305,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":4096,"msg":"正文链接上传到cdn"}]},"extra5":3,"extra6":3,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-010.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-022.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039757903","sourceStatusCode":200,"destWidth":342,"destHeight":64,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn92@2020_4/2021/04/03/05-59-08-710_1fef54573f00fbef.webp","sourceBytes":6966,"destBytes":6966,"feedId":23280,"totalSpendMs":2982,"convertSpendMs":0,"createdTime":"2021-04-03 13:59:05","host":"us-034*","referer":"https://segmentfault.com/a/1190000039757900","linkMd5ListStr":"0a51a1e37fc871b7da52703522d5c04c,0a51a1e37fc871b7da52703522d5c04c","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"6.8 KB","destSize":"6.8 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039757902","sourceStatusCode":200,"destWidth":398,"destHeight":64,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn99@2020_3/2021/04/03/05-59-12-264_57af7566db0eb8a7.webp","sourceBytes":7252,"destBytes":7252,"feedId":23280,"totalSpendMs":3356,"convertSpendMs":0,"createdTime":"2021-04-03 13:59:09","host":"us-010*","referer":"https://segmentfault.com/a/1190000039757900","linkMd5ListStr":"0a51a1e37fc871b7da52703522d5c04c","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"7.1 KB","destSize":"7.1 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039757904","sourceStatusCode":200,"destWidth":604,"destHeight":486,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn96@2020_4/2021/04/03/05-59-12-736_7fb946170753303b.webp","sourceBytes":12038,"destBytes":12038,"feedId":23280,"totalSpendMs":3933,"convertSpendMs":0,"createdTime":"2021-04-03 13:59:09","host":"us-022*","referer":"https://segmentfault.com/a/1190000039757900","linkMd5ListStr":"0a51a1e37fc871b7da52703522d5c04c","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"11.8 KB","destSize":"11.8 KB","compressRate":"100%"}],"successGithubMap":{"myreaderx27":1,"myreaderx4":1,"myreaderx2":1},"failGithubMap":{}}