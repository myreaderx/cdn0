{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2021-06-06 13:01:30","updatedTime":"2021-06-06 13:01:30","title":"Rust 与 OS | 一种有效的页表系统抽象设计","link":"https://juejin.cn/post/6970526073461145630","description":"<div class=\"markdown-body\"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:\"\";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><p>作者：洛佳 / 后期编辑 ：张汉东</p>\n<p>从段进化到页，是操作系统内存抽象的一大进步之处。页式存储管理由软硬件共同实现，软件提供映射关系，\n硬件来加速地址翻译的过程。为了更好地设计硬件，往往要求软件页满足一定的数据要求。</p>\n<p>这篇笔记尝试梳理软件层次上，页的实现过程。将会包括大页的分配算法，物理地址的对齐，多种分页模式的兼容设计，\n以及如何使用泛型、模块化等现代语言技术实现它们。</p>\n<p>可能讲得不清楚，请各位看官海涵。</p>\n<h2 data-id=\"heading-0\">大页分配算法</h2>\n<p>页式存储系统拥有“大页”的概念。在一些架构下，大页要求地址对齐。\n即大页的物理地址必须对齐到特定的级别，随后的低级页号和索引，将共同看作更长的索引使用。\n这就对分配算法提出了一定的要求。</p>\n<p>归纳需要解决的问题。我们的问题是：给定页表系统<code>M</code>，最大等级为<code>n</code>；对虚拟页号<code>v = (vn-1, ...v1, v0)</code>和待映射连续页数<code>n</code>,\n找到一组页的映射集合<code>U = { (v_开始, p_开始, 长度) }</code>，使得页号<code>v</code>能映射到物理页号<code>p</code>。\n考虑使用大页优化这一过程，使<code>| U |</code>越少越好，但需要注意对齐要求，即对等级为<code>k</code>的大页，\n起始地址为<code>(vn-1, ...vk, 0, ...0)</code>的<code>k-1</code>到<code>0</code>级均为0，即假如<code>k</code>级的对齐要求为<code>a[k]</code>，有<code>v = 0 (mod a[k])</code>。</p>\n<p>在<code>M = Sv39系统</code>中，最大等级<code>n = 3</code>，对齐要求<code>a[0] = 1</code>, <code>a[1] = 512</code>, <code>a[2] = 26'2144</code>[注释1]。即，每一级别包含512个页表项。</p>\n<p>为了简化问题理解，我们定义一个<code>M = 简单的页表系统</code>，最大等级也为<code>n = 3</code>，但<code>a[0] = 1</code>, <code>a[1] = 4</code>, <code>a[2] = 16</code>。\n每一级别包含3个页表项。给定虚拟地址<code>v = (2, 2, 2)</code>到<code>v + n = (5, 2, 1)</code>，要映射到物理地址<code>p = (2, 2, 2)</code>。</p>\n<p>现在我们在最高的3级，将要分配<code>r(v) = (2, 2, 2)..=(5, 2, 1)</code>到<code>p = (2, 2, 2)</code>。\n如果直接使用大页，将必须保证2、1级的编号都为0。也就是说，只能分配<code>r(v) = (3, 0, 0)..(5, 0, 0)</code>到<code>p = (3, 0, 0)</code>。</p>\n<p>为什么不分配<code>(2, 0, 0)..(3, 0, 0)</code>到<code>(2, 0, 0)</code>呢？因为这将分配超过<code>(2, 2, 2)..=(5, 2, 1)</code>的范围，\n和我们要求解的问题不同。同理，也不能分配<code>(5, 0, 0)..(6, 0, 0)</code>到<code>(5, 0, 0)</code>。这部分的范围，需要借助更低级的大页来完成。</p>\n<p>第3级的分配完成了，然后我们借助2级页表，分配附近零碎的<code>(2, 3, 0)..(3, 0, 0)</code>和<code>(5, 0, 0)..(5, 2, 0)</code>。\n分配<code>(2, 3, 0)..(3, 0, 0)</code>到<code>(2, 3, 0)</code>；<code>(5, 0, 0)..(5, 2, 0)</code>到<code>(5, 0, 0)</code>。</p>\n<p>最后，借助1级页表，分配<code>(2, 2, 2)..(2, 3, 0)</code>到<code>(2, 2, 2)</code>；<code>(5, 2, 0)..(5, 2, 2)</code>到<code>(5, 2, 0)</code>。\n至此，所有的分配完成了。</p>\n<p>由于这种方法要求在虚拟的大页上分配物理的大页，两个大页的基地址必须有相同的对齐方式，因此，\n初始传入的虚拟页号和物理页号，差值必须对齐到相应的页，即<code>v = p (mod a[k])</code>，才可以使用这种分配方法；否则就应当使用更低等级的分配方法。\n（想想看为什么？）否则就会在分配过程中，产生对齐要求的异常。</p>\n<p>比如<code>v = (2, 2, 2)</code>到<code>p = (2, 2, 2)</code>，就可以使用3级；而<code>v = (2, 2, 2)</code>到<code>p = (2, 1, 2)</code>，就只能使用2级。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/596077619b264b0cba3af3840207d4c5~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\" loading=\"lazy\" referrerpolicy=\"no-referrer\"></p>\n<p>推广这个结论，我们可以得到一个规律。首先，使用贪心的方法，将地址的上下限分别向内取整，分配最大的大页给最高的地址范围。\n然后，对两边的零碎范围，使用低1级的页表，继续分配。继续降低等级，直到所有的页都被分配完毕。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/373c0098930d481eb44d7c370a1c2161~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\" loading=\"lazy\" referrerpolicy=\"no-referrer\"></p>\n<p>根据对齐规则和所需求的页数，逐级降低算法的起始等级。对等级<code>n = 3</code>的页表系统，以分支形式，我们编写顺序规则的伪代码。</p>\n<pre><code class=\"copyable\">// input: v: VirtPageNum, p: PhysPageNum, n: usize, a: PageMode;\nif (v - p) % (a[2].frame_align()) == 0 && n >= a[2].frame_align() {\n    let l2n = (vs2 - ve2) / a[2].frame_align();\n    map(2, ve2, vs2, ve2-v+p);\n    let l1n = (ve2 - ve1 + vs1 - vs2) / a[1].frame_align();\n    map(1, ve1, ve2, ve1-v+p); map(1, vs2, vs1, vs2-v+p);\n    let l0n = (n + ve1 - vs1) / a[0].frame_align();\n    map(0, v, ve1, p); map(0, vs1, v+n, vs1-v+p);\n} else if (v - p) % (a[1].frame_align()) == 0 && n >= a[1].frame_align() {\n    let l1n = (vs1 - ve1) / a[1].frame_align();\n    map(1, ve1, vs1, ve1-v+p);\n    let l0n = (n + ve1 - vs1) / a[0].frame_align();\n    map(0, v, ve1, p); map(0, vs1, v+n, vs1-v+p);\n} else if (v - p) % (a[0].frame_align()) == 0 && n >= a[0].frame_align() {\n    let l0n = n / a[0].frame_align();\n    map(0, v, v+n, p);\n} else {\n    panic!(\"Can't map v to p under this page mode\")\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>我们发现，等级低算法的中间变量，也在等级高的地方出现了。于是这个算法可以改成循环的形式。</p>\n<pre><code class=\"copyable\">// input: v: VirtPageNum, p: PhysPageNum, n: usize, M: PageMode;\nfor i in M::visit_levels_until(PageLevel::leaf_level()) { // 遍历顺序：[n, ...1, 0]\n    let align = M::a(i); // i层的对齐要求\n    if (v - p) % align != 0 || n < align { // 对齐要求达不到等级，或者数量不够，使用低级算法\n        continue;\n    }\n    let (mut ve_prev, mut vs_prev) = (None, None);\n    for j in M::visit_levels_from(i) { // 遍历顺序：[j, j-1, ...0]\n        let a = M::a(j); // j层的对齐要求\n        let ve_cur = a * roundup(v / a)\n        let vs_cur = a * rounddown((v + n) / a)\n        if let (Some(ve_prev), Some(vs_prev)) = (ve_prev, vs_prev) {\n            map(j, ve_cur..ve_prev); // 执行映射函数\n            map(j, vs_prev..vs_cur);\n        } else {\n            map(j, ve_cur..vs_cur);\n        }\n        (ve_prev, vs_prev) = (Some(ve_cur), Some(vs_cur));\n    }\n    break;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>这个算法就可以用于任何等级的页表系统了，因此题目要求的算法得到解决。\n使用Rust语言的生成器或者迭代器包装算法，即可得到比较好的算法实现。</p>\n<p>传统分配算法是，将地址段内的所有地址，映射到最小的页帧上。此时，需要管理多少个页帧，就需要分配多少个页。\n大页分配算法通过分配满足对齐要求更少的页，就能完成同样的任务。我们如何比较大页分配算法和传统算法分配的页数呢？</p>\n<p>我们取用<code>M = Sv39系统</code>。其中，最大等级<code>n = 3</code>，对齐要求<code>a[0] = 1</code>, <code>a[1] = 512</code>, <code>a[2] = 26'2144</code>。</p>\n<p>同样分配<code>505'5550</code>个页帧，假设页号对齐能满足最大的<code>26'2144</code>，采用不同的虚拟页号。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>虚拟页号</th><th>数量</th><th>所需页表数</th><th>节省</th><th>等级0</th><th>等级1</th><th>等级2</th></tr></thead><tbody><tr><td>0</td><td>505'5550</td><td>227</td><td>0.00%</td><td>62</td><td>146</td><td>19</td></tr><tr><td>10</td><td>505'5550</td><td>1249</td><td>0.02%</td><td>574</td><td>657</td><td>18</td></tr><tr><td>20</td><td>505'5550</td><td>1249</td><td>0.02%</td><td>574</td><td>657</td><td>18</td></tr><tr><td>512</td><td>505'5550</td><td>738</td><td>0.01%</td><td>62</td><td>658</td><td>18</td></tr><tr><td>1024</td><td>505'5550</td><td>738</td><td>0.01%</td><td>62</td><td>658</td><td>18</td></tr><tr><td>1025</td><td>505'5550</td><td>1249</td><td>0.02%</td><td>574</td><td>657</td><td>18</td></tr><tr><td>26'2144</td><td>505'5550</td><td>227</td><td>0.00%</td><td>62</td><td>146</td><td>19</td></tr><tr><td>100'0000</td><td>505'5550</td><td>738</td><td>0.01%</td><td>574</td><td>145</td><td>19</td></tr></tbody></table>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>虚拟页号</th><th>数量</th><th>所需页表数</th><th>节省</th><th>等级0</th><th>等级1</th><th>等级2</th></tr></thead><tbody><tr><td>30'0000</td><td>1</td><td>1</td><td>100.00%</td><td>1</td><td>N/A</td><td>N/A</td></tr><tr><td>30'0000</td><td>10</td><td>10</td><td>100.00%</td><td>10</td><td>N/A</td><td>N/A</td></tr><tr><td>30'0000</td><td>100</td><td>100</td><td>100.00%</td><td>100</td><td>N/A</td><td>N/A</td></tr><tr><td>30'0000</td><td>1000</td><td>489</td><td>48.90%</td><td>488</td><td>1</td><td>N/A</td></tr><tr><td>30'0000</td><td>1'0000</td><td>291</td><td>2.91%</td><td>272</td><td>19</td><td>N/A</td></tr><tr><td>30'0000</td><td>10'0000</td><td>355</td><td>0.36%</td><td>160</td><td>195</td><td>N/A</td></tr><tr><td>30'0000</td><td>100'0000</td><td>995</td><td>0.10%</td><td>64</td><td>929</td><td>2</td></tr><tr><td>30'0000</td><td>1000'0000</td><td>752</td><td>0.01%</td><td>128</td><td>587</td><td>37</td></tr></tbody></table>\n<p>可以发现，Sv39下对齐要求高、页帧数量大时，大页只需要小于一千个页表，就能管理百万个页帧空间，非常节省页表的数量。\n页帧数量小时，由于对齐要求不高，节省的数量并不明显；对齐要求低时，节省数量也不明显。</p>\n<p>实际使用时，尽量给出最大的对齐要求，这样可以在分配大量页帧时，节省更多的页帧空间。\n这一结果对芯片外设的布局也有指导作用，如果高级的嵌入式芯片拥有较多外设，尽量将外设的物理地址放置到更高的对齐要求上，\n这样操作系统管理时就可以腾出更多的内存空间，供应用使用。</p>\n<p>[注释1]：表格中的'号表示万位分隔符，<a href=\"https://zhuanlan.zhihu.com/p/358635675\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">成会明院士：传承祖先的智慧，倡导中文中阿拉伯数字书写方式采用“4位数分隔法”. 中国科学院院刊</a></p>\n<h2 data-id=\"heading-1\">抽象软件设计</h2>\n<p>以Rust语言为例，给出页系统常见结构的抽象方法。</p>\n<h3 data-id=\"heading-2\">页号</h3>\n<p>首先定义物理和虚拟页号。</p>\n<pre><code class=\"copyable\">#[derive(Copy, Clone, PartialEq, Eq, Debug)]\npub struct PhysPageNum(usize);\n\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\npub struct VirtPageNum(usize);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>“物理页号长度 + 偏移长度”可能大于“架构地址宽度”，这允许我们访问大于架构宽度的地址。\n比如RISC-V RV32下，使用Sv32系统，可以访问34位的物理地址，即使架构只有32位。</p>\n<p>物理页号和虚拟页号，可以通过对应的地址转换而来。</p>\n<pre><code class=\"copyable\">impl PhysPageNum {\n    pub fn addr_begin<M: PageMode>(&self) -> PhysAddr {\n        PhysAddr(self.0 << M::FRAME_SIZE_BITS)\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>这种转换关系要求输入页表的模式。不同架构下，地址的偏移量可能不同。</p>\n<h3 data-id=\"heading-3\">页帧分配器</h3>\n<p>然后我们需要一个页帧分配器。模仿Rust语言alloc包的设计，可以给出结构如下。</p>\n<pre><code class=\"copyable\">pub trait FrameAllocator {\n    fn allocate_frame(&self) -> Result<PhysPageNum, FrameAllocError>;\n    fn deallocate_frame(&self, ppn: PhysPageNum);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>构造页帧分配器时，应当给定一个物理页的范围。</p>\n<p>而后，每次请求分配，其中的算法将返回分配的结果，或者当没有页存在时，返回一个错误。</p>\n<pre><code class=\"copyable\">impl StackFrameAllocator {\n    pub fn new(start: PhysPageNum, end: PhysPageNum) -> Self {\n        StackFrameAllocator { current: start, end, recycled: Vec::new() }\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>页帧分配器只分配编号，不会向被分配的内存中存储或读取数据，所以它的设计与alloc库简单。</p>\n<p>这种设计是为了方便测试页帧分配器的正确性和性能。</p>\n<h3 data-id=\"heading-4\">装箱的页帧</h3>\n<p>或者说<code>FrameBox</code>，借鉴了Rust中拥有所有权的Box名称，表示拥有所有权的一个页帧。</p>\n<pre><code class=\"copyable\">#[derive(Debug)]\npub struct FrameBox<A: FrameAllocator = DefaultFrameAllocator> {\n    ppn: PhysPageNum, // 相当于*mut类型的指针\n    frame_alloc: A,\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>每次新建时，从页帧分配器<code>frame_alloc</code>中得到新的页帧，然后使用所有权语义包装妥当。\n当它的生命周期结束，调用页帧分配器，释放所占有的页帧。</p>\n<pre><code class=\"copyable\">impl<A: FrameAllocator> FrameBox<A> {\n    // 分配页帧并创建FrameBox\n    pub fn try_new_in(frame_alloc: A) -> Result<FrameBox<A>, FrameAllocError> {\n        let ppn = frame_alloc.allocate_frame()?;\n        Ok(FrameBox { ppn, frame_alloc })\n    }\n}\n\nimpl<A: FrameAllocator> Drop for FrameBox<A> {\n    fn drop(&mut self) {\n        // 释放所占有的页帧\n        self.frame_alloc.deallocate_frame(self.ppn);\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>装箱的页帧实际地保管了页帧内存的所有权，可以向内写入数据，从中读取数据。</p>\n<h3 data-id=\"heading-5\">页式地址空间</h3>\n<p>一个表示分页系统实现的结构体，它保管着所有包含的页帧箱子，在释放时会释放其中的所有页帧。</p>\n<p>这个结构体拥有一个分页模式的类型参数，用于计算页帧插入算法。</p>\n<pre><code class=\"copyable\">// 表示一个分页系统实现的地址空间\n//\n// 如果属于直接映射或者线性偏移映射，不应当使用这个结构体，应当使用其它的结构体。\n#[derive(Debug)]\npub struct PagedAddrSpace<M: PageMode, A: FrameAllocator = DefaultFrameAllocator> {\n    root_frame: FrameBox<A>,\n    frames: Vec<FrameBox<A>>,\n    frame_alloc: A,\n    page_mode: M,\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>当创建页式地址空间时，立即分配一个根页表。</p>\n<pre><code class=\"copyable\">impl<M: PageMode, A: FrameAllocator + Clone> PagedAddrSpace<M, A> {\n    // 创建一个空的分页地址空间。一定会产生内存的写操作\n    pub fn try_new_in(page_mode: M, frame_alloc: A) -> Result<Self, FrameAllocError> {\n        // 新建一个根页表要求的页帧\n        let mut root_frame = FrameBox::try_new_in(frame_alloc.clone())?;\n        // 而后，向帧里填入一个空的根页表 \n        unsafe { fill_frame_with_initialized_page_table::<A, M>(&mut root_frame) };\n        Ok(Self { root_frame, frames: Vec::new(), frame_alloc, page_mode })\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>创建结构后，当插入新的映射关系，使用上一节提供的插入算法，得到需要插入的范围，然后读写页帧箱，完成插入操作。</p>\n<pre><code class=\"copyable\">impl<M: PageMode, A: FrameAllocator + Clone> PagedAddrSpace<M, A> {    \n    // 设置页表项。如果寻找的过程中，中间的页表没创建，那么创建它们\n    unsafe fn alloc_get_table(&mut self, entry_level: PageLevel, vpn_start: VirtPageNum)\n    -> Result<&mut M::PageTable, FrameAllocError> \n    {\n        let mut ppn = self.root_frame.phys_page_num();\n        for &level in M::visit_levels_before(entry_level) {\n            let page_table = unref_ppn_mut::<M>(ppn);\n            let vidx = M::vpn_index(vpn_start, level);\n            match M::slot_try_get_entry(&mut page_table[vidx]) {\n                Ok(entry) => ppn = M::entry_get_ppn(entry),\n                Err(mut slot) => {  // 需要一个内部页表，这里的页表项却没有数据，我们需要填写数据\n                    let frame_box = FrameBox::try_new_in(self.frame_alloc.clone())?;\n                    M::slot_set_child(&mut slot, frame_box.phys_page_num());\n                    ppn = frame_box.phys_page_num();\n                    self.frames.push(frame_box);\n                }\n            }\n        }\n        // println!(\"[kernel-alloc-map-test] in alloc_get_table PPN: {:x?}\", ppn);\n        let page_table = unref_ppn_mut::<M>(ppn); // 此时ppn是当前所需要修改的页表\n        // 创建了一个没有约束的生命周期。不过我们可以判断它是合法的，因为它的所有者是Self，在Self的周期内都合法\n        Ok(&mut *(page_table as *mut _))\n    }\n    pub fn allocate_map(&mut self, vpn: VirtPageNum, ppn: PhysPageNum, n: usize, flags: M::Flags)\n    -> Result<(), FrameAllocError> \n    {\n        for (page_level, vpn_range) in MapPairs::solve(vpn, ppn, n, self.page_mode) {\n            // println!(\"[kernel-alloc-map-test] PAGE LEVEL: {:?}, VPN RANGE: {:x?}\", page_level, vpn_range);\n            let table = unsafe { self.alloc_get_table(page_level, vpn_range.start) }?;\n            let idx_range = M::vpn_index_range(vpn_range.clone(), page_level);\n            // println!(\"[kernel-alloc-map-test] IDX RANGE: {:?}\", idx_range);\n            for vidx in idx_range {\n                let this_ppn = PhysPageNum(ppn.0 - vpn.0 + M::vpn_level_index(vpn_range.start, page_level, vidx).0);\n                // println!(\"[kernel-alloc-map-test] Table: {:p} Vidx {} -> Ppn {:x?}\", table, vidx, this_ppn);\n                match M::slot_try_get_entry(&mut table[vidx]) {\n                    Ok(_entry) => panic!(\"already allocated\"),\n                    Err(slot) => M::slot_set_mapping(slot, this_ppn, flags.clone())\n                }\n            }\n        }\n        Ok(())\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h3 data-id=\"heading-6\">包装的页帧分配算法</h3>\n<p>定义与实现如下。</p>\n<pre><code class=\"copyable\">#[derive(Debug)]\npub struct MapPairs<M> {\n    ans_iter: alloc::vec::IntoIter<(PageLevel, Range<VirtPageNum>)>,\n    mode: M,\n}\n\nimpl<M: PageMode> MapPairs<M> {\n    pub fn solve(vpn: VirtPageNum, ppn: PhysPageNum, n: usize, mode: M) -> Self {\n        let mut ans = Vec::new();\n        /* 省略求解过程 */\n        Self { ans_iter: ans.into_iter(), mode }\n    }\n}\n\nimpl<M> Iterator for MapPairs<M> {\n    type Item = (PageLevel, Range<VirtPageNum>);\n    fn next(&mut self) -> Option<Self::Item> {\n        self.ans_iter.next()\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>每次迭代它的结果，会返回一个应当分配的页帧。应当根据这个结果，设置映射关系。</p>\n<h3 data-id=\"heading-7\">激活函数</h3>\n<p>这个函数的实现与具体架构有关，此处以RISC-V Sv39为例。</p>\n<pre><code class=\"copyable\">// 切换地址空间，同时需要提供1.地址空间的详细设置 2.地址空间编号\npub unsafe fn activate_paged_riscv_sv39(root_ppn: PhysPageNum, asid: AddressSpaceId) {\n    use riscv::register::satp::{self, Mode};\n    satp::set(Mode::Sv39, asid.0 as usize, root_ppn.0);\n    asm!(\"sfence.vma {}\", in(reg) asid.0 as usize);\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>执行完毕后，就已经进入新的地址空间了。注意当前的pc地址仍未改变，如果进入新空间后，\n指令对应的代码段已经消失了，将产生异常。因此，一般使用各个虚拟空间中共同映射的“跳板页”，完成这一切换过程。</p>\n<h3 data-id=\"heading-8\">本设计的优缺点</h3>\n<p>这个设计的优点是，你会发现只需要传入泛型参数M，代表页表模式，就能自动填写算法剩余的部分。</p>\n<p>比如，RISC-V Sv39模式可以实现为页表模式，传入泛型参数M；它的定义如下。</p>\n<pre><code class=\"copyable\">// Sv39分页系统模式；RISC-V RV64下有效\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\npub struct Sv39;\n\nimpl PageMode for Sv39 {\n    const FRAME_SIZE_BITS: usize = 12;\n    const PPN_BITS: usize = 44;\n    type PageTable = Sv39PageTable;\n    type Entry = Sv39PageEntry;\n    type Slot = Sv39PageSlot;\n    type Flags = Sv39Flags;\n    /* 省略了大量的工具函数 */\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>只需要实现模式M中的这些参数，就可以无缝使用这个页表空间系统，包括求解算法。</p>\n<p>完整的代码实现在<a href=\"https://github.com/HUST-OS/luojia-os-labs/blob/main/03-virt-addr-kern/src/mm.rs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这里</a>。</p>\n<p>这种方法也有缺点，就是需要支持泛型的编程语言才可以使用；比如操作系统内核用Rust写，可以采用这种编程方法。</p>\n<h2 data-id=\"heading-9\">目前常见的硬件页表系统</h2>\n<p>RISC-V提供了Sv39和Sv48；它们分别是3、4级的页表系统，等级越高，能管理的虚拟空间越大。</p>\n<p>我们使用上一节的描述方法，描述这些页表系统的基本参数。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>页表系统M</th><th>虚拟地址</th><th>物理地址</th><th>等级n</th><th>对齐要求a</th></tr></thead><tbody><tr><td>RISC-V Sv39</td><td>39</td><td>55</td><td>3</td><td>1, 512, 26'2144</td></tr><tr><td>RISC-V Sv48</td><td>48</td><td>55</td><td>4</td><td>1, 512, 26'2144, 1'3421'7728</td></tr><tr><td>RISC-V Sv32</td><td>32</td><td>34*</td><td>2</td><td>1, 1024</td></tr><tr><td>龙芯 LA64</td><td>48</td><td>60</td><td>4</td><td>1, 4096/2048*, ...</td></tr><tr><td>龙芯 LA32</td><td>32</td><td>36</td><td>2</td><td>1, 1024</td></tr><tr><td>arm64</td><td>48</td><td>39</td><td>4</td><td>1, 512, 26'2144, 1'3421'7728</td></tr><tr><td>arm32</td><td>32</td><td>32</td><td>2</td><td>1, 256</td></tr><tr><td>x86-64 (旧)</td><td>48</td><td>47</td><td>4</td><td>1, 512, 26'2144, 1'3421'7728</td></tr><tr><td>x86-64 (新)</td><td>57</td><td>52</td><td>5</td><td>1, 512, 26'2144, 1'3421'7728, 687'1947'6736</td></tr><tr><td>x86-32</td><td>32</td><td>32</td><td>2</td><td>1, 1024</td></tr></tbody></table>\n<p>*Sv32的物理地址的确超过32位</p>\n<p>*龙芯LA64架构中，双页存储结构对齐要求不同</p>\n<p>系统启动时，内核可以激活Sv39，页表的等级少，开销较低，启动快。随后，根据需求，可以更换到更大空间的页表系统，来容纳更多应用。</p>\n<h2 data-id=\"heading-10\">页式内存管理笔记</h2>\n<p>在文章的最后，我们花一些时间尝试整理页式内存管理概念的笔记。</p>\n<h3 data-id=\"heading-11\">页式内存管理</h3>\n<p>要管理挂载的外设和内存块，我们定义物理地址，它是真实硬件中资源单元的编号。\n所有的物理地址构成一个地址空间；地址空间是可由地址索引的，具体资源和硬件的集合。</p>\n<p>我们的应用程序可以直接在物理地址上运行。然而，为了便于程序独占地址空间，便于连续地规划内存，\n我们为它们构造虚拟空间。于是程序可以在虚拟地址上运行，虚拟地址是虚拟空间中内存单元的编号。</p>\n<p>从前我们使用段的方式管理内存。为了减少内碎片和内存的浪费，我们引入了分页管理系统。</p>\n<p>分页系统将地址空间分为连续的等大内存块，它们被称作页帧。\n又将一个或多个连续页帧组成一个页，页的大小由硬件实现决定，软件必须按硬件给定页的大小。</p>\n<p>管理页的数据结构称作页表。在内存中，页表通常占一个页帧的大小，以便硬件上的分页系统管理。\n页表在内存中的存储位置被称作页号。</p>\n<p>超过一个页帧大小的页，又被称作大页。管理大页的页表中，每个项目代表一个子页。\n这个项目被称作页表的页表项，通常由权限位、控制位和物理页号组成。</p>\n<p>将地址空间看作最大的页，根页表就是管理最大页的页表。根页表的页号会被保存在专用的位置中，以作为硬件查询的起始地址使用。</p>\n<h3 data-id=\"heading-12\">翻译过程与地址对齐</h3>\n<p>现代的页表系统中，无论等级，都称管理页的数据结构为页表。页表的翻译过程大致等同于这个步骤：</p>\n<ol>\n<li>取出根页表的页号</li>\n<li>读取虚拟地址的特定区域，作为本级页表的索引</li>\n<li>根据索引，取出管理更小页的页表项</li>\n<li>如果页表项指向子页表，读取页号，返回到步骤2</li>\n</ol>\n<p>在这个简化的步骤中，可能出现非常多的异常。需要注意的是，如果当前页表项指向物理页号，这个物理页号有对齐要求。</p>\n<p>我们如果使用<code>(v0, v1, v2):offset</code>代表一个虚拟地址。</p>\n<p>如果<code>rt[v0][v1]</code>指向子页表，那么将继续查找<code>rt[v0][v1][v2]</code>。得到物理页号<code>(p0, p1, p2)</code>。\n和off结合，得到物理地址<code>(p0, p1, p2):offset</code>。</p>\n<p>如果<code>rt[v0][v1]</code>指向一个物理页，这是一个大页的页表项。页表项中，得到物理页号<code>(p0, p1, 0)</code>，\n直接将v2、off拼接，得到大页对应的物理地址为<code>(p0, p1):v2,offset</code>；相当于延长了偏移量的位数。</p>\n<p>采用后一种形式时，硬件通常要求物理页号只有高于大页的等级有效，低于它的无效。\n也就是说，如果页表项<code>(p0, p1, p2)</code>的p2不等于零，将会返回页异常。这就是大页页表系统的对齐要求。</p>\n<p>作者简介：</p>\n<p><strong>洛佳</strong></p>\n<p>华中科技大学网络空间安全学院本科生，热爱操作系统、嵌入式开发。3年Rust语言开发经验，社区活跃贡献者。目前致力于向产业、教学等更多的领域推广Rust语言。</p></div>","descriptionType":"text/html","publishedDate":"Sat, 05 Jun 2021 20:04:36 +0000","feedId":17720,"bgimg":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/596077619b264b0cba3af3840207d4c5~tplv-k3u1fbpfcp-zoom-1.image","linkMd5":"546fc0009e4fdfd6f6fb5d00fd648f0a","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn72@2020_2/2021/06/06/05-01-31-581_dc18a1e290073063.webp","destWidth":1422,"destHeight":1422,"sourceBytes":141733,"destBytes":100178,"author":"Rust_Magazine","articleImgCdnMap":{"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/596077619b264b0cba3af3840207d4c5~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn72@2020_2/2021/06/06/05-01-31-581_dc18a1e290073063.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/373c0098930d481eb44d7c370a1c2161~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn76@2020_6/2021/06/06/05-01-33-629_835ce68ff0e2db67.webp"},"publishedOrCreatedDate":1622955690607}],"record":{"createdTime":"2021-06-06 13:01:30","updatedTime":"2021-06-06 13:01:30","feedId":17720,"fetchDate":"Sun, 06 Jun 2021 05:01:30 +0000","fetchMs":50478,"handleMs":7,"totalMs":53820,"newArticles":0,"totalArticles":5,"status":1,"type":0,"ip":"4cf9ab886509ef3fd2ece0a16b714d9c","hostName":"europe63*","requestId":"6aa2bfb2af2b4ac295d5098b338bf5c9_17720","contentType":"application/xml; charset=utf-8","totalBytes":311958,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":2,"articlesImgsGithubTotal":2,"successGithubMap":{"myreaderx32":1,"myreaderx30":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:15:50","updatedTime":"2020-09-07 02:49:19","id":17720,"name":"掘金后端","url":"https://rsshub.app/juejin/category/backend","subscriber":187,"website":null,"icon":"https://juejin.im/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx63/cdn96@2020_3/2020/09/06/18-47-49-898_24cb365749d306f2.ico","description":"掘金后端 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":100178,"tmpBodyImgCdnBytes":211780,"tmpBgImgCdnBytes":0,"extra4":{"start":1622955640112,"total":0,"statList":[{"spend":50488,"msg":"获取xml内容"},{"spend":7,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":2043,"msg":"正文链接上传到cdn"}]},"extra5":2,"extra6":2,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-004.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/596077619b264b0cba3af3840207d4c5~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":1422,"destHeight":1422,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn72@2020_2/2021/06/06/05-01-31-581_dc18a1e290073063.webp","sourceBytes":141733,"destBytes":100178,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":1121,"convertSpendMs":75,"createdTime":"2021-06-06 13:01:30","host":"us-016*","referer":"https://juejin.cn/post/6970526073461145630","linkMd5ListStr":"546fc0009e4fdfd6f6fb5d00fd648f0a,546fc0009e4fdfd6f6fb5d00fd648f0a","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"138.4 KB","destSize":"97.8 KB","compressRate":"70.7%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/373c0098930d481eb44d7c370a1c2161~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":1440,"destHeight":1840,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn76@2020_6/2021/06/06/05-01-33-629_835ce68ff0e2db67.webp","sourceBytes":330437,"destBytes":211780,"targetWebpQuality":75,"feedId":17720,"totalSpendMs":1876,"convertSpendMs":150,"createdTime":"2021-06-06 13:01:32","host":"us-004*","referer":"https://juejin.cn/post/6970526073461145630","linkMd5ListStr":"546fc0009e4fdfd6f6fb5d00fd648f0a","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"322.7 KB","destSize":"206.8 KB","compressRate":"64.1%"}],"successGithubMap":{"myreaderx32":1,"myreaderx30":1},"failGithubMap":{}}