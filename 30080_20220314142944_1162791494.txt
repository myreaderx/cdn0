{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2022-03-14 22:29:44","updatedTime":"2022-03-14 22:29:44","title":"C++ in Kernel Drivers (c++, boost, std)","link":"http://www.zer0mem.sk/?p=517","description":" <p> Recently i was looking for another approaches how to use c++ features in kernel mode drivers. I found some references, but no one will fullfill my needs &#38; desires to use also boost &#38; std (at least partially). </p> \n<div class=\"centerobj\"></div>\n <p> Some time ago my friend show me a way how to add mentioned libraries to kernel code, so i decided to do it from scratch, do some minimalistic approach with some kind of &#8216;manual&#8217; and PoC, and maybe it can be for someone, except myself, usefull. <br /> \n <!-- CORE -->  <br /> \n&#160; </p> \n<ul>\n<li><em><strong>Part I. &#8211; force c++ to cooperate</strong></em></li>\n</ul>\n <p> Firstly, it is no big deal to use c++ in kernel mode. For example, some of references that i was able to found : </p> \n<ul>\n<li><a href=\"http://stackoverflow.com/questions/17251171/removed-the-c-runtime-library-and-i-am-receiving-some-unresolved-externals\" target=\"_blank\">removing C runtime, and solving some issues</a></li>\n<li><a href=\"http://www.hollistech.com/Resources/Cpp/kernel_c_runtime_library.htm\" target=\"_blank\">Kernel C runtime library</a></li>\n</ul>\n <p> What is needed, is well known, and it is to provide minimalistic c++ enviroment, including : </p> \n<ul>\n<li>malloc</li>\n<li>free</li>\n<li>realloc</li>\n<li>operator new</li>\n<li>operator delete</li>\n</ul>\n <p> it is easy doable : </p> <pre class=\"crayon-plain-tag\">EXTERN_C\n__drv_when(return!=0, __drv_allocatesMem(pBlock))\n__checkReturn\n__drv_maxIRQL(DISPATCH_LEVEL)\n__bcount_opt(size)\nvoid* \n__cdecl malloc(\n\t__in size_t size\n\t)\n{\n\tMEMBLOCK *pBlock = static_cast&#60;MEMBLOCK*&#62;(\n\t\tExAllocatePoolWithTag(\n\t\t\tNonPagedPoolNxCacheAligned, \n\t\t\tsize + sizeof(MEMBLOCK), \n\t\t\t_LIBC_POOL_TAG));\n\n\tif (nullptr == pBlock)\n\t\treturn nullptr;\n\n\tpBlock-&#62;size = size;\t\n\treturn pBlock-&#62;data;\n}\n\nEXTERN_C\n__drv_maxIRQL(DISPATCH_LEVEL)\nvoid \n__cdecl free(\n\t__inout_opt __drv_freesMem(Mem) void* ptr\n\t)\n{\n\tif (ptr)\n\t\tExFreePoolWithTag(CONTAINING_RECORD(ptr, MEMBLOCK, data), _LIBC_POOL_TAG);\n}\n\n__drv_when(return!=0, __drv_allocatesMem(ptr))\n__checkReturn\n__drv_maxIRQL(DISPATCH_LEVEL)\n__bcount_opt(size)\nvoid* \n__cdecl operator new(\n\t__in size_t size\n\t)\n{\n\treturn malloc(size);\n}\n\n__drv_maxIRQL(DISPATCH_LEVEL)\nvoid \n__cdecl operator delete(\n\t__inout void* ptr\n\t)\n{\n\tif (ptr)\n\t\tfree(ptr);\n}</pre> <p> another essential think, is to add implementation of calling ctors &#38; dtors, at loading / unloading drivers (allow creating singletons, &#8230;) : </p> <pre class=\"crayon-plain-tag\">EXTERN_C\nint\n__cdecl atexit(\n\t__in void(__cdecl *destructor)(void)\n\t)\n{\n\tif (!destructor)\n\t\treturn 0;\n\n\t//_kebreak();\n\tATEXIT_ENTRY* entry = new ATEXIT_ENTRY(destructor, g_pTopAtexitEntry);\n\tif (!entry)\n\t\treturn 0;\n\tg_pTopAtexitEntry = entry;\n\treturn 1;\n}\n\n#if defined(_IA64_) || defined(_AMD64_)\n#pragma section(\".CRT$XCA\",long,read)\n__declspec(allocate(\".CRT$XCA\")) void(*__ctors_begin__[1])(void) = { 0 };\n#pragma section(\".CRT$XCZ\",long,read)\n__declspec(allocate(\".CRT$XCZ\")) void(*__ctors_end__[1])(void) = { 0 };\n#pragma data_seg()\n#else\n#pragma data_seg(\".CRT$XCA\")\nvoid(*__ctors_begin__[1])(void) = { 0 };\n#pragma data_seg(\".CRT$XCZ\")\nvoid(*__ctors_end__[1])(void) = { 0 };\n#pragma data_seg()\n#endif\n\n#pragma data_seg(\".STL$A\")\nvoid(*___StlStartInitCalls__[1])(void) = { 0 };\n#pragma data_seg(\".STL$L\")\nvoid(*___StlEndInitCalls__[1])(void) = { 0 };\n#pragma data_seg(\".STL$M\")\nvoid(*___StlStartTerminateCalls__[1])(void) = { 0 };\n#pragma data_seg(\".STL$Z\")\nvoid(*___StlEndTerminateCalls__[1])(void) = { 0 };\n#pragma data_seg()\n\nEXTERN_C\nvoid\n__cdecl doexit(\n\t__in int /*code*/,\n\t__in int /*quick*/,\n\t__in int /*retcaller*/\n\t)\n{\n\tfor (ATEXIT_ENTRY* entry = g_pTopAtexitEntry; entry;)\n\t{\n\t\tATEXIT_ENTRY* next = entry-&#62;Next;\n\t\tdelete entry;\n\t\tentry = next;\n\t}\n}\n\nEXTERN_C\nint\n__cdecl _cinit(\n\t__in int\n\t)\n{\n\tfor (void(**ctor)(void) = __ctors_begin__ + 1;\n\t\tctor &#60; __ctors_end__;\n\t\tctor++)\n\t{\n\t\t(*ctor)();\n\t}\n\treturn 0;\n}</pre> <p> Ok, now it is good enough to use c++ in Kernel mode, and also usage of nice feature of std::unique_ptr. But when you attempt to use some boost::intrusive or std::shared_ptr you may encounter some <a href=\"http://www.osronline.com/showthread.cfm?link=250151\" target=\"_blank\">probems</a>! And this problemes are <a href=\"http://msdn.microsoft.com/en-us/library/windows/hardware/ff546823(v=vs.85).aspx\" target=\"_blank\">c++ E X C E P T I O N S</a> , on code project resides very good <a href=\"http://www.codeproject.com/Articles/22801/Drivers-Exceptions-and-C\" target=\"_blank\">article</a> for reading about c++ exceptions vs kernel. </p> \n <p> problem makers (vs 2013, c++ 11) : </p> \n<ul>\n<li>_CxxThrowException</li>\n<li>_wassert</li>\n<li>__CxxFrameHandler3</li>\n<li>some std friends (_Xbad_alloc, _Xlength_error, _Xout_of_range, _Syserror_map, _Winerror_map)</li>\n</ul>\n <p> so for first two, to avoid redefinition, is dummy solution in .asm : </p> <pre class=\"crayon-plain-tag\">.code\n\n_CxxThrowException proc\n\tint 3\n\tret\n_CxxThrowException endp\n\n_wassert proc\n\txor rax, rax\n\tret\n_wassert endp\n\nend</pre> <p> for others can it be done in similliar dummy way but in c++ : </p> <pre class=\"crayon-plain-tag\">EXTERN_C\n_CRTIMP \nEXCEPTION_DISPOSITION \n__CxxFrameHandler3(\n\t__in void* pExcept, // Information for this exception\n\t__in ULONG_PTR RN, // Dynamic information for this frame\n\t__in void* pContext, // Context info\n\t__in void* pDC // More dynamic info for this frame\n\t)\n{\n\tDbgBreakPoint();\n\treturn EXCEPTION_DISPOSITION::ExceptionNestedException;\n}\n\nnamespace std\n{\n\tvoid\n\t__cdecl _Xbad_alloc() \n\t{ \n\t\tDbgBreakPoint(); \n\t}\n...\n\n\tvoid \n\t__cdecl _Xout_of_range(\n\t\t__in char const*\n\t\t) \n\t{ \n\t\tDbgBreakPoint(); \n\t}\n...\n\n\tchar const* \n\t__cdecl _Winerror_map(\n\t\t__in int\n\t\t) \n\t{ \n\t\tDbgBreakPoint(); \n\t\treturn nullptr; \n\t}\n}</pre> <p> But remember, those are really dumb implementations, wich allows you to use c++ and some of nice c++ libraries (like std, boost), but you probably want to implement this methods correctly <span class=\"icon-emo-wink2\"/> </p> \n <p> Alltogether you can find .lib source codes (projects, etc. &#8230; vs2013) on my <a href=\"https://github.com/zer0mem/libc\" target=\"_blank\">github</a> </p> \n<ul>\n<li><em><strong>Part II. &#8211; Set up enviroment to cooperate (Visual Studio 2013 &#38; WDM driver)</strong></em></li>\n</ul>\n <p> Things what we need to do : </p> \n<ol>\n<li>link libc.lib to project</li>\n<li>add additional .lib to project (to cover f.e. functions like _hypot, .. )</li>\n<li>Set code generation, entry point, runtime  .. c++ and linker options mainly</li>\n</ol>\n <p> so lets finalize it : </p> <pre class=\"crayon-plain-tag\">linker/input\nadd dependecies : %(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)\\ntoskrnl.lib;$(DDK_LIB_PATH)\\hal.lib;$(DDK_LIB_PATH)\\wmilib.lib;\nifnore all def libs : Yes (/NODEFAULTLIB)\nigonere specific lib : libcmt.lib\n\nlinker/advanced\nEP : DriverEntry\nRnd Base : Yes (/DYNAMICBASE)\nDEP : Yes (/NXCOMPAT)\n\nlinker/cmd linde\n/INTEGRITYCHECK\n\n\nc++\nGeneral : \n$(SolutionDir);$(SolutionDir)/Common/;$(IntDir);$(VCInstallDir)/Include;%(AdditionalIncludeDirectories);\n\nCode generation:\nc++ exceptions : No\nruntime library: Multi-threaded (/MT)\nsecurity checks : Enable Security Check (/GS)\n\nlanguage : \nenable run-time type info : No (/GR-)\n\nprecompiled header (these is just optional ;) : \nCreate (/Yc)\ndrv_common.h\n\nadvanced (same, optinal)\ncalling convention : __fastcall (/Gr)\n\nall options\naditional options : clear this field and remove - \"/kernel %(ClCompile.AdditionalOptions)\"\n\n\nDriver signing : \nSign Mode : Test Sign\nTest Certificate : create test certificate</pre> <p> in libc.git project, i use <em>$(DDK_LIB_PATH)\\libcntpr.lib;</em> for including some additional functions (_hypot and friends&#8230;). And in next version of vs can be needed also another functions, and for this you should firstly find in .lib in <em>$(DDK_LIB_PATH) </em>and try to link it to project, or after that if nothing was found implement it by yourself &#8230; </p> \n <p> But important here, is to avoid linking usermode .dll into your kernel mode driver <span class=\"icon-emo-happy\"/> </p> \n <p> I also pushed on github <a href=\"https://github.com/zer0mem/KernelProject\" target=\"_blank\">KernelProject</a> PoC of usage of libc.git and new WDM driver for visual studio 2013 &#8211; (shared_ptr, unique_ptr, boost::intrusive::avltree). (i used also <a href=\"https://github.com/zer0mem/Common\" target=\"_blank\">Common</a> repo because of demonstrating on Vads, and usage of <a href=\"https://github.com/zer0mem/Common/blob/master/base/CppDriver.h\" target=\"_blank\">CCppDriver</a> class as &#8220;main&#8221; of driver) &#8211; Windows 8.1 Release is setup-ed configuration &#8211; platform, so you can try to set-up Windows 7.1 release for sucessfully running also Vad test (because in <a href=\"https://github.com/zer0mem/Common/blob/master/undoc/Undoc.hpp\" target=\"_blank\">undoc</a> is setuped constans just for win7sp1 and win7, both x64) <span class=\"icon-emo-tongue\"/> </p> \n <p> &#160; </p> \n<div class=\"centerobj\">[ <a title=\"PoC sources, enjoy\" href=\"https://github.com/zer0mem/libc\" target=\"_blank\">some SRC&#8217;s available on github</a> ]</div>\n","descriptionType":"html","publishedDate":"Tue, 06 May 2014 10:57:58 +0000","feedId":30080,"bgimg":"","linkMd5":"04254be72b93af5d05531ef16b0a63b8","bgimgJsdelivr":"","metaImg":"","author":"zer0mem","publishedOrCreatedDate":1647268184046}],"record":{"createdTime":"2022-03-14 22:29:44","updatedTime":"2022-03-14 22:29:44","feedId":30080,"fetchDate":"Mon, 14 Mar 2022 14:29:44 +0000","fetchMs":4749,"handleMs":22773,"totalMs":27651,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"af6ca12eefe249e94a3f077d15d7c168","hostName":"europe69*","requestId":"a7faf73fc7dc478b9b90fbf18dce2b06_30080","contentType":"text/xml; charset=UTF-8","totalBytes":0,"bgimgsTotal":0,"bgimgsGithubTotal":0,"articlesImgsTotal":0,"articlesImgsGithubTotal":0,"successGithubMap":{},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:48:45","updatedTime":"2021-09-28 02:08:13","id":30080,"name":"@zer0mem","url":"http://www.zer0mem.sk/?feed=rss2","subscriber":108,"website":null,"icon":"http://www.zer0mem.sk/favicon.ico","icon_jsdelivr":null,"description":"The opinions expressed in this blog are my own and do not represent those of my current employer","weekly":null,"link":"http://www.zer0mem.sk"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1647268156413,"total":0,"statList":[{"spend":4860,"msg":"获取xml内容"},{"spend":22773,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":0,"msg":"正文链接上传到cdn"}]},"extra5":0,"extra6":0,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{},"extra12ImgCdnSuccessResultVector":[],"successGithubMap":{},"failGithubMap":{}}