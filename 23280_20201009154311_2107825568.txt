{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-09 23:42:43","updatedTime":"2020-10-09 23:42:43","title":"图解九种常见的设计模式","link":"https://segmentfault.com/a/1190000030850326","description":"<p>在软件工程中，设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。根据模式的目的来划分的话，GoF（Gang of Four）设计模式可以分为以下 3 种类型：</p>\n<p><img src=\"https://segmentfault.com/img/bVcfO3r\" alt=\"image\" title=\"image\" /></p>\n<p>1、创建型模式：用来描述 “如何创建对象”，它的主要特点是 “将对象的创建和使用分离”。包括单例、原型、工厂方法、抽象工厂和建造者 5 种模式。</p>\n<p>2、结构型模式：用来描述如何将类或对象按照某种布局组成更大的结构。包括代理、适配器、桥接、装饰、外观、享元和组合 7 种模式。</p>\n<p>3、行为型模式：用来识别对象之间的常用交流模式以及如何分配职责。包括模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录和解释器 11 种模式。</p>\n<p>接下来阿宝哥将结合一些生活中的场景并通过精美的配图，来向大家介绍 9 种常用的设计模式。</p>\n<h3>一、建造者模式</h3>\n<p>建造者模式（Builder Pattern）将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p>\n<p>一辆小汽车 🚗 通常由 <strong>发动机、底盘、车身和电气设备</strong> 四大部分组成。汽车电气设备的内部构造很复杂，简单起见，我们只考虑三个部分：引擎、底盘和车身。</p>\n<p><img src=\"https://segmentfault.com/img/bVcfQ3q\" alt=\"image\" title=\"image\" /></p>\n<p>在现实生活中，小汽车也是由不同的零部件组装而成，比如上图中我们把小汽车分成引擎、底盘和车身三大部分。下面我们来看一下如何使用建造者模式来造车子。</p>\n<h5>1.1 实现代码</h5>\n<pre><code class=\"typescript\">class Car {\n  constructor(\n    public engine: string,\n    public chassis: string, \n    public body: string\n  ) {}\n}\n\nclass CarBuilder {\n  engine!: string; // 引擎\n  chassis!: string; // 底盘\n  body!: string; // 车身\n\n  addChassis(chassis: string) {\n    this.chassis = chassis;\n    return this;\n  }\n\n  addEngine(engine: string) {\n    this.engine = engine;\n    return this;\n  }\n\n  addBody(body: string) {\n    this.body = body;\n    return this;\n  }\n\n  build() {\n    return new Car(this.engine, this.chassis, this.body);\n  }\n}</code></pre>\n<p>在以上代码中，我们定义一个 <code>CarBuilder</code> 类，并提供了 <code>addChassis</code>、<code>addEngine</code> 和 <code>addBody</code> 3 个方法用于组装车子的不同部位，当车子的 3 个部分都组装完成后，调用 <code>build</code> 方法就可以开始造车。</p>\n<h5>1.2 使用示例</h5>\n<pre><code class=\"typescript\">const car = new CarBuilder()\n  .addEngine('v12')\n  .addBody('镁合金')\n  .addChassis('复合材料')\n  .build();</code></pre>\n<h5>1.3 应用场景及案例</h5>\n<ul>\n <li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li>\n <li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li>\n <li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>\n <li><a href=\"https://github.com/dresende/node-sql-query\" rel=\"nofollow noreferrer\">Github - node-sql-query</a>：<a href=\"https://github.com/dresende/node-sql-query\" rel=\"nofollow noreferrer\">https://github.com/dresende/n...</a></li>\n</ul>\n<h3>二、工厂模式</h3>\n<p>在现实生活中，工厂是负责生产产品的，比如牛奶、面包或礼物等，这些产品满足了我们日常的生理需求。</p>\n<p><img src=\"https://segmentfault.com/img/bVbK5q2\" alt=\"image\" title=\"image\" /></p>\n<p>在众多设计模式当中，有一种被称为工厂模式的设计模式，它提供了创建对象的最佳方式。工厂模式可以分为：<strong>简单工厂模式、工厂方法模式和抽象工厂模式</strong>。</p>\n<h4>2.1 简单工厂</h4>\n<p>简单工厂模式又叫 <strong>静态方法模式</strong>，因为工厂类中定义了一个静态方法用于创建对象。简单工厂让使用者不用知道具体的参数就可以创建出所需的 ”产品“ 类，即使用者可以直接消费产品而不需要知道产品的具体生产细节。</p>\n<p><img src=\"https://segmentfault.com/img/bVbMu1o\" alt=\"image\" title=\"image\" /></p>\n<p>在上图中，阿宝哥模拟了用户购车的流程，小王和小秦分别向 BMW 工厂订购了 BMW730 和 BMW840 型号的车型，接着工厂会先判断用户选择的车型，然后按照对应的模型进行生产并在生产完成后交付给用户。</p>\n<p>下面我们来看一下如何使用简单工厂来描述 BMW 工厂生产指定型号车子的过程。</p>\n<h5>2.1.1 实现代码</h5>\n<pre><code class=\"typescript\">abstract class BMW {\n  abstract run(): void;\n}\n\nclass BMW730 extends BMW {\n  run(): void {\n    console.log(\"BMW730 发动咯\");\n  }\n}\n\nclass BMW840 extends BMW {\n  run(): void {\n    console.log(\"BMW840 发动咯\");\n  }\n}\n\nclass BMWFactory {\n  public static produceBMW(model: \"730\" | \"840\"): BMW {\n    if (model === \"730\") {\n      return new BMW730();\n    } else {\n      return new BMW840();\n    }\n  }\n}</code></pre>\n<p>在以上代码中，我们定义一个 <code>BMWFactory</code> 类，该类提供了一个静态的 <code>produceBMW()</code> 方法，用于根据不同的模型参数来创建不同型号的车子。</p>\n<h5>2.1.2 使用示例</h5>\n<pre><code class=\"typescript\">const bmw730 = BMWFactory.produceBMW(\"730\");\nconst bmw840 = BMWFactory.produceBMW(\"840\");\n\nbmw730.run();\nbmw840.run();</code></pre>\n<h5>2.1.3 应用场景</h5>\n<ul>\n <li>工厂类负责创建的对象比较少：由于创建的对象比较少，不会造成工厂方法中业务逻辑过于复杂。</li>\n <li>客户端只需知道传入工厂类静态方法的参数，而不需要关心创建对象的细节。</li>\n</ul>\n<h4>2.2 工厂方法</h4>\n<p>工厂方法模式（Factory Method Pattern）又称为工厂模式，也叫多态工厂（Polymorphic Factory）模式，它属于类创建型模式。</p>\n<p>在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象， <strong>这样做的目的是将产品类的实例化操作延迟到工厂子类中完成</strong>，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>\n<p><img src=\"https://segmentfault.com/img/bVbK5q5\" alt=\"image\" title=\"image\" /></p>\n<p>在上图中，阿宝哥模拟了用户购车的流程，小王和小秦分别向 BMW 730 和 BMW 840 工厂订购了 BMW730 和 BMW840 型号的车子，接着工厂按照对应的模型进行生产并在生产完成后交付给用户。</p>\n<p>同样，我们来看一下如何使用工厂方法来描述 BMW 工厂生产指定型号车子的过程。</p>\n<h5>2.2.1 实现代码</h5>\n<pre><code class=\"typescript\">abstract class BMWFactory {\n  abstract produceBMW(): BMW;\n}\n\nclass BMW730Factory extends BMWFactory {\n  produceBMW(): BMW {\n    return new BMW730();\n  }\n}\n\nclass BMW840Factory extends BMWFactory {\n  produceBMW(): BMW {\n    return new BMW840();\n  }\n}</code></pre>\n<p>在以上代码中，我们分别创建了 <code>BMW730Factory</code> 和 <code>BMW840Factory</code> 两个工厂类，然后使用这两个类的实例来生产不同型号的车子。</p>\n<h5>2.2.2 使用示例</h5>\n<pre><code class=\"typescript\">const bmw730Factory = new BMW730Factory();\nconst bmw840Factory = new BMW840Factory();\n\nconst bmw730 = bmw730Factory.produceBMW();\nconst bmw840 = bmw840Factory.produceBMW();\n\nbmw730.run();\nbmw840.run();</code></pre>\n<h5>2.2.3 应用场景</h5>\n<ul>\n <li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li>\n <li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>\n</ul>\n<blockquote>\n 继续阅读：\n <a href=\"https://mp.weixin.qq.com/s/ODSjqmsb1cnjQwwjhS5AOg\" rel=\"nofollow noreferrer\">Typescript 设计模式之工厂方法</a>\n</blockquote>\n<h4>2.3 抽象工厂</h4>\n<p>抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p>\n<p>在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。 <strong>但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</strong></p>\n<p><img src=\"https://segmentfault.com/img/bVbK5q4\" alt=\"image\" title=\"image\" /></p>\n<p>在上图中，阿宝哥模拟了用户购车的流程，小王向 BMW 工厂订购了 BMW730，工厂按照 730 对应的模型进行生产并在生产完成后交付给小王。而小秦向同一个 BMW 工厂订购了 BMW840，工厂按照 840 对应的模型进行生产并在生产完成后交付给小秦。</p>\n<p>下面我们来看一下如何使用抽象工厂来描述上述的购车过程。</p>\n<h5>2.3.1 实现代码</h5>\n<pre><code class=\"typescript\">abstract class BMWFactory {\n  abstract produce730BMW(): BMW730;\n  abstract produce840BMW(): BMW840;\n}\n\nclass ConcreteBMWFactory extends BMWFactory {\n  produce730BMW(): BMW730 {\n    return new BMW730();\n  }\n\n  produce840BMW(): BMW840 {\n    return new BMW840();\n  }\n}</code></pre>\n<h5>2.3.2 使用示例</h5>\n<pre><code class=\"typescript\">const bmwFactory = new ConcreteBMWFactory();\n\nconst bmw730 = bmwFactory.produce730BMW();\nconst bmw840 = bmwFactory.produce840BMW();\n\nbmw730.run();\nbmw840.run();</code></pre>\n<h5>2.3.3 应用场景</h5>\n<ul>\n <li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>\n <li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>\n <li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>\n</ul>\n<blockquote>\n 继续阅读：\n <a href=\"https://mp.weixin.qq.com/s/ppxWe3ML9TrOCe_ympXdIQ\" rel=\"nofollow noreferrer\">创建对象的最佳方式是什么？</a>\n</blockquote>\n<h3>三、单例模式</h3>\n<p>单例模式（Singleton Pattern）是一种常用的模式，有一些对象我们往往只需要一个，比如全局缓存、浏览器中的 window 对象等。单例模式用于保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>\n<p><img src=\"https://segmentfault.com/img/bVcgWLd\" alt=\"image\" title=\"image\" /></p>\n<p>在上图中，阿宝哥模拟了借车的流程，小王临时有急事找阿宝哥借车子，阿宝哥家的车子刚好没用，就借给小王了。当天，小秦也需要用车子，也找阿宝哥借车，因为阿宝哥家里只有一辆车子，所以就没有车可借了。</p>\n<p>对于车子来说，它虽然给生活带来了很大的便利，但养车也需要一笔不小的费用（车位费、油费和保养费等），所以阿宝哥家里只有一辆车子。在开发软件系统时，如果遇到创建对象时耗时过多或耗资源过多，但又经常用到的对象，我们就可以考虑使用单例模式。</p>\n<p>下面我们来看一下如何使用 TypeScript 来实现单例模式。</p>\n<h5>3.1 实现代码</h5>\n<pre><code class=\"typescript\">class Singleton {\n  // 定义私有的静态属性，来保存对象实例\n  private static singleton: Singleton;\n  private constructor() {}\n\n  // 提供一个静态的方法来获取对象实例\n  public static getInstance(): Singleton {\n    if (!Singleton.singleton) {\n      Singleton.singleton = new Singleton();\n    }\n    return Singleton.singleton;\n  }\n}</code></pre>\n<h5>3.2 使用示例</h5>\n<pre><code class=\"typescript\">let instance1 = Singleton.getInstance();\nlet instance2 = Singleton.getInstance();\n\nconsole.log(instance1 === instance2); // true</code></pre>\n<h5>3.3 应用场景</h5>\n<ul>\n <li>需要频繁实例化然后销毁的对象。</li>\n <li>创建对象时耗时过多或耗资源过多，但又经常用到的对象。</li>\n <li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</li>\n</ul>\n<blockquote>\n 继续阅读：\n <a href=\"https://mp.weixin.qq.com/s/nr20pZzRPSph42mK8F_zHQ\" rel=\"nofollow noreferrer\">TypeScript 设计模式之单例模式</a>\n</blockquote>\n<h3>四、适配器模式</h3>\n<p>在实际生活中，也存在适配器的使用场景，比如：港式插头转换器、电源适配器和 USB 转接口。<strong>而在软件工程中，适配器模式的作用是解决两个软件实体间的接口不兼容的问题。</strong> 使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体就可以一起工作。</p>\n<p><img src=\"https://segmentfault.com/img/bVbCDtT\" alt=\"image\" title=\"image\" /></p>\n<h5>4.1 实现代码</h5>\n<pre><code class=\"typescript\">interface Logger {\n  info(message: string): Promise&lt;void&gt;;\n}\n\ninterface CloudLogger {\n  sendToServer(message: string, type: string): Promise&lt;void&gt;;\n}\n\nclass AliLogger implements CloudLogger {\n  public async sendToServer(message: string, type: string): Promise&lt;void&gt; {\n    console.info(message);\n    console.info('This Message was saved with AliLogger');\n  }\n}\n\nclass CloudLoggerAdapter implements Logger {\n  protected cloudLogger: CloudLogger;\n\n  constructor (cloudLogger: CloudLogger) {\n    this.cloudLogger = cloudLogger;\n  }\n\n  public async info(message: string): Promise&lt;void&gt; {\n    await this.cloudLogger.sendToServer(message, 'info');\n  }\n}\n\nclass NotificationService {\n  protected logger: Logger;\n  \n  constructor (logger: Logger) {    \n    this.logger = logger;\n  }\n\n  public async send(message: string): Promise&lt;void&gt; {\n    await this.logger.info(`Notification sended: ${message}`);\n  }\n}</code></pre>\n<p>在以上代码中，因为 <code>Logger</code> 和 <code>CloudLogger</code> 这两个接口不匹配，所以我们引入了 <code>CloudLoggerAdapter</code> 适配器来解决兼容性问题。</p>\n<h5>4.2 使用示例</h5>\n<pre><code class=\"typescript\">(async () =&gt; {\n  const aliLogger = new AliLogger();\n  const cloudLoggerAdapter = new CloudLoggerAdapter(aliLogger);\n  const notificationService = new NotificationService(cloudLoggerAdapter);\n  await notificationService.send('Hello semlinker, To Cloud');\n})();</code></pre>\n<h5>4.3 应用场景及案例</h5>\n<ul>\n <li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>\n <li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>\n <li><a href=\"https://github.com/ctimmerm/axios-mock-adapter\" rel=\"nofollow noreferrer\">Github - axios-mock-adapter</a>：<a href=\"https://github.com/ctimmerm/axios-mock-adapter\" rel=\"nofollow noreferrer\">https://github.com/ctimmerm/a...</a></li>\n</ul>\n<blockquote>\n 继续阅读：\n <a href=\"https://mp.weixin.qq.com/s/sxPtZrJQyObkblCOXTjxug\" rel=\"nofollow noreferrer\">TypeScript 设计模式之适配器模式</a>\n</blockquote>\n<h3>五、观察者模式 &amp; 发布订阅模式</h3>\n<h4>5.1 观察者模式</h4>\n<p>观察者模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p>\n<p>在观察者模式中有两个主要角色：Subject（主题）和 Observer（观察者）。</p>\n<p><img src=\"https://segmentfault.com/img/bVbLW2d\" alt=\"image\" title=\"image\" /></p>\n<p>在上图中，Subject（主题）就是阿宝哥的 TS 专题文章，而观察者就是小秦和小王。由于观察者模式支持简单的广播通信，当消息更新时，会自动通知所有的观察者。</p>\n<p>下面我们来看一下如何使用 TypeScript 来实现观察者模式。</p>\n<h5>5.1.1 实现代码</h5>\n<pre><code class=\"typescript\">interface Observer {\n  notify: Function;\n}\n\nclass ConcreteObserver implements Observer{\n  constructor(private name: string) {}\n\n  notify() {\n    console.log(`${this.name} has been notified.`);\n  }\n}\n\nclass Subject { \n  private observers: Observer[] = [];\n\n  public addObserver(observer: Observer): void {\n    console.log(observer, \"is pushed!\");\n    this.observers.push(observer);\n  }\n\n  public deleteObserver(observer: Observer): void {\n    console.log(\"remove\", observer);\n    const n: number = this.observers.indexOf(observer);\n    n != -1 &amp;&amp; this.observers.splice(n, 1);\n  }\n\n  public notifyObservers(): void {\n    console.log(\"notify all the observers\", this.observers);\n    this.observers.forEach(observer =&gt; observer.notify());\n  }\n}</code></pre>\n<h5>5.1.2 使用示例</h5>\n<pre><code class=\"typescript\">const subject: Subject = new Subject();\nconst xiaoQin = new ConcreteObserver(\"小秦\");\nconst xiaoWang = new ConcreteObserver(\"小王\");\nsubject.addObserver(xiaoQin);\nsubject.addObserver(xiaoWang);\nsubject.notifyObservers();\n\nsubject.deleteObserver(xiaoQin);\nsubject.notifyObservers();</code></pre>\n<h5>5.1.3 应用场景及案例</h5>\n<ul>\n <li>一个对象的行为依赖于另一个对象的状态。或者换一种说法，当被观察对象（目标对象）的状态发生改变时 ，会直接影响到观察对象的行为。</li>\n <li><a href=\"https://github.com/ReactiveX/rxjs/blob/master/src/internal/Subject.ts\" rel=\"nofollow noreferrer\">RxJS Subject</a>：<a href=\"https://github.com/ReactiveX/rxjs/blob/master/src/internal/Subject.ts\" rel=\"nofollow noreferrer\">https://github.com/ReactiveX/...</a></li>\n <li><a href=\"https://rxjs.dev/guide/subject\" rel=\"nofollow noreferrer\">RxJS Subject 文档</a>：<a href=\"https://rxjs.dev/guide/subject\" rel=\"nofollow noreferrer\">https://rxjs.dev/guide/subject</a></li>\n</ul>\n<blockquote>\n 继续阅读：\n <a href=\"https://mp.weixin.qq.com/s/XZVNfkuydrHQbkaOo-wxtw\" rel=\"nofollow noreferrer\">TypeScript 设计模式之观察者模式</a>\n</blockquote>\n<h4>5.2 发布订阅模式</h4>\n<p>在软件架构中，发布/订阅是一种消息范式，<strong>消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，然后分别发送给不同的订阅者。</strong> 同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在。</p>\n<p>在发布订阅模式中有三个主要角色：Publisher（发布者）、 Channels（通道）和 Subscriber（订阅者）。</p>\n<p><img src=\"https://segmentfault.com/img/bVbLW2i\" alt=\"image\" title=\"image\" /></p>\n<p>在上图中，Publisher（发布者）是阿宝哥，Channels（通道）中 Topic A 和 Topic B 分别对应于 TS 专题和 Deno 专题，而 Subscriber（订阅者）就是小秦、小王和小池。</p>\n<p>下面我们来看一下如何使用 TypeScript 来实现发布订阅模式。</p>\n<h5>5.2.1 实现代码</h5>\n<pre><code class=\"typescript\">type EventHandler = (...args: any[]) =&gt; any;\n\nclass EventEmitter {\n  private c = new Map&lt;string, EventHandler[]&gt;();\n\n  // 订阅指定的主题\n  subscribe(topic: string, ...handlers: EventHandler[]) {\n    let topics = this.c.get(topic);\n    if (!topics) {\n      this.c.set(topic, topics = []);\n    }\n    topics.push(...handlers);\n  }\n\n  // 取消订阅指定的主题\n  unsubscribe(topic: string, handler?: EventHandler): boolean {\n    if (!handler) {\n      return this.c.delete(topic);\n    }\n\n    const topics = this.c.get(topic);\n    if (!topics) {\n      return false;\n    }\n    \n    const index = topics.indexOf(handler);\n\n    if (index &lt; 0) {\n      return false;\n    }\n    topics.splice(index, 1);\n    if (topics.length === 0) {\n      this.c.delete(topic);\n    }\n    return true;\n  }\n\n  // 为指定的主题发布消息\n  publish(topic: string, ...args: any[]): any[] | null {\n    const topics = this.c.get(topic);\n    if (!topics) {\n      return null;\n    }\n    return topics.map(handler =&gt; {\n      try {\n        return handler(...args);\n      } catch (e) {\n        console.error(e);\n        return null;\n      }\n    });\n  }\n}</code></pre>\n<h5>5.2.2 使用示例</h5>\n<pre><code class=\"typescript\">const eventEmitter = new EventEmitter();\neventEmitter.subscribe(\"ts\", (msg) =&gt; console.log(`收到订阅的消息：${msg}`) );\n\neventEmitter.publish(\"ts\", \"TypeScript发布订阅模式\");\neventEmitter.unsubscribe(\"ts\");\neventEmitter.publish(\"ts\", \"TypeScript发布订阅模式\");</code></pre>\n<h5>5.2.3 应用场景</h5>\n<ul>\n <li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>\n <li>作为事件总线，来实现不同组件间或模块间的通信。</li>\n <li><a href=\"https://github.com/ustbhuangyi/better-scroll/blob/dev/packages/shared-utils/src/events.ts\" rel=\"nofollow noreferrer\">BetterScroll - EventEmitter</a>：<a href=\"https://github.com/ustbhuangyi/better-scroll/blob/dev/packages/shared-utils/src/events.ts\" rel=\"nofollow noreferrer\">https://github.com/ustbhuangy...</a></li>\n <li><a href=\"https://mp.weixin.qq.com/s/N4iw3bi0bxJ57J8EAp5ctQ\" rel=\"nofollow noreferrer\">EventEmitter 在插件化架构的应用</a>：<a href=\"https://mp.weixin.qq.com/s/N4iw3bi0bxJ57J8EAp5ctQ\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s/N4...</a></li>\n</ul>\n<blockquote>\n 继续阅读：\n <a href=\"https://mp.weixin.qq.com/s/NGrkTBIidrcxX-FvH0mSng\" rel=\"nofollow noreferrer\">如何优雅的实现消息通信？</a>\n</blockquote>\n<h3>六、策略模式</h3>\n<p>策略模式（Strategy Pattern）定义了一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活、可维护、可扩展。</p>\n<p><img src=\"https://segmentfault.com/img/bVcglbR\" alt=\"image\" title=\"image\" /></p>\n<p>目前在一些主流的 Web 站点中，都提供了多种不同的登录方式。比如账号密码登录、手机验证码登录和第三方登录。为了方便维护不同的登录方式，我们可以把不同的登录方式封装成不同的登录策略。</p>\n<p>下面我们来看一下如何使用策略模式来封装不同的登录方式。</p>\n<h5>6.1 实现代码</h5>\n<p>为了更好地理解以下代码，我们先来看一下对应的 UML 类图：</p>\n<p><img src=\"https://segmentfault.com/img/bVcgnhV\" alt=\"image\" title=\"image\" /></p>\n<pre><code class=\"typescript\">interface Strategy {\n  authenticate(...args: any): any;\n}\n\nclass Authenticator {\n  strategy: any;\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy: any) {\n    this.strategy = strategy;\n  }\n\n  authenticate(...args: any) {\n    if (!this.strategy) {\n      console.log('尚未设置认证策略');\n      return;\n    }\n    return this.strategy.authenticate(...args);\n  }\n}\n\nclass WechatStrategy implements Strategy {\n  authenticate(wechatToken: string) {\n    if (wechatToken !== '123') {\n      console.log('无效的微信用户');\n      return;\n    }\n    console.log('微信认证成功');\n  }\n}\n\nclass LocalStrategy implements Strategy {\n  authenticate(username: string, password: string) {\n    if (username !== 'abao' &amp;&amp; password !== '123') {\n      console.log('账号或密码错误');\n      return;\n    }\n    console.log('账号和密码认证成功');\n  }\n}</code></pre>\n<h5>6.2 使用示例</h5>\n<pre><code class=\"typescript\">const auth = new Authenticator();\n\nauth.setStrategy(new WechatStrategy());\nauth.authenticate('123456');\n\nauth.setStrategy(new LocalStrategy());\nauth.authenticate('abao', '123');</code></pre>\n<h5>6.3 应用场景及案例</h5>\n<ul>\n <li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li>\n <li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>\n <li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li>\n <li><a href=\"https://github.com/jaredhanson/passport-local\" rel=\"nofollow noreferrer\">Github - passport-local</a>：<a href=\"https://github.com/jaredhanson/passport-local\" rel=\"nofollow noreferrer\">https://github.com/jaredhanso...</a></li>\n <li><a href=\"https://github.com/jaredhanson/passport-oauth2\" rel=\"nofollow noreferrer\">Github - passport-oauth2</a>：<a href=\"https://github.com/jaredhanson/passport-oauth2\" rel=\"nofollow noreferrer\">https://github.com/jaredhanso...</a></li>\n <li><a href=\"https://github.com/vriad/zod/blob/master/src/types/string.ts\" rel=\"nofollow noreferrer\">Github - zod</a>：<a href=\"https://github.com/vriad/zod/blob/master/src/types/string.ts\" rel=\"nofollow noreferrer\">https://github.com/vriad/zod/...</a></li>\n</ul>\n<h3>七、职责链模式</h3>\n<p>职责链模式是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。</p>\n<p><img src=\"https://segmentfault.com/img/bVcgqnX\" alt=\"image\" title=\"image\" /></p>\n<p>在公司中不同的岗位拥有不同的职责与权限。以上述的请假流程为例，当阿宝哥请 1 天假时，只要组长审批就可以了，不需要流转到主管和总监。如果职责链上的某个环节无法处理当前的请求，若含有下个环节，则会把请求转交给下个环节来处理。</p>\n<p>在日常的软件开发过程中，对于职责链来说，一种常见的应用场景是中间件，下面我们来看一下如何利用职责链来处理请求。</p>\n<h5>7.1 实现代码</h5>\n<p>为了更好地理解以下代码，我们先来看一下对应的 UML 类图：</p>\n<p><img src=\"https://segmentfault.com/img/bVcgrCF\" alt=\"image\" title=\"image\" /></p>\n<pre><code class=\"typescript\">interface IHandler {\n  addMiddleware(h: IHandler): IHandler;\n  get(url: string, callback: (data: any) =&gt; void): void;\n}\n\nabstract class AbstractHandler implements IHandler {\n  next!: IHandler;\n  addMiddleware(h: IHandler) {\n    this.next = h;\n    return this.next;\n  }\n\n  get(url: string, callback: (data: any) =&gt; void) {\n    if (this.next) {\n      return this.next.get(url, callback);\n    }\n  }\n}\n\n// 定义Auth中间件\nclass Auth extends AbstractHandler {\n  isAuthenticated: boolean;\n  constructor(username: string, password: string) {\n    super();\n\n    this.isAuthenticated = false;\n    if (username === 'abao' &amp;&amp; password === '123') {\n      this.isAuthenticated = true;\n    }\n  }\n\n  get(url: string, callback: (data: any) =&gt; void) {\n    if (this.isAuthenticated) {\n      return super.get(url, callback);\n    } else {\n      throw new Error('Not Authorized');\n    }\n  }\n}\n\n// 定义Logger中间件\nclass Logger extends AbstractHandler {\n  get(url: string, callback: (data: any) =&gt; void) {\n    console.log('/GET Request to: ', url);\n    return super.get(url, callback);\n  }\n}\n\nclass Route extends AbstractHandler {\n  URLMaps: {[key: string]: any};\n  constructor() {\n    super();\n    this.URLMaps = {\n      '/api/todos': [{ title: 'learn ts' }, { title: 'learn react' }],\n      '/api/random': Math.random(),\n    };\n  }\n\n  get(url: string, callback: (data: any) =&gt; void) {\n    super.get(url, callback);\n\n    if (this.URLMaps.hasOwnProperty(url)) {\n      callback(this.URLMaps[url]);\n    }\n  }\n}</code></pre>\n<h5>7.2 使用示例</h5>\n<pre><code class=\"typescript\">const route = new Route();\nroute.addMiddleware(new Auth('abao', '123')).addMiddleware(new Logger());\n\nroute.get('/api/todos', data =&gt; {\n  console.log(JSON.stringify({ data }, null, 2));\n});\n\nroute.get('/api/random', data =&gt; {\n  console.log(data);\n});</code></pre>\n<h5>7.3 应用场景</h5>\n<ul>\n <li>可处理一个请求的对象集合应被动态指定。</li>\n <li>想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li>\n <li>有多个对象可以处理一个请求，哪个对象处理该请求运行时自动确定，客户端只需要把请求提交到链上即可。</li>\n</ul>\n<h3>八、模板方法模式</h3>\n<p>模板方法模式由两部分结构组成：抽象父类和具体的实现子类。<strong>通常在抽象父类中封装了子类的算法框架，也包括实现一些公共方法以及封装子类中所有方法的执行顺序</strong>。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p>\n<p><img src=\"https://segmentfault.com/img/bVcgt1W\" alt=\"image\" title=\"image\" /></p>\n<p>在上图中，阿宝哥通过使用不同的解析器来分别解析 CSV 和 Markup 文件。虽然解析的是不同的类型的文件，但文件的处理流程是一样的。这里主要包含读取文件、解析文件和打印数据三个步骤。针对这个场景，我们就可以引入模板方法来封装以上三个步骤的处理顺序。</p>\n<p>下面我们来看一下如何使用模板方法来实现上述的解析流程。</p>\n<h5>8.1 实现代码</h5>\n<p>为了更好地理解以下代码，我们先来看一下对应的 UML 类图：</p>\n<p><img src=\"https://segmentfault.com/img/bVcgvri\" alt=\"image\" title=\"image\" /></p>\n<pre><code class=\"typescript\">import fs from 'fs';\n\nabstract class DataParser {\n  data: string = '';\n  out: any = null;\n\n  // 这就是所谓的模板方法\n  parse(pathUrl: string) {\n    this.readFile(pathUrl);\n    this.doParsing();\n    this.printData();\n  }\n\n  readFile(pathUrl: string) {\n    this.data = fs.readFileSync(pathUrl, 'utf8');\n  }\n\n  abstract doParsing(): void;\n  \n  printData() {\n    console.log(this.out);\n  }\n}\n\nclass CSVParser extends DataParser {\n  doParsing() {\n    this.out = this.data.split(',');\n  }\n}\n\nclass MarkupParser extends DataParser {\n  doParsing() {\n    this.out = this.data.match(/&lt;\\w+&gt;.*&lt;\\/\\w+&gt;/gim);\n  }\n}</code></pre>\n<h5>8.2 使用示例</h5>\n<pre><code class=\"typescript\">const csvPath = './data.csv';\nconst mdPath = './design-pattern.md';\n\nnew CSVParser().parse(csvPath);\nnew MarkupParser().parse(mdPath);</code></pre>\n<h5>8.3 应用场景</h5>\n<ul>\n <li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>\n <li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li>\n</ul>\n<h3>九、参考资源</h3>\n<ul>\n <li><a href=\"https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA\" rel=\"nofollow noreferrer\">维基百科 - 设计模式</a>)</li>\n <li><a href=\"http://c.biancheng.net/design_pattern/\" rel=\"nofollow noreferrer\">Java设计模式：23种设计模式全面解析</a></li>\n <li><a href=\"https://dev.to/anuraghazra/design-patterns-everyday-53m0\" rel=\"nofollow noreferrer\">Design Patterns Everyday</a></li>\n</ul>\n<h3>十、推荐阅读</h3>\n<ul>\n <li><a href=\"http://www.semlinker.com/deno-quickstart/\" rel=\"nofollow noreferrer\">了不起的 Deno 入门篇</a></li>\n <li><a href=\"http://www.semlinker.com/deno-in-action/\" rel=\"nofollow noreferrer\">了不起的 Deno 实战教程</a></li>\n <li><a href=\"http://www.semlinker.com/you-dont-know-blob/\" rel=\"nofollow noreferrer\">你不知道的 Blob</a></li>\n <li><a href=\"http://www.semlinker.com/you-dont-know-weakmap/\" rel=\"nofollow noreferrer\">你不知道的 WeakMap</a></li>\n</ul>","descriptionType":"html","publishedDate":"Fri, 09 Oct 2020 08:13:48 +0000","feedId":23280,"bgimg":"https://segmentfault.com/img/bVcfO3r","linkMd5":"578419221cd55cbd8864d169e5e5213f","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn88@2020_5/2020/10/09/15-42-59-554_92d6d16562c698e2.webp","destWidth":800,"destHeight":264,"sourceBytes":79444,"destBytes":79444,"author":"阿宝哥","articleImgCdnMap":{"https://segmentfault.com/img/bVcfO3r":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn88@2020_5/2020/10/09/15-42-59-554_92d6d16562c698e2.webp","https://segmentfault.com/img/bVcfQ3q":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn40@2020_5/2020/10/09/15-43-03-635_dd1b61671b879bda.webp","https://segmentfault.com/img/bVbK5q2":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn26@2020_6/2020/10/09/15-43-06-331_13d097ff607bbc49.webp","https://segmentfault.com/img/bVbMu1o":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn96@2020_4/2020/10/09/15-43-10-319_5b66d092ecae1af4.webp","https://segmentfault.com/img/bVbK5q5":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn34@2020_3/2020/10/09/15-43-07-423_6b375fb8f805f0e0.webp","https://segmentfault.com/img/bVbK5q4":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn30@2020_1/2020/10/09/15-43-06-010_86ca3f478a72ec4a.webp","https://segmentfault.com/img/bVcgWLd":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn15@2020_5/2020/10/09/15-43-05-569_5503451204261295.webp","https://segmentfault.com/img/bVbCDtT":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn6@2020_2/2020/10/09/15-43-09-019_7372cefbe8143c9a.webp","https://segmentfault.com/img/bVbLW2d":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn23@2020_5/2020/10/09/15-43-05-955_7f2d6ccf06537d8e.webp","https://segmentfault.com/img/bVbLW2i":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn20@2020_4/2020/10/09/15-43-03-909_8490036c74a0a300.webp","https://segmentfault.com/img/bVcglbR":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn47@2020_6/2020/10/09/15-43-05-690_cfe9e1c95f736b09.webp","https://segmentfault.com/img/bVcgnhV":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn44@2020_2/2020/10/09/15-43-05-730_315a8ab747fa4d5b.webp","https://segmentfault.com/img/bVcgqnX":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn3@2020_2/2020/10/09/15-43-04-367_4bb09a82f28e1bba.webp","https://segmentfault.com/img/bVcgrCF":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn99@2020_2/2020/10/09/15-43-03-714_84bbd7282f33d5de.webp","https://segmentfault.com/img/bVcgt1W":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn52@2020_1/2020/10/09/15-43-04-241_549cfc26dcee4241.webp","https://segmentfault.com/img/bVcgvri":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn11@2020_1/2020/10/09/15-43-08-257_2aea5b02596a4a68.webp"},"publishedOrCreatedDate":1602258163464}],"record":{"createdTime":"2020-10-09 23:42:43","updatedTime":"2020-10-09 23:42:43","feedId":23280,"fetchDate":"Fri, 09 Oct 2020 15:42:43 +0000","fetchMs":52513,"handleMs":14308,"totalMs":95588,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"40ace73c106547fe13d820d5a8d040ba","hostName":"us-020*","requestId":"a2ee3d02b00e40cfb1689fe7fd4cab16_23280","contentType":"application/atom+xml; charset=UTF-8","totalBytes":571196,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":16,"articlesImgsGithubTotal":16,"successGithubMap":{"myreaderx7":1,"myreaderx15":1,"myreaderx27":1,"myreaderx16":1,"myreaderx6":1,"myreaderx4":1,"myreaderx11":1,"myreaderx3":1,"myreaderx33":1,"myreaderx2":1,"myreaderx1":1,"myreaderx24":1,"myreaderx30":1,"myreaderx5oss":1,"myreaderx18":1,"myreaderx19":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:29:58","updatedTime":"2020-09-07 13:26:29","id":23280,"name":"SegmentFault 最新的文章","url":"https://segmentfault.com/feeds/blogs","subscriber":142,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"https://segmentfault.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":79444,"tmpBodyImgCdnBytes":491752,"tmpBgImgCdnBytes":0,"extra4":{"start":1602258095627,"total":0,"statList":[{"spend":53542,"msg":"获取xml内容"},{"spend":14308,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":1,"msg":"修正封面图上传失败重新上传"},{"spend":10659,"msg":"正文链接上传到cdn"}]},"extra5":16,"extra6":16,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-032.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-021.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe63.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-024.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-011.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-25.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe21.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-036.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-033.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-004.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe67.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-51.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-008.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-029.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-012.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcfO3r","sourceStatusCode":200,"destWidth":800,"destHeight":264,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn88@2020_5/2020/10/09/15-42-59-554_92d6d16562c698e2.webp","sourceBytes":79444,"destBytes":79444,"feedId":23280,"totalSpendMs":4478,"convertSpendMs":0,"createdTime":"2020-10-09 23:42:56","host":"us-029*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f,578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"77.6 KB","destSize":"77.6 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcfQ3q","sourceStatusCode":200,"destWidth":800,"destHeight":198,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn40@2020_5/2020/10/09/15-43-03-635_dd1b61671b879bda.webp","sourceBytes":30930,"destBytes":30930,"feedId":23280,"totalSpendMs":3914,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"europe-25*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"30.2 KB","destSize":"30.2 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcgrCF","sourceStatusCode":200,"destWidth":800,"destHeight":464,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn99@2020_2/2020/10/09/15-43-03-714_84bbd7282f33d5de.webp","sourceBytes":38500,"destBytes":38500,"feedId":23280,"totalSpendMs":4223,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"europe67*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"37.6 KB","destSize":"37.6 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLW2i","sourceStatusCode":200,"destWidth":800,"destHeight":321,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn20@2020_4/2020/10/09/15-43-03-909_8490036c74a0a300.webp","sourceBytes":29462,"destBytes":29462,"feedId":23280,"totalSpendMs":4323,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"europe21*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"28.8 KB","destSize":"28.8 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcgqnX","sourceStatusCode":200,"destWidth":800,"destHeight":344,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn3@2020_2/2020/10/09/15-43-04-367_4bb09a82f28e1bba.webp","sourceBytes":39166,"destBytes":39166,"feedId":23280,"totalSpendMs":4640,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"us-032*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"38.2 KB","destSize":"38.2 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcgt1W","sourceStatusCode":200,"destWidth":800,"destHeight":277,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn52@2020_1/2020/10/09/15-43-04-241_549cfc26dcee4241.webp","sourceBytes":34750,"destBytes":34750,"feedId":23280,"totalSpendMs":4581,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"us-029*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"33.9 KB","destSize":"33.9 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcgWLd","sourceStatusCode":200,"destWidth":800,"destHeight":317,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn15@2020_5/2020/10/09/15-43-05-569_5503451204261295.webp","sourceBytes":27844,"destBytes":27844,"feedId":23280,"totalSpendMs":5855,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"us-008*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"27.2 KB","destSize":"27.2 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcglbR","sourceStatusCode":200,"destWidth":800,"destHeight":410,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn47@2020_6/2020/10/09/15-43-05-690_cfe9e1c95f736b09.webp","sourceBytes":21956,"destBytes":21956,"feedId":23280,"totalSpendMs":5942,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"us-51*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"21.4 KB","destSize":"21.4 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLW2d","sourceStatusCode":200,"destWidth":800,"destHeight":425,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn23@2020_5/2020/10/09/15-43-05-955_7f2d6ccf06537d8e.webp","sourceBytes":28624,"destBytes":28624,"feedId":23280,"totalSpendMs":6212,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"us-012*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"28 KB","destSize":"28 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK5q4","sourceStatusCode":200,"destWidth":800,"destHeight":392,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn30@2020_1/2020/10/09/15-43-06-010_86ca3f478a72ec4a.webp","sourceBytes":42778,"destBytes":42778,"feedId":23280,"totalSpendMs":6440,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"us-024*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"41.8 KB","destSize":"41.8 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcgnhV","sourceStatusCode":200,"destWidth":800,"destHeight":312,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn44@2020_2/2020/10/09/15-43-05-730_315a8ab747fa4d5b.webp","sourceBytes":33064,"destBytes":33064,"feedId":23280,"totalSpendMs":6346,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"europe63*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"32.3 KB","destSize":"32.3 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK5q2","sourceStatusCode":200,"destWidth":800,"destHeight":285,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn26@2020_6/2020/10/09/15-43-06-331_13d097ff607bbc49.webp","sourceBytes":27158,"destBytes":27158,"feedId":23280,"totalSpendMs":6611,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"us-036*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"26.5 KB","destSize":"26.5 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbK5q5","sourceStatusCode":200,"destWidth":800,"destHeight":386,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn34@2020_3/2020/10/09/15-43-07-423_6b375fb8f805f0e0.webp","sourceBytes":45396,"destBytes":45396,"feedId":23280,"totalSpendMs":7709,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"us-011*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"44.3 KB","destSize":"44.3 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcgvri","sourceStatusCode":200,"destWidth":800,"destHeight":419,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn11@2020_1/2020/10/09/15-43-08-257_2aea5b02596a4a68.webp","sourceBytes":28720,"destBytes":28720,"feedId":23280,"totalSpendMs":8607,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"us-021*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"28 KB","destSize":"28 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbCDtT","sourceStatusCode":200,"destWidth":800,"destHeight":362,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn6@2020_2/2020/10/09/15-43-09-019_7372cefbe8143c9a.webp","sourceBytes":19718,"destBytes":19718,"feedId":23280,"totalSpendMs":9284,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"us-033*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"19.3 KB","destSize":"19.3 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbMu1o","sourceStatusCode":200,"destWidth":800,"destHeight":389,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn96@2020_4/2020/10/09/15-43-10-319_5b66d092ecae1af4.webp","sourceBytes":43686,"destBytes":43686,"feedId":23280,"totalSpendMs":10616,"convertSpendMs":0,"createdTime":"2020-10-09 23:43:00","host":"us-004*","referer":"https://segmentfault.com/a/1190000030850326","linkMd5ListStr":"578419221cd55cbd8864d169e5e5213f","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"42.7 KB","destSize":"42.7 KB","compressRate":"100%"}],"successGithubMap":{"myreaderx7":1,"myreaderx15":1,"myreaderx27":1,"myreaderx16":1,"myreaderx6":1,"myreaderx4":1,"myreaderx11":1,"myreaderx3":1,"myreaderx33":1,"myreaderx2":1,"myreaderx1":1,"myreaderx24":1,"myreaderx30":1,"myreaderx5oss":1,"myreaderx18":1,"myreaderx19":1},"failGithubMap":{}}