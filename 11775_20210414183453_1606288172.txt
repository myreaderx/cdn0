{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2021-04-15 02:34:11","updatedTime":"2021-04-15 02:34:11","title":"Mutation Testing","link":"http://feedproxy.google.com/~r/blogspot/RLXA/~3/LbIQe4Pahdg/mutation-testing.html","description":"<style>  .code-reserved {     color: #9c27b0;   }   .code-method,   .code-attribute {     color: #3367d6;   }   .code-string {     color: #0f9d58;   }   .code-numerical {     color: #c53929;   }   .code-changed-added {     background-color: #d9ead3;     border: 1px solid green;   }   .code-changed-removed {     background-color: #f4cccc;     border: 1px solid red;   } </style> By Goran Petrovic<div><br /></div><h2 style=\"text-align: left;\">History  </h2><div><br /></div><div>It’s been a long-standing tradition of my team to organize hackathons twice a year. In weeks prior to the hackathon, the team gathers and brainstorms ideas for projects, ranging from improving the testing infrastructure or an existing process, to trying out a wild idea they’ve had for some time. Just before the hackathon, the team rates the accumulated ideas on a coolness-impact scale: how much fun does a project sound vs. how impactful could it potentially be; while impact is important, for hackathons, fun is non-negotiable. Then, engineers who are excited to work on some of the proposed projects subscribe and form teams. It was no different in the cold winter of 2013, where among the plethora of cool and wild ideas, one was to prototype <b>Mutation testing.</b></div><div><br /></div><div><br /></div><div>For those who are not familiar with it, mutation testing is a method of evaluating test quality by injecting bugs into the code and seeing whether the tests detect the fault or not. The more injected bugs the tests catch, the better they are. Here’s an example:</div><div><br /></div><div><br /></div><div>Negating the <i>if</i> condition.</div><div><br /></div>  <div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\"><span class=\"code-reserved\">def</span> checkout(cart):<br />  <span class=\"code-reserved\">if <span class=\"code-changed-added\">not</span></span> cart.items:<br />    <span class=\"code-reserved\">throw</span> <span class=\"code-method\">Error</span>(<span class=\"code-string\">\"cart empty\"</span>)<br />  <span class=\"code-reserved\">return</span> checkout_internal(cart)</span></pre></td>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\"><span class=\"code-reserved\">def</span> checkout(cart):<br />  <span class=\"code-reserved\">if</span> cart.items:<br />    <span class=\"code-reserved\">throw</span> <span class=\"code-method\">Error</span>(<span class=\"code-string\">\"cart empty\"</span>)<br />  <span class=\"code-reserved\">return</span> checkout_internal(cart)</span></pre></td></tr>   </tbody></table><br /></div>   If a test fails, we say it kills the mutant, and if no tests fail, we say that the mutant is alive.<div><br /></div><div><br /></div><div><div>By the end of the hackathon, mutagenesis was implemented for C++ and Python, and a prototype was born: a shell script that evaluates generated mutants in a diff (pull request) and textually reports live mutants in the files in the diff. A year passed with no work done on the project, before I started to work on it in my <a href=\"https://en.wikipedia.org/wiki/20%25_Project\">20% time</a>. I had no idea what Mutation testing was at the time, so I researched and read papers on the topic, and collected lots of ideas on what I should focus on.</div></div><div><br /></div><div><br /></div><div><h2>From Prototype To Launch</h2></div><div><br /></div><div><div>I quickly realized that the hackathon crew did not calculate the Mutation score, the ratio of mutants detected by tests, which is a prominent metric in the research literature and the holy grail of evaluating test quality, but just enumerated live mutants. My first exposure to mutants was just running the tool on the mutagenesis code itself and trying to understand the report. I was immediately overwhelmed: after a long execution time, I was facing thousands of mutants in just a handful of files. I tried going through a couple, but after a few minutes I grew tired and moved on with my main project, which happened to be on Google Shopping. In the following months, I stayed away from my 20% project, but I kept thinking about it, bugging my colleagues and friends about the ideas I had to make mutation testing work for us. After many months of brainstorming and discussions, almost a year after the original hackathon project, I was ready to design the Mutation Testing Service.</div></div><div><br /></div><div><br /></div><div><div>I faced two big problems. First, I could force myself to go through lots of mutants, and maybe find a useful one that would prompt me to write a test case, but I could not force others, not even my teammates. Second, the vast majority of mutants were simply bad. Here are some examples:</div></div> <div><br /></div><div><br /></div><div>Replacing division with subtraction, but in a logging statement.</div><div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">log.<span class=\"code-method\">Infof</span>(<span class=\"code-string\">\"Found %d (%.2f %%)!\"</span>, e,       <br />           float64(e)*<span class=\"code-numerical\">100.0</span> <span class=\"code-changed-removed\">/</span> total)</span></pre></td>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">log.<span class=\"code-method\">Infof</span>(<span class=\"code-string\">\"Found %d (%.2f %%)!\"</span>, e,<br />           float64(e)*<span class=\"code-numerical\">100.0</span> <span class=\"code-changed-added\">-</span> total)</span></pre></td></tr>   </tbody></table><br /></div>  <div><br /></div><div><br /></div><div>Appending number 1 to an error message.&nbsp;</div><div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\"><span class=\"code-method\">Error</span>.create(((key + <span class=\"code-string\">\" disabled\"</span>)));</span></pre></td>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\"><span class=\"code-method\">Error</span>.create(((key + <span class=\"code-string\">\" disabled\"</span>) <span class=\"code-changed-added\">+ <span class=\"code-numerical\">1</span></span>));</span></pre></td></tr>   </tbody></table><br /></div> <div><br /></div><div><br /></div><div><div>Replacing <i>greater than with less than</i> when comparing length of a collection to zero.</div></div><div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">showCart := len(cart.GetItems()) <span class=\"code-changed-removed\">&gt;</span> <span class=\"code-numerical\">0</span></span></pre></td>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">showCart := len(cart.GetItems()) <span class=\"code-changed-added\">&lt;</span> <span class=\"code-numerical\">0</span></span></pre></td></tr>   </tbody></table><br /></div>  <div><br /></div><div><br /></div><div><div>Replacing the idiomatic python check for whether the module is imported or executed as main.</div></div><div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\"><span class=\"code-reserved\">if</span> (__name__ <span class=\"code-changed-removed\">==</span> <span class=\"code-string\">'__main__'</span>):</span></pre></td>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\"><span class=\"code-reserved\">if</span> (__name__ <span class=\"code-changed-added\">!=</span> <span class=\"code-string\">'__main__'</span>):</span></pre></td></tr>   </tbody></table><br /></div> <div><br /></div><div><br /></div><div>Changing python’s string concatenation (+) to string multiplication (*).</div><div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">message = (<span class=\"code-string\">'id '</span> <span class=\"code-changed-removed\">+</span> run_idx)</span></pre></td>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">message = (<span class=\"code-string\">'id '</span> <span class=\"code-changed-added\">*</span> run_idx)</span></pre></td></tr>   </tbody></table><br /></div>  <div><br /></div><div><br /></div><div>Changing a tuning parameter.</div><div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">slo = (<span class=\"code-numerical\">20</span> * time.<span class=\"code-attribute\">Second</span>)</span></pre></td>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">slo = (<span class=\"code-numerical\">20</span> * time.<span class=\"code-attribute\">Second</span>) <span class=\"code-changed-added\">+ <span class=\"code-numerical\">1</span></span></span></pre></td></tr>   </tbody></table><br /></div> <div><br /></div><div><br /></div><div>Changing a network timeout, but the network layer is mocked in the tests.</div><div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">_TIMEOUT = (<span class=\"code-numerical\">60</span> <span class=\"code-changed-removed\">*</span> <span class=\"code-numerical\">10</span>)</span></pre></td>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">_TIMEOUT = (<span class=\"code-numerical\">60</span> <span class=\"code-changed-added\">/</span> <span class=\"code-numerical\">10</span>)</span></pre></td></tr>   </tbody></table><br /></div> <div><br /></div><div><br /></div><div>Subtracting from -∞.</div><div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">df = df.replace(<br />  [numpy.inf, -numpy.inf],<br />  numpy.nan<br />)</span></pre></td>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">df = df.replace(<br />  [numpy.inf, -numpy.inf <span class=\"code-changed-added\">- <span class=\"code-numerical\">1</span></span>],<br />  numpy.nan<br />)</span></pre></td></tr>   </tbody></table><br /></div><br /><div>Yes, the tests did not detect these mutants, but we would not want such tests anyway. Many of them would produce fragile, <a href=\"https://testing.googleblog.com/2015/01/testing-on-toilet-change-detector-tests.html\">change-detector tests</a>. We later settled on calling them <b>unproductive mutants</b>: writing tests for those mutants would make the test suite worse, not better.</div><div><br /></div> <div><br /></div><div><div>I realized that I needed to suppress these types of mutants: if I reported them, nobody would use mutation testing, myself included. Most of the mutants were not useful, and that is a waste of developer attention. The onus was on me to create a better tool. I set out to try various heuristics by looking at the report and suppressing mutants that I found unproductive. I encoded the heuristics in AST (<a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">Abstract Syntax Tree</a>) matching rules, and I dubbed the AST nodes which contained unproductive mutants as <b>arid nodes</b>. In the beginning, there were only a few rules in the system, but that was enough to make me feel confident that my colleagues would give it a try.</div></div><div><br /></div><div><br /></div><div><div>The other big issue was the sheer number of mutants. With five or more in a line, hundreds in a file, it was a challenge to display them, and even if I managed that, nobody would go through them anyway. I quickly realized that they shouldn’t: it took a lot of time for me to go through the mutants, and, while some pointed me to a hole in my test suite, most were useless, and many of them, especially ones in the same line, redundant. I did not need every possible combination of operators changed to tell me that my test for that condition was insufficient; one was just fine. That was my first decision on mutation testing: to report at most one mutant in a line. This was a quick and easy decision to make, because, if you’ve ever used a Code review system, you know that having more makes the review noisy and harder to do. Another reason why it was such an easy decision was that it would have been computationally prohibitively expensive to calculate all mutants, and I could have thrown my 20% project down the drain. I call it limitation-driven development :)</div></div><div><br /></div><div><br /></div><div>Of course, the idea was to report live mutants during <a href=\"https://research.google/pubs/pub47025/\">Code review</a>. Code review is the perfect time in the engineering process to surface useful findings about the code being changed, and integrating into the existing developer process has the <a href=\"https://research.google/pubs/pub43477/\">highest chance</a> that the developers will take action. This seemed like the most normal thing in the world: we had hundreds of <a href=\"https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43322.pdf\">analyzers</a> and all engineers were used to receiving findings from various analyses of their code. It took an outsider to point out that this was a strange approach: mutation testing was classically run on the whole program and the mutation score calculated and used as guidance.</div><div><br /></div><div><br /></div><div>This is what a Mutant finding looks like in the Code review tool:</div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/--aN_4XMCTb8/YHDnTj3u-lI/AAAAAAAAAfA/_L2ZFIq3T0EcLkgg_Q_J3ywqVyV7ky_qQCLcBGAsYHQ/s607/Code%2BReview%2BImage%2Bfor%2BMutation%2BTesting%2BArticle.jpg\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"430\" data-original-width=\"607\" src=\"https://1.bp.blogspot.com/--aN_4XMCTb8/YHDnTj3u-lI/AAAAAAAAAfA/_L2ZFIq3T0EcLkgg_Q_J3ywqVyV7ky_qQCLcBGAsYHQ/s16000/Code%2BReview%2BImage%2Bfor%2BMutation%2BTesting%2BArticle.jpg\" /></a></div><div><br /></div><div><br /></div><div><br /></div>Mutation Testing at Google is a dynamic analyzer of code changes that surfaces mutants during Code review by posting code findings. In terms of infrastructure, it consists of three main parts: the <i>change listener</i>, the <i>analyzer</i>, and many <i>mutagenesis servers</i>, one for each language.<br /><div><br /></div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-zdEPosZhI0o/YHDn654mV9I/AAAAAAAAAfI/TiZ1Y6bJn5kcnv4JvzFdGeInr8sTk_3vwCLcBGAsYHQ/s711/Block%2BDiagram%2Bfor%2BMutation%2BTesting%2BArticle.jpg\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"466\" data-original-width=\"711\" height=\"421\" src=\"https://1.bp.blogspot.com/-zdEPosZhI0o/YHDn654mV9I/AAAAAAAAAfI/TiZ1Y6bJn5kcnv4JvzFdGeInr8sTk_3vwCLcBGAsYHQ/w640-h421/Block%2BDiagram%2Bfor%2BMutation%2BTesting%2BArticle.jpg\" width=\"640\" /></a></div><br /><div><br /></div><div><br /></div><div><div>Each event during the Code review is announced using a publisher-subscriber pattern, and any interested party can listen, and react, to these events. When a change is sent for Code review, many things happen: linters are run, automated tests are evaluated, coverage is calculated, and for the users of mutation testing, mutants are generated and evaluated. Listening on all events coming from the Code review system, the <i>listener</i> schedules a mutation run on the <i>analyzer</i>.&nbsp;</div></div><div><br /></div><div><br /></div><div>The first thing the analyzer does is get the code coverage results for the patch in question; from it, the analyzer can extrapolate which tests cover which lines of source code. This is a very useful piece of information, because running the minimum set of tests that can kill a mutant is crucial; if we just ran all tests that were linked in, or covered the project, that would be prohibitively computationally expensive</div><div><br /></div><div><br /></div><div><div>Next, for each covered line in each file in the patch, a <i>mutagenesis server</i> for the language in question is asked to produce a mutant. The mutagenesis server parses the file, traverses its AST, and applies the mutators in the requested order (as per mutation context), ignoring arid nodes, nodes in uncovered lines and in lines that are not affected by the proposed patch.</div></div><div><br /></div><div><br /></div><div><div>When the <i>analyzer</i> assembles all mutants, it patches them one by one to a version control context and then evaluates all the tests for each mutant in parallel. For mutants for which all tests pass, the <i>analyzer</i> surfaces a finding for the code author and reviewers, and is done for the time being.</div></div><div><br /></div><div><br /></div><div>Because the Code review is a laborious and dynamic process, with many rounds of comments from reviewers and many automated findings from hundreds of different analyzers, there can be many snapshots as the patch evolves: adoption of recommendations from reviewers or accepting proposed changes from linters yields many code states. Mutation testing first runs after coverage is available, and then it runs for each subsequent snapshot: developers like to see the fruits of their labor: when they write a test to kill a mutant, they want to see the mutant killed.</div><div><br /></div><div><br /></div><div>I launched Mutation testing for the Shopping Engineering Productivity team in late 2015. Around 15 of my colleagues were subjected to Mutant findings during their Code reviews, and it was a bumpy start. Each finding has two buttons: <b>Please fix</b> and <b>Not useful</b>, as you can see on the Code review screenshot above. A reviewer can instruct the code author to fix some finding (e.g. a ClangTidy finding might point out that an object is being unnecessarily copied and suggest using a reference instead, or a Mutant finding might point out that code is not well tested). The author and all reviewers can give feedback to the author of the finding/analyzer that their finding is not useful. This is a source of valuable information, and I made use of it. For each mutant that was deemed not useful, I’d check it out and see whether I could generalize from it and add a new rule to my arid node heuristics. Slowly, I collected several hundred heuristics, many of them generally applicable, but many also tied to internal stuff, like monitoring frameworks. More and more, I noticed that just marking nodes as arid and suppressing mutants in them was not enough on its own; a more powerful mechanism was required to reduce this noise even further. Take a look at these motivating examples:</div>   <div><br /></div><div>Changing the condition of an if statement, but the body is arid (a logging statement).</div><div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\"><span class=\"code-reserved\">if</span> _, err := <span class=\"code-method\">Del</span>(req); err <span class=\"code-changed-removed\">!=</span> <span class=\"code-reserved\">nil</span> {<br />  log.<span class=\"code-method\">Errorf</span>(<span class=\"code-string\">\"cleanup failed: %v”</span>, cerr)<br />}</span></pre></td>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\"><span class=\"code-reserved\">if</span> _, err := c.<span class=\"code-method\">Del</span>(req); err <span class=\"code-changed-added\">==</span> <span class=\"code-reserved\">nil</span> {<br />  log.<span class=\"code-method\">Errorf</span>(<span class=\"code-string\">\"cleanup failed: %v”</span>, cerr)<br />}</span></pre></td></tr>   </tbody></table><br /></div> <br /><div><br /></div><div><div>Similar pattern, but in C++:</div></div><div><br /></div><div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\"><span class=\"code-reserved\">if</span> (<span class=\"code-changed-added\">!</span>(!status.ok())) {<br />    LOG(WARNING) &lt;&lt; <span class=\"code-string\">\"Updating dependency graph failed\"</span> &lt;&lt; status;<br />}</span></pre></td></tr>   </tbody></table><br /></div><br /><div><div>I settled for a transitive rule: an AST node is arid if I say it’s arid, or if it’s a compound statement and all its body is also arid. This made sense in retrospect, but it took some looking at reported examples of unproductive mutants to crystalize. Because the logging statements are arid, the whole <i>if</i> statement’s body is arid, and hence, the if statement itself is arid, including its condition.&nbsp;</div></div><div><br /></div><div><br /></div><div><div>In the summer of 2015, my intern, Małgorzata Salawa, and I got mutagenesis implemented for C++, Go, Python, and Java, and having transitive arid node detection and surfacing at most a single mutant per line and 7 per file, we called it a v1.0 and launched. Mutation testing was always an opt-in service, and in the beginning had a few users (93 code reviews in Q1 of 2016), but over time it ramped up to 2,500 users in February 2017, to tens of thousands today. The early days were crucial to get the users’ feedback and extend the arid node heuristics ever further. In the beginning, the <i>Not Useful</i> rate was around 80%, and this was already with some heuristics and at most a single mutant per line. With time, I got it down to around 15%. I was always aware that getting the rate to 0% was impossible, because of the nature of the mutants: sometimes, the mutant would produce an equivalent behavior as the original, and there was no way to avoid that fully.</div></div><div><br /></div><div><br /></div> <div>Changing cached lookup by removing the cache and always recalculating yields functionally equivalent code, undetectable by conventional testing.</div><div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">func (s *Serv) calculate(<span class=\"code-reserved\">in</span> int32) <span class=\"code-reserved\">int</span> {<span class=\"code-changed-added\"><br />  <span class=\"code-reserved\">if</span> val, ok := <span class=\"code-reserved\">if</span> s.cache[<span class=\"code-reserved\">in</span>] {<br />    <span class=\"code-reserved\">return</span> val  <br />  }</span><br />  val := s.calc(<span class=\"code-reserved\">in</span>)<br />  s.cache[<span class=\"code-reserved\">in</span>] = val<br />  <span class=\"code-reserved\">return</span> val<br />}</span></pre></td>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">func (s *Serv) calculate(<span class=\"code-reserved\">in</span> int32) <span class=\"code-reserved\">int</span> {<span class=\"code-changed-removed\"><br />                                <br />              <br />   <br /></span>  val := s.calc(<span class=\"code-reserved\">in</span>)<br />  s.cache[<span class=\"code-reserved\">in</span>] = val<br />  <span class=\"code-reserved\">return</span> val<br />}</span></pre></td></tr>   </tbody></table></div><br /><div><br /></div><div><br /></div><div><div>I was both surprised and happy that I could lower the <i>Not useful</i> rate to under 50%.</div></div><div><br /></div><div><br /></div><div><h2>Mutation Context</h2></div><div><br /></div><div>As time went by, I added support for more languages. In early 2017, I implemented support for JavaScript and TypeScript, and later in the year I added support for Dart. In 2018 I added support for <a href=\"https://github.com/google/zetasql\">ZetaSQL</a>. And finally, in early 2020, I added support for Kotlin as it became more and more popular in the Android world.</div><div><br /></div><div><br /></div><div><div>I kept track of various stats for all mutants: their survival rates and <i>Please fix/Not useful</i> ratios.&nbsp;</div></div><div><br /></div><div><br /></div><div>The worst performing mutator was ABS(<i>Absolute Value Mutator</i>) that would replace an <i>expression</i> with <i>±abs(expression),</i> for example:</div>  <div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">absl::<span class=\"code-method\">Minutes</span>(<span class=\"code-numerical\">10</span>) - elapsed;</span></pre></td>  <td style=\"background-color: #e0e0e0; vertical-align: top; width: 607px;\"><pre style=\"background-color: #e0e0e0; border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">absl::<span class=\"code-method\">Minutes</span>(<span class=\"code-changed-added\">-abs</span>(<span class=\"code-numerical\">10</span>)) - elapsed;</span></pre></td></tr>   </tbody></table><br /></div><div style=\"overflow-x: auto;\"><br /></div><div style=\"overflow-x: auto;\">Looking at the examples, I had to agree. Because the feedback was predominantly negative for this mutator, I quickly completely disabled it for all languages.</div><div style=\"overflow-x: auto;\"><br /></div><div style=\"overflow-x: auto;\"><br /></div><div style=\"overflow-x: auto;\"><div style=\"overflow-x: auto;\">I soon noticed that the SBR (<i>Statement Block Removal</i>) mutator, which deletes statements or whole blocks, is the most common one, and that made sense: while mutating a logical or arithmetic operator required the existence of such an operator in the code to be mutated, any line of code was eligible for deletion. Mutants generated by code deletion, though, did not have the best reported usefulness, or productivity. In fact, almost all other mutators generated more productive mutants than the SBR, and that got me thinking: not all code is the same; a condition within an <i>if</i> statement that contains a <i>return</i> statement is not the same as a condition in another location.</div><div><br /></div><div><br /></div><div><div>Out of this, an idea was born: context-based mutator selection. For each line, I would randomly shuffle mutator operators and pick one by one until one generated a mutant in that line. That was not ideal, because I knew that some operators worked better than others in some contexts. Rather than just randomly picking a mutant operator, I decided to pick the one most likely to generate a surviving mutant that is then most likely to be productive when reported, based on historical data. I had millions of mutants to learn from, I just needed to define the distance between pieces of code. Finally deciding to look for AST nodes that were in similar contexts as the node being mutated, I looked at the nodes around the node under mutation, and encoded the child-parent relationships of the near-by nodes to capture the AST context. Armed with the distance measure and with the help of my returning intern Małgorzata, it was easy to find the closest AST contexts from historic mutants and to look at their fate and pick the best one. I ordered the mutators by their productivity and tried to generate a mutant in the node, in that order, since it’s quite possible that some of the mutant operators are not applicable on some piece of code.</div><div><br /></div></div><div><br /></div><div>This was quite an improvement. Both mutant survivability and usefulness improved significantly for all mutant operators and programming languages. You can read more about the findings in <a href=\"https://arxiv.org/pdf/2102.11378.pdf\">the upcoming paper</a>.</div><div><br /></div><div><br /></div><div><div><h2>Fault Coupling</h2></div><div><br /></div></div><div><br /></div><div>Mutation testing is only valuable if the test cases we write for mutants are valuable. <a href=\"https://ieeexplore.ieee.org/document/6982626\" rel=\"nofollow\" target=\"_blank\">Mutants do not resemble real bugs</a>, they are simpler than bugs found in the wild. Mutation testing relies on the coupling hypothesis: <a href=\"https://dl.acm.org/doi/abs/10.1145/2635868.2635929\" rel=\"nofollow\" target=\"_blank\">mutants are coupled with real bugs</a>&nbsp;if a test suite that is sensitive enough to detect mutants is also sensitive enough to detect the more complex real bugs. Reporting mutants and writing tests to kill them only makes sense if they are coupled with real bugs.</div><div><br /></div><div><br /></div><div><br /></div><div><div>I instinctively thought that fault coupling was real, otherwise I would not have worked on mutation testing at all, and I’ve seen many many cases where mutants pointed to a bug; but still, I wanted to verify this hypothesis, if only for our code base. I designed an experiment: I would generate all mutants in a line for explicit bug-fixing changes, before and after the fix, and I would check whether, had mutation testing been run, it would have surfaced a mutant in the change that introduced the bug, and potentially prevented it (i.e., killed in the change that fixed the bug and added new tests cases). I ran this experiment on weekends for over a month, because we did not have the resources to run it during workdays. While I normally generate a single mutant in a line, to test the fault coupling effect, I used the classical mutation testing approach and generated all possible mutants, while still adhering to the arid node suppression. A total of 33 million test suites were executed to test hundreds of thousands of mutants, finally to conclude that, in around 70% of cases, a bug was coupled with a mutant.&nbsp;</div></div><div><br /></div><div><br /></div><div>While I was at it, I also checked my intuition on whether a single mutant per line was enough, and found that it was overwhelmingly so: in more than 90% of cases, either all mutants were killed in a line or none was. It’s worth keeping in mind that I still applied my arid node suppression heuristics for this experiment. It was great to finally have confirmation of my intuitions.</div><div><br /></div><div><br /></div><div>I also looked into the developer behavior changes after using mutation testing on a project for longer periods of time, and discovered that projects that use mutation testing get more tests over time, as developers get exposed to more and more mutants. Not only do developers write more test cases, but those test cases are more effective in killing mutants: less and less mutants get reported over time. I noticed this from personal experience too: when writing unit tests, I would see where I cut some corners in the tests, and anticipated the mutant. Now I just add the missing test cases, rather than facing a mutant in my Code review, and I rarely see mutants these days, as I’ve learned to anticipate and preempt them.</div><div><br /></div><div><br /></div><div>You can read more about the findings in our&nbsp;<a href=\"https://homes.cs.washington.edu/~rjust/publ/mutation_testing_practices_icse_2021.pdf\">ICSE paper</a>.</div><div><br /></div><div><br /></div><div><h2>Conclusion</h2></div><div><br /></div><div><br /></div><div><div>It’s been a long road since that hackathon in the winter of 2013. Mutation testing was a lot of fun to work on. It had its challenges, and I had days where I thought that I would throw everything down the drain (I’m looking at you, clang), but I am glad I stuck with it.</div></div><div><br /></div><div><br /></div><div><br /></div><div><div>The most interesting part of the project was getting Mutation testing to scale to such a large code base, and that required redefining the problem and adapting it to the existing ecosystem that engineers were already used to. Another interesting angle was working, and learning from, the academic community,&nbsp;in particular Gordon Fraser (University of Passau) and René Just (University of Washington).</div></div><div><br /></div><div><br /></div><div><br /></div><div>I would like to encourage everyone to give one of the many open source mutation testing tools a try on their projects. With some tweaks here and there, it can be a great way to keep your software well tested.</div><div><br /></div><div><br /></div><div><br /></div></div>  <div class=\"feedflare\">\n<a href=\"http://feeds.feedburner.com/~ff/blogspot/RLXA?a=LbIQe4Pahdg:QqeIUtH4Bn0:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/blogspot/RLXA?d=yIl2AUoC8zA\" border=\"0\"></img></a> <a href=\"http://feeds.feedburner.com/~ff/blogspot/RLXA?a=LbIQe4Pahdg:QqeIUtH4Bn0:V_sGLiPBpWU\"><img src=\"http://feeds.feedburner.com/~ff/blogspot/RLXA?i=LbIQe4Pahdg:QqeIUtH4Bn0:V_sGLiPBpWU\" border=\"0\"></img></a>\n</div><img src=\"http://feeds.feedburner.com/~r/blogspot/RLXA/~4/LbIQe4Pahdg\" height=\"1\" width=\"1\" alt=\"\"/>","descriptionType":"html","publishedDate":"Mon, 12 Apr 2021 15:16:00 +0000","feedId":11775,"bgimg":"https://1.bp.blogspot.com/--aN_4XMCTb8/YHDnTj3u-lI/AAAAAAAAAfA/_L2ZFIq3T0EcLkgg_Q_J3ywqVyV7ky_qQCLcBGAsYHQ/s16000/Code%2BReview%2BImage%2Bfor%2BMutation%2BTesting%2BArticle.jpg","linkMd5":"903703e41b856dd7debda36bc31c24ba","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn60@2020_5/2021/04/14/18-34-11-813_e52583a01567f144.webp","destWidth":607,"destHeight":430,"sourceBytes":26000,"destBytes":19256,"author":"Google Testing Bloggers","articleImgCdnMap":{"https://1.bp.blogspot.com/--aN_4XMCTb8/YHDnTj3u-lI/AAAAAAAAAfA/_L2ZFIq3T0EcLkgg_Q_J3ywqVyV7ky_qQCLcBGAsYHQ/s16000/Code%2BReview%2BImage%2Bfor%2BMutation%2BTesting%2BArticle.jpg":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn60@2020_5/2021/04/14/18-34-11-813_e52583a01567f144.webp","https://1.bp.blogspot.com/-zdEPosZhI0o/YHDn654mV9I/AAAAAAAAAfI/TiZ1Y6bJn5kcnv4JvzFdGeInr8sTk_3vwCLcBGAsYHQ/w640-h421/Block%2BDiagram%2Bfor%2BMutation%2BTesting%2BArticle.jpg":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn67@2020_3/2021/04/14/18-34-52-414_cc4f6c6e71419835.webp","http://feeds.feedburner.com/~ff/blogspot/RLXA?d=yIl2AUoC8zA":null,"http://feeds.feedburner.com/~ff/blogspot/RLXA?i=LbIQe4Pahdg:QqeIUtH4Bn0:V_sGLiPBpWU":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn65@2020_3/2021/04/14/18-34-12-454_863e6fdadd174c37.webp","http://feeds.feedburner.com/~r/blogspot/RLXA/~4/LbIQe4Pahdg":"https://cdn.jsdelivr.net/gh/myreaderx/cdn73@2020_4/2021/04/14/18-34-12-162_3fc66ebb10eb8c85.webp"},"publishedOrCreatedDate":1618425251779}],"record":{"createdTime":"2021-04-15 02:34:11","updatedTime":"2021-04-15 02:34:11","feedId":11775,"fetchDate":"Wed, 14 Apr 2021 18:34:11 +0000","fetchMs":17,"handleMs":21,"totalMs":41067,"newArticles":0,"totalArticles":25,"status":1,"type":0,"ip":"79b59b7ab14b8d981e3d8a220e20848a","hostName":"us-035*","requestId":"f1c72aef430c43ec87125b4b235ba089_11775","contentType":"text/xml; charset=UTF-8","totalBytes":35358,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":5,"articlesImgsGithubTotal":4,"successGithubMap":{"myreaderx6":1,"myreaderx32":1,"myreaderx33":1,"myreaderx":1},"failGithubMap":{"myreaderx14":1}},"feed":{"createdTime":"2020-08-25 04:37:02","updatedTime":"2020-09-05 16:26:40","id":11775,"name":"Google Testing Blog","url":"http://feeds.feedburner.com/blogspot/RLXA","subscriber":263,"website":null,"icon":"http://testing.googleblog.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx64/cdn83@2020_1/2020/09/05/08-26-40-365_4f867811af082105.ico","description":"If it ain't broke, you're not trying hard enough.","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2021-04-15 02:34:52","updatedTime":"2021-04-15 02:34:52","id":null,"feedId":11775,"linkMd5":"903703e41b856dd7debda36bc31c24ba"}],"tmpCommonImgCdnBytes":19256,"tmpBodyImgCdnBytes":16102,"tmpBgImgCdnBytes":0,"extra4":{"start":1618425251724,"total":0,"statList":[{"spend":34,"msg":"获取xml内容"},{"spend":21,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":40653,"msg":"正文链接上传到cdn"}]},"extra5":5,"extra6":5,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"http://feeds.feedburner.com/~ff/blogspot/RLXA?d=yIl2AUoC8zA","sourceStatusCode":200,"destWidth":62,"destHeight":24,"sourceBytes":997,"destBytes":310,"targetWebpQuality":75,"feedId":11775,"totalSpendMs":173,"convertSpendMs":3,"createdTime":"2021-04-15 02:34:12","host":"europe62*","referer":"http://feedproxy.google.com/~r/blogspot/RLXA/~3/LbIQe4Pahdg/mutation-testing.html","linkMd5ListStr":"903703e41b856dd7debda36bc31c24ba","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn64/contents/2021/04/14/18-34-12-277_b9f0744d659dcfb4.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Wed, 14 Apr 2021 18:34:12 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["9F18:743F:4F88B67:50D1A38:607735A4"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1618427708"],"x-ratelimit-used":["60"],"x-xss-protection":["0"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn64/contents/2021/04/14/18-34-12-277_b9f0744d659dcfb4.webp","historyStatusCode":[],"spendMs":140},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"997 B","destSize":"310 B","compressRate":"31.1%"},{"code":1,"isDone":false,"source":"http://feeds.feedburner.com/~ff/blogspot/RLXA?d=yIl2AUoC8zA","sourceStatusCode":200,"destWidth":62,"destHeight":24,"sourceBytes":997,"destBytes":310,"targetWebpQuality":75,"feedId":11775,"totalSpendMs":67,"convertSpendMs":3,"createdTime":"2021-04-15 02:34:12","host":"us-51*","referer":"http://feedproxy.google.com/~r/blogspot/RLXA/~3/LbIQe4Pahdg/mutation-testing.html","linkMd5ListStr":"903703e41b856dd7debda36bc31c24ba","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn64/contents/2021/04/14/18-34-12-490_b9f0744d659dcfb4.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Wed, 14 Apr 2021 18:34:12 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["9A54:21A6:10F1FDB:26E8AD8:607735A4"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1618427708"],"x-ratelimit-used":["60"],"x-xss-protection":["0"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn64/contents/2021/04/14/18-34-12-490_b9f0744d659dcfb4.webp","historyStatusCode":[],"spendMs":33},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"997 B","destSize":"310 B","compressRate":"31.1%"},null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://europe62.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://europe61.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-51.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-040.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://1.bp.blogspot.com/--aN_4XMCTb8/YHDnTj3u-lI/AAAAAAAAAfA/_L2ZFIq3T0EcLkgg_Q_J3ywqVyV7ky_qQCLcBGAsYHQ/s16000/Code%2BReview%2BImage%2Bfor%2BMutation%2BTesting%2BArticle.jpg","sourceStatusCode":200,"destWidth":607,"destHeight":430,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn60@2020_5/2021/04/14/18-34-11-813_e52583a01567f144.webp","sourceBytes":26000,"destBytes":19256,"targetWebpQuality":75,"feedId":11775,"totalSpendMs":348,"convertSpendMs":8,"createdTime":"2021-04-15 02:34:11","host":"us-024*","referer":"http://feedproxy.google.com/~r/blogspot/RLXA/~3/LbIQe4Pahdg/mutation-testing.html","linkMd5ListStr":"903703e41b856dd7debda36bc31c24ba,903703e41b856dd7debda36bc31c24ba","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.4 KB","destSize":"18.8 KB","compressRate":"74.1%"},{"code":1,"isDone":false,"source":"http://feeds.feedburner.com/~r/blogspot/RLXA/~4/LbIQe4Pahdg","sourceStatusCode":200,"destWidth":1,"destHeight":1,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn73@2020_4/2021/04/14/18-34-12-162_3fc66ebb10eb8c85.webp","sourceBytes":43,"destBytes":72,"targetWebpQuality":75,"feedId":11775,"totalSpendMs":302,"convertSpendMs":3,"createdTime":"2021-04-15 02:34:12","host":"us-51*","referer":"http://feedproxy.google.com/~r/blogspot/RLXA/~3/LbIQe4Pahdg/mutation-testing.html","linkMd5ListStr":"903703e41b856dd7debda36bc31c24ba","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"43 B","destSize":"72 B","compressRate":"167.4%"},{"code":1,"isDone":false,"source":"http://feeds.feedburner.com/~ff/blogspot/RLXA?i=LbIQe4Pahdg:QqeIUtH4Bn0:V_sGLiPBpWU","sourceStatusCode":200,"destWidth":66,"destHeight":24,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn65@2020_3/2021/04/14/18-34-12-454_863e6fdadd174c37.webp","sourceBytes":1009,"destBytes":340,"targetWebpQuality":75,"feedId":11775,"totalSpendMs":580,"convertSpendMs":3,"createdTime":"2021-04-15 02:34:12","host":"europe61*","referer":"http://feedproxy.google.com/~r/blogspot/RLXA/~3/LbIQe4Pahdg/mutation-testing.html","linkMd5ListStr":"903703e41b856dd7debda36bc31c24ba","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"1,009 B","destSize":"340 B","compressRate":"33.7%"},{"code":1,"isDone":false,"source":"https://1.bp.blogspot.com/-zdEPosZhI0o/YHDn654mV9I/AAAAAAAAAfI/TiZ1Y6bJn5kcnv4JvzFdGeInr8sTk_3vwCLcBGAsYHQ/w640-h421/Block%2BDiagram%2Bfor%2BMutation%2BTesting%2BArticle.jpg","sourceStatusCode":200,"destWidth":640,"destHeight":419,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn67@2020_3/2021/04/14/18-34-52-414_cc4f6c6e71419835.webp","sourceBytes":38590,"destBytes":15690,"targetWebpQuality":75,"feedId":11775,"totalSpendMs":366,"convertSpendMs":10,"createdTime":"2021-04-15 02:34:52","host":"europe62*","referer":"http://feedproxy.google.com/~r/blogspot/RLXA/~3/LbIQe4Pahdg/mutation-testing.html","linkMd5ListStr":"903703e41b856dd7debda36bc31c24ba","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"37.7 KB","destSize":"15.3 KB","compressRate":"40.7%"}],"successGithubMap":{"myreaderx6":1,"myreaderx32":1,"myreaderx33":1,"myreaderx":1},"failGithubMap":{"myreaderx14":1}}