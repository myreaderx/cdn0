{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-09-07 12:58:38","updatedTime":"2020-09-07 12:58:38","title":"JVM中方法调用的实现机制","link":"http://it.deepinmind.com/jvm/2019/07/19/jvm-method-invocation","description":"<p>本文将要介绍一下Java 8和Java 9中JVM是如何进行方法调用的。这是JVM内部实现的基础机制，如果你想理解JVM的just-in-time（JIT）编译器或者进行应用程序调优的话，这些是必需的背景知识。</p>\n\n<h3>字节码分析</h3>\n\n<p>我们先从一段简单的Java代码开始：</p>\n\n<div class=\"highlight\"><pre><code class=\"java\"><span class=\"kt\">long</span> <span class=\"n\">time</span> <span class=\"o\">=</span> <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">();</span>\n<span class=\"n\">HashMap</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">hm</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">&lt;&gt;();</span>\n<span class=\"n\">hm</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"s\">&quot;now&quot;</span><span class=\"o\">,</span> <span class=\"s\">&quot;bar&quot;</span><span class=\"o\">);</span>\n<span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">hm</span><span class=\"o\">;</span>\n<span class=\"n\">m</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"s\">&quot;foo&quot;</span><span class=\"o\">,</span> <span class=\"s\">&quot;baz&quot;</span><span class=\"o\">);</span></code></pre></div>\n\n<p>通过javap -c查看反编译后的代码，可以看到Java编译器所生成的字节码：</p>\n\n<div class=\"highlight\"><pre><code class=\"java\"><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">invokestatic</span> <span class=\"err\">#</span><span class=\"mi\">2</span> <span class=\"c1\">// Method</span>\n                     <span class=\"n\">java</span><span class=\"o\">/</span><span class=\"n\">lang</span><span class=\"o\">/</span><span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">:()</span><span class=\"n\">J</span>\n<span class=\"mi\">3</span><span class=\"o\">:</span> <span class=\"n\">lstore_1</span>\n<span class=\"mi\">4</span><span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"err\">#</span><span class=\"mi\">3</span> <span class=\"c1\">// class java/util/HashMap</span>\n<span class=\"mi\">7</span><span class=\"o\">:</span> <span class=\"n\">dup</span>\n<span class=\"mi\">8</span><span class=\"o\">:</span> <span class=\"n\">invokespecial</span> <span class=\"err\">#</span><span class=\"mi\">4</span> <span class=\"c1\">// Method java/util/HashMap.&quot;&lt;init&gt;&quot;:()V</span>\n<span class=\"mi\">11</span><span class=\"o\">:</span> <span class=\"n\">astore_3</span>\n<span class=\"mi\">12</span><span class=\"o\">:</span> <span class=\"n\">aload_3</span>\n<span class=\"mi\">13</span><span class=\"o\">:</span> <span class=\"n\">ldc</span> <span class=\"err\">#</span><span class=\"mi\">5</span> <span class=\"c1\">// String now</span>\n<span class=\"mi\">15</span><span class=\"o\">:</span> <span class=\"n\">ldc</span> <span class=\"err\">#</span><span class=\"mi\">6</span> <span class=\"c1\">// String bar</span>\n<span class=\"mi\">17</span><span class=\"o\">:</span> <span class=\"n\">invokevirtual</span> <span class=\"err\">#</span><span class=\"mi\">7</span> <span class=\"c1\">// Method java/util/HashMap.put:  (Ljava/lang/Object; Ljava/lang/Object;)Ljava/lang/Object;</span>\n<span class=\"mi\">20</span><span class=\"o\">:</span> <span class=\"n\">pop</span>\n<span class=\"mi\">21</span><span class=\"o\">:</span> <span class=\"n\">aload_3</span>\n<span class=\"mi\">22</span><span class=\"o\">:</span> <span class=\"n\">astore</span> <span class=\"mi\">4</span>\n<span class=\"mi\">24</span><span class=\"o\">:</span> <span class=\"n\">aload</span> <span class=\"mi\">4</span>\n<span class=\"mi\">26</span><span class=\"o\">:</span> <span class=\"n\">ldc</span> <span class=\"err\">#</span><span class=\"mi\">8</span> <span class=\"c1\">// String foo</span>\n<span class=\"mi\">28</span><span class=\"o\">:</span> <span class=\"n\">ldc</span> <span class=\"err\">#</span><span class=\"mi\">9</span> <span class=\"c1\">// String baz</span>\n<span class=\"mi\">30</span><span class=\"o\">:</span> <span class=\"n\">invokeinterface</span> <span class=\"err\">#</span><span class=\"mi\">10</span><span class=\"o\">,</span> <span class=\"mi\">3</span> <span class=\"c1\">// InterfaceMethod java/util/Map.put: (Ljava/lang/Object;Ljava/lang/Object;) Ljava/lang/Object;</span>\n<span class=\"mi\">35</span><span class=\"o\">:</span> <span class=\"n\">pop</span></code></pre></div>\n\n<p>首次阅读JVM级别的字节码的Java开发人员一定会感到奇怪，Java的方法调用全都变成了各式各样的invoke*指令。</p>\n\n<p>我们先来详细看下反编译后的第一段代码：</p>\n\n<div class=\"highlight\"><pre><code class=\"java\"><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">invokestatic</span> <span class=\"err\">#</span><span class=\"mi\">2</span> <span class=\"c1\">// Method java/lang/System.currentTimeMillis:()J</span>\n<span class=\"mi\">3</span><span class=\"o\">:</span> <span class=\"n\">lstore_1</span></code></pre></div>\n\n<p>对System.currentTimeMillis的静态方法调用变成了字节码标记0处的invokestatic操作码。这个方法没有入参，因此在方法分派调用前并没有什么需要加载进来的。</p>\n\n<p>紧接着，字节流中出现了00 02两个字节。它们组成了一个16位的数字（这里对应的是#2），它是class中的一个表——被称为常量池——里的偏移量。所有的常量池索引都是16位的，因此操作码如果想引用常量池里的任意一个值，对应入口的偏移量都会被编码为两个连续的字节。</p>\n\n<p>反编译器很贴心地加上了一段注释来告诉你#2处到底对应的是什么方法。这里当然就是System.currentTimeMillis方法了。javap反编译后的信息包含了被调用方法的名称，以及方法的入参类型（放在括号中），最后是方法的返回值类型。</p>\n\n<p>方法一旦返回，调用结果会被存储在栈上，标记3处可以看到一个单独的，无参数的操作码lstore_1，它会将返回值存储到long类型的局部变量中。</p>\n\n<p>读代码的人显然能发现这个返回值后面是用不上的。不过，Java编译器的一个设计目标就是要尽可能忠实地反映源代码的内容——不管逻辑上是不是有意义的。因此，这段程序中System.currentTimeMillis的返回值还是被存储起来了，尽管最后确实是没有用上。</p>\n\n<p>我们再来看一下后面这段字节码：</p>\n\n<div class=\"highlight\"><pre><code class=\"java\"><span class=\"mi\">4</span><span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"err\">#</span><span class=\"mi\">3</span> <span class=\"c1\">// class java/util/HashMap</span>\n<span class=\"mi\">7</span><span class=\"o\">:</span> <span class=\"n\">dup</span>\n<span class=\"mi\">8</span><span class=\"o\">:</span> <span class=\"n\">invokespecial</span> <span class=\"err\">#</span><span class=\"mi\">4</span> <span class=\"c1\">// Method java/util/HashMap.&quot;&lt;init&gt;&quot;:()V</span>\n<span class=\"mi\">11</span><span class=\"o\">:</span> <span class=\"n\">astore_3</span>\n<span class=\"mi\">12</span><span class=\"o\">:</span> <span class=\"n\">aload_3</span>\n<span class=\"mi\">13</span><span class=\"o\">:</span> <span class=\"n\">ldc</span> <span class=\"err\">#</span><span class=\"mi\">5</span> <span class=\"c1\">// String now</span>\n<span class=\"mi\">15</span><span class=\"o\">:</span> <span class=\"n\">ldc</span> <span class=\"err\">#</span><span class=\"mi\">6</span> <span class=\"c1\">// String bar</span>\n<span class=\"mi\">17</span><span class=\"o\">:</span> <span class=\"n\">invokevirtual</span> <span class=\"err\">#</span><span class=\"mi\">7</span> <span class=\"c1\">// Method java/util/HashMap.put:</span>\n                        <span class=\"o\">(</span><span class=\"n\">Ljava</span><span class=\"o\">/</span><span class=\"n\">lang</span><span class=\"o\">/</span><span class=\"n\">Object</span><span class=\"o\">;</span><span class=\"n\">Ljava</span><span class=\"o\">/</span><span class=\"n\">lang</span><span class=\"o\">/</span><span class=\"n\">Object</span><span class=\"o\">;)</span>\n                        <span class=\"n\">Ljava</span><span class=\"o\">/</span><span class=\"n\">lang</span><span class=\"o\">/</span><span class=\"n\">Object</span><span class=\"o\">;</span>\n<span class=\"mi\">20</span><span class=\"o\">:</span> <span class=\"n\">pop</span></code></pre></div>\n\n<p>标记4到10处新建了一个HashMap对象，11处的指令将对象引用的拷贝存储到一个局部变量中。紧接着，12到16的指令将put()方法用到的HashMap对象以及参数都压入了栈中。最终由17到19的指令来真正地完成方法调用。</p>\n\n<p>这次用到的invoke指令是invokevirtual。这和静态方法调用不同，因为静态方法调用不需要实例对象；这个实例有时又称为接收者对象（receiver object）。（在字节码中，调用实例方法必须先在栈上设置好接收者对象和调用参数才能发起invoke指令。）由于这里没有用到put()方法的返回值，因此20的指令把它给丢弃了。</p>\n\n<p>21到25的字节码看上去会有点奇怪：</p>\n\n<div class=\"highlight\"><pre><code class=\"java\"><span class=\"mi\">21</span><span class=\"o\">:</span> <span class=\"n\">aload_3</span>\n<span class=\"mi\">22</span><span class=\"o\">:</span> <span class=\"n\">astore</span> <span class=\"mi\">4</span>\n<span class=\"mi\">24</span><span class=\"o\">:</span> <span class=\"n\">aload</span> <span class=\"mi\">4</span>\n<span class=\"mi\">26</span><span class=\"o\">:</span> <span class=\"n\">ldc</span> <span class=\"err\">#</span><span class=\"mi\">8</span> <span class=\"c1\">// String foo</span>\n<span class=\"mi\">28</span><span class=\"o\">:</span> <span class=\"n\">ldc</span> <span class=\"err\">#</span><span class=\"mi\">9</span> <span class=\"c1\">// String baz</span>\n<span class=\"mi\">30</span><span class=\"o\">:</span> <span class=\"n\">invokeinterface</span> <span class=\"err\">#</span><span class=\"mi\">10</span><span class=\"o\">,</span> <span class=\"mi\">3</span> <span class=\"c1\">// InterfaceMethod java/util/Map.put:</span>\n                             <span class=\"o\">(</span><span class=\"n\">Ljava</span><span class=\"o\">/</span><span class=\"n\">lang</span><span class=\"o\">/</span><span class=\"n\">Object</span><span class=\"o\">;</span><span class=\"n\">Ljava</span><span class=\"o\">/</span><span class=\"n\">lang</span><span class=\"o\">/</span><span class=\"n\">Object</span><span class=\"o\">;)</span>\n                             <span class=\"n\">Ljava</span><span class=\"o\">/</span><span class=\"n\">lang</span><span class=\"o\">/</span><span class=\"n\">Object</span><span class=\"o\">;</span>\n<span class=\"mi\">35</span><span class=\"o\">:</span> <span class=\"n\">pop</span></code></pre></div>\n\n<p>在前面标记4处创建了一个HashMap实例，并由11处的指令存储到了局部变量3中，现在又被重新加载回栈上，将其引用复制了一份存储到局部变量4中。这个完成后会把引用从栈上删除掉，因此在使用它前还得再重新加载一下（从变量4加载，aload 4）。</p>\n\n<p>这个看似左手倒右手的操作是因为在原始的Java代码中创建了一个额外的局部变量（Map类型的m），尽管引用的仍然是原始变量中的同一个对象。这又是一个字节码忠实于源代码的例子。Java之所以采用这么一种“愚笨的字节码”，主要原因之一就是为了能够给JVM的JIT编译器提供一个尽可能简单的输入格式。</p>\n\n<p>变量加载到栈上后，26到29的指令负责把要存到Map中的值加载进来。现在接收者对象和参数都已经在栈上准备好了，30指令会去分派call()方法的调用。这回用的invoke指令是invokeinterface——尽管调用的仍是同一个方法。返回值仍会通过35的指令pop给丢弃掉。</p>\n\n<p>目前为此，我们已经看到，Java编译器会根据不同的调用上下文来生成invokestatic, invokevirtual, 或者invokeinterface指令。</p>\n\n<h3>JVM中方法调用的字节码</h3>\n\n<p>我们来看下JVM中能够用来进行方法调用的五种字节码（表一）。字节b0和b1会组成起来，代表常量池中的c1。</p>\n\n<p><img src=\"https://deepinmind.oss-cn-beijing.aliyuncs.com/53.jpg\" alt=\"图\"></p>\n\n<p>可以通过编写Java代码、然后使用javap反编译class文件，来帮助我们了解不同的情况下会生成什么样的字节码。</p>\n\n<h3>虚函数表及方法重载</h3>\n\n<p>最常见的方法调用类型是invokevirtual，它对应的是虚分派（virtual dispatch）。虚分派这个术语意味着调用的方法要在运行时才能确定。要理解这点，需要知道的是当应用程序在运行时，每一个类在JVM中都会有一块内存来存储与该类型相关的元数据。这块区域又被称为klass（至少在HotSpot VM中是这样的），可以认为它是该类型在JVM中的呈现方式。</p>\n\n<p>在Java 7以及更早的版本中，klass元信息是存储在一块叫持久代的堆空间中的。由于Java堆中的对象一定会有一个对象头（称为oop），klass又被称为klassOops。在Java 8和Java 9中，klass元数据从Java堆中被移到了本地堆中，因此便不再需要对象头了。对Java开发人员来说，klass中的一些信息可以通过对应类型的Class&lt;?&gt;对象来获取到——不过它们是两个不同的概念。</p>\n\n<p>klass中最重要的一块区域叫做虚函数表（vtable）。本质上来说它是一个函数指针表，会指向这个类型所定义的方法的具体实现。当你通过invokevirtual来调用一个实例方法时，JVM会咨询虚函数表来看究竟要执行哪段代码。如果klass中没有这个方法的定义，JVM会通过klass指向父类的指针来继续查找。</p>\n\n<p>这个过程就是JVM中方法重写（override）的基本思路。为了使得这个过程更加高效，虚函数表的排列方式比较特殊。每个klass都会把父类中定义过的方法放在虚函数表的起始处。并且这些方法的排列顺序和父类是严格一致的。而这个类型所新增的独有方法会放在虚函数表的尾部。</p>\n\n<p>这意味着当一个子类重写了父类方法时，它在虚函数表中的位置和被重写的方法是一样的。这样查找重写的方法就非常简单了，因为它俩在虚函数表中的位置完全一致。</p>\n\n<p>图一的例子中包含类Pet，Cat, Bear以及接口Furry。</p>\n\n<p><img src=\"https://deepinmind.oss-cn-beijing.aliyuncs.com/51.jpg\" alt=\"图一\"></p>\n\n<p>Java 7中虚函数表的排列如图二所示。可以看到，图中展示的是拥有持久代的Java 7中的视图，因此这里是klassOops，并且有两个字长的对象头（在图中是m和kk）。如前所述，Java 8和Java 9中是没有这几项的，但其余的东西都一样。</p>\n\n<p><img src=\"https://deepinmind.oss-cn-beijing.aliyuncs.com/52.jpg\" alt=\"图二\"></p>\n\n<p>如果调用的是Cat::feed方法，JVM在Cat类中没有找到重写的实现，因此它会顺着指针去找Pet的klass。而它实现了feed()方法，因此会调到到它的代码。因为Java只支持简单继承，因此这样的虚函数表结构是没有问题的。这意味着一个类型只能有一个直接的父类（除了Object，它是没有父类的）。</p>\n\n<p>但invokeinterface就会有一些复杂了。比方说，groom()方法在虚表中的实现的位置就不是固定的了。 Cat::groom和Bear::groom的偏移量不同是由于它们的类继承结构是不同的。一个编译时只知道接口类型的对象，当调用它上面的方法时，就会增加额外的查找工作。</p>\n\n<p>注意的是尽管接口调口会有一些额外开销，但也不要为了做一些无谓的优化而不去使用接口。别忘了JVM还有JIT编译器，这种性能上的差别就由它来消除就好了。</p>\n\n<h3>方法调用的例子</h3>\n\n<p>我们再来看另一个例子。看下这段代码：</p>\n<div class=\"highlight\"><pre><code class=\"language-text\" data-lang=\"text\">Cat tom = new Cat();\nBear pooh = new Bear();\nFurry f;\n\ntom.groom();\npooh.groom();\n\nf = tom;\nf.groom();\n\nf = pooh;\nf.groom();\n</code></pre></div>\n<p>生成的字节码如下：</p>\n\n<div class=\"highlight\"><pre><code class=\"java\"><span class=\"nl\">Code:</span>\n<span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"k\">new</span>           <span class=\"err\">#</span><span class=\"mi\">2</span>      <span class=\"c1\">// class scratch/Cat</span>\n<span class=\"mi\">3</span><span class=\"o\">:</span> <span class=\"n\">dup</span>\n<span class=\"mi\">4</span><span class=\"o\">:</span> <span class=\"n\">invokespecial</span> <span class=\"err\">#</span><span class=\"mi\">3</span>      <span class=\"c1\">// Method scratch/Cat.&quot;&lt;init&gt;&quot;:()V</span>\n<span class=\"mi\">7</span><span class=\"o\">:</span> <span class=\"n\">astore_1</span>\n<span class=\"mi\">8</span><span class=\"o\">:</span> <span class=\"k\">new</span>           <span class=\"err\">#</span><span class=\"mi\">4</span>      <span class=\"c1\">// class scratch/Bear</span>\n<span class=\"mi\">11</span><span class=\"o\">:</span> <span class=\"n\">dup</span>\n<span class=\"mi\">12</span><span class=\"o\">:</span> <span class=\"n\">invokespecial</span> <span class=\"err\">#</span><span class=\"mi\">5</span>     <span class=\"c1\">// Method scratch/Bear.&quot;&lt;init&gt;&quot;:()V</span>\n<span class=\"mi\">15</span><span class=\"o\">:</span> <span class=\"n\">astore_2</span>\n<span class=\"mi\">16</span><span class=\"o\">:</span> <span class=\"n\">aload_1</span>\n<span class=\"mi\">17</span><span class=\"o\">:</span> <span class=\"n\">invokevirtual</span> <span class=\"err\">#</span><span class=\"mi\">6</span>     <span class=\"c1\">// Method scratch/Cat.groom:()V</span>\n<span class=\"mi\">20</span><span class=\"o\">:</span> <span class=\"n\">aload_2</span>\n<span class=\"mi\">21</span><span class=\"o\">:</span> <span class=\"n\">invokevirtual</span> <span class=\"err\">#</span><span class=\"mi\">7</span>     <span class=\"c1\">// Method scratch/Bear.groom:()V</span>\n<span class=\"mi\">24</span><span class=\"o\">:</span> <span class=\"n\">aload_1</span>\n<span class=\"mi\">25</span><span class=\"o\">:</span> <span class=\"n\">astore_3</span>\n<span class=\"mi\">26</span><span class=\"o\">:</span> <span class=\"n\">aload_3</span>\n<span class=\"mi\">27</span><span class=\"o\">:</span> <span class=\"n\">invokeinterface</span> <span class=\"err\">#</span><span class=\"mi\">8</span><span class=\"o\">,</span>  <span class=\"mi\">1</span>        <span class=\"c1\">// InterfaceMethod scratch/Furry.groom:()V</span>\n<span class=\"mi\">32</span><span class=\"o\">:</span> <span class=\"n\">aload_2</span>\n<span class=\"mi\">33</span><span class=\"o\">:</span> <span class=\"n\">astore_3</span>\n<span class=\"mi\">34</span><span class=\"o\">:</span> <span class=\"n\">aload_3</span>\n<span class=\"mi\">35</span><span class=\"o\">:</span> <span class=\"n\">invokeinterface</span> <span class=\"err\">#</span><span class=\"mi\">8</span><span class=\"o\">,</span>  <span class=\"mi\">1</span>        <span class=\"c1\">// InterfaceMethod scratch/Furry.groom:()V</span></code></pre></div>\n\n<p>27和35处的两次调用看起来是一样的，但实际上是两个不同的方法。27调用的是Cat::groom，而35处是Bear::groom。</p>\n\n<p>了解完invokevirtual和invokeinterface，invokespecial就好理解一些了。如果一个方法是通过invokespecial来调用的，那它一定没进行虚方法查找。JVM只会在虚表中的固定位置来查找请求的方法。invokespecial有三种使用场景：私有方法，父类方法，构造方法（在字节码中这个被转成一个叫<init>的方法）。这三种情况下都绝对不会出现虚查找或者重写。</p>\n\n<h3>final方法</h3>\n\n<p>再说一个不太常见的情况：final方法。看起来final方法应该归到invokespecial这类。但是Java语言规范中的13.4.17节中有提到：“将一个方法从final改成非final不能破坏已发布的二进制程序的兼容性”。</p>\n\n<p>假设下编译器已经把一个final方法的调用编译成了一条invokespecial指令。如果这个方法又改成了非final的话，那它就有可能被子类重写。再假设这个时间有一个子类的实例被传入到编译完的代码中。那么仍然执行invokespecial指令的话，就会调用到错误的实现。这和Java的面向对象的设计原则是有冲突的（严格来说，这是违反了里氏替换原则）。</p>\n\n<p>因此final方法的调用只能编译成invokevirtual指令。在实践中Java HotSpot VM会有一些优化能够检测出final方法并执行得更高效一些。</p>\n\n<h3>结论</h3>\n\n<p>本文我们学习了JVM支持的5种调用指令中的4种。还有一个没提到的是invokedynamic，这个指令非常有趣，包含的内容也很丰富，需要一篇文章来单独介绍。本文的姊妹篇就将会专门介绍下这个指令以及相关的一些主题。</p>\n\n<p><a href=\"https://www.oracle.com/technetwork/java/javamagazine/index.html\">英文原文链接</a></p>\n","descriptionType":"html","feedId":16958,"bgimg":"https://deepinmind.oss-cn-beijing.aliyuncs.com/53.jpg","linkMd5":"04f1ea1ae1cdd2e471792b9ec02e889f","destWidth":1558,"destHeight":626,"sourceBytes":409515,"destBytes":64190,"author":"","articleImgCdnMap":{"https://deepinmind.oss-cn-beijing.aliyuncs.com/53.jpg":null,"https://deepinmind.oss-cn-beijing.aliyuncs.com/51.jpg":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn15@2020_5/2020/09/07/04-58-56-445_35f078b349bc490e.webp","https://deepinmind.oss-cn-beijing.aliyuncs.com/52.jpg":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn13@2020_6/2020/09/07/04-58-54-824_0c25bc54fddcf05d.webp"},"publishedOrCreatedDate":1599454718136}],"record":{"createdTime":"2020-09-07 12:58:38","updatedTime":"2020-09-07 12:58:38","feedId":16958,"fetchDate":"Mon, 07 Sep 2020 04:58:38 +0000","fetchMs":791,"handleMs":3395,"totalMs":27740,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"2f206359adb0c109a1a58d9b6d6580df","hostName":"europe63*","requestId":"88540c81db0d417791a2a178f8b46e2c_16958","contentType":"text/xml","totalBytes":38006,"bgimgsTotal":1,"bgimgsGithubTotal":0,"articlesImgsTotal":3,"articlesImgsGithubTotal":2,"successGithubMap":{"myreaderx15":1,"myreaderx24":1},"failGithubMap":{"myreaderx23":1}},"feed":{"createdTime":"2020-09-07 02:14:01","updatedTime":"2020-09-07 02:14:01","id":16958,"name":"Java译站","url":"http://it.deepinmind.com/atom.xml","subscriber":197,"website":null,"icon":"http://it.deepinmind.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"http://it.deepinmind.com"},"noPictureArticleList":[{"createdTime":"2020-09-07 12:58:57","updatedTime":"2020-09-07 12:58:57","id":null,"feedId":16958,"linkMd5":"04f1ea1ae1cdd2e471792b9ec02e889f"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":38006,"tmpBgImgCdnBytes":0,"extra4":{"start":1599454709500,"total":0,"statList":[{"spend":5241,"msg":"获取xml内容"},{"spend":3395,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":5512,"msg":"正文链接上传到cdn"}]},"extra5":3,"extra6":3,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://deepinmind.oss-cn-beijing.aliyuncs.com/53.jpg","sourceStatusCode":200,"destWidth":1558,"destHeight":626,"sourceBytes":409515,"destBytes":64190,"targetWebpQuality":75,"feedId":16958,"totalSpendMs":10323,"convertSpendMs":36,"createdTime":"2020-09-07 12:58:38","host":"europe69*","referer":"http://it.deepinmind.com/jvm/2019/07/19/jvm-method-invocation","linkMd5ListStr":"04f1ea1ae1cdd2e471792b9ec02e889f,04f1ea1ae1cdd2e471792b9ec02e889f","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn8/contents/2020/09/07/04-58-48-135_f8319697257f3283.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Mon, 07 Sep 2020 04:58:48 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["8D1A:BB65:1B74756D:2125E1BB:5F55BDFC"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1599455382"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn8/contents/2020/09/07/04-58-48-135_f8319697257f3283.webp","historyStatusCode":[],"spendMs":359},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"399.9 KB","destSize":"62.7 KB","compressRate":"15.7%"},{"code":1,"isDone":false,"source":"https://deepinmind.oss-cn-beijing.aliyuncs.com/53.jpg","sourceStatusCode":200,"destWidth":1558,"destHeight":626,"sourceBytes":409515,"destBytes":64190,"targetWebpQuality":75,"feedId":16958,"totalSpendMs":3222,"convertSpendMs":35,"createdTime":"2020-09-07 12:58:48","host":"europe69*","referer":"http://it.deepinmind.com/jvm/2019/07/19/jvm-method-invocation","linkMd5ListStr":"04f1ea1ae1cdd2e471792b9ec02e889f,04f1ea1ae1cdd2e471792b9ec02e889f","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn8/contents/2020/09/07/04-58-51-453_f8319697257f3283.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Mon, 07 Sep 2020 04:58:51 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["8D1A:BB65:1B7478F5:2125F6A5:5F55BE0B"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1599455382"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn8/contents/2020/09/07/04-58-51-453_f8319697257f3283.webp","historyStatusCode":[],"spendMs":270},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"399.9 KB","destSize":"62.7 KB","compressRate":"15.7%"}],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-034.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-035.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://deepinmind.oss-cn-beijing.aliyuncs.com/52.jpg","sourceStatusCode":200,"destWidth":1100,"destHeight":554,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn13@2020_6/2020/09/07/04-58-54-824_0c25bc54fddcf05d.webp","sourceBytes":65187,"destBytes":25390,"targetWebpQuality":75,"feedId":16958,"totalSpendMs":3810,"convertSpendMs":19,"createdTime":"2020-09-07 12:58:51","host":"us-034*","referer":"http://it.deepinmind.com/jvm/2019/07/19/jvm-method-invocation","linkMd5ListStr":"04f1ea1ae1cdd2e471792b9ec02e889f","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"63.7 KB","destSize":"24.8 KB","compressRate":"38.9%"},{"code":1,"isDone":false,"source":"https://deepinmind.oss-cn-beijing.aliyuncs.com/51.jpg","sourceStatusCode":200,"destWidth":870,"destHeight":392,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn15@2020_5/2020/09/07/04-58-56-445_35f078b349bc490e.webp","sourceBytes":29619,"destBytes":12616,"targetWebpQuality":75,"feedId":16958,"totalSpendMs":5335,"convertSpendMs":17,"createdTime":"2020-09-07 12:58:51","host":"us-035*","referer":"http://it.deepinmind.com/jvm/2019/07/19/jvm-method-invocation","linkMd5ListStr":"04f1ea1ae1cdd2e471792b9ec02e889f","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"28.9 KB","destSize":"12.3 KB","compressRate":"42.6%"}],"successGithubMap":{"myreaderx15":1,"myreaderx24":1},"failGithubMap":{"myreaderx23":1}}