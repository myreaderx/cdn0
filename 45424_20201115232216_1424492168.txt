{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-11-16 07:21:43","updatedTime":"2020-11-16 07:21:43","title":"JDK approach to address deserialization Vulnerability","link":"https://access.redhat.com/blogs/766093/posts/3135411","description":"<div class=\"field field-name-body field-type-text-with-summary field-label-hidden \"> \n <p><a href=\"https://cwe.mitre.org/data/definitions/502.html\"><em>Java Deserialization of untrusted data</em></a> has been a security buzzword for the past couple of years with almost every application using native Java serialization framework being vulnerable to Java deserialization attacks. Since it's inception, there have been <a href=\"https://github.com/kantega/notsoserial\">many</a> <a href=\"https://github.com/Contrast-Security-OSS/contrast-rO0\">scattered</a> <a href=\"https://github.com/mbechler/serianalyzer\">attempts</a> to come up with a solution to best address this flaw. This article focuses on Java deserialization vulnerability and explains how Oracle provides a mitigation framework in it's latest Java Development Kit (JDK) version.</p> \n <h2>Background</h2> \n <p>Let's begin by reviewing the Java deserialization process. <a href=\"https://docs.oracle.com/javase/7/docs/platform/serialization/spec/serialTOC.html\">Java Serialization Framework</a> is JDK's built-in utility that allows Java objects to be converted into byte representation of the object and vice versa. The process of converting Java objects into their binary form is called serialization and the process of reading binary data to construct a Java object is called deserialization. In any enterprise environment the ability to save or retrieve the state of the object is a critical factor in building reliable distributed systems. For instance, a <a href=\"https://en.wikipedia.org/wiki/Java_Message_Service\">JMS</a> message may be serialized to a stream of bytes and sent over the wire to a JMS destination. A <a href=\"https://docs.oracle.com/javaee/6/tutorial/doc/gijqy.html\">RESTful</a> client application may serialize an <a href=\"https://www.oauth.com/oauth2-servers/access-tokens/\">OAuth token</a> to disk for future verification. Java's <a href=\"https://docs.oracle.com/javase/7/docs/platform/rmi/spec/rmiTOC.html\">Remote Method Invocation (RMI)</a> uses serialization under the hood to pass objects between JVMs. These are just some of the use cases where Java serialization is used.</p> \n <p><img src=\"https://access.redhat.com/sites/default/files/styles/large/public/seri_1.jpg?itok=G9gocPBg\" width=\"480\" height=\"204\" alt=\"\" class=\"image-large\" /></p> \n <h3>Inspecting the Flow</h3> \n <p>When the application code triggers the deserialization process, <a href=\"https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInputStream.html\">ObjectInputStream</a> will be initialized to construct the object from the stream of bytes. <em>ObjectInputStream</em> ensures the object graph that has been serialized is recovered. During this process, <em>ObjectInputStream</em> matches the stream of bytes against the classes that are available in the JVM's classpath.</p> \n <p><img src=\"https://access.redhat.com/sites/default/files/styles/large/public/sequence.jpg?itok=k83detyi\" width=\"480\" height=\"419\" alt=\"\" class=\"image-large\" /></p> \n <h2>So, what is the problem?</h2> \n <p>During deserialization process, when readObject() takes the byte stream to reconstruct the object, it looks for the <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/ObjectStreamConstants.html\">magic bytes</a> relevant to the object type that has been written to the serialization stream, to determine what object type (e.g. enum, array, String, etc.) it needs to resolve the byte stream to. If the byte stream can not be resolved to one of these types, then it will be resolved to an ordinary object <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/ObjectStreamConstants.html#TC_OBJECT\">(TC_OBJECT)</a>, and finally the local class for that ObjectStreamClass will be retrieved from the JVM's classpath. If the class is not found then an InvalidClassException will be thrown.</p> \n <p>The problem arises when readObject() is presented with a byte stream that has been manipulated to leverage classes that have a high chance of being available in the JVM's classpath, also known as <a href=\"https://access.redhat.com/blogs/766093/posts/2361811\">gadget classes</a>, and are vulnerable to Remote Code Execution (RCE). So far a <a href=\"https://github.com/kantega/notsoserial\">number of classes</a> have been identified to be vulnerable to RCE, however research is still ongoing to discover more of such classes. Now you might ask, how these classes can be used for RCE? Well, depending on the nature of the class, the attack can be materialized by constructing the state of that particular class with a malicious payload, which is serialized and is fed at the point in which serialized data is exchanged (i.e. Stream Source) in the above work flow. This tricks JDK to believe this is the trusted byte stream, and it will be deserialized by initializing the class with the payload. Depending on the payload this can have disastrous consequences.</p> \n <p><img src=\"https://access.redhat.com/sites/default/files/styles/large/public/jvm_gadget_0.jpg?itok=Pbs4XzuX\" width=\"480\" height=\"181\" alt=\"JVM vulnerable classes\" title=\"Exploit JVM gadget classes\" class=\"image-large\" /></p> \n <p>Of course the challenge for the adversary is to be able to access the stream source for this purpose, of which the details are outside the scope of this article. A good tool to review for further information on the subject is <a href=\"https://github.com/frohoff/ysoserial\">ysoserial</a>, which is arguably the best tool for generating payloads.</p> \n <h2>How to mitigate against deserialization?</h2> \n <p>Loosely speaking, mitigation against a deserialization vulnerability is accomplished by implementing a <a href=\"https://www.owasp.org/index.php/Deserialization_Cheat_Sheet#Guidance_on_Deserializing_Objects_Safely\">LookAheadObjectInputStream</a> strategy. The implementation needs to subclass the existing ObjectInputStream to override the <a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/ObjectInputStream.html#resolveClass(java.io.ObjectStreamClass)\">resolveClass()</a> method to verify if the class is allowed to be loaded. This approach appears to be an effective way of hardening against deserialization and usually consists of two implementation flavors: <a href=\"https://www.schneier.com/blog/archives/2011/01/whitelisting_vs.html\">whitelist or blacklist</a>. In whitelist approach, implementation only includes the acceptable business classes that are allowed to be deserialized and blocks other classes. Blacklist implementation on the other hand holds a set of well-known classes that are vulnerable and blocks them from being serialized.</p> \n <p>Both whitelist and blacklist have their own pros and cons, however, whitelist-based implementation proves to be a better way to mitigate against a deserialization flaw. It effectively follows the principle of checking the input against the good values which have always been a part of security practices. On the other hand, blacklist-based implementation heavily relies on the intelligence gathered around what classes have been vulnerable and gradually include them in the list which is easy enough to be missed or bypassed.</p> \n <pre><code>protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)\n                throws IOException, ClassNotFoundException {\n      String name = desc.getName();\n\n      if(isBlacklisted(name) ) {\n              throw new SecurityException(\"Deserialization is blocked for security reasons\");\n      }\n\n      if(isWhitelisted(name) ) {\n              throw new SecurityException(\"Deserialization is blocked for security reasons\");\n      }\n\n      return super.resolveClass(desc);\n}\n</code></pre>\n <h2>JDK's new Deserialization Filtering</h2> \n <p>Although ad hoc implementations exist to harden against a deserialization flaw, the official specification on how to deal with this issue is still lacking. To address this issue, Oracle has recently introduced <a href=\"http://openjdk.java.net/jeps/290\">serialization filtering</a> to improve the security of deserialization of data which seems to have incorporated both whitelist and blacklist scenarios. The new deserialization filtering is targeted for JDK 9, however it has been <a href=\"http://www.oracle.com/technetwork/security-advisory/cpujan2017-2881727.html\">backported</a> to some of the older versions of JDK as well.</p> \n <p>The core mechanism of deserialization filtering is based on an <a href=\"https://docs.oracle.com/javase/9/docs/api/java/io/ObjectInputFilter.html\">ObjectInputFilter</a> interface which provides a configuration capability so that incoming data streams can be validated during the deserialization process. The status check on the incoming stream is determined by <a href=\"http://download.java.net/java/jdk9/docs/api/java/io/ObjectInputFilter.Status.html#ALLOWED\">Status.ALLOWED</a>, <a href=\"http://download.java.net/java/jdk9/docs/api/java/io/ObjectInputFilter.Status.html#REJECTED\">Status.REJECTED</a>, or <a href=\"http://download.java.net/java/jdk9/docs/api/java/io/ObjectInputFilter.Status.html#UNDECIDED\">Status.UNDECIDED</a> arguments of an enum type within <em>ObjectInputFilter</em> interface. These arguments can be configured depending on the deserialization scenarios, for instance if the intention is to blacklist a class then the argument will return <em>Status.REJECTED</em> for that specific class and allows the rest to be deserialized by returning the <em>Status.UNDECIDED</em>. On the other hand if the intention of the scenario is to whitelist then <em>Status.ALLOWED</em> argument can be returned for classes that match the expected business classes. In addition to that, the filter also allows access to some other information for the incoming deserializing stream, such as the number of array elements when deserializing an array of class (<a href=\"https://docs.oracle.com/javase/9/docs/api/java/io/ObjectInputFilter.FilterInfo.html#arrayLength--\">arrayLength</a>), the depth of each nested objects (<a href=\"https://docs.oracle.com/javase/9/docs/api/java/io/ObjectInputFilter.FilterInfo.html#depth--\">depth</a>), the current number of object references (<a href=\"https://docs.oracle.com/javase/9/docs/api/java/io/ObjectInputFilter.FilterInfo.html#references--\">references</a>), and the current number of bytes consumed (<a href=\"https://docs.oracle.com/javase/9/docs/api/java/io/ObjectInputFilter.FilterInfo.html#streamBytes--\">streamBytes</a>). This information provides more fine-grained assertion points on the incoming stream and return the relevant status that reflects each specific use cases.</p> \n <h3>Ways to configure the Filter</h3> \n <p>JDK 9 filtering supports 3 ways of configuring the filter: <a href=\"http://openjdk.java.net/jeps/290\">custom filter</a>, <a href=\"http://openjdk.java.net/jeps/290\">process-wide filter</a> also known as global filter, and <a href=\"http://www.oracle.com/technetwork/java/javase/8u121-relnotes-3315208.html\">built-in filters</a> for the RMI registry and <a href=\"https://docs.oracle.com/javase/8/docs/platform/rmi/spec/rmi-arch4.html\">Distributed Garbage Collection (DGC)</a> usage.</p> \n <h4>Case-based Filters</h4> \n <p>The configuration scenario for a custom filter occurs when a deserialization requirement is different from any other deserialization process throughout the application. In this use case a custom filter can be created by implementing the <em>ObjectInputFilter</em> interface and override the <em>checkInput(FilterInfo filterInfo)</em> method.</p> \n <pre><code>static class VehicleFilter implements ObjectInputFilter {\n        final Class&lt;?&gt; clazz = Vehicle.class;\n        final long arrayLength = -1L;\n        final long totalObjectRefs = 1L;\n        final long depth = 1l;\n        final long streamBytes = 95L;\n\n        public Status checkInput(FilterInfo filterInfo) {\n            if (filterInfo.arrayLength() &lt; this.arrayLength || filterInfo.arrayLength() &gt; this.arrayLength\n                    || filterInfo.references() &lt; this.totalObjectRefs || filterInfo.references() &gt; this.totalObjectRefs\n                    || filterInfo.depth() &lt; this.depth || filterInfo.depth() &gt; this.depth || filterInfo.streamBytes() &lt; this.streamBytes\n                    || filterInfo.streamBytes() &gt; this.streamBytes) {\n                return Status.REJECTED;\n            }\n\n            if (filterInfo.serialClass() == null) {\n                return Status.UNDECIDED;\n            }\n\n            if (filterInfo.serialClass() != null &amp;&amp; filterInfo.serialClass() == this.clazz) {\n                return Status.ALLOWED;\n            } else {\n                return Status.REJECTED;\n            }\n        }\n    }\n</code></pre>\n <p>JDK 9 has added two methods to the ObjectInputStream class allowing the above filter to be set/get for the current ObjectInputStream:</p> \n <pre><code>public class ObjectInputStream\n    extends InputStream implements ObjectInput, ObjectStreamConstants {\n\n    private ObjectInputFilter serialFilter;\n    ...\n    public final ObjectInputFilter getObjectInputFilter() {\n        return serialFilter;\n    }\n\n    public final void setObjectInputFilter(ObjectInputFilter filter) {\n        ...\n        this.serialFilter = filter;\n    }\n    ...\n} \n</code></pre>\n <p>Contrary to JDK 9, latest JDK 8 (1.8.0_144) seems to only allow filter to be set on <em>ObjectInputFilter.Config.setObjectInputFilter(ois, new VehicleFilter());</em> at the moment.</p> \n <h4>Process-wide (Global) Filters</h4> \n <p>Process-wide filter can be configured by setting <a href=\"https://docs.oracle.com/javase/9/docs/api/java/io/ObjectInputFilter.Config.html\">jdk.serialFilter</a> as either a <a href=\"https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html\">system property</a> or a <a href=\"http://docs.oracle.com/javase/7/docs/technotes/guides/security/PolicyFiles.html\">security property</a>. If the system property is defined then it is used to configure the filter; otherwise the filter checks for the security property (i.e. <strong>jdk1.8.0_144/jre/lib/security/java.security</strong>) to configure the filter.</p> \n <p>The value of <em>jdk.serialFilter</em> is configured as a sequence of patterns either by checking against the class name or the limits for incoming byte stream properties. Patterns are separated by semicolon and whitespace is also considered to be part of a pattern. Limits are checked before classes regardless of the order in which the pattern sequence is configured. Below are the limit properties which can be used during the configuration:</p> \n <pre><code>- maxdepth=value // the maximum depth of a graph\n- maxrefs=value // the maximum number of the internal references\n- maxbytes=value // the maximum number of bytes in the input stream\n- maxarray=value // the maximum array size allowed\n</code></pre>\n <p>Other patterns match the class or package name as returned by <em>Class.getName(). Class/Package</em> patterns accept asterisk (*), double asterisk (**), period (.), and forward slash (/) symbols as well. Below are a couple pattern scenarios that could possibly happens:</p> \n <pre><code>// this matches a specific class and rejects the rest\n\"jdk.serialFilter=org.example.Vehicle;!*\" \n\n // this matches all classes in the package and all subpackages and rejects the rest \n- \"jdk.serialFilter=org.example.**;!*\" \n\n// this matches all classes in the package and rejects the rest \n- \"jdk.serialFilter=org.example.*;!*\" \n\n // this matches any class with the pattern as a prefix\n- \"jdk.serialFilter=*;\n</code></pre>\n <h4>Built-in Filters</h4> \n <p>JDK 9 has also introduced additional built-in, configurable filters mainly for <a href=\"http://www.oracle.com/technetwork/java/javase/8u121-relnotes-3315208.html\">RMI Registry and Distributed Garbage Collection (DGC) </a>. Built-in filters for RMI Registry and DGC white-list classes that are expected to be used in either of these services. Below are classes for both RMIRegistryImpl and DGCImp:</p> \n <p><strong>RMIRegistryImpl</strong></p> \n <pre><code>java.lang.Number\njava.rmi.Remote\njava.lang.reflect.Proxy\nsun.rmi.server.UnicastRef\nsun.rmi.server.RMIClientSocketFactory\nsun.rmi.server.RMIServerSocketFactory\njava.rmi.activation.ActivationID\njava.rmi.server.UID\n</code></pre>\n <p><strong>DGCImpl</strong></p> \n <pre><code>java.rmi.server.ObjID\njava.rmi.server.UID\njava.rmi.dgc.VMID\njava.rmi.dgc.Lease\n</code></pre>\n <p>In addition to these classes, users can also add their own customized filters using <strong>sun.rmi.registry.registryFilter</strong> and <strong>sun.rmi.transport.dgcFilter</strong> system or security properties with the property pattern syntax as described in previous section.</p> \n <h2>Wrapping up</h2> \n <p>While Java deserialization is not a vulnerability itself, deserialization of untrusted data using JDK's native serialization framework is. It is important to differentiate between the two, as the latter is introduced by a bad application design rather than being a flaw. Java deserialization framework prior to <a href=\"http://openjdk.java.net/jeps/290\">JEP 290</a> however, did not have any validation mechanism to verify the legitimacy of the objects. While there are a number of ways to mitigate against JDK's lack of assertion on deserializing objects, there is no concrete specification to deal with this flaw within the JDK itself. With <a href=\"http://openjdk.java.net/jeps/290\">JEP 290</a>, Oracle introduced a new filtering mechanism to allow developers to configure the filter based on a number of deserialization scenarios. The new filtering mechanism seems to have made it easier to mitigate against deserialization of untrusted data should the need arises.</p> \n</div>\n<div class=\"form-item form-type-item\"> \n <label>Language </label> English \n</div> \n<div id=\"comment-wrapper-nid-3135411\"></div>\n<div class=\"field field-name-field-kcs-a-category-select field-type-taxonomy-term-reference field-label-above \"> \n <h2 class=\"field-label\"> Category </h2> Secure\n</div>\n<div class=\"field field-name-field-kcs-tags-select field-type-taxonomy-term-reference field-label-above \"> \n <h2 class=\"field-label\"> Tags </h2> java\n</div>","descriptionType":"text/html","publishedDate":"Wed, 21 Feb 2018 14:30:00 +0000","feedId":45424,"bgimg":"https://access.redhat.com/sites/default/files/styles/large/public/seri_1.jpg?itok=G9gocPBg","linkMd5":"a4883ea13075d7383a5f60217446e3f4","destWidth":480,"destHeight":204,"sourceBytes":39314,"destBytes":7242,"author":"Hooman Broujerdi","articleImgCdnMap":{"https://access.redhat.com/sites/default/files/styles/large/public/seri_1.jpg?itok=G9gocPBg":null,"https://access.redhat.com/sites/default/files/styles/large/public/sequence.jpg?itok=k83detyi":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn50@2020_4/2020/11/15/23-22-15-047_b2918f7d323b6505.webp","https://access.redhat.com/sites/default/files/styles/large/public/jvm_gadget_0.jpg?itok=Pbs4XzuX":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn51@2020_4/2020/11/15/23-21-45-566_c1232c0ee1519da3.webp"},"publishedOrCreatedDate":1605482503591}],"record":{"createdTime":"2020-11-16 07:21:43","updatedTime":"2020-11-16 07:21:43","feedId":45424,"fetchDate":"Sun, 15 Nov 2020 23:21:43 +0000","fetchMs":187,"handleMs":14,"totalMs":32820,"newArticles":0,"totalArticles":25,"status":1,"type":0,"ip":"aa5b771909b552db8ae765322bbc0947","hostName":"europe61*","requestId":"86b3780a48664bfe841f82229db1bb1e_45424","contentType":"application/rss+xml; charset=utf-8","totalBytes":15284,"bgimgsTotal":1,"bgimgsGithubTotal":0,"articlesImgsTotal":3,"articlesImgsGithubTotal":2,"successGithubMap":{"myreaderx15":1,"myreaderx27":1},"failGithubMap":{"myreaderx14":1}},"feed":{"createdTime":"2020-09-07 03:38:11","updatedTime":"2020-09-07 05:56:13","id":45424,"name":"Red Hat Security Blog Blog Posts","url":"https://access.redhat.com/blogs/766093/feed","subscriber":70,"website":null,"icon":"https://access.redhat.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx61/cdn94@2020_6/2020/09/06/21-56-12-542_5d61952b23efae56.ico","description":"These blog posts are a part of the Red Hat Security Blog.","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2020-11-16 07:22:15","updatedTime":"2020-11-16 07:22:15","id":null,"feedId":45424,"linkMd5":"a4883ea13075d7383a5f60217446e3f4"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":15284,"tmpBgImgCdnBytes":0,"extra4":{"start":1605482503156,"total":0,"statList":[{"spend":421,"msg":"获取xml内容"},{"spend":14,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":31155,"msg":"正文链接上传到cdn"}]},"extra5":3,"extra6":3,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://access.redhat.com/sites/default/files/styles/large/public/seri_1.jpg?itok=G9gocPBg","sourceStatusCode":200,"destWidth":480,"destHeight":204,"sourceBytes":39314,"destBytes":7242,"targetWebpQuality":75,"feedId":45424,"totalSpendMs":106,"convertSpendMs":11,"createdTime":"2020-11-16 07:21:44","host":"us-006*","referer":"https://access.redhat.com/blogs/766093/posts/3135411","linkMd5ListStr":"a4883ea13075d7383a5f60217446e3f4,a4883ea13075d7383a5f60217446e3f4","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn43/contents/2020/11/15/23-21-44-561_f929905cec1b0993.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Sun, 15 Nov 2020 23:21:44 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["8ABC:4689:11C3DD1:29815DA:5FB1B808"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1605484456"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn43/contents/2020/11/15/23-21-44-561_f929905cec1b0993.webp","historyStatusCode":[],"spendMs":42},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"7.1 KB","compressRate":"18.4%","sourceSize":"38.4 KB"},{"code":1,"isDone":false,"source":"https://access.redhat.com/sites/default/files/styles/large/public/seri_1.jpg?itok=G9gocPBg","sourceStatusCode":200,"destWidth":480,"destHeight":204,"sourceBytes":39314,"destBytes":7242,"targetWebpQuality":75,"feedId":45424,"totalSpendMs":89,"convertSpendMs":23,"createdTime":"2020-11-16 07:21:44","host":"us-006*","referer":"https://access.redhat.com/blogs/766093/posts/3135411","linkMd5ListStr":"a4883ea13075d7383a5f60217446e3f4,a4883ea13075d7383a5f60217446e3f4","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn43/contents/2020/11/15/23-21-44-737_f929905cec1b0993.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Sun, 15 Nov 2020 23:21:44 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["8ABC:4689:11C3DDD:29815EB:5FB1B808"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1605484456"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn43/contents/2020/11/15/23-21-44-737_f929905cec1b0993.webp","historyStatusCode":[],"spendMs":39},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"7.1 KB","compressRate":"18.4%","sourceSize":"38.4 KB"},null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://europe-56.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://europe-57.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://access.redhat.com/sites/default/files/styles/large/public/jvm_gadget_0.jpg?itok=Pbs4XzuX","sourceStatusCode":200,"destWidth":480,"destHeight":181,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn51@2020_4/2020/11/15/23-21-45-566_c1232c0ee1519da3.webp","sourceBytes":38238,"destBytes":5796,"targetWebpQuality":75,"feedId":45424,"totalSpendMs":1573,"convertSpendMs":5,"createdTime":"2020-11-16 07:21:44","host":"europe-57*","referer":"https://access.redhat.com/blogs/766093/posts/3135411","linkMd5ListStr":"a4883ea13075d7383a5f60217446e3f4","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"5.7 KB","compressRate":"15.2%","sourceSize":"37.3 KB"},{"code":1,"isDone":false,"source":"https://access.redhat.com/sites/default/files/styles/large/public/sequence.jpg?itok=k83detyi","sourceStatusCode":200,"destWidth":480,"destHeight":419,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn50@2020_4/2020/11/15/23-22-15-047_b2918f7d323b6505.webp","sourceBytes":73471,"destBytes":9488,"targetWebpQuality":75,"feedId":45424,"totalSpendMs":1027,"convertSpendMs":8,"createdTime":"2020-11-16 07:22:14","host":"europe-57*","referer":"https://access.redhat.com/blogs/766093/posts/3135411","linkMd5ListStr":"a4883ea13075d7383a5f60217446e3f4","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"9.3 KB","compressRate":"12.9%","sourceSize":"71.7 KB"}],"successGithubMap":{"myreaderx15":1,"myreaderx27":1},"failGithubMap":{"myreaderx14":1}}