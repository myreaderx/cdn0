{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-10 00:23:17","updatedTime":"2020-10-10 00:23:17","title":"Speeding up Javascript Test Time 1000x","link":"https://medium.com/p/460c528418e7","description":"<p>Eight months ago when I ran our core API tests at Shyp, it took 100 seconds from starting the test to seeing output on the screen. Today it takes about 100 milliseconds:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*hwzje9MbyeyFnNHB0YDg9Q.gif\" /></figure><h3>Why Bother?</h3><p>There are a lot of different demands on your time, why is a speedy test framework so important? Here are a few reasons we put a premium on being able to run tests quickly.</p><ol><li><strong>Deployments get faster.</strong> Our build/deployment server runs every test before a deployment. Making our tests faster means that we spend less time between pushing code and seeing it live in production. In situations where production is broken and we need to push a fix, faster tests mean we can get that fix to production more quickly.</li><li><strong>Gains accrue over time.</strong> We run tests 400–500 times a day; a ten second improvement in every test run translates to an hour of saved developer time, <em>every day</em>.</li><li><strong>Slow tests lead to context switches. Context switches are harmful.</strong> Distractions are everywhere with Slack, push notifications and open-plan offices. A ten or twenty second delay between kicking off a test run and viewing the results means you might be tempted to check email or Twitter or do any other activity which causes you to lose focus on the task at hand. Faster tests mean you can stay focused more easily.</li><li>Our target is to get feedback within 100ms; that’s <a href=\"http://www.nngroup.com/articles/response-times-3-important-limits/\">about as much time as a UI can take before it stops feeling responsive</a> and your mind starts to wander.</li><li><strong>Fast tests lead to better code.</strong> We are subconsciously biased against things that are slow. <a href=\"http://highscalability.com/latency-everywhere-and-it-costs-you-sales-how-crush-it\">Amazon famously found that 100ms of latency costs 1% of sales.</a> You might want to refactor a module, but subconsciously decide not to, because refactoring implies running the tests, and the tests are slow. You might not write an extra test you really should write, because it means <em>running the test suite again</em>, and the tests are slow. You might decide <a href=\"http://yellerapp.com/posts/2015-03-16-incuriosity-killed-the-infrastructure.html\">not to be curious about a test anomaly</a>, because narrowing down the issue would require running the tests, and the tests are slow.</li></ol><p>For these reasons, it’s important to us that we start to see test output in under 100ms. Fortunately, we were able to hit that goal. How did we do it?</p><h3>Measuring Performance</h3><p>The first step to making anything faster is to measure how fast or slow it is. At a minimum, you’ll want to measure:</p><ul><li>How long it takes before the first test starts running</li><li>How long it takes to perform any global, per-test setup/teardown actions</li><li>Minimum amount of time to do a database read (for us, 4ms)</li><li>How long each test takes. If you run your tests with <a href=\"http://mochajs.org/\">mocha</a>, I encourage you to set the — slow flag to 2 (milliseconds) so you can clearly see how long each test takes to run.</li></ul><p>There’s <a href=\"http://unix.stackexchange.com/a/26797/9519\">an awesome Unix tool called ts</a> (available on Macs via brew install moreutils) that will annotate every line of your test output with a timestamp. Pipe your test output through ts like so:</p><pre>mocha test/api/responses/notFound.test.js | ts &#39;[%Y-%m-%d %H:%M:%.S]&#39;</pre><p>And you’ll get test output annotated with timestamps with millisecond precision; all you need to do is find the right place to put console.log lines.</p><pre>[2015-04-19 21:53:45.730679] verbose: request hook loaded successfully. <br>[2015-04-19 21:53:45.731032] verbose: Loading the app&#39;s models and adapters... <br>[2015-04-19 21:53:45.731095] verbose: Loading app models... <br>[2015-04-19 21:53:47.928104] verbose: Loading app adapters... <br>[2015-04-19 21:53:47.929343] verbose: Loading blueprint middleware...</pre><p>We observed right away that a) our Node framework requires a <em>ton</em> of files before starting a test run, b) require is synchronous, and <em>really</em> slow in Node (on the order of milliseconds per file imported), and c) There were a <em>ton</em> of stat() syscalls to try and load modules in places where those modules did not exist.</p><p>The latter problem is <a href=\"https://kev.inburke.com/kevin/node-require-is-dog-slow/\">documented in more detail on my personal blog</a>, and there have been two promising developments in that area. First, <a href=\"http://glebbahmutov.com/\">Gleb Bahmutov</a> developed <a href=\"https://github.com/bahmutov/cache-require-paths\">the cache-require-paths library</a>, which helps Node remember where it found a file the last time it was imported, and avoids many wasteful/incorrect file seeks. Gleb observed a 36–38% speedup when loading an Express project — our speedup was closer to 20%, but we are still really glad this tool exists.</p><p>Second, <a href=\"https://github.com/pierreinglebert\">Pierre Ingelbert</a> <a href=\"https://github.com/nodejs/io.js/pull/1920\">submitted a patch</a> to io.js to avoid extraneous stat() syscalls in directories that do not exist. This patch was part of the io.js 2.3.1 release.</p><p>We run our tests in a virtual machine, so our development environment matches production. The core api project is shared between the host machine (usually a Mac) and the VM. Loading the test suite means that a lot of files in the node_modules directory are being loaded. If that node_modules folder lives inside the folder that’s being shared, the VM will have to reach across the system boundary to read it, which is much slower than reading a file inside the virtual machine.</p><p>It was clear we needed to install our node_modules folder somewhere inside the VM, but outside of the shared folder. Node’s NODE_PATH environment variable provides a mechanism for loading a folder saved elsewhere on the filesystem, but our Javascript framework <a href=\"https://github.com/balderdashy/sails/issues/2505\">hard-codes the location of the node_modules folder</a> in its imports, so it failed to find the files we had placed elsewhere.</p><p>Instead we installed the node_modules folder elsewhere and symlinked it into place. Here’s a bash snippet you can use to replicate this behavior.</p><pre>pushd ~/api <br>    npm install --prefix /opt/lib/node_modules <br>    ln -s /opt/lib/node_modules ~/api/node_modules <br>popd</pre><p><em>Savings</em>: This sped up test initialization time by <strong>a whopping 75%</strong>, or one minute and fifteen seconds.</p><h3>More Specific Regex</h3><p>We used to specify a test to run by typing mocha -g ‘testname’ at the command line. Unfortunately, mocha always loads a mocha.opts file if it is present, and our mocha.opts file hard coded a filename regex that matched every single test file in our system (100+ files). We added a new test runner and instructed people to manually specify the test file they want to run.</p><p><em>Savings</em>: This sped up test run time by about 50% (10–13 seconds).</p><h3>Stubbed database reads/writes</h3><p>The old test framework would do authentication by writing a valid access token to the database, then reading/returning the valid access token in the controller. We introduced a synchronous signIn test helper that stubbed these two network calls.</p><p><em>Savings</em>: 10–20ms across ~600 tests, a 6–12 second improvement.</p><h3>Batched writes</h3><p>In some instances we need to instantiate test environments with users, drivers and other objects. Previously the test helper would write one record, read the id, and then write a record that depended on it. By generating ids up front, we were able to perform multiple writes at the same time.</p><p><em>Savings</em>: 10–20ms across ~200 tests, a 2–4 second improvement.</p><h3>Faster test cleanup</h3><p>Between each test, we delete all records from the database. The helper responsible for this would open one database connection per table and then each one would call DELETE FROM &#60;tablename&#62;. Not only would this occasionally hang with no stack trace, it meant that the speed of the cleanup operation was the same as the slowest DELETE query.</p><p>Instead we grouped all of the deletes and sent them to the database in a single connection (e.g. Model.query(“DELETE FROM users; DELETE FROM pickups; …”)). Some reading online indicated <a href=\"https://stackoverflow.com/a/11423886/329700\">TRUNCATE would be faster than DELETE</a>; plus, it lets you use one command for everything, e.g. TRUNCATE TABLE users, pickups, …. For large datasets it is likely faster, however we observed this to be much slower than DELETE for our small test data sets, on the order of 200ms per action.</p><p>An optimization we’d like to implement in the future would only issue DELETEs for tables that have dirty data, which would also let us avoid issuing a DELETE if a test didn’t hit the database. Currently we’re not sure about the best way to hook into the ORM and determine this.</p><p>We’re also interested in running every test in a transaction. Unfortunately the ORM we use <a href=\"https://github.com/balderdashy/waterline/issues/755\">doesn’t support transactions</a>, and we are very worried about upgrading it.</p><p><em>Savings</em>: Clearing the DB used to take 14–30ms per test, now takes 3–11ms, a ~20 second improvement.</p><h3>Don’t Load Sails</h3><p>Our Javascript framework (Sails.js) needs to require every single model, controller, and service before it runs; this is the slowest part of the test run by far.</p><p>Where possible, we try to avoid loading Sails when writing/running tests. We try to implement most of our business logic in plain Javascript classes or modules, outside of models and controllers. If this logic operates on objects in memory, you can use fake model objects in your tests — var user = {email: ‘foo@bar.com’}, and avoid loading Sails entirely.</p><p>Avoiding Sails isn’t possible in every situation, but we’ve found it’s a useful design principle — it helps us separate our business logic and our data storage layer, and will make it easier for us to move off Sails in the future.</p><p>For more on this technique, you should check out <a href=\"https://www.destroyallsoftware.com/screencasts\">Gary Bernhardt’s excellent <em>Destroy All Software</em> series of videos</a>. He gave <a href=\"https://www.youtube.com/watch?v=RAxiiRPHS9k\">a great introduction to his “don’t load Rails” style of testing at Pycon in 2012</a> (summary <a href=\"http://pycon-2012-notes.readthedocs.org/en/latest/fast_tests_slow_tests.html\">here</a>).</p><h3>Tighter Editor Integration</h3><p>Most of the time the test you want to run is the same one that is right underneath your cursor, so manually specifying the filename at the command line wastes time. The awesome <a href=\"https://github.com/janko-m/vim-test\">vim-test plugin</a> makes it incredibly easy to map leader commands for running the current suite of tests or the current file. It worked on literally the first try; I’ve rarely been so impressed with a piece of software.</p><p>Some of our team members use <a href=\"http://www.sublimetext.com/\">Sublime Text</a>, and we haven’t figured out how to get their editor integration set up yet. It’s on our to do list for this quarter.</p><p><em>Savings</em>: One context switch and ~1–3 seconds per test run.</p><h3>Avoid Reloading All Dependencies Every Test Run</h3><p>After all of this we were able to get test run time down to about 7 seconds. Most of this time is spent waiting for v8 to parse/require ~500 files.</p><p>We can go much faster if we loaded every dependency once when we sat down at the computer, and then only re-required the files that had changed. You can do this by hacking with Node’s require.cache. I don’t recommend it for production, but it works just fine.</p><p>Anyway the end result of this is <a href=\"https://github.com/Shyp/lucifer\">a command line client and a server called Lucifer</a>. Start Lucifer when you sit down at your computer. When we change a file, we call lucifer invalidate [filename] (or configure our editors to do this for us), which invalidates the cache for that file, and then re-requires it. Then you can kick off a test run by calling lucifer run [filename] from the command line (or from your editor). When you kick off a test every dependency is ready to go, which means your tests start in about 100ms.</p><p><em>Savings</em>: Test initialization time went from 6–7 seconds to 100ms, a 60x speedup.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*hwzje9MbyeyFnNHB0YDg9Q.gif\" /></figure><h3>Caveats</h3><p>This is similar to the approach taken by <a href=\"https://github.com/sporkrb/spork\">spork</a> in Ruby — keep a server up and reload changed files. The same failure modes that apply to Spork — increased complexity, subtle inconsistencies, failure to reload files — apply here. In particular, we’ve found that sometimes Node doesn’t wipe the cache for files that have changed, so new code won’t get loaded. This is probably a result of our limited understanding of how and where Node caches loaded dependencies. We always do a clean run of our test suite on our build server before deploying to production.</p><p>Still, it’s been very useful in certain situations — if you’ve flushed out a method or a controller and are writing several tests in quick succession, the only file that’s changing is your test file, so the chance of subtle dependency breakage is low.</p><h3>Lessons</h3><p><em>Your slow test suite isn’t hopeless!</em> But improving it is probably going to take a concerted investment. You also have to get know your stack really well, which is probably a good idea anyway. Look at all of the places we had to inspect to find performance improvements:</p><ul><li>File reads in a virtual machine</li><li>The require function in Node</li><li>Test workflow</li><li>Use batching to avoid database connection overhead</li><li>Editor integration</li></ul><p>You don’t know what will be slow until you measure it. You’ll also want to know how to use basic profiling tools for your stack:</p><ul><li><a href=\"http://unix.stackexchange.com/a/26797/9519\">the ts command</a></li><li>Strace/DTruss (not covered in depth here, but extremely useful for observing system calls/timings for a running process)</li><li>Logging / timing for queries that hit the database</li><li>Logging and profiling your test run time</li></ul><h3>We’re hiring!</h3><p>Our team of ten engineers powers four warehouses, four mobile apps, hundreds of drivers and loads of pickups every day. We’re looking for people who are curious about the tools they use and eager to improve their productivity day in and day out. <a href=\"https://shyp.com/jobs\">We’d love to hear from you</a>; you can’t waste our time by getting in touch.</p><h3>Errata</h3><p>Some odd things I found while profiling:</p><ul><li>Accessing the .stack property of an Error object <a href=\"https://groups.google.com/forum/#!searchin/nodejs/stack$20slow/nodejs/-U2hIDWcc30/5WRuCeoA8HgJ\">can block a process for up to 100ms</a>. Stub your logger before running tests and you can see a quick win.</li><li>Some imports are extremely slow; require(‘faker’), for example, <a href=\"https://github.com/Marak/faker.js/issues/167\">tacks a 60ms penalty onto your test runs</a>. If you don’t need the locale data, you can speed this up quite a bit by only loading locales that you need.</li></ul><p><em>Originally published at </em><a href=\"https://shyp.github.io/2015/07/13/speed-up-your-javascript-tests.html\"><em>shyp.github.io</em></a><em> on July 12, 2015.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=460c528418e7\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/shyp-engineering/speeding-up-javascript-test-time-1000x-460c528418e7\">Speeding up Javascript Test Time 1000x</a> was originally published in <a href=\"https://medium.com/shyp-engineering\">Shyp Engineering</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>","descriptionType":"html","publishedDate":"Mon, 18 Jul 2016 17:53:49 +0000","feedId":38834,"bgimg":"https://cdn-images-1.medium.com/max/1024/1*hwzje9MbyeyFnNHB0YDg9Q.gif","linkMd5":"faac916105be718c18473a113cfe3fed","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn22@2020_5/2020/10/09/16-23-38-742_1f157bd8c58a926b.webp","destWidth":1024,"destHeight":715,"sourceBytes":62133694,"destBytes":4359654,"author":"Kevin Burke","articleImgCdnMap":{"https://cdn-images-1.medium.com/max/1024/1*hwzje9MbyeyFnNHB0YDg9Q.gif":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn22@2020_5/2020/10/09/16-23-38-742_1f157bd8c58a926b.webp","https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=460c528418e7":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn25@2020_3/2020/10/09/16-23-41-971_fe44bcf5692c3747.webp"},"publishedOrCreatedDate":1602260597337}],"record":{"createdTime":"2020-10-10 00:23:17","updatedTime":"2020-10-10 00:23:17","feedId":38834,"fetchDate":"Fri, 09 Oct 2020 16:23:17 +0000","fetchMs":93,"handleMs":12,"totalMs":25713,"newArticles":0,"totalArticles":3,"status":1,"type":0,"ip":"7b37e896e03ef23ae487347d9632f8b0","hostName":"us-022*","requestId":"7b9aa93d6a4742a6877990c715a13323_38834","contentType":"text/xml; charset=UTF-8","totalBytes":4359726,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":2,"articlesImgsGithubTotal":2,"successGithubMap":{"myreaderx22":1,"myreaderx19":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 03:15:25","updatedTime":"2020-09-07 05:30:55","id":38834,"name":"Shyp Engineering - Medium","url":"https://medium.com/feed/shyp-engineering","subscriber":83,"website":null,"icon":"https://cdn-images-1.medium.com/proxy/1*TGH72Nnw24QL3iV9IOm4VA.png","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn24@2020_2/2020/09/06/21-30-54-318_7b1d3de1dd751a79.png","description":"All things engineering at Shyp - Medium","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":4359654,"tmpBodyImgCdnBytes":72,"tmpBgImgCdnBytes":0,"extra4":{"start":1602260597230,"total":0,"statList":[{"spend":96,"msg":"获取xml内容"},{"spend":12,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":1345,"msg":"正文链接上传到cdn"}]},"extra5":2,"extra6":2,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://europe-58.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://cdn-images-1.medium.com/max/1024/1*hwzje9MbyeyFnNHB0YDg9Q.gif","sourceStatusCode":200,"destWidth":1024,"destHeight":715,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn22@2020_5/2020/10/09/16-23-38-742_1f157bd8c58a926b.webp","sourceBytes":62133694,"destBytes":4359654,"targetWebpQuality":1,"feedId":38834,"totalSpendMs":24079,"convertSpendMs":17825,"createdTime":"2020-10-10 00:23:17","host":"europe70*","referer":"https://medium.com/p/460c528418e7","linkMd5ListStr":"faac916105be718c18473a113cfe3fed,faac916105be718c18473a113cfe3fed,faac916105be718c18473a113cfe3fed","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"59.3 MB","destSize":"4.2 MB","compressRate":"7%"},{"code":1,"isDone":false,"source":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=460c528418e7","sourceStatusCode":200,"destWidth":1,"destHeight":1,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn25@2020_3/2020/10/09/16-23-41-971_fe44bcf5692c3747.webp","sourceBytes":43,"destBytes":72,"targetWebpQuality":75,"feedId":38834,"totalSpendMs":1170,"convertSpendMs":3,"createdTime":"2020-10-10 00:23:41","host":"europe-58*","referer":"https://medium.com/p/460c528418e7","linkMd5ListStr":"faac916105be718c18473a113cfe3fed","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"43 B","destSize":"72 B","compressRate":"167.4%"}],"successGithubMap":{"myreaderx22":1,"myreaderx19":1},"failGithubMap":{}}