{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-13 22:47:22","updatedTime":"2020-10-13 22:47:22","title":"How Grammarly Built a Native Keyboard for Android","link":"https://www.grammarly.com/blog/?p=39990","description":"<img width=\"235\" height=\"124\" src=\"https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/Grammarly_Android-Keyboard_Post-Header-235x124.png\" class=\"webfeedsFeaturedVisual wp-post-image\" alt=\"\" style=\"display: block; margin-bottom: 5px; clear:both;max-width: 100%;\" link_thumbnail=\"\" /><p><span style=\"font-weight: 400;\">The Grammarly app on both Android and iOS is a native keyboard. The motivation behind building a keyboard, as opposed to a traditional mobile app like a text editor, is the same principle behind Grammarly’s browser extension: the writing assistant should be available wherever the user is writing. The Grammarly Keyboard on Android is used over 70 times per day by the average user, and it meaningfully impacts how people communicate using their phones. </span></p>\n<p><span style=\"font-weight: 400;\">The decision to build the Grammarly app as a native keyboard has introduced our team to some fascinating and complex problems in mobile app architecture, UX, performance, and testing. This blog post will look at Android in particular, where the Grammarly app is unique—in that unlike most Android apps, it’s not an activity or a fragment. The UI is constrained and constantly changing. Each keypress on the Grammarly Keyboard triggers a number of concurrent events. The keyboard looks for suggestions from its on-device models, and as that request is being processed, it also checks with the backend to get an in-depth analysis of the text you typed. Another thread fetches a list of synonyms for the current word and shows them in the “suggestion strip” above the keys. All of this happens in 10s of milliseconds. If this sounds interesting, read on for a peek into what building a keyboard app is like.</span></p>\n<p><img class=\"aligncenter size-full wp-image-39994\" src=\"https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/Screen-Recording_Android-keyboard_V3.gif\" alt=\"\" width=\"800\" height=\"778\" /></p>\n<h2><span style=\"font-weight: 400;\">Android keyboards</span></h2>\n<p><span style=\"font-weight: 400;\">A keyboard on Android is called an IME, or input method editor. The </span><span style=\"font-weight: 400;\">Android </span><a href=\"https://developer.android.com/guide/topics/text/creating-input-method\"><span style=\"font-weight: 400;\">documentation</span></a><span style=\"font-weight: 400;\"> gives a good overview of implementing an IME, so we’ll just briefly mention the main points. On Android, a keyboard is an app whose state and visibility is controlled by a service component called the </span><span style=\"font-weight: 400;\"><code>InputMethodService</code></span><span style=\"font-weight: 400;\">. The keyboard also implements a </span><span style=\"font-weight: 400;\"><code>KeyboardActionListener</code></span><span style=\"font-weight: 400;\">, whose primary job is to handle touch events like typing and gestures and then send updates to the text editor through the </span><span style=\"font-weight: 400;\"><code>InputConnection</code></span><span style=\"font-weight: 400;\"> interface. </span></p>\n<p><span style=\"font-weight: 400;\">When it comes to features, most keyboards have a strip above the keys where predictive suggestions are displayed to help the user type faster. And to improve accuracy, keyboards use intelligent models to predict the character that is most likely to have been touched by the user. Finally, to implement autocorrect, most keyboards also attempt to predict the word the user is trying to type. </span></p>\n<h3><span style=\"font-weight: 400;\">Additional requirements for Grammarly</span></h3>\n<p><span style=\"font-weight: 400;\">Like most Android keyboards, Grammarly runs its own autocorrect and next-word prediction models; we also wrote our own gesture-recognition algorithm to give users the option of swipe-to-type. But our broader goal was to go beyond the basic features described above to help the user write better. To this end, we wanted to provide deeper writing suggestions by surfacing the same kinds of alerts users receive from Grammarly’s browser extension. Where appropriate, we also wanted Grammarly’s keyboard to suggest good synonyms for the current word.</span></p>\n<p><span style=\"font-weight: 400;\">To do all this, our keyboard draws from two sources of information: (1) fast models stored on-device as part of the app for autocorrect, next-word prediction, synonyms, and gesture typing; and (2) Grammarly’s backend, which performs deeper sentence- and paragraph-level analysis. By combining these sources, the keyboard is able to present the most relevant writing suggestions to the user at all times. </span></p>\n<p><div class=\"tool__product\" onclick=\"window.Grammarly.follow('https://www.grammarly.com/jobs/openings?utm_medium=engContent&#38;utm_source=chMidButton&#38;utm_medium=engContent&#38;utm_source=chMidButton','');\">\n    <div>\n        <div class=\"tool__product-icon\"></div>\n        <div class=\"tool__product-copy\">\n            <div class=\"tool__product-headline\">Shape the way millions of people communicate!</div>\n            <div class=\"tool__product-note\"></div>\n        </div>\n        <div class=\"tool__product-button\">Open Roles</div>\n    </div>\n</div>\n</p>\n<h2><span style=\"font-weight: 400;\">Focus areas for building Grammarly’s keyboard </span></h2>\n<p><span style=\"font-weight: 400;\">Below, we outline some of the interesting complexities we’ve faced while building an app that needs to serve as both a smart writing assistant and a fast, reliable IME. We’ll explore a few of these topics in more depth in future blog posts.</span></p>\n<h3><span style=\"font-weight: 400;\">Enabling micro-interactions at each keypress</span></h3>\n<p><span style=\"font-weight: 400;\">For the Grammarly Keyboard, we had to find a way to fit more information into an already small and uniform space. It’s important for users to see Grammarly’s suggestions, but at the same time, information shown while typing can quickly become overwhelming or distracting. We settled on a UX where the suggestions from the backend appear as </span><b>alert cards</b><span style=\"font-weight: 400;\"> next to the Grammarly logo on the suggestion strip, stacking up if there are multiple cards. To allow users to see additional details for each alert, we introduced a </span><b>revision view</b><span style=\"font-weight: 400;\"> that replaces the keyboard layout and shows cards with descriptions about what changes might be applied to the text.</span></p>\n<p><img class=\"aligncenter size-full wp-image-40053\" src=\"https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/android_state.png\" alt=\"\" width=\"3041\" height=\"1600\" /></p>\n<p><span style=\"font-weight: 400;\">With space being so limited, we played with another dimension: time. When the user has stopped typing for more than a few seconds, the keyboard’s top strip changes from showing autocomplete or next-word predictions and displays synonym suggestions instead.</span></p>\n<h3><span style=\"font-weight: 400;\">Developing a state machine for UI views </span></h3>\n<p><span style=\"font-weight: 400;\">The UI for a keyboard is very unassuming. It mainly consists of a view that shows different suggestions above the keyboard and another view containing the keyboard layout itself. Even though a keyboard might seem static compared to a typical app, the UI is constantly in flux. A keyboard can’t create new screens and views. Instead, depending on the event, views are either switched out or overlaid, often in many places at once. For example, when a user taps on the symbols key, the keyboard layout switches by replacing the views for the alphabet keys with new ones, and when a user taps on the Grammarly logo the keyboard layout switches to the revision view. Trajectories for gesture typing are drawn on top of the keyboard layout.</span></p>\n<p><img class=\"aligncenter size-full wp-image-39992\" src=\"https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/Android-eng-blog-diagram.png\" alt=\"\" width=\"1521\" height=\"800\" /></p>\n<p><span style=\"font-weight: 400;\">Grammarly’s suggestion strip has more moving parts than most. Its view hierarchy consists of the following: the Grammarly logo, autocorrect or next-word suggestions, alert cards, synonyms, a badge on top of the Grammarly logo that displays the number of alerts in the stack, and important user prompts. All of these views have to coexist seamlessly in the suggestion strip, switching in and out or overlaying as needed, with specific transition animations. We designed a state-driven architecture to make the UI fluid and delightful. The layout inspector output below shows the number of views that make up the suggestion strip.</span></p>\n<p><img class=\"aligncenter size-full wp-image-39993\" src=\"https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/Android-eng-blog-wireframe.png\" alt=\"\" width=\"1521\" height=\"800\" /></p>\n<h3><span style=\"font-weight: 400;\">Managing multiple pipelines and threading</span></h3>\n<p><span style=\"font-weight: 400;\">The constant flow of suggestions and alerts to the suggestion strip is fed by different pipelines that get predictions from the on-device models and the Grammarly backend. At each keypress, a complex sequence of events unfolds across multiple threads.</span></p>\n<p><span style=\"font-weight: 400;\">In the main thread, the keypress gets committed to the editor and appears in the text box. But in parallel, another thread gets next-word or autocorrect predictions. If the keypress was a regular character, like “g,” the models try to predict what word the user is currently typing, like “great.” If it’s a space or another separator, the models try to predict the next word or words, like “job” after “great.” A different thread fetches synonyms for the last typed word, which will be shown if the user pauses for more than a few seconds.</span></p>\n<p><span style=\"font-weight: 400;\">These various suggestions go through an RxJava pipeline and connect to the view models for the suggestion strip’s view hierarchy. All of this happens in about 20 milliseconds. </span></p>\n<p><span style=\"font-weight: 400;\">But that only covers what’s happening on-device. Meanwhile, a separate thread creates diffs of the text and sends them to the back-end in batches. The keyboard uses chains of </span><a href=\"https://quilljs.com/docs/delta\"><span style=\"font-weight: 400;\">Deltas</span></a><span style=\"font-weight: 400;\">, an expressive format for describing insert, retain, or delete operations, to communicate what has changed. As the backend receives these changes, its models provide additional writing suggestions that might be at the sentence or even paragraph level. These alerts are what stack as cards next to the Grammarly logo in the suggestion strip. </span></p>\n<p><span style=\"font-weight: 400;\">The challenge with managing these different pipelines is similar to maintaining </span><a href=\"https://en.wikipedia.org/wiki/Cache_coherence\"><span style=\"font-weight: 400;\">cache coherence</span></a><span style=\"font-weight: 400;\">. With various threads manipulating the data at once, we need to be careful to avoid corruptions. If the text in the editor is modified in the same place the backend was suggesting a change, that change needs to be invalidated. If the text preceding a suggestion is modified, that suggestion’s bounds need to be shifted to the right to accommodate. Otherwise, the suggestion could be applied to the wrong section and corrupt the text.</span></p>\n<h3><span style=\"font-weight: 400;\">Modifying the text</span></h3>\n<p><span style=\"font-weight: 400;\">Most keyboards keep track of only the last few words as the user is typing. However, since Grammarly’s back-end suggestions could apply to any part of the text, the keyboard needs to handle modifying any part of the user’s text. This is particularly challenging because the changes to the text can happen in any order and from any source: individual keys, suggestions, or back-end alerts. </span></p>\n<p><span style=\"font-weight: 400;\">To handle these changes, the keyboard needs to have quick access to the user’s entire text. While it is possible to get the text from the editor with the </span><span style=\"font-weight: 400;\"><code>InputConnection</code></span><span style=\"font-weight: 400;\"> interface, it’s an IPC call, which is expensive. To avoid having to make these calls frequently, the keyboard maintains a cache of the text in the editor. Again, careful rules must be applied to avoid corrupting the text. These include reloading the cache when the user is not typing or when the keyboard fetches synonyms from the on-device models after the user has paused for a few seconds. </span></p>\n<h3><span style=\"font-weight: 400;\">Ensuring snappy performance</span></h3>\n<p><span style=\"font-weight: 400;\">Keyboards need to be </span><i><span style=\"font-weight: 400;\">very </span></i><span style=\"font-weight: 400;\">fast. Any code change that adds even a few 10s of milliseconds to any part of the call flow will result in visible lag and degrade the user’s typing experience. We are constantly trying to optimize the call flows to make the user experience as snappy as possible. </span></p>\n<p><span style=\"font-weight: 400;\">We think of performance on two fronts. The first is </span><b>keyboard start time</b><span style=\"font-weight: 400;\">. The keyboard is an always-running service, as opposed to an app that the user can kill by swiping it out of Android’s Recently Used Apps list. If the keyboard process does get killed, the OS immediately restarts it. A cold start (when the keyboard app reboots from scratch) is an expensive operation, and while the on-device models are being initialized, the user might see empty placeholders for suggestions. If the keyboard is running but major parts of the app need to be reinitialized, this is called a warm start, and it can also be costly. All other keyboard sessions are hot starts, which should be as fast as possible. Given that the OS decides when cold and warm starts occur, our goal is to speed up the keyboard start time across all these scenarios. </span></p>\n<p><span style=\"font-weight: 400;\">The second performance metric we focus on is </span><b>keypress latency</b><span style=\"font-weight: 400;\">. When the user presses a key, multiple pipelines run to generate suggestions, and various views transition in and out of the suggestion strip. The time for all of this activity to complete on the UI thread is what we generally think of as the keypress latency. It translates to how responsive the keyboard feels for each keypress. </span></p>\n<p><span style=\"font-weight: 400;\">This is an area that we are currently focusing a lot of our efforts on, and we aim to achieve significant gains in the coming months. The way we are tackling this is by reducing the utilization of the UI thread and minimizing the context switches between different threads in the text processing pipelines. During profiling, we’ve identified some time-consuming operations on the UI thread that sometimes delay it from handling the next incoming keypress. We also discovered that when we generate a lot of on-device suggestions, the allocated memory increases rapidly, causing frequent garbage collection that can hamper the UI performance.</span></p>\n<h3><span style=\"font-weight: 400;\">Going beyond manual tests</span></h3>\n<p><span style=\"font-weight: 400;\">Testing a keyboard is a challenging (but super interesting!) problem. The keyboard view is seemingly static, but the keyboard can be in one of many states, depending on the user’s text, the cursor’s position, or the character before or after the cursor. The Grammarly Keyboard also has suggestions from the backend that add to the complexity. Each new writing feature we add can non-linearly increase the number of things to test. </span></p>\n<p><span style=\"font-weight: 400;\">Our testing strategy includes a combination of manual, unit, instrumentation, and UI tests. Instrumentation tests for a keyboard are tricky because the </span><span style=\"font-weight: 400;\"><code>InputMethodService</code></span><span style=\"font-weight: 400;\"> doesn’t lend itself to use through a </span><a href=\"https://developer.android.com/reference/androidx/test/rule/ServiceTestRule\"><span style=\"font-weight: 400;\"><code>ServiceTestRule</code></span></a><span style=\"font-weight: 400;\">. We’ve found that instrumentation tests don’t get a handle to the local binder of the </span><span style=\"font-weight: 400;\"><code>InputMethodService</code></span><span style=\"font-weight: 400;\"> (these tests typically need that handle to call the service’s APIs). So we are moving toward more unit and UI tests. Popular UI testing frameworks are great at testing the app that’s in focus; however, we’ve found that they don’t support testing the IME itself. So we use Android’s built-in </span><a href=\"https://developer.android.com/training/testing/ui-automator\"><span style=\"font-weight: 400;\">UI Automator</span></a><span style=\"font-weight: 400;\">. To keep the duration of the test cycle short, we run multiple tests in parallel using </span><a href=\"https://github.com/shazam/fork\"><span style=\"font-weight: 400;\">Fork</span></a><span style=\"font-weight: 400;\">. </span></p>\n<h2><span style=\"font-weight: 400;\">Further challenges await</span></h2>\n<p><span style=\"font-weight: 400;\">We’ve gone through a broad overview of how the Grammarly Keyboard works, along with the various areas of focus for our team: from figuring out how to optimize the UX for a small screen, to managing on-device and back-end pipelines with multi-threading, to determining how to test an Android app that doesn’t behave like a normal application. </span></p>\n<p><span style=\"font-weight: 400;\">In subsequent posts, we&#8217;ll dive deeper into specific topics, such as internal pipelines, view orchestration, and performance optimization. We are exploring a few architecture patterns that we can apply to the keyboard to make it more robust and easier to maintain. We are trying to design our own architecture that is state-driven by following good design principles and borrowing ideas from paradigms like Model–view–viewModel (MVVM) and Model–view–intent (MVI).</span></p>\n<p><span style=\"font-weight: 400;\">If you are interested in solving complex architecture issues, optimizing performance, or designing an amazing UX, </span><a href=\"https://www.grammarly.com/jobs/engineering/senior-software-engineer-android?gh_jid=2067821\"><span style=\"font-weight: 400;\">we would love to talk to you</span></a><span style=\"font-weight: 400;\">. Grammarly’s Android team is a relatively small team right now—and we are looking for people who can join us in building an awesome writing assistant. </span></p>\n<p>The post <a rel=\"nofollow\" href=\"https://www.grammarly.com/blog/engineering/how-grammarly-built-a-native-keyboard-for-android/\">How Grammarly Built a Native Keyboard for Android</a> appeared first on <a rel=\"nofollow\" href=\"https://www.grammarly.com/blog\">Grammarly Blog</a>.</p>\n","descriptionType":"html","publishedDate":"Tue, 13 Oct 2020 14:00:57 +0000","feedId":41920,"bgimg":"","linkMd5":"a12e459eb3516f2a195f58e63ec2842d","bgimgJsdelivr":"","metaImg":"","author":"Tushar Janefalkar","articleImgCdnMap":{"https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/Grammarly_Android-Keyboard_Post-Header-235x124.png":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn85@2020_6/2020/10/13/14-47-22-791_4c1c1588539391a0.webp","https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/Screen-Recording_Android-keyboard_V3.gif":null,"https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/android_state.png":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn94@2020_5/2020/10/13/14-47-22-824_f29a898b8779a054.webp","https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/Android-eng-blog-diagram.png":null,"https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/Android-eng-blog-wireframe.png":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn2@2020_1/2020/10/13/14-47-22-544_e6d455e731b9aebd.webp"},"publishedOrCreatedDate":1602600442139}],"record":{"createdTime":"2020-10-13 22:47:22","updatedTime":"2020-10-13 22:47:22","feedId":41920,"fetchDate":"Tue, 13 Oct 2020 14:47:22 +0000","fetchMs":783,"handleMs":7,"totalMs":122633,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"a993c83344c28519da04fcfeb12b5e1c","hostName":"europe-24*","requestId":"17e20fb27e0a4df092c4486b596beea6_41920","contentType":"application/rss+xml; charset=UTF-8","totalBytes":83258,"bgimgsTotal":0,"bgimgsGithubTotal":0,"articlesImgsTotal":5,"articlesImgsGithubTotal":3,"successGithubMap":{"myreaderx10":1,"myreaderx3":1,"myreaderx1":1},"failGithubMap":{"myreaderx23":1}},"feed":{"createdTime":"2020-09-07 03:25:45","updatedTime":"2020-09-07 05:42:35","id":41920,"name":"Grammarly Blog","url":"https://www.grammarly.com/blog/feed/","subscriber":76,"website":null,"icon":"https://www.grammarly.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn47@2020_2/2020/09/06/21-42-34-441_a9189256f4246014.jpg","description":"Grammarly Blog","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2020-10-13 22:49:23","updatedTime":"2020-10-13 22:49:23","id":null,"feedId":41920,"linkMd5":"a12e459eb3516f2a195f58e63ec2842d"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":83258,"tmpBgImgCdnBytes":0,"extra4":{"start":1602600441147,"total":0,"statList":[{"spend":985,"msg":"获取xml内容"},{"spend":7,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":121625,"msg":"正文链接上传到cdn"}]},"extra5":5,"extra6":4,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/Android-eng-blog-diagram.png","sourceStatusCode":200,"destWidth":1521,"destHeight":800,"sourceBytes":21958,"destBytes":25444,"targetWebpQuality":75,"feedId":41920,"totalSpendMs":243,"convertSpendMs":76,"createdTime":"2020-10-13 22:47:22","host":"us-022*","referer":"https://www.grammarly.com/blog/?p=39990","linkMd5ListStr":"a12e459eb3516f2a195f58e63ec2842d","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn98/contents/2020/10/13/14-47-22-485_4d08a0c3fbba5ebf.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 13 Oct 2020 14:47:22 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["AE5A:1293:2F232DC:4DFC6DB:5F85BDED"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1602601017"],"x-ratelimit-used":["61"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn98/contents/2020/10/13/14-47-22-485_4d08a0c3fbba5ebf.webp","historyStatusCode":[],"spendMs":49},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"21.4 KB","destSize":"24.8 KB","compressRate":"115.9%"},{"code":1,"isDone":false,"source":"https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/Android-eng-blog-diagram.png","sourceStatusCode":200,"destWidth":1521,"destHeight":800,"sourceBytes":21958,"destBytes":25444,"targetWebpQuality":75,"feedId":41920,"totalSpendMs":134,"convertSpendMs":63,"createdTime":"2020-10-13 22:47:22","host":"us-022*","referer":"https://www.grammarly.com/blog/?p=39990","linkMd5ListStr":"a12e459eb3516f2a195f58e63ec2842d","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn98/contents/2020/10/13/14-47-22-697_4d08a0c3fbba5ebf.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 13 Oct 2020 14:47:22 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["AE5A:1293:2F23302:4DFD6C7:5F85BDFA"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1602601017"],"x-ratelimit-used":["61"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn98/contents/2020/10/13/14-47-22-697_4d08a0c3fbba5ebf.webp","historyStatusCode":[],"spendMs":47},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"21.4 KB","destSize":"24.8 KB","compressRate":"115.9%"},null,null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://europe-56.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://europe68.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-034.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-010.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-022.herokuapp.com/":{"failCount":1,"successCount":2,"resultList":[200,200,null]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/Android-eng-blog-wireframe.png","sourceStatusCode":200,"destWidth":1521,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn2@2020_1/2020/10/13/14-47-22-544_e6d455e731b9aebd.webp","sourceBytes":17437,"destBytes":13012,"targetWebpQuality":75,"feedId":41920,"totalSpendMs":1155,"convertSpendMs":130,"createdTime":"2020-10-13 22:47:22","host":"us-010*","referer":"https://www.grammarly.com/blog/?p=39990","linkMd5ListStr":"a12e459eb3516f2a195f58e63ec2842d","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"17 KB","destSize":"12.7 KB","compressRate":"74.6%"},{"code":1,"isDone":false,"source":"https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/Grammarly_Android-Keyboard_Post-Header-235x124.png","sourceStatusCode":200,"destWidth":235,"destHeight":124,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn85@2020_6/2020/10/13/14-47-22-791_4c1c1588539391a0.webp","sourceBytes":18120,"destBytes":4948,"targetWebpQuality":75,"feedId":41920,"totalSpendMs":1549,"convertSpendMs":5,"createdTime":"2020-10-13 22:47:22","host":"europe68*","referer":"https://www.grammarly.com/blog/?p=39990","linkMd5ListStr":"a12e459eb3516f2a195f58e63ec2842d","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"17.7 KB","destSize":"4.8 KB","compressRate":"27.3%"},{"code":1,"isDone":false,"source":"https://contenthub-static.grammarly.com/blog/wp-content/uploads/2020/10/android_state.png","sourceStatusCode":200,"destWidth":3041,"destHeight":1600,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn94@2020_5/2020/10/13/14-47-22-824_f29a898b8779a054.webp","sourceBytes":131713,"destBytes":65298,"targetWebpQuality":75,"feedId":41920,"totalSpendMs":1496,"convertSpendMs":379,"createdTime":"2020-10-13 22:47:22","host":"us-034*","referer":"https://www.grammarly.com/blog/?p=39990","linkMd5ListStr":"a12e459eb3516f2a195f58e63ec2842d","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"128.6 KB","destSize":"63.8 KB","compressRate":"49.6%"}],"successGithubMap":{"myreaderx10":1,"myreaderx3":1,"myreaderx1":1},"failGithubMap":{"myreaderx23":1}}