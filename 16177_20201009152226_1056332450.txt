{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-09 23:22:04","updatedTime":"2020-10-09 23:22:04","title":"用户端智能的应用实践","link":"http://blog.cnbang.net/?p=3643","description":"<p class=\"p1\">去年团队在用户端上进行了一些简单的智能应用探索实践，这里记录梳理下。</p>\n<p class=\"p1\">现在很多“智能”，是普通推荐算法借深度学习的风包装的，核心也就是决策树<span class=\"s1\">/</span>随机森林/SVM这些9<span class=\"s1\">0</span>年代已经提出的算法，我们这里的实践也是这样。在用户端上，智能应用最广泛的目前两个点：个性化和多媒体识别，我们主要实践是在个性化上，从原来所有用户都用同一套或几套规则，换成根据推荐算法给每个用户制定符合他个性化特征的不同规则。</p>\n<p class=\"p1\">实际上简单的个性化推荐也可以认为是规则，只是这个规则很复杂，里面的<span class=\"s1\">if/else/</span>权重<span class=\"s1\">/</span>概率计算不是人工写的，而是算法算出来的，大多采用监督学习的方式，这种需求大体实现步骤是：</p>\n<ol class=\"ol1\">\n<li class=\"li1\">建模，把问题转化为三个点：输入<span class=\"s1\">/</span>输出<span class=\"s1\">/</span>算法。也就是挑选特征集<span class=\"s1\">X</span>，确定输出目标值标签<span class=\"s1\">Y</span>，挑选算法尝试找出<span class=\"s1\">Y=f</span>(<span class=\"s1\">X</span>)。</li>\n<li class=\"li1\">取数，选择一坨线上数据，清洗出需要的特征和对应的目标值。</li>\n<li class=\"li1\">训练，不断调整算法<span class=\"s1\">/</span>参数<span class=\"s1\">/</span>数据，找出用户特征<span class=\"s1\">-&#62;</span>目标值的一个靠谱转化方式，输出一个模型。</li>\n<li class=\"li1\">应用，部署线上应用，实时预测，分析效果输入特征。</li>\n</ol>\n<p class=\"p1\">按这个套路，寻找了一些应用场景，做了一些尝试。</p>\n<h2 class=\"p3\"></h2>\n<h2 class=\"p3\"><span class=\"s2\">智能</span>push</h2>\n<p class=\"p1\">智能<span class=\"s1\">push</span>想做的是在合适的时间给人推<span class=\"s1\">push</span>，提高点击率。基于一个假想：每个用户都有不同时间段的活跃时间点，如果<span class=\"s1\">push</span>不是统一固定时间下发，而是选择每个用户对应活跃的时间点下发，可以提高点击率。这里的<span class=\"s1\">push</span>是促活类的，例如资讯的<span class=\"s1\">push</span>。这里的问题可以转化为：怎样根据一个用户已有信息预测出他的活跃时间点。</p>\n<ol class=\"ol1\">\n<li class=\"li3\"><span class=\"s2\">建模</span>\n<ul class=\"ol1\">\n<li class=\"li1\">输入，选取可能跟用户作息有关的年龄<span class=\"s1\">/</span>收入<span class=\"s1\">/</span>城市等基础信息，再加上用户过去<span class=\"s1\">7</span>天的<span class=\"s1\">push</span>点击数据作为特征值。</li>\n<li class=\"li1\">输出，用户的活跃时间点，精确到小时，用户一天可能在多个时间点活跃，需要输出多个时间点。因为需求原因，<span class=\"s1\">push</span>时间点限制在<span class=\"s1\">8-21</span>点。</li>\n<li class=\"li1\">算法，<span class=\"s1\">8-21</span>点共<span class=\"s1\">14</span>个小时，<span class=\"s1\">14</span>小时<span class=\"s1\">-&#62;14</span>个分类，多个时间点活跃<span class=\"s1\">-&#62;</span>属于多个分类，是个多标签分类问题，我们用多个二分类的方式实现，同样用随机森林的算法，<span class=\"s1\">14</span>个时间点每个点都单独做一次二分类，每个二分类的计算结果都是<span class=\"s1\">0-1</span>之间的数，可以当成这个用户在这个时间点的活跃概率，最后合起来，得到每个时间点的概率。再根据指定阈值确定是否活跃时间点，例如：<br />\n<a href=\"http://blog.cnbang.net/wp-content/uploads/2019/03/20190324164008.jpg\"><img class=\"alignnone size-full wp-image-3644\" src=\"http://blog.cnbang.net/wp-content/uploads/2019/03/20190324164008.jpg\" alt=\"20190324164008\" width=\"429\" srcset=\"http://blog.cnbang.net/wp-content/uploads/2019/03/20190324164008.jpg 858w, http://blog.cnbang.net/wp-content/uploads/2019/03/20190324164008-300x60.jpg 300w, http://blog.cnbang.net/wp-content/uploads/2019/03/20190324164008-768x154.jpg 768w, http://blog.cnbang.net/wp-content/uploads/2019/03/20190324164008-700x140.jpg 700w\" sizes=\"(max-width: 858px) 100vw, 858px\" /></a></li>\n</ul>\n</li>\n<li class=\"li3\"><span class=\"s2\">取数：</span>\n<ul>\n<li class=\"li1\">对过去的<span class=\"s1\">push</span>数据进行处理，根据<span class=\"s1\">8</span>点<span class=\"s1\">-21</span>点每个时间是否有点击<span class=\"s1\">push</span>，合成多条特征数据，取过去<span class=\"s1\">8</span>天的数据，<span class=\"s1\">1-7</span>天的数据作为特征，第<span class=\"s1\">8</span>天的数据作为目标值标签。</li>\n<li class=\"li1\">清洗用户基础特征，数据转换，拼接<span class=\"s1\">push</span>特征。</li>\n</ul>\n</li>\n<li class=\"li1\">训练：根据第二步的数据分<span class=\"s1\">14</span>个二分类(<span class=\"s1\">14</span>个时间点）训练，得到<span class=\"s1\">14</span>个模型，每个时间点一个模型，最后合成一个。</li>\n<li class=\"li1\">应用：经过算法模型可以得到用户每个时间点的活跃概率，有多种使用策略，可以通过阈值得到几个活跃时间点，也可以直接选用概率最高的时间点，还可以在业务发送<span class=\"s1\">push</span>时，往后选取概率最大的时间点发送，例如业务<span class=\"s1\">12</span>点发送<span class=\"s1\">push</span>，选<span class=\"s1\">12</span>点<span class=\"s1\">-21</span>点之间概率最大的时间点，把<span class=\"s1\">push</span>进队列延迟到该时间点发送。</li>\n</ol>\n<p class=\"p1\">同样是经过了多轮的数据分析、模型调整、特征优化、<span class=\"s1\">AB</span>实验、<span class=\"s1\">Android</span>分链路优化等，最终同一条<span class=\"s1\">push</span>内容，使用智能<span class=\"s1\">push</span>链路和普通链路直接推送相比，点击率稳定在提升<span class=\"s1\">25%</span>左右。</p>\n<h3 class=\"p1\">本地处理</h3>\n<p class=\"p1\"><span class=\"s1\">push</span>的优化上当时我们想做更多，除了活跃时间段，实际上影响用户点击<span class=\"s1\">push</span>的还有他当前手机的实时状态，例如是否在看视频<span class=\"s1\">/</span>玩游戏<span class=\"s1\">/</span>放在口袋里等状态，在这些情况下用户点击<span class=\"s1\">push</span>概率一定很小，如果在收到<span class=\"s1\">push</span>后显示前能实时检测到这些状态，就可以推迟到更合适的时间显示。为此我们在<span class=\"s1\">iOS</span>上做了一些尝试：</p>\n<ol class=\"ol1\">\n<li class=\"li1\">需要在用户收到<span class=\"s1\">push</span>后执行代码逻辑，再决定是否显示<span class=\"s1\">push</span>，经调研<span class=\"s1\"> Notification Extension </span>没有取消展示<span class=\"s1\">push</span>的能力，<span class=\"s1\">VoIP </span>需要特殊权限，只能用普通的静默<span class=\"s1\">push</span>去做。</li>\n<li class=\"li1\">每条<span class=\"s1\">push</span>都改成静默<span class=\"s1\">push</span>，收到后唤起执行代码，经过各种判断后创建<span class=\"s1\">Local Notification</span>，在指定时间展示<span class=\"s1\">push</span>。</li>\n<li class=\"li1\"><span class=\"s1\">iOS </span>无法直接判断用户正在运行的程序和手机状态，只能通过一些侧面属性判断，包括横竖屏状态、耳机插入、内存情况、<span class=\"s1\">cpu</span>情况、锁屏情况、网络状态这些信息，模糊猜测用户当前所处环境，给出一条运算公式计算用户当前是否适合展示<span class=\"s1\">push</span>，公式可以动态下发，根据效果调整。</li>\n<li class=\"li1\">用户本地保存上面跑出来的每个时间点活跃概率数据，把<span class=\"s1\">push</span>延迟到下一个较活跃的时间点显示。</li>\n</ol>\n<p class=\"p1\"><span class=\"s1\">Android </span>也实现了差不多的方案，不过<span class=\"s1\">iOS</span>和<span class=\"s1\">Android</span>的方案都有缺陷，<span class=\"s1\">iOS</span>方面用户手动<span class=\"s1\">kill</span>掉的<span class=\"s1\">APP</span>情况会收不到静默<span class=\"s1\">push</span>，会影响<span class=\"s1\">push</span>的到达率，<span class=\"s1\">Android</span>方面没有可靠的延迟展示<span class=\"s1\">push</span>手段，若延迟的时间点<span class=\"s1\">APP</span>处于非活跃状态，会无法展示，同样也是会影响<span class=\"s1\"> push </span>到达率，这些缺陷导致最后本地处理的方案实现后没有很好地应用上。</p>\n<h2 class=\"p3\"><span class=\"s2\">其他</span></h2>\n<p class=\"p1\">除了智能<span class=\"s1\">push</span>，还做了一些其他智能的尝试，包括</p>\n<ol class=\"ol1\">\n<li class=\"li1\">智能异常检测：客户端的一些异常很多时候无法通过代码准确地检测到，例如图形引擎在一些安卓机器上的花屏，没有报错的白屏<span class=\"s1\">/</span>黑屏，期望是有统一的手段检测到这些显示的异常。做法是在端上内置机器学习框架，云端训练模型，输入是截屏图片，输出是异常分类，我们挑了三种情况作为异常截屏样本：白屏<span class=\"s1\">/</span>黑屏<span class=\"s1\">/</span>花屏，做一个简单的图形分类模型，典型的深度学习<span class=\"s1\">cnn</span>入门级项目，压缩模型下发到客户端运行，用户运行过程中根据一定的规则抽样进行截屏检测，有异常可能即上报。</li>\n<li class=\"li1\">股票<span class=\"s1\">OCR</span>导入：自选股票从不同<span class=\"s1\">APP</span>迁移时，需要逐个股票进行输入<span class=\"s1\">-&#62;</span>搜索<span class=\"s1\">-&#62;</span>添加自选，这里要做的是在应用<span class=\"s1\">A</span>自选列表截屏，在应用<span class=\"s1\">B</span>导入截屏，<span class=\"s1\">OCR</span>识别出截屏上的股票代码。<span class=\"s1\">OCR</span>是比较通用的识别能力，直接用现成模型，配合一些逻辑处理就能实现了。</li>\n</ol>\n<p class=\"p1\">还有像智能预加载<span class=\"s1\">/</span>智能分页<span class=\"s1\">/</span>交互预测<span class=\"s1\">/</span>交易流失归因分析这些实践，但还没有做完整，就不描述了。</p>\n<h2 class=\"p3\"><span class=\"s2\">感想</span></h2>\n<ol class=\"ol1\">\n<li class=\"li1\">当智能基础能力的基建（训练平台，模型部署，数据打标等）做好了，要把智能能力应用到业务上时，需要的更多是业务理解和数据分析能力，多数精力会耗费在清洗数据、模型调优上，这个能力跟工程能力有很大不同。</li>\n<li class=\"li1\">简单的“智能”需求，不需要理解具体算法实现也能做出来，只是理解了算法可能对优化有帮助。</li>\n<li class=\"li1\">机器学习算法繁多，与过往计算机通用经验复用度不高，要达到创造<span class=\"s1\">/</span>改进算法的程度门槛太高。</li>\n<li class=\"li1\">用户端体验上的智能应用在多媒体、<span class=\"s1\">IoT</span>、系统级优化上比较有空间，其他的并没有找到特别大的应用场景。</li>\n<li class=\"li1\">即使做了几个智能的应用，也没法说已经入门了这个领域，只是接触到一点皮毛，而且当时去补的各种知识点在一段时间没有接触使用后，也很容易就遗忘了。</li>\n</ol>\n<img src=\"http://feeds.feedburner.com/~r/webbang/~4/oflTbiS4WIE\" height=\"1\" width=\"1\" alt=\"\"/>","descriptionType":"html","publishedDate":"Mon, 25 Mar 2019 04:06:12 +0000","feedId":16177,"bgimg":"","linkMd5":"680063619bc110e853933c87780c5c6a","bgimgJsdelivr":"","metaImg":"","author":"bang","articleImgCdnMap":{"http://blog.cnbang.net/wp-content/uploads/2019/03/20190324164008.jpg":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn5@2020_6/2020/10/09/15-22-25-528_d2e650cedc78af66.webp","http://feeds.feedburner.com/~r/webbang/~4/oflTbiS4WIE":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn3@2020_1/2020/10/09/15-22-05-407_c5ae195f0fd53ba9.webp"},"publishedOrCreatedDate":1602256924840}],"record":{"createdTime":"2020-10-09 23:22:04","updatedTime":"2020-10-09 23:22:04","feedId":16177,"fetchDate":"Fri, 09 Oct 2020 15:22:04 +0000","fetchMs":237,"handleMs":4827,"totalMs":26903,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"d4510fc825f54523eea4f1b6f606b860","hostName":"us-007*","requestId":"6a03a832103640f386a57a26998c2888_16177","contentType":"text/xml; charset=UTF-8","totalBytes":10340,"bgimgsTotal":0,"bgimgsGithubTotal":0,"articlesImgsTotal":2,"articlesImgsGithubTotal":2,"successGithubMap":{"myreaderx7":1,"myreaderx4":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:12:16","updatedTime":"2020-09-07 02:12:16","id":16177,"name":"bang’s blog","url":"http://feeds.feedburner.com/webbang","subscriber":207,"website":null,"icon":"http://blog.cnbang.net/favicon.ico","icon_jsdelivr":null,"description":"我的世界","weekly":null,"link":"http://blog.cnbang.net"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":10340,"tmpBgImgCdnBytes":0,"extra4":{"start":1602256919501,"total":0,"statList":[{"spend":519,"msg":"获取xml内容"},{"spend":4827,"msg":"解释文章"},{"spend":20,"msg":"上传封面图到cdn"},{"spend":8,"msg":"修正封面图上传失败重新上传"},{"spend":21252,"msg":"正文链接上传到cdn"}]},"extra5":2,"extra6":2,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-037.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-036.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"http://feeds.feedburner.com/~r/webbang/~4/oflTbiS4WIE","sourceStatusCode":200,"destWidth":1,"destHeight":1,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn3@2020_1/2020/10/09/15-22-05-407_c5ae195f0fd53ba9.webp","sourceBytes":43,"destBytes":72,"targetWebpQuality":75,"feedId":16177,"totalSpendMs":800,"convertSpendMs":4,"createdTime":"2020-10-09 23:22:05","host":"us-037*","referer":"http://blog.cnbang.net/?p=3643","linkMd5ListStr":"680063619bc110e853933c87780c5c6a","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"43 B","destSize":"72 B","compressRate":"167.4%"},{"code":1,"isDone":false,"source":"http://blog.cnbang.net/wp-content/uploads/2019/03/20190324164008.jpg","sourceStatusCode":200,"destWidth":858,"destHeight":172,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn5@2020_6/2020/10/09/15-22-25-528_d2e650cedc78af66.webp","sourceBytes":32990,"destBytes":10268,"targetWebpQuality":75,"feedId":16177,"totalSpendMs":2840,"convertSpendMs":45,"createdTime":"2020-10-09 23:22:23","host":"us-036*","referer":"http://blog.cnbang.net/?p=3643","linkMd5ListStr":"680063619bc110e853933c87780c5c6a","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"32.2 KB","destSize":"10 KB","compressRate":"31.1%"}],"successGithubMap":{"myreaderx7":1,"myreaderx4":1},"failGithubMap":{}}