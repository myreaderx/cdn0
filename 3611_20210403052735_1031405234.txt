{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2021-04-03 13:23:33","updatedTime":"2021-04-03 13:23:33","title":"Factorized layers revisited: Compressing deep networks without playing the lottery","link":"https://www.microsoft.com/en-us/research/?p=734179","description":"\n<figure class=\"wp-block-image alignwide size-large\"><img src=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/1400x788_autoML_animation_no_logov2.gif\" alt=\"\"/></figure>\n\n\n\n<p>From BiT (<a href=\"https://arxiv.org/abs/1912.11370\">928 million parameters</a>) to GPT-3 (<a href=\"https://arxiv.org/abs/2005.14165\">175 billion parameters</a>), state-of-the-art machine learning models are rapidly growing in size. With the greater expressivity and easier trainability of these models come skyrocketing training costs, deployment difficulties, and even <a href=\"https://www.microsoft.com/en-us/research/video/frontiers-in-machine-learning-climate-impact-of-machine-learning/\">climate impact</a>. As a result, we’re witnessing exciting and emerging research into compressing these models to make them less expensive, small enough to store on any device, and more energy efficient. Perhaps the most popular approach to model compression is pruning, in which redundant model parameters are removed, leaving only a small subset of parameters, or a <em>subnetwork</em>. A major drawback of pruning, though, is it requires training a large model first, which is expensive and resource intensive.</p>\n\n\n\n<p>Recent research around pruning has focused on the <a href=\"https://openreview.net/forum?id=rJl-b3RcF7\">lottery ticket hypothesis</a>, which suggests that most parameters of large models are redundant <em>even during training </em>and that there exists a subnetwork responsible for most of the model’s performance. In other words, you can train this subnetwork alone and still obtain the same accuracy as if you had trained all the parameters—provided you are able to identify the subnetwork first. While such subnetworks—called <em>lottery tickets</em>—have been shown to exist by pruning large networks <em>after </em>training, intensive efforts to design methods that guess them <em>before </em>training, such as <a href=\"https://arxiv.org/abs/2002.07376\">GraSP </a>and <a href=\"https://arxiv.org/abs/2009.11094\">hybrid tickets</a>, haven’t achieved the same performance.</p>\n\n\n\n<p>Are sparsity-based methods such as pruning and guessing lottery tickets the right way to obtain compressed models? As part of our paper “<a href=\"https://www.microsoft.com/en-us/research/publication/initialization-and-regularization-of-factorized-neural-layers/\">Initialization and Regularization of Factorized Neural Layers</a>,”<span class=\"has-inline-color has-orange-color\"> </span>which we’re presenting at the <a href=\"https://www.microsoft.com/en-us/research/event/iclr-2021/\">International Conference on Learning Representations</a> (ICLR 2021), we revisit the <a href=\"https://arxiv.org/abs/1511.06067\">alternative compression approach of factorized neural layers</a>. While sparsity-based approaches remove parameters from the weight matrices of a network incrementally, factorization replaces the matrices with products of smaller matrices that are more efficient to store and compute. Despite the fact that factorized layers are more amenable to deployment on deep learning accelerators such as GPUs and software frameworks such as PyTorch, sparsity-based methods remain more popular because they’re <a href=\"https://openaccess.thecvf.com/content_CVPR_2020/html/Idelbayev_Low-Rank_Compression_of_Neural_Nets_Learning_the_Rank_of_Each_CVPR_2020_paper.html\">seen as better at maintaining high accuracy at high compression rates</a> (for example, 10 percent or less parameters remaining).</p>\n\n\n\n<p>Our results contradict this position: we show that if we use the right initialization scheme (<em>spectral initialization,</em> or <em>SI</em>) and the right regularization penalty (<em>Frobenius decay</em>, or <em>FD</em>), we can achieve higher accuracy on three benchmark datasets by training a factorized ResNet from scratch than by pruning or guessing lottery tickets. The key principle underlying these two natural methods, neither of which requires extra hyperparameters, is that the training behavior of a factorized model should mimic that of the original (unfactorized) network.</p>\n\n\n\n<p>We further demonstrate the usefulness of these schemes in two settings beyond model compression where factorized neural layers are applied. The first is an exciting new area of knowledge distillation in which an overcomplete factorization is used to replace the complicated and expensive student-teacher training phase with a single matrix multiplication at each layer. The second is for training Transformer-based architectures such as <a href=\"https://arxiv.org/abs/1810.04805\">BERT</a>, which are popular models for learning over sequences like text and genomic data and whose multi-head self-attention mechanisms are also factorized neural layers.</p>\n\n\n\n<p>Our work is part of <a href=\"https://www.microsoft.com/en-us/research/lab/microsoft-research-new-england/\">Microsoft Research New England’s</a> <a href=\"https://www.microsoft.com/en-us/research/project/automl/\">AutoML research efforts</a>, which seek to make the exploration and deployment of state-of-the-art machine learning easier through the development of models that help automate the complex processes involved. The code to our work is available at our <a href=\"https://github.com/microsoft/fnl_paper\">GitHub repository</a>.</p>\n\n\n\n<h2>Factorized neural layers and where to find them</h2>\n\n\n\n<p>Deep networks are function approximators in which inputs are passed through a sequence of nonlinear transformations \\(g(W,x)\\), each modifying the previous layer’s output \\(x\\) using some mapping specified by a weight matrix \\(W\\)∈ \\(\\mathbb{R}\\)\\(^m\\)\\(^x\\)\\(^n\\). The space and time complexity of each layer is typically tied directly to the dimensionality of this weight matrix; for example, standard implementations of fully connected and convolutional layers require \\(O(mn)\\) operations to compute \\(g(W, x)\\).</p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-large\"><a href=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Factorized-Neural_Figure-2_Automl.jpg\"><img loading=\"lazy\" width=\"1024\" height=\"508\" src=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Factorized-Neural_Figure-2_Automl-1024x508.jpg\" alt=\"Two side-by-side depictions of a convolution applied to a 5-by-5 input. On the left, a 3-by-3 filter labeled “k-by-k convolution (c-by-c channels)” is applied to the 5-by-5 input to produce a 3-by-3 output. Next to it is a square labeled “W” described as a “weight tensor (reshaped) (c squared k squared parameters)”; it has side lengths ck and ck. An arrow points to two rectangles: a vertical rectangle labeled “U” and a horizontal rectangle labeled “V superscript T” described as a “factorized weight tensor (2ckr parameters)”; each rectangle has side lengths ck and r. To the right, a 1-by-3 filter labeled “1-by-k convolution (r-by-c channels)” is applied to the 5-by-5 input to produce a 5-by-3 output; applied to this input is a 3-by-1 filter labeled “k-by-1 convolution (c-by-r channels)” to produce a 3-by-3 output.\" class=\"wp-image-734335\" srcset=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Factorized-Neural_Figure-2_Automl-1024x508.jpg 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Factorized-Neural_Figure-2_Automl-300x149.jpg 300w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Factorized-Neural_Figure-2_Automl-768x381.jpg 768w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Factorized-Neural_Figure-2_Automl-16x8.jpg 16w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Factorized-Neural_Figure-2_Automl.jpg 1528w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" /></a><figcaption>Figure 1: An example of how to factorize a two-dimensional convolution layer. Here the weight tensor of a regular <em>k </em>×<em> k</em> convolution (left) is reshaped into a matrix and factorized into two smaller weight matrices, each corresponding to a one-dimensional convolution performed along one dimension of an image (right).</figcaption></figure></div>\n\n\n\n<p>Factorized neural layers replace the matrix with a product of matrices; in the simplest case, we have the standard low-rank decomposition \\(W\\)=\\(UV\\)\\(^T\\) for matrices \\(U\\)∈ \\(\\mathbb{R}\\)\\(^m\\)\\(^x\\)\\(^r\\), \\(V\\)∈ \\(\\mathbb{R}\\)\\(^n\\)\\(^x\\)\\(^r\\). In the model compression case, we can set \\(r\\)≪\\(m,n\\) to improve the complexity of fully connected and convolutional layers from \\(O(mn)\\) to \\(O(r(m+n))\\); as shown in Figure 1, for two-dimensional convolutions, this speedup is achieved using two one-dimensional convolutions, one along each spatial dimension. In the case of Transformers, which take as input a sequence \\(x\\) with hidden dimension \\(d\\), we can express the action of a multi-head attention (MHA) operation parameterized by \\(H\\) query \\((Q_h)\\), key \\((K_h)\\), value \\((V_h)\\), and output \\((O_h)\\) projection matrices as the following summation over its heads \\(h\\)=1,…,\\(H\\):</p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img loading=\"lazy\" width=\"1024\" height=\"185\" src=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Latex_AutoML_figure1-1024x185.jpg\" alt=\"\" class=\"wp-image-734284\" srcset=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Latex_AutoML_figure1-1024x185.jpg 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Latex_AutoML_figure1-300x54.jpg 300w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Latex_AutoML_figure1-768x139.jpg 768w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Latex_AutoML_figure1-16x3.jpg 16w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Latex_AutoML_figure1.jpg 1061w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" /></figure>\n\n\n\n<p>This formulation makes clear that MHA is an aggregation over \\(2H\\) factorized neural layers with rank \\(r=d/H\\), half of them parameterized by \\(Q_h\\) \\(Kh^T\\) and the other half by \\(V_h\\) \\(O_h^T\\).</p>\n\n\n\n<h2>How should training routines handle factorized neural layers?</h2>\n\n\n\n<p>It’s straightforward to apply standard deep network training algorithms such as stochastic gradient descent (SGD) to networks with factorized layers. However, modern optimization procedures have many critical aspects, such as initialization and regularization, that significantly influence the performance of the final model. When we factorize a network, the effect of these components can change substantially, so we often can’t use the same settings as for the unfactorized model. For example, in the unfactorized case, the standard weight decay regularization penalizes the squared <a href=\"https://encyclopediaofmath.org/wiki/Frobenius_matrix_norm\">Frobenius norm</a> ||\\(W||_{Fro}^{2}\\) of each weight matrix in the model; however, if we directly apply this to the factors \\(U\\) and \\(V\\) in a factorized layer, we end up penalizing an upper bound on twice the <a href=\"https://encyclopediaofmath.org/wiki/Nuclear_norm\">nuclear norm</a> of their product:</p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img loading=\"lazy\" width=\"1024\" height=\"126\" src=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Latex-2-1024x126.jpg\" alt=\"\" class=\"wp-image-734290\" srcset=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Latex-2-1024x126.jpg 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Latex-2-300x37.jpg 300w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Latex-2-768x94.jpg 768w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Latex-2-16x2.jpg 16w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Latex-2.jpg 1114w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" /></figure>\n\n\n\n<p>As indicated in the figure below, this upper bound is tight when training a factorized ResNet using regular weight decay, showing that it effectively penalizes the nuclear norm rather than the Frobenius norm.</p>\n\n\n\n<figure class=\"wp-block-image size-large is-resized\"><a href=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML_figure-updated_-CIFAR.jpg\"><img loading=\"lazy\" src=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML_figure-updated_-CIFAR.jpg\" alt=\"Three line plots side by side, each with “training epoch” on the x-axis and “average across layers” on the y-axis. The first, titled “Kaiming init, different regularizers,” has three solid lines representing nuclear norm: one in black and labeled “no-decay,” one in green and labeled “weight decay,” and one in blue and labeled “Frobenius decay,” with the first above the second and the second above the third. It also has three unlabeled dotted lines representing the nuclear norm upper bound corresponding to each solid line. Those corresponding to “no decay” and “weight decay” are very close to their respective solid lines, while the dotted line corresponding to “Frobenius” decay is not. The second plot, titled “Spectral init, different regularizers,” shows the same result. The last plot, titled “Weight decay, different rank scales,” has six pairs of solid and dotted lines labeled and color coordinated by powers of three from –3 to 2; in all cases, the dotted lines are very close to their respective solid lines.\" width=\"900\" height=\"331\"/></a><figcaption>Figure 2: Comparison of nuclear norm (solid line) and nuclear norm upper bound penalized by weight decay on individual factors (dotted line) during the training of ResNet20 on CIFAR-10, showing that for most of training, weight decay is effectively penalizing the nuclear norm.</figcaption></figure>\n\n\n\n<p>This example demonstrates how factorizing the model without modifying the training routine can lead to substantial changes in training behavior. Thus, following the principle that the training behavior of a factorized model should mimic that of the original model to recover the latter’s performance, we argue in favor of using spectral initialization (SI) and Frobenius decay (FD) when training factorized neural layers. SI initializes \\(U\\) and \\(V\\) by applying a rank-deficient singular value decomposition (SVD) to the standard random initialization of the corresponding full-rank weight matrix \\(W\\) in the original model, while FD replaces weight decay by penalizing the squared Frobenius norm ‖\\(UV\\)\\(^T\\)‖\\(_{Fro}^{2}\\) rather than the sum of squared norms of the individual factors.</p>\n\n\n\n<p>In our paper, we extend a recent <a href=\"https://openreview.net/forum?id=B1lz-3Rct7\">approximate analysis of weight decay</a> to show that these two schemes allow SGD to maintain a high effective step size when training factorized neural layers, mimicking the role of regular weight decay applied to the original models. More informally, SI follows the mimicking principle since the SVD provably returns the best factorized approximation of initialization used by the original model. FD follows the mimicking principle by regularizing the squared Frobenius norm of the product, as is done by weight decay applied to the original model; in contrast, applying weight decay to the individual factors implicitly regularizes the nuclear norm, as shown in the figure above. Together, these two simple, efficient modifications lead to substantial improvements in model compression, knowledge distillation, and the training of Transformer-based architectures.</p>\n\n\n\n<h2>Factorization vs. sparsity-based methods for model compression</h2>\n\n\n\n<p>As mentioned above, sparsity-based approaches such as pruning and guessing lottery tickets represent the prevailing trend in model compression. However, in this section, we show that low-rank factorization is competitive with these methods and can even attain better accuracy at the same parameter count. In particular, the figure below demonstrates that, in the case of low-memory ResNets, factorized neural layers outperform not only sparse (low-memory) training methods like guessing lottery tickets and <a href=\"https://arxiv.org/abs/1902.05967\">dynamic sparsity</a> but often even full model training followed by pruning. The model—a modified ResNet32—and datasets—CIFAR-10, CIFAR-100, and Tiny-ImageNet—we use reflect the same standard setup considered by the lottery ticket papers GraSP and hybrid tickets.</p>\n\n\n\n<figure class=\"wp-block-image size-large\"><a href=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Updated-Figure-_resnet.jpg\"><img loading=\"lazy\" width=\"1024\" height=\"411\" src=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Updated-Figure-_resnet-1024x411.jpg\" alt=\"Three bar graphs side by side, each with “accuracy” on the y-axis and the following data categories corresponding to a specific color bar on the x-axis: original model (black); pruning (blue with black dots); lottery ticket (blue with black dots); dynamic sparsity (blue); fixed sparsity (guessing tickets) (blue); low-rank (orange); and low-rank plus spectral initialization and Frobenius decay (orange).\n\nIn the first, titled “CIFAR-10,” the original model is 94.49 percent accurate and then, in order of highest accuracy: low-rank plus spectral initialization and Frobenius decay, 94.34; pruning, 94.21; lottery ticket, 94.14; low-rank, 93.59; dynamic sparsity, 92.97; and fixed sparsity (guessing tickets), 92.97.\n\nIn the second, titled “CIFAR-100,” the original model is 75.41 percent accurate and then, in order of highest accuracy: low-rank plus spectral initialization and Frobenius decay, 74.41; low-rank, 72.71; lottery ticket, 72.41; pruning, 72.34; fixed sparsity (guessing tickets), 69.70; and dynamic sparsity, 69.66.\n\nIn the third, titled “Tiny-ImageNet,” the original model is 63.02 percent accurate and then, in order of highest accuracy: low-rank plus spectral initialization and Frobenius decay, 60.25; low-rank, 58.72; lottery ticket, 57.77; pruning, 57.62; dynamic sparsity, 57.19; and fixed sparsity (guessing tickets), 55.53.\n\" class=\"wp-image-735724\" srcset=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Updated-Figure-_resnet-1024x411.jpg 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Updated-Figure-_resnet-300x120.jpg 300w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Updated-Figure-_resnet-768x308.jpg 768w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Updated-Figure-_resnet-1536x617.jpg 1536w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Updated-Figure-_resnet-16x6.jpg 16w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Updated-Figure-_resnet.jpg 1860w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" /></a><figcaption>Figure 3: Comparison of the accuracy of several training methods: full model training (black); the sparsity-based approaches full model pruning, in which the full model is trained and then pruned (blue with black dots), and sparse training, in which a sparse model is trained (blue); and low-rank factorized layers (orange). When properly initialized and regularized, low-rank training, particularly with spectral initialization and Frobenius decay, achieves better performance at 10 percent compression than sparsity-based methods.</figcaption></figure>\n\n\n\n<p>This superior performance depends critically on the use of spectral initialization and Frobenius decay in tandem; interestingly, in the paper, we find that both schemes <em>decrease </em>accuracy when used independently. While factorization isn’t always best at very high compression rates, the figure above shows that it’s clearly superior in the standard lottery ticket regime, when the compressed model accuracy is close to that of the original model (usually this means the compressed model has 10 percent or more of the original parameters). Notably, our approach doesn’t require any additional tuning, as the decay coefficient used for the uncompressed model is the same one used by FD. Thus, factorized neural layers serve as a strong, simple baseline regardless of whether we’re targeting memory savings or fast computation.</p>\n\n\n\n<h2>Teacher-free teaching with overcomplete knowledge distillation</h2>\n\n\n\n<p>While our motivating application is model compression, factorized neural layers can also be found in other applications, such as knowledge distillation, a field that studies how to obtain a better small model by “teaching” it using a more powerful large model. <a href=\"https://arxiv.org/abs/1811.10495\">Recent work on using overparameterization to train compact networks</a> suggests that factorized neural layers can help us avoid the (expensive) two-stage student-teacher training process of knowledge distillation by using an <em>overcomplete </em>factorization of each of the student’s weight matrices \\(W\\)=\\(UV\\)\\(^T\\), where matrix factors \\(U\\)∈ \\(\\mathbb{R}\\)\\(^m\\)\\(^x\\)\\(^r\\),\\(V\\)∈ \\(\\mathbb{R}\\)\\(^n\\)\\(^x\\)\\(^r\\) have inner dimension \\(r\\)≥\\(m,n\\), making the factors wider than the original weight matrix, or even by using a deep factorization \\(W\\)=\\(UMV\\)\\(^T\\). The goal is to take advantage of the training <a href=\"https://arxiv.org/abs/1802.06509\">benefits of deeper or wider networks suggested by recent theoretical work</a> while not actually increasing the model capacity. While this increases the parameter count during training, afterward we can directly obtain a network of the original size by multiplying the factors together. We refer to this technique as <em>overcomplete knowledge distillation</em>.</p>\n\n\n\n<figure class=\"wp-block-image size-large\"><a href=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Overcompleted_updatedfig4_automl.jpg\"><img loading=\"lazy\" width=\"1024\" height=\"704\" src=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Overcompleted_updatedfig4_automl-1024x704.jpg\" alt=\"A flow chart of low-rank model compression and overcomplete knowledge distillation applied to a convolutional neural network. On the left, an image of a frog is passed through three weight matrices, each followed by a nonlinearity, and then on to a classifier that labels the image a “frog.” The second weight matrix has two arrows pointing from it, both labeled “factorize during training.” The first points to the low-rank model compression pipeline. Two rectangles represent weight matrices: one labeled “U” and the other “V superscript T,” with U being tall and narrow and V superscript T being short and wide. Below the image is the label “($\\ll mn$ parameters).” Another arrow labeled “keep factorized during inference” points to the same image. The second arrow labeled “factorize during training” points to the overcomplete knowledge distillation pipeline. Two rectangles represent weight matrices: one labeled “U” and the other “V superscript T,” with U being short and wide and V superscript T being tall and narrow. Below the image is the label ($>mn$ parameters). An arrow labeled “multiply back before inference” points to a square labeled “UV superscript T” with the caption “(mn parameters).”\" class=\"wp-image-735718\" srcset=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Overcompleted_updatedfig4_automl-1024x704.jpg 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Overcompleted_updatedfig4_automl-300x206.jpg 300w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Overcompleted_updatedfig4_automl-768x528.jpg 768w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Overcompleted_updatedfig4_automl-16x12.jpg 16w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Overcompleted_updatedfig4_automl-800x550.jpg 800w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Overcompleted_updatedfig4_automl.jpg 1171w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" /></a><figcaption>Figure 4: Comparison between the model compression (top) and knowledge distillation (bottom) pipelines. While both train a factorized model, in overcomplete knowledge distillation, the factors are remultiplied after training to bring the parameter count back to that of a normal model. This is a teacher-free way of taking advantage of the training benefits of larger models without suffering their larger inference cost.</figcaption></figure>\n\n\n\n<p>Since spectral initialization isn’t applicable when the decomposition is overcomplete, we investigate the effect of Frobenius decay alone. We find that this regularization is critical for overcomplete knowledge distillation using ResNets trained on CIFAR data; in fact, overparameterizing and applying regular weight decay <em>decreases </em>model accuracy. On the other hand, using FD, we can train an overparameterized ResNet56 (1.7 million parameters during training/850,000 parameters at inference time) that matches the performance of ResNet110 (1.7 million parameters at both training and inference). Furthermore, training the overcomplete ResNet56 is 1.5 times faster than training the regular ResNet110. These results are the first successful application of overcomplete knowledge distillation for large-depth neural networks on CIFAR.</p>\n\n\n\n<h2>Factorization-aware training of Transformers</h2>\n\n\n\n<p>Finally, we apply spectral initialization and Frobenius decay in the MHA module of Transformer-based architectures. While we can show that this indeed helps when training such models using regular SGD, large-scale unsupervised models, such as BERT, are usually trained using variants of adaptive algorithms such as <a href=\"https://arxiv.org/abs/1412.6980\">Adam </a>or <a href=\"https://openreview.net/forum?id=Syx4wnEtvH\">LAMB </a>that “<a href=\"https://arxiv.org/abs/1711.05101\">decouple</a>” weight decay by defining it as an operation that subtracts a small constant times the parameter from itself before taking a gradient step. While the equivalence breaks for adaptive methods, in the case of SGD, this is equivalent to adding a squared Frobenius penalty term to the objective. Thus for adaptive algorithms, we can devise a similar “decoupled” FD scheme that subtracts a small constant times \\(UV\\)\\(^T\\) \\(V\\)=∇\\(_U\\)\\(_{2}^{1/}\\) ‖\\(UV\\)\\(^T\\) ‖ \\(_{Fro}^{2}\\) and \\(VU\\)\\(^T\\) \\(U\\)=∇\\(_V\\)\\(_{2}^{1/}\\) ‖\\(UV\\)\\(^T\\) ‖\\(_{Fro}^{2}\\) from the factors \\(U\\) and \\(V\\), respectively.</p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-large\"><a href=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/automl-figure_mulihead.jpg\"><img loading=\"lazy\" width=\"1024\" height=\"675\" src=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/automl-figure_mulihead-1024x675.jpg\" alt=\"diagram\" class=\"wp-image-735625\" srcset=\"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/automl-figure_mulihead-1024x675.jpg 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/automl-figure_mulihead-300x198.jpg 300w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/automl-figure_mulihead-768x506.jpg 768w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/automl-figure_mulihead-16x12.jpg 16w, https://www.microsoft.com/en-us/research/uploads/prod/2021/03/automl-figure_mulihead.jpg 1054w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" /></a><figcaption>Figure 5: A diagram of how multi-head self-attention implicitly consists of&#160;2<em>H</em>&#160;factorized neural layers. Specifically,&#160;multi-head attention&#160;is a sum&#160;over&#160;<em>H</em>&#160;attention&#160;heads (orange), each a matrix product&#160;of two&#160;terms:&#160;the first&#160;produced by&#160;the&#160;low-rank bilinear&#160;form&#160;<em>Q<sub>h</sub>&#160;K<sub>h</sub><sup>T</sup></em>&#160;and the second&#160;by the&#160;low-rank&#160;linear transform&#160;<em>V<sub>h</sub>&#160;O<sub>h</sub><sup>T</sup></em>.&#160;</figcaption></figure></div>\n\n\n\n<p>Applying FD in this manner to the MHA module when pretraining BERT-Base (110 million parameters) on unsupervised data yields a better downstream evaluation on the SQuAD task. When the MHA embedding dimension is halved (14.3 million fewer parameters), the advantage of FD continues to hold. On BERT-Large (340 million parameters), we’re able to halve the MHA embedding dimension (44.2 million fewer parameters) while losing less than a point in terms of F1-score.</p>\n\n\n\n<h2>Next steps in efficient model training</h2>\n\n\n\n<p>By studying how a standard initialization scheme and standard regularization scheme need to be modified to handle factorized layers, we were able to obtain better algorithms for learning efficient models, knowledge distillation, and training Transformers. We hope these results spur more investigation into how different components of standard training pipelines behave when training efficient models from scratch. For example:</p>\n\n\n\n<ul><li>How should techniques like Dropout and BatchNorm be modified for factorized layers?</li><li>Can we improve performance by<a href=\"https://arxiv.org/abs/2103.03936\"> factorizing using SVD after a few epochs of unfactorized model training rather than upon initialization</a>? </li><li>What aspects of model training should be changed when leveraging sparse or tensorial methods?</li><li>Are different models better suited to different compression schemes?</li></ul>\n\n\n<table style=\"float: right; width: 50%; margin: 15px; text-align: center; border: 1px solid #000000; border-collapse: collapse; border-spacing: inherit;\">\n<tbody>\n<tr style=\"height: 24px;\">\n<td style=\"background-color: #000000; padding: 5px 30px; border: inherit; height: 24px;\"><span style=\"color: #ffffff;\"><strong>Virtual speaker series</strong></span></td>\n</tr>\n<tr style=\"height: 23px;\">\n<td style=\"padding: 5px 30px; border: inherit; height: 23px;\"> Would you like to know more about AutoML research and its community at Microsoft? Join us for our free virtual speaker series “Directions in ML: AutoML and Automating Algorithms.”  <a href=\"https://www.microsoft.com/en-us/research/event/directions-in-ml/#!upcoming-speaker\"> Learn more and register.</a></td>\n</tr>\n</tbody>\n</table>\n\n\n<p>We’re excited by how this work can advance cost-effective, high-performing models capable of running on any device. We’re also exploring the link between training compute time and energy consumption. <a href=\"https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.economist.com%2Ftechnology-quarterly%2F2020%2F06%2F11%2Fthe-cost-of-training-machines-is-becoming-a-problem&data=04%7C01%7Cv-krdod%40microsoft.com%7Ce4894248a66b4e3583d808d8e4f39926%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637511082182909825%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C1000&sdata=WktVI2VM%2FcmKCQUEgJs44nmG9flfk3ABPG9ZsSwVlJw%3D&reserved=0\">Compute power for model training has been doubling at a rapid pace</a>. By reducing the required training time, our method for directly training smaller models raises the possibility of reducing energy consumption, as well. To learn more about the connections between compute and model architectures and power demands, check out the panel “<a href=\"https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.microsoft.com%2Fen-us%2Fresearch%2Fvideo%2Ffrontiers-in-machine-learning-climate-impact-of-machine-learning%2F&data=04%7C01%7Cv-krdod%40microsoft.com%7Ce4894248a66b4e3583d808d8e4f39926%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637511082182919817%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C1000&sdata=sEObeXFSQlmhUXKIWo274ygIJQZFgKIItUK2RFb7Kpo%3D&reserved=0\">Frontiers in Machine Learning: Climate Impact of Machine Learning</a>.”</p>\n\n\n\n<p><em><strong>Acknowledgments</strong></em><br><em>This work was led by Carnegie Mellon University PhD student Misha Khodak, in collaboration with Neil Tenenholtz, Lester Mackey, and Nicolò Fusi, during a Microsoft Research internship.</em></p>\n\n\n\n<p></p>\n\n\n\n<p></p>\n<p>The post <a rel=\"nofollow\" href=\"https://www.microsoft.com/en-us/research/blog/factorized-layers-revisited-compressing-deep-networks-without-playing-the-lottery/\">Factorized layers revisited: Compressing deep networks without playing the lottery</a> appeared first on <a rel=\"nofollow\" href=\"https://www.microsoft.com/en-us/research\">Microsoft Research</a>.</p>\n","descriptionType":"html","publishedDate":"Wed, 24 Mar 2021 21:22:38 +0000","feedId":3611,"bgimg":"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/1400x788_autoML_animation_no_logov2.gif","linkMd5":"5ce554b30239b9b49bf726645f89c45a","author":"Alexis Hagen","articleImgCdnMap":{"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/1400x788_autoML_animation_no_logov2.gif":null,"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Factorized-Neural_Figure-2_Automl-1024x508.jpg":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn18@2020_4/2021/04/03/05-25-33-970_1f09f62befe4d096.webp","https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Latex_AutoML_figure1-1024x185.jpg":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn44@2020_2/2021/04/03/05-25-33-921_ec6d6b0a2b7dd19f.webp","https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Latex-2-1024x126.jpg":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn32@2020_5/2021/04/03/05-25-34-606_b7c92fafb98610a0.webp","https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML_figure-updated_-CIFAR.jpg":null,"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Updated-Figure-_resnet-1024x411.jpg":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn37@2020_5/2021/04/03/05-25-33-953_02b95b7baee88feb.webp","https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Overcompleted_updatedfig4_automl-1024x704.jpg":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn35@2020_5/2021/04/03/05-25-33-918_b2657cb0f055d099.webp","https://www.microsoft.com/en-us/research/uploads/prod/2021/03/automl-figure_mulihead-1024x675.jpg":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn46@2020_5/2021/04/03/05-25-34-019_0024fe1848edea33.webp"},"publishedOrCreatedDate":1617427413155}],"record":{"createdTime":"2021-04-03 13:23:33","updatedTime":"2021-04-03 13:23:33","feedId":3611,"fetchDate":"Sat, 03 Apr 2021 05:23:33 +0000","fetchMs":462,"handleMs":142,"totalMs":242818,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"47468b37a6864928dc0b2c174a1c864f","hostName":"us-032*","requestId":"83fab8eb67484138b413e8217947606e_3611","contentType":"application/rss+xml; charset=UTF-8","totalBytes":161452,"bgimgsTotal":1,"bgimgsGithubTotal":0,"articlesImgsTotal":8,"articlesImgsGithubTotal":6,"successGithubMap":{"myreaderx10":1,"myreaderx3":1,"myreaderx2":1,"myreaderx12":1,"myreaderx13":1,"myreaderx18":1},"failGithubMap":{"myreaderx14":1}},"feed":{"createdTime":"2020-08-25 04:29:28","updatedTime":"2020-09-01 10:32:05","id":3611,"name":"Microsoft Research","url":"https://www.microsoft.com/en-us/research/feed/","subscriber":null,"website":null,"icon":"https://www.microsoft.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn38@2020_5/2020/09/01/02-32-02-775_ddd9473b17dec87a.ico","description":"","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2021-04-03 13:27:35","updatedTime":"2021-04-03 13:27:35","id":null,"feedId":3611,"linkMd5":"5ce554b30239b9b49bf726645f89c45a"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":161452,"tmpBgImgCdnBytes":0,"extra4":{"start":1617427412512,"total":0,"statList":[{"spend":504,"msg":"获取xml内容"},{"spend":142,"msg":"解释文章"},{"spend":121530,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":121582,"msg":"正文链接上传到cdn"}]},"extra5":8,"extra6":7,"extra7ImgCdnFailResultVector":[null,null,{"code":1,"isDone":false,"source":"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML_figure-updated_-CIFAR.jpg","sourceStatusCode":200,"destWidth":1850,"destHeight":681,"sourceBytes":145661,"destBytes":89294,"targetWebpQuality":75,"feedId":3611,"totalSpendMs":329,"convertSpendMs":84,"createdTime":"2021-04-03 13:25:35","host":"us-012*","referer":"https://www.microsoft.com/en-us/research/?p=734179","linkMd5ListStr":"5ce554b30239b9b49bf726645f89c45a","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn26/contents/2021/04/03/05-25-36-046_23c60a0f1ac3f9a0.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Sat, 03 Apr 2021 05:25:36 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["A6EA:5ED2:FDECAD:1A80A3E:6067FC50"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1617428942"],"x-ratelimit-used":["67"],"x-xss-protection":["0"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn26/contents/2021/04/03/05-25-36-046_23c60a0f1ac3f9a0.webp","historyStatusCode":[],"spendMs":36},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"142.2 KB","destSize":"87.2 KB","compressRate":"61.3%"},{"code":1,"isDone":false,"source":"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML_figure-updated_-CIFAR.jpg","sourceStatusCode":200,"destWidth":1850,"destHeight":681,"sourceBytes":145661,"destBytes":89294,"targetWebpQuality":75,"feedId":3611,"totalSpendMs":311,"convertSpendMs":72,"createdTime":"2021-04-03 13:25:36","host":"us-016*","referer":"https://www.microsoft.com/en-us/research/?p=734179","linkMd5ListStr":"5ce554b30239b9b49bf726645f89c45a","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn26/contents/2021/04/03/05-25-36-375_23c60a0f1ac3f9a0.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Sat, 03 Apr 2021 05:25:36 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["D524:7D36:7A56CE:17F3E60:6067FC50"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1617428942"],"x-ratelimit-used":["67"],"x-xss-protection":["0"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn26/contents/2021/04/03/05-25-36-375_23c60a0f1ac3f9a0.webp","historyStatusCode":[],"spendMs":36},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"142.2 KB","destSize":"87.2 KB","compressRate":"61.3%"},null,null,null,null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-037.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-25.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,null]},"http://us-51.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-015.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-016.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-040.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-012.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-011.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Latex_AutoML_figure1-1024x185.jpg","sourceStatusCode":200,"destWidth":1024,"destHeight":185,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn44@2020_2/2021/04/03/05-25-33-921_ec6d6b0a2b7dd19f.webp","sourceBytes":24255,"destBytes":15192,"targetWebpQuality":75,"feedId":3611,"totalSpendMs":454,"convertSpendMs":39,"createdTime":"2021-04-03 13:25:33","host":"us-016*","referer":"https://www.microsoft.com/en-us/research/?p=734179","linkMd5ListStr":"5ce554b30239b9b49bf726645f89c45a","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"23.7 KB","destSize":"14.8 KB","compressRate":"62.6%"},{"code":1,"isDone":false,"source":"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Overcompleted_updatedfig4_automl-1024x704.jpg","sourceStatusCode":200,"destWidth":1024,"destHeight":704,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn35@2020_5/2021/04/03/05-25-33-918_b2657cb0f055d099.webp","sourceBytes":67760,"destBytes":38530,"targetWebpQuality":75,"feedId":3611,"totalSpendMs":476,"convertSpendMs":28,"createdTime":"2021-04-03 13:25:33","host":"us-040*","referer":"https://www.microsoft.com/en-us/research/?p=734179","linkMd5ListStr":"5ce554b30239b9b49bf726645f89c45a","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"66.2 KB","destSize":"37.6 KB","compressRate":"56.9%"},{"code":1,"isDone":false,"source":"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/automl-figure_mulihead-1024x675.jpg","sourceStatusCode":200,"destWidth":1024,"destHeight":675,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn46@2020_5/2021/04/03/05-25-34-019_0024fe1848edea33.webp","sourceBytes":56352,"destBytes":28372,"targetWebpQuality":75,"feedId":3611,"totalSpendMs":538,"convertSpendMs":88,"createdTime":"2021-04-03 13:25:33","host":"us-015*","referer":"https://www.microsoft.com/en-us/research/?p=734179","linkMd5ListStr":"5ce554b30239b9b49bf726645f89c45a","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"55 KB","destSize":"27.7 KB","compressRate":"50.3%"},{"code":1,"isDone":false,"source":"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Updated-Figure-_resnet-1024x411.jpg","sourceStatusCode":200,"destWidth":1024,"destHeight":411,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn37@2020_5/2021/04/03/05-25-33-953_02b95b7baee88feb.webp","sourceBytes":63237,"destBytes":37738,"targetWebpQuality":75,"feedId":3611,"totalSpendMs":545,"convertSpendMs":40,"createdTime":"2021-04-03 13:25:33","host":"us-51*","referer":"https://www.microsoft.com/en-us/research/?p=734179","linkMd5ListStr":"5ce554b30239b9b49bf726645f89c45a","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"61.8 KB","destSize":"36.9 KB","compressRate":"59.7%"},{"code":1,"isDone":false,"source":"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/Factorized-Neural_Figure-2_Automl-1024x508.jpg","sourceStatusCode":200,"destWidth":1024,"destHeight":508,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn18@2020_4/2021/04/03/05-25-33-970_1f09f62befe4d096.webp","sourceBytes":46815,"destBytes":26244,"targetWebpQuality":75,"feedId":3611,"totalSpendMs":750,"convertSpendMs":28,"createdTime":"2021-04-03 13:25:33","host":"us-037*","referer":"https://www.microsoft.com/en-us/research/?p=734179","linkMd5ListStr":"5ce554b30239b9b49bf726645f89c45a","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"45.7 KB","destSize":"25.6 KB","compressRate":"56.1%"},{"code":1,"isDone":false,"source":"https://www.microsoft.com/en-us/research/uploads/prod/2021/03/AutoML-Latex-2-1024x126.jpg","sourceStatusCode":200,"destWidth":1024,"destHeight":126,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn32@2020_5/2021/04/03/05-25-34-606_b7c92fafb98610a0.webp","sourceBytes":19940,"destBytes":15376,"targetWebpQuality":75,"feedId":3611,"totalSpendMs":1811,"convertSpendMs":7,"createdTime":"2021-04-03 13:25:33","host":"europe-25*","referer":"https://www.microsoft.com/en-us/research/?p=734179","linkMd5ListStr":"5ce554b30239b9b49bf726645f89c45a","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"19.5 KB","destSize":"15 KB","compressRate":"77.1%"}],"successGithubMap":{"myreaderx10":1,"myreaderx3":1,"myreaderx2":1,"myreaderx12":1,"myreaderx13":1,"myreaderx18":1},"failGithubMap":{"myreaderx14":1}}