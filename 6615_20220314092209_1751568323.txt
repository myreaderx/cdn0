{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2022-03-14 17:22:09","updatedTime":"2022-03-14 17:22:09","title":"petite-vue源码剖析-双向绑定`v-model`的工作原理","link":"https://segmentfault.com/a/1190000041545178","description":"<h2>前言</h2><p>双向绑定<code>v-model</code>不仅仅是对可编辑HTML元素(<code>select</code>, <code>input</code>, <code>textarea</code>和附带<code>[contenteditable=true]</code>)同时附加<code>v-bind</code>和<code>v-on</code>，而且还能利用通过petite-vue附加给元素的<code>_value</code>、<code>_trueValue</code>和<code>_falseValue</code>属性提供存储非字符串值的能力。</p><h2>深入<code>v-model</code>工作原理</h2><pre><code class=\"ts\">export const model: Directive&lt;\n  HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement\n&gt; = ({ el, exp, get, effect, modifers }) =&gt; {\n  const type = el.type\n  // 通过`with`对作用域的变量/属性赋值\n  const assign = get(`val =&gt; { ${exp} = val }`)\n  // 若type为number则默认将值转换为数字\n  const { trim, number = type ==== 'number'} = modifiers || {}\n\n  if (el.tagName === 'select') {\n    const sel = el as HTMLSelectElement\n    // 监听控件值变化，更新状态值\n    listen(el, 'change', () =&gt; {\n      const selectedVal = Array.prototype.filter\n        .call(sel.options, (o: HTMLOptionElement) =&gt; o.selected)\n        .map((o: HTMLOptionElement) =&gt; number ? toNumber(getValue(o)) : getValue(o))\n      assign(sel.multiple ? selectedVal : selectedVal[0])\n    })\n\n    // 监听状态值变化，更新控件值\n    effect(() =&gt; {\n      value = get()\n      const isMultiple = sel.muliple\n      for (let i = 0, l = sel.options.length; i &lt; i; i++) {\n        const option = sel.options[i]\n        const optionValue = getValue(option)\n        if (isMulitple) {\n          // 当为多选下拉框时，入参要么是数组，要么是Map\n          if (isArray(value)) {\n            option.selected = looseIndexOf(value, optionValue) &gt; -1\n          }\n          else {\n            option.selected = value.has(optionValue)\n          }\n        }\n        else {\n          if (looseEqual(optionValue, value)) {\n            if (sel.selectedIndex !== i) sel.selectedIndex = i\n            return\n          }\n        }\n      }\n    })\n  }\n  else if (type === 'checkbox') {\n    // 监听控件值变化，更新状态值\n    listen(el, 'change', () =&gt; {\n      const modelValue = get()\n      const checked = (el as HTMLInputElement).checked\n      if (isArray(modelValue)) {\n        const elementValue = getValue(el)\n        const index = looseIndexOf(modelValue, elementValue)\n        const found = index !== -1\n        if (checked &amp;&amp; !found) {\n          // 勾选且之前没有被勾选过的则加入到数组中\n          assign(modelValue.concat(elementValue))\n        }\n        else if (!checked &amp;&amp; found) {\n          // 没有勾选且之前已勾选的排除后在重新赋值给数组\n          const filered = [...modelValue]\n          filteed.splice(index, 1)\n          assign(filtered)\n        }\n        // 其它情况就啥都不干咯\n      }\n      else {\n        assign(getCheckboxValue(el as HTMLInputElement, checked))\n      }\n    })\n\n    // 监听状态值变化，更新控件值\n    let oldValue: any\n    effect(() =&gt; {\n      const value = get()\n      if (isArray(value)) {\n        ;(el as HTMLInputElement).checked = \n          looseIndexOf(value, getValue(el)) &gt; -1\n      }\n      else if (value !== oldValue) {\n        ;(el as HTMLInputElement).checked = looseEqual(\n          value,\n          getCheckboxValue(el as HTMLInputElement, true)\n        )\n      }\n      oldValue = value\n    })\n  }\n  else if (type === 'radio') {\n    // 监听控件值变化，更新状态值\n    listen(el, 'change', () =&gt; {\n      assign(getValue(el))\n    })\n\n    // 监听状态值变化，更新控件值\n    let oldValue: any\n    effect(() =&gt; {\n      const value = get()\n      if (value !== oldValue) {\n        ;(el as HTMLInputElement).checked = looseEqual(value, getValue(el))\n      }\n    })\n  }\n  else {\n    // input[type=text], textarea, div[contenteditable=true]\n    const resolveValue = (value: string) =&gt; {\n      if (trim) return val.trim()\n      if (number) return toNumber(val)\n      return val\n    }\n\n    // 监听是否在输入法编辑器(input method editor)输入内容\n    listen(el, 'compositionstart', onCompositionStart)\n    listen(el, 'compositionend', onCompositionEnd)\n    // change事件是元素失焦后前后值不同时触发，而input事件是输入过程中每次修改值都会触发\n    listen(el, modifiers?.lazy ? 'change' : 'input', () =&gt; {\n      // 元素的composing属性用于标记是否处于输入法编辑器输入内容的状态，如果是则不执行change或input事件的逻辑\n      if ((el as any).composing) return\n      assign(resolveValue(el.value))\n    })\n    if (trim) {\n      // 若modifiers.trim，那么当元素失焦时马上移除值前后的空格字符\n      listen(el, 'change', () =&gt; {\n        el.value = el.value.trim()\n      })\n    }\n\n    effect(() =&gt; {\n      if ((el as any).composing) {\n        return\n      }\n      const curVal = el.value\n      const newVal = get()\n      // 若当前元素处于活动状态（即得到焦点），并且元素当前值进行类型转换后值与新值相同，则不用赋值；\n      // 否则只要元素当前值和新值类型或值不相同，都会重新赋值。那么若新值为数组[1,2,3]，赋值后元素的值将变成[object Array]\n      if (document.activeElement === el &amp;&amp; resolveValue(curVal) === newVal) {\n        return\n      }\n      if (curVal !== newVal) {\n        el.value = newVal\n      }\n    })\n  }\n}\n\n// v-bind中使用_value属性保存任意类型的值，在v-modal中读取\nconst getValue = (el: any) =&gt; ('_value' in el ? el._value : el.value)\n\nconst getCheckboxValue = (\n  el: HTMLInputElement &amp; {_trueValue?: any, _falseValue?: any}, // 通过v-bind定义的任意类型值\n  checked: boolean // checkbox的默认值是true和false\n) =&gt; {\n  const key = checked ? '_trueValue' : '_falseValue'\n  return key in el ? el[key] : checked\n}\n\nconst onCompositionStart = (e: Event) =&gt; {\n  // 通过自定义元素的composing元素，用于标记是否在输入法编辑器中输入内容\n  ;(e.target as any).composing = true\n}  \n\nconst onCompositionEnd = (e: Event) =&gt; {\n  const target = e.target as any\n  if (target.composing) {\n    // 手动触发input事件\n    target.composing = false\n    trigger(target, 'input')\n  }\n}\n\nconst trigger = (el: HTMLElement, type: string) =&gt; {\n  const e = document.createEvent('HTMLEvents')\n  e.initEvent(type, true, true)\n  el.dispatchEvent(e)\n}</code></pre><h2><code>compositionstart</code>和<code>compositionend</code>是什么？</h2><p><code>compositionstart</code>是开始在输入法编辑器上输入字符触发，而<code>compositionend</code>则是在输入法编辑器上输入字符结束时触发，另外还有一个<code>compositionupdate</code>是在输入法编辑器上输入字符过程中触发。</p><p>当我们在输入法编辑器敲击键盘时会按顺序执行如下事件：<br><code>compositionstart</code> -&gt; (<code>compositionupdate</code> -&gt; <code>input</code>)+ -&gt; <code>compositionend</code> -&gt; 当失焦时触发<code>change</code><br>当在输入法编辑器上输入<code>ri</code>后按空格确认<code>日</code>字符，则触发如下事件<br><code>compositionstart(data=&quot;&quot;)</code> -&gt; <code>compositionupdate(data=&quot;r&quot;)</code> -&gt; <code>input</code> -&gt; <code>compositionupdate(data=&quot;ri&quot;)</code> -&gt; <code>input</code> -&gt; <code>compositionupdate(data=&quot;日&quot;)</code> -&gt; <code>input</code> -&gt; <code>compositionend(data=&quot;日&quot;)</code></p><p>由于在输入法编辑器上输入字符时会触发<code>input</code>事件，所以petite-vue中通过在对象上设置<code>composing</code>标识是否执行<code>input</code>逻辑。</p><p>事件对象属性如下：</p><pre><code class=\"ts\">readonly target: EventTarget // 指向触发事件的HTML元素\nreadolny type: DOMString // 事件名称，即compositionstart或compositionend\nreadonly bubbles: boolean // 事件是否冒泡\nreadonly cancelable: boolean // 事件是否可取消\nreadonly view: WindowProxy // 当前文档对象所属的window对象(`document.defaultView`)\nreadonly detail: long\nreadonly data: DOMString // 最终填写到元素的内容，compositionstart为空，compositionend事件中能获取如&quot;你好&quot;的内容\nreadonly locale: DOMString</code></pre><h2>编码方式触发事件</h2><p>DOM Level2的事件中包含HTMLEvents, MouseEvents、MutationEvents和UIEvents，而DOM Level3则增加如CustomEvent等事件类型。</p><pre><code class=\"ts\">enum EventType {\n  // DOM Level 2 Events\n  UIEvents,\n  MouseEvents, // event.initMouseEvent\n  MutationEvents, // event.initMutationEvent\n  HTMLEvents, // event.initEvent\n  // DOM Level 3 Events\n  UIEvent,\n  MouseEvent, // event.initMouseEvent\n  MutationEvent, // event.initMutationEvent\n  TextEvent, // TextEvents is also supported, event.initTextEvent\n  KeyboardEvent, // KeyEvents is also supported, use `new KeyboardEvent()` to create keyboard event\n  CustomEvent, // event.initCustomEvent\n  Event, // Basic events module, event.initEvent\n}</code></pre><ul><li>HTMLEvents包含<code>abort</code>, <code>blur</code>, <code>change</code>, <code>error</code>, <code>focus</code>, <code>load</code>, <code>reset</code>, <code>resize</code>, <code>scroll</code>, <code>select</code>, <code>submit</code>, <code>unload</code>, <code>input</code></li><li>UIEvents包含<code>DOMActive</code>, <code>DOMFocusIn</code>, <code>DOMFocusOut</code>, <code>keydown</code>, <code>keypress</code>, <code>keyup</code></li><li>MouseEvents包含<code>click</code>, <code>mousedown</code>, <code>mousemove</code>, <code>mouseout</code>, <code>mouseover</code>, <code>mouseup</code></li><li>MutationEvents包含<code>DOMAttrModified</code>,<code>DOMNodeInserted</code>,<code>DOMNodeRemoved</code>,<code>DOMCharacterDataModified</code>,<code>DOMNodeInsertedIntoDocument</code>,<code>DOMNodeRemovedFromDocument</code>,<code>DOMSubtreeModified</code></li></ul><h3>创建和初始化事件对象</h3><h4>MouseEvent</h4><p>方法1</p><pre><code class=\"ts\">const e: Event = document.createEvent('MouseEvent')\ne.initMouseEvent(\n  type: string,\n  bubbles: boolean,\n  cancelable: boolean,\n  view: AbstractView, // 指向与事件相关的视图，一般为document.defaultView\n  detail: number, // 供事件回调函数使用，一般为0\n  screenX: number, // 相对于屏幕的x坐标\n  screenY: number, // 相对于屏幕的Y坐标\n  clientX: number, // 相对于视口的x坐标\n  clientY: number, // 相对于视口的Y坐标\n  ctrlKey: boolean, // 是否按下Ctrl键\n  altKey: boolean, // 是否按下Ctrl键\n  shiftKey: boolean, // 是否按下Ctrl键\n  metaKey: boolean, // 是否按下Ctrl键\n  button: number, // 按下按个鼠标键，默认为0.0左，1中，2右\n  relatedTarget: HTMLElement // 指向于事件相关的元素，一般只有在模拟mouseover和mouseout时使用\n)</code></pre><p>方法2</p><pre><code class=\"ts\">const e: Event = new MouseEvent('click', {\n  bubbles: false,\n  // ......\n})</code></pre><h4>KeyboardEvent</h4><pre><code class=\"ts\">const e = new KeyboardEvent(\n  typeArg: string, // 如keypress\n  {\n    ctrlKey: true,\n    // ......\n  }\n)</code></pre><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent\" rel=\"nofollow noreferrer\">https://developer.mozilla.org...</a></p><h4>Event的初始方法</h4><pre><code class=\"ts\">/**\n * 选项的属性\n * @param {string} name - 事件名称, 如click,input等\n * @param {boolean} [cancelable=false] - 指定事件是否可冒泡\n * @param {boolean} [cancelable=false] - 指定事件是否可被取消\n * @param {boolean} [composed=false] - 指定事件是否会在Shadow DOM根节点外触发事件回调函数\n */\nconst e = new Event('input', {\n  name: string, \n  bubbles: boolean = false, \n  cancelable: boolean = false, \n  composed: boolean = false\n})</code></pre><h4>CustomEvent</h4><p>方法1</p><pre><code class=\"ts\">const e: Event = document.createEvent('CustomEvent')\ne.initMouseEvent(\n  type: string,\n  bubbles: boolean,\n  cancelable: boolean,\n  detail: any\n)</code></pre><p>方法2</p><pre><code class=\"ts\">/**\n * 选项的属性\n * @param {string} name - 事件名称, 如click,input等，可随意定义\n * @param {boolean} [cancelable=false] - 指定事件是否可冒泡\n * @param {boolean} [cancelable=false] - 指定事件是否可被取消\n * @param {any} [detail=null] - 事件初始化时传递的数据\n */\nconst e = new CustomEvent('hi', {\n  name: string, \n  bubbles: boolean = false, \n  cancelable: boolean = false, \n  detail: any = null\n})</code></pre><h4>HTMLEvents</h4><pre><code class=\"ts\">const e: Event = document.createEvent('HTMLEvents')\ne.initMouseEvent(\n  type: string,\n  bubbles: boolean,\n  cancelable: boolean\n)</code></pre><h3>添加监听和发布事件</h3><pre><code class=\"ts\">element.addEventListener(type: string)\nelement.dispatchEvent(e: Event)</code></pre><h3>针对petite-vue进行分析</h3><pre><code class=\"ts\">const onCompositionEnd = (e: Event) =&gt; {\n  const target = e.target as any\n  if (target.composing) {\n    // 手动触发input事件\n    target.composing = false\n    trigger(target, 'input')\n  }\n}\nconst trigger = (el: HTMLElement, type: string) =&gt; {\n  const e = document.createEvent('HTMLEvents')\n  e.initEvent(type, true, true)\n  el.dispatchEvent(e)\n}</code></pre><p>当在输入法编辑器操作完毕后会手动触发input事件，但当事件绑定修饰符设置为<code>lazy</code>后并没有绑定<code>input</code>事件回调函数，此时在输入法编辑器操作完毕后并不会自动更新状态，我们又有机会可以贡献代码了:)</p><pre><code class=\"ts\">// change事件是元素失焦后前后值不同时触发，而input事件是输入过程中每次修改值都会触发\n    listen(el, modifiers?.lazy ? 'change' : 'input', () =&gt; {\n      // 元素的composing属性用于标记是否处于输入法编辑器输入内容的状态，如果是则不执行change或input事件的逻辑\n      if ((el as any).composing) return\n      assign(resolveValue(el.value))\n    })</code></pre><h3>外番：IE的事件模拟</h3><pre><code class=\"js\">var e = document.createEventObject()\ne.shiftKey = false\ne.button = 0\ndocument.getElementById('click').fireEvent('onclick', e)</code></pre><h2>总结</h2><p>整合LayUI等DOM-based框架时免不了使用<code>this.$ref</code>获取元素实例，下一篇《petite-vue源码剖析-ref的工作原理》我们一起来探索吧！</p>","descriptionType":"html","publishedDate":"Mon, 14 Mar 2022 07:03:10 +0000","feedId":6615,"bgimg":"","linkMd5":"ca7466c8e64b87d7ac91682f3c0dbbf4","bgimgJsdelivr":"","metaImg":"","author":"肥仔John","publishedOrCreatedDate":1647249729451}],"record":{"createdTime":"2022-03-14 17:22:09","updatedTime":"2022-03-14 17:22:09","feedId":6615,"fetchDate":"Mon, 14 Mar 2022 09:22:09 +0000","fetchMs":3682,"handleMs":106,"totalMs":31176,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"245d88d7b2d8f26704713c23b090d029","hostName":"us-014*","requestId":"030b60864ca04186bcfea87bd22850ac_6615","contentType":"application/atom+xml; charset=UTF-8","totalBytes":0,"bgimgsTotal":0,"bgimgsGithubTotal":0,"articlesImgsTotal":0,"articlesImgsGithubTotal":0,"successGithubMap":{},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:33:08","updatedTime":"2021-04-03 14:32:14","id":6615,"name":"SegmentFault 最新的文章","url":"http://segmentfault.com/feeds/blogs","subscriber":null,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx63/cdn75@2020_2/2021/04/03/06-32-08-760_eb238dca7c8e9f0e.jpg","description":"","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1647249698276,"total":0,"statList":[{"spend":31069,"msg":"获取xml内容"},{"spend":106,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":0,"msg":"正文链接上传到cdn"}]},"extra5":0,"extra6":0,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{},"extra12ImgCdnSuccessResultVector":[],"successGithubMap":{},"failGithubMap":{}}