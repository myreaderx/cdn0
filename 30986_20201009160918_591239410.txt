{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-10 00:05:15","updatedTime":"2020-10-10 00:05:15","title":"Finding Bieber: On removing duplicates from a set of documents","link":"http://stevehanov.ca/blog/?id=144","description":"<p> So I have two million song lyrics in a big file. Don't ask me how I got it. The point is that I want to find the most poetic phrase of all time. <p> Problem is, the origins of this file are so sketchy it would make a <i>Pearls Before Swine</i> cartoon look like a Da Vinci. There could well be thousands of copies of Justin Bieber's <i>Eenie Meenie</i>, all frenetically typed in by a horde of snapchatting teenagers using mom's Windows Vista laptop with the missing shift key. <p> I don't want my analysis to include the copies and covers of the same song. So I have two problems to solve: \n   <ol> \n    <li>How can we know whether two songs are actually the same? <li>And how can we do this quickly, over the whole collection? </li></li>\n   </ol> <h3>But first</h3> When dealing with text, or images, or sound files, or whatever kind of media tickles your pickle, we want to transform them into numbers that computers can use. We turn them into <i>feature vectors</i>, or what most Ph.D toting natural language processing experts call, when they really want to get technical for a stodgy old formal publication -- one that will put them on the tenure track -- when they want to choose the most technically precise phrase, they call them: \"bags of words\". I am not making this up. <p> Lets say we had this paragon of poesy: <pre>\nEenie, meenie, miney, mo\nCatch a bad chick by her toe\nIf she holla\nIf, if, if she holla, let her go\n</pre> <p> A bag of words is set of words, and their counts. The ordering of the words is lost to simplify things. Order is rarely important anyway. <p> {a: 1, bad: 1, by: 1, catch: 1, chick: 1, eenie: 1, go: 1,her: 2, holla: 2, if: 4, let: 1, meenie: 1, miney: 1 mo:1, she: 2, toe: 1 } <p> We could go even simpler and remove the counts, if we feel they aren't important. <p> {a, bad, by, catch, chick, eenie, go, her, holla, if, let, meenie, miney, mo, she, toe} <p> As we process each document from the database, the first thing we do is turn it into the bag of words. In python it's a one-liner. <pre>\ndef makeBag(song):\n    return set(song.replace(\",\", \" \").split())\n</pre> <h3>Comparing two bags</h3> Let's say we had three sets. One is the song above. In the other, the teenaged transcriber thought \"miney\" should be spelled \"miny\". The third is Frank Sinatra's Fly me to the moon. We would like a distance function, so that if two songs are differ by only one word, then the distance would be small, and if they are completely different, the distance is large. <p> To find the answer, we have to travel to 1907, and accompany Swiss professor Paul Jaccard on his trip to the Alps to do some serious botany. He noticed that there were different clusters of plants in different regions, and wondered if these clusters could be used to determine the ecological evolution of the area. He writes: \n          <blockquote>\n            In order to reply to this question I have considered, in an alpine district of fair size, various natural sub-divisions, presenting, besides numerous resemblances in their ecological conditions (i.e. conditions dependent on soil and climate), a few characteristic differences, and I have sought to determine, by comparison, the influence of these resemblances and differences on the composition of flora. \n          </blockquote> <p align=\"center\"><img src=\"http://gs.riverdale.k12.or.us/~suzannal17/swiss/alpsmount.jpg\" /></p> He counted all of the different plants in different regions, and came up with this formula to compare how similar two different regions are: <p> Number of species common to the two districts / total number of species in the two districts. <p> This gives 0 if the sets share no common elements, and 1 if they are the same. But that's the opposite of what we need, so we subtract it from one to obtain a distance function. <pre>\ndef Jaccard(A, B):  \n    intersection = len(A &amp; B)\n    union = len(A | B)\n    return 1.0 - float(intersection)/union\n</pre> <p> Now we have a distance function. To find all the duplicate songs, we just run it on every pair of songs that we have. With two million songs, that's only, umm, <i>four trillion comparisons</i>. If we can do 10000/second we could be done in about three years. Maybe we could split it up, use some cloud instances, pay a few thousand dollars for compute time and be done in a day. <p> Or we could use algorithms. <h3>Time to get LSH'd</h3> <p> I have two little girls and coincidentally, they have approximately two million individual socks, with no two pairs alike. Yet it doesn't take me three years to sort them, because I use a locality sensitive hash. <p align=\"center\"><img src=\"http://2.bp.blogspot.com/_ZptPwpCkJ5g/TTtGhTPa_cI/AAAAAAAAAsw/BcdxxDDvsDY/s1600/socks.jpg\" /></p> <p> I take a sock, and if it's pinkish, I put it in the top left. Purple goes in the top right, and colours in the middle go in between. Blues go on the bottom, greens have their own spot. By the time I run out of socks to sort, the pairs are of near each-other on the carpet. Then it's a simple matter to join them together. <p> Actually, over the years, I have further refined the system, because \"pinkish\" is ambiguous. Children's socks are a mix of shapes, eyes, cats &amp; dinosaurs of all colours. If the sock as any blue at all, no matter how small, it goes top left. Otherwise, if it has any red, other colours notwithstanding, it goes bottom left. Otherwise, if it has any green whatsoever, top right. Otherwise, bottom left. <p> This is known as: <h3>MinHash</h3> <p> <img align=\"right\" width=\"120px\" src=\"http://4.bp.blogspot.com/_CNrtanQnRc0/SO7PQ9XIxQI/AAAAAAAAAIY/rbi802mOxmY/s320/lance-ito.jpg\"> Now let's travel to 1997. <i>Titanic</i> and <i>The Full Monty</i> are in theaters. Some people pay to see the film 9 or 10 times. (<i>Titanic</i>, I mean) This is unsurprising because the only thing on TV is the OJ Simpson trial. On the WWW, then known as the <i>World Wide Wait</i>, AltaVista is one of the top search engines for finding the status of the <a href=\"http://en.wikipedia.org/wiki/Trojan_Room_coffee_pot\">Trojan Room Coffee Pot</a>. <p> Computer Scientist Andrei Broder, who has been with AltaVista from near the beginning, is working on the <i>duplicates problem</i>. As the web was expanding, a lot of search results that come up are duplicates of other pages. For search, this is Very Annoying. Broder devises a way of quickly searching these millions of pages for duplicates. <p> MinHash is a function that reduces a text document to a single number. Documents that share many of the same words have numbers that are near each-other. <p> How is this done? <p> Suppose you build a dictionary of all the words that could possibly occur in your documents, and you number them. <pre>\n0 aardvark\n1 abacus\n2 abacuses\n3 abaft\n4 abalone\n5 abandon\n...\n</pre> The minhash would take this dictionary, and take your document, and assign it the number of the minimum word that occurs. That's it. <p> So if your document is \"The aardvark abandoned his abacus\" then the number assigned would be 0 (because aardvark is the zero'th word in the dictionary). In fact, every document that talks about an aardvark would hash to 0. <p> But what if, by chance, there is a document that is similar to our aardvark text but mispells it? Then they would hash to some other number entirely. <p> To guard against this, we actually take several random permutations of the dictionary and average the minhash against each of them. \n                           <table> \n                            <tr> \n                             <td> <pre>\n0 abacus\n1 abalone\n2 abacuses\n3 aardvark\n4 abaft\n5 abandoned\n</pre> </td> \n                             <td> <pre>\n0 abalone\n1 abacus\n2 abacuses\n3 abandoned\n4 aardvark\n5 abaft\n</pre> </td> \n                             <td> <pre>\n0 abacus\n1 abaft\n2 abacuses\n3 abalone\n4 abandoned\n5 aardvark\n</pre> </td> \n                            </tr> \n                           </table> \n                           <ul> \n                            <li>Document: \"The aardvark abandoned his abacus\" <li>Minhash under first dictionary: 0 <li>Minhash under dictionary 2: 1 <li>Minhash under dictionary 3: 0 <li>Combined minhash: (0 + 1 + 0) / 3 = 0.333333333 </li></li></li></li></li>\n                           </ul> As you use more and more dictionaries to compute the hash, then documents that share similar sets of words begin to hash to similar values. If you like code, here's some python. <p> <pre>\nimport random\n\ndef MinHash(corpus, k = 5):\n    # Map from words to array of the five values\n    words = {}\n    for word in corpus:\n        words[word] = []\n\n    for i in range(k):\n        shuffled = list(corpus)\n        random.shuffle(shuffled)\n        for j in range(len(shuffled)):\n            words[shuffled[j]].append(j)\n\n    def hash(document):\n        total = 0.\n\n        # for each hash function, find the lowest value word in the\n        # document.\n\n        #sum(min(h_k(w) over words in doc)\n\n        vals = [-1] * k\n        for word in document:\n            if word in words:\n                m = words[word]\n                for i in range(k):\n                    if vals[i] == -1 or m[i] &lt; vals[i]:\n                        vals[i] = m[i]\n\n        return sum(vals) / k\n\n    return hash\n</pre> <h3>Finally</h3> Using MinHash, you can mark duplicates in three passes through the data, and a sort. \n                            <ol> \n                             <li>In the first pass, build a dictionary of all the words that occur, and use it to create the hash function. <li>In the second pass, compute the minhash of each document. <li>Sort the documents by their minhash (if you can afford to do so) or place them into buckets. In either case, documents that are similar will theoretically be close together. <li>Finally, go through the list (if sorted) or nearby buckets, and compare documents within a certain window using a more refined comparison function, such as Jaccard distance. Anything that is close enough to being the same is a duplicate. </li></li></li></li>\n                            </ol> <h3>Oh yeah</h3> I will assume that the most poetic words of all time, in English, are the ones most likely to end a line. After analysis of 2 million song lyrics, with near duplicates removed, they are: <pre>\nat all\nno more\ndon't know\nall alone\nright now\nall night\nat night\nfar away\nlike that\nlet go\ntoo late\n</pre> And the number one most poetic phrase in the history of music: <pre>\noh oh\n</pre> \n                            <ul>\n                             <li><a href=\"http://stevehanov.ca/blog/?id=9\">What does your phone number spell?</a><li><a href=\"http://stevehanov.ca/blog/?id=92\">qb.js: An implementation of QBASIC in Javascript </a><li><a href=\"http://stevehanov.ca/blog/?id=73\">How to run a linux based home web server</a><li><a href=\"http://stevehanov.ca/blog/?id=57\">Coding tips they don't teach you in school</a><li><a href=\"http://stevehanov.ca/blog/?id=70\">Finding great ideas for your startup</a><li><a href=\"http://stevehanov.ca/blog/?id=115\">Compressing dictionaries with a DAWG</a><li><a href=\"http://stevehanov.ca/blog/?id=130\">VP trees: A data structure for finding stuff fast</a></li></li></li></li></li></li></li>\n                            </ul> </p></p></p></p></p></p></p></p></img></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>","descriptionType":"html","publishedDate":"Mon, 10 Nov 2014 13:00:00 +0000","feedId":30986,"bgimg":"http://gs.riverdale.k12.or.us/~suzannal17/swiss/alpsmount.jpg","linkMd5":"15bd41b69b3ae0acd2d43ff05e42162b","author":"Steve Hanov","articleImgCdnMap":{"http://gs.riverdale.k12.or.us/~suzannal17/swiss/alpsmount.jpg":null,"http://2.bp.blogspot.com/_ZptPwpCkJ5g/TTtGhTPa_cI/AAAAAAAAAsw/BcdxxDDvsDY/s1600/socks.jpg":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn40@2020_5/2020/10/09/16-07-17-711_8bf591d72d3fe59a.webp","http://4.bp.blogspot.com/_CNrtanQnRc0/SO7PQ9XIxQI/AAAAAAAAAIY/rbi802mOxmY/s320/lance-ito.jpg":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn38@2020_3/2020/10/09/16-07-17-627_d7b6ac1b7dad5719.webp"},"publishedOrCreatedDate":1602259515554}],"record":{"createdTime":"2020-10-10 00:05:15","updatedTime":"2020-10-10 00:05:15","feedId":30986,"fetchDate":"Fri, 09 Oct 2020 16:05:15 +0000","fetchMs":373,"handleMs":807,"totalMs":244809,"newArticles":0,"totalArticles":103,"status":1,"type":0,"ip":"818b2f91db1355e1383e1c549cf591f8","hostName":"europe69*","requestId":"7f846b48fb444ef384204adec9700016_30986","contentType":"application/atom+xml","totalBytes":42446,"bgimgsTotal":1,"bgimgsGithubTotal":0,"articlesImgsTotal":3,"articlesImgsGithubTotal":2,"successGithubMap":{"myreaderx11":1,"myreaderx31":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:51:21","updatedTime":"2020-09-07 02:51:21","id":30986,"name":"Steve Hanov's Programming Blog","url":"http://stevehanov.ca/blog/?atom","subscriber":104,"website":null,"icon":"http://stevehanov.ca/favicon.ico","icon_jsdelivr":null,"description":"\n      Windows, C++ programming techniques, Mobile technology, \n      neat tricks you can do with Computer Science algorithms.\n  ","weekly":null,"link":"http://stevehanov.ca"},"noPictureArticleList":[{"createdTime":"2020-10-10 00:09:18","updatedTime":"2020-10-10 00:09:18","id":null,"feedId":30986,"linkMd5":"15bd41b69b3ae0acd2d43ff05e42162b"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":42446,"tmpBgImgCdnBytes":0,"extra4":{"start":1602259513961,"total":0,"statList":[{"spend":787,"msg":"获取xml内容"},{"spend":807,"msg":"解释文章"},{"spend":120326,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":121633,"msg":"正文链接上传到cdn"}]},"extra5":3,"extra6":2,"extra7ImgCdnFailResultVector":[null,null,null,null,null,null],"extra10_invalidATagHrefValue":{"http://stevehanov.ca/blog/?id=144_?id=73":"http://stevehanov.ca/blog/?id=73","http://stevehanov.ca/blog/?id=144_?id=92":"http://stevehanov.ca/blog/?id=92","http://stevehanov.ca/blog/?id=144_?id=70":"http://stevehanov.ca/blog/?id=70","http://stevehanov.ca/blog/?id=144_?id=9":"http://stevehanov.ca/blog/?id=9","http://stevehanov.ca/blog/?id=144_?id=130":"http://stevehanov.ca/blog/?id=130","http://stevehanov.ca/blog/?id=144_?id=57":"http://stevehanov.ca/blog/?id=57","http://stevehanov.ca/blog/?id=144_?id=115":"http://stevehanov.ca/blog/?id=115"},"extra111_proxyServerAndStatMap":{"http://europe63.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://us-028.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,null]},"http://us-029.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"http://4.bp.blogspot.com/_CNrtanQnRc0/SO7PQ9XIxQI/AAAAAAAAAIY/rbi802mOxmY/s320/lance-ito.jpg","sourceStatusCode":200,"destWidth":300,"destHeight":200,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn38@2020_3/2020/10/09/16-07-17-627_d7b6ac1b7dad5719.webp","sourceBytes":13542,"destBytes":8518,"targetWebpQuality":75,"feedId":30986,"totalSpendMs":1186,"convertSpendMs":7,"createdTime":"2020-10-10 00:07:17","host":"us-028*","referer":"http://stevehanov.ca/blog/?id=144","linkMd5ListStr":"15bd41b69b3ae0acd2d43ff05e42162b","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"13.2 KB","destSize":"8.3 KB","compressRate":"62.9%"},{"code":1,"isDone":false,"source":"http://2.bp.blogspot.com/_ZptPwpCkJ5g/TTtGhTPa_cI/AAAAAAAAAsw/BcdxxDDvsDY/s1600/socks.jpg","sourceStatusCode":200,"destWidth":550,"destHeight":367,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn40@2020_5/2020/10/09/16-07-17-711_8bf591d72d3fe59a.webp","sourceBytes":97589,"destBytes":33928,"targetWebpQuality":75,"feedId":30986,"totalSpendMs":1396,"convertSpendMs":16,"createdTime":"2020-10-10 00:07:17","host":"us-029*","referer":"http://stevehanov.ca/blog/?id=144","linkMd5ListStr":"15bd41b69b3ae0acd2d43ff05e42162b","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"95.3 KB","destSize":"33.1 KB","compressRate":"34.8%"}],"successGithubMap":{"myreaderx11":1,"myreaderx31":1},"failGithubMap":{}}