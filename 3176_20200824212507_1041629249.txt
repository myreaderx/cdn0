{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-08-25 05:24:49","updatedTime":"2020-08-25 05:24:49","title":"SwiftUI 的一些初步探索 (二)","link":"https://onevcat.com/2019/06/swift-ui-firstlook-2/","description":"<p><img src=\"https://onevcat.com/assets/images/2019/swift-ui.png\" alt=\"\" /></p> \n<blockquote> \n <p>我已经计划写一本关于 SwiftUI 和 Combine 编程的书籍，希望能通过一些实践案例帮助您快速上手 SwiftUI 及 Combine 响应式编程框架，掌握下一代客户端 UI 开发技术。现在这本书已经开始预售，预计能在 10 月左右完成。如果您对此有兴趣，可以查看 <a href=\"https://objccn.io/products/\">ObjC 中国的产品页面</a>了解详情及购买。十分感谢！</p> \n</blockquote> \n<p>接<a href=\"https://onevcat.com/2019/06/swift-ui-firstlook/\">上一篇</a>继续对 SwiftUI 的教程进行一些解读。</p> \n<h3 id=\"教程-2---building-lists-and-navigation\"><a href=\"https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation\">教程 2 - Building Lists and Navigation</a></h3> \n<h4 id=\"section-4---step-2-静态-list\"><a href=\"https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation#create-the-list-of-landmarks\">Section 4 - Step 2: 静态 <code class=\"highlighter-rouge\">List</code></a></h4> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"kt\">List</span> <span class=\"p\">{</span>\n        <span class=\"kt\">LandmarkRow</span><span class=\"p\">(</span><span class=\"nv\">landmark</span><span class=\"p\">:</span> <span class=\"n\">landmarkData</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n        <span class=\"kt\">LandmarkRow</span><span class=\"p\">(</span><span class=\"nv\">landmark</span><span class=\"p\">:</span> <span class=\"n\">landmarkData</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>这里的 <code class=\"highlighter-rouge\">List</code> 和 <code class=\"highlighter-rouge\">HStack</code> 或者 <code class=\"highlighter-rouge\">VStack</code> 之类的容器很相似，接受一个 view builder 并采用 View DSL 的方式列举了两个 <code class=\"highlighter-rouge\">LandmarkRow</code>。这种方式构建了对应着 <code class=\"highlighter-rouge\">UITableView</code> 的静态 cell 的组织方式。</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"nf\">init</span><span class=\"p\">(</span><span class=\"nv\">content</span><span class=\"p\">:</span> <span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Content</span><span class=\"p\">)</span>\n</code></pre>\n </div>\n</div> \n<p>我们可以运行 app，并使用 Xcode 的 View Hierarchy 工具来观察 UI，结果可能会让你觉得很眼熟：</p> \n<p><img src=\"https://images.xiaozhuanlan.com/photo/2019/a900c8d2687dab13ba438602da826552.png\" alt=\"\" /></p> \n<p>实际上在屏幕上绘制的 <code class=\"highlighter-rouge\">UpdateCoalesingTableView</code> 是一个 <code class=\"highlighter-rouge\">UITableView</code> 的子类，而两个 cell <code class=\"highlighter-rouge\">ListCoreCellHost</code> 也是 <code class=\"highlighter-rouge\">UITableViewCell</code> 的子类。对于 <code class=\"highlighter-rouge\">List</code> 来说，SwiftUI 底层直接使用了成熟的 <code class=\"highlighter-rouge\">UITableView</code> 的一套实现逻辑，而并非重新进行绘制。相比起来，像是 <code class=\"highlighter-rouge\">Text</code> 或者 <code class=\"highlighter-rouge\">Image</code> 这样的单一 <code class=\"highlighter-rouge\">View</code> 在 <code class=\"highlighter-rouge\">UIKit</code> 层则全部统一由 <code class=\"highlighter-rouge\">DisplayList.ViewUpdater.Platform.CGDrawingView</code> 这个 <code class=\"highlighter-rouge\">UIView</code> 的子类进行绘制。</p> \n<p>不过在使用 SwiftUI 时，我们首先需要做的就是跳出 UIKit 的思维方式，不应该去关心背后的绘制和实现。使用 <code class=\"highlighter-rouge\">UITableView</code> 来表达 <code class=\"highlighter-rouge\">List</code> 也许只是权宜之计，也许在未来也会被另外更高效的绘制方式取代。由于 SwiftUI 层只是 <code class=\"highlighter-rouge\">View</code> 描述的数据抽象，因此和 React 的 Virtual DOM 以及 Flutter 的 Widget 一样，背后的具体绘制方式是完全解耦合，并且可以进行替换的。这为今后 SwiftUI 更进一步留出了足够的可能性。</p> \n<h4 id=\"section-5---step-2-动态-list-和-identifiable\"><a href=\"https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation#make-the-list-dynamic\">Section 5 - Step 2: 动态 <code class=\"highlighter-rouge\">List</code> 和 <code class=\"highlighter-rouge\">Identifiable</code></a></h4> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kt\">List</span><span class=\"p\">(</span><span class=\"n\">landmarkData</span><span class=\"o\">.</span><span class=\"nf\">identified</span><span class=\"p\">(</span><span class=\"nv\">by</span><span class=\"p\">:</span> <span class=\"p\">\\</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">))</span> <span class=\"p\">{</span> <span class=\"n\">landmark</span> <span class=\"k\">in</span>\n    <span class=\"kt\">LandmarkRow</span><span class=\"p\">(</span><span class=\"nv\">landmark</span><span class=\"p\">:</span> <span class=\"n\">landmark</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>除了静态方式以外，<code class=\"highlighter-rouge\">List</code> 当然也可以接受动态方式的输入，这时使用的初始化方法和上面静态的情况不一样：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">struct</span> <span class=\"kt\">List</span><span class=\"o\">&lt;</span><span class=\"kt\">Selection</span><span class=\"p\">,</span> <span class=\"kt\">Content</span><span class=\"o\">&gt;</span> <span class=\"k\">where</span> <span class=\"kt\">Selection</span> <span class=\"p\">:</span> <span class=\"kt\">SelectionManager</span><span class=\"p\">,</span> <span class=\"kt\">Content</span> <span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">init</span><span class=\"o\">&lt;</span><span class=\"kt\">Data</span><span class=\"p\">,</span> <span class=\"kt\">RowContent</span><span class=\"o\">&gt;</span><span class=\"p\">(</span>\n        <span class=\"n\">_</span> <span class=\"nv\">data</span><span class=\"p\">:</span> <span class=\"kt\">Data</span><span class=\"p\">,</span> <span class=\"nv\">action</span><span class=\"p\">:</span> <span class=\"kd\">@escaping</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Element</span><span class=\"o\">.</span><span class=\"kt\">IdentifiedValue</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span><span class=\"p\">,</span>\n        <span class=\"nv\">rowContent</span><span class=\"p\">:</span> <span class=\"kd\">@escaping</span> <span class=\"p\">(</span><span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Element</span><span class=\"o\">.</span><span class=\"kt\">IdentifiedValue</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">RowContent</span><span class=\"p\">)</span> \n    <span class=\"k\">where</span> \n        <span class=\"kt\">Content</span> <span class=\"o\">==</span> <span class=\"kt\">ForEach</span><span class=\"o\">&lt;</span><span class=\"kt\">Data</span><span class=\"p\">,</span> <span class=\"kt\">Button</span><span class=\"o\">&lt;</span><span class=\"kt\">HStack</span><span class=\"o\">&lt;</span><span class=\"kt\">RowContent</span><span class=\"o\">&gt;&gt;&gt;</span><span class=\"p\">,</span> \n        <span class=\"kt\">Data</span> <span class=\"p\">:</span> <span class=\"kt\">RandomAccessCollection</span><span class=\"p\">,</span> \n        <span class=\"kt\">RowContent</span> <span class=\"p\">:</span> <span class=\"kt\">View</span><span class=\"p\">,</span> \n        <span class=\"kt\">Data</span><span class=\"o\">.</span><span class=\"kt\">Element</span> <span class=\"p\">:</span> <span class=\"kt\">Identifiable</span>\n        \n    <span class=\"c1\">//...</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>这个初始化方法的约束比较多，我们一行行来看：</p> \n<ul> \n <li><code class=\"highlighter-rouge\">Content == ForEach&lt;Data, Button&lt;HStack&lt;RowContent&gt;&gt;&gt;</code> 因为这个函数签名中并没有出现 <code class=\"highlighter-rouge\">Content</code>，<code class=\"highlighter-rouge\">Content</code> 仅只 <code class=\"highlighter-rouge\">List&lt;Selection, Content&gt;</code> 的类型声明中有定义，所以在这与其说是一个约束，不如说是一个用来反向确定 <code class=\"highlighter-rouge\">List</code> 实际类型的描述。现在让我们先将注意力放在更重要的地方，稍后会再多讲一些这个。</li> \n <li><code class=\"highlighter-rouge\">Data : RandomAccessCollection</code> 这基本上等同于要求第一个输入参数是 <code class=\"highlighter-rouge\">Array</code>。</li> \n <li><code class=\"highlighter-rouge\">RowContent : View</code> 对于构建每一行的 <code class=\"highlighter-rouge\">rowContent</code> 来说，需要返回是 <code class=\"highlighter-rouge\">View</code> 是很正常的事情。注意 <code class=\"highlighter-rouge\">rowContent</code> 其实也是被 <code class=\"highlighter-rouge\">@ViewBuilder</code> 标记的，因此你也可以把 <code class=\"highlighter-rouge\">LandmarkRow</code> 的内容展开写进去。不过一般我们会更希望尽可能拆小 UI 部件，而不是把东西堆在一起。</li> \n <li><code class=\"highlighter-rouge\">Data.Element : Identifiable</code> 要求 <code class=\"highlighter-rouge\">Data.Element</code> (也就是数组元素的类型) 上存在一个可以辨别出某个实例的<a href=\"https://developer.apple.com/documentation/swiftui/identifiable/3285392-id\">满足 <code class=\"highlighter-rouge\">Hashable</code> 的 id</a>。这个要求将在数据变更时快速定位到变化的数据所对应的 cell，并进行 UI 刷新。</li> \n</ul> \n<p>关于 <code class=\"highlighter-rouge\">List</code> 以及其他一些常见的基础 <code class=\"highlighter-rouge\">View</code>，有一个比较有趣的事实。在下面的代码中，我们期望 <code class=\"highlighter-rouge\">List</code> 的初始化方法生成的是某个类型的 <code class=\"highlighter-rouge\">View</code>：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"kt\">List</span> <span class=\"p\">{</span>\n        <span class=\"c1\">//...</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>但是你看遍 <a href=\"https://developer.apple.com/documentation/swiftui/list\">List 的文档</a>，甚至是 Cmd + Click 到 SwiftUI 的 interface 中查找 <code class=\"highlighter-rouge\">View</code> 相关的内容，都找不到 <code class=\"highlighter-rouge\">List : View</code> 之类的声明。</p> \n<p>难道是因为 SwiftUI 做了什么手脚，让本来没有满足 <code class=\"highlighter-rouge\">View</code> 的类型都可以“充当”一个 <code class=\"highlighter-rouge\">View</code> 吗？当然不是这样…如果你在运行时暂定 app 并用 lldb 打印一下 <code class=\"highlighter-rouge\">List</code> 的类型信息，可以看到下面的下面的信息：</p> \n<div class=\"highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code>(lldb) type lookup List\n...\nstruct List&lt;Selection, Content&gt; : SwiftUI._UnaryView where ...\n</code></pre>\n </div>\n</div> \n<p>进一步，<code class=\"highlighter-rouge\">_UnaryView</code> 的声明是：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">protocol</span> <span class=\"nv\">_UnaryView</span> <span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"k\">where</span> <span class=\"k\">Self</span><span class=\"o\">.</span><span class=\"kt\">Body</span> <span class=\"p\">:</span> <span class=\"n\">_UnaryView</span> <span class=\"p\">{</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>SwiftUI 内部的一元视图 <code class=\"highlighter-rouge\">_UnaryView</code> 协议虽然是满足 <code class=\"highlighter-rouge\">View</code> 的，但它被隐藏起来了，而满足它的 <code class=\"highlighter-rouge\">List</code> 虽然是 public 的，但是却可以把这个协议链的信息也作为内部信息隐藏起来。这是 Swift 内部框架的特权，第三方的开发者无法这样在在两个 public 的声明之间插入一个私有声明。</p> \n<p>最后，SwiftUI 中当前 (Xcode 11 beta 1) 只有对应 <code class=\"highlighter-rouge\">UITableView</code> 的 <code class=\"highlighter-rouge\">List</code>，而没有 <code class=\"highlighter-rouge\">UICollectionView</code> 对应的像是 <code class=\"highlighter-rouge\">Grid</code> 这样的类型。现在想要实现类似效果的话，只能嵌套使用 <code class=\"highlighter-rouge\">VStack</code> 和 <code class=\"highlighter-rouge\">HStack</code>。这是比较奇怪的，因为技术层面上应该和 table view 没有太多区别，大概是因为工期不太够？相信今后应该会补充上 <code class=\"highlighter-rouge\">Grid</code>。</p> \n<h3 id=\"教程-3---handling-user-input\"><a href=\"https://developer.apple.com/tutorials/swiftui/handling-user-input\">教程 3 - Handling User Input</a></h3> \n<h4 id=\"section-3---step-2-state-和-binding\"><a href=\"https://developer.apple.com/tutorials/swiftui/handling-user-input#add-a-control-to-toggle-the-state\">Section 3 - Step 2: <code class=\"highlighter-rouge\">@State</code> 和 <code class=\"highlighter-rouge\">Binding</code></a></h4> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">@State</span> <span class=\"k\">var</span> <span class=\"nv\">showFavoritesOnly</span> <span class=\"o\">=</span> <span class=\"kc\">true</span>\n\n<span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"kt\">NavigationView</span> <span class=\"p\">{</span>\n        <span class=\"kt\">List</span> <span class=\"p\">{</span>\n            <span class=\"kt\">Toggle</span><span class=\"p\">(</span><span class=\"nv\">isOn</span><span class=\"p\">:</span> <span class=\"err\">$</span><span class=\"n\">showFavoritesOnly</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Favorites only\"</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span>\n    <span class=\"c1\">//...</span>\n            <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">showFavoritesOnly</span> <span class=\"o\">||</span> <span class=\"n\">landmark</span><span class=\"o\">.</span><span class=\"n\">isFavorite</span> <span class=\"p\">{</span>\n</code></pre>\n </div>\n</div> \n<p>这里出现了两个以前在 Swift 里没有的特性：<code class=\"highlighter-rouge\">@State</code> 和 <code class=\"highlighter-rouge\">$showFavoritesOnly</code>。</p> \n<p>如果你 Cmd + Click 点到 <code class=\"highlighter-rouge\">State</code> 的定义里面，可以看到它其实是一个特殊的 <code class=\"highlighter-rouge\">struct</code>：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">@propertyWrapper</span> <span class=\"kd\">public</span> <span class=\"kd\">struct</span> <span class=\"kt\">State</span><span class=\"o\">&lt;</span><span class=\"kt\">Value</span><span class=\"o\">&gt;</span> <span class=\"p\">:</span> <span class=\"kt\">DynamicViewProperty</span><span class=\"p\">,</span> <span class=\"kt\">BindingConvertible</span> <span class=\"p\">{</span>\n\n    <span class=\"c1\">/// Initialize with the provided initial value.</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">init</span><span class=\"p\">(</span><span class=\"n\">initialValue</span> <span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"kt\">Value</span><span class=\"p\">)</span>\n\n    <span class=\"c1\">/// The current state value.</span>\n    <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"kt\">Value</span> <span class=\"p\">{</span> <span class=\"k\">get</span> <span class=\"k\">nonmutating</span> <span class=\"k\">set</span> <span class=\"p\">}</span>\n\n    <span class=\"c1\">/// Returns a binding referencing the state value.</span>\n    <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">binding</span><span class=\"p\">:</span> <span class=\"kt\">Binding</span><span class=\"o\">&lt;</span><span class=\"kt\">Value</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span> <span class=\"k\">get</span> <span class=\"p\">}</span>\n\n    <span class=\"c1\">/// Produces the binding referencing this state value</span>\n    <span class=\"kd\">public</span> <span class=\"k\">var</span> <span class=\"nv\">delegateValue</span><span class=\"p\">:</span> <span class=\"kt\">Binding</span><span class=\"o\">&lt;</span><span class=\"kt\">Value</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span> <span class=\"k\">get</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p><code class=\"highlighter-rouge\">@propertyWrapper</code> 标注和<a href=\"https://xiaozhuanlan.com/topic/7652341890#sectionsection3step5viewbuilderhttpsdeveloperapplecomtutorialsswiftuicreatingandcombiningviewscombineviewsusingstacks\">上一篇中提到</a>的 <code class=\"highlighter-rouge\">@_functionBuilder</code> 类似，它修饰的 <code class=\"highlighter-rouge\">struct</code> 可以变成一个新的修饰符并作用在其他代码上，来改变这些代码默认的行为。这里 <code class=\"highlighter-rouge\">@propertyWrapper</code> 修饰的 <code class=\"highlighter-rouge\">State</code> 被用做了 <code class=\"highlighter-rouge\">@State</code> 修饰符，并用来修饰 <code class=\"highlighter-rouge\">View</code> 中的 <code class=\"highlighter-rouge\">showFavoritesOnly</code> 变量。</p> \n<p>和 <code class=\"highlighter-rouge\">@_functionBuilder</code> 负责按照规矩“重新构造”函数的作用不同，<code class=\"highlighter-rouge\">@propertyWrapper</code> 的修饰符最终会作用在属性上，将属性“包裹”起来，以达到控制某个属性的读写行为的目的。如果将这部分代码“展开”，它实际上是这个样子的：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"c1\">// @State var showFavoritesOnly = true</span>\n   <span class=\"k\">var</span> <span class=\"nv\">showFavoritesOnly</span> <span class=\"o\">=</span> <span class=\"kt\">State</span><span class=\"p\">(</span><span class=\"nv\">initialValue</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">)</span>\n    \n<span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"kt\">NavigationView</span> <span class=\"p\">{</span>\n        <span class=\"kt\">List</span> <span class=\"p\">{</span>\n<span class=\"c1\">//          Toggle(isOn: $showFavoritesOnly) {</span>\n            <span class=\"kt\">Toggle</span><span class=\"p\">(</span><span class=\"nv\">isOn</span><span class=\"p\">:</span> <span class=\"n\">showFavoritesOnly</span><span class=\"o\">.</span><span class=\"n\">binding</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Favorites only\"</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span>\n    <span class=\"c1\">//...</span>\n<span class=\"c1\">//          if !self.showFavoritesOnly || landmark.isFavorite {</span>\n            <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">showFavoritesOnly</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">||</span> <span class=\"n\">landmark</span><span class=\"o\">.</span><span class=\"n\">isFavorite</span> <span class=\"p\">{</span>\n</code></pre>\n </div>\n</div> \n<p>我把变化之前的部分注释了一下，并且在后面一行写上了展开后的结果。可以看到 <code class=\"highlighter-rouge\">@State</code> 只是声明 <code class=\"highlighter-rouge\">State</code> struct 的一种简写方式而已。<code class=\"highlighter-rouge\">State</code> 里对具体要如何读写属性的规则进行了定义。对于读取，非常简单，使用 <code class=\"highlighter-rouge\">showFavoritesOnly.value</code> 就能拿到 <code class=\"highlighter-rouge\">State</code> 中存储的实际值。而原代码中 <code class=\"highlighter-rouge\">$showFavoritesOnly</code> 的写法也只不过是 <code class=\"highlighter-rouge\">showFavoritesOnly.binding</code> 的简化。<code class=\"highlighter-rouge\">binding</code> 将创建一个 <code class=\"highlighter-rouge\">showFavoritesOnly</code> 的引用，并将它传递给 <code class=\"highlighter-rouge\">Toggle</code>。再次强调，这个 <code class=\"highlighter-rouge\">binding</code> 是一个<strong>引用</strong>类型，所以 <code class=\"highlighter-rouge\">Toggle</code> 中对它的修改，会直接反应到当前 View 的 <code class=\"highlighter-rouge\">showFavoritesOnly</code> 去设置它的 <code class=\"highlighter-rouge\">value</code>。而 <code class=\"highlighter-rouge\">State</code> 的 value didSet 将触发 <code class=\"highlighter-rouge\">body</code> 的刷新，从而完成 State -&gt; View 的绑定。</p> \n<blockquote> \n <p>在 Xcode 11 beta 1 中，Swift 中使用的修饰符名字是 <code class=\"highlighter-rouge\">@propertyDelegate</code>，不过在 WWDC 上 Apple 提到这个特性时把它叫做了 <code class=\"highlighter-rouge\">@propertyWrapper</code>。根据<a href=\"https://twitter.com/josefdolezal/status/1137619597002248192?s=21\">可靠消息</a>，在未来正式版中应该也会叫做 <code class=\"highlighter-rouge\">@propertyWrapper</code>，所以大家在看各种资料的时候最好也建议一个简单的映射关系。</p> \n <p>如果你想要了解更多关于 <code class=\"highlighter-rouge\">@propertyWrapper</code> 的细节，可以看看<a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-delegates.md\">相关的提案</a>和<a href=\"https://forums.swift.org/t/se-0258-property-delegates/23139\">论坛讨论</a>。比较有意思的细节是 Apple 在将相应的 PR merge 进了 master 以后又把这个提案的打回了“修改”的状态，而非直接接受。除了 <code class=\"highlighter-rouge\">@propertyWrapper</code> 的名称修正以外，应该还会有一些其他的细节修改，但是已经公开的行为模式上应该不会太大变化了。</p> \n</blockquote> \n<p>SwiftUI 中还有几个常见的 <code class=\"highlighter-rouge\">@</code> 开头的修饰，比如 <code class=\"highlighter-rouge\">@Binding</code>，<code class=\"highlighter-rouge\">@Environment</code>，<code class=\"highlighter-rouge\">@EnvironmentObject</code> 等，原理上和 <code class=\"highlighter-rouge\">@State</code> 都一样，只不过它们所对应的 struct 中定义读写方式有区别。它们共同构成了 SwiftUI 数据流的最基本的单元。对于 SwiftUI 的数据流，如果展开的话足够一整篇文章了。在这里还是十分建议看一看 <a href=\"https://developer.apple.com/videos/play/wwdc2019/226/\">Session 226 - Data Flow Through SwiftUI</a> 的相关内容。</p> \n<h3 id=\"教程-5---animating-views-and-transitions\"><a href=\"https://developer.apple.com/tutorials/swiftui/animating-views-and-transitions\">教程 5 - Animating Views and Transitions</a></h3> \n<h4 id=\"section-2---step-4-两种动画的方式\"><a href=\"https://developer.apple.com/tutorials/swiftui/animating-views-and-transitions#customize-view-transitions\">Section 2 - Step 4: 两种动画的方式</a></h4> \n<p>在 SwiftUI 中，做动画变的十分简单。Apple 的教程里提供了两种动画的方式：</p> \n<ol> \n <li>直接在 <code class=\"highlighter-rouge\">View</code> 上使用 <code class=\"highlighter-rouge\">.animation</code> modifier</li> \n <li>使用 <code class=\"highlighter-rouge\">withAnimation { }</code> 来控制某个 <code class=\"highlighter-rouge\">State</code>，进而触发动画。</li> \n</ol> \n<p>对于只需要对单个 <code class=\"highlighter-rouge\">View</code> 做动画的时候，<code class=\"highlighter-rouge\">animation(_:)</code> 要更方便一些，它和其他各类 modifier 并没有太大不同，返回的是一个包装了对象 <code class=\"highlighter-rouge\">View</code> 和对应的动画类型的新的 <code class=\"highlighter-rouge\">View</code>。<code class=\"highlighter-rouge\">animation(_:)</code> 接受的参数 <code class=\"highlighter-rouge\">Animation</code> 并不是直接定义 <code class=\"highlighter-rouge\">View</code> 上的动画的数值内容的，它是描述的是动画所使用的时间曲线，动画的延迟等这些和 <code class=\"highlighter-rouge\">View</code> 无关的东西。具体和 <code class=\"highlighter-rouge\">View</code> 有关的，想要进行动画的数值方面的变更，由其他的诸如 <code class=\"highlighter-rouge\">rotationEffect</code> 和 <code class=\"highlighter-rouge\">scaleEffect</code> 这样的 modifier 来描述。</p> \n<p>在上面的 <a href=\"https://developer.apple.com/tutorials/swiftui/animating-views-and-transitions#add-animations-to-individual-views\">教程 5 - Section 1 - Step 5</a> 里有这样一段代码：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kt\">Button</span><span class=\"p\">(</span><span class=\"nv\">action</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">showDetail</span><span class=\"o\">.</span><span class=\"nf\">toggle</span><span class=\"p\">()</span>\n<span class=\"p\">})</span> <span class=\"p\">{</span>\n    <span class=\"kt\">Image</span><span class=\"p\">(</span><span class=\"nv\">systemName</span><span class=\"p\">:</span> <span class=\"s\">\"chevron.right.circle\"</span><span class=\"p\">)</span>\n        <span class=\"o\">.</span><span class=\"nf\">imageScale</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">large</span><span class=\"p\">)</span>\n        <span class=\"o\">.</span><span class=\"nf\">rotationEffect</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"nf\">degrees</span><span class=\"p\">(</span><span class=\"n\">showDetail</span> <span class=\"p\">?</span> <span class=\"mi\">90</span> <span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n        <span class=\"o\">.</span><span class=\"nf\">animation</span><span class=\"p\">(</span><span class=\"kc\">nil</span><span class=\"p\">)</span>\n        <span class=\"o\">.</span><span class=\"nf\">scaleEffect</span><span class=\"p\">(</span><span class=\"n\">showDetail</span> <span class=\"p\">?</span> <span class=\"mf\">1.5</span> <span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"o\">.</span><span class=\"nf\">padding</span><span class=\"p\">()</span>\n        <span class=\"o\">.</span><span class=\"nf\">animation</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"nf\">spring</span><span class=\"p\">())</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>要注意，SwiftUI 的 modifier 是有顺序的。在我们调用 <code class=\"highlighter-rouge\">animation(_:)</code> 时，SwiftUI 做的事情等效于是把之前的所有 modifier 检查一遍，然后找出所有满足 <a href=\"https://developer.apple.com/documentation/swiftui/animatable\"><code class=\"highlighter-rouge\">Animatable</code></a> 协议的 view 上的数值变化，比如角度、位置、尺寸等，然后将这些变化打个包，创建一个事物 (<code class=\"highlighter-rouge\">Transaction</code>) 并提交给底层渲染去做动画。在上面的代码中，<code class=\"highlighter-rouge\">.rotationEffect</code> 后的 <code class=\"highlighter-rouge\">.animation(nil)</code> 将 rotation 的动画提交，因为指定了 <code class=\"highlighter-rouge\">nil</code> 所以这里没有实际的动画。在最后，<code class=\"highlighter-rouge\">.rotationEffect</code> 已经被处理了，所以末行的 <code class=\"highlighter-rouge\">.animation(.spring())</code> 提交的只有 <code class=\"highlighter-rouge\">.scaleEffect</code>。</p> \n<p><code class=\"highlighter-rouge\">withAnimation { }</code> 是一个顶层函数，在闭包内部，我们一般会触发某个 State 的变化，并让 <code class=\"highlighter-rouge\">View.body</code> 进行重新计算：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kt\">Button</span><span class=\"p\">(</span><span class=\"nv\">action</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"n\">withAnimation</span> <span class=\"p\">{</span>\n        <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">showDetail</span><span class=\"o\">.</span><span class=\"nf\">toggle</span><span class=\"p\">()</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">})</span> <span class=\"p\">{</span> \n  <span class=\"c1\">//...</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>如果需要，你也可以为它指定一个具体的 <code class=\"highlighter-rouge\">Animation</code>：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"nf\">withAnimation</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"nf\">basic</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n    <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">showDetail</span><span class=\"o\">.</span><span class=\"nf\">toggle</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>这个方法相当于把一个 <code class=\"highlighter-rouge\">animation</code> 设置到 <code class=\"highlighter-rouge\">View</code> 数值变化的 <code class=\"highlighter-rouge\">Transaction</code> 上，并提交给底层渲染去做动画。从原理上来说，<code class=\"highlighter-rouge\">withAnimation</code> 是统一控制单个的 <code class=\"highlighter-rouge\">Transaction</code>，而针对不同 <code class=\"highlighter-rouge\">View</code> 的 <code class=\"highlighter-rouge\">animation(_:)</code> 调用则可能对应多个不同的 <code class=\"highlighter-rouge\">Transaction</code>。</p> \n<h3 id=\"教程-7---working-with-ui-controls\"><a href=\"https://developer.apple.com/tutorials/swiftui/working-with-ui-controls\">教程 7 - Working with UI Controls</a></h3> \n<h4 id=\"section-4---step-2-关于-view-的生命周期\"><a href=\"https://developer.apple.com/tutorials/swiftui/working-with-ui-controls#delay-edit-propagation\">Section 4 - Step 2: 关于 <code class=\"highlighter-rouge\">View</code> 的生命周期</a></h4> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kt\">ProfileEditor</span><span class=\"p\">(</span><span class=\"nv\">profile</span><span class=\"p\">:</span> <span class=\"err\">$</span><span class=\"n\">draftProfile</span><span class=\"p\">)</span>\n    <span class=\"o\">.</span><span class=\"n\">onDisappear</span> <span class=\"p\">{</span>\n        <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">draftProfile</span> <span class=\"o\">=</span> <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">profile</span>\n    <span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>在 UIKit 开发时，我们经常会接触一些像是 <code class=\"highlighter-rouge\">viewDidLoad</code>，<code class=\"highlighter-rouge\">viewWillAppear</code> 这样的生命周期的方法，并在里面进行一些配置。SwiftUI 里也有一部分这类生命周期的方法，比如 <code class=\"highlighter-rouge\">.onAppear</code> 和 <code class=\"highlighter-rouge\">.onDisappear</code>，它们也被“统一”在了 modifier 这面大旗下。</p> \n<p>但是相对于 UIKit 来说，SwiftUI 中能 hook 的生命周期方法比较少，而且相对要通用一些。本身在生命周期中做操作这种方式就和声明式的编程理念有些相悖，看上去就像是加上了一些命令式的 hack。我个人比较期待 <code class=\"highlighter-rouge\">View</code> 和 <code class=\"highlighter-rouge\">Combine</code> 能再深度结合一些，把像是 <code class=\"highlighter-rouge\">self.draftProfile = self.profile</code> 这类依赖生命周期的操作也用绑定的方式搞定。</p> \n<p>相比于 <code class=\"highlighter-rouge\">.onAppear</code> 和 <code class=\"highlighter-rouge\">.onDisappear</code>，更通用的事件响应 hook 是 <code class=\"highlighter-rouge\">.onReceive(_:perform:)</code>，它定义了一个可以响应目标 <code class=\"highlighter-rouge\">Publisher</code> 的任意的 <code class=\"highlighter-rouge\">View</code>，一旦订阅的 <code class=\"highlighter-rouge\">Publisher</code> 发出新的事件时，<code class=\"highlighter-rouge\">onReceive</code> 就将被调用。因为我们可以自行定义这些 publisher，所以它是完备的，这在把现有的 UIKit View 转换到 SwiftUI View 时会十分有用。</p>","descriptionType":"text/html","publishedDate":"Tue, 11 Jun 2019 03:32:00 +0000","feedId":3176,"bgimg":"https://onevcat.com/assets/images/2019/swift-ui.png","linkMd5":"d28a702d7fd07e9b34d530e42587e33b","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn23@2020_6/2020/08/24/21-24-58-692_244dd07ca8408fce.webp","destWidth":1041,"destHeight":281,"sourceBytes":13758,"destBytes":12856,"author":"","articleImgCdnMap":{"https://onevcat.com/assets/images/2019/swift-ui.png":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn23@2020_6/2020/08/24/21-24-58-692_244dd07ca8408fce.webp","https://images.xiaozhuanlan.com/photo/2019/a900c8d2687dab13ba438602da826552.png":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn34@2020_2/2020/08/24/21-25-03-089_954c34b4a40703b9.webp"},"publishedOrCreatedDate":1598304289186},{"createdTime":"2020-08-25 05:24:49","updatedTime":"2020-08-25 05:24:49","title":"关于 Backpressure 和 Combine 中的处理","link":"https://onevcat.com/2019/12/backpressure-in-combine/","description":"<blockquote> \n <p>本文是对我的《SwiftUI 和 Combine 编程》书籍的补充，对一些虽然很重要，但和书中上下文内容相去略远，或者一些不太适合以书本的篇幅详细展开解释的内容进行了追加说明。如果你对 SwiftUI 和 Combine 的更多话题有兴趣的话，可以考虑<a href=\"https://objccn.io/products/swift-ui\">参阅原书</a>。</p> \n</blockquote> \n<p>Combine 在 API 设计上很多地方都参考了 Rx 系，特别是 <a href=\"https://github.com/ReactiveX/RxSwift\">RxSwift</a> 的做法。如果你已经对响应式编程很了解的话，从 RxSwift 迁移到 Combine 应该是轻而易举的。如果要说起 RxSwift 和 Combine 的最显著的不同，那就是 RxSwift 在可预期的未来<a href=\"https://github.com/ReactiveX/RxSwift/issues/1666?source=post_page-----64780a150d89----------------------#issuecomment-395546338\">没有支持 backpressure 的计划</a>；但是 Combine 中原生对这个特性进行了支持：在 Combine 中你可以在 <code class=\"highlighter-rouge\">Subscriber</code> 中返回追加接收的事件数量，来定义 Backpressure 的响应行为。在这篇文章里，我们会解释这个行为。</p> \n<h2 id=\"什么是-backpressure为什么需要处理它\">什么是 Backpressure，为什么需要处理它</h2> \n<p>虽然在 iOS 客户端中，backpressure 也许不是那么常见，但是这在软件开发里可能是一个开发者或多或少都会遇到的话题。Backpressure 这个词来源于流体力学，一般被叫做<strong>背压</strong>或者<strong>回压</strong>，指的是<strong>流体在管道中流动时，(由于高度差或者压力所产生的阻滞) 在逆流动方向上的阻力</strong>。在响应式的编程世界中，我们经常会把由 Publisher，Operator 和 Subscriber 组成的事件处理方式比喻为“管道”，把对应的不断发生的事件叫做“事件流”。类比而言，在这个上下文中，backpressure 指的是<strong>在事件流动中，下游 (Operator 或者 Subscriber) 对上游 Publisher 的阻力</strong>。</p> \n<p>为什么会产生这样的“阻力”呢？一个最常见的原因就是下游的 Subscriber 的处理速度无法跟上上游 Publisher 产生事件的速度。在理想世界中，如果我们的处理速度无穷，那么不管 Publisher 以多快的速度产生事件，Subscriber 都可以消化并处理这些事件。但是实际情况显然不会如此，有时候 Publisher 的事件生成速度可以远超 Subscriber 的处理速度，这种情况下就会产生一些问题。</p> \n<p>举例来说，比如我们的 Publisher 从一个快速的 web socket 接受数据，经过一系列类似 <a href=\"https://developer.apple.com/documentation/combine/publishers/map\"><code class=\"highlighter-rouge\">Publishers.Map</code></a> 的变形操作，将接收到的数据转换为 app 中的 Model，最终的订阅者在接收到数据后执行 UI 渲染的工作，把数据添加到 Table View 里并绘制 UI。很显然，相对于 UI 渲染来说，接收数据和数据变形是非常快的。在一帧 (60 Hz 下的话，16ms) 中，我们可以接收和处理成千上万条数据，但是可能只能创建和渲染十多个 cell。如果我们想要处理这些数据，朴素来说，可能的方式有四种：</p> \n<ol> \n <li>阻塞主线程，在这一帧中处理完这成千上万的 cell。</li> \n <li>把接受到的数据暂存在一个 buffer 里，取出合适的量进行处理。剩余部分则等待下一帧或者稍后空闲时再进行渲染。</li> \n <li>在接收到数据后，使用采样方法丢弃掉一部分数据，只去处理部分数据，以满足满帧渲染。</li> \n <li>控制事件产生的速度，让事件的发生速度减慢，来“适应”订阅者处理的速度。</li> \n</ol> \n<p>在客户端开发中，方案 1 是最不可取的，很显然它会把 UI 整个卡死，甚至让我们可爱的 <a href=\"https://stackoverflow.com/a/36644249/1468886\">watchdog 0x8badf00d (ate bad food)</a> 从而造成 app 崩溃。方案 2 在某些情况下可能会有用，但是如果数据一直堆积，buffer 迟早会发生溢出。对于方案 3，在“将大量数据渲染到 UI 上”这一情景中，UI 刷新的速率将远远超过人能看到和处理的信息量，所以它是可行的，丢弃掉部分数据并不会造成使用体验上的影响。方案 4 如果可以实现的话，则是相对理想的 backpressure 处理方式：让发送端去适配接收端，在保证体验的情况下同时也保障了数据完整性，并且 (至少对客户端来说) 不会存在 buffer 溢出的情况。</p> \n<p>另外一个常见的例子是大型文件转存，例如从磁盘的某个位置通过一个 stream 读取数据，然后将它写入到另一个地方。磁盘的读写速度往往是存在差别的，通常来说读速要比写速快很多。假设磁盘读取速度为 100 MB/s，写入速度为 50 MB/s，如果两端都全速的话，每秒将会堆积 50 MB 的数据到 buffer 中，很多场景下这是难以接受的。我们可以通过限制读取速度，来完美解决这个速度差，而这就是上面的方案 4 中的思想。</p> \n<p>简单来说，backpressure 提供了一种方案，来解决在异步操作中发送端和接收端速率无法匹配的问题 (通常是发送端快于接收端)。在一个 (像是 Combine 这样的) 异步处理框架中，是否能够支持控制上游速度来处理 backpressure，关键取决于一点：事件的发送到底是基于<strong>拉取模型</strong>还是<strong>推送模型</strong>。如果是拉取模型，那么所定义的 Publisher 会根据要求<strong>按需发送</strong>，那么我们就可以控制事件发送的频率，进而处理前述的上下游速度不匹配的问题。</p> \n<h2 id=\"自定义-subscriber\">自定义 Subscriber</h2> \n<h3 id=\"combine-框架基于拉取的事件模型\">Combine 框架基于拉取的事件模型</h3> \n<p>好消息是，Combine 的事件发送确实是基于拉取模型的。我们回顾一下典型的 Combine 订阅和事件发送的流程：</p> \n<p><img src=\"https://onevcat.com/assets/images/2019/publisher-subscriber-flow.svg\" alt=\"\" /></p> \n<p>图中共有三种主要角色，除了两端的 <code class=\"highlighter-rouge\">Publisher</code> 和 <code class=\"highlighter-rouge\">Subscriber</code> 以外，还有一个负责作为“桥梁”连接两者的 <code class=\"highlighter-rouge\">Subscription</code>。</p> \n<p>步骤 3，4 和 5 中分别涉及到 <code class=\"highlighter-rouge\">Subscription</code> 和 <code class=\"highlighter-rouge\">Subscriber</code> 的下面两个方法：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">protocol</span> <span class=\"kt\">Subscription</span> <span class=\"p\">{</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">request</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">demand</span><span class=\"p\">:</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Demand</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">protocol</span> <span class=\"kt\">Subscriber</span> <span class=\"p\">{</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">input</span><span class=\"p\">:</span> <span class=\"k\">Self</span><span class=\"o\">.</span><span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Demand</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>它们都和 <code class=\"highlighter-rouge\">Subscribers.Demand</code> 相关：这个值表示了 <code class=\"highlighter-rouge\">Subscriber</code> 希望接收的事件数量。Combine 框架中有这样的约定：<code class=\"highlighter-rouge\">Subscriber</code> 对应着的订阅所发出的事件总数，不应该超过 <code class=\"highlighter-rouge\">Subscription.request(_:)</code> 所传入的 <code class=\"highlighter-rouge\">Demand</code> 和接下来每次 <code class=\"highlighter-rouge\">Subscriber.receive(_:)</code> 被调用时返回的 <code class=\"highlighter-rouge\">Demand</code> 的值的累加。基于这个规则，<code class=\"highlighter-rouge\">Subscriber</code> 可以根据自身情况通过使用合适的 <code class=\"highlighter-rouge\">Demand</code> 来控制上游。</p> \n<p>这么说会有些抽象。在这篇文章里，我们会把注意力集中在 <code class=\"highlighter-rouge\">Subscriber</code> 上，首先来看看如何实现自定义的 <code class=\"highlighter-rouge\">Subscriber</code>，由此理解 Combine 的拉取模型的意义。然后再尝试实现一个能够控制 <code class=\"highlighter-rouge\">Publisher</code> 发送事件的特殊 <code class=\"highlighter-rouge\">Subscriber</code>。</p> \n<p>关于图中另外两种角色 <code class=\"highlighter-rouge\">Publisher</code> 和 <code class=\"highlighter-rouge\">Subscription</code>，我可能会在另外的文章里再进行更多说明。</p> \n<h3 id=\"重写-sink\">重写 Sink</h3> \n<p>在订阅某个 <code class=\"highlighter-rouge\">Publisher</code> 时，大概最常用的莫过于 <code class=\"highlighter-rouge\">sink</code> 了：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">publisher</span><span class=\"o\">.</span><span class=\"nf\">sink</span><span class=\"p\">(</span>\n    <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">completion</span> <span class=\"k\">in</span>\n        <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Completion: </span><span class=\"se\">\\(</span><span class=\"n\">completion</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n    <span class=\"p\">},</span>\n    <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">value</span> <span class=\"k\">in</span>\n        <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Receive value: </span><span class=\"se\">\\(</span><span class=\"n\">value</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n</code></pre> \n </div> \n</div> \n<p>定义在 <code class=\"highlighter-rouge\">Publisher</code> 上的扩展方法 <code class=\"highlighter-rouge\">sink(receiveCompletion:receiveValue:)</code> 只不过是标准的订阅流程的简写方式。按照“正规的”方式，我们可以明确地创建 <code class=\"highlighter-rouge\">Subscriber</code> 并让它订阅 <code class=\"highlighter-rouge\">Publisher</code>，上面的代码等效于：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">publisher</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">publisher</span>\n<span class=\"k\">let</span> <span class=\"nv\">subscriber</span> <span class=\"o\">=</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Sink</span><span class=\"o\">&lt;</span><span class=\"kt\">Int</span><span class=\"p\">,</span> <span class=\"kt\">Never</span><span class=\"o\">&gt;</span><span class=\"p\">(</span>\n    <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">completion</span> <span class=\"k\">in</span>\n        <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Completion: </span><span class=\"se\">\\(</span><span class=\"n\">completion</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n    <span class=\"p\">},</span>\n    <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">value</span> <span class=\"k\">in</span>\n        <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Receive value: </span><span class=\"se\">\\(</span><span class=\"n\">value</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">publisher</span><span class=\"o\">.</span><span class=\"nf\">subscribe</span><span class=\"p\">(</span><span class=\"n\">subscriber</span><span class=\"p\">)</span>\n</code></pre> \n </div> \n</div> \n<p><code class=\"highlighter-rouge\">Sink</code> 做的事情非常简单，它在订阅时直接申请接受 <code class=\"highlighter-rouge\">Subscribers.Demand.unlimited</code> 个元素。在每次收到事件时，调用预先设定的 block。现在，作为起始，我们来创建一个自定义的 <code class=\"highlighter-rouge\">MySink</code>：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"c1\">// 1</span>\n<span class=\"kd\">extension</span> <span class=\"kt\">Subscribers</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 2</span>\n    <span class=\"kd\">class</span> <span class=\"kt\">MySink</span><span class=\"o\">&lt;</span><span class=\"kt\">Input</span><span class=\"p\">,</span> <span class=\"kt\">Failure</span><span class=\"p\">:</span> <span class=\"kt\">Error</span><span class=\"o\">&gt;</span><span class=\"p\">:</span> <span class=\"kt\">Subscriber</span><span class=\"p\">,</span> <span class=\"kt\">Cancellable</span> <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Completion</span><span class=\"o\">&lt;</span><span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span>\n        <span class=\"k\">let</span> <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span>\n        <span class=\"c1\">// 3</span>\n        <span class=\"k\">var</span> <span class=\"nv\">subscription</span><span class=\"p\">:</span> <span class=\"kt\">Subscription</span><span class=\"p\">?</span>\n        \n        <span class=\"c1\">// ...</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<ol> \n <li>Combine 中的 <code class=\"highlighter-rouge\">Publisher</code> 和 <code class=\"highlighter-rouge\">Subscriber</code> 大都作为内嵌类型，定义在 <code class=\"highlighter-rouge\">Publishers</code> 和 <code class=\"highlighter-rouge\">Subscribers</code> 中。在这里，我们也遵循这个规则，把 <code class=\"highlighter-rouge\">MySink</code> 写在 <code class=\"highlighter-rouge\">Subscribers</code> 里。</li> \n <li>我们想让 <code class=\"highlighter-rouge\">MySink</code> 满足 <code class=\"highlighter-rouge\">Cancellable</code>，因此需要持有 <code class=\"highlighter-rouge\">subscription</code>，才能在未来取消这个订阅。在语义上来说，我们也不希望发生复制，所以使用 <code class=\"highlighter-rouge\">class</code> 来声明 <code class=\"highlighter-rouge\">MySink</code>。这也是实现自定义 <code class=\"highlighter-rouge\">Subscriber</code> 的一般做法。</li> \n <li>在 <code class=\"highlighter-rouge\">Subscriber</code> 中持有 <code class=\"highlighter-rouge\">subscription</code> 是很常见的操作，除了用来对应取消以外，这还可以让我们灵活处理额外的值的请求，稍后我们会看到这方面的内容。</li> \n</ol> \n<p>接下来，创建一个初始化方法，它接受 <code class=\"highlighter-rouge\">receiveCompletion</code> 和 <code class=\"highlighter-rouge\">receiveValue</code>：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"nf\">init</span><span class=\"p\">(</span>\n    <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"kd\">@escaping</span> <span class=\"p\">(</span><span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Completion</span><span class=\"o\">&lt;</span><span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span><span class=\"p\">,</span>\n    <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"kd\">@escaping</span> <span class=\"p\">(</span><span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span>\n<span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">receiveCompletion</span> <span class=\"o\">=</span> <span class=\"n\">receiveCompletion</span>\n    <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">receiveValue</span> <span class=\"o\">=</span> <span class=\"n\">receiveValue</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>想要实现 <code class=\"highlighter-rouge\">Subscriber</code> 协议，我们需要实现协议中定义的所有三个方法：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">protocol</span> <span class=\"kt\">Subscriber</span> <span class=\"p\">{</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"nv\">subscription</span><span class=\"p\">:</span> <span class=\"kt\">Subscription</span><span class=\"p\">)</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">input</span><span class=\"p\">:</span> <span class=\"k\">Self</span><span class=\"o\">.</span><span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Demand</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"nv\">completion</span><span class=\"p\">:</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Completion</span><span class=\"o\">&lt;</span><span class=\"k\">Self</span><span class=\"o\">.</span><span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>在 <code class=\"highlighter-rouge\">MySink</code> 里，我们可以完全遵循 <code class=\"highlighter-rouge\">Sink</code> 的做法：在一开始收到订阅时，就请求无限多的事件；而在后续收到值时，则不再做 (也不需要做) 更多的请求：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"nv\">subscription</span><span class=\"p\">:</span> <span class=\"kt\">Subscription</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">subscription</span> <span class=\"o\">=</span> <span class=\"n\">subscription</span>\n    <span class=\"n\">subscription</span><span class=\"o\">.</span><span class=\"nf\">request</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">unlimited</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n        \n<span class=\"kd\">func</span> <span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">input</span><span class=\"p\">:</span> <span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Demand</span> <span class=\"p\">{</span>\n    <span class=\"nf\">receiveValue</span><span class=\"p\">(</span><span class=\"n\">input</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"o\">.</span><span class=\"k\">none</span>\n<span class=\"p\">}</span>\n        \n<span class=\"kd\">func</span> <span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"nv\">completion</span><span class=\"p\">:</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Completion</span><span class=\"o\">&lt;</span><span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nf\">receiveCompletion</span><span class=\"p\">(</span><span class=\"n\">completion</span><span class=\"p\">)</span>\n    <span class=\"n\">subscription</span> <span class=\"o\">=</span> <span class=\"kc\">nil</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>最后，为了实现 <code class=\"highlighter-rouge\">Cancellable</code>，我们需要将 <code class=\"highlighter-rouge\">cancel()</code> 的调用“转发”给 <code class=\"highlighter-rouge\">subscription</code>：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">cancel</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"n\">subscription</span><span class=\"p\">?</span><span class=\"o\">.</span><span class=\"nf\">cancel</span><span class=\"p\">()</span>\n    <span class=\"n\">subscription</span> <span class=\"o\">=</span> <span class=\"kc\">nil</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>为了避免意外的循环引用 (因为 <code class=\"highlighter-rouge\">Subscription</code> 很多情况下也会持有 <code class=\"highlighter-rouge\">Subscriber</code>)，所以在收到完成事件或者收到取消请求时，不再继续需要订阅的情况下，要记得将 <code class=\"highlighter-rouge\">subscription</code> 置回为 <code class=\"highlighter-rouge\">nil</code>。</p> \n<p>最后的最后，为了方便使用，不妨为 <code class=\"highlighter-rouge\">Publisher</code> 提供一个扩展方法，来帮助我们用 <code class=\"highlighter-rouge\">MySink</code> 做订阅：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">extension</span> <span class=\"kt\">Publisher</span> <span class=\"p\">{</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">mySink</span><span class=\"p\">(</span>\n        <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"kd\">@escaping</span> <span class=\"p\">(</span><span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Completion</span><span class=\"o\">&lt;</span><span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span><span class=\"p\">,</span>\n        <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"kd\">@escaping</span> <span class=\"p\">(</span><span class=\"kt\">Output</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span>\n    <span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Cancellable</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"nv\">sink</span> <span class=\"o\">=</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">MySink</span><span class=\"o\">&lt;</span><span class=\"kt\">Output</span><span class=\"p\">,</span> <span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">(</span>\n            <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"n\">receiveCompletion</span><span class=\"p\">,</span>\n            <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"n\">receiveValue</span>\n        <span class=\"p\">)</span>\n        <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"nf\">subscribe</span><span class=\"p\">(</span><span class=\"n\">sink</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">sink</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">publisher</span><span class=\"o\">.</span><span class=\"nf\">mySink</span><span class=\"p\">(</span>\n    <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">completion</span> <span class=\"k\">in</span>\n        <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Completion: </span><span class=\"se\">\\(</span><span class=\"n\">completion</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n    <span class=\"p\">},</span>\n    <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">value</span> <span class=\"k\">in</span>\n        <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Receive value: </span><span class=\"se\">\\(</span><span class=\"n\">value</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\">// 输出：</span>\n<span class=\"c1\">// Receive value: 1</span>\n<span class=\"c1\">// Receive value: 2</span>\n<span class=\"c1\">// Receive value: 3</span>\n<span class=\"c1\">// Receive value: 4</span>\n<span class=\"c1\">// Receive value: 5</span>\n<span class=\"c1\">// Completion: finished</span>\n</code></pre> \n </div> \n</div> \n<p><code class=\"highlighter-rouge\">mySink</code> 的行为和原始的 <code class=\"highlighter-rouge\">sink</code> 应该是完全一致的。现在我们就可以开始着手修改 <code class=\"highlighter-rouge\">MySink</code> 的代码，让事情变得更有趣一些了。</p> \n<h3 id=\"按照-demand-的需求来发送事件\">按照 Demand 的需求来发送事件</h3> \n<p>我们可以对 <code class=\"highlighter-rouge\">MySink</code> 做一点手脚，来控制它的拉取行为。比如将 <code class=\"highlighter-rouge\">receive(subscription:)</code> 里初始的请求数量调整为 <code class=\"highlighter-rouge\">.max(1)</code>：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"nv\">subscription</span><span class=\"p\">:</span> <span class=\"kt\">Subscription</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">subscription</span> <span class=\"o\">=</span> <span class=\"n\">subscription</span>\n    <span class=\"c1\">// subscription.request(.unlimited)</span>\n    <span class=\"n\">subscription</span><span class=\"o\">.</span><span class=\"nf\">request</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>这样一来，输出就停留在只有一行了：</p> \n<div class=\"highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code>Receive value: 1\n</code></pre> \n </div> \n</div> \n<p>这是因为现在我们只在订阅发生时去请求了一个值，而在 <code class=\"highlighter-rouge\">receive(_:)</code> 里，我们返回的 <code class=\"highlighter-rouge\">.none</code> 代表不再需要 <code class=\"highlighter-rouge\">Publisher</code> 给出新值了。在这个方法中，我们有机会决定下一次的事件请求数量：可以将请求数从 <code class=\"highlighter-rouge\">.none</code> 调整为 <code class=\"highlighter-rouge\">.max(1)</code>：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">input</span><span class=\"p\">:</span> <span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Demand</span> <span class=\"p\">{</span>\n    <span class=\"nf\">receiveValue</span><span class=\"p\">(</span><span class=\"n\">input</span><span class=\"p\">)</span>\n    <span class=\"c1\">// return .none</span>\n    <span class=\"k\">return</span> <span class=\"o\">.</span><span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>输出将恢复原来的情况：每当 <code class=\"highlighter-rouge\">MySink</code> 收到一个值时，它会再去<strong>拉取</strong>下一个值，直到最后结束。我们可以通过为 <code class=\"highlighter-rouge\">Publisher</code> 添加 <code class=\"highlighter-rouge\">print()</code> 来从控制台输出确定这个行为：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"c1\">// [1,2,3,4,5].publisher</span>\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">publisher</span><span class=\"o\">.</span><span class=\"nf\">print</span><span class=\"p\">()</span>\n    <span class=\"o\">.</span><span class=\"nf\">mySink</span><span class=\"p\">(</span>\n        <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">completion</span> <span class=\"k\">in</span>\n            <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Completion: </span><span class=\"se\">\\(</span><span class=\"n\">completion</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n        <span class=\"p\">},</span>\n        <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">value</span> <span class=\"k\">in</span>\n            <span class=\"c1\">// print(\"Receive value: \\(value)\")</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">)</span>\n\n<span class=\"c1\">// 输出：</span>\n<span class=\"c1\">// receive subscription: ([1, 2, 3, 4, 5])</span>\n<span class=\"c1\">// request max: (1)</span>\n<span class=\"c1\">// receive value: (1)</span>\n<span class=\"c1\">// request max: (1) (synchronous)</span>\n<span class=\"c1\">// receive value: (2)</span>\n<span class=\"c1\">// request max: (1) (synchronous)</span>\n<span class=\"c1\">// receive value: (3)</span>\n<span class=\"c1\">// ... </span>\n</code></pre> \n </div> \n</div> \n<p>通过在 <code class=\"highlighter-rouge\">Subscriber</code> 里的 <code class=\"highlighter-rouge\">receive(subscription:)</code> 和 <code class=\"highlighter-rouge\">receive(_:)</code> 来控制 <code class=\"highlighter-rouge\">Subscribers.Demand</code>，我们做到了控制 <code class=\"highlighter-rouge\">Publisher</code> 的事件发送。那要如何使用这个特性处理 backpressure 的情况呢？</p> \n<h2 id=\"能够处理-backpressure-的-subscriber\">能够处理 backpressure 的 Subscriber</h2> \n<h3 id=\"让已停止的事件流继续\">让已停止的事件流继续</h3> \n<p>按照 Combine 约定，当 <code class=\"highlighter-rouge\">Publisher</code> 发送的值满足 <code class=\"highlighter-rouge\">Subscriber</code> 所要求的数量后，便不再发送新的值。在上面的 <code class=\"highlighter-rouge\">MySink</code> 实现里，只要将 <code class=\"highlighter-rouge\">receive(_:)</code> 的返回值设为 <code class=\"highlighter-rouge\">.none</code>，那么就只会有第一个值被发出。这时候我们便遇到了一个问题，因为后续的值不会再被发送，<code class=\"highlighter-rouge\">receive(_:)</code> 也不会再被调用，因此我们不再有机会在 <code class=\"highlighter-rouge\">receive(_:)</code> 中返回新的 <code class=\"highlighter-rouge\">Demand</code>，来让 <code class=\"highlighter-rouge\">Publisher</code> 重新开始工作。</p> \n<p>我们需要一种方式来“重新启动”这个流程，那就是 <code class=\"highlighter-rouge\">Subscription</code> 上的 <code class=\"highlighter-rouge\">request(_ demand: Subscribers.Demand)</code> 方法。在订阅刚开始时，我们已经使用过它来开始第一次发送。现在，当 <code class=\"highlighter-rouge\">Publisher</code> “暂停”后，我也也可以从外部用它来重启发送流程，这也是我们要暂存 <code class=\"highlighter-rouge\">subscription</code> 的另一个重要理由。</p> \n<p>在 <code class=\"highlighter-rouge\">MySink</code> 里添加 <code class=\"highlighter-rouge\">resume</code> 方法：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">resume</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"n\">subscription</span><span class=\"p\">?</span><span class=\"o\">.</span><span class=\"nf\">request</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>创建一个 <code class=\"highlighter-rouge\">Resumable</code> 协议，并让 <code class=\"highlighter-rouge\">MySink</code> 遵守这个协议：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">protocol</span> <span class=\"kt\">Resumable</span> <span class=\"p\">{</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">resume</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">extension</span> <span class=\"kt\">Subscribers</span> <span class=\"p\">{</span>\n    <span class=\"kd\">class</span> <span class=\"kt\">MySink</span><span class=\"o\">&lt;</span><span class=\"kt\">Input</span><span class=\"p\">,</span> <span class=\"kt\">Failure</span><span class=\"p\">:</span> <span class=\"kt\">Error</span><span class=\"o\">&gt;</span>\n    <span class=\"p\">:</span> <span class=\"kt\">Subscriber</span><span class=\"p\">,</span> <span class=\"kt\">Cancellable</span><span class=\"p\">,</span> <span class=\"kt\">Resumable</span> \n    <span class=\"p\">{</span>\n        <span class=\"c1\">//...</span>\n        <span class=\"c1\">// MySink 已经实现了 resume()</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>最后，把 <code class=\"highlighter-rouge\">Publisher.mySink</code> 的返回类型从 <code class=\"highlighter-rouge\">Cancellable</code> 修改为 <code class=\"highlighter-rouge\">Cancellable &amp; Resumable</code> 的联合：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">extension</span> <span class=\"kt\">Publisher</span> <span class=\"p\">{</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">mySink</span><span class=\"p\">(</span>\n        <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"kd\">@escaping</span> <span class=\"p\">(</span><span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Completion</span><span class=\"o\">&lt;</span><span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span><span class=\"p\">,</span>\n        <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"kd\">@escaping</span> <span class=\"p\">(</span><span class=\"kt\">Output</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span>\n    <span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Cancellable</span> <span class=\"o\">&amp;</span> <span class=\"kt\">Resumable</span>\n    <span class=\"p\">{</span>\n      <span class=\"c1\">// ...</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>现在，即使我们把 <code class=\"highlighter-rouge\">MySink</code> 里 <code class=\"highlighter-rouge\">receive(_:)</code> 的返回值改回 <code class=\"highlighter-rouge\">.none</code>，让 <code class=\"highlighter-rouge\">Publisher</code> 在被订阅后只发出一次值，我们也可以再通过反复调用 <code class=\"highlighter-rouge\">resume(_:)</code> 来“分批次”拉取所有值了：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">extension</span> <span class=\"kt\">Subscribers</span> <span class=\"p\">{</span>\n    <span class=\"kd\">class</span> <span class=\"kt\">MySink</span> <span class=\"c1\">//... {</span>\n        <span class=\"kd\">func</span> <span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">input</span><span class=\"p\">:</span> <span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Demand</span> <span class=\"p\">{</span>\n            <span class=\"nf\">receiveValue</span><span class=\"p\">(</span><span class=\"n\">input</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"o\">.</span><span class=\"k\">none</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">subscriber</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">publisher</span><span class=\"o\">.</span><span class=\"nf\">print</span><span class=\"p\">()</span>\n    <span class=\"o\">.</span><span class=\"nf\">mySink</span><span class=\"p\">(</span>\n        <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">completion</span> <span class=\"k\">in</span>\n            <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Completion: </span><span class=\"se\">\\(</span><span class=\"n\">completion</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n        <span class=\"p\">},</span>\n        <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">value</span> <span class=\"k\">in</span>\n            <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Receive value: </span><span class=\"se\">\\(</span><span class=\"n\">value</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">)</span>\n\n<span class=\"n\">subscriber</span><span class=\"o\">.</span><span class=\"nf\">resume</span><span class=\"p\">()</span>\n<span class=\"n\">subscriber</span><span class=\"o\">.</span><span class=\"nf\">resume</span><span class=\"p\">()</span>\n<span class=\"n\">subscriber</span><span class=\"o\">.</span><span class=\"nf\">resume</span><span class=\"p\">()</span>\n<span class=\"n\">subscriber</span><span class=\"o\">.</span><span class=\"nf\">resume</span><span class=\"p\">()</span>\n</code></pre> \n </div> \n</div> \n<h3 id=\"注入控制逻辑暂停-publisher-发送\">注入控制逻辑，暂停 <code class=\"highlighter-rouge\">Publisher</code> 发送</h3> \n<p>现在我们只差最后一块拼图了，那就是到底由谁来负责暂停 <code class=\"highlighter-rouge\">Publisher</code> 的逻辑。当前的 <code class=\"highlighter-rouge\">MySink</code> 中，由于开始订阅时只接受了 <code class=\"highlighter-rouge\">.max(1)</code>，同时， <code class=\"highlighter-rouge\">receive(_:)</code> 返回的是 <code class=\"highlighter-rouge\">.none</code>，所以在接到第一个值后，<code class=\"highlighter-rouge\">Publisher</code> 是无条件暂停的。实际上，和 <code class=\"highlighter-rouge\">resume</code> 逻辑类似，我们会更希望将暂停的逻辑也“委托”出去，由调用者来决定合适的暂停时机：<code class=\"highlighter-rouge\">receiveValue</code> 回调是一个不错的地方。将 <code class=\"highlighter-rouge\">MySink</code> 中的 <code class=\"highlighter-rouge\">receiveValue</code> 签名进行修改，让它返回一个 <code class=\"highlighter-rouge\">Bool</code> 来表示是否应该继续下一次请求，并为 <code class=\"highlighter-rouge\">MySink</code> 添加一个属性持有它：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"kt\">MySink</span> <span class=\"c1\">// ... {</span>\n    <span class=\"c1\">// let receiveValue: (Input) -&gt; Void</span>\n    <span class=\"k\">let</span> <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Bool</span>\n    \n    <span class=\"k\">var</span> <span class=\"nv\">shouldPullNewValue</span><span class=\"p\">:</span> <span class=\"kt\">Bool</span> <span class=\"o\">=</span> <span class=\"kc\">false</span>\n    \n    <span class=\"nf\">init</span><span class=\"p\">(</span>\n        <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"kd\">@escaping</span> <span class=\"p\">(</span><span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Completion</span><span class=\"o\">&lt;</span><span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span><span class=\"p\">,</span>\n        <span class=\"c1\">// receiveValue: @escaping (Input) -&gt; Void</span>\n        <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"kd\">@escaping</span> <span class=\"p\">(</span><span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Bool</span>\n    <span class=\"p\">)</span>\n    <span class=\"c1\">// ...</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">extension</span> <span class=\"kt\">Publisher</span> <span class=\"p\">{</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">mySink</span><span class=\"p\">(</span>\n        <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"kd\">@escaping</span> <span class=\"p\">(</span><span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Completion</span><span class=\"o\">&lt;</span><span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span><span class=\"p\">,</span>\n        <span class=\"c1\">// receiveValue: @escaping (Output) -&gt; Void</span>\n        <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"kd\">@escaping</span> <span class=\"p\">(</span><span class=\"kt\">Output</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Bool</span>\n    <span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Cancellable</span> <span class=\"o\">&amp;</span> <span class=\"kt\">Resumable</span>\n</code></pre> \n </div> \n</div> \n<p>当 <code class=\"highlighter-rouge\">shouldPullNewValue</code> 为 <code class=\"highlighter-rouge\">true</code> 时，在收到新值后，应当继续请求下一个值；否则，便不再继续请求，将事件流关闭，等待外界调用 <code class=\"highlighter-rouge\">resume</code> 再重启。</p> \n<p>对 <code class=\"highlighter-rouge\">MySink</code> 的相关方法进行修改：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"nv\">subscription</span><span class=\"p\">:</span> <span class=\"kt\">Subscription</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">subscription</span> <span class=\"o\">=</span> <span class=\"n\">subscription</span>\n    <span class=\"nf\">resume</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">input</span><span class=\"p\">:</span> <span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Demand</span> <span class=\"p\">{</span>\n    <span class=\"n\">shouldPullNewValue</span> <span class=\"o\">=</span> <span class=\"nf\">receiveValue</span><span class=\"p\">(</span><span class=\"n\">input</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">shouldPullNewValue</span> <span class=\"p\">?</span> <span class=\"o\">.</span><span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"k\">none</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"nf\">resume</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">guard</span> <span class=\"o\">!</span><span class=\"n\">shouldPullNewValue</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">shouldPullNewValue</span> <span class=\"o\">=</span> <span class=\"kc\">true</span>\n    <span class=\"n\">subscription</span><span class=\"p\">?</span><span class=\"o\">.</span><span class=\"nf\">request</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>这样，就可以在使用的时候通过 <code class=\"highlighter-rouge\">receiveValue</code> 闭包返回 <code class=\"highlighter-rouge\">false</code> 来暂停；在暂停后，通过调用 <code class=\"highlighter-rouge\">resume</code> 来继续了。</p> \n<p>假设我们有一个巨大 (甚至无限！) 的数据集，在使用 <code class=\"highlighter-rouge\">sink</code> 的情况下由于处理速度无法跟上事件的发送速度，我们将会被直接卡死：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">...</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">publisher</span><span class=\"o\">.</span><span class=\"nf\">sink</span><span class=\"p\">(</span>\n    <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">completion</span> <span class=\"k\">in</span>\n        <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Completion: </span><span class=\"se\">\\(</span><span class=\"n\">completion</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n    <span class=\"p\">},</span>\n    <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">value</span> <span class=\"k\">in</span>\n        <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Receive value: </span><span class=\"se\">\\(</span><span class=\"n\">value</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n</code></pre> \n </div> \n</div> \n<p>但是如果我们通过使用 <code class=\"highlighter-rouge\">mySink</code> 并设定一定条件，就可以很优雅地处理这个 backpressure。比如每秒只需要 <code class=\"highlighter-rouge\">Publisher</code> 发送五个事件，并进行处理：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"k\">var</span> <span class=\"nv\">buffer</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kt\">Int</span><span class=\"p\">]()</span>\n<span class=\"k\">let</span> <span class=\"nv\">subscriber</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">...</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">publisher</span><span class=\"o\">.</span><span class=\"nf\">print</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"nf\">mySink</span><span class=\"p\">(</span>\n    <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">completion</span> <span class=\"k\">in</span>\n        <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Completion: </span><span class=\"se\">\\(</span><span class=\"n\">completion</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n    <span class=\"p\">},</span>\n    <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">value</span> <span class=\"k\">in</span>\n        <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Receive value: </span><span class=\"se\">\\(</span><span class=\"n\">value</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n        <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"nf\">append</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"o\">&lt;</span> <span class=\"mi\">5</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">cancellable</span>  <span class=\"o\">=</span> <span class=\"kt\">Timer</span><span class=\"o\">.</span><span class=\"nf\">publish</span><span class=\"p\">(</span><span class=\"nv\">every</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nv\">on</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">main</span><span class=\"p\">,</span> <span class=\"nv\">in</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"k\">default</span><span class=\"p\">)</span>\n    <span class=\"o\">.</span><span class=\"nf\">autoconnect</span><span class=\"p\">()</span>\n    <span class=\"o\">.</span><span class=\"n\">sink</span> <span class=\"p\">{</span> <span class=\"n\">_</span> <span class=\"k\">in</span>\n        <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"nf\">removeAll</span><span class=\"p\">()</span>\n        <span class=\"n\">subscriber</span><span class=\"o\">.</span><span class=\"nf\">resume</span><span class=\"p\">()</span>\n    <span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>通过这种方式，我们自定义的 <code class=\"highlighter-rouge\">MySink</code> 成为了一个可以用于处理 backpressure 的通用方案。</p> \n<blockquote> \n <p>相关的代码可以<a href=\"https://gist.github.com/onevcat/baecc584e3cbfa2cc161290b2dfd300a\">在这里找到</a>。</p> \n</blockquote> \n<h2 id=\"练习\">练习</h2> \n<p>为了保持和<a href=\"https://onevcat.com/2019/12/backpressure-in-combine/(https://objccn.io/products/swift-ui)\">《SwiftUI 和 Combine 编程》</a>这本书的形式上的类似，我也准备了一些小练习，希望能帮助读者通过实际动手练习掌握本文的内容。</p> \n<h3 id=\"1-自定义实现-subscribersassign\">1. 自定义实现 <code class=\"highlighter-rouge\">Subscribers.Assign</code></h3> \n<p>文中自定义了 <code class=\"highlighter-rouge\">MySink</code>，来复现 <code class=\"highlighter-rouge\">Sink</code> 的功能。现在请你依照类似的方式创建一个你自己的 <code class=\"highlighter-rouge\">MyAssign</code> 类型，让它和 <code class=\"highlighter-rouge\">Subscribers.Assign</code> 的行为一致。作为提示，下面是 Combine 框架中 <code class=\"highlighter-rouge\">Subscribers.Assign</code> 的 (简化版的) public 声明：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"kt\">Assign</span><span class=\"o\">&lt;</span><span class=\"kt\">Root</span><span class=\"p\">,</span> <span class=\"kt\">Input</span><span class=\"o\">&gt;</span> <span class=\"p\">:</span> <span class=\"kt\">Subscriber</span><span class=\"p\">,</span> <span class=\"kt\">Cancellable</span> <span class=\"p\">{</span>\n    <span class=\"kd\">typealias</span> <span class=\"kt\">Failure</span> <span class=\"o\">=</span> <span class=\"kt\">Never</span>\n    <span class=\"k\">var</span> <span class=\"nv\">object</span><span class=\"p\">:</span> <span class=\"kt\">Root</span><span class=\"p\">?</span> <span class=\"p\">{</span> <span class=\"k\">get</span> <span class=\"p\">}</span>\n    <span class=\"k\">let</span> <span class=\"nv\">keyPath</span><span class=\"p\">:</span> <span class=\"kt\">ReferenceWritableKeyPath</span><span class=\"o\">&lt;</span><span class=\"kt\">Root</span><span class=\"p\">,</span> <span class=\"kt\">Input</span><span class=\"o\">&gt;</span>\n    \n    <span class=\"c1\">// ...</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<h3 id=\"2-一次-request-超过-max1-个数的事件\">2. 一次 request 超过 <code class=\"highlighter-rouge\">.max(1)</code> 个数的事件</h3> \n<p>在引入 <code class=\"highlighter-rouge\">resume</code> 时，我们将 <code class=\"highlighter-rouge\">.max(1)</code> 硬编码在了方法内部：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">resume</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"n\">subscription</span><span class=\"p\">?</span><span class=\"o\">.</span><span class=\"nf\">request</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>我们能不能修改这个方法的签名，让它更灵活一些，接受一个 <code class=\"highlighter-rouge\">Demand</code> 参数，让它可以向 <code class=\"highlighter-rouge\">subscription</code> 请求多个值？比如：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">resume</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">demand</span><span class=\"p\">:</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Demand</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">subscription</span><span class=\"p\">?</span><span class=\"o\">.</span><span class=\"nf\">request</span><span class=\"p\">(</span><span class=\"n\">demand</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>这么做会对 <code class=\"highlighter-rouge\">Resumable</code> 产生影响吗？会对之后我们想要实现的暂停逻辑有什么影响？我们还能够使用这样的 <code class=\"highlighter-rouge\">resume</code> 写出可靠的暂停和重启逻辑么？</p> \n<h3 id=\"3-通用的-subscriber-和专用的-subscriber\">3. 通用的 Subscriber 和专用的 Subscriber</h3> \n<p>本文最后我们实现的是一个相对通用的 Subscriber，但是如果逻辑更复杂，或者需要大规模重复使用时，把逻辑放在 <code class=\"highlighter-rouge\">receiveValue</code> 闭包中会有些麻烦。</p> \n<p>请尝试把原文中 「<code class=\"highlighter-rouge\">buffer</code> 元素数到达 5 时，暂停一秒」这个逻辑封装起来，用一个新的专用的 <code class=\"highlighter-rouge\">Subscriber</code> 替代。你可以尝试两个方向：</p> \n<ol> \n <li>使用一个新的类型，包装现有的 <code class=\"highlighter-rouge\">MySink</code>，将判断逻辑放到新类型中；<code class=\"highlighter-rouge\">Subscriber</code> 协调所需要定义的方法，通过转发的方式交给 <code class=\"highlighter-rouge\">MySink</code> 处理。</li> \n <li>完全重新实现一个和 <code class=\"highlighter-rouge\">MySink</code> 无关的 <code class=\"highlighter-rouge\">Subscriber</code>，专门用来处理这类定时开关的事件流。</li> \n</ol>","descriptionType":"text/html","publishedDate":"Sun, 01 Dec 2019 03:32:00 +0000","feedId":3176,"bgimg":"https://onevcat.com/assets/images/2019/publisher-subscriber-flow.svg","linkMd5":"54f2952e3c3edce65471aa706e814635","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn19@2020_5/2020/08/24/21-24-58-477_f762b5692aadc07f.svg","destWidth":0,"destHeight":0,"sourceBytes":5068,"destBytes":5068,"author":"","articleImgCdnMap":{"https://onevcat.com/assets/images/2019/publisher-subscriber-flow.svg":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn19@2020_5/2020/08/24/21-24-58-477_f762b5692aadc07f.svg"},"publishedOrCreatedDate":1598304289202},{"createdTime":"2020-08-25 05:24:49","updatedTime":"2020-08-25 05:24:49","title":"一些关于 App Clips 的笔记","link":"https://onevcat.com/2020/06/first-look-app-clips/","description":"<p>App clips 是今天 WWDC 上 iOS 14 的一个重要“卖点”，它提供了一种“即时使用”的方式，让用户可以在特定时间、特定场景，在不下载完整 app 的前提下，体验到你的 app 的核心功能。</p> \n<p>装好 Xcode 12 以后第一时间体验了一下如何为 app 添加 app clip。它的创建和使用都很简单，也没有什么新的 API，所以要为 app 开发一个 clip 的话，难点更多地在于配置、代码的复用以及尺寸优化等。在阅读文档和实际体验的同时，顺便整理了一些要点，作为备忘。</p> \n<h3 id=\"app-clips-的一些基本事实和添加步骤\">App clips 的一些基本事实和添加步骤</h3> \n<p>在写作本文时 (2020.06.23)，通过文档和实践能获知的关于 app clips 的几点情况：</p> \n<ul> \n <li>一个 app 能且只能拥有一个 app clip。</li> \n <li> <p>通过在一个 app project 中添加 app clip target 就能很简单地创建一个 app clip 了。</p> <p><img src=\"https://onevcat.com/assets/images/2020/app_clip_target_add.png\" alt=\"\" /></p> </li> \n <li>App clip 的<strong>结构和普通的 app 毫无二致</strong>。你可以使用绝大多数的框架，包括 SwiftUI 和 UIKit (<a href=\"https://developer.apple.com/documentation/app_clips/developing_a_great_app_clip#3625585\">不能使用的</a>都是一些冷门框架和隐私相关的框架，比如 CallKit 和 HomeKit 等 )。所以 app clip 的开发非常简单，你可以使用所有你已经熟知的技术：创建 <code class=\"highlighter-rouge\">UIViewController</code>，组织 <code class=\"highlighter-rouge\">UIView</code>，用 <code class=\"highlighter-rouge\">URLSession</code> 发送请求等等。和小程序这种 H5 技术不同，app clip 就是一个 native 的几乎“什么都能做”的“简化版”的 app。</li> \n <li>App clip 所包含的功能必须是 main app 的子集。App clip 的 bundle ID 必须是 main app 的 bundle ID 后缀加上 <code class=\"highlighter-rouge\">.Clip</code> (在 Xcode 中创建 app clip target 时会自动帮你搞定)。</li> \n <li>域名和 server 配置方面，和支持 Universal Link 以及 Web Credentials 的时候要做的事情非常相似：你需要为 app clip 的 target 添加 Associated Domain，格式为 <code class=\"highlighter-rouge\">appclips:yourdomain.com</code>；然后在 server 的 App Site Association (通常是在网站 <code class=\"highlighter-rouge\">.well-known</code> 下的 <code class=\"highlighter-rouge\">apple-app-site-association</code> 文件) 中添加这个域名对应的 <code class=\"highlighter-rouge\">appclips</code> 条目：</li> \n</ul> \n<div class=\"language-javascript highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"p\">{</span>\n  <span class=\"s2\">\"appclips\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"apps\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"ABCED12345.com.example.MyApp.Clip\"</span><span class=\"p\">]</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span> \n</code></pre>\n </div>\n</div> \n<ul> \n <li> <p>默认最简单的情况下，app clip <strong>通过 Safari App Banner 或者 iMessage app 中的符合 domain 要求的 URL 下载和启动</strong>。这种启动方式叫做 Default App Clip Experience。</p> </li> \n <li> <p>一个能够启动 app clip 的 App Banner 形式如下：</p> </li> \n</ul> \n<div class=\"language-xml highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"nt\">&lt;meta</span> \n  <span class=\"na\">name=</span><span class=\"s\">\"apple-itunes-app\"</span> \n  <span class=\"na\">content=</span><span class=\"s\">\"app-id=myAppStoreID,</span> <span class=\"na\">app-clip-bundle-id=</span><span class=\"s\">appClipBundleID</span>\n<span class=\"nt\">&gt;</span>\n</code></pre>\n </div>\n</div> \n<ul> \n <li> <p>你的 app clip 在被真正调用前，系统会显示一个 app clip card。对于 Default App Clip Experience，你可以在 App Store Connect 中为这种启动方式提供固定的图片，标题文本和按钮文本。（现在版本的 App Store Connect 中似乎还没有设置的地方，应该是 iOS 14 正式发布后会添加）。</p> <p><img src=\"https://onevcat.com/assets/images/2020/app_clip_parts.png\" alt=\"\" /></p> </li> \n <li>App clip card 显示时，你的 app clip 就已经开始下载了。App clip 的<strong>体积必须在 10MB 以内</strong>。这样，大概率在用户选择打开你的 app clip 之前，就能下载完成，以提供良好体验。</li> \n <li>用户点击 banner 或者 iMessage 链接，且继续点击打开按钮后，app clip 的 user activity 关联的生命周期函数将被调用，根据你所使用的技术不同，它将是 <a href=\"https://developer.apple.com/documentation/swiftui/view/oncontinueuseractivity(_:perform:)\"><code class=\"highlighter-rouge\">onContinueUserActivity(_:perform:)</code></a> (SwiftUI)，<a href=\"https://developer.apple.com/documentation/uikit/uiscenedelegate/3238060-scene\"><code class=\"highlighter-rouge\">scene(_:willContinueUserActivityWithType:)</code></a> (Scene-Based app) 或者 <a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623072-application\"><code class=\"highlighter-rouge\">application(_:continue:restorationHandler:)</code></a> (App Delegate app) 之一。获取到唤醒 app clip 的 <code class=\"highlighter-rouge\">NSUserActivity</code> 后，就可以通过 <code class=\"highlighter-rouge\">webpageURL</code> 获取到调用的链接了(Banner 所在页面的链接，或 iMessage 中点击的链接)。</li> \n <li>根据唤醒 app clip 的 URL，用 UIKit 或 SwiftUI 完成对应的 UI 构建和展示。因为 App Clip 需要是 main app 的子集，因此一般来说这些 URL (以及对应的 <code class=\"highlighter-rouge\">NSUserActivity</code>) 也需要能被 main app 处理。当 main app 已经被安装时，唤醒的会是 main app。</li> \n <li>对于更复杂的唤醒情况，可以根据 URL 的不同、甚至是地点的不同，来提供不一样的 app clip card。这部分内容也是通过 App Store Connect 进行配置的。这类启动方式被称为 Advanced App Clip Experiences。</li> \n <li> <p>在开发时，可以通过设置 <code class=\"highlighter-rouge\">_XCAppClipURL</code> 这个环境变量，并运行 app clip target 来“模拟”通过特定 URL 点击后的情况。当 Associated Domain 设置正确后，在 Xcode 中运行 app clip，就可以拿到包含这个环境值的 <code class=\"highlighter-rouge\">NSUserActivity</code>。这样在 Beta 期间的本地开发就不需要依赖外部 server 环境了。</p> <p><img src=\"https://onevcat.com/assets/images/2020/app_clip_url_env.png\" alt=\"\" /></p> </li> \n <li>关于代码和资源的组织。很大机率 main app 和 app clip 是需要共用代码的，可以无脑地选择将源码放到 main app 和 app clip 两个 target 中，也可以选择打成 framework 或者 local Swift Package。不管如何，这部分共用的 binary 都会同时存在于 main app bundle 和 app clip bundle 中。图片等素材资源也类似。简单说，app clip 其实就是一个完整但尺寸有所限制、并且和某个域名绑定，因此不需要用户认证 Apple ID 就可以下载的 app。</li> \n <li>部分 app clip 是“用完就走”的，但是也有部分 app clip 是为了导流到 main app。可以通过 <code class=\"highlighter-rouge\">SKOverlay</code> 或 <code class=\"highlighter-rouge\">SKStoreProductViewController</code> 来显示一个指向 main app 的推广窗：</li> \n</ul> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">scene</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">scene</span><span class=\"p\">:</span> <span class=\"kt\">UIScene</span><span class=\"p\">,</span> <span class=\"k\">continue</span> <span class=\"nv\">userActivity</span><span class=\"p\">:</span> <span class=\"kt\">NSUserActivity</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// 处理 userActivity ...</span>\n  \n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"nv\">scene</span> <span class=\"o\">=</span> <span class=\"n\">scene</span> <span class=\"k\">as?</span> <span class=\"kt\">UIWindowScene</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"nv\">overlay</span> <span class=\"o\">=</span> <span class=\"kt\">SKOverlay</span><span class=\"p\">(</span><span class=\"nv\">configuration</span><span class=\"p\">:</span> <span class=\"kt\">SKOverlay</span><span class=\"o\">.</span><span class=\"kt\">AppClipConfiguration</span><span class=\"p\">(</span><span class=\"nv\">position</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">bottom</span><span class=\"p\">))</span>\n    <span class=\"n\">overlay</span><span class=\"o\">.</span><span class=\"nf\">present</span><span class=\"p\">(</span><span class=\"nv\">in</span><span class=\"p\">:</span> <span class=\"n\">scene</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p><img src=\"https://onevcat.com/assets/images/2020/app_clip_skoverlay.png\" alt=\"\" /></p> \n<ul> \n <li>如果在 app clip 中有用户注册/登录和支付需求的话，Apple 推荐使用 Sign in with Apple 和 Apple Pay 来简化流程。虽然在 app clip 中，所有的 UI 操作和导航关系都是支持的 (手势，modal present，navigation push 等等)，但 app clip 应该尽量避免 tab 或者很长的表单这类复杂交互，让用户能直奔主题。</li> \n</ul> \n<h3 id=\"一些初步的思考和展望\">一些初步的思考和展望</h3> \n<p>所以今后，一个有追求的 iOS app 将会有两个 .app 的 bundle：一个完整的原始版本，一个快速搞定核心功能的 lite 版本。不过悲剧的是，国内的 iOS 生态面临崩溃，微信小程序的地位不可撼动，所以 app clip 能在多大程度上吸引开发者是存有疑问的：因为很难说服一个跨 iOS 和 Android 平台的成熟服务将 app clip 作为核心部分进行开发，而 iPhone 的市场占有率又决定了这样的开发能够覆盖的用户十分有限。</p> \n<p>不过好处在于，很大程度上，为现有的 app 提供一个 app clip 需要花费的精力并不会很多：在确定了方向和提供的核心功能后，大量的 main app 中的既有代码和素材都可以重复使用。App clip 和小程序定位也完全不同。前者并没有改变以 app 为中心、以提高体验和快捷使用为基本点的方针：它更像一种为 main app 做 promotion 的手段，让 main app 多一些被曝光和试用的机会。对于线下获取用户来说，也许会有一定效果。从体验上来说，可以肯定的是，基于 native 和成熟开发框架 (此处专指 UIKit，暂不包含 SwiftUI) 的 app clip 一定是胜过小程序很多的。但是，究竟有多少注重体验的高端用户，愿意为其买单，我个人只能抱有谨慎乐观的态度。</p>","descriptionType":"text/html","publishedDate":"Tue, 23 Jun 2020 03:00:00 +0000","feedId":3176,"bgimg":"https://onevcat.com/assets/images/2020/app_clip_target_add.png","linkMd5":"42ee8ad4bdf9b8502fc537512e6b6e21","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn12@2020_1/2020/08/24/21-24-58-937_029fdc8167349910.webp","destWidth":726,"destHeight":525,"sourceBytes":43677,"destBytes":9048,"author":"","articleImgCdnMap":{"https://onevcat.com/assets/images/2020/app_clip_target_add.png":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn12@2020_1/2020/08/24/21-24-58-937_029fdc8167349910.webp","https://onevcat.com/assets/images/2020/app_clip_parts.png":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn84@2020_6/2020/08/24/21-25-02-722_97d943277f58e145.webp","https://onevcat.com/assets/images/2020/app_clip_url_env.png":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn44@2020_4/2020/08/24/21-25-03-517_ff5405e0e6835298.webp","https://onevcat.com/assets/images/2020/app_clip_skoverlay.png":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn96@2020_1/2020/08/24/21-25-03-247_a2185489f92d9b3f.webp"},"publishedOrCreatedDate":1598304289193},{"createdTime":"2020-08-25 05:24:49","updatedTime":"2020-08-25 05:24:49","title":"与 JOSE 战斗的日子 - 写给 iOS 开发者的密码学入门手册 (实践)","link":"https://onevcat.com/2018/12/jose-3/","description":"<p><img src=\"https://onevcat.com/assets/images/2018/matrix.jpg\" alt=\"\" /></p> \n<h2 id=\"概述\">概述</h2> \n<p>这是关于 JOSE 和密码学的三篇系列文章中的最后一篇，你可以在下面的链接中找到其他部分：</p> \n<ol> \n <li><a href=\"https://onevcat.com/2018/12/jose-1/\">基础 - 什么是 JWT 以及 JOSE</a></li> \n <li><a href=\"https://onevcat.com/2018/12/jose-2/\">理论 - JOSE 中的签名和验证流程</a></li> \n <li>实践 - 如何使用 Security.framework 处理 JOSE 中的验证 (本文)</li> \n</ol> \n<p>这一篇中，我们会在 JOSE 基础篇和理论篇的知识架构上，使用 iOS (或者说 Cocoa) 的相关框架来完成对 JWT 的解析，并利用 JWK 对它的签名进行验证。在最后，我会给出一些我自己在实现和学习这些内容时的思考，并把一些相关工具和标准列举一下。</p> \n<h2 id=\"解码-jwt\">解码 JWT</h2> \n<p>JWT，或者更精确一点，JWS 中的 Header 和 Payload 都是 Base64Url 编码的。为了获取原文内容，先需要对 Header 和 Payload 解码。</p> \n<h3 id=\"base64url\">Base64Url</h3> \n<p>Base64 相信大家都已经很熟悉了，随着网络普及，这套编码有一个很大的“缺点”，就是使用了 <code class=\"highlighter-rouge\">+</code>，<code class=\"highlighter-rouge\">/</code> 和 <code class=\"highlighter-rouge\">=</code>。这些字符在 URL 里是很不友好的，在作为传输时需要额外做 escaping。Base64Url 就是针对这个问题的改进，具体来说就是：</p> \n<ol> \n <li>将 <code class=\"highlighter-rouge\">+</code> 替换为 <code class=\"highlighter-rouge\">-</code>；</li> \n <li>将 <code class=\"highlighter-rouge\">/</code> 替换为 <code class=\"highlighter-rouge\">_</code>；</li> \n <li>将末尾的 <code class=\"highlighter-rouge\">=</code> 干掉。</li> \n</ol> \n<p>相关代码的话非常简单，为 <code class=\"highlighter-rouge\">Data</code> 和 <code class=\"highlighter-rouge\">String</code> 分别添加 extension 来相互转换就好：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">extension</span> <span class=\"kt\">Data</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// Encode `self` with URL escaping considered.</span>\n    <span class=\"k\">var</span> <span class=\"nv\">base64URLEncoded</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"nv\">base64Encoded</span> <span class=\"o\">=</span> <span class=\"nf\">base64EncodedString</span><span class=\"p\">()</span>\n        <span class=\"k\">return</span> <span class=\"n\">base64Encoded</span>\n            <span class=\"o\">.</span><span class=\"nf\">replacingOccurrences</span><span class=\"p\">(</span><span class=\"nv\">of</span><span class=\"p\">:</span> <span class=\"s\">\"+\"</span><span class=\"p\">,</span> <span class=\"nv\">with</span><span class=\"p\">:</span> <span class=\"s\">\"-\"</span><span class=\"p\">)</span>\n            <span class=\"o\">.</span><span class=\"nf\">replacingOccurrences</span><span class=\"p\">(</span><span class=\"nv\">of</span><span class=\"p\">:</span> <span class=\"s\">\"/\"</span><span class=\"p\">,</span> <span class=\"nv\">with</span><span class=\"p\">:</span> <span class=\"s\">\"_\"</span><span class=\"p\">)</span>\n            <span class=\"o\">.</span><span class=\"nf\">replacingOccurrences</span><span class=\"p\">(</span><span class=\"nv\">of</span><span class=\"p\">:</span> <span class=\"s\">\"=\"</span><span class=\"p\">,</span> <span class=\"nv\">with</span><span class=\"p\">:</span> <span class=\"s\">\"\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">extension</span> <span class=\"kt\">String</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// Returns the data of `self` (which is a base64 string), with URL related characters decoded.</span>\n    <span class=\"k\">var</span> <span class=\"nv\">base64URLDecoded</span><span class=\"p\">:</span> <span class=\"kt\">Data</span><span class=\"p\">?</span> <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"nv\">paddingLength</span> <span class=\"o\">=</span> <span class=\"mi\">4</span> <span class=\"o\">-</span> <span class=\"n\">count</span> <span class=\"o\">%</span> <span class=\"mi\">4</span>\n        <span class=\"c1\">// Filling = for %4 padding.</span>\n        <span class=\"k\">let</span> <span class=\"nv\">padding</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">paddingLength</span> <span class=\"o\">&lt;</span> <span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"p\">?</span> <span class=\"kt\">String</span><span class=\"p\">(</span><span class=\"nv\">repeating</span><span class=\"p\">:</span> <span class=\"s\">\"=\"</span><span class=\"p\">,</span> <span class=\"nv\">count</span><span class=\"p\">:</span> <span class=\"n\">paddingLength</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"s\">\"\"</span>\n        <span class=\"k\">let</span> <span class=\"nv\">base64EncodedString</span> <span class=\"o\">=</span> <span class=\"k\">self</span>\n            <span class=\"o\">.</span><span class=\"nf\">replacingOccurrences</span><span class=\"p\">(</span><span class=\"nv\">of</span><span class=\"p\">:</span> <span class=\"s\">\"-\"</span><span class=\"p\">,</span> <span class=\"nv\">with</span><span class=\"p\">:</span> <span class=\"s\">\"+\"</span><span class=\"p\">)</span>\n            <span class=\"o\">.</span><span class=\"nf\">replacingOccurrences</span><span class=\"p\">(</span><span class=\"nv\">of</span><span class=\"p\">:</span> <span class=\"s\">\"_\"</span><span class=\"p\">,</span> <span class=\"nv\">with</span><span class=\"p\">:</span> <span class=\"s\">\"/\"</span><span class=\"p\">)</span>\n            <span class=\"o\">+</span> <span class=\"n\">padding</span>\n        <span class=\"k\">return</span> <span class=\"kt\">Data</span><span class=\"p\">(</span><span class=\"nv\">base64Encoded</span><span class=\"p\">:</span> <span class=\"n\">base64EncodedString</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<h3 id=\"结合使用-jsondecoder-和-base64url-来处理-jwt\">结合使用 <code class=\"highlighter-rouge\">JSONDecoder</code> 和 Base64Url 来处理 JWT</h3> \n<p>因为 JWT 的 Header 和 Payload 部分实际上是有效的 JSON，为了简单，我们可以利用 Swift 的 Codable 来解析 JWT。为了简化处理，可以封装一个针对以 Base64Url 表示的 JSON 的 decoder：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">class</span>  <span class=\"kt\">Base64URLJSONDecoder</span><span class=\"p\">:</span> <span class=\"kt\">JSONDecoder</span> <span class=\"p\">{</span>\n    <span class=\"k\">override</span> <span class=\"kd\">func</span> <span class=\"n\">decode</span><span class=\"o\">&lt;</span><span class=\"kt\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">type</span><span class=\"p\">:</span> <span class=\"kt\">T</span><span class=\"o\">.</span><span class=\"k\">Type</span><span class=\"p\">,</span> <span class=\"n\">from</span> <span class=\"nv\">data</span><span class=\"p\">:</span> <span class=\"kt\">Data</span><span class=\"p\">)</span> <span class=\"k\">throws</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">T</span> <span class=\"k\">where</span> <span class=\"kt\">T</span> <span class=\"p\">:</span> <span class=\"kt\">Decodable</span> <span class=\"p\">{</span>\n        <span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">string</span> <span class=\"o\">=</span> <span class=\"kt\">String</span><span class=\"p\">(</span><span class=\"nv\">data</span><span class=\"p\">:</span> <span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"nv\">encoding</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">ascii</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// 错误处理</span>\n        <span class=\"p\">}</span>\n        \n        <span class=\"k\">return</span> <span class=\"k\">try</span> <span class=\"nf\">decode</span><span class=\"p\">(</span><span class=\"n\">type</span><span class=\"p\">,</span> <span class=\"nv\">from</span><span class=\"p\">:</span> <span class=\"n\">string</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n    \n    <span class=\"kd\">func</span> <span class=\"n\">decode</span><span class=\"o\">&lt;</span><span class=\"kt\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">type</span><span class=\"p\">:</span> <span class=\"kt\">T</span><span class=\"o\">.</span><span class=\"k\">Type</span><span class=\"p\">,</span> <span class=\"n\">from</span> <span class=\"nv\">string</span><span class=\"p\">:</span> <span class=\"kt\">String</span><span class=\"p\">)</span> <span class=\"k\">throws</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">T</span> <span class=\"k\">where</span> <span class=\"kt\">T</span> <span class=\"p\">:</span> <span class=\"kt\">Decodable</span> <span class=\"p\">{</span>\n        <span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">decodedData</span> <span class=\"o\">=</span> <span class=\"n\">string</span><span class=\"o\">.</span><span class=\"n\">base64URLDecoded</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// 错误处理</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"k\">try</span> <span class=\"k\">super</span><span class=\"o\">.</span><span class=\"nf\">decode</span><span class=\"p\">(</span><span class=\"n\">type</span><span class=\"p\">,</span> <span class=\"nv\">from</span><span class=\"p\">:</span> <span class=\"n\">decodedData</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p><code class=\"highlighter-rouge\">Base64URLJSONDecoder</code> 将 Base64Url 的转换封装到解码过程中，这样一来，我们只需要获取 JWT，将它用 <code class=\"highlighter-rouge\">.</code> 分割开，然后使用 <code class=\"highlighter-rouge\">Base64URLJSONDecoder</code> 就能把 Header 和 Payload 轻易转换了，比如：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"kt\">Header</span><span class=\"p\">:</span> <span class=\"kt\">Codable</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"nv\">algorithm</span><span class=\"p\">:</span> <span class=\"kt\">String</span>\n    <span class=\"k\">let</span> <span class=\"nv\">tokenType</span><span class=\"p\">:</span> <span class=\"kt\">String</span><span class=\"p\">?</span>\n    <span class=\"k\">let</span> <span class=\"nv\">keyID</span><span class=\"p\">:</span> <span class=\"kt\">String</span><span class=\"p\">?</span>\n\n    <span class=\"kd\">enum</span> <span class=\"kt\">CodingKeys</span><span class=\"p\">:</span> <span class=\"kt\">String</span><span class=\"p\">,</span> <span class=\"kt\">CodingKey</span> <span class=\"p\">{</span>\n        <span class=\"k\">case</span> <span class=\"n\">algorithm</span> <span class=\"o\">=</span> <span class=\"s\">\"alg\"</span>\n        <span class=\"k\">case</span> <span class=\"n\">tokenType</span> <span class=\"o\">=</span> <span class=\"s\">\"typ\"</span>\n        <span class=\"k\">case</span> <span class=\"n\">keyID</span> <span class=\"o\">=</span> <span class=\"s\">\"kid\"</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">jwtRaw</span> <span class=\"o\">=</span> <span class=\"s\">\"eyJhbGciOiJSUzI1NiI...\"</span> <span class=\"c1\">// JWT 字符串，后面部分省略了</span>\n<span class=\"k\">let</span> <span class=\"nv\">rawComponents</span> <span class=\"o\">=</span> <span class=\"n\">text</span><span class=\"o\">.</span><span class=\"nf\">components</span><span class=\"p\">(</span><span class=\"nv\">separatedBy</span><span class=\"p\">:</span> <span class=\"s\">\".\"</span><span class=\"p\">)</span>\n<span class=\"k\">let</span> <span class=\"nv\">decoder</span> <span class=\"o\">=</span> <span class=\"kt\">Base64JSONDecoder</span><span class=\"p\">()</span>\n<span class=\"k\">let</span> <span class=\"nv\">header</span> <span class=\"o\">=</span> <span class=\"k\">try</span> <span class=\"n\">decoder</span><span class=\"o\">.</span><span class=\"nf\">decode</span><span class=\"p\">(</span><span class=\"kt\">Header</span><span class=\"o\">.</span><span class=\"k\">self</span><span class=\"p\">,</span> <span class=\"nv\">from</span><span class=\"p\">:</span> <span class=\"n\">rawComponents</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n\n<span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">keyID</span> <span class=\"o\">=</span> <span class=\"n\">header</span><span class=\"o\">.</span><span class=\"n\">keyID</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"cm\">/* 验证失败 */</span> <span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>在 Header 中，我们应该可以找到指定了验证签名所需要使用的公钥的 <code class=\"highlighter-rouge\">keyID</code>。如果没有的话，验证失败，登录过程终止。</p> \n<p>对于签名，我们将解码后的原始的 <code class=\"highlighter-rouge\">Data</code> 保存下来，稍后使用。同样地，我们最好也保存一下 <code class=\"highlighter-rouge\">{Header}.{Payload}</code> 的部分，它在验证中也会被使用到：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">signature</span> <span class=\"o\">=</span> <span class=\"n\">rawComponents</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">base64URLDecoded</span><span class=\"o\">!</span>\n<span class=\"k\">let</span> <span class=\"nv\">plainText</span> <span class=\"o\">=</span> <span class=\"s\">\"</span><span class=\"se\">\\(</span><span class=\"n\">rawComponents</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"se\">)</span><span class=\"s\">.</span><span class=\"se\">\\(</span><span class=\"n\">rawComponents</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"se\">)</span><span class=\"s\">\"</span>\n</code></pre> \n </div> \n</div> \n<blockquote> \n <p>这里的代码基本都没有考虑错误处理，大部分是直接让程序崩溃。实际的产品中验证签名过程中的错误应该被恰当处理，而不是粗暴挂掉。</p> \n</blockquote> \n<h2 id=\"在-securityframework-中处理签名\">在 Security.framework 中处理签名</h2> \n<p>我们已经准备好签名的数据和原文了，万事俱备，只欠密钥。</p> \n<h3 id=\"处理密钥\">处理密钥</h3> \n<p>通过 <code class=\"highlighter-rouge\">keyID</code>，在预先设定的 JWT Host 中我们应该可以找到以 JWK 形式表示的密钥。我们计划使用 Security.framework 来处理密钥和签名验证，首先要做的就是遵守框架和 JWA 的规范，通过 JWK 的密钥生成 Security 框架喜欢的 <code class=\"highlighter-rouge\">SecKey</code> 值。</p> \n<p>在其他大部分情况下，我们可能会从一个证书 (certificate，不管是从网络下载的 PEM 还是存储在本地的证书文件) 里获取公钥。像是处理 HTTPS challenge 或者 SSL Pinning 的时候，大部分情况下我们拿到的是完整的证书数据，通过 <code class=\"highlighter-rouge\">SecCertificateCreateWithData</code> 使用 DER 编码的数据创建证书并获取公钥：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">cert</span> <span class=\"o\">=</span> <span class=\"kt\">SecCertificateCreateWithData</span><span class=\"p\">(</span><span class=\"kc\">nil</span><span class=\"p\">,</span> <span class=\"n\">data</span> <span class=\"k\">as</span> <span class=\"kt\">CFData</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 错误处理</span>\n    <span class=\"k\">return</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">policy</span> <span class=\"o\">=</span> <span class=\"kt\">SecPolicyCreateBasicX509</span><span class=\"p\">()</span>\n<span class=\"k\">var</span> <span class=\"nv\">trust</span><span class=\"p\">:</span> <span class=\"kt\">SecTrust</span><span class=\"p\">?</span> <span class=\"o\">=</span> <span class=\"kc\">nil</span>\n<span class=\"kt\">SecTrustCreateWithCertificates</span><span class=\"p\">(</span><span class=\"n\">cert</span><span class=\"p\">,</span> <span class=\"n\">policy</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">trust</span><span class=\"p\">)</span>\n<span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">t</span> <span class=\"o\">=</span> <span class=\"n\">trust</span><span class=\"p\">,</span> <span class=\"k\">let</span> <span class=\"nv\">key</span><span class=\"p\">:</span> <span class=\"kt\">SecKey</span> <span class=\"o\">=</span> <span class=\"kt\">SecTrustCopyPublicKey</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 错误处理</span>\n    <span class=\"k\">return</span>\n<span class=\"p\">}</span>\n<span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)</span>\n</code></pre> \n </div> \n</div> \n<p>但是，在 JWK 的场合，我们是没有 X.509 证书的。JWK 直接将密钥类型和参数编码在 JSON 中，我们当然可以按照 DER 编码规则将这些信息编码回一个符合 X.509 要求的证书，然后使用上面的方法再从中获取证书。不过这显然是画蛇添足，我们完全可以直接通过这些参数，使用特定格式的数据来直接生成 <code class=\"highlighter-rouge\">SecKey</code>。</p> \n<blockquote> \n <p>有可能有同学会迷惑于“公钥”和“证书”这两个概念。一个证书，除了包含有公钥以外，还包含有像是证书发行者，证书目的，以及其他一些元数据的信息。因此，我们可以从一个证书中，提取它所存储的公钥。</p> \n <p>另外，证书本身一般会由另外一个私钥进行签名，并由颁发机构或者受信任的机构进行验证保证其真实性。</p> \n</blockquote> \n<p>使用 <a href=\"https://developer.apple.com/documentation/security/1643701-seckeycreatewithdata\"><code class=\"highlighter-rouge\">SecKeyCreateWithData</code></a> 就可以直接通过公钥参数来生成了：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"kt\">SecKeyCreateWithData</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">keyData</span><span class=\"p\">:</span> <span class=\"kt\">CFData</span><span class=\"p\">,</span> \n                          <span class=\"n\">_</span> <span class=\"nv\">attributes</span><span class=\"p\">:</span> <span class=\"kt\">CFDictionary</span><span class=\"p\">,</span> \n                          <span class=\"n\">_</span> <span class=\"nv\">error</span><span class=\"p\">:</span> <span class=\"kt\">UnsafeMutablePointer</span><span class=\"o\">&lt;</span><span class=\"kt\">Unmanaged</span><span class=\"o\">&lt;</span><span class=\"kt\">CFError</span><span class=\"o\">&gt;</span><span class=\"p\">?</span><span class=\"o\">&gt;</span><span class=\"p\">?)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">SecKey</span><span class=\"p\">?</span>\n</code></pre> \n </div> \n</div> \n<p>第二个参数 <code class=\"highlighter-rouge\">attributes</code> 需要的是密钥种类 (RSA 还是 EC)，密钥类型 (公钥还是私钥)，密钥尺寸 (数据 bit 数) 等信息，比较简单。</p> \n<p>关于所需要的数据格式，根据密钥种类不同，而有所区别。在<a href=\"https://developer.apple.com/documentation/security/1643698-seckeycopyexternalrepresentation\">这个风马牛不相及的页面</a> 以及 <a href=\"https://opensource.apple.com/source/Security/Security-58286.41.2/keychain/SecKey.h\">SecKey 源码</a> 的注释中有所提及：</p> \n<blockquote> \n <p>The method returns data in the PKCS #1 format for an RSA key. For an elliptic curve public key, the format follows the ANSI X9.63 standard using a byte string of 04 || X || Y. … All of these representations use constant size integers, including leading zeros as needed.</p> \n</blockquote> \n<blockquote> \n <p>The requested data format depend on the type of key (kSecAttrKeyType) being created:</p> \n <div class=\"highlighter-rouge\"> \n  <div class=\"highlight\"> \n   <pre class=\"highlight\"><code>kSecAttrKeyTypeRSA               PKCS#1 format, public key can be also in x509 public key format\nkSecAttrKeyTypeECSECPrimeRandom  ANSI X9.63 format (04 || X || Y [ || K])\n</code></pre> \n  </div> \n </div> \n</blockquote> \n<h4 id=\"jwa---rsa\">JWA - RSA</h4> \n<p>简单说，RSA 的公钥需要遵守 PKCS#1，使用 X.509 编码即可。所以对于 RSA 的 JWK 里的 <code class=\"highlighter-rouge\">n</code> 和 <code class=\"highlighter-rouge\">e</code>，我们用 DER 按照 X.509 编码成序列后，就可以扔给 Security 框架了：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">extension</span> <span class=\"kt\">JWK</span> <span class=\"p\">{</span>\n    <span class=\"kd\">struct</span> <span class=\"kt\">RSA</span> <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"nv\">modulus</span><span class=\"p\">:</span> <span class=\"kt\">String</span>\n        <span class=\"k\">let</span> <span class=\"nv\">exponent</span><span class=\"p\">:</span> <span class=\"kt\">String</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">jwk</span><span class=\"p\">:</span> <span class=\"kt\">JWK</span><span class=\"o\">.</span><span class=\"kt\">RSA</span> <span class=\"o\">=</span> <span class=\"o\">...</span>\n<span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">n</span> <span class=\"o\">=</span> <span class=\"n\">jwk</span><span class=\"o\">.</span><span class=\"n\">modulus</span><span class=\"o\">.</span><span class=\"n\">base64URLDecoded</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"o\">...</span> <span class=\"p\">}</span>\n<span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">e</span> <span class=\"o\">=</span> <span class=\"n\">jwk</span><span class=\"o\">.</span><span class=\"n\">exponent</span><span class=\"o\">.</span><span class=\"n\">base64URLDecoded</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"o\">...</span> <span class=\"p\">}</span>\n\n<span class=\"k\">var</span> <span class=\"nv\">modulusBytes</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kt\">UInt8</span><span class=\"p\">](</span><span class=\"n\">n</span><span class=\"p\">)</span>            \n<span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"nv\">firstByte</span> <span class=\"o\">=</span> <span class=\"n\">modulusBytes</span><span class=\"o\">.</span><span class=\"n\">first</span><span class=\"p\">,</span> <span class=\"n\">firstByte</span> <span class=\"o\">&gt;=</span> <span class=\"mh\">0x80</span> <span class=\"p\">{</span>\n    <span class=\"n\">modulusBytes</span><span class=\"o\">.</span><span class=\"nf\">insert</span><span class=\"p\">(</span><span class=\"mh\">0x00</span><span class=\"p\">,</span> <span class=\"nv\">at</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"k\">let</span> <span class=\"nv\">exponentBytes</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kt\">UInt8</span><span class=\"p\">](</span><span class=\"n\">e</span><span class=\"p\">)</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">modulusEncoded</span> <span class=\"o\">=</span> <span class=\"n\">modulusBytes</span><span class=\"o\">.</span><span class=\"nf\">encode</span><span class=\"p\">(</span><span class=\"nv\">as</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">integer</span><span class=\"p\">)</span>\n<span class=\"k\">let</span> <span class=\"nv\">exponentEncoded</span> <span class=\"o\">=</span> <span class=\"n\">exponentBytes</span><span class=\"o\">.</span><span class=\"nf\">encode</span><span class=\"p\">(</span><span class=\"nv\">as</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">integer</span><span class=\"p\">)</span>\n<span class=\"k\">let</span> <span class=\"nv\">sequenceEncoded</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">modulusEncoded</span> <span class=\"o\">+</span> <span class=\"n\">exponentEncoded</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"nf\">encode</span><span class=\"p\">(</span><span class=\"nv\">as</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">sequence</span><span class=\"p\">)</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">data</span> <span class=\"o\">=</span> <span class=\"kt\">Data</span><span class=\"p\">(</span><span class=\"nv\">bytes</span><span class=\"p\">:</span> <span class=\"n\">sequenceEncoded</span><span class=\"p\">)</span>\n</code></pre> \n </div> \n</div> \n<blockquote> \n <p>关于 DER 编码部分的代码，可以在<a href=\"https://github.com/line/line-sdk-ios-swift/blob/8c2476d9d00225cf4b33c0e245e9bd580c59f4d8/LineSDK/LineSDK/Crypto/JWK/JWA.swift#L185-L240\">这里</a>找到。对于 <code class=\"highlighter-rouge\">modulusBytes</code>，首位大于等于 <code class=\"highlighter-rouge\">0x80</code> 时需要追加 <code class=\"highlighter-rouge\">0x00</code> 的原因，也已经在<a href=\"https://onevcat.com/2018/jose-1/\">第一篇</a>中提及。如果你不知道我在说什么，建议回头仔细再看一下前两篇的内容。</p> \n</blockquote> \n<p>使用上面的 <code class=\"highlighter-rouge\">data</code> 就可以获取 RSA 的公钥了：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">sizeInBits</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"o\">*</span> <span class=\"kt\">MemoryLayout</span><span class=\"o\">&lt;</span><span class=\"kt\">UInt8</span><span class=\"o\">&gt;.</span><span class=\"n\">size</span>\n<span class=\"k\">let</span> <span class=\"nv\">attributes</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"kt\">CFString</span><span class=\"p\">:</span> <span class=\"kt\">Any</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"nv\">kSecAttrKeyType</span><span class=\"p\">:</span> <span class=\"n\">kSecAttrKeyTypeRSA</span><span class=\"p\">,</span>\n    <span class=\"nv\">kSecAttrKeyClass</span><span class=\"p\">:</span> <span class=\"n\">kSecAttrKeyClassPublic</span><span class=\"p\">,</span>\n    <span class=\"nv\">kSecAttrKeySizeInBits</span><span class=\"p\">:</span> <span class=\"kt\">NSNumber</span><span class=\"p\">(</span><span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"n\">sizeInBits</span><span class=\"p\">)</span>\n<span class=\"p\">]</span>\n<span class=\"k\">var</span> <span class=\"nv\">error</span><span class=\"p\">:</span> <span class=\"kt\">Unmanaged</span><span class=\"o\">&lt;</span><span class=\"kt\">CFError</span><span class=\"o\">&gt;</span><span class=\"p\">?</span>\n<span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">key</span> <span class=\"o\">=</span> <span class=\"kt\">SecKeyCreateWithData</span><span class=\"p\">(</span><span class=\"n\">data</span> <span class=\"k\">as</span> <span class=\"kt\">CFData</span><span class=\"p\">,</span> <span class=\"n\">attributes</span> <span class=\"k\">as</span> <span class=\"kt\">CFDictionary</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">error</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 错误处理</span>\n<span class=\"p\">}</span>\n<span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)</span>\n\n<span class=\"c1\">// 一切正常的话，打印类似这样：</span>\n<span class=\"c1\">// &lt;SecKeyRef algorithm id: 1, key type: RSAPublicKey, version: 4, </span>\n<span class=\"c1\">// block size: 1024 bits, exponent: {hex: 10001, decimal: 65537}, </span>\n<span class=\"c1\">// modulus: DD95AB518D18E8828DD6A238061C51D82EE81D516018F624..., </span>\n<span class=\"c1\">// addr: 0x6000027ffb00&gt;</span>\n</code></pre> \n </div> \n</div> \n<h4 id=\"jwa---ecsda\">JWA - ECSDA</h4> \n<p>按照说明，对于 EC 公钥，期望的数据是符合 X9.63 中未压缩的椭圆曲线点座标：<code class=\"highlighter-rouge\">04 || X || Y</code>。不过，虽然在文档说明里提及：</p> \n<blockquote> \n <p>All of these representations use constant size integers, including leading zeros as needed.</p> \n</blockquote> \n<p>但事实是 <code class=\"highlighter-rouge\">SecKeyCreateWithData</code> 并不喜欢在首位追加 <code class=\"highlighter-rouge\">0x00</code> 的做法。这里的 <code class=\"highlighter-rouge\">X</code> 和 <code class=\"highlighter-rouge\">Y</code> <strong>必须</strong>是满足椭圆曲线对应要求的密钥位数的整数值，如果在首位大于等于 <code class=\"highlighter-rouge\">0x80</code> 的值前面追加 <code class=\"highlighter-rouge\">0x00</code>，反而会导致无法创建 <code class=\"highlighter-rouge\">SecKey</code>。所以，在组织数据时，不仅不需要添加 <code class=\"highlighter-rouge\">0x00</code>，我们反而最好检查一下获取的 JWK，如果首位有不必要的 <code class=\"highlighter-rouge\">0x00</code> 的话，应该将其去除：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">extension</span> <span class=\"kt\">JWK</span> <span class=\"p\">{</span>\n    <span class=\"kd\">struct</span> <span class=\"kt\">RSA</span> <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"nv\">x</span><span class=\"p\">:</span> <span class=\"kt\">String</span>\n        <span class=\"k\">let</span> <span class=\"nv\">y</span><span class=\"p\">:</span> <span class=\"kt\">String</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">jwk</span><span class=\"p\">:</span> <span class=\"kt\">JWK</span><span class=\"o\">.</span><span class=\"kt\">RSA</span> <span class=\"o\">=</span> <span class=\"o\">...</span>\n<span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">decodedXData</span> <span class=\"o\">=</span> <span class=\"n\">jwk</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">base64URLDecoded</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"o\">...</span> <span class=\"p\">}</span>\n<span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">decodedYData</span> <span class=\"o\">=</span> <span class=\"n\">jwk</span><span class=\"o\">.</span><span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">base64URLDecoded</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"o\">...</span> <span class=\"p\">}</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">xBytes</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"kt\">UInt8</span><span class=\"p\">]</span>\n<span class=\"k\">if</span> <span class=\"n\">decodedXData</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">curve</span><span class=\"o\">.</span><span class=\"n\">coordinateOctetLength</span> <span class=\"p\">{</span>\n    <span class=\"n\">xBytes</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kt\">UInt8</span><span class=\"p\">](</span><span class=\"n\">decodedXData</span><span class=\"p\">)</span>\n<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n    <span class=\"n\">xBytes</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kt\">UInt8</span><span class=\"p\">](</span><span class=\"n\">decodedXData</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">dropFirst</span> <span class=\"p\">{</span> <span class=\"nv\">$0</span> <span class=\"o\">==</span> <span class=\"mh\">0x00</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n            \n<span class=\"k\">let</span> <span class=\"nv\">yBytes</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"kt\">UInt8</span><span class=\"p\">]</span>\n<span class=\"k\">if</span> <span class=\"n\">decodedYData</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">curve</span><span class=\"o\">.</span><span class=\"n\">coordinateOctetLength</span> <span class=\"p\">{</span>\n    <span class=\"n\">yBytes</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kt\">UInt8</span><span class=\"p\">](</span><span class=\"n\">decodedYData</span><span class=\"p\">)</span>\n<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n    <span class=\"n\">yBytes</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kt\">UInt8</span><span class=\"p\">](</span><span class=\"n\">decodedYData</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">dropFirst</span> <span class=\"p\">{</span> <span class=\"nv\">$0</span> <span class=\"o\">==</span> <span class=\"mh\">0x00</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">uncompressedIndicator</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"kt\">UInt8</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mh\">0x04</span><span class=\"p\">]</span>\n<span class=\"k\">let</span> <span class=\"nv\">data</span> <span class=\"o\">=</span> <span class=\"kt\">Data</span><span class=\"p\">(</span><span class=\"nv\">bytes</span><span class=\"p\">:</span> <span class=\"n\">uncompressedIndicator</span> <span class=\"o\">+</span> <span class=\"n\">xBytes</span> <span class=\"o\">+</span> <span class=\"n\">yBytes</span><span class=\"p\">)</span>\n</code></pre> \n </div> \n</div> \n<p>创建公钥时和 RSA 类似：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">sizeInBits</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"o\">*</span> <span class=\"kt\">MemoryLayout</span><span class=\"o\">&lt;</span><span class=\"kt\">UInt8</span><span class=\"o\">&gt;.</span><span class=\"n\">size</span>\n<span class=\"k\">let</span> <span class=\"nv\">attributes</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"kt\">CFString</span><span class=\"p\">:</span> <span class=\"kt\">Any</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"nv\">kSecAttrKeyType</span><span class=\"p\">:</span> <span class=\"n\">kSecAttrKeyTypeECSECPrimeRandom</span><span class=\"p\">,</span>\n    <span class=\"nv\">kSecAttrKeyClass</span><span class=\"p\">:</span> <span class=\"n\">kSecAttrKeyClassPublic</span><span class=\"p\">,</span>\n    <span class=\"nv\">kSecAttrKeySizeInBits</span><span class=\"p\">:</span> <span class=\"kt\">NSNumber</span><span class=\"p\">(</span><span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"n\">sizeInBits</span><span class=\"p\">)</span>\n<span class=\"p\">]</span>\n<span class=\"k\">var</span> <span class=\"nv\">error</span><span class=\"p\">:</span> <span class=\"kt\">Unmanaged</span><span class=\"o\">&lt;</span><span class=\"kt\">CFError</span><span class=\"o\">&gt;</span><span class=\"p\">?</span>\n<span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">key</span> <span class=\"o\">=</span> <span class=\"kt\">SecKeyCreateWithData</span><span class=\"p\">(</span><span class=\"n\">data</span> <span class=\"k\">as</span> <span class=\"kt\">CFData</span><span class=\"p\">,</span> <span class=\"n\">attributes</span> <span class=\"k\">as</span> <span class=\"kt\">CFDictionary</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">error</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 错误处理</span>\n<span class=\"p\">}</span>\n<span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)</span>\n\n<span class=\"c1\">// 一切正常的话，打印类似这样：</span>\n<span class=\"c1\">// &lt;SecKeyRef curve type: kSecECCurveSecp256r1, algorithm id: 3, </span>\n<span class=\"c1\">// key type: ECPublicKey, version: 4, block size: 256 bits, </span>\n<span class=\"c1\">// y: 3D4F8B27B29E5C77FCF877367245F3D75C2FBA806C54A0A0C05807E1B536E68A, </span>\n<span class=\"c1\">// x: FFB00CF903B79BB0F6C049208A59C448049BE0A2A1AF4692C486085CBD9057EF, </span>\n<span class=\"c1\">// addr: 0x7fcafd80ced0&gt;</span>\n</code></pre> \n </div> \n</div> \n<h3 id=\"验证签名\">验证签名</h3> \n<p>Security 框架中为使用公钥进行签名验证准备了一个方法：<a href=\"https://developer.apple.com/documentation/security/1643715-seckeyverifysignature\"><code class=\"highlighter-rouge\">SecKeyVerifySignature</code></a>：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"kt\">SecKeyVerifySignature</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">key</span><span class=\"p\">:</span> <span class=\"kt\">SecKey</span><span class=\"p\">,</span> \n                         <span class=\"n\">_</span> <span class=\"nv\">algorithm</span><span class=\"p\">:</span> <span class=\"kt\">SecKeyAlgorithm</span><span class=\"p\">,</span> \n                         <span class=\"n\">_</span> <span class=\"nv\">signedData</span><span class=\"p\">:</span> <span class=\"kt\">CFData</span><span class=\"p\">,</span> \n                         <span class=\"n\">_</span> <span class=\"nv\">signature</span><span class=\"p\">:</span> <span class=\"kt\">CFData</span><span class=\"p\">,</span> \n                         <span class=\"n\">_</span> <span class=\"nv\">error</span><span class=\"p\">:</span> <span class=\"kt\">UnsafeMutablePointer</span><span class=\"o\">&lt;</span><span class=\"kt\">Unmanaged</span><span class=\"o\">&lt;</span><span class=\"kt\">CFError</span><span class=\"o\">&gt;</span><span class=\"p\">?</span><span class=\"o\">&gt;</span><span class=\"p\">?)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Bool</span>\n</code></pre> \n </div> \n</div> \n<p><code class=\"highlighter-rouge\">key</code> 我们已经拿到了，<code class=\"highlighter-rouge\">signedData</code> 就是之前我们准备的 <code class=\"highlighter-rouge\">{Header}.{Payload}</code> 的字符串的数据表示 (也就是 <code class=\"highlighter-rouge\">plainText.data(using: .ascii)</code>。注意，这里的 <code class=\"highlighter-rouge\">plainText</code> 不是一个 Base64Url 字符串，JWS 签名所针对的就是这个拼凑后的字符串的散列值)。我们需要为不同的签名算法指定合适的 <code class=\"highlighter-rouge\">SecKeyAlgorithm</code>，通过访问 <code class=\"highlighter-rouge\">SecKeyAlgorithm</code> 的静态成员，就可以获取 Security 框架预先定义的算法了。比如常用的：</p> \n<div class=\"highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code>let ecdsa256 = SecKeyAlgorithm.ecdsaSignatureMessageX962SHA256\nlet rsa256 = SecKeyAlgorithm.rsaSignatureDigestPKCS1v15SHA256\n</code></pre> \n </div> \n</div> \n<p>你可以在 Apple 的<a href=\"https://developer.apple.com/documentation/security/seckeyalgorithm\">文档里</a>找到所有支持的算法的定义，但是不幸的是，这些算法都只有名字，没有具体说明，也没有使用范例。想要具体知道某个算法的用法，可能需要在<a href=\"https://opensource.apple.com/source/Security/Security-57740.51.3/keychain/SecKey.h\">源码级别</a>去参考注释。为了方便，对于签名验证相关的一些常用算法，我列了一个表说明对应关系：</p> \n<table> \n <thead> \n  <tr> \n   <th>算法</th> \n   <th>输入数据 (signedData)</th> \n   <th>签名 (signature)</th> \n   <th>对应 JWT 算法</th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td>rsaSignatureDigestPKCS1v15SHA{x}</td> \n   <td>原数据的 SHA-x 摘要</td> \n   <td>PKCS#1 v1.5 padding 的签名</td> \n   <td>RS{x}</td> \n  </tr> \n  <tr> \n   <td>rsaSignatureMessagePKCS1v15SHA{x}</td> \n   <td>原数据本身，框架负责计算 SHA-x 摘要</td> \n   <td>PKCS#1 v1.5 padding 的签名</td> \n   <td>RS{x}</td> \n  </tr> \n  <tr> \n   <td>rsaSignatureDigestPSSSHA{x}</td> \n   <td>原数据的 SHA-x 摘要</td> \n   <td>使用 PSS 的 PKCS#1 v2.1 签名</td> \n   <td>PS{x}</td> \n  </tr> \n  <tr> \n   <td>rsaSignatureMessagePSSSHA{x}</td> \n   <td>原数据本身，框架负责计算 SHA-x 摘要</td> \n   <td>使用 PSS 的 PKCS#1 v2.1 签名</td> \n   <td>PS{x}</td> \n  </tr> \n  <tr> \n   <td>ecdsaSignatureDigestX962SHA{x}</td> \n   <td>原数据的 SHA-x 摘要</td> \n   <td>DER x9.62 编码的 r 和 s</td> \n   <td>ES{x}</td> \n  </tr> \n  <tr> \n   <td>ecdsaSignatureMessageX962SHA{x}</td> \n   <td>原数据本身，框架负责计算 SHA-x 摘要</td> \n   <td>DER x9.62 编码的 r 和 s</td> \n   <td>ES{x}</td> \n  </tr> \n </tbody> \n</table> \n<p>不难看出，这些签名算法基本就是 <code class=\"highlighter-rouge\">{算法类型} + {数据处理方式} + {签名格式}</code> 的组合。另外还有一些更为泛用的签名算法，像是 <code class=\"highlighter-rouge\">.ecdsaSignatureRFC4754</code> 或者 <code class=\"highlighter-rouge\">.rsaSignatureRaw</code>，你需要按照源码注释给入合适的输入，不过一般来说还是直接使用预设的散列的 <code class=\"highlighter-rouge\">__Message__SHA___</code> 这类算法最为方便。</p> \n<blockquote> \n <p><code class=\"highlighter-rouge\">SecKeyAlgorithm</code> 中除了签名算法，也包括了使用 RSA 和 EC 进行加密的相关算法。整体上和签名算法的命名方式类似，有兴趣和需要相关内容的同学可以自行研究。</p> \n</blockquote> \n<p>对于 JWT 来说，RS 算法的签名已经是 PKCS#1 v1.5 padding 的了，所以直接将 <code class=\"highlighter-rouge\">signedData</code> 和 <code class=\"highlighter-rouge\">signature</code> 配合使用 <code class=\"highlighter-rouge\">rsaSignatureMessagePKCS1v15SHA{x}</code> 就可以完成验证。</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"k\">var</span> <span class=\"nv\">error</span><span class=\"p\">:</span> <span class=\"kt\">Unmanaged</span><span class=\"o\">&lt;</span><span class=\"kt\">CFError</span><span class=\"o\">&gt;</span><span class=\"p\">?</span>\n<span class=\"k\">let</span> <span class=\"nv\">result</span> <span class=\"o\">=</span> <span class=\"kt\">SecKeyVerifySignature</span><span class=\"p\">(</span>\n    <span class=\"n\">key</span><span class=\"p\">,</span> \n    <span class=\"o\">.</span><span class=\"n\">rsaSignatureMessagePKCS1v15SHA256</span><span class=\"p\">,</span> \n    <span class=\"n\">signedData</span> <span class=\"k\">as</span> <span class=\"kt\">CFData</span><span class=\"p\">,</span> \n    <span class=\"n\">signature</span> <span class=\"k\">as</span> <span class=\"kt\">CFData</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">error</span><span class=\"p\">)</span>\n</code></pre> \n </div> \n</div> \n<p>对于 ES 的 JWT 来说，事情要麻烦一些。我们收到的 JWT 里的签名只是 {r, s} 的简单连接，所以需要预先进行处理。按照 X9.62 中对 <code class=\"highlighter-rouge\">signature</code> 的编码定义：</p> \n<div class=\"highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code>ECDSA-Sig-Value ::= SEQUENCE {\n    r INTEGER,\n    s INTEGER }\n</code></pre> \n </div> \n</div> \n<p>因此，在调用 <code class=\"highlighter-rouge\">SecKeyVerifySignature</code> 之前，先处理签名：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">count</span> <span class=\"o\">=</span> <span class=\"n\">signature</span><span class=\"o\">.</span><span class=\"n\">count</span>\n<span class=\"k\">guard</span> <span class=\"n\">count</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">count</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 错误，签名应该是两个等长的整数</span>\n<span class=\"p\">}</span>\n<span class=\"k\">var</span> <span class=\"nv\">rBytes</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kt\">UInt8</span><span class=\"p\">](</span><span class=\"n\">signature</span><span class=\"p\">[</span><span class=\"o\">..&lt;</span><span class=\"p\">(</span><span class=\"n\">count</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">)])</span>\n<span class=\"k\">var</span> <span class=\"nv\">sBytes</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kt\">UInt8</span><span class=\"p\">](</span><span class=\"n\">signature</span><span class=\"p\">[(</span><span class=\"n\">count</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">...</span><span class=\"p\">])</span>\n\n<span class=\"c1\">// 处理首位，我们已经做过很多次了。</span>\n<span class=\"k\">if</span> <span class=\"n\">rBytes</span><span class=\"o\">.</span><span class=\"n\">first</span><span class=\"o\">!</span> <span class=\"o\">&gt;=</span> <span class=\"kt\">UInt8</span><span class=\"p\">(</span><span class=\"mh\">0x80</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">rBytes</span><span class=\"o\">.</span><span class=\"nf\">insert</span><span class=\"p\">(</span><span class=\"mh\">0x00</span><span class=\"p\">,</span> <span class=\"nv\">at</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">if</span> <span class=\"n\">sBytes</span><span class=\"o\">.</span><span class=\"n\">first</span><span class=\"o\">!</span> <span class=\"o\">&gt;=</span> <span class=\"kt\">UInt8</span><span class=\"p\">(</span><span class=\"mh\">0x80</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">sBytes</span><span class=\"o\">.</span><span class=\"nf\">insert</span><span class=\"p\">(</span><span class=\"mh\">0x00</span><span class=\"p\">,</span> <span class=\"nv\">at</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 完成签名的 DER 编码</span>\n<span class=\"k\">let</span> <span class=\"nv\">processedSignature</span> <span class=\"o\">=</span> <span class=\"kt\">Data</span><span class=\"p\">(</span><span class=\"nv\">bytes</span><span class=\"p\">:</span> \n    <span class=\"p\">(</span><span class=\"n\">rBytes</span><span class=\"o\">.</span><span class=\"nf\">encode</span><span class=\"p\">(</span><span class=\"nv\">as</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">integer</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">sBytes</span><span class=\"o\">.</span><span class=\"nf\">encode</span><span class=\"p\">(</span><span class=\"nv\">as</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">integer</span><span class=\"p\">))</span>\n    <span class=\"o\">.</span><span class=\"nf\">encode</span><span class=\"p\">(</span><span class=\"nv\">as</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">sequence</span><span class=\"p\">))</span>\n\n<span class=\"k\">var</span> <span class=\"nv\">error</span><span class=\"p\">:</span> <span class=\"kt\">Unmanaged</span><span class=\"o\">&lt;</span><span class=\"kt\">CFError</span><span class=\"o\">&gt;</span><span class=\"p\">?</span>\n<span class=\"k\">let</span> <span class=\"nv\">result</span> <span class=\"o\">=</span> <span class=\"kt\">SecKeyVerifySignature</span><span class=\"p\">(</span>\n    <span class=\"n\">key</span><span class=\"p\">,</span> \n    <span class=\"o\">.</span><span class=\"n\">ecdsaSignatureMessageX962SHA256</span><span class=\"p\">,</span> \n    <span class=\"n\">signedData</span> <span class=\"k\">as</span> <span class=\"kt\">CFData</span><span class=\"p\">,</span> \n    <span class=\"n\">processedSignature</span> <span class=\"k\">as</span> <span class=\"kt\">CFData</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">error</span><span class=\"p\">)</span>\n</code></pre> \n </div> \n</div> \n<blockquote> \n <p>上面 RSA 和 ECDSA 的验证，都假设了使用 SHA-256 作为散列算法。如果你采用的是其他的散列算法，记得替换。</p> \n</blockquote> \n<h3 id=\"验证-payload-内容\">验证 Payload 内容</h3> \n<p>签名正确完成验证之后，我们就可以对 JWT Payload 里的内容进行验证了：包括但不限于 “iss”，”sub”，”exp”，”iat” 这些保留值是否正确。当签名和内容都验证无误后，就可以安心使用这个 JWT 了。</p> \n<h2 id=\"一些问题\">一些问题</h2> \n<p>至此，我们从最初的 JWT 定义开始，引伸出 JWA，JWK 等一系列 JOSE 概念。然后我们研究了互联网安全领域的通用编码方式和几种最常见的密钥的构成。最后，我们使用这些知识在 Security 框架的帮助下，完成了 JWT 的签名验证的整个流程。</p> \n<p>事后看上去没有太大难度，但是由于涉及到的名词概念很多，相关标准错综复杂，因此初上手想要把全盘都弄明白，还是会有一定困难。希望这系列文章能够帮助你在起步阶段就建立相对清晰的知识体系，这样在阅读其他的相关信息时，可以对新的知识进行更好的分类整理。</p> \n<p>最后，是一些我自己在学习和实践中的考虑。在此一并列出，以供参考。如果您有什么指正和补充，也欢迎留言评论。</p> \n<h4 id=\"为什么不用已有的相关开源框架\">为什么不用已有的相关开源框架</h4> \n<p>现存的和这个主题相关的 iOS 或者 Swift 框架有一些，比如 <a href=\"https://github.com/airsidemobile/JOSESwift\">JOSESwift</a>，<a href=\"https://github.com/kylef/JSONWebToken.swift\">JSONWebToken.swift</a>，<a href=\"https://github.com/IBM-Swift/Swift-JWT\">Swift-JWT</a>，<a href=\"https://github.com/vapor/jwt\">vaper/jwt</a> 等等。来回比较考察，它们现在 (2018 年 12 月) 或多或少存在下面的不足：</p> \n<ul> \n <li>没有一个从 JWK 开始到 JWT 的完整方案。JWT 相关的框架基本都是从本地证书获取公钥进行验证，而我需要从 JWK 获取证书</li> \n <li>支持 JWK 的框架只实现了部分算法，比如只有 RSA，没有 ECDSA 支持。</li> \n <li>一些框架依赖关系太复杂，而且大部分实现是面向 Swift Server Side，而非 iOS 的。</li> \n</ul> \n<p>在 <a href=\"https://github.com/line/line-sdk-ios-swift\">LINE SDK</a> 中，我们需要，且只需要在 iOS 上利用 Security 框架完成验证。同时 Server 可能会变更配置，所以我们需要同时支持 RSA 和 ECDSA (当前默认使用 ECDSA)。另外，本身作为一个提供给第三方开发者的 SDK，我们不允许引入不可靠的复杂依赖关系 (最理想的情况是零依赖，也就是 LINE SDK 的现状)。基于这些原因，我没有使用现有的开源代码，而是自己从头进行实现。</p> \n<h4 id=\"为什么不把你做的相关内容整理开源\">为什么不把你做的相关内容整理开源</h4> \n<p>在 LINE SDK 中的方案是不完备的，它是 JOSE 中满足我们的 JWT 解析和验证需求的最小子集，因此没有很高的泛用性，不适合作为单独项目开源。不过因为 LINE SDK 整个项目是开源的，JOSE 部分的代码其实也都是公开且相对独立的。如果你感兴趣，可以在 LINE SDK 的 <a href=\"https://github.com/line/line-sdk-ios-swift/tree/master/LineSDK/LineSDK/Crypto\">Crypto 文件夹</a>下找到所有相关代码。</p> \n<h4 id=\"为什么要用非对称算法各算法之间有什么优劣\">为什么要用非对称算法，各算法之间有什么优劣</h4> \n<p>不少 JWT 使用 HS 的算法 (HMAC)。和 RSA 或 ECDSA 不同，HMAC 是对称加密算法。对称算法加密和解密比较简单，因为密钥相同，所以比较适合用在 Server to Server 这种双方可信的场合。如果在客户端上使用对称算法，那就需要将这个密钥存放在客户端上，这显然是不可接受的。对于 Client - Server 的通讯，非对称算法应该是毋庸置疑的选择。</p> \n<p>相比与 RSA，ECDSA 可以使用更短的密钥实现和数倍长于自己的 RSA 相同的安全性能。</p> \n<blockquote> \n <p>For example, at a security level of 80 bits (meaning an attacker requires a maximum of about 2^80 operations to find the private key) the size of an ECDSA public key would be 160 bits, whereas the size of a DSA public key is at least 1024 bits.</p> \n</blockquote> \n<p>由于 ECDSA 是专用的 DSA 算法，只能用于签名，而不能用作加密和密钥交换，所以它比 RSA 要快很多。另外，更小的密钥也带来了更小的计算量。这些特性对于减少 Server 负担非常重要。关于 ECDSA 的优势和它相对于 RSA 的对比，可以参考 Cloudflare 的<a href=\"https://blog.cloudflare.com/ecdsa-the-digital-signature-algorithm-of-a-better-internet/\">这篇文章</a>。</p> \n<h4 id=\"签名的安全性\">签名的安全性</h4> \n<p>JWT 签名的伪造一直是一个困扰人的问题。因为 JWT 的 Header 和 Payload 内容一旦确定的话，它的签名也就确定了 (虽然 ECDSA 会产生随机数使签名每次都不同，但是这些签名都可以通过验证)。这带来一个问题，攻击者可以通过截取以前的有效的 JWT，然后把它作为新的响应发给用户。这类 JWT 依然可以正确通过签名验证。</p> \n<p>因此，我们必须每次生成不同的 JWT，来防止这种替换攻击。最简单的方式就是在内存中存储随机值，发送 JWT 请求时附带这个随机值，然后 Server 将这个随机值嵌入在返回的 JWT 的 Payload 中。Client 收到后，再与内存中保存的值进行比对。这样保证了每次返回的 JWT 都不相同，让签名验证更加安全。</p> \n<h4 id=\"openssl-版本的问题\">OpenSSL 版本的问题</h4> \n<p>macOS 上自带的 OpenSSL 版本一般比较旧，而大部分 Linux 系统的 OpenSSL 更新一些。不同版本的 OpenSSL (或者其他的常用安全框架) 实现细节上会有差异，比如有些版本会在负数首位补 <code class=\"highlighter-rouge\">0x00</code> 等。在测试时，最好让 Server 的小伙伴确认一下使用的 OpenSSL 版本，这样能在验证和使用密钥上避免一些不必要的麻烦。(请不要问我细节！都是泪)</p> \n<h4 id=\"jwt-可以用来做什么应该用来做什么\">JWT 可以用来做什么，应该用来做什么</h4> \n<p>JWT 最常见的使用场景有两个：</p> \n<ul> \n <li><strong>授权</strong>：用户登录后，在后续的请求中带上一个有效的 JWT，其中包含该用户可以访问的路径或权限等。服务器验证 JWT 有效性后对访问进行授权。相比于传统像是 OAuth 的 token 来说，服务器并不需要存储这些 token，可以实现无状态的授权，因此它的开销较小，也更容易实现和理解。另外，由于 JWT 不需要依赖 Cookie 的特性，跨站或者跨服务依然可能使用，这让单点登录非常简单。</li> \n <li><strong>信息交换</strong>：LINE SDK 中对用户信息进行签名和验证，就属于信息交换的范畴。依赖 JWT 的签名特性，接收方可以确保 JWT 中的内容没有被篡改，是一种安全的信息交换方式。</li> \n</ul> \n<p>最近有非常多的关于反对使用 JWT 进行授权的声音，比如<a href=\"http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/\">这篇文章</a>和<a href=\"https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid\">这篇文章</a>。JWT 作为授权 token 来使用，最大的问题在于无法过期或者作废，另外，一些严格遵守标准的实现，反而可能<a href=\"https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/\">引入严重的安全问题</a>。</p> \n<p>不过对于第二种用法，也就是信息交换来说，JWT 所提供的便捷和安全性是无人质疑的。</p> \n<h4 id=\"我也想读读看相关标准\">我也想读读看相关标准</h4> \n<p>如你所愿，我整理了一下涉及到的标准。祝武运昌隆！</p> \n<h5 id=\"关于编码和算法\">关于编码和算法</h5> \n<ul> \n <li><a href=\"https://www.itu.int/ITU-T/studygroups/com17/languages/X.680-0207.pdf\">X.680 - ASN.1 的标准和基本标注方式</a>：ASN.1 是这套方法的名字，而对应的标准号是 X.680。</li> \n <li><a href=\"https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf\">X.690 - DER 编码规则</a>：也包括了其他的，比如 BER 和 CER 的编码规则。</li> \n <li><a href=\"https://tools.ietf.org/html/rfc3279\">RFC 3279 - 关于 X.509 如何编码密钥和签名</a>：在 X.509 应用层面上密钥以及签名的构成。</li> \n <li><a href=\"http://www.secg.org/sec2-v2.pdf\">SEC 2 - 关于椭圆曲线算法参数</a>：ECDSA 的各种 OIDs 定义和椭圆曲线 G 值的表示方式。</li> \n <li><a href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.202.2977&amp;rep=rep1&amp;type=pdf\">X9.62 - 椭圆曲线的应用和相关编码方式</a>：描述了 ECDSA 算法和密钥的表示方式。它在 SEC 2 的基础上添加了关于曲线点 (也就是实际的密钥本身) 的定义。</li> \n <li><a href=\"https://tools.ietf.org/html/rfc5480\">RFC 5480 - 椭圆曲线公钥的信息</a>：EC 公钥的定义，表示方式，使用曲线和对应的密钥位数及散列算法的关系。</li> \n <li><a href=\"https://tools.ietf.org/html/rfc8017\">RFC 8017 - RSA 算法相关的标准</a>：包括像是 RSA key 的 ASN.1 定义，所注册的 OIDs 。</li> \n</ul> \n<h5 id=\"关于-jose\">关于 JOSE</h5> \n<ul> \n <li><a href=\"https://tools.ietf.org/html/rfc7515\">RFC 7515 - JSON Web Signature (JWS)</a></li> \n <li><a href=\"https://tools.ietf.org/html/rfc7516\">RFC 7516 - JSON Web Encryption (JWE)</a></li> \n <li><a href=\"https://tools.ietf.org/html/rfc7517\">RFC 7517 - JSON Web Key (JWK)</a></li> \n <li><a href=\"https://tools.ietf.org/html/rfc7518\">RFC 7518 - JSON Web Algorithms (JWA)</a></li> \n <li><a href=\"https://tools.ietf.org/html/rfc7519\">RFC 7519 - JSON Web Token (JWT)</a></li> \n <li><a href=\"https://tools.ietf.org/html/rfc7165\">RFC 7165 - JOSE 的使用例子和要求</a></li> \n</ul> \n<h5 id=\"杂项\">杂项</h5> \n<ul> \n <li><a href=\"https://tools.ietf.org/html/rfc4648\">RFC 4648 - 关于 Base64Url 的编码规则</a>：JOSE 中的数据都是使用 Base64Url 进行编码的。</li> \n <li><a href=\"https://openid.net/specs/openid-connect-discovery-1_0.html\">OpenID Connect Discovery</a>：OpenID 相关的 profile 取得方式，以及其中键值对的定义。关于 Discovery Document 的更好的说明，可以参考 <a href=\"https://developers.google.com/identity/protocols/OpenIDConnect#discovery\">Google 的这个指南</a>。</li> \n</ul> \n<h4 id=\"验证和速查工具汇总\">验证和速查工具汇总</h4> \n<ul> \n <li><a href=\"https://holtstrom.com/michael/tools/asn1decoder.php\">ASN.1 解码器</a>：将一段 DER 数据解码为可读的 ASN.1 表示。</li> \n <li><a href=\"https://cryptii.com/pipes/base64-to-hex\">数据格式转换</a>：将数据在 Base64、文本和字节表示之间进行任意转换。</li> \n <li><a href=\"https://www.alvestrand.no/objectid/top.html\">ASN.1 中的 OIDs 转换</a>：帮助解码和编码 OBJECT IDENTIFIER 值。</li> \n <li><a href=\"https://8gwifi.org/jwkconvertfunctions.jsp\">JWK 和 PEM 相互转换</a>：将 JWK 或者 PEM 的密钥相互转换的工具。</li> \n</ul> \n<h4 id=\"你的这篇文章或者代码好像有问题\">你的这篇文章或者代码好像有问题！</h4> \n<p>我是初学者，文章中的纰漏请不吝赐教指出！</p> \n<p>关于代码方面的不足，<a href=\"https://github.com/line/line-sdk-ios-swift\">LINE SDK</a> 欢迎各种 PR。但是如果您发现的问题涉及安全漏洞，或者会导致比较严重后果的话，还请<strong>先不要公开公布</strong>。如果能按照<a href=\"https://github.com/line/line-sdk-ios-swift/blob/master/.github/ISSUE_TEMPLATE.md\">这里的说明</a>给我们发送邮件联系的话，实在感激不尽。</p>","descriptionType":"text/html","publishedDate":"Fri, 07 Dec 2018 01:28:00 +0000","feedId":3176,"bgimg":"https://onevcat.com/assets/images/2018/matrix.jpg","linkMd5":"cee620a1f3451cdfc9b2722c018d3754","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx/cdn15@2020_6/2020/08/24/21-24-59-104_9d4efca24d46f79d.webp","destWidth":1024,"destHeight":500,"sourceBytes":86506,"destBytes":45088,"author":"","articleImgCdnMap":{"https://onevcat.com/assets/images/2018/matrix.jpg":"https://cdn.jsdelivr.net/gh/myreaderx/cdn15@2020_6/2020/08/24/21-24-59-104_9d4efca24d46f79d.webp"},"publishedOrCreatedDate":1598304289192},{"createdTime":"2020-08-25 05:24:49","updatedTime":"2020-08-25 05:24:49","title":"@StateObject 和 @ObservedObject 的区别和使用","link":"https://onevcat.com/2020/06/stateobject/","description":"<blockquote> \n <p>WWDC 2020 中，SwiftUI 迎来了非常多的变更。相比于 2019 年的初版，可以说 SwiftUI 达到了一个相对可用的状态。从这篇文章开始，我打算写几篇文章来介绍一些重要的变化和新追加的内容。如果你需要 SwiftUI 的入门和基本概念的材料，我参与的两本书籍<a href=\"https://objccn.io/products/swift-ui\">《SwiftUI 与 Combine 编程》</a>和<a href=\"https://objccn.io/products/thinking-in-swiftui\">《SwiftUI 编程思想》</a>依然会是很好的选择。</p> \n</blockquote> \n<h3 id=\"字太多不想看长求总\">字太多，不想看，长求总</h3> \n<p><code class=\"highlighter-rouge\">@ObservedObject</code> 不管存储，会随着 <code class=\"highlighter-rouge\">View</code> 的创建被多次创建。而 <code class=\"highlighter-rouge\">@StateObject</code> 保证对象只会被创建一次。因此，如果是在 <code class=\"highlighter-rouge\">View</code> 里自行创建的 <code class=\"highlighter-rouge\">ObservableObject</code> model 对象，大概率来说使用 <code class=\"highlighter-rouge\">@StateObject</code> 会是更正确的选择。<code class=\"highlighter-rouge\">@StateObject</code> 基本上来说就是一个针对 class 的 <code class=\"highlighter-rouge\">@State</code> 升级版。</p> \n<p>如果你对详细内容感兴趣，想知道整个故事的始末，可以继续阅读。</p> \n<h3 id=\"初版-swiftui-的状态管理\">初版 SwiftUI 的状态管理</h3> \n<p>在 2019 年 SwiftUI 刚问世时，除去专门用来管理手势的 <code class=\"highlighter-rouge\">@GestureState</code> 以外，有三个常用的和状态管理相关的 property wrapper，它们分别是 <code class=\"highlighter-rouge\">@State</code>，<code class=\"highlighter-rouge\">@ObservedObject</code> 和 <code class=\"highlighter-rouge\">@EnvironmentObject</code>。根据职责和作用范围不同，它们各自的适用场景也有区别。一般来说：</p> \n<ul> \n <li><code class=\"highlighter-rouge\">@State</code> 用于 <code class=\"highlighter-rouge\">View</code> 中的私有状态值，一般来说它所修饰的都应该是 struct 值，并且不应该被其他的 view 看到。它代表了 SwiftUI 中作用范围最小，本身也最简单的状态，比如一个 <code class=\"highlighter-rouge\">Bool</code>，一个 <code class=\"highlighter-rouge\">Int</code> 或者一个 <code class=\"highlighter-rouge\">String</code>。简单说，如果一个状态能够被标记为 <code class=\"highlighter-rouge\">private</code> 并且它是值类型，那么 <code class=\"highlighter-rouge\">@State</code> 是适合的。</li> \n <li>对于更复杂的一组状态，我们可以将它组织在一个 class 中，并让其实现 <code class=\"highlighter-rouge\">ObservableObject</code> 协议。对于这样的 class 类型，其中被标记为 <code class=\"highlighter-rouge\">@Published</code> 的属性，将会在变更时自动发出事件，通知对它有依赖的 <code class=\"highlighter-rouge\">View</code> 进行更新。<code class=\"highlighter-rouge\">View</code> 中如果需要依赖这样的 <code class=\"highlighter-rouge\">ObservableObject</code> 对象，在声明时则使用 <code class=\"highlighter-rouge\">@ObservedObject</code> 来订阅。</li> \n <li><code class=\"highlighter-rouge\">@EnvironmentObject</code> 针对那些需要传递到深层次的子 <code class=\"highlighter-rouge\">View</code> 中的 <code class=\"highlighter-rouge\">ObservableObject</code> 对象，我们可以在父层级的 <code class=\"highlighter-rouge\">View</code> 上用 <code class=\"highlighter-rouge\">.environmentObject</code> 修饰器来将它注入到环境中，这样任意子 <code class=\"highlighter-rouge\">View</code> 都可以通过 <code class=\"highlighter-rouge\">@EnvironmentObject</code> 来获取对应的对象。</li> \n</ul> \n<p>这基本就是初版 SwiftUI 状态管理的全部了。</p> \n<p><img src=\"https://onevcat.com/assets/images/2020/48b8f3b0ed887f90b8d420b137fb3689.jpg\" alt=\"\" /></p> \n<p>看起来对于状态管理，SwiftUI 的覆盖已经很全面了，那为什么要新加一个 <code class=\"highlighter-rouge\">@StateObject</code> property wrapper 呢？为了弄清这个问题，我们先要来看看 <code class=\"highlighter-rouge\">@ObservedObject</code> 存在的问题。</p> \n<h3 id=\"observedobject-有什么问题\">@ObservedObject 有什么问题</h3> \n<p>我们来考虑实现下面这样的界面：</p> \n<p><img src=\"https://onevcat.com/assets/images/2020/stateobject_app.png\" alt=\"\" /></p> \n<p>点击“Toggle Name”时，Current User 在真实名字和昵称之间转换。点击 “+1” 时，无条件为这个 <code class=\"highlighter-rouge\">View</code> <del>续一秒</del> 显示的 Score 增加 1。</p> \n<p>来看看下面的代码，算上空行也就五十行不到：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"kt\">ContentView</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"kd\">@State</span> <span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">showRealName</span> <span class=\"o\">=</span> <span class=\"kc\">false</span>\n    <span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n        <span class=\"kt\">VStack</span> <span class=\"p\">{</span>\n            <span class=\"kt\">Button</span><span class=\"p\">(</span><span class=\"s\">\"Toggle Name\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"n\">showRealName</span><span class=\"o\">.</span><span class=\"nf\">toggle</span><span class=\"p\">()</span>\n            <span class=\"p\">}</span>\n            <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Current User: </span><span class=\"se\">\\(</span><span class=\"n\">showRealName</span> <span class=\"p\">?</span> <span class=\"s\">\"Wei Wang\"</span> <span class=\"p\">:</span> <span class=\"s\">\"onevcat\"</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n            <span class=\"kt\">ScorePlate</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"nf\">padding</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">top</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"kt\">Model</span><span class=\"p\">:</span> <span class=\"kt\">ObservableObject</span> <span class=\"p\">{</span>\n    <span class=\"nf\">init</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Model Created\"</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n    <span class=\"kd\">@Published</span> <span class=\"k\">var</span> <span class=\"nv\">score</span><span class=\"p\">:</span> <span class=\"kt\">Int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">struct</span> <span class=\"kt\">ScorePlate</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n\n    <span class=\"kd\">@ObservedObject</span> <span class=\"k\">var</span> <span class=\"nv\">model</span> <span class=\"o\">=</span> <span class=\"kt\">Model</span><span class=\"p\">()</span>\n    <span class=\"kd\">@State</span> <span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">niceScore</span> <span class=\"o\">=</span> <span class=\"kc\">false</span>\n\n    <span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n        <span class=\"kt\">VStack</span> <span class=\"p\">{</span>\n            <span class=\"kt\">Button</span><span class=\"p\">(</span><span class=\"s\">\"+1\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"k\">if</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">score</span> <span class=\"o\">&gt;</span> <span class=\"mi\">3</span> <span class=\"p\">{</span>\n                    <span class=\"n\">niceScore</span> <span class=\"o\">=</span> <span class=\"kc\">true</span>\n                <span class=\"p\">}</span>\n                <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">score</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"p\">}</span>\n            <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Score: </span><span class=\"se\">\\(</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">score</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n            <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Nice? </span><span class=\"se\">\\(</span><span class=\"n\">niceScore</span> <span class=\"p\">?</span> <span class=\"s\">\"YES\"</span> <span class=\"p\">:</span> <span class=\"s\">\"NO\"</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n            <span class=\"kt\">ScoreText</span><span class=\"p\">(</span><span class=\"nv\">model</span><span class=\"p\">:</span> <span class=\"n\">model</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"nf\">padding</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">top</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">struct</span> <span class=\"kt\">ScoreText</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"kd\">@ObservedObject</span> <span class=\"k\">var</span> <span class=\"nv\">model</span><span class=\"p\">:</span> <span class=\"kt\">Model</span>\n\n    <span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">score</span> <span class=\"o\">&gt;</span> <span class=\"mi\">10</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Fantastic\"</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">score</span> <span class=\"o\">&gt;</span> <span class=\"mi\">3</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Good\"</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Ummmm...\"</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>简单解释一下行为：</p> \n<p>对于 Toggle Name 按钮和 Current User 标签，直接写在了 <code class=\"highlighter-rouge\">ContentView</code> 中。+1 按钮和显示分数以及分数状态的部分，则被封装到一个叫 <code class=\"highlighter-rouge\">ScorePlate</code> 的 <code class=\"highlighter-rouge\">View</code> 里。它需要一个模型来记录分数，也就是 <code class=\"highlighter-rouge\">Model</code>。在 <code class=\"highlighter-rouge\">ScorePlate</code> 中，我们将它声明为了一个 <code class=\"highlighter-rouge\">@ObservedObject</code> 变量：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"kt\">ScorePlate</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"kd\">@ObservedObject</span> <span class=\"k\">var</span> <span class=\"nv\">model</span> <span class=\"o\">=</span> <span class=\"kt\">Model</span><span class=\"p\">()</span>\n    <span class=\"c1\">//...</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>除了 <code class=\"highlighter-rouge\">Model</code> 外，我们还在 <code class=\"highlighter-rouge\">ScorePlate</code> 里添加了另一个私有的布尔状态 <code class=\"highlighter-rouge\">@State niceScore</code>。每次 +1 时，除了让 <code class=\"highlighter-rouge\">model.score</code> 增加外，还检查了它是否大于三，并且依此设置 <code class=\"highlighter-rouge\">niceScore</code>。我们可以用它来考察 <code class=\"highlighter-rouge\">@State</code> 和 <code class=\"highlighter-rouge\">@ObservedObject</code> 行为上的不同。</p> \n<p>最后，最下面一行是另外一个 <code class=\"highlighter-rouge\">View</code>：<code class=\"highlighter-rouge\">ScoreText</code>。它也含有一个 <code class=\"highlighter-rouge\">@ObservedObject</code> 的 <code class=\"highlighter-rouge\">Model</code>，并根据 score 值来决定要显示的文本内容。这个 <code class=\"highlighter-rouge\">model</code> 会在初始化时传入：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"kt\">ScorePlate</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// ...</span>\n        <span class=\"kt\">ScoreText</span><span class=\"p\">(</span><span class=\"nv\">model</span><span class=\"p\">:</span> <span class=\"n\">model</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"nf\">padding</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">top</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<blockquote> \n <p>当然，在这个例子中，其实使用一个简单的 <code class=\"highlighter-rouge\">@State</code> 的 <code class=\"highlighter-rouge\">Int</code> 值就够了，但是为了说明问题，还是生造了一个 <code class=\"highlighter-rouge\">Model</code> 这把牛刀来杀鸡。实际项目中 <code class=\"highlighter-rouge\">Model</code> 肯定是会比一个 <code class=\"highlighter-rouge\">Int</code> 要来得更复杂。</p> \n</blockquote> \n<p>当我们尝试运行的时候，“+1” 按钮可以完美工作，“Nice” 和 “Ummmm…” 文本也能够按照预期改变，一切都很完美…直到我们想要用 “Toggle Name” 改变一下名字：</p> \n<p><img src=\"https://onevcat.com/assets/images/2020/stateobject_reset.gif\" alt=\"\" /></p> \n<p>除了 (被 <code class=\"highlighter-rouge\">@State</code> 驱动的) Nice 标签，<code class=\"highlighter-rouge\">ScorePlate</code> 的其他文本都被一个看似不相关的操作重置了！这显然不是我们想要的行为。</p> \n<blockquote> \n <p>(为节约流量和尊重 BLM，此处请自行脑补非洲裔问号图)</p> \n</blockquote> \n<p>这是因为，和 <code class=\"highlighter-rouge\">@State</code> 这种底层存储被 SwiftUI “全面接管” 的状态不同，<code class=\"highlighter-rouge\">@ObservedObject</code> 只是在 <code class=\"highlighter-rouge\">View</code> 和 <code class=\"highlighter-rouge\">Model</code> 之间添加订阅关系，而不影响存储。因此，当 <code class=\"highlighter-rouge\">ContentView</code> 中的状态发生变化，<code class=\"highlighter-rouge\">ContentView.body</code> 被重新求值时，<code class=\"highlighter-rouge\">ScorePlate</code> 就会被重新生成，其中的 <code class=\"highlighter-rouge\">model</code> 也一同重新生成，导致了状态的“丢失”。运行代码，在 Xcode console 中可以看到每次点击 Toggle 按钮时都伴随着 <code class=\"highlighter-rouge\">Model.init</code> 的输出。</p> \n<blockquote> \n <p>Nice 标签则不同，它是由 <code class=\"highlighter-rouge\">@State</code> 驱动的：由于 <code class=\"highlighter-rouge\">View</code> 是不可变的 struct，它的状态改变需要底层存储的支持。SwiftUI 将为 <code class=\"highlighter-rouge\">@State</code> 创建额外的存储空间，来保证在 <code class=\"highlighter-rouge\">View</code> 刷新 (也就是重新创建时)，状态能够保持。但这对 <code class=\"highlighter-rouge\">@ObservedObject</code> 并不适用。</p> \n</blockquote> \n<h3 id=\"保证单次创建的-stateobject\">保证单次创建的 @StateObject</h3> \n<p>只要理解了 <code class=\"highlighter-rouge\">@ObservedObject</code> 存在的问题，<code class=\"highlighter-rouge\">@StateObject</code> 的意义也就很明显了。<code class=\"highlighter-rouge\">@StateObject</code> 就是 <code class=\"highlighter-rouge\">@State</code> 的升级版：<code class=\"highlighter-rouge\">@State</code> 是针对 struct 状态所创建的存储，<code class=\"highlighter-rouge\">@StateObject</code> 则是针对 <code class=\"highlighter-rouge\">ObservableObject</code> class 的存储。它保证这个 class 实例不会随着 <code class=\"highlighter-rouge\">View</code> 被重新创建。从而解决问题。</p> \n<p>在上面这个具体的例子中，只要把 <code class=\"highlighter-rouge\">ScorePlate</code> 中的 <code class=\"highlighter-rouge\">@ObservedObject</code> 改成 <code class=\"highlighter-rouge\">@StateObject</code>，就万事大吉了：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"kt\">ScorePlate</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// @ObservedObject var model = Model()</span>\n    <span class=\"kd\">@StateObject</span> <span class=\"k\">var</span> <span class=\"nv\">model</span> <span class=\"o\">=</span> <span class=\"kt\">Model</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>现在，<code class=\"highlighter-rouge\">ScorePlate</code> 和 <code class=\"highlighter-rouge\">ScoreText</code> 里的状态不会被重置了。</p> \n<p>那么，一个自然而然引申出的问题是，我们是不是应该把所有的 <code class=\"highlighter-rouge\">@ObservedObject</code> 都换成 <code class=\"highlighter-rouge\">@StateObject</code>？比如上面例子中需要把 <code class=\"highlighter-rouge\">ScoreText</code> 里的声明也进行替换吗？这看实际上你的 <code class=\"highlighter-rouge\">View</code> 到底期望怎样的行为：如果不希望 model 状态在 View 刷新时丢失，那确实可以进行替换，这 (虽然可能会对性能有一些影响，但) 不会影响整体的行为。但是，如果 <code class=\"highlighter-rouge\">View</code> 本身就期望每次刷新时获得一个全新的状态，那么对于那些不是自己创建的，而是从外界接受的 <code class=\"highlighter-rouge\">ObservableObject</code> 来说，<code class=\"highlighter-rouge\">@StateObject</code> 反而是不合适的。</p> \n<h3 id=\"更多的讨论\">更多的讨论</h3> \n<h4 id=\"使用-environmentobject-保持状态\">使用 <code class=\"highlighter-rouge\">@EnvironmentObject</code> 保持状态</h4> \n<p>除了 <code class=\"highlighter-rouge\">@StateObject</code> 外，另一种让状态 object 保持住的方式，是在更外层使用 <code class=\"highlighter-rouge\">.environmentObject</code>：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"kt\">SwiftUINewApp</span><span class=\"p\">:</span> <span class=\"kt\">App</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">Scene</span> <span class=\"p\">{</span>\n        <span class=\"kt\">WindowGroup</span> <span class=\"p\">{</span>\n            <span class=\"kt\">ContentView</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"nf\">environmentObject</span><span class=\"p\">(</span><span class=\"kt\">Model</span><span class=\"p\">())</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>这样，model 对象将被注入到环境中，不再随着 <code class=\"highlighter-rouge\">ContentView</code> 的刷新而变更。在使用时，只需要遵循普通的 environment 方式，把 <code class=\"highlighter-rouge\">Model</code> 声明为 <code class=\"highlighter-rouge\">@EnvironmentObject</code> 就行了：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"kt\">ScorePlate</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"kd\">@EnvironmentObject</span> <span class=\"k\">var</span> <span class=\"nv\">model</span><span class=\"p\">:</span> <span class=\"kt\">Model</span>\n    <span class=\"c1\">// ...</span>\n    \n    <span class=\"c1\">// ScoreText(model: model).padding(.top, 20)</span>\n    <span class=\"kt\">ScoreText</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"nf\">padding</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">top</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">struct</span> <span class=\"kt\">ScoreText</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"kd\">@EnvironmentObject</span> <span class=\"k\">var</span> <span class=\"nv\">model</span><span class=\"p\">:</span> <span class=\"kt\">Model</span>\n    <span class=\"c1\">// ...</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<h4 id=\"和-state-保持同样的生命周期\">和 <code class=\"highlighter-rouge\">@State</code> 保持同样的生命周期</h4> \n<p>除了确保单次创建外，<code class=\"highlighter-rouge\">@StateObject</code> 的另一个重要特性是和 <code class=\"highlighter-rouge\">@State</code> 的“生命周期”保持统一，让 SwiftUI 全面接管背后的存储，也可以避免一些不必要的 bug。</p> \n<p>在 <code class=\"highlighter-rouge\">ContentView</code> 上稍作修改，把 <code class=\"highlighter-rouge\">ScorePlate()</code> 放到一个 <code class=\"highlighter-rouge\">NavigationLink</code> 中，就能看到结果：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n  <span class=\"kt\">NavigationView</span> <span class=\"p\">{</span>\n    <span class=\"kt\">VStack</span> <span class=\"p\">{</span>\n      <span class=\"kt\">Button</span><span class=\"p\">(</span><span class=\"s\">\"Toggle Name\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">showRealName</span><span class=\"o\">.</span><span class=\"nf\">toggle</span><span class=\"p\">()</span>\n      <span class=\"p\">}</span>\n      <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Current User: </span><span class=\"se\">\\(</span><span class=\"n\">showRealName</span> <span class=\"p\">?</span> <span class=\"s\">\"Wei Wang\"</span> <span class=\"p\">:</span> <span class=\"s\">\"onevcat\"</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n      <span class=\"kt\">NavigationLink</span><span class=\"p\">(</span><span class=\"s\">\"Next\"</span><span class=\"p\">,</span> <span class=\"nv\">destination</span><span class=\"p\">:</span> <span class=\"kt\">ScorePlate</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"nf\">padding</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">top</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">))</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>当点击 “Next” 时，会导航到 <code class=\"highlighter-rouge\">ScorePlate</code> 页面，可以在那里进行 +1 操作。当点击 Back button 回到 <code class=\"highlighter-rouge\">ContentView</code>，并再次点击 “Next” 时，一般情况下我们会希望 <code class=\"highlighter-rouge\">ScorePlate</code> 的状态被重置，得到一个全新的，从 0 开始的状态。此时使用 <code class=\"highlighter-rouge\">@StateObject</code> 可以工作良好，因为 SwiftUI 帮助我们重建了 <code class=\"highlighter-rouge\">@State</code> 和 <code class=\"highlighter-rouge\">@StateObject</code>。而如果我们将 <code class=\"highlighter-rouge\">ScorePlate</code> 里的声明从 <code class=\"highlighter-rouge\">@StateObject</code> 改回 <code class=\"highlighter-rouge\">@ObservedObject</code> 的话，SwiftUI 将不再能够帮助我们进行状态管理，除非通过 “Toggle” 按钮刷新整个 <code class=\"highlighter-rouge\">ContentView</code>，否则 <code class=\"highlighter-rouge\">ScorePlate</code> 在再次展示时将保留原来的状态。</p> \n<blockquote> \n <p>当然，如果你有意想要在 <code class=\"highlighter-rouge\">ScorePlate</code> 保留这些状态的话，使用 <code class=\"highlighter-rouge\">@ObservedObject</code> 或者上面的 <code class=\"highlighter-rouge\">@EnvironmentObject</code> 的方式才是正确的选择。</p> \n</blockquote> \n<h3 id=\"总结\">总结</h3> \n<p>简单说，对于 <code class=\"highlighter-rouge\">View</code> 自己创建的 <code class=\"highlighter-rouge\">ObservableObject</code> 状态对象来说，极大概率你可能需要使用新的 <code class=\"highlighter-rouge\">@StateObject</code> 来让它的存储和生命周期更合理：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"kt\">MyView</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"kd\">@StateObject</span> <span class=\"k\">var</span> <span class=\"nv\">model</span> <span class=\"o\">=</span> <span class=\"kt\">Model</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>而对于那些从外界接受 <code class=\"highlighter-rouge\">ObservableObject</code> 的 <code class=\"highlighter-rouge\">View</code>，究竟是使用 <code class=\"highlighter-rouge\">@ObservedObject</code> 还是 <code class=\"highlighter-rouge\">@StateObject</code>，则需要根据情况和需要确定。像是那些存在于 <code class=\"highlighter-rouge\">NavigationLink</code> 的 <code class=\"highlighter-rouge\">destination</code> 中的 <code class=\"highlighter-rouge\">View</code>，由于 SwiftUI 对它们的构建时机并没有做 lazy 处理，在处理它们时，需要格外小心。</p> \n<p>不论哪种情况，彻底弄清楚两者的区别和背后的逻辑，可以帮助我们更好地理解一个 SwiftUI app 的行为模式。</p>","descriptionType":"text/html","publishedDate":"Thu, 25 Jun 2020 03:00:00 +0000","feedId":3176,"bgimg":"https://onevcat.com/assets/images/2020/48b8f3b0ed887f90b8d420b137fb3689.jpg","linkMd5":"4066587684cc4554b82f49d89fa4b04f","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn4@2020_4/2020/08/24/21-24-58-759_bca69bb8da9e549a.webp","destWidth":280,"destHeight":249,"sourceBytes":10479,"destBytes":8880,"author":"","articleImgCdnMap":{"https://onevcat.com/assets/images/2020/48b8f3b0ed887f90b8d420b137fb3689.jpg":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn4@2020_4/2020/08/24/21-24-58-759_bca69bb8da9e549a.webp","https://onevcat.com/assets/images/2020/stateobject_app.png":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn27@2020_5/2020/08/24/21-25-03-255_7c0316a36367be54.webp","https://onevcat.com/assets/images/2020/stateobject_reset.gif":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn79@2020_5/2020/08/24/21-25-04-160_91e623db0d5c1bb9.webp"},"publishedOrCreatedDate":1598304289184},{"createdTime":"2020-08-25 05:24:49","updatedTime":"2020-08-25 05:24:49","title":"在 Combine 中实现自定义 Publisher","link":"https://onevcat.com/2020/01/customize-publisher/","description":"<blockquote> \n <p>本文是对我的《SwiftUI 和 Combine 编程》书籍的补充，对一些虽然很重要，但和书中上下文内容相去略远，或者一些不太适合以书本的篇幅详细展开解释的内容进行了追加说明。如果你对 SwiftUI 和 Combine 的更多话题有兴趣的话，可以考虑<a href=\"https://objccn.io/products/swift-ui\">参阅原书</a>。</p> \n</blockquote> \n<p><a href=\"https://onevcat.com/2019/12/backpressure-in-combine/\">上一篇文章</a>里，我们探索了 Combine 里对 back pressure 的处理。在那边，主要涉及到的是实现自定义的 <code class=\"highlighter-rouge\">Subscriber</code>，来通过控制事件流终端的 pull 行为，实现合理的 back pressure 机制。</p> \n<p>对于整个事件流的另一端，<code class=\"highlighter-rouge\">Publisher</code>，有时候我们也有自定义的需求。在《SwiftUI 和 Combine 编程》中，在“打包”多个请求时，我们用了一种很 naive 的方法：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"kt\">LoadPokemonRequest</span> <span class=\"p\">{</span>\n    <span class=\"kd\">static</span> <span class=\"k\">var</span> <span class=\"nv\">all</span><span class=\"p\">:</span> <span class=\"kt\">AnyPublisher</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">PokemonViewModel</span><span class=\"p\">],</span> <span class=\"kt\">AppError</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n        <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">...</span><span class=\"mi\">30</span><span class=\"p\">)</span>\n            <span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">{</span> <span class=\"kt\">LoadPokemonRequest</span><span class=\"p\">(</span><span class=\"nv\">id</span><span class=\"p\">:</span> <span class=\"nv\">$0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">publisher</span> <span class=\"p\">}</span>\n            <span class=\"o\">.</span><span class=\"n\">zipAll</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>其中，<code class=\"highlighter-rouge\">zipAll</code> 是 <code class=\"highlighter-rouge\">Array</code> 上的 extension：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">extension</span> <span class=\"kt\">Array</span> <span class=\"k\">where</span> <span class=\"kt\">Element</span><span class=\"p\">:</span> <span class=\"kt\">Publisher</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nv\">zipAll</span><span class=\"p\">:</span> <span class=\"kt\">AnyPublisher</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">Element</span><span class=\"o\">.</span><span class=\"kt\">Output</span><span class=\"p\">],</span> <span class=\"kt\">Element</span><span class=\"o\">.</span><span class=\"kt\">Failure</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"nv\">initial</span> <span class=\"o\">=</span> <span class=\"kt\">Just</span><span class=\"p\">([</span><span class=\"kt\">Element</span><span class=\"o\">.</span><span class=\"kt\">Output</span><span class=\"p\">]())</span>\n            <span class=\"o\">.</span><span class=\"nf\">setFailureType</span><span class=\"p\">(</span><span class=\"nv\">to</span><span class=\"p\">:</span> <span class=\"kt\">Element</span><span class=\"o\">.</span><span class=\"kt\">Failure</span><span class=\"o\">.</span><span class=\"k\">self</span><span class=\"p\">)</span>\n            <span class=\"o\">.</span><span class=\"nf\">eraseToAnyPublisher</span><span class=\"p\">()</span>\n        <span class=\"k\">return</span> <span class=\"nf\">reduce</span><span class=\"p\">(</span><span class=\"n\">initial</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">result</span><span class=\"p\">,</span> <span class=\"n\">publisher</span> <span class=\"k\">in</span>\n            <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"nf\">zip</span><span class=\"p\">(</span><span class=\"n\">publisher</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"nv\">$0</span> <span class=\"o\">+</span> <span class=\"p\">[</span><span class=\"nv\">$1</span><span class=\"p\">]</span> <span class=\"p\">}</span><span class=\"o\">.</span><span class=\"nf\">eraseToAnyPublisher</span><span class=\"p\">()</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>这个做法创建了多个“临时” <code class=\"highlighter-rouge\">Publisher</code>，并通过 <code class=\"highlighter-rouge\">reduce</code> 把它们组合在一起。对于 <code class=\"highlighter-rouge\">zip</code> 来说，这么做侥幸可以工作，但是这并不是一个一般性的解决方案。和自定义 <code class=\"highlighter-rouge\">Subscriber</code> 一样，Combine 中的 <code class=\"highlighter-rouge\">Publisher</code> 也是 protocol，我们可以按照需求去创建那些 Combine 库中还不存在、但是很有用的 <code class=\"highlighter-rouge\">Publisher</code>。在本文里，我们就以创建一个真正的 <code class=\"highlighter-rouge\">ZipAll</code> 作为例子，来说明自定义 <code class=\"highlighter-rouge\">Publisher</code> 的一般方法。</p> \n<p>你可以打开一个 Playground，跟随本文键入代码，也可以<a href=\"https://gist.github.com/onevcat/138ca5a41ee1a7f2994a6c366936744e\">在这里</a>直接查看并尝试完整的代码。</p> \n<p>在我们正式开始之前，我还是想强调下面这张图，它总结了 Combine 框架的完整工作流程。其实归根溯源，不管我们只是想很初级地使用 Combine 的内建内容，还是想更高级一些去自定义响应式的操作和事件流，归根结底，我们都是在如图定义的工作流中进行操作。只有真正理解和熟悉这张 Combine 的工作流程图，才能说是真正掌握了 Combine 的思维方式。</p> \n<p><img src=\"https://onevcat.com/assets/images/2019/publisher-subscriber-flow.svg\" alt=\"\" /></p> \n<h2 id=\"主要角色和工作\">主要角色和工作</h2> \n<p>按照上图，我们逐行来梳理在自定义一个 <code class=\"highlighter-rouge\">Publisher</code> 时需要做些什么。这可以为自定义 <code class=\"highlighter-rouge\">Publisher</code> 的设计提供一个概览性的指导。对于图中的每个步骤，说明如下：</p> \n<ol> \n <li><code class=\"highlighter-rouge\">Subscriber</code> 可以通过调用 <code class=\"highlighter-rouge\">Publisher.subscribe</code> 来告诉 <code class=\"highlighter-rouge\">Publisher</code> 订阅开始。自然地，我们需要在 <code class=\"highlighter-rouge\">Publisher</code> 上增加一个方法：<code class=\"highlighter-rouge\">subscribe</code>。</li> \n <li><code class=\"highlighter-rouge\">Publisher</code> 需要调用 <code class=\"highlighter-rouge\">Subscriber</code> 上的 <code class=\"highlighter-rouge\">receive(subscription:)</code> 方法。这个方法接收一个 <code class=\"highlighter-rouge\">Subscription</code>。那么显然，<code class=\"highlighter-rouge\">Publisher</code> 需要知道如何创建一个<strong>合适的</strong> <code class=\"highlighter-rouge\">Subscription</code>。</li> \n <li><code class=\"highlighter-rouge\">Subscriber</code> 通过调用 2 中创建的 <code class=\"highlighter-rouge\">Subscription</code> 上的 <code class=\"highlighter-rouge\">request</code> 方法，来首次表明自己需要多少个事件。也就是说，<code class=\"highlighter-rouge\">Subscription</code> 上必须要有一个 <code class=\"highlighter-rouge\">request</code> 方法，它接受并记录 <code class=\"highlighter-rouge\">Subscribers.Demand</code> (这也是 <code class=\"highlighter-rouge\">Subscription</code> 协议中所定义的方法)。如果你对这个过程还不太熟悉，建议你可以参考我之前关于自定义 <code class=\"highlighter-rouge\">Subscriber</code> 和实现 back pressure 的<a href=\"https://onevcat.com/2019/12/backpressure-in-combine/\">文章</a>，那边对 <code class=\"highlighter-rouge\">Demand</code> 的用法和原理进行了详细的说明。</li> \n <li>当新的事件发生，并且当前的 demand 满足要求 (也即 <code class=\"highlighter-rouge\">Subscriber</code> 还需要更多事件) 时，调用 <code class=\"highlighter-rouge\">Subscriber.receive(_:)</code> 来向下游发送一个事件。这件事情可以由 <code class=\"highlighter-rouge\">Publisher</code> 完成，但是更多的时候，我们会倾向于保持 <code class=\"highlighter-rouge\">Publisher</code> 的值语义，然后选择在 <code class=\"highlighter-rouge\">Subscription</code> 中实现这些逻辑。因为 <code class=\"highlighter-rouge\">Subscription</code> 在大部分情况下会保持某个 buffer，并随着时间进行响应并改变值 (毕竟这正是 Combine 或者说响应式编程所要解决的问题领域)，所以一般我们会选择将 <code class=\"highlighter-rouge\">Subscription</code> 声明为 <code class=\"highlighter-rouge\">class</code> 并使用引用语义。另外，<code class=\"highlighter-rouge\">Subscriber.receive(_:)</code> 返回的 <code class=\"highlighter-rouge\">Demand</code> 值应该被追加到剩余需要的事件个数中。</li> \n <li>同 4。</li> \n <li>如果事件结束 (比如异步操作完全完成，或者出现了错误)，需要调用 <code class=\"highlighter-rouge\">Subscriber.receive(completion:)</code>。这一步也经常是由 <code class=\"highlighter-rouge\">Subscription</code> 来实现的。</li> \n</ol> \n<p>上面的 4，5，6 中涉及的都是在 <code class=\"highlighter-rouge\">Subscription</code> 中调用 <code class=\"highlighter-rouge\">Subscriber</code> 的方法，所以在我们的实现中，在 <code class=\"highlighter-rouge\">Subscription</code> 里持有 <code class=\"highlighter-rouge\">Subscriber</code> 是一个自然而然的选择。对于自定义的具体的 <code class=\"highlighter-rouge\">Publisher</code> 类型来说，它只负责提供一个简单的接口封装，来满足 <code class=\"highlighter-rouge\">Publisher</code> 协议的规定，并保持这个角色的值语义 (在 Combine 的实现中，绝大部分的 <code class=\"highlighter-rouge\">Publisher</code> 都拥有值语义，这让订阅的声明周期和行为相对简单)。事件发送，值的保持等涉及到具体、时序上的操作，则由一个相对复杂的 <code class=\"highlighter-rouge\">Subscription</code> 实现。</p> \n<h3 id=\"publisher\">Publisher</h3> \n<p>对于我们要实现的接受数组版本的 <code class=\"highlighter-rouge\">zip</code> 来说，最直接的就是实现一个 <code class=\"highlighter-rouge\">ZipAll</code>，让它实现 <code class=\"highlighter-rouge\">Publisher</code> 协议。遵循 Combine 的一般方式，我们把 <code class=\"highlighter-rouge\">ZipAll</code> 定义在 <code class=\"highlighter-rouge\">Publishers</code> 中，并添加上 <code class=\"highlighter-rouge\">Publisher</code> 协议所需要的方法：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">extension</span> <span class=\"kt\">Publishers</span> <span class=\"p\">{</span>\n    <span class=\"kd\">struct</span> <span class=\"kt\">ZipAll</span><span class=\"o\">&lt;</span><span class=\"kt\">Collection</span><span class=\"p\">:</span> <span class=\"kt\">Swift</span><span class=\"o\">.</span><span class=\"kt\">Collection</span><span class=\"o\">&gt;</span><span class=\"p\">:</span> <span class=\"kt\">Publisher</span> \n    <span class=\"k\">where</span> <span class=\"kt\">Collection</span><span class=\"o\">.</span><span class=\"kt\">Element</span><span class=\"p\">:</span> <span class=\"kt\">Publisher</span> \n    <span class=\"p\">{</span>\n        <span class=\"c1\">// 1</span>\n        <span class=\"kd\">typealias</span> <span class=\"kt\">Output</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kt\">Collection</span><span class=\"o\">.</span><span class=\"kt\">Element</span><span class=\"o\">.</span><span class=\"kt\">Output</span><span class=\"p\">]</span>\n        <span class=\"kd\">typealias</span> <span class=\"kt\">Failure</span> <span class=\"o\">=</span> <span class=\"kt\">Collection</span><span class=\"o\">.</span><span class=\"kt\">Element</span><span class=\"o\">.</span><span class=\"kt\">Failure</span>\n      \n        <span class=\"kd\">private</span> <span class=\"k\">let</span> <span class=\"nv\">publishers</span><span class=\"p\">:</span> <span class=\"kt\">Collection</span>\n\n        <span class=\"nf\">init</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">publishers</span><span class=\"p\">:</span> <span class=\"kt\">Collection</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">publishers</span> <span class=\"o\">=</span> <span class=\"n\">publishers</span>\n        <span class=\"p\">}</span>\n\n        <span class=\"c1\">// 2</span>\n        <span class=\"kd\">func</span> <span class=\"n\">receive</span><span class=\"o\">&lt;</span><span class=\"kt\">S</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"nv\">subscriber</span><span class=\"p\">:</span> <span class=\"kt\">S</span><span class=\"p\">)</span>\n            <span class=\"k\">where</span> <span class=\"kt\">S</span> <span class=\"p\">:</span> <span class=\"kt\">Subscriber</span><span class=\"p\">,</span> <span class=\"kt\">Failure</span> <span class=\"o\">==</span> <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"kt\">Failure</span><span class=\"p\">,</span> <span class=\"kt\">Output</span> <span class=\"o\">==</span> <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"kt\">Input</span>\n        <span class=\"p\">{</span>\n            <span class=\"c1\">// 3</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<ol> \n <li>作为新的 <code class=\"highlighter-rouge\">Publisher</code>，<code class=\"highlighter-rouge\">ZipAll</code> 也需要自己的 <code class=\"highlighter-rouge\">Output</code>。通过限定 <code class=\"highlighter-rouge\">ZipAll</code> 所接收的子 <code class=\"highlighter-rouge\">Publisher</code> 具有相同的类型，新的 <code class=\"highlighter-rouge\">Publisher</code> 的 <code class=\"highlighter-rouge\">Output</code> 也便可以被确定。</li> \n <li>这是 <code class=\"highlighter-rouge\">Publisher</code> 协议所规定需要实现的方法，不论你自定义的 <code class=\"highlighter-rouge\">Publisher</code> 具体是什么，这一部分是不会改变的。</li> \n <li>在 <code class=\"highlighter-rouge\">receive(subscriber:)</code> 里，按照 Combine 工作流程，我们创建 <code class=\"highlighter-rouge\">Subscription</code> 并调用 <code class=\"highlighter-rouge\">Subscriber.receive(subscription:)</code> 来把这个新创建的 <code class=\"highlighter-rouge\">Subscription</code> 发送给 <code class=\"highlighter-rouge\">Subscriber</code>。(流程图中的 1 和 2)，然后等待 <code class=\"highlighter-rouge\">Subscriber</code> 首次请求数据。现在我们还没有创建合适的 <code class=\"highlighter-rouge\">Subscription</code> 类型，所以先把它留空。在后面我们会回到这个方法，并填上需要的内容。</li> \n</ol> \n<p>在 <code class=\"highlighter-rouge\">init</code> 里，我们接收了一个类型满足 <code class=\"highlighter-rouge\">Swift.Collection</code>，且其中元素均为同类型 <code class=\"highlighter-rouge\">Publisher</code> 的集合类型作为参数。在实际使用这个 <code class=\"highlighter-rouge\">ZipAll</code> 时，我们大概会想要做的步骤如下：</p> \n<ol> \n <li>订阅每个输入的 publisher，并观察它们的事件。建立符合输入的 publisher 个数的缓冲区。</li> \n <li>某个 publisher 发出新的值后，先将它保存到对应的缓冲区里。然后检查所有这些缓冲区中是不是都有待处理的元素。如果都有，则将它们的首个元素移出来，形成一个数组并作为新的 <code class=\"highlighter-rouge\">ZipAll</code> 值发送出去。</li> \n <li>某个输入 publisher 发出成功完成的事件后，将它记录下来，并检查是不是所有的输入 publisher 都完成了。如果是，则将 <code class=\"highlighter-rouge\">.finish</code> 事件发送出去。</li> \n <li>如果某个输入 publisher 发出了错误，那么将错误直接作为新 <code class=\"highlighter-rouge\">Publisher</code> 的结果发出。</li> \n</ol> \n<p>暂时我们现在还不知道要怎么往 <code class=\"highlighter-rouge\">receive(subscriber:)</code> 中填写内容，这要求我们需要知道如何创建 <code class=\"highlighter-rouge\">Subscription</code>。好消息是，<code class=\"highlighter-rouge\">Subscription</code> 本身也是一个被严格定义的协议，这为我们实现自定义订阅类型提供了一些基本的依据。</p> \n<h3 id=\"subscription\">Subscription</h3> \n<p>紧接着 <code class=\"highlighter-rouge\">ZipAll</code> 的定义，在 <code class=\"highlighter-rouge\">Publishers</code> 中创建一个私有的 <code class=\"highlighter-rouge\">ZipAppSubscription</code> 类：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">extension</span> <span class=\"kt\">Publishers</span> <span class=\"p\">{</span>\n    <span class=\"kd\">struct</span> <span class=\"kt\">ZipAll</span> <span class=\"o\">...</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// ...</span>\n    <span class=\"p\">}</span>\n    \n    <span class=\"kd\">private</span> <span class=\"kd\">class</span> <span class=\"kt\">ZipAppSubscription</span><span class=\"o\">&lt;</span><span class=\"kt\">Output</span><span class=\"p\">,</span> <span class=\"kt\">Failure</span><span class=\"p\">:</span> <span class=\"kt\">Error</span><span class=\"o\">&gt;</span><span class=\"p\">:</span> <span class=\"kt\">Subscription</span>\n    <span class=\"p\">{</span>\n        <span class=\"c1\">// 1</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>Combine 中，<code class=\"highlighter-rouge\">Subscription</code> 协议定义了两个必须实现的方法：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">request</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">demand</span><span class=\"p\">:</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Demand</span><span class=\"p\">)</span>\n<span class=\"kd\">func</span> <span class=\"nf\">cancel</span><span class=\"p\">()</span>\n</code></pre> \n </div> \n</div> \n<p>前者用来接收 <code class=\"highlighter-rouge\">Subscriber</code> 的请求，后者用来取消当前订阅。</p> \n<p>在 <code class=\"highlighter-rouge\">ZipAppSubscription</code> 的 <code class=\"highlighter-rouge\">// 1</code> 里添加下面这些内容：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"c1\">// 1</span>\n<span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">leftDemand</span><span class=\"p\">:</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Demand</span> <span class=\"o\">=</span> <span class=\"o\">.</span><span class=\"k\">none</span>\n<span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">subscriber</span><span class=\"p\">:</span> <span class=\"kt\">AnySubscriber</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">Output</span><span class=\"p\">],</span> <span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">?</span> <span class=\"o\">=</span> <span class=\"kc\">nil</span>\n<span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">buffer</span><span class=\"p\">:</span> <span class=\"p\">[[</span><span class=\"kt\">Output</span><span class=\"p\">]]</span>\n<span class=\"kd\">private</span> <span class=\"k\">let</span> <span class=\"nv\">publishers</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"kt\">AnyPublisher</span><span class=\"o\">&lt;</span><span class=\"kt\">Output</span><span class=\"p\">,</span> <span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">]</span>\n<span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">childSubscriptions</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"kt\">AnyCancellable</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n<span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">finishedCount</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">// 2</span>\n<span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">lock</span> <span class=\"o\">=</span> <span class=\"kt\">NSRecursiveLock</span><span class=\"p\">()</span>\n\n<span class=\"kd\">init</span><span class=\"o\">&lt;</span><span class=\"kt\">S</span><span class=\"p\">:</span> <span class=\"kt\">Subscriber</span><span class=\"o\">&gt;</span><span class=\"p\">(</span>\n    <span class=\"nv\">subscriber</span><span class=\"p\">:</span> <span class=\"kt\">S</span><span class=\"p\">,</span>\n    <span class=\"nv\">publishers</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"kt\">AnyPublisher</span><span class=\"o\">&lt;</span><span class=\"kt\">Output</span><span class=\"p\">,</span> <span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">]</span>\n<span class=\"p\">)</span> <span class=\"k\">where</span> <span class=\"kt\">Failure</span> <span class=\"o\">==</span> <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"kt\">Failure</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"kt\">Output</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"kt\">Input</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">subscriber</span> <span class=\"o\">=</span> <span class=\"kt\">AnySubscriber</span><span class=\"p\">(</span><span class=\"n\">subscriber</span><span class=\"p\">)</span>\n    <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"kt\">Array</span><span class=\"p\">(</span><span class=\"nv\">repeating</span><span class=\"p\">:</span> <span class=\"p\">[],</span> <span class=\"nv\">count</span><span class=\"p\">:</span> <span class=\"n\">publishers</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">)</span>\n    <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">publishers</span> <span class=\"o\">=</span> <span class=\"n\">publishers</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"nf\">request</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">demand</span><span class=\"p\">:</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Demand</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"nf\">lock</span><span class=\"p\">()</span>\n    <span class=\"k\">defer</span> <span class=\"p\">{</span> <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"nf\">unlock</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n\n    <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">leftDemand</span> <span class=\"o\">+=</span> <span class=\"n\">demand</span>\n\n    <span class=\"c1\">// 3</span>\n    <span class=\"nf\">send</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"nf\">cancel</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"nf\">lock</span><span class=\"p\">()</span>\n    <span class=\"k\">defer</span> <span class=\"p\">{</span> <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"nf\">unlock</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n\n    <span class=\"n\">childSubscriptions</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"n\">subscriber</span> <span class=\"o\">=</span> <span class=\"kc\">nil</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<ol> \n <li>既然生活在 Combine 的世界中，我们就得遵守 Combine 的游戏规则。<code class=\"highlighter-rouge\">leftDemand</code> 将记录下游订阅者还需要的值的数量，这样我们可以遵守基于 pull 的行为规则。</li> \n <li>我们不能确定 zip 操作中涉及的各个 publisher 最终会在哪个线程向我们发送数据，这些数据在接收后会被放到 <code class=\"highlighter-rouge\">buffer</code> 中待用，因此这里出现了多个线程共享资源的情况。让整个操作线程安全的最简单的方法就是上锁。</li> \n <li>当收到 <code class=\"highlighter-rouge\">request(_:)</code> 调用时，除了将下游告知的需求 <code class=\"highlighter-rouge\">demand</code> 累加到 <code class=\"highlighter-rouge\">leftDemand</code> 以外，我们还需要检查 <code class=\"highlighter-rouge\">buffer</code> 并尝试触发事件 <code class=\"highlighter-rouge\">send</code> 就是做这件事情的。</li> \n</ol> \n<p>另外，我们还需要一个开始订阅的方法 (<code class=\"highlighter-rouge\">startSubscribing</code>)，它会负责开始订阅 <code class=\"highlighter-rouge\">publishers</code> 发出的值和事件。</p> \n<p>这个 <code class=\"highlighter-rouge\">startSubscribing</code> 和 3 中的 <code class=\"highlighter-rouge\">send</code> 是 <code class=\"highlighter-rouge\">Subscription</code> 的关键内容。前者负责把对应的事件进行转发处理：对于接收到的值，将它缓存在 <code class=\"highlighter-rouge\">buffer</code> 中，并判断是否应当触发 zip 合并后的事件；对于接收到的结束事件，如果是错误事件，则结束自身事件流，如果是子 publisher 的结束事件，则将它记录下来，直到所有的 publisher 都结束后，再向外发送自身的结束事件。</p> \n<p>这些逻辑看起来有些麻烦，但是如果给翻译翻译的话，代码看起来还是比较简单的：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">startSubscribing</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">publisher</span><span class=\"p\">)</span> <span class=\"k\">in</span> <span class=\"n\">publishers</span><span class=\"o\">.</span><span class=\"nf\">enumerated</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">publisher</span><span class=\"o\">.</span><span class=\"nf\">sink</span><span class=\"p\">(</span>\n            <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"p\">{</span>  <span class=\"p\">[</span><span class=\"k\">weak</span> <span class=\"k\">self</span><span class=\"p\">]</span> <span class=\"n\">completion</span> <span class=\"k\">in</span>\n                <span class=\"k\">self</span><span class=\"p\">?</span><span class=\"o\">.</span><span class=\"nf\">receiveCompletion</span><span class=\"p\">(</span><span class=\"n\">completion</span><span class=\"p\">,</span> <span class=\"nv\">at</span><span class=\"p\">:</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n            <span class=\"p\">},</span>\n            <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"p\">[</span><span class=\"k\">weak</span> <span class=\"k\">self</span><span class=\"p\">]</span> <span class=\"n\">value</span> <span class=\"k\">in</span>\n                <span class=\"k\">self</span><span class=\"p\">?</span><span class=\"o\">.</span><span class=\"nf\">receiveValue</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"nv\">at</span><span class=\"p\">:</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">)</span><span class=\"o\">.</span><span class=\"nf\">store</span><span class=\"p\">(</span><span class=\"nv\">in</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"n\">childSubscriptions</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kd\">func</span> <span class=\"nf\">receiveValue</span><span class=\"p\">(</span>\n    <span class=\"n\">_</span> <span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"kt\">Output</span><span class=\"p\">,</span> <span class=\"n\">at</span> <span class=\"nv\">index</span><span class=\"p\">:</span> <span class=\"kt\">Int</span>\n<span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"nf\">lock</span><span class=\"p\">()</span>\n    <span class=\"k\">defer</span> <span class=\"p\">{</span> <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"nf\">unlock</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n    <span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"nf\">append</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n\n    <span class=\"nf\">send</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kd\">func</span> <span class=\"nf\">receiveCompletion</span><span class=\"p\">(</span>\n    <span class=\"n\">_</span> <span class=\"nv\">event</span><span class=\"p\">:</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Completion</span><span class=\"o\">&lt;</span><span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"n\">at</span> <span class=\"nv\">index</span><span class=\"p\">:</span> <span class=\"kt\">Int</span>\n<span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"nf\">lock</span><span class=\"p\">()</span>\n    <span class=\"k\">defer</span> <span class=\"p\">{</span> <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"nf\">unlock</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n\n    <span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">subscriber</span> <span class=\"o\">=</span> <span class=\"n\">subscriber</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"p\">}</span>\n\n    <span class=\"k\">switch</span> <span class=\"n\">event</span> <span class=\"p\">{</span>\n    <span class=\"k\">case</span> <span class=\"o\">.</span><span class=\"nv\">finished</span><span class=\"p\">:</span>\n        <span class=\"n\">finishedCount</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">if</span> <span class=\"n\">finishedCount</span> <span class=\"o\">==</span> <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"p\">{</span>\n            <span class=\"n\">subscriber</span><span class=\"o\">.</span><span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"nv\">completion</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">finished</span><span class=\"p\">)</span>\n            <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">subscriber</span> <span class=\"o\">=</span> <span class=\"kc\">nil</span>\n        <span class=\"p\">}</span>\n    <span class=\"k\">case</span> <span class=\"o\">.</span><span class=\"nv\">failure</span><span class=\"p\">:</span>\n        <span class=\"n\">subscriber</span><span class=\"o\">.</span><span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"nv\">completion</span><span class=\"p\">:</span> <span class=\"n\">event</span><span class=\"p\">)</span>\n        <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">subscriber</span> <span class=\"o\">=</span> <span class=\"kc\">nil</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>然后是 <code class=\"highlighter-rouge\">Subscription</code> 里的另一个重要方法 <code class=\"highlighter-rouge\">send</code>，它负责检查 <code class=\"highlighter-rouge\">buffer</code>，并在满足 zip 逻辑的时候向外发布一个新值：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">private</span> <span class=\"kd\">func</span> <span class=\"nf\">send</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">subscriber</span> <span class=\"o\">=</span> <span class=\"n\">subscriber</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"p\">}</span>\n    <span class=\"k\">while</span> <span class=\"n\">leftDemand</span> <span class=\"o\">&gt;</span> <span class=\"o\">.</span><span class=\"k\">none</span><span class=\"p\">,</span> <span class=\"k\">let</span> <span class=\"nv\">outputs</span> <span class=\"o\">=</span> <span class=\"n\">firstRowOutputItems</span> <span class=\"p\">{</span>\n        <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">leftDemand</span> <span class=\"o\">-=</span> <span class=\"o\">.</span><span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"k\">let</span> <span class=\"nv\">nextDemand</span> <span class=\"o\">=</span> <span class=\"n\">subscriber</span><span class=\"o\">.</span><span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"n\">outputs</span><span class=\"p\">)</span>\n        <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">leftDemand</span> <span class=\"o\">+=</span> <span class=\"n\">nextDemand</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">firstRowOutputItems</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"kt\">Output</span><span class=\"p\">]?</span> <span class=\"p\">{</span>\n    <span class=\"k\">guard</span> <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"nf\">allSatisfy</span><span class=\"p\">({</span> <span class=\"o\">!</span><span class=\"nv\">$0</span><span class=\"o\">.</span><span class=\"n\">isEmpty</span> <span class=\"p\">})</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"kc\">nil</span> <span class=\"p\">}</span>\n    <span class=\"k\">var</span> <span class=\"nv\">outputs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kt\">Output</span><span class=\"p\">]()</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"mi\">0</span> <span class=\"o\">..&lt;</span> <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">count</span> <span class=\"p\">{</span>\n        <span class=\"k\">var</span> <span class=\"nv\">column</span> <span class=\"o\">=</span> <span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n        <span class=\"n\">outputs</span><span class=\"o\">.</span><span class=\"nf\">append</span><span class=\"p\">(</span><span class=\"n\">column</span><span class=\"o\">.</span><span class=\"nf\">remove</span><span class=\"p\">(</span><span class=\"nv\">at</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n        <span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">column</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">outputs</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>这样，我们就有一个完整的 <code class=\"highlighter-rouge\">Subscription</code> 角色了。最后，让我们回到 <code class=\"highlighter-rouge\">Publishers.ZipAll</code> 中，把刚才剩下的 <code class=\"highlighter-rouge\">receive(subscriber:)</code> 方法补完。创建一个 <code class=\"highlighter-rouge\">ZipAppSubscription</code> 实例，调用 <code class=\"highlighter-rouge\">Subscriber</code> 协议所定义的 <code class=\"highlighter-rouge\">receive(subscription:)</code> 方法，并开始订阅所有的 publisher：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"kt\">ZipAll</span> <span class=\"o\">...</span> <span class=\"p\">{</span>\n\n    <span class=\"c1\">// ...</span>\n\n    <span class=\"kd\">func</span> <span class=\"n\">receive</span><span class=\"o\">&lt;</span><span class=\"kt\">S</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"nv\">subscriber</span><span class=\"p\">:</span> <span class=\"kt\">S</span><span class=\"p\">)</span>\n        <span class=\"k\">where</span> <span class=\"kt\">S</span> <span class=\"p\">:</span> <span class=\"kt\">Subscriber</span><span class=\"p\">,</span> <span class=\"kt\">Failure</span> <span class=\"o\">==</span> <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"kt\">Failure</span><span class=\"p\">,</span> <span class=\"kt\">Output</span> <span class=\"o\">==</span> <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"kt\">Input</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"nv\">subscription</span> <span class=\"o\">=</span> <span class=\"kt\">ZipAppSubscription</span><span class=\"o\">&lt;</span><span class=\"kt\">Collection</span><span class=\"o\">.</span><span class=\"kt\">Element</span><span class=\"o\">.</span><span class=\"kt\">Output</span><span class=\"p\">,</span> <span class=\"kt\">Failure</span><span class=\"o\">&gt;</span><span class=\"p\">(</span>\n            <span class=\"nv\">subscriber</span><span class=\"p\">:</span> <span class=\"n\">subscriber</span><span class=\"p\">,</span> <span class=\"nv\">publishers</span><span class=\"p\">:</span> <span class=\"n\">publishers</span><span class=\"o\">.</span><span class=\"n\">map</span> <span class=\"p\">{</span> <span class=\"nv\">$0</span><span class=\"o\">.</span><span class=\"nf\">eraseToAnyPublisher</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n        <span class=\"p\">)</span>\n        <span class=\"n\">subscriber</span><span class=\"o\">.</span><span class=\"nf\">receive</span><span class=\"p\">(</span><span class=\"nv\">subscription</span><span class=\"p\">:</span> <span class=\"n\">subscription</span><span class=\"p\">)</span>\n        <span class=\"n\">subscription</span><span class=\"o\">.</span><span class=\"nf\">startSubscribing</span><span class=\"p\">()</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre> \n </div> \n</div> \n<p>现在，我们就可以通过 <code class=\"highlighter-rouge\">Publishers.ZipAll</code> 来创建一个真正的 <code class=\"highlighter-rouge\">ZipAll</code> 的 <code class=\"highlighter-rouge\">Publisher</code> 了。比如：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">p1</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">publisher</span>\n<span class=\"k\">let</span> <span class=\"nv\">p2</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">publisher</span>\n<span class=\"k\">let</span> <span class=\"nv\">p3</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"mi\">9</span><span class=\"p\">,</span><span class=\"mi\">10</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">publisher</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">zipped</span> <span class=\"o\">=</span> <span class=\"kt\">Publishers</span><span class=\"o\">.</span><span class=\"kt\">ZipAll</span><span class=\"p\">([</span><span class=\"n\">p1</span><span class=\"p\">,</span> <span class=\"n\">p2</span><span class=\"p\">,</span> <span class=\"n\">p3</span><span class=\"p\">])</span>\n<span class=\"k\">let</span> <span class=\"nv\">subscription</span> <span class=\"o\">=</span> <span class=\"n\">zipped</span><span class=\"o\">.</span><span class=\"nf\">sink</span><span class=\"p\">(</span>\n    <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"n\">completion</span> <span class=\"k\">in</span>\n        <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"receiveCompletion </span><span class=\"se\">\\(</span><span class=\"n\">completion</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n    <span class=\"p\">},</span>\n    <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">values</span> <span class=\"k\">in</span>\n        <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"receiveValues: </span><span class=\"se\">\\(</span><span class=\"n\">values</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\">// 输出：</span>\n<span class=\"c1\">// receiveValues: [1, 4, 7]</span>\n<span class=\"c1\">// receiveValues: [2, 5, 8]</span>\n<span class=\"c1\">// receiveValues: [3, 6, 9]</span>\n<span class=\"c1\">// receiveCompletion finished</span>\n</code></pre> \n </div> \n</div> \n<p>当然，最后，我们可以学习 <code class=\"highlighter-rouge\">Publishers</code> 中的其他类型那样，为 <code class=\"highlighter-rouge\">ZipAll</code> 提供一个辅助方法，让创建 <code class=\"highlighter-rouge\">Publishers.ZipAll</code> 变得简单一些：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kd\">extension</span> <span class=\"kt\">Collection</span> <span class=\"k\">where</span> <span class=\"kt\">Element</span><span class=\"p\">:</span> <span class=\"kt\">Publisher</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nv\">zipAll</span><span class=\"p\">:</span> <span class=\"kt\">Publishers</span><span class=\"o\">.</span><span class=\"kt\">ZipAll</span><span class=\"o\">&lt;</span><span class=\"k\">Self</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n        <span class=\"kt\">Publishers</span><span class=\"o\">.</span><span class=\"kt\">ZipAll</span><span class=\"p\">(</span><span class=\"k\">self</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">zipped</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">p1</span><span class=\"p\">,</span> <span class=\"n\">p2</span><span class=\"p\">,</span> <span class=\"n\">p3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">zipAll</span>\n</code></pre> \n </div> \n</div> \n<h2 id=\"不足之处和改进空间\">不足之处和改进空间</h2> \n<p>虽然 <code class=\"highlighter-rouge\">ZipAll</code> 应该已经可以正常工作了，但是还有一些值得优化的地方。</p> \n<h3 id=\"性能改进\">性能改进</h3> \n<p>首先是 <code class=\"highlighter-rouge\">firstRowOutputItems</code> 中的数组操作的效率。<code class=\"highlighter-rouge\">buffer</code> 的类型是 <code class=\"highlighter-rouge\">[[Output]]</code>，它其中的元素也只是普通的 <code class=\"highlighter-rouge\">Array</code>。因此 <code class=\"highlighter-rouge\">firstRowOutputItems</code> 里的移除首个元素 <code class=\"highlighter-rouge\">column.remove(at: 0)</code> 的操作，其实时间复杂度是 <code class=\"highlighter-rouge\">O(n)</code>，而它又处于一个 <code class=\"highlighter-rouge\">buffer.count</code> 的循环中，所以这里会带来一个 n^2 的复杂度，是难以接收的。我们可以自己创建一个队列的数据结构，把 <code class=\"highlighter-rouge\">remove(at: 0)</code> 的操作简化为 <code class=\"highlighter-rouge\">O(1)</code> 来避免这个问题。</p> \n<p>其次，还是在 <code class=\"highlighter-rouge\">firstRowOutputItems</code> 里，我们每次都对“是否 <code class=\"highlighter-rouge\">buffer</code> 中所有的列都至少有一个元素”进行了判断：<code class=\"highlighter-rouge\">buffer.allSatisfy({ !$0.isEmpty })</code>，这也是一个 <code class=\"highlighter-rouge\">O(n)</code>。一种更简单的方式，是维护一个变量来记录当前已经收到的可合并值的个数：在每次收到值时，判断 <code class=\"highlighter-rouge\">buffer</code> 对应的位置上是否已经有值，来确定需不需要更改这个变量。如果发现已经收到的可合并值的个数与 publishers 的数量相等的话，就说明所有数据都已经准备就绪，可以将它们 <code class=\"highlighter-rouge\">zip</code> 并发送。通过这样一个变量，我们可以把这里的 <code class=\"highlighter-rouge\">O(n)</code> 也简化为 <code class=\"highlighter-rouge\">O(1)</code>。甚至更进一步，可以自然而然地做到去掉上面提到的 <code class=\"highlighter-rouge\">buffer.count</code> 循环，把整个发送流程优化到 <code class=\"highlighter-rouge\">O(1)</code>。</p> \n<h3 id=\"有限-demand\">有限 Demand</h3> \n<p>除了速度优化外，<code class=\"highlighter-rouge\">ZipAll</code> 现在的行为逻辑也有值得商榷的地方。在 <code class=\"highlighter-rouge\">startSubscribing</code> 里，我们简单地使用了 <code class=\"highlighter-rouge\">sink</code> 来对输入的 <code class=\"highlighter-rouge\">publishers</code> 进行订阅。<code class=\"highlighter-rouge\">Sink</code> subscriber 在通过 <code class=\"highlighter-rouge\">receive(subscription:)</code> 接收到订阅后，会立即 <code class=\"highlighter-rouge\">request(_:)</code> <code class=\"highlighter-rouge\">.unlimited</code> 的 <code class=\"highlighter-rouge\">Subscribers.Demand</code>。这其实没有尊重 Combine 事件的拉取模型原则：在我们的 <code class=\"highlighter-rouge\">ZipAll</code> 实现中，下游订阅者可以通过控制 <code class=\"highlighter-rouge\">Demand</code> 来控制收到的值的数量，但是内部的 <code class=\"highlighter-rouge\">publishers</code> 的订阅却可以接受无限多的值。这么一来，一旦在 <code class=\"highlighter-rouge\">ZipAll</code> 内部产生 back pressure，比如外部所需要的值的频率小于内部 publishers 产生值的频率的话，<code class=\"highlighter-rouge\">buffer</code> 将可以大量积压，导致内存问题。实际上，我们可以根据下游订阅者需要的值的数量，来决定我们所需要的 publishers 给我们的值的数量。这样，我们就能将 back pressure 的处理也应用到被 zip 的 publishers 中去，从而避免溢出问题。</p> \n<p>相对于使用 <code class=\"highlighter-rouge\">Sink</code>，我们可以用 <code class=\"highlighter-rouge\">AnySubscriber</code> 来在更细的力度上进行一些控制。比如在收到订阅后只请求有限个事件，在收到新值时尊重下游订阅的 <code class=\"highlighter-rouge\">Demand</code> 等：</p> \n<div class=\"language-swift highlighter-rouge\"> \n <div class=\"highlight\"> \n  <pre class=\"highlight\"><code><span class=\"kt\">AnySubscriber</span><span class=\"p\">(</span>\n    <span class=\"nv\">receiveSubscription</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">subscription</span> <span class=\"k\">in</span>\n        \n    <span class=\"p\">},</span> \n    <span class=\"nv\">receiveValue</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">value</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Subscribers</span><span class=\"o\">.</span><span class=\"kt\">Demand</span> <span class=\"k\">in</span>\n    \n    <span class=\"p\">},</span> \n    <span class=\"nv\">receiveCompletion</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"n\">completion</span> <span class=\"k\">in</span> \n\n    <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n</code></pre> \n </div> \n</div> \n<h2 id=\"总结\">总结</h2> \n<p>可以看出，文中给出的实现有不少缺点，这个参考实现更多地是为了以最简单的方式说明自定义 <code class=\"highlighter-rouge\">Publisher</code> 的一般方法，还远远没有达到可以用在产品代码中的质量。不过，通过这种直接的例子，我们可以总结出一些实现自定义 <code class=\"highlighter-rouge\">Publisher</code> 时的一般经验：</p> \n<ol> \n <li><code class=\"highlighter-rouge\">Publisher</code> 的接口和它需要完成的任务是相对固定的，遵循 Combine 的工作流程图，来实现其中各个职责类型的必要方法即可。</li> \n <li>如果没有特殊的需求，一般我们会将 <code class=\"highlighter-rouge\">Publisher</code> 定义为 <code class=\"highlighter-rouge\">struct</code> 而非 <code class=\"highlighter-rouge\">class</code>，这可以让内存管理和多次订阅的行为更加容易预测。但是，如果一个 <code class=\"highlighter-rouge\">Publisher</code> 有需要共享的话，应该将它定义为引用语义，比如 <a href=\"https://developer.apple.com/documentation/combine/publishers/share\"><code class=\"highlighter-rouge\">Publishers.Share</code></a>。</li> \n <li>相对于 <code class=\"highlighter-rouge\">Publisher</code>，大部分有关时序的操作都被封装到了 <code class=\"highlighter-rouge\">Subscription</code> 里。作为 <code class=\"highlighter-rouge\">Publisher</code> 和 <code class=\"highlighter-rouge\">Subscriber</code> 之间通讯的桥梁，<code class=\"highlighter-rouge\">Subscription</code> 负责大部分逻辑，并维护 Combine 流程的正确性。一般来说，这也是在自定义 <code class=\"highlighter-rouge\">Publisher</code> 时我们花费最多时间的地方。</li> \n <li>想要确保你的自定义 <code class=\"highlighter-rouge\">Publisher</code> 能在 Combine 的世界中运行良好，需要遵守基本的规则。比如尊重下游的 demand，考虑性能因素等。</li> \n</ol> \n<h2 id=\"练习\">练习</h2> \n<p>为了保持和<a href=\"https://onevcat.com/2020/01/customize-publisher/(https://objccn.io/products/swift-ui)\">《SwiftUI 和 Combine 编程》</a>这本书的形式上的类似，我也准备了一些小练习，希望能帮助读者通过实际动手练习掌握本文的内容。</p> \n<h3 id=\"1-优化-zipall\">1. 优化 <code class=\"highlighter-rouge\">ZipAll</code></h3> \n<p>上面提出了关于优化 <code class=\"highlighter-rouge\">ZipAll</code> 的一些想法，包括运行性能的优化和防止 <code class=\"highlighter-rouge\">buffer</code> 堆积等。请你在力所能及的范围内对 <code class=\"highlighter-rouge\">ZipAll</code> 进行修改和优化，并架设一些性能测试来验证你的修改确实发挥了作用。</p> \n<blockquote> \n <p>提示，一般来说，在测试中我们可以使用 <code class=\"highlighter-rouge\">PassthroughSubject</code> 作为数据源，并通过 <a href=\"https://developer.apple.com/documentation/xctest/xctestcase/1496290-measure\"><code class=\"highlighter-rouge\">measure(_:)</code></a> 来设立性能测试。如果在尝试后你还是对如何优化没有概念的话，不妨可以参考 RxSwift 中关于 ZipAll 的这个<a href=\"https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Zip%2BCollection.swift\">高效实现</a>。</p> \n</blockquote> \n<h3 id=\"2-实现-combinelatestall\">2. 实现 <code class=\"highlighter-rouge\">CombineLatestAll</code></h3> \n<p>和 <code class=\"highlighter-rouge\">Zip</code> 相对应的操作是 <code class=\"highlighter-rouge\">CombineLatest</code>，我们对它应该已经非常熟悉了：和 <code class=\"highlighter-rouge\">Zip</code> 等待<strong>所有</strong> <code class=\"highlighter-rouge\">Publisher</code> 都发出值不同，它会在<strong>任意</strong> <code class=\"highlighter-rouge\">Publisher</code> 发出值后即把各个 <code class=\"highlighter-rouge\">Publisher</code> 的最新值合并且向外发送。Combine 中也只实现了 <code class=\"highlighter-rouge\">CombineLatest</code>，<code class=\"highlighter-rouge\">CombineLatest3</code> 和 <code class=\"highlighter-rouge\">CombineLatest4</code>，但是没有更一般的接受任意多个 <code class=\"highlighter-rouge\">Publisher</code> 的 <code class=\"highlighter-rouge\">CombineLatestAll</code>。请你仿照 <code class=\"highlighter-rouge\">ZipAll</code> 的方式，实现自定义的 <code class=\"highlighter-rouge\">CombineLatestAll</code>。</p>","descriptionType":"text/html","publishedDate":"Mon, 20 Jan 2020 01:00:00 +0000","feedId":3176,"bgimg":"https://onevcat.com/assets/images/2019/publisher-subscriber-flow.svg","linkMd5":"c47674d37f17d51d6127a238695ea4de","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn19@2020_5/2020/08/24/21-24-58-477_f762b5692aadc07f.svg","destWidth":0,"destHeight":0,"sourceBytes":5068,"destBytes":5068,"author":"","articleImgCdnMap":{"https://onevcat.com/assets/images/2019/publisher-subscriber-flow.svg":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn19@2020_5/2020/08/24/21-24-58-477_f762b5692aadc07f.svg"},"publishedOrCreatedDate":1598304289203},{"createdTime":"2020-08-25 05:24:49","updatedTime":"2020-08-25 05:24:49","title":"Swift ABI 稳定对我们到底意味着什么","link":"https://onevcat.com/2019/02/swift-abi/","description":"<p>Swift 社区最近最重大的新闻应该就是 ABI 稳定了。这个话题虽然已经讨论了有一阵子了，但随着 Xcode 10.2 beta 的迭代和 Swift 5 的 release 被提上日程，最终 Swift ABI 稳定能做到什么程度，我们开发者能做些什么，需要做些什么，就变成了一个重要的话题。Apple 在这个月接连发布了 <a href=\"https://swift.org/blog/abi-stability-and-more/\">ABI Stability and More</a> 和 <a href=\"https://swift.org/blog/abi-stability-and-apple/\">Evolving Swift On Apple Platforms After ABI Stability</a> 两篇文章来阐述 Swift 5 发布以后 ABI 相关的内容所带来的改变。虽然原文不是很长，但是有些地方上下文没有说太清楚，可能不太容易理解。本文希望对这个话题以问答的形式进行一些总结，让大家能更明白将要发生的事情。</p> \n<h3 id=\"我是一个-app-开发者swift-5-发布以后会怎么样\">我是一个 app 开发者，Swift 5 发布以后会怎么样？</h3> \n<p>简单说，安装 Xcode 10.2，然后<strong>正常迁移</strong>就可以了，和以往 Swift 3 到 Swift 4 需要做的事情差不多。单论 Swift 5 这个版本，不会对你的开发造成什么影响，直到下一个版本 (比如 Swift 5.1) 之前，你几乎不需要关心 ABI 稳定这件事。关于下个 Swift 版本，我们稍后会提到这件事情。</p> \n<h3 id=\"我还是想知道什么是-abi-稳定\">我还是想知道什么是 ABI 稳定？</h3> \n<p>就是 binary 接口稳定，也就是在运行的时候只要是用 Swift 5 (或以上) 的编译器编译出来的 binary，就可以跑在任意的 Swift 5 (或以上) 的 runtime 上。这样，我们就不需要像以往那样在 app 里放一个 Swift runtime 了，Apple 会把它弄到 iOS 和 macOS 系统里。</p> \n<h3 id=\"所以说-app-尺寸会变小\">所以说 app 尺寸会变小？</h3> \n<p><strong>是的</strong>，但是这是 Apple 通过 App Thinning 帮我们完成的，不需要你操心。在提交 app 时，Apple 将会按照 iOS 系统创建不同的下载包。对于 iOS 12.2 的系统，因为它们预装了 Swift 5 的 runtime，所以不再需要 Swift 的库，它们会被从 app bundle 中删掉。对于 iOS 12.2 以下的系统，外甥打灯笼，照旧。</p> \n<p>一个新创建的空 app，针对 <strong>iOS 12.2 打包出来压缩后的下载大小是 26KB</strong>，<strong>而对 iOS 12.0 则是 2.4MB</strong>。如果你使用了很多标准库里的东西，那这个差距会更大 (因为没有用到的标准库的符号会被 strip 掉)，对于一个比较有规模的 app 来说，一般可以减小 10M 左右的体积。</p> \n<h3 id=\"还有什么其他好处么\">还有什么其他好处么？</h3> \n<p>因为系统集成了 Swift，所以大家都用同一个 Swift 了，app 启动的时候也就不需要额外加载 Swift，所以在新系统上会更快更省内存。当然啦，只是针对新系统。</p> \n<p>另外，对于 Apple 的工程师来说，他们终于能在系统的框架里使用 Swift 了。这样一来，很多东西就不必通过 Objective-C wrap 一遍，这会让代码运行效率提高很多。虽然在 iOS 12.2 中应该还没有 Swift 编写的框架，但是我们也许能在不久的将来看到 Swift 被 Apple 自己所使用。等今年 WWDC 的消息吧。</p> \n<h3 id=\"我还想用一段时间的-xcode-101不太想这么快升级\">我还想用一段时间的 Xcode 10.1，不太想这么快升级</h3> \n<p>Xcode 10.1 里的是 Swift 4.2 的编译器，出来的 binary 不是 ABI 稳定的，而且必定打包了 Swift runtime。新的系统发现 app 包中有 Swift runtime 后，就会选择不去使用系统本身的 Swift runtime。这种情况下一切保持和现在不变。旧版本的 Xcode 只有旧版本的 iOS SDK，所以自然你也没有办法用到新系统的 Swift 写的框架，系统肯定不需要在同一个进程中跑两个 Swift runtime。</p> \n<p>简单说，你还可以一直使用 Xcode 10.1 直到 Apple 不再接受它打包的 app。不过这样的话，你不能使用新版本 Swift 的任何特性，也不能从 ABI 稳定中获得任何好处。</p> \n<h3 id=\"我升级了-xcode-102但是还想用-swift-4-的兼容模式会怎么样\">我升级了 Xcode 10.2，但是还想用 Swift 4 的兼容模式，会怎么样？</h3> \n<p>首先你需要弄清楚 Swift 的<strong>编译器版本</strong>和<strong>语言兼容版本</strong>的区别：</p> \n<table> \n <thead> \n  <tr> \n   <th>编译器版本</th> \n   <th>语言兼容版本</th> \n   <th>对应的 Xcode 版本</th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td>Swift 5.0</td> \n   <td>Swift 5.0, 4.2, 4.0</td> \n   <td>Xcode 10.2</td> \n  </tr> \n  <tr> \n   <td>Swift 4.2</td> \n   <td>Swift 4.2, 4.0, 3.0</td> \n   <td>Xcode 10.0, Xcode 10.1</td> \n  </tr> \n  <tr> \n   <td>更多历史版本 …</td> \n   <td>&nbsp;</td> \n   <td>&nbsp;</td> \n  </tr> \n </tbody> \n</table> \n<p>同一个 Xcode 版本默认使用的编译器版本只有一个 (在你不更换 toolchain 的前提下)，当我们在说到“使用 Xcode10.2 的 Swift 4 兼容模式”时，我们其实指的是，使用 Xcode 10.2 搭载的 Swift 5.0 版本的编译器，它提供了 4.2 的语法兼容，可以让我们不加修改地编译 Swift 4.2 的代码。即使你在 Xcode 10.2 中选择语言为 Swift 4，你所得到的二进制依然是 ABI 稳定的。ABI 和你的语言是 Swift 4 还是 Swift 5 无关，只和你的编译器版本，或者说 Xcode 版本有关。</p> \n<blockquote> \n <p>多提一句，即使你选择了 Swift 4 的语言兼容，只要编译器版本 (当然，以及对应的标准库版本) 是 5.0 以上，你依然可以使用 Swift 5 的语法特性 (比如新增加的类型等)。</p> \n</blockquote> \n<h3 id=\"看起来-abi-稳定很美好那么代价呢\">看起来 ABI 稳定很美好，那么代价呢？</h3> \n<p>Good question! 我们在第一个问题里就提到过，一切都会很美好，直到下一个版本。因为 Swift runtime 现在被放到 iOS 系统里了，所以想要升级就没那么容易了。</p> \n<p>在 ABI 稳定之前，Swift runtime 是作为开发工具的一部分，被作为库打包到 app 中的。这样一来，在开发时，我们可以随意使用新版本 Swift 的类型或特性，因为它们的版本是开发者自己决定的。不过，当 ABI 稳定后，Swift runtime 变为了用户系统的一部分，它从开发工具，变为了运行的环境，不再由我们开发者唯一决定。比如说，对应 iOS 13 的 Swift 6 的标准库中添加了某个类型 <code class=\"highlighter-rouge\">A</code>，但是在 iOS 12.2 这个只搭载了 Swift 5 的系统中，并没有这个类型。这意味着我们需要在使用 Swift 的时候考虑设备兼容的问题：如果你需要兼容那些搭载了旧版本 Swift 的系统，那你将无法在代码里使用新版本的 Swift runtime 特性。</p> \n<p>这和我们一直以来适配新系统的 API 时候的情况差不多，在 Swift 5 以后，我们需要等到 deploy target 升级到对应的版本，才能开始使用对应的 Swift 特性。这意味着，我们可能会需要写一些这样的兼容代码：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"c1\">// 假如 Swift 6.0 是 iOS 13.0 的 Swift 版本</span>\n<span class=\"k\">if</span> <span class=\"kd\">#available(iOS 13.0, *)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// Swift 6.0 标准库中存在 A</span>\n    <span class=\"k\">let</span> <span class=\"nv\">a</span> <span class=\"o\">=</span> <span class=\"kt\">A</span><span class=\"p\">()</span>\n<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 不存在 A 时的处理</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>对于“新添加的某个类型”这种程度的兼容，我们可以用上面的方式处理。但是对于更靠近语言层面的一些东西 (比如现在已有的 <code class=\"highlighter-rouge\">Codable</code> 这样的特性)，恐怕适配起来就没有那么简单了。在未来，Deployment target 可能会和 Swift 语言版本挂钩，新的语言特性出现后，我们可能需要等待一段时间才能实际用上。而除了那些纯编译期间的内容外，任何与 Swift runtime 有关的特性，都会要遵守这个规则。</p> \n<h3 id=\"可以像现在一样打包新版本的-swift-runtime-到-app-里然后指定用打包的-swift-版本么\">可以像现在一样打包新版本的 Swift runtime 到 app 里，然后指定用打包的 Swift 版本么</h3> \n<p>不能，对于包含有 Swift runtime 的系统，如果运行的 binary 是 ABI 稳定的，那么就必须使用系统提供的 Swift。这里的主要原因是，Apple 想要保留使用 Swift 来实现系统框架的可能性：</p> \n<ol> \n <li>如果允许两个 Swift runtime (系统自带，以及 app 打包的)，那么这两个运行时将无法互相访问，app 也无法与系统的 Swift 框架或者第三方的 ABI 稳定的框架进行交互。</li> \n <li>如果允许完全替换 Swift runtime，系统的 Swift 框架将执行用户提供的 Swift 标准库中的代码，这将造成重大的安全隐患。</li> \n</ol> \n<h3 id=\"有任何可能性让我能无视系统版本去使用-swift-的新特性么\">有任何可能性让我能无视系统版本，去使用 Swift 的新特性么</h3> \n<p>有，但是相对麻烦，很大程度上也依赖 Apple 是否愿意支持。如果你还记得 iOS 5.0 引入 ARC 时，Apple 为了让 iOS 4.3 和之前的系统也能使用 ARC 的代码，在 deployment target 选到 iOS 4.3 或之前时，会用 static link 的方式打包一个叫做 <code class=\"highlighter-rouge\">libarclite</code> 的库，其中包含了 ARC 所需要的一些 runtime 方法。对于 ABI 稳定后的 Swift，也许可以采用类似做法，来提供兼容。</p> \n<blockquote> \n <p>这种做法在感觉上和 Android 的 <a href=\"https://developer.android.com/topic/libraries/support-library/packages\">Support Library Packages</a> 的方式类似，但是 Apple 似乎不是很倾向于提供这样的官方支持。所以之后要看有没有机会依靠社区力量来提供 Swift 的兼容支持了。</p> \n</blockquote> \n<p>不能第一时间用上新的语言特性，必然会打击大家进行适配和使用新特性的积极性，也势必会影响到语言的发展和快速迭代，可以说这一限制是相当不利的。</p> \n<p>所以，对于一般的 app 开发者来说，ABI 稳定其实就是一场博弈：你现在有更小的 app 尺寸，但是却被限制了无法使用最新的语言特性，除非你提升 app 的 depolyment target。</p> \n<h3 id=\"我是框架开发者abi-稳定后我可以用-binary-形式来发布了么\">我是框架开发者，ABI 稳定后我可以用 binary 形式来发布了么？</h3> \n<blockquote> \n <h4 id=\"2019-12-17-更新\">2019-12-17 更新：</h4> \n <p>从 Swift 5.1 (Xcode 11) 开始，Apple 提供了 XCFramework 支持，来让开发者以二进制的形式发布框架。现在 Swift 已经达到了 module stability。</p> \n</blockquote> \n<p>还不能。ABI 稳定是使用 binary 发布框架的必要非充分条件。框架的 binary 在不同的 runtime 是兼容了，但是作为框架，现在是依靠一个 <code class=\"highlighter-rouge\">.swiftmodule</code> 的二进制文件来描述 API Interface 的，这个二进制文件中包含了序列化后的 AST (更准确说，是 interface 的 SIL)，以及编译这个 module 时的平台环境 (Swift 编译器版本等)。</p> \n<p>ABI 稳定并不意味着编译工具链的稳定，对于框架来说，想要用 binary 的方式提供框架，除了 binary 本身稳定以外，还需要描述 binary 的方式 (也就是现在的 swiftmodule) 也稳定，而这正在开发中。将来，Swift 将为 module 提供文本形式的 <code class=\"highlighter-rouge\">.swiftinterface</code> 作为框架 API 描述，然后让未来的编译器根据这个描述去“编译”出对应的 <code class=\"highlighter-rouge\">.swiftmodule</code> 作为缓存并使用。</p> \n<p>这一目标被称为 module stability，当达到 module stability 后，你就可以使用 binary 来发布框架了。</p> \n<h3 id=\"能总结一下-abi-稳定或者展望一下未来么\">能总结一下 ABI 稳定，或者展望一下未来么？</h3> \n<p>ABI 稳定最大的受益者应该是 Apple，这让 Apple 在自己的生态系统中，特别是系统框架中，可以使用 Swift 来进行实现。在我看来，Swift ABI 稳定为 Apple 开发平台的一场革命奠定了基础。在接下来的几年里，如果你还想要关注 Apple 平台，可能下面几件事情会特别重要：</p> \n<ol> \n <li>Apple 什么时候发布第一个 Swift 写的系统框架</li> \n <li>Apple 什么时候开始提供第一个 Swift only 的 API</li> \n <li>Apple 什么时候开始“锁定” Objective-C 的 SDK，不再为它增加新的 API</li> \n <li>Apple 什么时候开始用 Swift 特性更新现有的 Objective-C SDK</li> \n</ol> \n<p>这些事情也许会在未来几年陆续发生。面对微软从 Win32 API 向 .Net 一路迁移，到今天的 UWP (Universal Windows Platform)，Google 来势汹汹的 Fuchsia 和 Dart，Swift 是 Apple 唯一能与它们抗衡的答案。相比于微软提供的泛型和并行编程模型，Google 的 Flutter 的跨平台的先天优势，Apple 平台基于 Objective-C 的 API 的易用性已然被抛开很远。虽然 Apple 在 2014 年承诺过依然维护 Objective-C，但是经过 Swift 这五年的发展，随着 Swift ABI 的稳定，什么时候如果 Objective-C 成为了继续发展的阻碍，相信 Apple 已经有足够的理由将它抛弃。</p> \n<p>作为 Apple 平台的从业者，我们也许正处在另一个时代变革的开端。</p> \n<blockquote> \n <h4 id=\"2019-12-17-更新-1\">2019-12-17 更新：</h4> \n <p>1 和 2 已经完全实现：Apple 在 WWDC 2019 上高调宣布了一系列 Swift written 和 Swift only 的框架，包括 Combine 和 SwiftUI 等。iOS Swift 开发的新纪元已经开始了。</p> \n</blockquote>","descriptionType":"text/html","publishedDate":"Thu, 21 Feb 2019 01:28:00 +0000","feedId":3176,"bgimg":"","linkMd5":"93780e7d68bab89291ee811aa0b7141d","bgimgJsdelivr":"","metaImg":"","author":"","publishedOrCreatedDate":1598304289192},{"createdTime":"2020-08-25 05:24:49","updatedTime":"2020-08-25 05:24:49","title":"2019 年终总结","link":"https://onevcat.com/2019/12/2019-final/","description":"<p><img src=\"https://onevcat.com/assets/images/2019/2019-final.jpg\" alt=\"\" /></p> \n<p>距离<a href=\"https://onevcat.com/2015/12/2015-final/\">上一次写年终总结</a>已经过去四年时间了。在人生中带上两个小朋友以后，远游这种事情的难度就高企不下了。一年里除了工作以外，活动的轨迹多半也都落在了以家为圆心两公里为半径的圆周里。看着小朋友们一天天长大，在被她们的想象力和好奇心折服的同时，也不可避免地感觉到了自己的“成熟”…嗯，或者直白些，不可避免地感觉到了自己在变老。</p> \n<p>对我来说，2019 年是很有意思的一年，它是充满“矛盾”的一年。我能认知的世界在变大，但我实际生活的圈子却在变小。世界的变动非常剧烈，在中美争霸背景下，被时代洪流的裹挟向前的我们，其实很难对抗宏观层面的规律。而对这个世界的认知范围，往往决定了我们在这一变局下会去往何方。但同时，偏安一隅的日本在经济上的孤岛效应，在这个大时代中却偶然地变成了一个避风港，把这些影响缩小了。庆幸的同时，有一些不甘；但不甘的同时，却又有些许惧怕。这样的矛盾的心情，大概还会持续一段时间。</p> \n<p>矫情完毕，回到年终总结。因为心绪比较散乱，所以我挑选并加注了一些今年的“有意思”的自摄照片，希望能够作为今年思考的记录。最后，我也会整理一下今年的书单和好物目录，算是传统节目。</p> \n<h2 id=\"照片\">照片</h2> \n<h3 id=\"2019-年-1-月-1-日--冲绳那覇那覇客运码头\">2019 年 1 月 1 日 @ 冲绳・那覇・那覇客运码头</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-01-01.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>新年的第一个早晨，在那霸码头等船。朝阳虽然被云遮住，但它们正被吹走。云后透出的金色阳光，均匀地铺在略显陈旧，但整齐码放的集装箱上，呈现出颇具冲击力的色彩，给人“烈士暮年，壮心不已”的感觉。</p> \n</blockquote> \n<p>彼时彼刻：孟晚舟女士刚被捕一月；中美贸易战箭在弦上，蓄势待发；习川互致贺信庆祝新年和40年建交。大多数人在 2018 经历的寒冬之后，都期盼能迎来春天，但是后续的展开却不遂人愿。此时此刻：孟的引渡听证将要开始，但事件结束还遥遥无期；贸易战已打得如火如荼，一地鸡毛；中美的世界领导权争夺已经摆上台面，闷声发展的阶段似乎已经远去。世界正在经历着剧烈的变更，也许我们不自觉，但这个时代里的每件事情的影响，在历史上也许都会远超我们的想象。到底我们会去向何方，到底我们能去向何方？</p> \n<hr /> \n<h3 id=\"2019-年-3-月-31-日--千叶鸭川鸭川海洋世界\">2019 年 3 月 31 日 @ 千叶・鸭川・鸭川海洋世界</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-03-31.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>妹妹拿到了好吃的冰激凌，主动与姐姐分食。</p> \n</blockquote> \n<p>作为独生子女的一代，以前对于这种兄弟姐妹之间的情愫只能依靠想象来做猜测。不过现在有机会看到两个小朋友之间的各种“相爱相杀”，也算是很有趣的一件事情。四岁半的姐姐和两岁半的妹妹今后种种，还希望你们互相多一点照应包容，少一些争执纷扰，共同去品尝和体会这段奇妙的人生。</p> \n<hr /> \n<h3 id=\"2019-年-4-月-3-日--神奈川川崎小川町樱花道\">2019 年 4 月 3 日 @ 神奈川・川崎・小川町樱花道</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-04-03.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>四月初是神奈川樱花满开之际，家门前的寻常街道亦堪绝景。满满在拿到了她的第一个相机后，兴奋地跑到街上随意乱按，便有了这张《川崎夜樱图》。</p> \n</blockquote> \n<p>当代科技和大规模的工业，让曾经高不可及的物件寻常不已。至今我仍会唏嘘，小时候一个废旧的不能使用的相机，作为玩具陪伴了我多年。而如今，只需要花一点小钱，就可以买到质量不错的，专门为小朋友准备的数码相机。当一代人开始提到“相片”时，第一反应是找到手机上那个带花儿的 app；看到显示屏时，上来就用手指划来划去。她们才是数码时代的原生代，而她们的生活，注定将于我们不同。这是一种值得尊重的生活方式，而她们也注定是值得尊重的一代新人类。</p> \n<hr /> \n<h3 id=\"2019-年-4-月-13-日--东京迪士尼乐园卡通城\">2019 年 4 月 13 日 @ 东京迪士尼乐园・卡通城</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-04-13.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>妹妹看到姐姐的小相机后羡慕不已，吵着也要了一台，还带去了迪士尼乐园。在排队时，她从自己的视角拍下了这张照片。</p> \n</blockquote> \n<p>兴许这只是妹妹随手一拍，而后她的注意力便会立即转移到路边的小草，漂亮的栏杆。但又有谁在这一时一刻注意到了她的视角呢？</p> \n<p>立场不同，看到的事物自然也会不同。但是就是这般简单的道理，很多时候我们这些大人都有迷惘。你看到的是人头攒动、熙熙攘攘、森罗万象，但有人看到的是孤苦伶仃、杂乱无章，甚至重重压迫。</p> \n<p>无数鸡汤告诉我们要换位思考，但这又何其容易！人生的高度，有传承，有天分，有努力，有运气。高度不够的芸芸大众，要活好这一辈子已是不易，时刻为至亲至爱之人加以考虑，都是捉襟见肘，更遑论博爱天下之善为；高高在上之人想要苦天下之所苦，乐天下之所乐，要付出的努力恐怕不输上这高位所需。我们所在追寻的这种风度，在当今社会，不过只是水中花镜中月罢了。</p> \n<hr /> \n<h3 id=\"2019-年-4-月-27-日--北京清华大学某教授办公室\">2019 年 4 月 27 日 @ 北京・清华大学・某教授办公室</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-04-27.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>跟着爸爸妈妈参加完一系列“无聊的”毕业十周年校庆活动后，满满在教授爷爷的办公室里躺倒在了两把椅子拼凑的临时行军床上。胆敢在教授老师们的办公室里公然睡觉，还不被责罚的，大概只有这种初生牛犊了。</p> \n</blockquote> \n<p>转眼本科毕业已经十年。当初风华正茂，意气风发的青年，现在已经大腹便便，油腻不堪。大学的光阴是美好的，但是当我真正意识到这一点时，毕业已经过去太久。如果要问，如果给我一架哆啦 A 梦的时光机，你想去哪里？我大概会回答送我到背着行李告别父母的入学仪式那天。那是新的人生的开始，也是新的诗篇的序章。我大概会有机会谱出更好的旋律和节奏，成为一个更有用的人。</p> \n<p>这个世界并没有时光机，很多事情只能留下回忆。 不过，要是问我关于这段回忆的感受，那我的答案是：</p> \n<p>有过遗憾，但无后悔。这是因为，新的篇章，每天都可以开始书写。</p> \n<hr /> \n<h3 id=\"2019-年-5-月-7-日--东京新宿未来塔line-办公室\">2019 年 5 月 7 日 @ 东京・新宿未来塔・LINE 办公室</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-05-07.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>普通的一天上午，空空如也的 LINE 办公室，我的工位就在最深处的角落。如果不说，很难想象这已经是标准上班时间过后接近一小时的场面。裁量劳动制下的弹性工作时间，意味着员工可以选择自由的上下班时间，而在 LINE 里，加班可以说是比较罕见的。</p> \n</blockquote> \n<p>996.ICU 是今年一个热点话题。我从唯物辨证法里获益良多，所以也习惯了用唯物辨证法来分析问题。当然，我不想去当一个卫道士，为 996 寻找千百理由；同样，我也不想再极口项斯，天天夸耀 LINE 的弹性工作。</p> \n<p>一个社会中有无数个例，万千的个例会交汇，会集合，会碰撞。当这些个例的棱角被磨平后，它们互相挤压作用，呈现出一种社会学上的共性。身处变局中的我们，不可能去决定这个共性。如果不想被磨平棱角和相互挤压，大概就只有去做那个闪闪发光的个例。</p> \n<hr /> \n<h3 id=\"2019-年-5-月-27-日--杭州阿里巴巴西溪园区员工食堂\">2019 年 5 月 27 日 @ 杭州・阿里巴巴西溪园区・员工食堂</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-05-27.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>中午十二点，食堂正在准备营业。已经有零零星星的人开始吃饭，但真正的人潮还要等到半小时后。偌大的园区，依靠自行车穿梭在楼宇之间，食堂体育馆，这一切仿佛把人带回了校园生活。不，也许这里的很多人，就没有离开过校园生活。</p> \n</blockquote> \n<p>在东京的话，是很难想象能有这么一块地方，让一个公司建立起这样一套完善的配套机制的。阿里巴巴创造的商业奇迹大概很难再复制，因为这个世界上找不出第二个有着这样统一语言，统一市场，统一文化的地方了。我只能心怀敬畏去仰视这个商业帝国，并没有立场，也没有能力去对它进行什么评价。</p> \n<p>希望在这里工作的人，能追寻到自己的梦想；希望在这里发生的事，能带领我们的时代前进。</p> \n<hr /> \n<h3 id=\"2019-年-5-月-29-日--北京清华大学职业发展指导中心\">2019 年 5 月 29 日 @ 北京・清华大学・职业发展指导中心</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-05-29.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>因为 LINE 2020 校园招聘回到学校，向学弟学妹们介绍 LINE 的技术背景和企业文化，期望能够帮助工作寻找到合适的跨国人才。</p> \n</blockquote> \n<p>能站在清华大学的校徽后面讲上个十来二十分钟，可以算是我的夙愿了。虽然最后是以招聘会这种形式实现的，但我也心存感激。不管是校庆，还是宣讲，每次回到学校，总是觉得自己想要找回一些什么东西。</p> \n<p>可以感受到学校逐年都在进步，95 后甚至是 00 后的学弟学妹们的眼界，比我们那时候不知道高到哪里去了。他们所思考的，他们所担忧的，正是这个时代所思考和担忧的。这是这个时代的幸事，一批年轻有为的人，正在思索着自己和国家的未来。这些我对他们的了解，远超我的想象。</p> \n<hr /> \n<h3 id=\"2019-年-6-月-4-日--神奈川川崎车站人行天桥\">2019 年 6 月 4 日 @ 神奈川・川崎・车站人行天桥</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-06-04.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>姐妹俩赖床导致来不及在家吃早餐。上学路上，一人<a href=\"https://zh.moegirl.org/zh-hans/叼面包\">叼一片面包</a>相视而笑。不过直到吃完也没有在街角撞到奇怪的东西或者变成魔法少女，这让两人非常失望。</p> \n</blockquote> \n<p>日本的保育制度十分完善，小朋友们都有稳定和专业的保育园可以托付，这让我们得以用双职工的家庭养育两个小孩，也不至于太过狼狈，十月开始保育园的<a href=\"https://www.youhomushouka.go.jp\">收费负担也有所下降</a>。可以说，在各个方面上，都能体会到日本政府对于生育率和人口问题发自内心的担忧。</p> \n<hr /> \n<h3 id=\"2019-年-6-月-23-日--神奈川新-川崎住宅公園\">2019 年 6 月 23 日 @ 神奈川・新 川崎住宅公園</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-06-23.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>新家外观的效果图初稿。</p> \n</blockquote> \n<p>现在的住处无法保证两个小朋友今后有各自的房间，也确实略显狭小了，因此今年都在寻找更合适的房子。一户建在日本是普通的居民住宅，很多时候反而高层公寓是更高档的存在。不过对于中国人来说，拥有一栋自己的小楼的诱惑，还是难以抵挡的。</p> \n<p>一开始是想寻找合适的造好的买，但是不论从土地大小和建筑格局，总是没有找到称心如意的。所以最后决定从购入土地开始，走注文住宅的路子，让建筑公司帮忙设计和新建。期间完整地经历了一次在日本买地盖房的全过程，算是很有趣的体验。在来回十几次的调整设计之后，总算是能按照心愿确定细节，不出意外的话，大概明年就能入住。</p> \n<hr /> \n<h3 id=\"2019-年-7-月-1-日--神奈川川崎家中\">2019 年 7 月 1 日 @ 神奈川・川崎・家中</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-07-01.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>在家中关注香港局势。香港反送中运动高潮之一，示威者冲入立法会并进行喷涂，这些活动和行为通过视频直播传遍全球。</p> \n</blockquote> \n<p>得益于直播行业的兴起和普及，世界上任何地方发生的事情，几乎都能被迅速传播。对于香港的问题，在不同立场上往往会选择性地只看到事实的某个侧面，进而很容易得到不同的结论。这种事件，当下是难以说清的，它所带来的历史成本与公允价值判断是无法估量的。</p> \n<p>如果真要说“时代革命”，那一定会是新的科技和生产方式带来的，也许是 AI 和机器人的全面发力，也许是某个不可想象的医疗突破，也许是信息整合调度方式的变更。基于 4G 的直播技术的可以说已经完全成熟。它确实给人们的生活带来了变化，但算不上变革。近几年回国开会，大家张口闭口谈的都是 5G。在当下所谓“后移动互联网”时代，大家都在思考 5G 能做什么，会不会带来下一个风口。我的判断是，5G 当然也会带来变化，但却不会是变革。</p> \n<hr /> \n<h3 id=\"2019-年-7-月-18-日--东京新宿未来塔line-办公室\">2019 年 7 月 18 日 @ 东京・新宿未来塔・LINE 办公室</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-07-18.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>FaceApp 中的特效，将一张照片中的人“老龄化”处理，效果相当惊人。</p> \n</blockquote> \n<p>AI 这几年真的热到沸腾了，图像风格化和这类图片处理的 app 常常能成为热点。我个人倾向于把 AI 和机器学习叫做“新时代的算法”：这年头熟练红黑树大概率并不能帮你创造一些什么，但是如果能熟练使用几种机器学习的方法，很可能可以帮助这个世界变得更好。</p> \n<p>而且老年版里居然为我保留了头发，没有被处理成秃子，真的很感谢！</p> \n<hr /> \n<h3 id=\"2019-年-9-月-20-日--台北松山机场捷运站\">2019 年 9 月 20 日 @ 台北・松山机场捷运站</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-09-20.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>在便利店付钱时，误将 100 人民币当成了 100 新台币交给店员，被好心退回。从颜色到布局到款式，两种货币的 100 元都过于相似了吧 XD。</p> \n</blockquote> \n<p>到台北参加了 iPlayground 的会议。和 @Swift 类似，这也是一场由开发者和志愿者自行举办的 Swift 技术会议。从大陆到台湾的自由行已经被暂停了，不过从日本过去还并没有什么阻碍。这是我第二次到台湾，会方给安排了台大对面的夜市中心。我只想说，楼下陈三鼎的黑糖青蛙撞奶真香！</p> \n<hr /> \n<h3 id=\"2019-年-10-月-11-日--神奈川川崎lefront-购物广场\">2019 年 10 月 11 日 @ 神奈川・川崎・LeFRONT 购物广场</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-10-11.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>“史上最强台风”，“云系覆盖日本全境”，“预计东京 8000 人伤亡”，<a href=\"https://zh.wikipedia.org/wiki/颱風海貝思_(2019年)\">台风 19 号</a>来临前，商场停业，电车停运，整个东日本如临大敌。</p> \n</blockquote> \n<p>55 条河流 79 处决堤，93 人死亡 468 人受伤。自从 311 大地震造成了惨痛的教训后，日本对于自然灾害的重视已经到了新的高度。但即使这样，即使发展出了高度的文明，我们人类，在大自然面前依然是渺小的存在。</p> \n<hr /> \n<h3 id=\"2019-年-12-月-24-日--神奈川川崎家中\">2019 年 12 月 24 日 @ 神奈川・川崎・家中</h3> \n<p><img src=\"https://onevcat.com/assets/images/2019/2019-final-2019-12-24.jpg\" alt=\"\" /></p> \n<blockquote> \n <p>看完《冰雪奇缘 2》的妹妹总是以 Anna 自居，而姐姐也乐得当 Elsa。今年妹妹收到了 Anna 公主的紫红色披肩和宝石蓝裙子。自己终于能和娃娃穿成一样了，非常满意。</p> \n</blockquote> \n<p>小朋友们现在是从心底相信圣诞老人存在的，今年满满还专门给圣诞老人寄了愿望卡片，并且承诺要做一个好孩子。不过，孩子们终究会慢慢长大，她们会知道圣诞老人也许从不曾存在：一直都是爸爸妈妈在挑选礼物，并鬼鬼祟祟地把它们藏在袜子和衣柜里；她们寄给圣诞老人的卡片也从没有离开过这个家，而是被收藏在了满是稚嫩作品的盒子里。</p> \n<p>但那又有什么关系呢？“圣诞老人总会驾驶着麋鹿拉的雪橇，在这一天晚上把礼物派发给每一个小朋友”，对“圣诞老人”来说，这是一种无条件的信任，对小朋友们来说，这是一种无终止的承诺。</p> \n<p>有诗歌，有幻想，有浪漫，有希望，有爱。圣诞老人，其实真的存在。</p> \n<hr /> \n<h2 id=\"好书\">好书</h2> \n<p>今年读过并且觉得比较有意思的一些课外书，以及一句话评语。技术类书籍几乎都很无聊，就不列举了。</p> \n<ul> \n <li><a href=\"https://book.douban.com/subject/30375911/\">日本国紀 by 百田尚樹</a> - 日语能力见长所带来的显而易见的好处是，我几乎已经可以阅读第一手的日语书籍和博客了。想要了解身处的国家以及这个国家国民的思维，一个最好的方式就是读史。这本《日本国紀》算是对日本人 DNA 的由来，做了一次剖析，也让我看到日本右翼政治一些“有趣”的地方。</li> \n <li><a href=\"https://book.douban.com/subject/27021578/\">大国的崩溃 by 沙希利·浦洛基</a> - 一本关于苏联解体过程的纪实和解读。在当下中美格局里，或多或少能从中看到一些影子。对于判断当下的局势也许会有帮助。</li> \n <li><a href=\"https://book.douban.com/subject/34888158/\">中国经济 2020 by 王德培</a> - 经济类的图书一般都很难看，因为学派出身和官方口径往往会左右笔者的视角。不过这本书相对轻松，让“经济外行人”也能凑个热闹。</li> \n <li><a href=\"https://book.douban.com/subject/3533221/\">非暴力沟通 by 马歇尔·卢森堡</a> - 本来是为了减少和小朋友们吵架的机率开始读的，但是最后发现其实运用到一般生活里也很合适。“暴力沟通”并不只有吵架，也有“不合作”或者“自我发泄”这样的“冷暴力沟通”，它们甚至很多时候比争吵发泄更加严重。这是一本情绪管理的好书，而且非常实用。</li> \n</ul> \n<hr /> \n<h2 id=\"好物\">好物</h2> \n<p>今年买的一些觉得比较值得的东西，以及一句话评语。</p> \n<ul> \n <li><a href=\"https://www.j-urban.jp\">住友不动产 J・URBAN 注文住宅</a> - 有生以来买的最贵的商品。不过从先期设计到来回交流，看着最初的想法逐渐成型，还是很有成就感。</li> \n <li><a href=\"https://www.dji.com/mavic-mini\">御Mavic Mini 航拍小飞机</a> - 随带随飞的迷你款无人机，以前买过 Phantom，但是那个实在是太大太显眼，想要带出门需要做很多心理斗争。但是 Mini 完全没有这方面的顾虑，就一个手机大小，非常适合轻度用户。</li> \n <li><a href=\"https://www.visionkids.com/happicamu-kids-camera\">VisionKids HappiCAMU 儿童相机</a> - 画风可爱，受到小朋友们的欢迎。不过如果太暴力的话，会有点容易坏。</li> \n <li><a href=\"https://www.logitech.com.cn/zh-cn/product/r500-laser-presentation-remote\">罗技 R500 激光笔无线演示器</a> - 今年做各种 presentation 比较多，科普类的演讲还好，但是如果涉及到一些代码的话，有时很难说清楚。另外，每次翻页的时候要碰键盘，也让演讲流畅性大打折扣。如果有演讲场合，一个遥控器还是很必要。泛用性和性价比看来的话，我对现在用的 R500 很满意。</li> \n <li><a href=\"https://www.kickstarter.com/projects/bullet/bull3t-worlds-most-powerful-micro-flashlight-ever/description\">BULL3T 便携式微型电筒</a> - 挂在钥匙链上使用。晚上小朋友睡觉后不方便开灯，手机也不在身边的时候就需要它帮忙。另外，走夜路的时候担心手机电池不足时，小电筒也能提供足够和安心的照明。</li> \n <li><a href=\"https://www.kickstarter.com/projects/keytron/keychron-k2-a-sleek-compact-wireless-mechanical-ke/description\">Keychron K2 机械键盘</a> - 作为机械键盘玩家，看到有众筹的键盘，而且还无缝支持 Mac，自然是要下手的。买之前已经做好了这是一款炫酷键盘的心理准备，但是实际上手后发现比想象得还要炫酷…只能用来打游戏，用来写代码的话实在太中二了。</li> \n</ul> \n<p>2019，以上，再见。2020，你好，未来。</p>","descriptionType":"text/html","publishedDate":"Tue, 31 Dec 2019 05:22:00 +0000","feedId":3176,"bgimg":"https://onevcat.com/assets/images/2019/2019-final.jpg","linkMd5":"ea9bda7de74ac05eb1a4d213ce3f1c77","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn5@2020_2/2020/08/24/21-24-59-701_6bb1b66a2436dae5.webp","destWidth":3024,"destHeight":1580,"sourceBytes":201885,"destBytes":127262,"author":"","articleImgCdnMap":{"https://onevcat.com/assets/images/2019/2019-final.jpg":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn5@2020_2/2020/08/24/21-24-59-701_6bb1b66a2436dae5.webp","https://onevcat.com/assets/images/2019/2019-final-2019-01-01.jpg":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn71@2020_5/2020/08/24/21-25-04-607_7c8d19a0fee69292.webp","https://onevcat.com/assets/images/2019/2019-final-2019-03-31.jpg":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn3@2020_4/2020/08/24/21-25-03-794_c80a8da61a94a667.webp","https://onevcat.com/assets/images/2019/2019-final-2019-04-03.jpg":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn60@2020_6/2020/08/24/21-25-04-709_32ccc85e3ca2ebb7.webp","https://onevcat.com/assets/images/2019/2019-final-2019-04-13.jpg":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn92@2020_6/2020/08/24/21-25-04-014_680c41d2f88e4d83.webp","https://onevcat.com/assets/images/2019/2019-final-2019-04-27.jpg":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn87@2020_2/2020/08/24/21-25-04-289_0d6dce813bdca683.webp","https://onevcat.com/assets/images/2019/2019-final-2019-05-07.jpg":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn100@2020_3/2020/08/24/21-25-04-651_6c8d1b5ef418f642.webp","https://onevcat.com/assets/images/2019/2019-final-2019-05-27.jpg":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn64@2020_2/2020/08/24/21-25-04-069_cf0c36f0a988b510.webp","https://onevcat.com/assets/images/2019/2019-final-2019-05-29.jpg":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn39@2020_6/2020/08/24/21-25-05-269_a89f9e1960e6d913.webp","https://onevcat.com/assets/images/2019/2019-final-2019-06-04.jpg":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn68@2020_3/2020/08/24/21-25-04-948_b02e9ec22fdbf48a.webp","https://onevcat.com/assets/images/2019/2019-final-2019-06-23.jpg":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn47@2020_2/2020/08/24/21-25-04-920_538078730d222154.webp","https://onevcat.com/assets/images/2019/2019-final-2019-07-01.jpg":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn56@2020_1/2020/08/24/21-25-03-924_7d3b717a7418f1ec.webp","https://onevcat.com/assets/images/2019/2019-final-2019-07-18.jpg":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn52@2020_6/2020/08/24/21-25-05-855_097f0013c0ca1dca.webp","https://onevcat.com/assets/images/2019/2019-final-2019-09-20.jpg":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn76@2020_5/2020/08/24/21-25-05-477_07a13635d119267d.webp","https://onevcat.com/assets/images/2019/2019-final-2019-10-11.jpg":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn6@2020_2/2020/08/24/21-25-04-975_2d1e79061eb44bf4.webp","https://onevcat.com/assets/images/2019/2019-final-2019-12-24.jpg":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn30@2020_2/2020/08/24/21-25-04-918_ec12321c324bc6d3.webp"},"publishedOrCreatedDate":1598304289182},{"createdTime":"2020-08-25 05:24:49","updatedTime":"2020-08-25 05:24:49","title":"使用 protocol 和 callAsFunction 改进 Delegate","link":"https://onevcat.com/2020/03/improve-delegate/","description":"<p>2018 年 3 月的时候我写过一篇在 Swift 中如何<a href=\"https://xiaozhuanlan.com/topic/6104325798\">改进 Delegate Pattern</a> 的文章，主要思想是用遮蔽变量 (shadow variable) 声明的方式，来保证 <code class=\"highlighter-rouge\">self</code> 变量可以被常时地标记为 <code class=\"highlighter-rouge\">weak</code>。本文中，为了保证没有看过原文的读者能处在同一频道，我会先 (再次) 简单介绍一下这种方法。然后，结合 Swift 5.2 的新特性提出一些小的改进方式。</p> \n<h2 id=\"delegate\">Delegate</h2> \n<p>简单说，为了避免繁琐老式的 <code class=\"highlighter-rouge\">protocol</code> 定义和实现，我们可能更倾向于选择提供闭包的方式完成回调。比如在一个收集用户输入的自定义 view 中，提供一个外部可以设置的函数类型变量 <code class=\"highlighter-rouge\">onConfirmInput</code>，并在合适的时候调用它：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"kt\">TextInputView</span><span class=\"p\">:</span> <span class=\"kt\">UIView</span> <span class=\"p\">{</span>\n\n    <span class=\"kd\">@IBOutlet</span> <span class=\"k\">weak</span> <span class=\"k\">var</span> <span class=\"nv\">inputTextField</span><span class=\"p\">:</span> <span class=\"kt\">UITextField</span><span class=\"o\">!</span>\n    <span class=\"k\">var</span> <span class=\"nv\">onConfirmInput</span><span class=\"p\">:</span> <span class=\"p\">((</span><span class=\"kt\">String</span><span class=\"p\">?)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Void</span><span class=\"p\">)?</span>\n\n    <span class=\"kd\">@IBAction</span> <span class=\"kd\">func</span> <span class=\"nf\">confirmButtonPressed</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">sender</span><span class=\"p\">:</span> <span class=\"kt\">Any</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nf\">onConfirmInput</span><span class=\"p\">?(</span><span class=\"n\">inputTextField</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>在 <code class=\"highlighter-rouge\">TextInputView</code> 的 controller 中，检测 input 确定事件就不需要一堆 <code class=\"highlighter-rouge\">textInputView.delegate = self</code> 和 <code class=\"highlighter-rouge\">textInputView(_:didConfirmText:)</code> 之类 的麻烦事了，可以直接设置 <code class=\"highlighter-rouge\">onConfirmInput</code>：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"kt\">ViewController</span><span class=\"p\">:</span> <span class=\"kt\">UIViewController</span> <span class=\"p\">{</span>\n\n    <span class=\"kd\">@IBOutlet</span> <span class=\"k\">weak</span> <span class=\"k\">var</span> <span class=\"nv\">textLabel</span><span class=\"p\">:</span> <span class=\"kt\">UILabel</span><span class=\"o\">!</span>\n\n    <span class=\"k\">override</span> <span class=\"kd\">func</span> <span class=\"nf\">viewDidLoad</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">super</span><span class=\"o\">.</span><span class=\"nf\">viewDidLoad</span><span class=\"p\">()</span>\n        <span class=\"k\">let</span> <span class=\"nv\">inputView</span> <span class=\"o\">=</span> <span class=\"kt\">TextInputView</span><span class=\"p\">(</span><span class=\"nv\">frame</span><span class=\"p\">:</span> <span class=\"cm\">/*...*/</span><span class=\"p\">)</span>\n        <span class=\"n\">inputView</span><span class=\"o\">.</span><span class=\"n\">onConfirmInput</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"n\">text</span> <span class=\"k\">in</span> \n            <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">textLabel</span><span class=\"o\">.</span><span class=\"n\">text</span> <span class=\"o\">=</span> <span class=\"n\">text</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">view</span><span class=\"o\">.</span><span class=\"nf\">addSubview</span><span class=\"p\">(</span><span class=\"n\">inputView</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>但是这引入了一个 retain cycle！<code class=\"highlighter-rouge\">TextInputView.onConfirmInput</code> 持有 <code class=\"highlighter-rouge\">self</code>，而 <code class=\"highlighter-rouge\">self</code> 通过 <code class=\"highlighter-rouge\">view</code> 持有 <code class=\"highlighter-rouge\">TextInputView</code> 这个 sub view，内存将会无法释放。</p> \n<p>当然，解决方法也很简单，我们只需要在设置 <code class=\"highlighter-rouge\">onConfirmInput</code> 的时候使用 <code class=\"highlighter-rouge\">[weak self]</code> 来将闭包中的 <code class=\"highlighter-rouge\">self</code> 换为弱引用即可：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"n\">inputView</span><span class=\"o\">.</span><span class=\"n\">onConfirmInput</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"p\">[</span><span class=\"k\">weak</span> <span class=\"k\">self</span><span class=\"p\">]</span> <span class=\"n\">text</span> <span class=\"k\">in</span>\n    <span class=\"k\">self</span><span class=\"p\">?</span><span class=\"o\">.</span><span class=\"n\">textLabel</span><span class=\"o\">.</span><span class=\"n\">text</span> <span class=\"o\">=</span> <span class=\"n\">text</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>这为使用 <code class=\"highlighter-rouge\">onConfirmInput</code> 这样的闭包变量加上了一个前提：你大概率需要将 <code class=\"highlighter-rouge\">self</code> 标记为 <code class=\"highlighter-rouge\">weak</code> 以避免犯错，否则你将写出一个内存泄漏。这个泄漏无法在编译期间定位，运行时也不会有任何警告或者错误，这类问题也极易带到最终产品中。在开发界有一句话是真理：</p> \n<blockquote> \n <p>如果一个问题可能发生，那么它必然会发生。</p> \n</blockquote> \n<p>一个简单的 <code class=\"highlighter-rouge\">Delegate</code> 类型可以解决这个问题：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"kt\">Delegate</span><span class=\"o\">&lt;</span><span class=\"kt\">Input</span><span class=\"p\">,</span> <span class=\"kt\">Output</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n    <span class=\"kd\">private</span> <span class=\"k\">var</span> <span class=\"nv\">block</span><span class=\"p\">:</span> <span class=\"p\">((</span><span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Output</span><span class=\"p\">?)?</span>\n    <span class=\"kd\">func</span> <span class=\"n\">delegate</span><span class=\"o\">&lt;</span><span class=\"kt\">T</span><span class=\"p\">:</span> <span class=\"kt\">AnyObject</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">on</span> <span class=\"nv\">target</span><span class=\"p\">:</span> <span class=\"kt\">T</span><span class=\"p\">,</span> <span class=\"nv\">block</span><span class=\"p\">:</span> <span class=\"p\">((</span><span class=\"kt\">T</span><span class=\"p\">,</span> <span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Output</span><span class=\"p\">)?)</span> <span class=\"p\">{</span>\n        <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">block</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"p\">[</span><span class=\"k\">weak</span> <span class=\"n\">target</span><span class=\"p\">]</span> <span class=\"n\">input</span> <span class=\"k\">in</span>\n            <span class=\"k\">guard</span> <span class=\"k\">let</span> <span class=\"nv\">target</span> <span class=\"o\">=</span> <span class=\"n\">target</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"kc\">nil</span> <span class=\"p\">}</span>\n            <span class=\"k\">return</span> <span class=\"nf\">block</span><span class=\"p\">?(</span><span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">input</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kd\">func</span> <span class=\"nf\">call</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">input</span><span class=\"p\">:</span> <span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Output</span><span class=\"p\">?</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nf\">block</span><span class=\"p\">?(</span><span class=\"n\">input</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>通过设置 <code class=\"highlighter-rouge\">block</code> 时就将 <code class=\"highlighter-rouge\">target</code> (通常是 <code class=\"highlighter-rouge\">self</code>) 做 <code class=\"highlighter-rouge\">weak</code> 化处理，并且在调用 <code class=\"highlighter-rouge\">block</code> 时提供一个 weak 后的 <code class=\"highlighter-rouge\">target</code> 的变量，就可以保证在调用侧不会意外地持有 <code class=\"highlighter-rouge\">target</code>。举个例子，上面的 <code class=\"highlighter-rouge\">TextInputView</code> 可以重写为：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"kt\">TextInputView</span><span class=\"p\">:</span> <span class=\"kt\">UIView</span> <span class=\"p\">{</span>\n    <span class=\"c1\">//...</span>\n    <span class=\"k\">let</span> <span class=\"nv\">onConfirmInput</span> <span class=\"o\">=</span> <span class=\"kt\">Delegate</span><span class=\"o\">&lt;</span><span class=\"kt\">String</span><span class=\"p\">?,</span> <span class=\"kt\">Void</span><span class=\"o\">&gt;</span><span class=\"p\">()</span>\n    \n    <span class=\"kd\">@IBAction</span> <span class=\"kd\">func</span> <span class=\"nf\">confirmButtonPressed</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">sender</span><span class=\"p\">:</span> <span class=\"kt\">Any</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">onConfirmInput</span><span class=\"o\">.</span><span class=\"nf\">call</span><span class=\"p\">(</span><span class=\"n\">inputTextField</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>使用时，通过 <code class=\"highlighter-rouge\">delegate(on:)</code> 完成订阅：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"n\">inputView</span><span class=\"o\">.</span><span class=\"n\">onConfirmInput</span><span class=\"o\">.</span><span class=\"nf\">delegate</span><span class=\"p\">(</span><span class=\"nv\">on</span><span class=\"p\">:</span> <span class=\"k\">self</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"p\">(</span><span class=\"k\">self</span><span class=\"p\">,</span> <span class=\"n\">text</span><span class=\"p\">)</span> <span class=\"k\">in</span>\n    <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">textLabel</span><span class=\"o\">.</span><span class=\"n\">text</span> <span class=\"o\">=</span> <span class=\"n\">text</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>闭包的输入参数 <code class=\"highlighter-rouge\">(self, text)</code> 和闭包 body <code class=\"highlighter-rouge\">self.textLabel.text</code> 中的 <code class=\"highlighter-rouge\">self</code>，<strong>并不是</strong>原来的代表 controller 的 self，而是由 <code class=\"highlighter-rouge\">Delegate</code> 把 <code class=\"highlighter-rouge\">self</code> 标为 <code class=\"highlighter-rouge\">weak</code> 后的参数。因此，直接在闭包中使用这个遮蔽变量 <code class=\"highlighter-rouge\">self</code>，也不会造成循环引用。</p> \n<p>到这里为止的原始版本 <code class=\"highlighter-rouge\">Delegate</code> 可以在<a href=\"https://gist.github.com/onevcat/3c8f7c4e8c96f288854688cf34111636/3674c944a420a09f473726043856f28c9c1014d0\">这个 Gist</a> 里找到，加上空行一共就 21 行代码。</p> \n<h2 id=\"问题和改进\">问题和改进</h2> \n<p>上面的实现有三个小瑕疵，我们对它们进行一些分析和改进。</p> \n<h3 id=\"1-更自然i的调用\">1. 更自然i的调用</h3> \n<p>现在，对 delegate 的调用时不如闭包变量那样自然，每次需要去使用 <code class=\"highlighter-rouge\">call(_:)</code> 或者 <code class=\"highlighter-rouge\">call()</code>。虽然不是什么大不了的事情，但是如果能直接使用类似 <code class=\"highlighter-rouge\">onConfirmInput(inputTextField.text)</code> 的形式，会更简单。</p> \n<p>Swift 5.2 中引入的 <a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md\"><code class=\"highlighter-rouge\">callAsFunction</code></a>，它可以让我们直接以“调用实例”的方式 call 一个方法。使用起来很简单，只需要创建一个名称为 <code class=\"highlighter-rouge\">callAsFunction</code> 的实例方法就可以了：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"kt\">Adder</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"kt\">Int</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">callAsFunction</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">input</span><span class=\"p\">:</span> <span class=\"kt\">Int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Int</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"n\">input</span> <span class=\"o\">+</span> <span class=\"n\">value</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">let</span> <span class=\"nv\">add2</span> <span class=\"o\">=</span> <span class=\"kt\">Adder</span><span class=\"p\">(</span><span class=\"nv\">value</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"nf\">add2</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"c1\">// 3</span>\n</code></pre>\n </div>\n</div> \n<p>这个特性非常适合把 <code class=\"highlighter-rouge\">Delegate.call</code> 简化，只需要加入对应的 <code class=\"highlighter-rouge\">callAsFunction</code> 实现，并调用 <code class=\"highlighter-rouge\">block</code> 就行了：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"kt\">Delegate</span><span class=\"o\">&lt;</span><span class=\"kt\">Input</span><span class=\"p\">,</span> <span class=\"kt\">Output</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// ...</span>\n    \n    <span class=\"kd\">func</span> <span class=\"nf\">callAsFunction</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">input</span><span class=\"p\">:</span> <span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Output</span><span class=\"p\">?</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nf\">block</span><span class=\"p\">?(</span><span class=\"n\">input</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"kt\">TextInputView</span><span class=\"p\">:</span> <span class=\"kt\">UIView</span> <span class=\"p\">{</span>\n    <span class=\"kd\">@IBAction</span> <span class=\"kd\">func</span> <span class=\"nf\">confirmButtonPressed</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">sender</span><span class=\"p\">:</span> <span class=\"kt\">Any</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nf\">onConfirmInput</span><span class=\"p\">(</span><span class=\"n\">inputTextField</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>现在，<code class=\"highlighter-rouge\">onConfirmInput</code> 的调用看起来就和一个闭包完全一样了。</p> \n<blockquote> \n <p>类似于 <code class=\"highlighter-rouge\">callAsFunction</code> 的直接在实例上调用方法的方式，在 Python 中有很多应用。在 Swift 语言中添加这个特性能让习惯于 Python 的开发者更容易地迁移到像是 Swift for TensorFlow 这样的项目。而这个提案的提出和审核相关人员，也基本是 Swift for TensorFlow 的成员。</p> \n</blockquote> \n<h3 id=\"2-双层可选值\">2. 双层可选值</h3> \n<p>如果 <code class=\"highlighter-rouge\">Delegate&lt;Input, Output&gt;</code> 中的 <code class=\"highlighter-rouge\">Output</code> 是一个可选值的话，那么 <code class=\"highlighter-rouge\">call</code> 之后的结果将会是双重可选的 <code class=\"highlighter-rouge\">Output??</code>。</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">onReturnOptional</span> <span class=\"o\">=</span> <span class=\"kt\">Delegate</span><span class=\"o\">&lt;</span><span class=\"kt\">Int</span><span class=\"p\">,</span> <span class=\"kt\">Int</span><span class=\"p\">?</span><span class=\"o\">&gt;</span><span class=\"p\">()</span>\n<span class=\"k\">let</span> <span class=\"nv\">value</span> <span class=\"o\">=</span> <span class=\"n\">onReturnOptional</span><span class=\"o\">.</span><span class=\"nf\">call</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"c1\">// value : Int??</span>\n</code></pre>\n </div>\n</div> \n<p>这可以让我们区分出 <code class=\"highlighter-rouge\">block</code> 没有被设置的情况和 <code class=\"highlighter-rouge\">Delegate</code> 确实返回 <code class=\"highlighter-rouge\">nil</code> 的情况：当 <code class=\"highlighter-rouge\">onReturnOptional.delegate(on:block:)</code> 没有被调用过 (<code class=\"highlighter-rouge\">block</code> 为 <code class=\"highlighter-rouge\">nil</code>) 时，<code class=\"highlighter-rouge\">value</code> 是简单的 <code class=\"highlighter-rouge\">nil</code>。但如果 <code class=\"highlighter-rouge\">delegate</code> 被设置了，但是闭包返回的是 <code class=\"highlighter-rouge\">nil</code> 时，<code class=\"highlighter-rouge\">value</code> 的值将为 <code class=\"highlighter-rouge\">.some(nil)</code>。在实际使用上这很容易造成困惑，绝大多数情况下，我们希望把 <code class=\"highlighter-rouge\">.none</code>，<code class=\"highlighter-rouge\">.some(.none)</code> 和 <code class=\"highlighter-rouge\">.some(.some(value))</code> 这样的返回值展平到单层 <code class=\"highlighter-rouge\">Optional</code> 的 <code class=\"highlighter-rouge\">.none</code> 或 <code class=\"highlighter-rouge\">.some(value)</code>。</p> \n<p>要解决这个问题，可以对 <code class=\"highlighter-rouge\">Delegate</code> 进行扩展，为那些 <code class=\"highlighter-rouge\">Output</code> 是 <code class=\"highlighter-rouge\">Optional</code> 情况提供重载的 <code class=\"highlighter-rouge\">call(_:)</code> 实现。不过 <code class=\"highlighter-rouge\">Optional</code> 是带有泛型参数的类型，所以我们没有办法写出像是 <code class=\"highlighter-rouge\">extension Delegate where Output == Optional</code> 这样的条件扩展。一个“取巧”的方式是自定义一个新的 <code class=\"highlighter-rouge\">OptionalProtocol</code>，让 <code class=\"highlighter-rouge\">extension</code> 基于 <code class=\"highlighter-rouge\">where Output: OptionalProtocol</code> 来做条件扩展：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">protocol</span> <span class=\"kt\">OptionalProtocol</span> <span class=\"p\">{</span>\n    <span class=\"kd\">static</span> <span class=\"k\">var</span> <span class=\"nv\">createNil</span><span class=\"p\">:</span> <span class=\"k\">Self</span> <span class=\"p\">{</span> <span class=\"k\">get</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">extension</span> <span class=\"kt\">Optional</span> <span class=\"p\">:</span> <span class=\"kt\">OptionalProtocol</span> <span class=\"p\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"k\">var</span> <span class=\"nv\">createNil</span><span class=\"p\">:</span> <span class=\"kt\">Optional</span><span class=\"o\">&lt;</span><span class=\"kt\">Wrapped</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n         <span class=\"k\">return</span> <span class=\"kc\">nil</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">extension</span> <span class=\"kt\">Delegate</span> <span class=\"k\">where</span> <span class=\"kt\">Output</span><span class=\"p\">:</span> <span class=\"kt\">OptionalProtocol</span> <span class=\"p\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">func</span> <span class=\"nf\">call</span><span class=\"p\">(</span><span class=\"n\">_</span> <span class=\"nv\">input</span><span class=\"p\">:</span> <span class=\"kt\">Input</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Output</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"nv\">result</span> <span class=\"o\">=</span> <span class=\"nf\">block</span><span class=\"p\">?(</span><span class=\"n\">input</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">result</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"o\">.</span><span class=\"n\">createNil</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>这样，即使 <code class=\"highlighter-rouge\">Output</code> 为可选值，<code class=\"highlighter-rouge\">block?(input)</code> 调用所得到的结果也可以经过 <code class=\"highlighter-rouge\">if let</code> 解包，并返回单层的 <code class=\"highlighter-rouge\">result</code> 或是 <code class=\"highlighter-rouge\">nil</code>。</p> \n<h3 id=\"3-遮蔽失效\">3. 遮蔽失效</h3> \n<p>由于使用了遮蔽变量 <code class=\"highlighter-rouge\">self</code>，在闭包中的 <code class=\"highlighter-rouge\">self</code> 其实是这个遮蔽变量，而非原本的 <code class=\"highlighter-rouge\">self</code>。这样要求我们比较小心，否则可能造成意外的循环引用。比如下面的例子：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"n\">inputView</span><span class=\"o\">.</span><span class=\"n\">onConfirmInput</span><span class=\"o\">.</span><span class=\"nf\">delegate</span><span class=\"p\">(</span><span class=\"nv\">on</span><span class=\"p\">:</span> <span class=\"k\">self</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">text</span><span class=\"p\">)</span> <span class=\"k\">in</span>\n    <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">textLabel</span><span class=\"o\">.</span><span class=\"n\">text</span> <span class=\"o\">=</span> <span class=\"n\">text</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>上面的代码编译和使用都没有问题，但是由于我们把 <code class=\"highlighter-rouge\">(self, text)</code> 换成了 <code class=\"highlighter-rouge\">(_, text)</code>，这导致闭包内部 <code class=\"highlighter-rouge\">self.textLabel.text</code> 中的 <code class=\"highlighter-rouge\">self</code> 直接参照了真正的 <code class=\"highlighter-rouge\">self</code>，这是一个强引用，进而内存泄露。</p> \n<p>这种错误和 <code class=\"highlighter-rouge\">[weak self]</code> 声明一样，没有办法得到编译器的提示，所以也很难完全避免。也许一个可行方案是不要用 <code class=\"highlighter-rouge\">(self, text)</code> 这样的隐式遮蔽，而是将参数名明确写成不一样的形式，比如 <code class=\"highlighter-rouge\">(weakSelf, text)</code>，然后在闭包中只使用 <code class=\"highlighter-rouge\">weakSelf</code>。但这么做其实和 <code class=\"highlighter-rouge\">self</code> 遮蔽差距不大，依然摆脱不了用“人为规定”来强制统一代码规则。当然，你也可以依靠使用 linter 和添加对应规则来提醒自己，但是这些方式也都不是非常理想。如果你有什么好的想法或者建议，十分欢迎交流和指教。</p>","descriptionType":"text/html","publishedDate":"Thu, 12 Mar 2020 01:00:00 +0000","feedId":3176,"bgimg":"","linkMd5":"5f47e52d2dd8659721fb1376b79d2fd2","bgimgJsdelivr":"","metaImg":"","author":"","publishedOrCreatedDate":1598304289198},{"createdTime":"2020-08-25 05:24:49","updatedTime":"2020-08-25 05:24:49","title":"SwiftUI 的一些初步探索 (一)","link":"https://onevcat.com/2019/06/swift-ui-firstlook/","description":"<p><img src=\"https://onevcat.com/assets/images/2019/swift-ui.png\" alt=\"\" /></p> \n<blockquote> \n <p>我已经计划写一本关于 SwiftUI 和 Combine 编程的书籍，希望能通过一些实践案例帮助您快速上手 SwiftUI 及 Combine 响应式编程框架，掌握下一代客户端 UI 开发技术。现在这本书已经开始预售，预计能在 10 月左右完成。如果您对此有兴趣，可以查看 <a href=\"https://objccn.io/products/\">ObjC 中国的产品页面</a>了解详情及购买。十分感谢！</p> \n</blockquote> \n<h2 id=\"总览\">总览</h2> \n<p>如果你想要入门 SwiftUI 的使用，那 Apple 这次给出的<a href=\"https://developer.apple.com/tutorials/swiftui\">官方教程</a>绝对给力。这个教程提供了非常详尽的步骤和说明，网页的交互也是一流，是觉得值得看和动手学习的参考。</p> \n<p>不过，SwiftUI 中有一些值得注意的细节在教程里并没有太详细提及，也可能造成一些困惑。这篇文章以我的个人观点对教程的某些部分进行了补充说明，希望能在大家跟随教程学习 SwiftUI 的时候有点帮助。这篇文章的推荐阅读方式是，一边参照 SwiftUI 教程实际动手进行实现，一边在到达对应步骤时参照本文加深理解。在下面每段内容前我标注了对应的教程章节和链接，以供参考。</p> \n<p>在开始学习 SwiftUI 之前，我们需要大致了解一个问题：为什么我们会需要一个新的 UI 框架。</p> \n<h2 id=\"为什么需要-swiftui\">为什么需要 SwiftUI</h2> \n<h3 id=\"uikit-面临的挑战\">UIKit 面临的挑战</h3> \n<p>对于 Swift 开发者来说，昨天的 WWDC 19 首日 Keynote 和 Platforms State of the Union 上最引人注目的内容自然是 SwiftUI 的公布了。从 iOS SDK 2.0 开始，UIKit 已经伴随广大 iOS 开发者经历了接近十年的风风雨雨。UIKit 的思想继承了成熟的 AppKit 和 MVC，在初出时，为 iOS 开发者提供了良好的学习曲线。</p> \n<p>UIKit 提供的是一套符合直觉的，基于控制流的命令式的编程方式。最主要的思想是在确保 View 或者 View Controller 生命周期以及用户交互时，相应的方法 (比如 <code class=\"highlighter-rouge\">viewDidLoad</code> 或者某个 target-action 等) 能够被正确调用，从而构建用户界面和逻辑。不过，不管是从使用的便利性还是稳定性来说，UIKit 都面临着巨大的挑战。我个人勉强也能算是 iOS 开发的“老司机”了，但是「掉到 UIKit 的坑里」这件事，也几乎还是我每天的日常。UIKit 的基本思想要求 View Controller 承担绝大部分职责，它需要协调 model，view 以及用户交互。这带来了巨大的 side effect 以及大量的状态，如果没有妥善安置，它们将在 View Controller 中混杂在一起，同时作用于 view 或者逻辑，从而使状态管理愈发复杂，最后甚至不可维护而导致项目失败。不仅是作为开发者我们自己写的代码，UIKit 本身内部其实也经常受困于可变状态，各种奇怪的 bug 也频频出现。</p> \n<h3 id=\"声明式的界面开发方式\">声明式的界面开发方式</h3> \n<p>近年来，随着编程技术和思想的进步，使用声明式或者函数式的方式来进行界面开发，已经越来越被接受并逐渐成为主流。最早的思想大概是来源于 <a href=\"https://elm-lang.org\">Elm</a>，之后这套方式被 <a href=\"https://reactjs.org\">React</a> 和 <a href=\"https://flutter.dev\">Flutter</a> 采用，这一点上 SwiftUI 也几乎与它们一致。总结起来，这些 UI 框架都遵循以下步骤和原则：</p> \n<ol> \n <li> <p>使用各自的 DSL 来描述「UI 应该是什么样子」，而不是用一句句的代码来指导「要怎样构建 UI」。</p> <p>比如传统的 UIKit，我们会使用这样的代码来添加一个 “Hello World” 的标签，它负责“创建 label”，“设置文字”，“将其添加到 view 上”：</p> \n  <div class=\"language-swift highlighter-rouge\">\n   <div class=\"highlight\">\n    <pre class=\"highlight\"><code> <span class=\"kd\">func</span> <span class=\"nf\">viewDidLoad</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n     <span class=\"k\">super</span><span class=\"o\">.</span><span class=\"nf\">viewDidLoad</span><span class=\"p\">()</span>\n     <span class=\"k\">let</span> <span class=\"nv\">label</span> <span class=\"o\">=</span> <span class=\"kt\">UILabel</span><span class=\"p\">()</span>\n     <span class=\"n\">label</span><span class=\"o\">.</span><span class=\"n\">text</span> <span class=\"o\">=</span> <span class=\"s\">\"Hello World\"</span>\n     <span class=\"n\">view</span><span class=\"o\">.</span><span class=\"nf\">addSubview</span><span class=\"p\">(</span><span class=\"n\">label</span><span class=\"p\">)</span>\n     <span class=\"c1\">// 省略了布局的代码</span>\n <span class=\"p\">}</span>\n</code></pre>\n   </div> \n  </div> <p>而相对起来，使用 SwiftUI 我们只需要告诉 SDK 我们需要一个文字标签：</p> \n  <div class=\"language-swift highlighter-rouge\">\n   <div class=\"highlight\">\n    <pre class=\"highlight\"><code> <span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n     <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Hello World\"</span><span class=\"p\">)</span>\n <span class=\"p\">}</span>\n</code></pre>\n   </div> \n  </div> </li> \n <li> <p>接下来，框架内部读取这些 view 的声明，负责将它们以合适的方式绘制渲染。</p> <p>注意，这些 view 的声明只是纯数据结构的描述，而不是实际显示出来的视图，因此这些结构的创建和差分对比并不会带来太多性能损耗。相对来说，将描述性的语言进行渲染绘制的部分是最慢的，这部分工作将交由框架以黑盒的方式为我们完成。</p> </li> \n <li> <p>如果 <code class=\"highlighter-rouge\">View</code> 需要根据某个状态 (state) 进行改变，那我们将这个状态存储在变量中，并在声明 view 时使用它：</p> \n  <div class=\"language-swift highlighter-rouge\">\n   <div class=\"highlight\">\n    <pre class=\"highlight\"><code> <span class=\"kd\">@State</span> <span class=\"k\">var</span> <span class=\"nv\">name</span><span class=\"p\">:</span> <span class=\"kt\">String</span> <span class=\"o\">=</span> <span class=\"s\">\"Tom\"</span>\n <span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n     <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Hello </span><span class=\"se\">\\(</span><span class=\"n\">name</span><span class=\"se\">)</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n <span class=\"p\">}</span>\n</code></pre>\n   </div> \n  </div> \n  <blockquote> \n   <p>关于代码细节可以先忽略，我们稍后会更多地解释这方面的内容。</p> \n  </blockquote> </li> \n <li> <p>状态发生改变时，框架重新调用声明部分的代码，计算出新的 view 声明，并和原来的 view 进行差分，之后框架负责对变更的部分进行高效的重新绘制。</p> </li> \n</ol> \n<p>SwiftUI 的思想也完全一样，而且实际处理也不外乎这几个步骤。使用描述方式开发，大幅减少了在 app 开发者层面上出现问题的机率。</p> \n<h2 id=\"一些细节解读\">一些细节解读</h2> \n<p><a href=\"https://developer.apple.com/tutorials/swiftui\">官方教程</a>中对声明式 UI 的编程思想有深刻的体现。另外，SwiftUI 中也采用了非常多 Swift 5.1 的新特性，会让习惯了 Swift 4 或者 5 的开发者“耳目一新”。接下来，我会分几个话题，对官方教程的一些地方进行解释和探索。</p> \n<h3 id=\"教程-1---creating-and-combining-views\"><a href=\"https://developer.apple.com/tutorials/swiftui/creating-and-combining-views\">教程 1 - Creating and Combining Views</a></h3> \n<h4 id=\"section-1---step-3-swiftui-app-的启动\"><a href=\"https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-new-project-and-explore-the-canvas\">Section 1 - Step 3: SwiftUI app 的启动</a></h4> \n<p>创建 app 之后第一件好奇的事情是，SwiftUI app 是怎么启动的。</p> \n<p>教程示例 app 在 AppDelegate 中通过 <code class=\"highlighter-rouge\">application(_:configurationForConnecting:options)</code> 返回了一个名为 “Default Configuration” 的 <code class=\"highlighter-rouge\">UISceneConfiguration</code> 实例：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">application</span><span class=\"p\">(</span>\n    <span class=\"n\">_</span> <span class=\"nv\">application</span><span class=\"p\">:</span> <span class=\"kt\">UIApplication</span><span class=\"p\">,</span>\n    <span class=\"n\">configurationForConnecting</span> <span class=\"nv\">connectingSceneSession</span><span class=\"p\">:</span> <span class=\"kt\">UISceneSession</span><span class=\"p\">,</span>\n    <span class=\"nv\">options</span><span class=\"p\">:</span> <span class=\"kt\">UIScene</span><span class=\"o\">.</span><span class=\"kt\">ConnectionOptions</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">UISceneConfiguration</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"kt\">UISceneConfiguration</span><span class=\"p\">(</span><span class=\"nv\">name</span><span class=\"p\">:</span> <span class=\"s\">\"Default Configuration\"</span><span class=\"p\">,</span> <span class=\"nv\">sessionRole</span><span class=\"p\">:</span> <span class=\"n\">connectingSceneSession</span><span class=\"o\">.</span><span class=\"n\">role</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>这个名字的 Configuration 在 Info.plist 的 “UIApplicationSceneManifest -&gt; UISceneConfigurations” 中进行了定义，指定了 Scene Session Delegate 类为 <code class=\"highlighter-rouge\">$(PRODUCT_MODULE_NAME).SceneDelegate</code>。这部分内容是 iOS 13 中新加入的通过 Scene 管理 app 生命周期的方式，以及多窗口支持部分所需要的代码。这部分不是我们今天的话题。在 app 完成启动后，控制权被交接给 <code class=\"highlighter-rouge\">SceneDelegate</code>，它的 <code class=\"highlighter-rouge\">scene(_:willConnectTo:options:)</code> 将会被调用，进行 UI 的配置：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">func</span> <span class=\"nf\">scene</span><span class=\"p\">(</span>\n        <span class=\"n\">_</span> <span class=\"nv\">scene</span><span class=\"p\">:</span> <span class=\"kt\">UIScene</span><span class=\"p\">,</span>\n        <span class=\"n\">willConnectTo</span> <span class=\"nv\">session</span><span class=\"p\">:</span> <span class=\"kt\">UISceneSession</span><span class=\"p\">,</span>\n        <span class=\"n\">options</span> <span class=\"nv\">connectionOptions</span><span class=\"p\">:</span> <span class=\"kt\">UIScene</span><span class=\"o\">.</span><span class=\"kt\">ConnectionOptions</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"nv\">window</span> <span class=\"o\">=</span> <span class=\"kt\">UIWindow</span><span class=\"p\">(</span><span class=\"nv\">frame</span><span class=\"p\">:</span> <span class=\"kt\">UIScreen</span><span class=\"o\">.</span><span class=\"n\">main</span><span class=\"o\">.</span><span class=\"n\">bounds</span><span class=\"p\">)</span>\n        <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">rootViewController</span> <span class=\"o\">=</span> <span class=\"kt\">UIHostingController</span><span class=\"p\">(</span><span class=\"nv\">rootView</span><span class=\"p\">:</span> <span class=\"kt\">ContentView</span><span class=\"p\">())</span>\n        <span class=\"k\">self</span><span class=\"o\">.</span><span class=\"n\">window</span> <span class=\"o\">=</span> <span class=\"n\">window</span>\n        <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"nf\">makeKeyAndVisible</span><span class=\"p\">()</span>\n    <span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>这部分内容就是标准的 iOS app 启动流程了。<code class=\"highlighter-rouge\">UIHostingController</code> 是一个 <code class=\"highlighter-rouge\">UIViewController</code> 子类，它将负责接受一个 SwiftUI 的 View 描述并将其用 UIKit 进行渲染 (在 iOS 下的情况)。<code class=\"highlighter-rouge\">UIHostingController</code> 就是一个普通的 <code class=\"highlighter-rouge\">UIViewController</code>，因此完全可以做到将 SwiftUI 创建的界面一点点集成到已有的 UIKit app 中，而并不需要从头开始就是基于 SwiftUI 的构建。</p> \n<p>由于 Swift ABI 已经稳定，SwiftUI 是一个搭载在用户 iOS 系统上的 Swift 框架。因此它的最低支持的版本是 iOS 13，可能想要在实际项目中使用，还需要等待一两年时间。</p> \n<h4 id=\"section-1---step-4-关于-some-view\"><a href=\"https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-new-project-and-explore-the-canvas\">Section 1 - Step 4: 关于 some View</a></h4> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"kt\">ContentView</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n        <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Hello World\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>一眼看上去可能会对 <code class=\"highlighter-rouge\">some</code> 比较陌生，为了讲明白这件事，我们先从 <code class=\"highlighter-rouge\">View</code> 说起。</p> \n<p><code class=\"highlighter-rouge\">View</code> 是 SwiftUI 的一个最核心的协议，代表了一个屏幕上元素的描述。这个协议中含有一个 associatedtype：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">protocol</span> <span class=\"kt\">View</span> <span class=\"p\">:</span> <span class=\"n\">_View</span> <span class=\"p\">{</span>\n    <span class=\"kd\">associatedtype</span> <span class=\"kt\">Body</span> <span class=\"p\">:</span> <span class=\"kt\">View</span>\n    <span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"k\">Self</span><span class=\"o\">.</span><span class=\"kt\">Body</span> <span class=\"p\">{</span> <span class=\"k\">get</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>这种带有 associatedtype 的协议不能作为<strong>类型</strong>来使用，而只能作为<strong>类型约束</strong>使用：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"c1\">// Error</span>\n<span class=\"kd\">func</span> <span class=\"nf\">createView</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// OK</span>\n<span class=\"kd\">func</span> <span class=\"n\">createView</span><span class=\"o\">&lt;</span><span class=\"kt\">T</span><span class=\"p\">:</span> <span class=\"kt\">View</span><span class=\"o\">&gt;</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">T</span> <span class=\"p\">{</span>\n    \n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>这样一来，其实我们是不能写类似这种代码的：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"c1\">// Error，含有 associatedtype 的 protocol View 只能作为类型约束使用</span>\n<span class=\"kd\">struct</span> <span class=\"kt\">ContentView</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n        <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Hello World\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>想要 Swift 帮助自动推断出 <code class=\"highlighter-rouge\">View.Body</code> 的类型的话，我们需要明确地指出 <code class=\"highlighter-rouge\">body</code> 的真正的类型。在这里，<code class=\"highlighter-rouge\">body</code> 的实际类型是 <code class=\"highlighter-rouge\">Text</code>：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"kt\">ContentView</span><span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"kt\">Text</span> <span class=\"p\">{</span>\n        <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Hello World\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>当然我们可以明确指定出 <code class=\"highlighter-rouge\">body</code> 的类型，但是这带来一些麻烦：</p> \n<ol> \n <li>每次修改 <code class=\"highlighter-rouge\">body</code> 的返回时我们都需要手动去更改相应的类型。</li> \n <li>新建一个 <code class=\"highlighter-rouge\">View</code> 的时候，我们都需要去考虑会是什么类型。</li> \n <li>其实我们只关心返回的是不是一个 <code class=\"highlighter-rouge\">View</code>，而对实际上它是什么类型并不感兴趣。</li> \n</ol> \n<p><code class=\"highlighter-rouge\">some View</code> 这种写法使用了 Swift 5.1 的 <a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md\">Opaque return types 特性</a>。它向编译器作出保证，每次 <code class=\"highlighter-rouge\">body</code> 得到的一定是某一个确定的，遵守 <code class=\"highlighter-rouge\">View</code> 协议的类型，但是请编译器“网开一面”，不要再细究具体的类型。返回类型<strong>确定单一</strong>这个条件十分重要，比如，下面的代码也是无法通过的：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code>\n<span class=\"k\">let</span> <span class=\"nv\">someCondition</span><span class=\"p\">:</span> <span class=\"kt\">Bool</span>\n\n<span class=\"c1\">// Error: Function declares an opaque return type, </span>\n<span class=\"c1\">// but the return statements in its body do not have </span>\n<span class=\"c1\">// matching underlying types.</span>\n<span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"n\">someCondition</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 这个分支返回 Text</span>\n        <span class=\"k\">return</span> <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Hello World\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 这个分支返回 Button，和 if 分支的类型不统一</span>\n        <span class=\"k\">return</span> <span class=\"kt\">Button</span><span class=\"p\">(</span><span class=\"nv\">action</span><span class=\"p\">:</span> <span class=\"p\">{})</span> <span class=\"p\">{</span>\n            <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Tap me\"</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>这是一个编译期间的特性，在保证 associatedtype protocol 的功能的前提下，使用 <code class=\"highlighter-rouge\">some</code> 可以抹消具体的类型。这个特性用在 SwiftUI 上简化了书写难度，让不同 <code class=\"highlighter-rouge\">View</code> 声明的语法上更加统一。</p> \n<h4 id=\"section-2---step-1-预览-swiftui\"><a href=\"https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#customize-the-text-view\">Section 2 - Step 1: 预览 SwiftUI</a></h4> \n<p>SwiftUI 的 Preview 是 Apple 用来对标 RN 或者 Flutter 的 Hot Reloading 的开发工具。由于 IBDesignable 的性能上的惨痛教训，而且得益于 SwiftUI 经由 UIKit 的跨 Apple 平台的特性，Apple 这次选择了直接在 macOS 上进行渲染。因此，你需要使用搭载有 SwiftUI.framework 的 macOS 10.15 才能够看到 Xcode Previews 界面。</p> \n<p>Xcode 将对代码进行静态分析 (得益于 <a href=\"https://github.com/apple/swift-syntax\">SwiftSyntax 框架</a>)，找到所有遵守 <code class=\"highlighter-rouge\">PreviewProvider</code> 协议的类型进行预览渲染。另外，你可以为这些预览提供合适的数据，这甚至可以让整个界面开发流程不需要实际运行 app 就能进行。</p> \n<p>笔者自己尝试下来，这套开发方式带来的效率提升相比 Hot Reloading 要更大。Hot Reloading 需要你有一个大致界面和准备相应数据，然后运行 app，停在要开发的界面，再进行调整。如果数据状态发生变化，你还需要 restart app 才能反应。SwiftUI 的 Preview 相比起来，不需要运行 app 并且可以提供任何的 dummy 数据，在开发效率上更胜一筹。</p> \n<p>经过短短一天的使用，Option + Command + P 这个刷新 preview 的快捷键已经深入到我的肌肉记忆中了。</p> \n<h4 id=\"section-3---step-5-关于-viewbuilder\"><a href=\"https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#combine-views-using-stacks\">Section 3 - Step 5: 关于 ViewBuilder</a></h4> \n<p>创建 Stack 的语法很有趣：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kt\">VStack</span><span class=\"p\">(</span><span class=\"nv\">alignment</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">leading</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Turtle Rock\"</span><span class=\"p\">)</span>\n        <span class=\"o\">.</span><span class=\"nf\">font</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">title</span><span class=\"p\">)</span>\n    <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Joshua Tree National Park\"</span><span class=\"p\">)</span>\n        <span class=\"o\">.</span><span class=\"nf\">font</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">subheadline</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>一开始看起来好像我们给出了两个 <code class=\"highlighter-rouge\">Text</code>，似乎是构成的是一个类似数组形式的 <code class=\"highlighter-rouge\">[View]</code>，但实际上并不是这么一回事。这里调用了 <code class=\"highlighter-rouge\">VStack</code> 类型的初始化方法：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">struct</span> <span class=\"kt\">VStack</span><span class=\"o\">&lt;</span><span class=\"kt\">Content</span><span class=\"o\">&gt;</span> <span class=\"k\">where</span> <span class=\"kt\">Content</span> <span class=\"p\">:</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"nf\">init</span><span class=\"p\">(</span>\n        <span class=\"nv\">alignment</span><span class=\"p\">:</span> <span class=\"kt\">HorizontalAlignment</span> <span class=\"o\">=</span> <span class=\"o\">.</span><span class=\"n\">center</span><span class=\"p\">,</span> \n        <span class=\"nv\">spacing</span><span class=\"p\">:</span> <span class=\"kt\">Length</span><span class=\"p\">?</span> <span class=\"o\">=</span> <span class=\"kc\">nil</span><span class=\"p\">,</span> \n        <span class=\"nv\">content</span><span class=\"p\">:</span> <span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Content</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>前面的 <code class=\"highlighter-rouge\">alignment</code> 和 <code class=\"highlighter-rouge\">spacing</code> 没啥好说，最后一个 <code class=\"highlighter-rouge\">content</code> 比较有意思。看签名的话，它是一个 <code class=\"highlighter-rouge\">() -&gt; Content</code> 类型，但是我们在创建这个 <code class=\"highlighter-rouge\">VStack</code> 时所提供的代码只是简单列举了两个 <code class=\"highlighter-rouge\">Text</code>，而并没有实际返回一个可用的 <code class=\"highlighter-rouge\">Content</code>。</p> \n<p>这里使用了 Swift 5.1 的另一个新特性：<a href=\"https://github.com/apple/swift-evolution/blob/9992cf3c11c2d5e0ea20bee98657d93902d5b174/proposals/XXXX-function-builders.md\">Funtion builders</a>。如果你实际观察 <code class=\"highlighter-rouge\">VStack</code> 的<a href=\"https://developer.apple.com/documentation/swiftui/vstack/3278367-init\">这个初始化方法的签名</a>，会发现 <code class=\"highlighter-rouge\">content</code> 前面其实有一个 <code class=\"highlighter-rouge\">@ViewBuilder</code> 标记：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"nf\">init</span><span class=\"p\">(</span>\n    <span class=\"nv\">alignment</span><span class=\"p\">:</span> <span class=\"kt\">HorizontalAlignment</span> <span class=\"o\">=</span> <span class=\"o\">.</span><span class=\"n\">center</span><span class=\"p\">,</span> \n    <span class=\"nv\">spacing</span><span class=\"p\">:</span> <span class=\"kt\">Length</span><span class=\"p\">?</span> <span class=\"o\">=</span> <span class=\"kc\">nil</span><span class=\"p\">,</span> \n    <span class=\"kd\">@ViewBuilder</span> <span class=\"nv\">content</span><span class=\"p\">:</span> <span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Content</span><span class=\"p\">)</span>\n</code></pre>\n </div>\n</div> \n<p>而 <code class=\"highlighter-rouge\">ViewBuilder</code> 则是一个由 <code class=\"highlighter-rouge\">@_functionBuilder</code> 进行标记的 struct：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">@_functionBuilder</span> <span class=\"kd\">public</span> <span class=\"kd\">struct</span> <span class=\"kt\">ViewBuilder</span> <span class=\"p\">{</span> <span class=\"cm\">/* */</span> <span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>使用 <code class=\"highlighter-rouge\">@_functionBuilder</code> 进行标记的类型 (这里的 <code class=\"highlighter-rouge\">ViewBuilder</code>)，可以被用来对其他内容进行标记 (这里用 <code class=\"highlighter-rouge\">@ViewBuilder</code> 对 <code class=\"highlighter-rouge\">content</code> 进行标记)。被用 function builder 标记过的 <code class=\"highlighter-rouge\">ViewBuilder</code> 标记以后，<code class=\"highlighter-rouge\">content</code> 这个输入的 function 在被使用前，会按照 <code class=\"highlighter-rouge\">ViewBuilder</code> 中合适的 <code class=\"highlighter-rouge\">buildBlock</code> <a href=\"https://github.com/apple/swift-evolution/blob/9992cf3c11c2d5e0ea20bee98657d93902d5b174/proposals/XXXX-function-builders.md#function-building-methods\">进行 build</a> 后再使用。如果你阅读 <code class=\"highlighter-rouge\">ViewBuilder</code> 的<a href=\"https://developer.apple.com/documentation/swiftui/viewbuilder\">文档</a>，会发现有很多接受不同个数参数的 <code class=\"highlighter-rouge\">buildBlock</code> 方法，它们将负责把闭包中一一列举的 <code class=\"highlighter-rouge\">Text</code> 和其他可能的 <code class=\"highlighter-rouge\">View</code> 转换为一个 <code class=\"highlighter-rouge\">TupleView</code>，并返回。由此，<code class=\"highlighter-rouge\">content</code> 的签名 <code class=\"highlighter-rouge\">() -&gt; Content</code> 可以得到满足。</p> \n<p>实际上构建这个 <code class=\"highlighter-rouge\">VStack</code> 的代码会被转换为类似下面这样：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"c1\">// 等效伪代码，不能实际编译。</span>\n<span class=\"kt\">VStack</span><span class=\"p\">(</span><span class=\"nv\">alignment</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">leading</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">viewBuilder</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Content</span> <span class=\"k\">in</span>\n    <span class=\"k\">let</span> <span class=\"nv\">text1</span> <span class=\"o\">=</span> <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Turtle Rock\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"nf\">font</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">title</span><span class=\"p\">)</span>\n    <span class=\"k\">let</span> <span class=\"nv\">text2</span> <span class=\"o\">=</span> <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Joshua Tree National Park\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"nf\">font</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">subheadline</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">viewBuilder</span><span class=\"o\">.</span><span class=\"nf\">buildBlock</span><span class=\"p\">(</span><span class=\"n\">text1</span><span class=\"p\">,</span> <span class=\"n\">text2</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>当然这种基于 funtion builder 的方式是有一定限制的。比如 <code class=\"highlighter-rouge\">ViewBuilder</code> 就只实现了最多<a href=\"https://developer.apple.com/documentation/swiftui/viewbuilder/3278693-buildblock\">十个参数</a>的 <code class=\"highlighter-rouge\">buildBlock</code>，因此如果你在一个 <code class=\"highlighter-rouge\">VStack</code> 中放超过十个 <code class=\"highlighter-rouge\">View</code> 的话，编译器就会不太高兴。不过对于正常的 UI 构建，十个参数应该足够了。如果还不行的话，你也可以考虑直接使用 <code class=\"highlighter-rouge\">TupleView</code> 来用多元组的方式合并 <code class=\"highlighter-rouge\">View</code>：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kt\">TupleView</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"kt\">Text</span><span class=\"p\">,</span> <span class=\"kt\">Text</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"p\">(</span>\n    <span class=\"p\">(</span><span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Hello\"</span><span class=\"p\">),</span> <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Hello\"</span><span class=\"p\">))</span>\n<span class=\"p\">)</span>\n</code></pre>\n </div>\n</div> \n<p>除了按顺序接受和构建 <code class=\"highlighter-rouge\">View</code> 的 <code class=\"highlighter-rouge\">buildBlock</code> 以外，<code class=\"highlighter-rouge\">ViewBuilder</code> 还实现了两个特殊的方法：<code class=\"highlighter-rouge\">buildEither</code> 和 <code class=\"highlighter-rouge\">buildIf</code>。它们分别对应 block 中的 <code class=\"highlighter-rouge\">if...else</code> 的语法和 <code class=\"highlighter-rouge\">if</code> 的语法。也就是说，你可以在 <code class=\"highlighter-rouge\">VStack</code> 里写这样的代码：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"k\">var</span> <span class=\"nv\">someCondition</span><span class=\"p\">:</span> <span class=\"kt\">Bool</span>\n\n<span class=\"kt\">VStack</span><span class=\"p\">(</span><span class=\"nv\">alignment</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">leading</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Turtle Rock\"</span><span class=\"p\">)</span>\n        <span class=\"o\">.</span><span class=\"nf\">font</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">title</span><span class=\"p\">)</span>\n    <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Joshua Tree National Park\"</span><span class=\"p\">)</span>\n        <span class=\"o\">.</span><span class=\"nf\">font</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">subheadline</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">someCondition</span> <span class=\"p\">{</span>\n        <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Condition\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Not Condition\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>其他的命令式的代码在 <code class=\"highlighter-rouge\">VStack</code> 的 <code class=\"highlighter-rouge\">content</code> 闭包里是不被接受的，下面这样也不行：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kt\">VStack</span><span class=\"p\">(</span><span class=\"nv\">alignment</span><span class=\"p\">:</span> <span class=\"o\">.</span><span class=\"n\">leading</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// let 语句无法通过 function builder 创建合适的输出</span>\n    <span class=\"k\">let</span> <span class=\"nv\">someCondition</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">condition</span>\n    <span class=\"k\">if</span> <span class=\"n\">someCondition</span> <span class=\"p\">{</span>\n        <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Condition\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"kt\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Not Condition\"</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>到目前为止，只有以下三种写法能被接受 (有可能随着 SwiftUI 的发展出现别的可接受写法)：</p> \n<ul> \n <li>结果为 <code class=\"highlighter-rouge\">View</code> 的语句</li> \n <li><code class=\"highlighter-rouge\">if</code> 语句</li> \n <li><code class=\"highlighter-rouge\">if...else...</code> 语句</li> \n</ul> \n<h4 id=\"section-4---step-7-链式调用修改-view-的属性\"><a href=\"https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-custom-image-view\">Section 4 - Step 7: 链式调用修改 View 的属性</a></h4> \n<p>教程到这一步的话，相信大家已经对 SwiftUI 的超强表达能力有所感悟了。</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"k\">var</span> <span class=\"nv\">body</span><span class=\"p\">:</span> <span class=\"n\">some</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"kt\">Image</span><span class=\"p\">(</span><span class=\"s\">\"turtlerock\"</span><span class=\"p\">)</span>\n        <span class=\"o\">.</span><span class=\"nf\">clipShape</span><span class=\"p\">(</span><span class=\"kt\">Circle</span><span class=\"p\">())</span>\n        <span class=\"o\">.</span><span class=\"nf\">overlay</span><span class=\"p\">(</span>\n            <span class=\"kt\">Circle</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"nf\">stroke</span><span class=\"p\">(</span><span class=\"kt\">Color</span><span class=\"o\">.</span><span class=\"n\">white</span><span class=\"p\">,</span> <span class=\"nv\">lineWidth</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n        <span class=\"o\">.</span><span class=\"nf\">shadow</span><span class=\"p\">(</span><span class=\"nv\">radius</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>可以试想一下，在 UIKit 中要动手撸一个这个效果的困难程度。我大概可以保证，99% 的开发者很难在不借助文档或者 copy paste 的前提下完成这些事情，但是在 SwiftUI 中简直信手拈来。在创建 <code class=\"highlighter-rouge\">View</code> 之后，用链式调用的方式，可以将 <code class=\"highlighter-rouge\">View</code> 转换为一个含有变更后内容的对象。这么说比较抽象，我们可以来看一个具体的例子。比如简化一下上面的代码：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"nv\">image</span><span class=\"p\">:</span> <span class=\"kt\">Image</span> <span class=\"o\">=</span> <span class=\"kt\">Image</span><span class=\"p\">(</span><span class=\"s\">\"turtlerock\"</span><span class=\"p\">)</span>\n<span class=\"k\">let</span> <span class=\"nv\">modified</span><span class=\"p\">:</span> <span class=\"n\">_ModifiedContent</span><span class=\"o\">&lt;</span><span class=\"kt\">Image</span><span class=\"p\">,</span> <span class=\"n\">_ShadowEffect</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"n\">image</span><span class=\"o\">.</span><span class=\"nf\">shadow</span><span class=\"p\">(</span><span class=\"nv\">radius</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n</code></pre>\n </div>\n</div> \n<p><code class=\"highlighter-rouge\">image</code> 通过一个 <code class=\"highlighter-rouge\">.shadow</code> 的 modifier，<code class=\"highlighter-rouge\">modified</code> 变量的类型将转变为 <code class=\"highlighter-rouge\">_ModifiedContent&lt;Image, _ShadowEffect&gt;</code>。如果你查看 <code class=\"highlighter-rouge\">View</code> 上的 <code class=\"highlighter-rouge\">shadow</code> 的定义，它是这样的：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">extension</span> <span class=\"kt\">View</span> <span class=\"p\">{</span>\n    <span class=\"kd\">func</span> <span class=\"nf\">shadow</span><span class=\"p\">(</span>\n        <span class=\"nv\">color</span><span class=\"p\">:</span> <span class=\"kt\">Color</span> <span class=\"o\">=</span> <span class=\"kt\">Color</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"n\">sRGBLinear</span><span class=\"p\">,</span> <span class=\"nv\">white</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nv\">opacity</span><span class=\"p\">:</span> <span class=\"mf\">0.33</span><span class=\"p\">),</span> \n        <span class=\"nv\">radius</span><span class=\"p\">:</span> <span class=\"kt\">Length</span><span class=\"p\">,</span> <span class=\"nv\">x</span><span class=\"p\">:</span> <span class=\"kt\">Length</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nv\">y</span><span class=\"p\">:</span> <span class=\"kt\">Length</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> \n    <span class=\"o\">-&gt;</span> <span class=\"k\">Self</span><span class=\"o\">.</span><span class=\"kt\">Modified</span><span class=\"o\">&lt;</span><span class=\"n\">_ShadowEffect</span><span class=\"o\">&gt;</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p><code class=\"highlighter-rouge\">Modified</code> 是 <code class=\"highlighter-rouge\">View</code> 上的一个 typealias，在 <code class=\"highlighter-rouge\">struct Image: View</code> 的实现里，我们有：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">typealias</span> <span class=\"kt\">Modified</span><span class=\"o\">&lt;</span><span class=\"kt\">T</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"n\">_ModifiedContent</span><span class=\"o\">&lt;</span><span class=\"k\">Self</span><span class=\"p\">,</span> <span class=\"kt\">T</span><span class=\"o\">&gt;</span>\n</code></pre>\n </div>\n</div> \n<p><code class=\"highlighter-rouge\">_ModifiedContent</code> 是一个 SwiftUI 的私有类型，它存储了待变更的内容，以及用来实施变更的 <code class=\"highlighter-rouge\">Modifier</code>：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">struct</span> <span class=\"n\">_ModifiedContent</span><span class=\"o\">&lt;</span><span class=\"kt\">Content</span><span class=\"p\">,</span> <span class=\"kt\">Modifier</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nv\">content</span><span class=\"p\">:</span> <span class=\"kt\">Content</span>\n    <span class=\"k\">var</span> <span class=\"nv\">modifier</span><span class=\"p\">:</span> <span class=\"kt\">Modifier</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>在 <code class=\"highlighter-rouge\">Content</code> 遵守 <code class=\"highlighter-rouge\">View</code>，<code class=\"highlighter-rouge\">Modifier</code> 遵守 <code class=\"highlighter-rouge\">ViewModifier</code> 的情况下，<code class=\"highlighter-rouge\">_ModifiedContent</code> 也将遵守 <code class=\"highlighter-rouge\">View</code>，这是我们能够通过 <code class=\"highlighter-rouge\">View</code> 的各个 modifier extension 进行链式调用的基础：</p> \n<div class=\"language-swift highlighter-rouge\">\n <div class=\"highlight\">\n  <pre class=\"highlight\"><code><span class=\"kd\">extension</span> <span class=\"nv\">_ModifiedContent</span> <span class=\"p\">:</span> <span class=\"n\">_View</span> \n    <span class=\"k\">where</span> <span class=\"kt\">Content</span> <span class=\"p\">:</span> <span class=\"kt\">View</span><span class=\"p\">,</span> <span class=\"kt\">Modifier</span> <span class=\"p\">:</span> <span class=\"kt\">ViewModifier</span> \n<span class=\"p\">{</span>\n<span class=\"p\">}</span>\n</code></pre>\n </div>\n</div> \n<p>在 <code class=\"highlighter-rouge\">shadow</code> 的例子中，SwiftUI 内部会使用 <code class=\"highlighter-rouge\">_ShadowEffect</code> 这个 <code class=\"highlighter-rouge\">ViewModifier</code>，并把 <code class=\"highlighter-rouge\">image</code> 自身和 <code class=\"highlighter-rouge\">_ShadowEffect</code> 实例存放到 <code class=\"highlighter-rouge\">_ModifiedContent</code> 里。不论是 image 还是 modifier，都只是对未来实际视图的描述，而不是直接对渲染进行的操作。在最终渲染前，<code class=\"highlighter-rouge\">ViewModifier</code> 的 <code class=\"highlighter-rouge\">body(content: Self.Content) -&gt; Self.Body</code> 将被调用，以给出最终渲染层所需要的各个属性。</p> \n<blockquote> \n <p>更具体来说，<code class=\"highlighter-rouge\">_ShadowEffect</code> 是一个满足 <a href=\"https://developer.apple.com/documentation/swiftui/environmentalmodifier\"><code class=\"highlighter-rouge\">EnvironmentalModifier</code> 协议</a>的类型，这个协议要求在使用前根据使用环境将自身解析为具体的 modifier。</p> \n</blockquote> \n<p>其他的几个修改 View 属性的链式调用与 <code class=\"highlighter-rouge\">shadow</code> 的原理几乎一致。</p> \n<h2 id=\"小结\">小结</h2> \n<p>上面是对 SwiftUI 教程的第一部分进行的一些说明，在之后的一篇文章里，我会对剩余的几个教程中有意思的部分再做些解释。</p> \n<p>虽然公开还只有一天，但是 SwiftUI 已经经常被用来和 Flutter 等框架进行比较。试用下来，在 view 的描述表现力上和与 app 的结合方面，SwiftUI 要胜过 Flutter 和 Dart 的组合很多。Swift 虽然开源了，但是 Apple 对它的掌控并没有减弱。Swift 5.1 的很多特性几乎可以说都是为了 SwiftUI 量身定制的，我们已经在本文中看到了一些例子，比如 Opaque return types 和 Function builder 等。在接下来对后面几个教程的解读中，我们还会看到更多这方面的内容。</p> \n<p>另外，Apple 在背后使用 Combine.framework 这个响应式编程框架来对 SwiftUI.framework 进行驱动和数据绑定，相比于现有的 RxSwift/RxCocoa 或者是 ReactiveSwift 的方案来说，得到了语言和编译器层级的大力支持。如果有机会，我想我也会对这方面的内容进行一些探索和介绍。</p>","descriptionType":"text/html","publishedDate":"Tue, 04 Jun 2019 06:32:00 +0000","feedId":3176,"bgimg":"https://onevcat.com/assets/images/2019/swift-ui.png","linkMd5":"7a945dfee7f4d163e94abdaeaf587b11","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn23@2020_6/2020/08/24/21-24-58-692_244dd07ca8408fce.webp","destWidth":1041,"destHeight":281,"sourceBytes":13758,"destBytes":12856,"author":"","articleImgCdnMap":{"https://onevcat.com/assets/images/2019/swift-ui.png":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn23@2020_6/2020/08/24/21-24-58-692_244dd07ca8408fce.webp"},"publishedOrCreatedDate":1598304289198}],"record":{"createdTime":"2020-08-25 05:24:49","updatedTime":"2020-08-25 05:24:49","feedId":3176,"fetchDate":"Mon, 24 Aug 2020 21:24:49 +0000","fetchMs":3834,"handleMs":2883,"totalMs":25587,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"54.210.109.46","hostName":"us-032.herokuapp.com","requestId":"ac3382a7e82a4fcbb708e91d9935d764_3176","contentType":"text/xml","totalBytes":8165958,"bgimgsTotal":8,"bgimgsGithubTotal":8,"articlesImgsTotal":27,"articlesImgsGithubTotal":27,"successGithubMap":{"myreaderx14":1,"myreaderx8":1,"myreaderx7":1,"myreaderx15":1,"myreaderx16":1,"myreaderx6":1,"myreaderx10":1,"myreaderx4":1,"myreaderx32":1,"myreaderx33":1,"myreaderx11":1,"myreaderx3":1,"myreaderx12":1,"myreaderx2":1,"myreaderx13":1,"myreaderx30":1,"myreaderx31":1,"myreaderx18":1,"myreaderx19":1,"myreaderx":1,"myreaderx25":1,"myreaderx27":1,"myreaderx21":1,"myreaderx22":1,"myreaderx24":1,"myreaderx5oss":1,"myreaderx29":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:29:20","updatedTime":"2020-08-25 04:29:20","id":3176,"name":"OneV's Den","url":"http://onevcat.com/atom.xml","subscriber":null,"website":null,"icon":"https://onevcat.com/assets/images/favicon.png","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx65/cdn35@2020_3/2020/08/24/21-24-48-411_e05fcc2e2b0cab45.png","description":"嗨，我是王巍 (@onevcat)，一名 iOS 开发者。","weekly":null,"link":"https://onevcat.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":208202,"tmpBodyImgCdnBytes":7957756,"tmpBgImgCdnBytes":0,"extra4":{"start":1598304281496,"total":0,"statList":[{"spend":4824,"msg":"获取xml内容"},{"spend":2883,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":170,"msg":"修正封面图上传失败重新上传"},{"spend":5885,"msg":"正文链接上传到cdn"}]},"extra5":27,"extra6":27,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{"https://onevcat.com/2019/12/backpressure-in-combine/_(https://objccn.io/products/swift-ui)":"https://onevcat.com/2019/12/backpressure-in-combine/(https://objccn.io/products/swift-ui)","https://onevcat.com/2018/12/jose-3/_/2018/jose-1/":"https://onevcat.com/2018/jose-1/","https://onevcat.com/2018/12/jose-3/_/2018/12/jose-1/":"https://onevcat.com/2018/12/jose-1/","https://onevcat.com/2018/12/jose-3/_/2018/12/jose-2/":"https://onevcat.com/2018/12/jose-2/","https://onevcat.com/2020/01/customize-publisher/_(https://objccn.io/products/swift-ui)":"https://onevcat.com/2020/01/customize-publisher/(https://objccn.io/products/swift-ui)","https://onevcat.com/2019/12/2019-final/_/2015/12/2015-final/":"https://onevcat.com/2015/12/2015-final/"},"extra111_proxyServerAndStatMap":{"http://us-018.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-039.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-53.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe65.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-002.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://europe61.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-035.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-022.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-030.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-026.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-038.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-006.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-025.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-001.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-23.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe69.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-57.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-010.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-014.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/publisher-subscriber-flow.svg","sourceStatusCode":200,"destWidth":0,"destHeight":0,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn19@2020_5/2020/08/24/21-24-58-477_f762b5692aadc07f.svg","sourceBytes":5068,"destBytes":5068,"feedId":3176,"totalSpendMs":2221,"convertSpendMs":0,"createdTime":"2020-08-25 05:24:57","host":"us-010*","referer":"https://onevcat.com/2020/01/customize-publisher/","linkMd5ListStr":"54f2952e3c3edce65471aa706e814635,c47674d37f17d51d6127a238695ea4de,54f2952e3c3edce65471aa706e814635,c47674d37f17d51d6127a238695ea4de","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"4.9 KB","sourceSize":"4.9 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2020/48b8f3b0ed887f90b8d420b137fb3689.jpg","sourceStatusCode":200,"destWidth":280,"destHeight":249,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn4@2020_4/2020/08/24/21-24-58-759_bca69bb8da9e549a.webp","sourceBytes":10479,"destBytes":8880,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":2603,"convertSpendMs":5,"createdTime":"2020-08-25 05:24:57","host":"europe-56*","referer":"https://onevcat.com/2020/06/stateobject/","linkMd5ListStr":"4066587684cc4554b82f49d89fa4b04f,4066587684cc4554b82f49d89fa4b04f","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"8.7 KB","sourceSize":"10.2 KB","compressRate":"84.7%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2020/app_clip_target_add.png","sourceStatusCode":200,"destWidth":726,"destHeight":525,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn12@2020_1/2020/08/24/21-24-58-937_029fdc8167349910.webp","sourceBytes":43677,"destBytes":9048,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":2739,"convertSpendMs":41,"createdTime":"2020-08-25 05:24:57","host":"us-035*","referer":"https://onevcat.com/2020/06/first-look-app-clips/","linkMd5ListStr":"42ee8ad4bdf9b8502fc537512e6b6e21,42ee8ad4bdf9b8502fc537512e6b6e21","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"8.8 KB","sourceSize":"42.7 KB","compressRate":"20.7%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/swift-ui.png","sourceStatusCode":200,"destWidth":1041,"destHeight":281,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn23@2020_6/2020/08/24/21-24-58-692_244dd07ca8408fce.webp","sourceBytes":13758,"destBytes":12856,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":2782,"convertSpendMs":11,"createdTime":"2020-08-25 05:24:57","host":"europe-23*","referer":"https://onevcat.com/2019/06/swift-ui-firstlook/","linkMd5ListStr":"d28a702d7fd07e9b34d530e42587e33b,7a945dfee7f4d163e94abdaeaf587b11,d28a702d7fd07e9b34d530e42587e33b,7a945dfee7f4d163e94abdaeaf587b11","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"12.6 KB","sourceSize":"13.4 KB","compressRate":"93.4%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2018/matrix.jpg","sourceStatusCode":200,"destWidth":1024,"destHeight":500,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn15@2020_6/2020/08/24/21-24-59-104_9d4efca24d46f79d.webp","sourceBytes":86506,"destBytes":45088,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":2942,"convertSpendMs":33,"createdTime":"2020-08-25 05:24:57","host":"us-022*","referer":"https://onevcat.com/2018/12/jose-3/","linkMd5ListStr":"cee620a1f3451cdfc9b2722c018d3754,cee620a1f3451cdfc9b2722c018d3754","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"44 KB","sourceSize":"84.5 KB","compressRate":"52.1%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final.jpg","sourceStatusCode":200,"destWidth":3024,"destHeight":1580,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn5@2020_2/2020/08/24/21-24-59-701_6bb1b66a2436dae5.webp","sourceBytes":201885,"destBytes":127262,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":4016,"convertSpendMs":214,"createdTime":"2020-08-25 05:24:57","host":"europe-57*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77,ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"124.3 KB","sourceSize":"197.2 KB","compressRate":"63%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2020/app_clip_parts.png","sourceStatusCode":200,"destWidth":263,"destHeight":540,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn84@2020_6/2020/08/24/21-25-02-722_97d943277f58e145.webp","sourceBytes":43886,"destBytes":21436,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":2158,"convertSpendMs":19,"createdTime":"2020-08-25 05:25:01","host":"us-010*","referer":"https://onevcat.com/2020/06/first-look-app-clips/","linkMd5ListStr":"42ee8ad4bdf9b8502fc537512e6b6e21","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"20.9 KB","sourceSize":"42.9 KB","compressRate":"48.8%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2020/app_clip_skoverlay.png","sourceStatusCode":200,"destWidth":828,"destHeight":494,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn96@2020_1/2020/08/24/21-25-03-247_a2185489f92d9b3f.webp","sourceBytes":19569,"destBytes":11124,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":2621,"convertSpendMs":28,"createdTime":"2020-08-25 05:25:01","host":"us-039*","referer":"https://onevcat.com/2020/06/first-look-app-clips/","linkMd5ListStr":"42ee8ad4bdf9b8502fc537512e6b6e21","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"10.9 KB","sourceSize":"19.1 KB","compressRate":"56.8%"},{"code":1,"isDone":false,"source":"https://images.xiaozhuanlan.com/photo/2019/a900c8d2687dab13ba438602da826552.png","sourceStatusCode":200,"destWidth":744,"destHeight":1408,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn34@2020_2/2020/08/24/21-25-03-089_954c34b4a40703b9.webp","sourceBytes":990480,"destBytes":78108,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":2679,"convertSpendMs":123,"createdTime":"2020-08-25 05:25:01","host":"us-026*","referer":"https://onevcat.com/2019/06/swift-ui-firstlook-2/","linkMd5ListStr":"d28a702d7fd07e9b34d530e42587e33b","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"76.3 KB","sourceSize":"967.3 KB","compressRate":"7.9%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2020/stateobject_app.png","sourceStatusCode":200,"destWidth":493,"destHeight":914,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn27@2020_5/2020/08/24/21-25-03-255_7c0316a36367be54.webp","sourceBytes":31039,"destBytes":61576,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":2803,"convertSpendMs":56,"createdTime":"2020-08-25 05:25:01","host":"us-038*","referer":"https://onevcat.com/2020/06/stateobject/","linkMd5ListStr":"4066587684cc4554b82f49d89fa4b04f","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"60.1 KB","sourceSize":"30.3 KB","compressRate":"198.4%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2020/app_clip_url_env.png","sourceStatusCode":200,"destWidth":892,"destHeight":663,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn44@2020_4/2020/08/24/21-25-03-517_ff5405e0e6835298.webp","sourceBytes":81395,"destBytes":18000,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":3100,"convertSpendMs":22,"createdTime":"2020-08-25 05:25:01","host":"us-002*","referer":"https://onevcat.com/2020/06/first-look-app-clips/","linkMd5ListStr":"42ee8ad4bdf9b8502fc537512e6b6e21","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"17.6 KB","sourceSize":"79.5 KB","compressRate":"22.1%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-03-31.jpg","sourceStatusCode":200,"destWidth":1054,"destHeight":1908,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn3@2020_4/2020/08/24/21-25-03-794_c80a8da61a94a667.webp","sourceBytes":189489,"destBytes":161974,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":3423,"convertSpendMs":103,"createdTime":"2020-08-25 05:25:01","host":"us-001*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"158.2 KB","sourceSize":"185 KB","compressRate":"85.5%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-07-01.jpg","sourceStatusCode":200,"destWidth":1920,"destHeight":1080,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn56@2020_1/2020/08/24/21-25-03-924_7d3b717a7418f1ec.webp","sourceBytes":293461,"destBytes":166984,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":3618,"convertSpendMs":89,"createdTime":"2020-08-25 05:25:01","host":"us-030*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"163.1 KB","sourceSize":"286.6 KB","compressRate":"56.9%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2020/stateobject_reset.gif","sourceStatusCode":200,"destWidth":306,"destHeight":318,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn79@2020_5/2020/08/24/21-25-04-160_91e623db0d5c1bb9.webp","sourceBytes":154925,"destBytes":69274,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":3799,"convertSpendMs":985,"createdTime":"2020-08-25 05:25:01","host":"us-022*","referer":"https://onevcat.com/2020/06/stateobject/","linkMd5ListStr":"4066587684cc4554b82f49d89fa4b04f","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"67.7 KB","sourceSize":"151.3 KB","compressRate":"44.7%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-05-27.jpg","sourceStatusCode":200,"destWidth":1920,"destHeight":1080,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn64@2020_2/2020/08/24/21-25-04-069_cf0c36f0a988b510.webp","sourceBytes":256343,"destBytes":224080,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":3890,"convertSpendMs":81,"createdTime":"2020-08-25 05:25:01","host":"us-006*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"218.8 KB","sourceSize":"250.3 KB","compressRate":"87.4%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-04-13.jpg","sourceStatusCode":200,"destWidth":2592,"destHeight":1936,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn92@2020_6/2020/08/24/21-25-04-014_680c41d2f88e4d83.webp","sourceBytes":278499,"destBytes":253074,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":4318,"convertSpendMs":155,"createdTime":"2020-08-25 05:25:01","host":"europe61*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"247.1 KB","sourceSize":"272 KB","compressRate":"90.9%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-05-07.jpg","sourceStatusCode":200,"destWidth":4032,"destHeight":3024,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn100@2020_3/2020/08/24/21-25-04-651_6c8d1b5ef418f642.webp","sourceBytes":397027,"destBytes":375920,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":4503,"convertSpendMs":706,"createdTime":"2020-08-25 05:25:01","host":"us-026*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"367.1 KB","sourceSize":"387.7 KB","compressRate":"94.7%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-04-03.jpg","sourceStatusCode":200,"destWidth":3024,"destHeight":4032,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn60@2020_6/2020/08/24/21-25-04-709_32ccc85e3ca2ebb7.webp","sourceBytes":813798,"destBytes":842122,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":4538,"convertSpendMs":792,"createdTime":"2020-08-25 05:25:01","host":"us-018*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"822.4 KB","sourceSize":"794.7 KB","compressRate":"103.5%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-04-27.jpg","sourceStatusCode":200,"destWidth":3024,"destHeight":4032,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn87@2020_2/2020/08/24/21-25-04-289_0d6dce813bdca683.webp","sourceBytes":612192,"destBytes":562782,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":4672,"convertSpendMs":594,"createdTime":"2020-08-25 05:25:01","host":"europe-23*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"549.6 KB","sourceSize":"597.8 KB","compressRate":"91.9%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-12-24.jpg","sourceStatusCode":200,"destWidth":3024,"destHeight":4032,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn30@2020_2/2020/08/24/21-25-04-918_ec12321c324bc6d3.webp","sourceBytes":515187,"destBytes":469178,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":4782,"convertSpendMs":675,"createdTime":"2020-08-25 05:25:01","host":"us-025*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"458.2 KB","sourceSize":"503.1 KB","compressRate":"91.1%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-10-11.jpg","sourceStatusCode":200,"destWidth":3024,"destHeight":4032,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn6@2020_2/2020/08/24/21-25-04-975_2d1e79061eb44bf4.webp","sourceBytes":518504,"destBytes":452152,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":4924,"convertSpendMs":784,"createdTime":"2020-08-25 05:25:01","host":"us-002*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"441.6 KB","sourceSize":"506.4 KB","compressRate":"87.2%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-05-29.jpg","sourceStatusCode":200,"destWidth":4032,"destHeight":3024,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn39@2020_6/2020/08/24/21-25-05-269_a89f9e1960e6d913.webp","sourceBytes":623310,"destBytes":583456,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":5184,"convertSpendMs":1056,"createdTime":"2020-08-25 05:25:01","host":"us-014*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"569.8 KB","sourceSize":"608.7 KB","compressRate":"93.6%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-01-01.jpg","sourceStatusCode":200,"destWidth":4032,"destHeight":3024,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn71@2020_5/2020/08/24/21-25-04-607_7c8d19a0fee69292.webp","sourceBytes":983852,"destBytes":1097554,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":5235,"convertSpendMs":648,"createdTime":"2020-08-25 05:25:01","host":"europe-57*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"1 MB","sourceSize":"960.8 KB","compressRate":"111.6%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-09-20.jpg","sourceStatusCode":200,"destWidth":3024,"destHeight":4032,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn76@2020_5/2020/08/24/21-25-05-477_07a13635d119267d.webp","sourceBytes":666002,"destBytes":721284,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":5380,"convertSpendMs":1548,"createdTime":"2020-08-25 05:25:01","host":"us-035*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"704.4 KB","sourceSize":"650.4 KB","compressRate":"108.3%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-07-18.jpg","sourceStatusCode":200,"destWidth":4640,"destHeight":3088,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn52@2020_6/2020/08/24/21-25-05-855_097f0013c0ca1dca.webp","sourceBytes":484098,"destBytes":351834,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":4931,"convertSpendMs":1243,"createdTime":"2020-08-25 05:25:02","host":"us-53*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"343.6 KB","sourceSize":"472.8 KB","compressRate":"72.7%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-06-04.jpg","sourceStatusCode":200,"destWidth":4032,"destHeight":3024,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn68@2020_3/2020/08/24/21-25-04-948_b02e9ec22fdbf48a.webp","sourceBytes":761861,"destBytes":820628,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":5490,"convertSpendMs":338,"createdTime":"2020-08-25 05:25:01","host":"europe69*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"801.4 KB","sourceSize":"744 KB","compressRate":"107.7%"},{"code":1,"isDone":false,"source":"https://onevcat.com/assets/images/2019/2019-final-2019-06-23.jpg","sourceStatusCode":200,"destWidth":3800,"destHeight":2816,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn47@2020_2/2020/08/24/21-25-04-920_538078730d222154.webp","sourceBytes":594157,"destBytes":615216,"targetWebpQuality":75,"feedId":3176,"totalSpendMs":5536,"convertSpendMs":466,"createdTime":"2020-08-25 05:25:01","host":"europe65*","referer":"https://onevcat.com/2019/12/2019-final/","linkMd5ListStr":"ea9bda7de74ac05eb1a4d213ce3f1c77","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"destSize":"600.8 KB","sourceSize":"580.2 KB","compressRate":"103.5%"}],"successGithubMap":{"myreaderx14":1,"myreaderx8":1,"myreaderx7":1,"myreaderx15":1,"myreaderx16":1,"myreaderx6":1,"myreaderx10":1,"myreaderx4":1,"myreaderx32":1,"myreaderx33":1,"myreaderx11":1,"myreaderx3":1,"myreaderx12":1,"myreaderx2":1,"myreaderx13":1,"myreaderx30":1,"myreaderx31":1,"myreaderx18":1,"myreaderx19":1,"myreaderx":1,"myreaderx25":1,"myreaderx27":1,"myreaderx21":1,"myreaderx22":1,"myreaderx24":1,"myreaderx5oss":1,"myreaderx29":1},"failGithubMap":{}}