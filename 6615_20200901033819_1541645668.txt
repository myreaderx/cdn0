{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"输入网址按回车，到底发生了什么","link":"https://segmentfault.com/a/1190000023835978","description":"<p>详解输入网址点击回车，后台到底发生了什么。透析 HTTP 协议与 TCP 连接之间的千丝万缕的关系。掌握为何是三次握手四次挥手？ time_wait 存在的意义是什么？全面图解重点问题，再也不用担心面试问这个问题。</p>\n<p><strong>大致流程</strong></p>\n<ul>\n <li>URL 解析。</li>\n <li>DNS 查询。</li>\n <li>TCP 连接。</li>\n <li>服务器处理请求。</li>\n <li>客户端接收 HTTP 报文响应。</li>\n <li>渲染页面</li>\n</ul>\n<p><strong>重点来了</strong>：</p>\n<ul>\n <li>如何理解 TCP 的三次握手与四次挥手？每次握手客户端与服务端是怎样的状态？</li>\n <li>为何挥手会出现 2MSL，遇到大量 Socket 处在 TIME_WAIT 或者 CLOSE_WAIT 状态是什么问题？</li>\n <li>三次握手与四次挥手的过程是怎样的？</li>\n <li>HTTP 的报文格式又是怎样的？</li>\n</ul>\n<p>继续阅读本文，且听<strong>码哥字节</strong>答疑解惑，微信搜索 “码哥字节”，关注公众号更多硬核。</p>\n<h2>URL 解析</h2>\n<p>地址解析：首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p>\n<p><strong>HSTS</strong> 由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：你所不知道的 HSTS[1]。</p>\n<p><strong>其他操作</strong> 浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p>\n<p><strong>检查缓存</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023835981\" alt=\"URL解析\" title=\"URL解析\" /></p>\n<h2>DNS 查询</h2>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023835982\" alt=\"DNS 查询\" title=\"DNS 查询\" /></p>\n<ol>\n <li>浏览器缓存：先检查是否在缓存中，没有则调用系统库函数进行查询。</li>\n <li>操作系统缓存：操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</li>\n <li>路由器缓存。</li>\n <li><strong>ISP DNS 缓存</strong>：ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</li>\n</ol>\n<p><strong>根域名服务器查询</strong></p>\n<p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023835984\" alt=\"DNS递归查询\" title=\"DNS递归查询\" /></p>\n<p>需要注意的的是：</p>\n<ol>\n <li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地 DNS 服务器的过程）</li>\n <li>迭代方式，就是本地 DNS 服务器到根域名服务器查询的方式。</li>\n <li>什么是 DNS 劫持</li>\n <li>前端 dns-prefetch 优化</li>\n</ol>\n<h2>TCP 连接建立与断开</h2>\n<p>TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023835985\" alt=\"TCP/IP 连接\" title=\"TCP/IP 连接\" /></p>\n<p><strong>应用层：发送 HTTP 请求</strong></p>\n<p>浏览器从地址栏得到服务器 IP，接着构造一个 HTTP 报文，其中包括：</p>\n<ul>\n <li>请求报头(Request Header)：请求方法、目标地址、遵循的协议等</li>\n <li>请求主体，请求参数，比如 body 里面的参数</li>\n</ul>\n<p><strong>传输层：TCP 传输报文</strong></p>\n<p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。在建立连接前，会先进行 TCP 三次握手。</p>\n<p><strong>网络层：IP 协议查询 MAC 地址</strong></p>\n<p>将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p>\n<p><strong>链路层：以太网协议</strong></p>\n<p>根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p>\n<ul>\n <li>标头：数据包的发送者、接受者、数据类型</li>\n <li>数据：数据包具体内容</li>\n</ul>\n<p><strong>Mac 地址</strong></p>\n<p>以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p>\n<p>主要的请求过程：</p>\n<ol>\n <li>浏览器从地址栏中获取服务器的 IP 和端口号；</li>\n <li>浏览器有服务器之间通过 TCP 三次握手建立连接；</li>\n <li>浏览器向服务器发送报文；</li>\n <li>服务器接收报文处理，同时将响应报文发给浏览器；</li>\n <li>浏览器解析报文，渲染输出到页面；</li>\n</ol>\n<h3>三次握手</h3>\n<p>在传输层传输数据之前需要建立连接，也就是三次握手创建可靠连接。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023835989\" alt=\"三次握手\" title=\"三次握手\" /></p>\n<p>首先建立链接前需要 Server 端先监听端口，因此 Server 端建立链接前的初始状态就是 LISTEN 状态，这时 Client 端准备建立链接，先发送一个 SYN 同步包，发送完同步包后，Client 端的链接状态变成了 SYN_SENT 状态。Server 端收到 SYN 后，同意建立链接，会向 Client 端回复一个 ACK。</p>\n<p>由于 TCP 是双工传输，Server 端也会同时向 Client 端发送一个 SYN，申请 Server 向 Client 方向建立链接。发送完 ACK 和 SYN 后，Server 端的链接状态就变成了 SYN_RCVD。</p>\n<p>Client 收到 Server 的 ACK 后，Client 端的链接状态就变成了 ESTABLISHED 状态，同时，Client 向 Server 端发送 ACK，回复 Server 端的 SYN 请求。</p>\n<p>Server 端收到 Client 端的 ACK 后，Server 端的链接状态也就变成了的 ESTABLISHED 状态，此时建连完成，双方随时可以进行数据传输。</p>\n<p><strong>在面试时需要明白三次握手是为了建立双向的链接，需要记住 Client 端和 Server 端的链接状态变化。另外回答建连的问题时，可以提到 SYN 洪水攻击发生的原因，就是 Server 端收到 Client 端的 SYN 请求后，发送了 ACK 和 SYN，但是 Client 端不进行回复，导致 Server 端大量的链接处在 SYN_RCVD 状态，进而影响其他正常请求的建连。可以设置 tcp_synack_retries = 0 加快半链接的回收速度，或者调大 tcp_max_syn_backlog 来应对少量的 SYN 洪水攻击</strong></p>\n<h3>四次挥手</h3>\n<p>我们只要关注 80 端口与 13743 端口建立的连接断开过程，浏览器通过 13747 端口发送 [FIN, ACK] 这里是不是跟很多网上看到的不一样？</p>\n<ol>\n <li>其实是客户端在发送 [FIN] 报文的时候顺带发了一个 [ACK] 确认上次传输确认。</li>\n <li>接着服务端通过 80 端口响应了 [ACK] ，然后立马响应 [FIN, ACK] 表示数据传输完了，可以关闭连接。</li>\n <li>最后浏览器通过 13743 端口 发送 [ACK] 包给服务端，客服端与服务端连接就关闭了。</li>\n</ol>\n<p>具体流程如下图抓包所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023835983\" alt=\"四次挥手\" title=\"四次挥手\" /></p>\n<p><strong>三次握手与四次挥手</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023835986\" alt=\"TCP 连接与断开\" title=\"TCP 连接与断开\" /></p>\n<p><strong>客户端：</strong></p>\n<ul>\n <li>SYN_SENT - 客户端发起第 1 次握手后，连接状态为 SYN_SENT ，等待服务端内核进行应答，如果服务端来不及处理（例如服务端的 backlog 队列已满）就可以看到这种状态的连接。</li>\n <li>ESTABLISHED - 表示连接处于正常状态，可以进行数据传送。客户端收到服务器回复的 SYN+ACK 后，对服务端的 SYN 单独回复（第 3 次握手），连接建立完成，进入 ESTABLISHED 状态。服务端程序收到第 3 次握手包后，也进入 ESTABLISHED 状态。</li>\n <li>FIN_WAIT_1 - 客户端发送了关闭连接的 FIN 报文后，等待服务端回复 ACK 确认。</li>\n <li>FIN_WAIT_2 - 表示我方已关闭连接，正在等待服务端关闭。客户端发了关闭连接的 FIN 报文后，服务器发回 ACK 应答，但是没进行关闭，就会处于这种状态。</li>\n <li>TIME_WAIT - 双方都正常关闭连接后，客户端会维持 TIME_WAIT 一段时间，以确保最后一个 ACK 能成功发送到服务器端。停留时长为 2 倍的 MSL (报文最大生存时间)，Linux 下大约是 60 秒。所以在一个频繁建立短连接的服务器上通常可以看到成千上万的 TIME_WAIT 连接。</li>\n</ul>\n<p><strong>服务端：</strong></p>\n<ul>\n <li>LISTEN - 表示当前程序正在监听某个端口时。</li>\n <li>SYN_RCVD - 服务端收到第 1 次握手后，进入 SYN_RCVD 状态，并回复一个 SYN+ACK（第 2 次握手），再等待对方确认。</li>\n <li>ESTABLISHED - 表示连接处于正常状态，可以进行数据传送。完成 TCP3 次握手后，连接建立完成，进入 ESTABLISHED 状态。</li>\n <li>CLOSE_WAIT - 表示客户端已经关闭连接，但是本地还没关闭，正在等待本地关闭。有时客户端程序已经退出了，但服务端程序由于异常或 BUG 没有调用 close()函数对连接进行关闭，那在服务器这个连接就会一直处于 CLOSE_WAIT 状态，而在客户机已经不存在这个连接了。</li>\n <li>LAST_ACK - 表示正在等待客户端对服务端的关闭请求进行最终确认。</li>\n</ul>\n<p><strong>TIME_WAIT 状态存在的理由：</strong></p>\n<p><strong>划重点了</strong></p>\n<ul>\n <li>可靠地实现 TCP 全双工连接的终止 在进行关闭连接四路握手协议时，最后的 ACK 是由主动关闭端发出的，如果这个最终的 ACK 丢失，服务器将重发最终的 FIN，因此客户端必须维护状态信息允 许它重发最终的 ACK。如 果不维持这个状态信息，那么客户端将响应 RST 分节，服务器将此分节解释成一个错误（ 在 java 中会抛出 connection reset 的 SocketException)。因而，要实现 TCP 全双工连接的正常终 止，必须处理终止序列四个分节中任何一个分节的丢失情况，主动关闭 的客户端必须维持状 态信息进入 TIME_WAIT 状态。</li>\n <li>允许老的重复分节在网络中消逝 TCP 分节可能由于路由器异常而“迷途”，在迷途期间，TCP 发送端可能因确认超时而重发这个 分节，迷途的分节在路由器修复后也会被送到最终目的地，这个 原来的迷途分节就称为 lost duplicate。在关闭一个 TCP 连接后，马上又重新建立起一个相同的 IP 地址和端口之间的 TCP 连接，后一个连接被称为前一个连接的化身 （ incarnation)，那么有可能出现这种情况，前一 个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。为了避免 这个情 况，TCP 不允许处于 TIME_WAIT 状态的连接启动一个新的化身，<strong>因为 TIME_WAIT 状 态持续 2MSL，就可以保证当成功建立一个 TCP 连接的时 候，来自连接先前化身的重复分组已 经在网络中消逝</strong>。</li>\n</ul>\n<p><strong>另外回答断链的问题时，可以提到实际应用中有可能遇到大量 Socket 处在 TIME_WAIT 或者 CLOSE_WAIT 状态的问题。一般开启 tcp_tw_reuse 和 tcp_tw_recycle 能够加快 TIME-WAIT 的 Sockets 回收；而大量 CLOSE_WAIT 可能是被动关闭的一方存在代码 bug，没有正确关闭链接导致的。</strong></p>\n<p><strong>简单地说就是</strong></p>\n<ol>\n <li>保证 TCP 协议的全双工连接能够可靠关闭；</li>\n <li>保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆；</li>\n</ol>\n<h2>服务器处理请求并响应 HTTP 报文</h2>\n<p>深入分析下 HTTP 报文到底是什么玩意。数据传输都是通过 TCP/IP 协议负责底层的传输工作， HTTP 协议基本不用操心，所谓的 “超文本传输协议” 似乎不怎么例会 “传输” 这个事情，那 HTTP 的核心又是什么呢？</p>\n<p>比图 TCP 报文，它在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等。</p>\n<p>有了这个附加的 TCP 头，数据包才能够正确传输，到了目的地后把头部去掉，就可以拿到真正的数据。这个很容易理解，设置起点与终点，不同协议贴上不同的头部，到了对应目的地就拆下这个头部，提取真正的数据。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023835987\" alt=\"HTTP报文\" title=\"HTTP报文\" /></p>\n<p>与 TCP/UDP 类似需要在传输数据前设置一些请求头，不同的是 HTTP 是一个 “纯文本” 的协议，所有的头都是 ASCII 码的文本，很容易看出来是什么。</p>\n<p>再者就是他的请求报文与响应报文的结构基本一样，主要三大部分组成：</p>\n<ol>\n <li>起始行(Start Line)：描述请求或者响应的基本信息。</li>\n <li>Header：使用 key-value 的形式详细说明报文信息。</li>\n <li>空行。</li>\n <li>消息正文（Entity）：传输的数据，图片、视频、文本等都可以。</li>\n</ol>\n<p>这其中前两部分起始行和头部字段经常又合称为“<strong>请求头</strong>”或“<strong>响应头</strong>”，消息正文又称为“<strong>实体</strong>”，但与“<strong>header</strong>”对应，很多时候就直接称为“<strong>body</strong>”。</p>\n<p><strong>敲黑板了</strong></p>\n<p>HTTP 协议规定报文必须包含 Header，而且之后必须有一个 “空行”，也就是“CRLF”，十六进制的“0D0A”，可以没有 “body”。</p>\n<p>报文结构如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023835988\" alt=\"HTTP报文\" title=\"HTTP报文\" /></p>\n<p>截取一段报文：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023835991\" alt=\"HTTP报文抓取\" title=\"HTTP报文抓取\" /></p>\n<p><strong>请求头-起始行</strong></p>\n<p>请求行由请求方法字段、URL 字段和 HTTP 协议版本字段 3 个字段组成，它们用空格分隔。例如，GET / HTTP/1.1。</p>\n<p>HTTP 协议的请求方法有 <code>GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT</code>。</p>\n<p>GET 是请求方法， “/” 是请求的目标资源，“HTTP/1.1” 请求协议版本号。</p>\n<p><code>GET / HTTP/1.1</code> 翻译成文字大概就是：“hello，服务器，我要请求根目录下的默认文件使用的是 HTTP 1.1 协议版本”。</p>\n<p><strong>头部 Header</strong></p>\n<p>第二部分就是 Header，组成形式是 key：value，使用自定义头需要注意事项：</p>\n<ol>\n <li>header 字段不区分大小写，通常是首字母大写；</li>\n <li>字段名不允许有空格，可以使用 “-”，不能使用 “_”；</li>\n <li>字段名必须紧接着 “:”，不能有空格，但是 “:” 后面可以有空格。</li>\n <li>字段名顺序没有意义；</li>\n</ol>\n<h2>浏览器接收响应并渲染数据</h2>\n<p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。如果响应资源进行了压缩（比如 gzip），还需要进行解压。然后，对响应资源做缓存。接下来，根据响应资源里的 MIME[3] 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。</p>\n<p>接下来将接收到的数据渲染出来，不同的浏览器也不是完全相同，但是大致流程是一样的：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023835990\" alt=\"浏览器渲染页面流程\" title=\"浏览器渲染页面流程\" /></p>\n<p>如果觉得阅读后对你有帮助，希望多多分享、点赞与在看素质三连不做白嫖者。关注 【码哥字节】解锁更多硬核。</p>\n<p><strong>推荐阅读</strong></p>\n<p>以下几篇文章阅读量与读者反馈都很好，推荐大家阅读：</p>\n<ul>\n <li><a href=\"https://mp.weixin.qq.com/s/lJSnLgJ1gE-0RtQdrw2e3g\" rel=\"nofollow noreferrer\">RESTful 最佳实践</a></li>\n <li><a href=\"https://mp.weixin.qq.com/s/fU5Jj9tQvNTjRiT9grm6RA\" rel=\"nofollow noreferrer\">Tomcat 架构原理解析到架构设计借鉴</a></li>\n <li><a href=\"https://mp.weixin.qq.com/s/0jj7QfQCxEIBS2PM58H4bw\" rel=\"nofollow noreferrer\">Tomcat 高并发之道原理拆解与性能调优</a></li>\n <li><a href=\"https://mp.weixin.qq.com/s/HoSul-GjX6FmulY6ugdmgQ\" rel=\"nofollow noreferrer\">数据库系统设计概述</a></li>\n</ul>\n<p>公众号后台回复 ”加群“，加入读者技术群，里面有阿里、腾讯的小伙伴一起探讨技术。</p>\n<p>我的个人微信：<strong>MageByte1024</strong></p>","descriptionType":"html","publishedDate":"Mon, 31 Aug 2020 09:29:03 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023835981","linkMd5":"11320f189f6b74cb092e6a54ca53cc59","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn21@2020_2/2020/09/01/03-37-53-749_148d9cc269b7b49b.webp","destWidth":800,"destHeight":619,"sourceBytes":150577,"destBytes":20332,"author":"码哥字节","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023835981":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn21@2020_2/2020/09/01/03-37-53-749_148d9cc269b7b49b.webp","https://segmentfault.com/img/remote/1460000023835982":"https://cdn.jsdelivr.net/gh/myreaderx/cdn59@2020_1/2020/09/01/03-37-58-947_c6e6d48e1f719d09.webp","https://segmentfault.com/img/remote/1460000023835984":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn75@2020_4/2020/09/01/03-37-58-547_c5267cfd3bf7c079.webp","https://segmentfault.com/img/remote/1460000023835985":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn80@2020_3/2020/09/01/03-37-58-498_ec6ffbbfb1079ac1.webp","https://segmentfault.com/img/remote/1460000023835989":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn70@2020_2/2020/09/01/03-37-56-978_718ac95e2e6a9d79.webp","https://segmentfault.com/img/remote/1460000023835983":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn64@2020_1/2020/09/01/03-37-58-336_a5a9f542f4afb62e.webp","https://segmentfault.com/img/remote/1460000023835986":null,"https://segmentfault.com/img/remote/1460000023835987":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn88@2020_3/2020/09/01/03-37-58-456_ce9a5c21e316ff27.webp","https://segmentfault.com/img/remote/1460000023835988":null,"https://segmentfault.com/img/remote/1460000023835991":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn51@2020_6/2020/09/01/03-37-58-589_6cea6f4153ccda38.webp","https://segmentfault.com/img/remote/1460000023835990":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn56@2020_4/2020/09/01/03-37-58-430_93934df93f8b9105.webp"},"publishedOrCreatedDate":1598931423820},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"Node 在 Controller 层如何进行数据校验","link":"https://segmentfault.com/a/1190000023797742","description":"<blockquote>\n <p>本文收录于 GitHub 山月行博客: <a href=\"https://github.com/shfshanyue/blog\" rel=\"nofollow noreferrer\">shfshanyue/blog</a>，内含我在实际工作中碰到的问题、关于业务的思考及在全栈方向上的学习</p>\n <ul>\n  <li><a href=\"https://github.com/shfshanyue/blog#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96\" rel=\"nofollow noreferrer\">前端工程化系列</a></li>\n  <li><a href=\"https://github.com/shfshanyue/blog#node-%E5%AE%9E%E8%B7%B5\" rel=\"nofollow noreferrer\">Node进阶系列</a></li>\n </ul>\n</blockquote>\n<p>幽默风趣的后端程序员一般自嘲为 CURD Boy。CURD, 也就是对某一存储资源的增删改查，这完全是面向数据编程啊。</p>\n<p>真好呀，面向数据编程，往往会对业务理解地更加透彻，从而写出更高质量的代码，造出更少的 BUG。既然是面向数据编程那更需要避免脏数据的出现，加强数据校验。否则，难道要相信前端的数据校验吗，毕竟前端数据校验直达用户，是为了 UI 层更友好的用户反馈。</p>\n<h2>数据校验层</h2>\n<p>后端由于重业务逻辑以及待处理各种数据，以致于分成各种各样的层级，以我经历过的后端项目就有分为 <code>Controller</code>、<code>Service</code>、<code>Model</code>、<code>Helper</code>、<code>Entity</code> 等各种命名的层，五花八门。但这里肯定有一个层称为 <code>Controller</code>，站在后端最上层直接接收客户端传输数据。</p>\n<p>由于 <code>Controller</code> 层是服务器端中与客户端数据交互的最顶层，秉承着 <code>Fail Fast</code> 的原则，肩负着数据过滤器的功能，对于不合法数据直接打回去，如同秦琼与尉迟恭门神般威严。</p>\n<p>数据校验同时衍生了一个半文档化的副产品，你只需要看一眼数据校验层，便知道要传哪些字段，都是些什么格式。</p>\n<p>以下都是常见的数据校验，本文讲述如何对它们进行校验：</p>\n<ol>\n <li>required/optional</li>\n <li>基本的数据校验，如 number、string、timestamp 及值需要满足的条件</li>\n <li>复杂的数据校验，如 IP、手机号、邮箱与域名</li>\n</ol>\n<pre><code class=\"js\">const body = {\n  id,\n  name,\n  mobilePhone,\n  email\n}</code></pre>\n<p>山月接触过一个没有数据校验层的后端项目，<code>if/else</code> 充斥在各种层级，万分痛苦，分分钟向重构。</p>\n<h2>JSON Schema</h2>\n<p><code>JSON Schema</code> 基于 JSON 进行数据校验格式，并附有一份规范 <a href=\"http://json-schema.org/\" rel=\"nofollow noreferrer\">json-schema.org</a>，目前 (2020-08) 最新版本是 7.0。各种服务器编程语言都对规范进行了实现，如 <code>go</code>、<code>java</code>、<code>php</code> 等，当然伟大的 javascript 也有，如不温不火的 <a href=\"https://github.com/ajv-validator/ajv\" rel=\"nofollow noreferrer\">ajv</a>。</p>\n<p>以下是校验用户信息的一个 Schema，可见语法复杂与繁琐:</p>\n<pre><code class=\"json\">{\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"User\",\n  \"description\": \"用户信息\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"description\": \"用户 ID\",\n      \"type\": \"integer\"\n    },\n    \"name\": {\n      \"description\": \"用户姓名\",\n      \"type\": \"string\"\n    },\n    \"email\": {\n      \"description\": \"用户邮箱\",\n      \"type\": \"string\",\n      \"format\": \"email\",\n      \"maxLength\": 20\n    },\n    \"mobilePhone\": {\n      \"description\": \"用户手机号\",\n      \"type\": \"string\",\n      \"pattern\": \"^(?:(?:\\+|00)86)?1[3-9]\\d{9}$\",\n      \"maxLength\": 15\n    }\n  },\n  \"required\": [\"id\", \"name\"]\n}</code></pre>\n<p>对于复杂的数据类型校验，JSON Schema 内置了以下 Format，方便快捷校验</p>\n<ul>\n <li>Dates and times</li>\n <li>Email addresses</li>\n <li>Hostnames</li>\n <li>IP Addresses</li>\n <li>Resource identifiers</li>\n <li>URI template</li>\n <li>JSON Pointer</li>\n <li>Regular Expressions</li>\n</ul>\n<p>对于不在内置 Format 中的手机号，使用 <code>ajv.addFormat</code> 可手动添加 Format</p>\n<pre><code class=\"js\">ajv.addFormat('mobilePhone', (str) =&gt; /^(?:(?:\\+|00)86)?1[3-9]\\d{9}$/.test(str));</code></pre>\n<h2>Joi</h2>\n<p><a href=\"https://github.com/sideway/joi\" rel=\"nofollow noreferrer\">joi</a> 自称最强大的 JS 校验库，在 github 也斩获了一万六颗星星。相比 JSON Schema 而言，它的语法更加简洁并且功能强大。</p>\n<blockquote>\n The most powerful data validation library for JS\n</blockquote>\n<p>完成相同的校验，仅需要更少的代码，并能够完成更加强大的校验。以下仅做示例，更多示例请前往文档。</p>\n<pre><code class=\"js\">const schema = Joi.object({\n  id: Joi.number().required(),\n  name: Joi.number().required(),\n  email: Joi.string().email({ minDomainSegments: 2, tlds: { allow: ['com', 'net'] } }),\n  mobilePhone: Joi.string().pattern(/^(?:(?:\\+|00)86)?1[3-9]\\d{9}$/),\n\n  password: Joi.string().pattern(/^[a-zA-Z0-9]{3,30}$/),\n  // 与 password 相同的校验\n  repeatPassword: Joi.ref('password'),\n})\n  // 密码与重复密码需要同时发送\n  .with('password', 'repeat_password');\n  // 邮箱与手机号提供一个即可\n  .xor('email', 'mobilePhone')</code></pre>\n<h2>数据校验与路由层集成</h2>\n<p>由于数据直接从路由传递，因此 <code>koajs</code> 官方基于 <code>joi</code> 实现了一个 <a href=\"https://github.com/koajs/joi-router\" rel=\"nofollow noreferrer\">joi-router</a>，前置数据校验到路由层，对前端传递来的 <code>query</code>、<code>body</code> 与 <code>params</code> 进行校验。</p>\n<p><code>joi-router</code> 也同时基于 <code>co-body</code> 对前端传输的各种 <code>content-type</code> 进行解析及限制。如限制为 <code>application/json</code>，也可在一定程度上防止 CSRF 攻击。</p>\n<pre><code class=\"js\">const router = require('koa-joi-router');\nconst public = router();\n\npublic.route({\n  method: 'post',\n  path: '/signup',\n  validate: {\n    header: joiObject,\n    query: joiObject,\n    params: joiObject,\n    body: joiObject,\n    maxBody: '64kb',\n    output: { '400-600': { body: joiObject } },\n    type: 'json',\n    failure: 400,\n    continueOnError: false\n  },\n  pre: async (ctx, next) =&gt; {\n    await checkAuth(ctx);\n    return next();\n  },\n  handler: async (ctx) =&gt; {\n    await createUser(ctx.request.body);\n    ctx.status = 201;\n  },\n});</code></pre>\n<h2>正则表达式与安全正则表达式</h2>\n<p>山月在一次排查性能问题时发现，一条 API 竟在数据校验层耗时过久，这是我未曾想到的。而问题根源在于不安全的正则表达式，那什么叫做不安全的正则表达式呢？</p>\n<p>比如下边这个能把 CPU 跑挂的正则表达式就是一个定时炸弹，回溯次数进入了指数爆炸般的增长。</p>\n<blockquote>\n 可以参考文章 \n <a href=\"https://www.freebuf.com/articles/network/124422.html\" rel=\"nofollow noreferrer\">浅析 ReDos 原理与实践</a>\n</blockquote>\n<pre><code class=\"js\">const safe = require('safe-regex')\nconst re = /(x+x+)+y/\n\n// 能跑死 CPU 的一个正则\nre.test('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')\n\n// 使用 safe-regex 判断正则是否安全\nsafe(re)   // false</code></pre>\n<p>数据校验，针对的大多是字符串校验，也会充斥着各种各样的正则表达式，保证正则表达式的安全相当紧要。<a href=\"https://github.com/substack/safe-regex\" rel=\"nofollow noreferrer\">safe-regex</a> 能够发现哪些不安全的正则表达式。</p>\n<h2>总结</h2>\n<ol>\n <li>Controller 层需要进行统一的数据校验，可以采用 JSON Schema (Node 实现 ajv) 与 Joi</li>\n <li>JSON Schema 有官方规范及各个语言的实现，但语法繁琐，可使用校验功能更为强大的 Joi</li>\n <li>进行字符串校验时，注意不安全的正则引起的性能问题</li>\n</ol>","descriptionType":"html","publishedDate":"Thu, 27 Aug 2020 23:19:23 +0000","feedId":6615,"bgimg":"","linkMd5":"dc7f3b7df9b5c752479765443909f10a","bgimgJsdelivr":"","metaImg":"","author":"shanyue","publishedOrCreatedDate":1598931423823},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"「译」如何实现交互式 WebGL 悬停效果","link":"https://segmentfault.com/a/1190000023798228","description":"<blockquote>\n <ul>\n  <li>原文地址：<a href=\"https://tympanus.net/codrops/2020/04/14/interactive-webgl-hover-effects/\" rel=\"nofollow noreferrer\">Interactive WebGL Hover Effects</a></li>\n  <li>原文作者：<a href=\"https://tympanus.net/codrops/author/akella/\" rel=\"nofollow noreferrer\">Yuriy Artyukh</a></li>\n </ul>\n <p>本文主要内容是介绍如何通过一些简单的步骤，在图像上实现交互式鼠标悬停效果。</p>\n <p><a href=\"https://tympanus.net/Tutorials/webgl-mouseover-effects/step3.html\" rel=\"nofollow noreferrer\">查看 Demo</a> 或 <a href=\"https://github.com/akella/webgl-mouseover-effects/archive/master.zip\" rel=\"nofollow noreferrer\">下载源码</a></p>\n</blockquote>\n<p>我很喜欢 WebGL，在本文中，我将介绍如何在掌握着色器基础上做出炫酷效果。我想要重现的这个效果，源自 <a href=\"https://jesperlandberg.dev/\" rel=\"nofollow noreferrer\">Jesper Landberg</a> 的网站，他是一个非常酷的家伙，请务必查看一下他网站上的东西。</p>\n<p><img src=\"https://segmentfault.com/img/bVbL09U\" alt=\"image\" title=\"image\" /></p>\n<p>让我们开始吧！让我们从编写简单的 HTML 开始：</p>\n<pre><code class=\"html\">&lt;div class=\"item\"&gt;\n    &lt;img src=\"img.jpg\" class=\"js-image\" alt=\"\"&gt;\n    &lt;h2&gt;Some title&lt;/h2&gt;\n    &lt;p&gt;Lorem ipsum.&lt;/p&gt;\n&lt;/div&gt;\n&lt;script src=\"app.js\"&gt;&lt;/script&gt;</code></pre>\n<p>这个例子再简单不过了！接下来，让我们来添加些样式，以使其它起来更漂亮：</p>\n<p><img src=\"https://segmentfault.com/img/bVbL096\" alt=\"image\" title=\"image\" /></p>\n<p>所有动画效果将在 Canvas 元素中呈现，同时我们还需要添加部分 JavaScript 代码。我在这里使用 <a href=\"https://parceljs.org/\" rel=\"nofollow noreferrer\">Parcel</a>，因为学习起来非常简单，我还将在 WebGL 部分中使用 <a href=\"https://threejs.org/\" rel=\"nofollow noreferrer\">Three.js</a>。</p>\n<p>到这里，我们开始编写 JavaScript 代码，并按照官方文档着手进行基本的 Three.js 设置：</p>\n<pre><code class=\"js\">import * as THREE from \"three\";\n\nvar scene = new THREE.Scene();\nvar camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );\n\nvar renderer = new THREE.WebGLRenderer();\nrenderer.setSize( window.innerWidth, window.innerHeight );\ndocument.body.appendChild( renderer.domElement );\n\n\ncamera.position.z = 5;\n\nvar animate = function () {\n    requestAnimationFrame( animate );\n\n    cube.rotation.x += 0.01;\n    cube.rotation.y += 0.01;\n\n    renderer.render( scene, camera );\n};\n\nanimate();</code></pre>\n<p>让我们设置 Canvas 元素的样式：</p>\n<pre><code class=\"css\">body { margin: 0; }\n\ncanvas { \n    display: block; \n    position: fixed;\n    z-index: -1; // 将其设置为背景\n    left: 0; // 铺满整个屏幕\n    top: 0; // 铺满整个屏幕\n}</code></pre>\n<p>当你完成所有这些操作，就可以使用 <code>parcel index.html</code> 运行它。现在，您不会看到太多，到目前为止，它是一个空的 3D 场景。让我们暂时搁置 HTML，专注于 3D 场景操作。</p>\n<p>让我们创建一个带有图像的简单 <a href=\"https://threejs.org/docs/#api/en/geometries/PlaneBufferGeometry\" rel=\"nofollow noreferrer\">PlaneBufferGeometry</a> 对象。像这样：</p>\n<pre><code class=\"js\">let TEXTURE = new TextureLoader().load('supaAmazingImage.jpg'); \nlet mesh = new Mesh(\n    new PlaneBufferGeometry(), \n    new MeshBasicMaterial({map: TEXTURE})\n)</code></pre>\n<p>现在，我们将看到以下内容：</p>\n<p><img src=\"https://segmentfault.com/img/bVbL1ag\" alt=\"image\" title=\"image\" /></p>\n<p>显然我们还没有实现效果，我们需要追踪鼠标的颜色轨迹。当然，我们还需要着色器。如果您对着色器感兴趣，或者您可能已经学过一些有关如何放置图像的教程，例如<a href=\"https://tympanus.net/codrops/2018/04/10/webgl-distortion-hover-effects/\" rel=\"nofollow noreferrer\">如何将鼠标放在悬停位置上？</a><a href=\"https://tympanus.net/codrops/2017/10/10/liquid-distortion-effects/\" rel=\"nofollow noreferrer\">液体变形效果？</a></p>\n<p>但是我们有一个问题：我们只能在上面的示例中在该图像上（和内部）使用着色器。但是效果并不局限于任何图像边界，而是流动的，覆盖整个区域，就像整个屏幕一样。</p>\n<h2>后期处理进行渲染</h2>\n<p>事实证明 Three.js 渲染器的输出只是另一幅图像。我们可以利用它，并在该输出上应用着色器位移！</p>\n<p>这是代码的补充部分：</p>\n<pre><code class=\"js\">// 设置后期处理\nlet composer = new EffectComposer(renderer);\nlet renderPass = new RenderPass(scene, camera);\n// 用图像渲染场景\ncomposer.addPass(renderPass);\n\n// 我们的自定义着色器传递整个屏幕，以替换以前的渲染\nlet customPass = new ShaderPass({vertexShader,fragmentShader});\n// 确保我们正在渲染它\ncustomPass.renderToScreen = true;\ncomposer.addPass(customPass);\n\n// 最后真正使用我们的着色器渲染场景\ncomposer.render()\n// 而不是以前的 render()\n// renderer.render(scene, camera);</code></pre>\n<p>但整个过程用一句话概括就是，着色器被应用到了整个屏幕上。</p>\n<p>接下来，让我们完成具有炫酷效果的最终着色器：</p>\n<pre><code class=\"js\">// 在鼠标周围留一个小圆圈，并保持一定距离\nfloat c = circle(uv, mouse, 0.0, 0.2);\n// 获取 3 次纹理，每次具有不同的偏移量，具体取决于鼠标速度：\nfloat r = texture2D(tDiffuse, uv.xy += (mouseVelocity * .5)).x;\nfloat g = texture2D(tDiffuse, uv.xy += (mouseVelocity * .525)).y;\nfloat b = texture2D(tDiffuse, uv.xy += (mouseVelocity * .55)).z;\n// 将所有内容合并到最终输出\ncolor = vec4(r, g, b, 1.);</code></pre>\n<p>您可以在<a href=\"https://tympanus.net/Tutorials/webgl-mouseover-effects/step1.html\" rel=\"nofollow noreferrer\">第一个演示</a>中看到此结果。</p>\n<h2>将效果应用于多张图像</h2>\n<p>屏幕具有不同尺寸，3D 图像也各自具有尺寸。因此，我们现在要做的是计算这两者之间的某种关系。</p>\n<p>就像我一样吗？在<a href=\"https://tympanus.net/codrops/2019/11/05/creative-webgl-image-transitions/\" rel=\"nofollow noreferrer\">上一篇文章</a>中，我们可以制作一个宽度为 1 的平面，并将其完全适配屏幕宽度。所以实际上，我们使用了： <code>WidthOfPlane=ScreenSize</code>。</p>\n<p>对于我们的 Three.js 场景，这意味着如果要在屏幕上显示 100px 宽的图像，我们将创建一个 Three.js 对象，其宽度为 <code>100*(WidthOfPlane/ScreenSize)</code>。通过这种数学运算，我们还可以轻松设置一些边距和位置。</p>\n<p>页面加载后，我将遍历所有图像，获取它们的尺寸，并将它们添加到我的 3D 世界中：</p>\n<pre><code class=\"js\">let images = [...document.querySelectorAll('.js-image')];\nimages.forEach(image=&gt;{\n    // 现在，我们有了图像的大小和左边、上边的位置\n    let dimensions = image.getBoundingClientRect();\n    // 隐藏原始图像\n    image.style.visibility = hidden;\n    // 根据其 HTML 将 3D 对象添加到场景中\n    createMesh(dimensions);\n})</code></pre>\n<p>现在，制作<a href=\"https://tympanus.net/Tutorials/webgl-mouseover-effects/step1.html\" rel=\"nofollow noreferrer\">这个</a><a href=\"https://tympanus.net/Tutorials/webgl-mouseover-effects/step2.html\" rel=\"nofollow noreferrer\">HTML-3D混合结构</a>非常简单。</p>\n<p>关于 <code>mouseVelocity</code> 我想补充的是，我用它来改变效果的半径，鼠标移动得越快，半径越大。</p>\n<p>要使其可滚动，我们只需要移动整个场景即可，与滚动屏幕的数量相同。使用我之前提到的相同公式：<code>NumberOfPixels*(WidthOfPlane/ScreenSize)</code>。</p>\n<p>有时，<code>WidthOfPlane</code> 等于甚至更容易 <code>ScreenSize</code>。这样，您最终在两个世界中得到的数字完全相同！</p>\n<h2>探索不同的效果</h2>\n<p>使用不同的着色器，您可以使用此方法产生任何效果。因此，我决定使用一些参数。</p>\n<p>无需将图像分为三个颜色层，我们可以根据与鼠标的距离来简单地移动图像：</p>\n<pre><code class=\"js\">vec2 newUV = mix(uv, mouse, circle); \ncolor = texture2D(tDiffuse,newUV);</code></pre>\n<p>对于最后一个效果，我使用了一些随机性，以在鼠标光标周围获得像素化效果。</p>\n<p>在<a href=\"https://tympanus.net/Tutorials/webgl-mouseover-effects/step3.html\" rel=\"nofollow noreferrer\">最后一个演示</a>中，您可以在效果之间切换以查看可以进行的一些修改。有了“缩放”效果，我只使用了一个位移，但是在最后一个中，我还对像素进行了随机化，这对我来说看起来很酷！</p>\n<p>很高兴看到您对此动画的想法。您将用这种技术产生什么样的效果？</p>\n<p>在 <a href=\"https://github.com/akella/webgl-mouseover-effects/\" rel=\"nofollow noreferrer\">GitHub</a> 上找到这个项目。</p>","descriptionType":"html","publishedDate":"Fri, 28 Aug 2020 00:54:58 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbL09U","linkMd5":"d167da38ff728721e4952cff6ba6724a","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn9@2020_5/2020/09/01/03-37-53-209_227eed20c6d87d00.webp","destWidth":320,"destHeight":200,"sourceBytes":1142328,"destBytes":164322,"author":"前端zenblo","articleImgCdnMap":{"https://segmentfault.com/img/bVbL09U":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn9@2020_5/2020/09/01/03-37-53-209_227eed20c6d87d00.webp","https://segmentfault.com/img/bVbL096":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn10@2020_5/2020/09/01/03-37-58-539_efe6e4b19f6012d9.webp","https://segmentfault.com/img/bVbL1ag":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn79@2020_4/2020/09/01/03-37-59-143_6d3087a652bb0127.webp"},"publishedOrCreatedDate":1598931423823},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"Jetpack Compose 重磅更新！最全的新组件上手指南！","link":"https://segmentfault.com/a/1190000023829018","description":"<blockquote>\n 文章首发于公众号：\n <code>「 技术最TOP 」</code>，每天都有干货文章持续更新，可以微信搜索\n <code>「 技术最TOP 」</code>第一时间阅读，回复【思维导图】【面试】【简历】有我准备一些Android进阶路线、面试指导和简历模板送给你\n</blockquote>\n<p>Jetpack Compose 是Google发布的一个Android原生现代UI工具包，它完全采用Kotlin编写，可以使用Kotlin语言的全部特性，可以帮助你轻松、快速的构建高质量的Android应用程序。如果你还不了解Jetpack Compose是什么？建议你读一下我前面的2篇文章：</p>\n<p><a href=\"https://juejin.im/post/6844903999347359751\" rel=\"nofollow noreferrer\">Android Jetpack Compose 最全上手指南</a></p>\n<p><a href=\"https://juejin.im/post/6844904165408243725\" rel=\"nofollow noreferrer\">Jetpack Compose,不止是一个UI框架！</a></p>\n<p>去年的Google IO 大会上，Google宣布了Jetpack Compose的面世，但是在去年11月份，它才发布第一个预览版-Developer Preview1，此后，基本保持每两周发布一个小版本，到现在，半年的时间过去了，中间发布了十多个小版本，今天，终于迎来了重大更新，Developer Preview2 发布了。</p>\n<p>Jetpack Compose Developer Preview1发布后，开发者最关心的几个问题是，没有Compose版本的RecyclerView、Constriantlayout、动画等一系列问题。这些问题在Preview2都解决了。</p>\n<p>当然，从Preview1 到现在发布的Preview2，变化非常大，甚至很多API都已经变了，有的属性或者类的增加或者删除。具体的变换化太多，就不在这里一一讲解，感兴趣的可以看看官方的每个小版本的更新日志。今天就带大家一起看看PreView2增加的一些重磅功能。</p>\n<ul>\n <li>1、Modifier</li>\n <li>2、RecyclerView</li>\n <li>3、Constriantlayout</li>\n <li>4、动画</li>\n <li>5、原生View引入Compose</li>\n</ul>\n<p>好戏开场了！</p>\n<h3>1、Modifier</h3>\n<p>首先，说一下Modifier(修改器)，在Preview1版本，就已经有了modifier,不过使用的地方不多，并且对于它的定位比较模糊，令人困惑，因为modifier能干的事儿，通过组合函数也能做到。但是我们发现了一件事，例如，要在Compose函数中增加padding的时候，会产生大量的嵌套，因为要给嵌套一个容器才能设置padding,因此，现在将很多功能都移动到了Modifier,它现在使用非常广泛，可以修饰一个元素、一个布局或者一些其他行为。如何使用Modifier?先来看一个例子：</p>\n<p>首先，我们写一个Compose函数（即Compose组件），展示一张图片</p>\n<pre><code class=\"kotlin\">@Composable\nfun Greeting() {\n    val (shape,setShape) = state&lt;Shape&gt; { CircleShape }\n    Image(asset = imageResource(R.drawable.androidstudio),\n        contentScale = ContentScale.Crop )\n}</code></pre>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023829022\" alt=\"\" title=\"\" /></p>\n<p>图片显示的是原来的尺寸，然后给图片指定一个大小，比如：256dp,此时就需要使用Modifier了。</p>\n<pre><code class=\"kotlin\">@Composable\nfun Greeting() {\n    val (shape,setShape) = state&lt;Shape&gt; { CircleShape }\n    Image(asset = imageResource(R.drawable.androidstudio),\n        contentScale = ContentScale.Crop,\n     modifier = Modifier.size(256.dp))\n}</code></pre>\n<p>修改后如下，宽高都为256dp。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023829021\" alt=\"\" title=\"\" /></p>\n<p>modifier中有很多可以配的参数，比如，<code>增加一个padding</code>,<code>将图片裁剪成一个圆形</code>。</p>\n<pre><code class=\"kotlin\">@Composable\nfun Greeting() {\n    val (shape,setShape) = state&lt;Shape&gt; { CircleShape }\n    Image(asset = imageResource(R.drawable.androidstudio),\n        contentScale = ContentScale.Crop,\n     modifier = Modifier.size(256.dp)\n         .padding(16.dp)\n         .drawShadow(8.dp,shape = shape)\n        )\n}</code></pre>\n<p>效果就成了这样：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023829023\" alt=\"\" title=\"\" /></p>\n<p>还可以再圆形头像加一个<code>border</code>，代码如下：</p>\n<pre><code class=\"kotlin\">@Composable\nfun Greeting() {\n    val (shape,setShape) = state&lt;Shape&gt; { CircleShape }\n    Image(asset = imageResource(R.drawable.androidstudio),\n        contentScale = ContentScale.Crop,\n     modifier = Modifier.size(256.dp)\n         .padding(16.dp)\n         .drawShadow(8.dp,shape = shape)\n         .drawBorder(6.dp,MaterialTheme.colors.primary,shape = shape)\n        )\n}</code></pre>\n<p>效果如下：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023829024\" alt=\"\" title=\"\" /></p>\n<p>还可以同时添加多个border，比如我再增加2个：</p>\n<pre><code class=\"kotlin\">@Composable\nfun Greeting() {\n    val (shape,setShape) = state&lt;Shape&gt; { CircleShape }\n    Image(asset = imageResource(R.drawable.androidstudio),\n        contentScale = ContentScale.Crop,\n     modifier = Modifier.size(256.dp)\n         .padding(16.dp)\n         .drawShadow(8.dp,shape = shape)\n         .drawBorder(6.dp,MaterialTheme.colors.primary,shape = shape)\n         .drawBorder(12.dp,MaterialTheme.colors.secondary,shape = shape)\n         .drawBorder(18.dp,MaterialTheme.colors.background,shape = shape)\n        )\n}</code></pre>\n<p>效果就成这样了：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023829026\" alt=\"\" title=\"\" /></p>\n<p>设置点击事件也是再modifier中，比如我们要在点击这个图片后，改变形状，以前的View可麻烦了，但是Jetpack compose 却非常简单，modifier中增加如下代码：</p>\n<pre><code>@Composable\nfun Greeting() {\n    val (shape,setShape) = state&lt;Shape&gt; { CircleShape }\n    Image(asset = imageResource(R.drawable.androidstudio),\n        contentScale = ContentScale.Crop,\n     modifier = Modifier.size(256.dp)\n         .padding(16.dp)\n         .drawShadow(8.dp,shape = shape)\n         .drawBorder(6.dp,MaterialTheme.colors.primary,shape = shape)\n         .drawBorder(12.dp,MaterialTheme.colors.secondary,shape = shape)\n         .drawBorder(18.dp,MaterialTheme.colors.background,shape = shape)\n         .clickable { // 点击事件\n             setShape(\n                 if(shape == CircleShape)\n                     CutCornerShape(topLeft = 32.dp,bottomRight = 32.dp)\n                else\n                     CircleShape\n             )\n         }\n        )\n}</code></pre>\n<p>上面的代码中，我们还增加了判断，如果当前shape是<code>CircleShape</code>,我们就改变形状，否则就设置为<code>CircleShape</code>,效果就是点击图片，形状在这两种效果之间来回切换。</p>\n<p>效果如下:</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023829025\" alt=\"\" title=\"\" /></p>\n<h3>2. Jetpack Compose 中的RecyclerView</h3>\n<p>RecyclerView是我们Android开发中用来展示大数据列表的常用组件，它能帮助我们回收复用视图，有很好的性能体验。在Jetpack Developer PreView1 刚出来的时候，我就在官网或者代码库中找这个组件。很遗憾翻遍了所有资料都每找到，是确实没有，最终只找到了一个叫做<code>VerticalScroller</code>的组件你。它可以用来展示列表，但是它不是RecyclerView,它类似我们的ScrollView,也就是说，展示少量数据的列表是可以的，因为它没有复用机制，展示大列表时，内存堪忧，会OOM。</p>\n<p>但是在这次的Preview2中，RecyclerView终于被盼来了，组件名字叫做：<code>AdapterList</code>,它就对应我们原生Android开发的RecyclerView。以前我们要写一个列表是非常复杂的，用写xml,Adapter,ViewHolder等，最终还要在Activity/Fragment初始化和绑定数据，非常麻烦。Jetpack Compose中的列表使用则是非常简单，简单到令人发指。来看一下我们如何展示一个列表：</p>\n<pre><code class=\"kotlin\">@Composable\nfun generateList(context: Context) {\n    val list = mutableListOf&lt;String&gt;()\n    //准备数据\n    for (i in 1..100) {\n        list.add(i.toString())\n    }\n    AdapterList(data = list) {\n        Card(\n            shape = MaterialTheme.shapes.medium,\n            modifier = Modifier\n                .preferredSize(context.resources.displayMetrics.widthPixels.dp, 60.dp)\n                .padding(10.dp)\n        ) {\n\n            Box(gravity = ContentGravity.Center) {\n                ProvideEmphasis(EmphasisAmbient.current.medium) {\n                    Text(\n                        text = it,\n                        style = MaterialTheme.typography.body2\n                    )\n                }\n            }\n\n        }\n        Spacer(modifier = Modifier.preferredHeight(10.dp))\n    }\n}</code></pre>\n<p>看到了没，就是这样几行代码，我们的列表就完成了，解释一下代码：最开始的准备数据没啥说的，向list中添加了100个数据，然后将数据源传给<code>AdapterList</code>,列表的每一个Item是一个卡片，用的是Card组件，卡片里展示了一个Text文本，最后的<code>Spacer</code>用来设置item之间的间距，相当于<code>ItemDecoration</code>,看一下效果：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023829027\" alt=\"\" title=\"\" /></p>\n<h3>3. Constriantlayout</h3>\n<p><code>Constriantlayout</code>是一个功能非常强大的布局，也是现在Android开发中最受欢迎的布局之一，当Jetpack Compose Preview1版本才出来的时候，很多开发者都有一个疑问，Compose 中该如何使用<code>Constriantlayout</code>呢？它将如何运作，这确实是个有意思的问题。因为在Jetpack Compose中，所有的组件都是组合函数，获取不到View饮用，如何约束彼此之间的关系确实是一个难题。好在现在这个难题解决了，下面通过几个小例子一起来看看Compose中的<code>Constriantlayout</code>使用。</p>\n<p>如下图所示，有两个View,A和B,ViewB在ViewA的右边，顶部和ViewA的底部对齐，如何使用Constriantlayout 描述它们的位置关系？</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023829028\" alt=\"\" title=\"\" /></p>\n<p>代码：</p>\n<pre><code class=\"kotlin\">@Composable\nfun GreetConstraintLayout(context: Context) {\n    ConstraintLayout(constraintSet = ConstraintSet {\n        val viewA = tag(\"ViewTagA\").apply {\n            left constrainTo parent.left\n            centerVertically()\n        }\n       val viewB =  tag(\"ViewTagB\").apply {\n            left constrainTo viewA.right\n            centerVertically()\n            top constrainTo viewA.bottom\n        }\n    }, modifier = Modifier.preferredSize(context.screenWidth().dp,400.dp).drawBackground(Color.LightGray)) {\n\n        Box(\n            modifier = Modifier.tag(\"ViewTagA\").preferredSize(100.dp, 100.dp),\n            backgroundColor = Color.Blue,\n            gravity = ContentGravity.Center\n        ) {\n            Text(text = \"A\")\n        }\n        Box(\n            modifier = Modifier.tag(\"ViewTagB\").preferredSize(100.dp, 100.dp),\n            backgroundColor = Color.Green,\n            gravity = ContentGravity.Center\n        ) {\n            Text(text = \"B\")\n        }\n    }\n}</code></pre>\n<p>解释一下上面的代码：在<code>ConstraintSet</code>中来定义约束，使用Tag来创建一个约束，后面我们就可以通过这个tag来使用我们定义的约束，返回的是一个<code>ConstrainedLayoutReference</code>，ViewA的左边与父组件的左边对齐，垂直居中。ViewB的左边与ViewA的右边对齐，top与ViewA的底部对齐。也垂直居中。</p>\n<p>比如ViewB中就是使用ViewA来作为约束条件了。</p>\n<p>后面使用的时候，直接用<code>Modifier.tag()</code>应用约束到组件上。</p>\n<p>这还不是最牛逼，还有一个强大的功能是可以在布局约束中添加逻辑，比如：我有一个ViewC 它的位置可能有两种情况：</p>\n<ul>\n <li>1、ViewC 的左边与ViewA的右边对齐</li>\n <li>2、View C的左边与ViewB的右边对齐</li>\n</ul>\n<p>该怎么写代码？先定一个一个Boolean 变量叫<code>hasFlag</code>(随便其的名，它的值根据你的业务逻辑某些情况是true,某些情况是false)</p>\n<pre><code class=\"kotlin\"> val hasFlag = true // 它的值根据你的业务逻辑某些情况是true,某些情况是false\n \n tag(\"ViewC\").apply {\n            // 根据判断条件改变，约束也改变\n            left constrainTo (if(hasFlag) viewA else viewB).right\n            bottom constrainTo viewB.top\n        }\n</code></pre>\n<p>完整代码如下：</p>\n<pre><code class=\"kotlin\">@Composable\nfun GreetConstraintLayout(context: Context) {\n    ConstraintLayout(constraintSet = ConstraintSet {\n        val hasFlag = true // 它的值根据你的业务逻辑某些情况是true,某些情况是false\n        val viewA = tag(\"ViewTagA\").apply {\n            left constrainTo parent.left\n            centerVertically()\n        }\n       val viewB =  tag(\"ViewTagB\").apply {\n            left constrainTo viewA.right\n            centerVertically()\n            top constrainTo viewA.bottom\n        }\n        tag(\"ViewC\").apply {\n            // 根据判断条件改变，约束也改变\n            left constrainTo (if(hasFlag) viewA else viewB).right\n            bottom constrainTo viewB.top\n        }\n    }, modifier = Modifier.preferredSize(context.screenWidth().dp,400.dp).drawBackground(Color.LightGray)) {\n\n        Box(\n            modifier = Modifier.tag(\"ViewTagA\").preferredSize(100.dp, 100.dp),\n            backgroundColor = Color.Blue,\n            gravity = ContentGravity.Center\n        ) {\n            Text(text = \"A\")\n        }\n        Box(\n            modifier = Modifier.tag(\"ViewTagB\").preferredSize(100.dp, 100.dp),\n            backgroundColor = Color.Green,\n            gravity = ContentGravity.Center\n        ) {\n            Text(text = \"B\")\n        }\n        Box(\n            modifier = Modifier.tag(\"ViewC\").preferredSize(100.dp, 100.dp),\n            backgroundColor = Color.Red,\n            gravity = ContentGravity.Center\n        ) {\n            Text(text = \"C\")\n        }\n    }\n}</code></pre>\n<p><code>hasFlag=true</code> 效果如下：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023829029\" alt=\"\" title=\"\" /></p>\n<p><code>hasFlag=false</code> 效果如下：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023829030\" alt=\"\" title=\"\" /></p>\n<p>其他的一些约束布局属性同现在我们使用的<code>ConstraintLayout</code>相同，有兴趣的可以去试试。</p>\n<h3>4. 动画</h3>\n<p>Jetpack Compose对动画的支持也是开发者非常关心的一个问题，这一小节就看看Compose中，动画的使用，还是来看一个小例子，先看效果图：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023829031\" alt=\"\" title=\"\" /></p>\n<p>如上，一个简单的属性动画，图片有<code>选中/未选中</code>两种状态，由<code>未选中-&gt;选中</code>时，有一个<code>正方形-&gt;圆形</code>的动画，并且伴随着<code>alpha</code>动画。</p>\n<p>代码如下：</p>\n<pre><code class=\"kotlin\">@Composable\nfun GreetAnimate(){\n    //\n    val (selected,onValueChange) = state { false }\n    // radius 变化\n    val radius = animate(if(selected) 100.dp else 8.dp)\n    // alpha 动画\n    val selectAlpha = animate(if(selected) 0.4f else 1.0f)\n\n   Surface(shape = RoundedCornerShape(\n       topLeft = radius,\n       topRight = radius,\n       bottomRight = radius,\n       bottomLeft = radius\n   )) {\n       Toggleable(\n           value = selected,\n           onValueChange = onValueChange,\n           modifier = Modifier.ripple()\n       ) {\n\n           Image(\n               asset = imageResource(R.drawable.androidstudio),\n               modifier = Modifier.preferredSize(200.dp,200.dp),\n               contentScale = ContentScale.Crop,\n               alpha = selectAlpha\n           )\n       }\n   }\n}</code></pre>\n<p>动画使用<code>animate</code> Compose函数来完成，只需要为它提供不同的target的值，它就能帮你完成之间的变化，一旦动画创建，它就和普通的Compose函数是一样的。</p>\n<p><strong>注意一点</strong> ：<code>animate</code>创建的动画是不能被取消的，要创建可以被取消的动画可以使用<code>animatedValue</code>。还有其他两个相似动画函数：<code>animatedFloat</code>,<code>animatedColor</code></p>\n<p>啥？你说看起来有点熟悉？那可不是嘛，<code>ObjectAnimator</code>,<code>ValueAnimator</code>, 你细品，更多关于动画的使用方式这里不展开了，有兴趣的同学下来自己动手试试。</p>\n<h3>4. 与原生View 的兼容</h3>\n<p>一门新的语言，一个新的框架，考虑兼容是很有必要的，就像Kotlin那样，我们使用Kotlin不必一下子重写整个项目，你可以添加一个新的类，一个新的模块中使用Kotlin，因为它们与Java 完全相互调用。</p>\n<p>Jetpack Compose 借鉴了经验，我们要使用Jetpack Compose,也可以慢慢来，以前的代码不用动，在你的新模块中一点一点的添加，这就涉及到与原来的View的兼容，在Compose中，可以使用AndroidView来兼容以前的Views。</p>\n<p>比如我的Jetpack Compose 中要使用到Webview，而它本身也没有提供，该如何是好？别担心，用原来的就行。</p>\n<p>首先，创建一个xml文件<code>webview.xml</code>，里面添加Webview 布局：</p>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;WebView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"&gt;\n&lt;/WebView&gt;</code></pre>\n<p>然后写一个compose 函数，使用AndroidView 来加载：</p>\n<pre><code class=\"kotlin\">@Composable\nfun androidView(){\n    AndroidView(R.layout.webview){ view -&gt;\n        val webView = view as WebView\n        webView.settings.javaScriptEnabled =true\n        webView.settings.allowFileAccess = true\n        webView.settings.allowContentAccess = true\n        webView.loadUrl(\"https://juejin.im/\")\n    }\n}</code></pre>\n<p>加载了一个原生的Webview，然后在webview中加载了掘金的网址，效果如下：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023829032\" alt=\"\" title=\"\" /></p>\n<p>看一下AndroidView函数签名：</p>\n<pre><code>@Composable\n// TODO(popam): support modifiers here\nfun AndroidView(@LayoutRes resId: Int, postInflationCallback: (View) -&gt; Unit = { _ -&gt; }) {\n    AndroidViewHolder(\n        postInflationCallback = postInflationCallback,\n        resId = resId\n    )\n}</code></pre>\n<p>接受一个布局文件资源id,和一个回调<code>postInflationCallback</code>,当View被inflate出来后，会调用这个回调，然后你就可以在回调中使用它了。</p>\n<p>但是，<strong><em>注意:</em></strong> <code>回调通常是在主线程被调用。</code></p>\n<h3>5.总结</h3>\n<p>总的来说，这次Developer PreView2 更新比较多，并且很多API发生了变化，增加了一些关键的组件如<code>AdapterList</code>,<code>ConstraintLayout</code>，<code>动画组件</code>等,使用方式也与Preview1有很多不同。可以来看一下Google关于Jetpack Compose 上的时间表：</p>\n<ul>\n <li>2019.5 宣布Jetpack Compose</li>\n <li>2019.11 第一个 Developer Preview</li>\n <li>2020.6 第二个 Developer Preview</li>\n <li>2020 夏天将发布Alpha版本</li>\n <li>2021 将发布release 1.0版本</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023829033\" alt=\"\" title=\"\" /></p>\n<p>但是，要说的是，现在很多API还不是最终版本，可以看到，每一个打版本的变化还是蛮大的，现在仍然不能用在商用项目上。但是就jetpack Compose 本身来说，个人还是比较期待的，从上面的时间表就可以看到，大概明年就能出第一个release版本，敬请期待吧！</p>\n<p>对了，最新版本的Jetpack Compose 需要Android Studio 4.2以上版本才能使用，想要体验的同学先安卓Android Studio 4.2 Canary ​版本。​去官网下载！</p>\n<p>小版本日志列表请看：<a href=\"https://developer.android.com/jetpack/androidx/releases/ui?hl=ru\" rel=\"nofollow noreferrer\">https://developer.android.com...</a></p>\n<p>youtobe视频介绍请看：<a href=\"https://www.youtube.com/watch?v=U5BwfqBpiWU\" rel=\"nofollow noreferrer\">https://www.youtube.com/watch...</a></p>","descriptionType":"html","publishedDate":"Mon, 31 Aug 2020 03:06:13 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023829022","linkMd5":"320be39dd093985807704133bf69c403","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn42@2020_5/2020/09/01/03-37-53-725_787fee427414f64f.webp","destWidth":447,"destHeight":800,"sourceBytes":42564,"destBytes":11140,"author":"依然饭特稀西","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023829022":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn42@2020_5/2020/09/01/03-37-53-725_787fee427414f64f.webp","https://segmentfault.com/img/remote/1460000023829021":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn56@2020_3/2020/09/01/03-38-04-649_9d931e81099ea1d8.webp","https://segmentfault.com/img/remote/1460000023829023":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn51@2020_2/2020/09/01/03-38-04-628_ba283ef1d7058c22.webp","https://segmentfault.com/img/remote/1460000023829024":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn47@2020_3/2020/09/01/03-38-05-567_82bf961b3771e401.webp","https://segmentfault.com/img/remote/1460000023829026":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn39@2020_4/2020/09/01/03-38-06-544_02ac04abae4be91f.webp","https://segmentfault.com/img/remote/1460000023829025":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn43@2020_2/2020/09/01/03-38-10-106_cb9aeb358d5a2ab3.webp","https://segmentfault.com/img/remote/1460000023829027":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn35@2020_4/2020/09/01/03-38-17-565_db27bcfb0a32ede7.webp","https://segmentfault.com/img/remote/1460000023829028":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn31@2020_3/2020/09/01/03-38-04-361_b3febd452e1a81fb.webp","https://segmentfault.com/img/remote/1460000023829029":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn28@2020_1/2020/09/01/03-38-04-334_84b41de998f544de.webp","https://segmentfault.com/img/remote/1460000023829030":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn23@2020_3/2020/09/01/03-38-05-249_72717722b790ff6e.webp","https://segmentfault.com/img/remote/1460000023829031":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn19@2020_1/2020/09/01/03-38-09-750_f0051cf8e9511243.webp","https://segmentfault.com/img/remote/1460000023829032":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn16@2020_2/2020/09/01/03-38-04-291_7f6b1c0bd813e1e3.webp","https://segmentfault.com/img/remote/1460000023829033":null},"publishedOrCreatedDate":1598931423820},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"RocketMQ 分布式事务消息","link":"https://segmentfault.com/a/1190000023801496","description":"<p><img src=\"https://segmentfault.com/img/bVbL11b\" alt=\"\" title=\"\" /></p>\n<h3>一、什么是事务</h3>\n<p>事务是将一次执行过程中所涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下才能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。一句话来说，就是保证多个操作要么都做，要么都不做。同时一旦事务提交，则其所做的修改会永久保存到数据库。</p>\n<h3>二、事务的四个特性（ACID）</h3>\n<ul>\n <li>A:原子性(Atomicity)<br>一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</br></li>\n <li>C:一致性(Consistency)<br>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。</br></li>\n <li>I:隔离性(Isolation)<br>指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</br></li>\n <li>D:持久性(Durability)<br>指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</br></li>\n</ul>\n<h3>三、InnoDB 事务实现</h3>\n<p>基于衡量事务的四个特性，InnoDB 实现事务实际上就是 4 个特性的实现。</p>\n<ul>\n <li><p>原子性</p>\n  <ul>\n   <li>在 MySQL 中有很多类型的日志，二进制日志、查询日志、错误日志、慢查询日志等等。除了这些日志，还提供了两种事务日志，redo log 用来保证持久性， undo log 是原子性和隔离性实现的基础。</li>\n   <li>数据库每执行一条更新数据的 sql 就会生成一条 undo log，比如 insert 一条数据，就会生出一条 delete 的 undo log。如果事务执行失败或者调用 rollback 就可以根据 undo log 做数据回滚。</li>\n  </ul></li>\n <li><p>隔离性</p>\n  <ul>\n   <li>隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。严格的隔离性，对应了事务隔离级别中的Serializable (可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。</li>\n   <li>InnoDB 采用可重复读隔离级别，使用 MVCC 和行锁、间隙锁实现隔离性。</li>\n  </ul></li>\n <li><p>持久性</p>\n  <ul>\n   <li>InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。</li>\n   <li>Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</li>\n   <li>于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</li>\n  </ul>\n  <blockquote>\n   既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：\n   <br>（1）刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。<br>（2）刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。</br></br>\n  </blockquote></li>\n <li><p>一致性</p>\n  <ul>\n   <li>一致性是指事务执行结束后，<strong>数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</strong></li>\n   <li>一致性不仅由数据库本身来保证，同时业务系统也保证数据的一致性。</li>\n  </ul></li>\n</ul>\n<h3>四、分布式事务的由来</h3>\n<p>现代软件架构随着业务领域划分为多个微服务，共同组成了复杂的软件系统。而从数据库层面来看，随着数据量的爆发，不得不采用分库分表的方式，降低数据库的压力。这样，就造成多个服务依赖不同的数据库，那么在同时操作的时候，如何保证事务？这就是分布式事务。</p>\n<p>简而言之，分布式事务就是一个大的事务由不同的子事务组成，这些小的事务操作分布在不同的服务器节点上面，属于不同的微服务，分布式事务需要保证同一事务下的子事务要么全部成功，要么全部失败，即保证数据的最终一致性。</p>\n<h3>五、分布式事务解决方案</h3>\n<p>在这篇不想用太大的篇幅说一些概念上的东西，但是要说 RocketMQ 的分布式事务实现，所以在这里顺便提一下当前分布式事务的集中解决方案：</p>\n<ul>\n <li><h4>两阶段提交（2PC）</h4><p><strong>两阶段提交（2PC）</strong> 是 Oracle Tuxedo 系统提出的 XA 分布式事务协议的其中一种实现方式，参考 <a href=\"https://aysaml.com/articles/2020/06/16/1592303735898.html\" rel=\"nofollow noreferrer\">《分布式事务之两阶段提交（2PC）》</a> 。</p></li>\n <li><h4>Try-Confirm-Cancle （TCC）</h4><p><strong>TCC</strong> 是基于尝试、确认、取消来实现分布式事务的，想了解更多，参考 <a href=\"https://aysaml.com/articles/2020/06/16/1592304957424.html\" rel=\"nofollow noreferrer\">《分布式事务之补偿事务（ TCC ）》</a> 。</p></li>\n <li><h4>本地消息表</h4><p><strong>本地消息表</strong> 方案最初是ebay提出的，核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。</p></li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/bVbL11c\" alt=\"image.png\" title=\"image.png\" /></p>\n<p>除了上述外，还有一些解决方案，比如阿里 SEATA ，SAGA方案和最大努力通知...感兴趣同学们可以自行了解,当然还有我们这篇要说的 MQ 事务。</p>\n<h3>六、MQ 事务</h3>\n<p>RocketMQ 是阿里开源的一款高性能、高吞吐量的分布式消息中间件，基于消息异步方式提供了对分布式事务的支持，实现事务最终一致性。</p>\n<p>下面是 RocketMQ 事务消息的基本流程交互图：</p>\n<p><img src=\"https://segmentfault.com/img/bVbL11d\" alt=\"image.png\" title=\"image.png\" /></p>\n<p>如图其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>\n<p>1.事务消息发送及提交：</p>\n<p>(1) 发送 half 消息。<br>(2) 服务端响应消息写入结果。<br>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。<br>(4) 根据本地事务状态执行 Commit 或者 Rollback（ Commit 操作生成消息索引，消息对消费者可见）</br></br></br></p>\n<p>流程图如下：</p>\n<p><img src=\"https://segmentfault.com/img/bVbL11f\" alt=\"image.png\" title=\"image.png\" /></p>\n<p>2.补偿流程：</p>\n<p>(1) 对没有 Commit/Rollback 的事务消息（ pending 状态的消息），从服务端发起一次“回查”<br>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态<br>(3) 根据本地事务状态，重新Commit或者Rollback</br></br></p>\n<p>其中，补偿阶段使用定时器回查方式用于解决消息 Commit 或者 Rollback 发生超时或者失败的情况。</p>\n<h3>七、RocektMQ 事务消息的使用</h3>\n<p>如上，小伙伴们应该对 RocketMQ 的事务消息有了一定的了解，下面看下如何在开发场景下如何使用。</p>\n<p>发送事务消息时和普通的消息区别是，自己要新建一个 <code>TransactionMQProducer</code> 和对应的一个 <code>TransactionListener</code>的实现。</p>\n<ul>\n <li>TransactionMQProducer<br>具体的配置有 group、 nameServer 地址、执行本地事务的线程池和事务监听器的实现。</br></li>\n</ul>\n<pre><code class=\"java\">this.producer = new TransactionMQProducer(config.getGroup());\n    this.producer.setNamesrvAddr(config.getNameServer());\n    this.producer.setExecutorService(config.getExecutorService());\n    this.producer.setTransactionListener(config.getTransactionListener());</code></pre>\n<ul>\n <li><p>TransactionListener<br>实现 <code>TransactionListener</code> 接口的两个方法：</br></p>\n  <ul>\n   <li><code>executeLocalTransaction(Message message, Object o)</code><br>用于执行本地事务的方法。</br></li>\n   <li><code>checkLocalTransaction(MessageExt messageExt)</code><br>RocketMQ 回查本地事务状态调用的方法。</br></li>\n  </ul></li>\n</ul>\n<p>代码详见 👀 : <a href=\"https://github.com/wangning1018/rocketmq-transaction-message-demo\" rel=\"nofollow noreferrer\">https://github.com/wangning1018/rocketmq-transaction-message-demo</a></p>\n<blockquote>\n 欢迎访问\n <a href=\"https://aysaml.com\" rel=\"nofollow noreferrer\">个人博客</a> 获取更多知识分享。\n</blockquote>","descriptionType":"html","publishedDate":"Fri, 28 Aug 2020 03:16:49 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbL11b","linkMd5":"b134f90b7371ef57332d75c0b700b0c2","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn50@2020_2/2020/09/01/03-37-53-800_320f368bba9b5746.webp","destWidth":800,"destHeight":450,"sourceBytes":72666,"destBytes":56028,"author":"AYSAML","articleImgCdnMap":{"https://segmentfault.com/img/bVbL11b":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn50@2020_2/2020/09/01/03-37-53-800_320f368bba9b5746.webp","https://segmentfault.com/img/bVbL11c":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn100@2020_6/2020/09/01/03-37-58-491_aed931b01bc971ba.webp","https://segmentfault.com/img/bVbL11d":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn91@2020_1/2020/09/01/03-37-58-244_8d1b710f42a44156.webp","https://segmentfault.com/img/bVbL11f":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn95@2020_6/2020/09/01/03-37-58-429_d01a93f13494880c.webp"},"publishedOrCreatedDate":1598931423822},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"RTC 技术站上行业新风口，Geek Online 2020 编程挑战赛开拓全新应用场景","link":"https://segmentfault.com/a/1190000023787562","description":"<p><img src=\"https://segmentfault.com/img/bVbLZP0\" alt=\"RTC 技术站上行业新风口，Geek Online 2020 编程挑战赛开拓全新应用场景\" title=\"RTC 技术站上行业新风口，Geek Online 2020 编程挑战赛开拓全新应用场景\" /></p>\n<p>2020 年初，一场突如其来的新冠疫情让全国乃至全球的各行各业陷入了几乎停摆的状态。在如此境况下，线上实时互动的需求开始爆发式增长，RTC 技术也站上了行业的新风口。</p>\n<p>这其中最具代表性的应用包括在线教育、视频会议、游戏连麦、平台直播等等。RTC 技术最初在直播互动和实时音视频通信中应用最为广泛，在用户猛增和网络流量成倍数增长的情况下，RTC 技术结合 5G 网络又有了更大的突破。</p>\n<p>RTC 技术已经开始全面浸入人们的日常生活。在此背景下，为适应市场发展趋势，鼓励开发者开发出更多创新应用，国家层面和企业自身都出台了相关优惠政策，提供了全方位的支持。</p>\n<p>融云作为全球领先的互联网通信云厂商，一直致力于 RTC 技术的创新和发展，并在近日正式举办 Geek Online 2020 编程挑战赛，希望借此机会与全球开发者一道，共同寻找 RCT 技术的更多落地场景，开辟更多使用途径。</p>\n<h2>RTC 技术全面浸入日常生活</h2>\n<p><img src=\"https://segmentfault.com/img/bVbLYfM\" alt=\"image.png\" title=\"image.png\" /></p>\n<p>数据统计，2020 年上半年，全国有 100 多万人参与到了直播带货大潮中，如薇娅、李佳琦等头部主播一场直播的成交额动辄上亿元。在主播的宣传和情绪带动下，消费者直观的感受到销售氛围，立即点击链接进入购物界面。</p>\n<p>在疫情的影响下，房屋和汽车这种主打线下销售的产业受到了不小的冲击，VR 看房、看车业务也应运而生。类似需要用到 RTC 技术的场景还有很多，包括远程医疗、在线教育、视频会议等等。</p>\n<p>随着互联网通信技术的发展，越来越多的企业开始把 RTC 技术融入到自己的产品当中，更加重视实时互动性。</p>\n<ul>\n <li>衣，有电商、直播带货等消费形式；</li>\n <li>食，有无接触配送，在线下单送货上门；</li>\n <li>住，有 VR 看房，远程实时交易；</li>\n <li>行，有无人驾驶，路况视频实时回传。</li>\n</ul>\n<p>这些无不反映了即时反馈，实时互动在现阶段的消费场景中占据的重要地位。</p>\n<h2>融云 RTC 技术保证通信传输低延时、高清晰、无卡顿</h2>\n<p>融云率先提出了为开发者提供即时通讯与实时音视频能力融合的 PaaS 通信云服务，通过&nbsp; IM+RTC 整体方案满足开发者对互联网通信能力的要求，以高可靠的 IM 信令保障为前提，为实时音视频通话、直播带货等应用场景提供通信保障。</p>\n<p>在确保信息安全，不在传输中出现错乱的前提下，融云的 RTC 技术保证了通信传输的低延时、高清晰和无卡顿。 目前，融云实时音视频服务已经覆盖 iOS、Android、Web、Windows、macOS、Linux、Electron 等多类型平台。</p>\n<h2>Geek Online 2020 编程挑战赛开启</h2>\n<p>为鼓励开发者挖掘更多关于实时音视频和即时通讯技术的创意，大胆创新，融云发起了&nbsp;Geek Online 2020 编程挑战赛，以“后疫情时代，通信云技术的创新及实践”为主题。选手可使用融云 IM+RTC SDK 进行创新应用开发，竞赛作品需集成融云官网最新版本的即时通讯 SDK 或实时音视频（直播）SDK。</p>\n<p>大赛已于 8 月 24 日开始报名，赛程近 2 个月，10 月 17 日进行线上决赛，并计划在 10 月 24 日现场颁奖。</p>\n<p><img src=\"https://segmentfault.com/img/bVbLYfS\" alt=\"image.png\" title=\"image.png\" /></p>\n<h4>参赛规则：</h4>\n<p><strong>参赛对象：</strong></p>\n<p>职业开发者，创业者等群体。</p>\n<p><strong>参与报名：</strong></p>\n<p>开发者以个人身份报名，团队的每个成员都要单独报名，报名后官方将对报名人员进行筛选。</p>\n<p><strong>团队规模：</strong></p>\n<p>本次比赛要求组队参加，每个团队 1-5 人，团队最高人限 5 人，1 人只能参与 1 个团队。</p>\n<h4>赛程安排</h4>\n<table>\n <thead>\n  <tr>\n   <th>时间</th>\n   <th>赛程</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>8 月 24 日-10 月 11 日</td>\n   <td>官网报名</td>\n  </tr>\n  <tr>\n   <td>8 月 24 日-10 月 11 日</td>\n   <td>开发阶段</td>\n  </tr>\n  <tr>\n   <td>9 月 21 日-10 月14 日</td>\n   <td>作品提交</td>\n  </tr>\n  <tr>\n   <td>10 月 15 日-10 月 16 日</td>\n   <td>作品初评</td>\n  </tr>\n  <tr>\n   <td>10 月 17 日</td>\n   <td>网上决赛</td>\n  </tr>\n  <tr>\n   <td>10 月 24 日</td>\n   <td>现场颁奖</td>\n  </tr>\n </tbody>\n</table>\n<h4>奖项设置</h4>\n<p><strong>冠军：</strong>（1 组团队）</p>\n<p>奖金 5 万元、奖杯证书</p>\n<p><strong>亚军：</strong>（1 组团队）</p>\n<p>奖金 2 万元、奖杯证书</p>\n<p><strong>季军</strong>：（1 组团队）</p>\n<p>奖金 1 万元、奖杯证书</p>\n<p><strong>单项奖：</strong>（若干）</p>\n<p>奖金 1 千元、奖杯证书</p>\n<p>*<strong>优秀作品将优先推荐投资机构</strong></p>\n<p><strong>*进入决赛队伍中的优秀选手可进入融云绿色招聘通道</strong></p>\n<p>扫描下方二维码加入“Geek Online 2020 编程挑战赛”交流群</p>\n<p><img src=\"https://segmentfault.com/img/bVbLZP7\" alt=\"image.png\" title=\"image.png\" /></p>\n<p><img src=\"https://segmentfault.com/img/bVbJgYT\" alt=\"segmentfault 公众号\" title=\"segmentfault 公众号\" /></p>","descriptionType":"html","publishedDate":"Thu, 27 Aug 2020 05:00:31 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbLZP0","linkMd5":"dca2daa8a54c47eee063881bb9368430","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn26@2020_3/2020/09/01/03-37-54-717_26cf72c0c5b11837.webp","destWidth":800,"destHeight":474,"sourceBytes":313452,"destBytes":43586,"author":"芒果果","articleImgCdnMap":{"https://segmentfault.com/img/bVbLZP0":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn26@2020_3/2020/09/01/03-37-54-717_26cf72c0c5b11837.webp","https://segmentfault.com/img/bVbLYfM":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn68@2020_6/2020/09/01/03-37-58-464_61ddaa75fdc0b5b4.webp","https://segmentfault.com/img/bVbLYfS":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn63@2020_3/2020/09/01/03-37-58-322_ae3aff3564aecd3b.webp","https://segmentfault.com/img/bVbLZP7":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn20@2020_3/2020/09/01/03-37-59-849_c9d3de54bab8926e.webp","https://segmentfault.com/img/bVbJgYT":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn24@2020_5/2020/09/01/03-37-59-160_7f8323e1c3c7e5a5.webp"},"publishedOrCreatedDate":1598931423823},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"深入Node.js的模块加载机制，手写require函数","link":"https://segmentfault.com/a/1190000023828613","description":"<p>模块是Node.js里面一个很基本也很重要的概念，各种原生类库是通过模块提供的，第三方库也是通过模块进行管理和引用的。本文会从基本的模块原理出发，到最后我们会利用这个原理，自己实现一个简单的模块加载机制，即自己实现一个<code>require</code>。</p>\n<p><strong>本文完整代码已上传GitHub：<a href=\"https://github.com/dennis-jiang/Front-End-Knowledges/blob/master/Examples/Node.js/Module/MyModule/index.js\" rel=\"nofollow noreferrer\">https://github.com/dennis-jiang/Front-End-Knowledges/blob/master/Examples/Node.js/Module/MyModule/index.js</a></strong></p>\n<h2>简单例子</h2>\n<p>老规矩，讲原理前我们先来一个简单的例子，从这个例子入手一步一步深入原理。Node.js里面如果要导出某个内容，需要使用<code>module.exports</code>，使用<code>module.exports</code>几乎可以导出任意类型的JS对象，包括字符串，函数，对象，数组等等。我们先来建一个<code>a.js</code>导出一个最简单的<code>hello world</code>:</p>\n<pre><code class=\"javascript\">// a.js \nmodule.exports = \"hello world\";</code></pre>\n<p>然后再来一个<code>b.js</code>导出一个函数：</p>\n<pre><code class=\"javascript\">// b.js\nfunction add(a, b) {\n  return a + b;\n}\n\nmodule.exports = add;</code></pre>\n<p>然后在<code>index.js</code>里面使用他们，即<code>require</code>他们，<code>require</code>函数返回的结果就是对应文件<code>module.exports</code>的值：</p>\n<pre><code class=\"javascript\">// index.js\nconst a = require('./a.js');\nconst add = require('./b.js');\n\nconsole.log(a);      // \"hello world\"\nconsole.log(add(1, 2));    // b导出的是一个加法函数，可以直接使用，这行结果是3</code></pre>\n<h3>require会先运行目标文件</h3>\n<p>当我们<code>require</code>某个模块时，并不是只拿他的<code>module.exports</code>，而是会从头开始运行这个文件，<code>module.exports = XXX</code>其实也只是其中一行代码，我们后面会讲到，这行代码的效果其实就是修改模块里面的<code>exports</code>属性。比如我们再来一个<code>c.js</code>：</p>\n<pre><code class=\"javascript\">// c.js\nlet c = 1;\n\nc = c + 1;\n\nmodule.exports = c;\n\nc = 6;</code></pre>\n<p>在<code>c.js</code>里面我们导出了一个<code>c</code>，这个<code>c</code>经过了几步计算，当运行到<code>module.exports = c;</code>这行时<code>c</code>的值为<code>2</code>，所以我们<code>require</code>的<code>c.js</code>的值就是<code>2</code>，后面将<code>c</code>的值改为了<code>6</code>并不影响前面的这行代码:</p>\n<pre><code class=\"javascript\">const c = require('./c.js');\n\nconsole.log(c);  // c的值是2</code></pre>\n<p>前面<code>c.js</code>的变量<code>c</code>是一个基本数据类型，所以后面的<code>c = 6;</code>不影响前面的<code>module.exports</code>，那他如果是一个引用类型呢？我们直接来试试吧：</p>\n<pre><code class=\"javascript\">// d.js\nlet d = {\n  num: 1\n};\n\nd.num++;\n\nmodule.exports = d;\n\nd.num = 6;</code></pre>\n<p>然后在<code>index.js</code>里面<code>require</code>他：</p>\n<pre><code class=\"javascript\">const d = require('./d.js');\n\nconsole.log(d);     // { num: 6 }</code></pre>\n<p>我们发现在<code>module.exports</code>后面给<code>d.num</code>赋值仍然生效了，因为<code>d</code>是一个对象，是一个引用类型，我们可以通过这个引用来修改他的值。其实对于引用类型来说，不仅仅在<code>module.exports</code>后面可以修改他的值，在模块外面也可以修改，比如<code>index.js</code>里面就可以直接改：</p>\n<pre><code class=\"javascript\">const d = require('./d.js');\n\nd.num = 7;\nconsole.log(d);     // { num: 7 }</code></pre>\n<h2><code>require</code>和<code>module.exports</code>不是黑魔法</h2>\n<p>我们通过前面的例子可以看出来，<code>require</code>和<code>module.exports</code>干的事情并不复杂，我们先假设有一个全局对象<code>{}</code>，初始情况下是空的，当你<code>require</code>某个文件时，就将这个文件拿出来执行，如果这个文件里面存在<code>module.exports</code>，当运行到这行代码时将<code>module.exports</code>的值加入这个对象，键为对应的文件名，最终这个对象就长这样：</p>\n<pre><code class=\"javascript\">{\n  \"a.js\": \"hello world\",\n  \"b.js\": function add(){},\n  \"c.js\": 2,\n  \"d.js\": { num: 2 }\n}</code></pre>\n<p>当你再次<code>require</code>某个文件时，如果这个对象里面有对应的值，就直接返回给你，如果没有就重复前面的步骤，执行目标文件，然后将它的<code>module.exports</code>加入这个全局对象，并返回给调用者。这个全局对象其实就是我们经常听说的缓存。<strong>所以<code>require</code>和<code>module.exports</code>并没有什么黑魔法，就只是运行并获取目标文件的值，然后加入缓存，用的时候拿出来用就行。</strong>再看看这个对象，因为<code>d.js</code>是一个引用类型，所以你在任何地方获取了这个引用都可以更改他的值，如果不希望自己模块的值被更改，需要自己写模块时进行处理，比如使用<code>Object.freeze()</code>，<code>Object.defineProperty()</code>之类的方法。</p>\n<h2>模块类型和加载顺序</h2>\n<p>这一节的内容都是一些概念，比较枯燥，但是也是我们需要了解的。</p>\n<h3>模块类型</h3>\n<p>Node.js的模块有好几种类型，前面我们使用的其实都是<code>文件模块</code>，总结下来，主要有这两种类型：</p>\n<blockquote>\n <ol>\n  <li><strong>内置模块</strong>：就是Node.js原生提供的功能，比如<code>fs</code>，<code>http</code>等等，这些模块在Node.js进程起来时就加载了。</li>\n  <li><strong>文件模块</strong>：我们前面写的几个模块，还有第三方模块，即<code>node_modules</code>下面的模块都是文件模块。</li>\n </ol>\n</blockquote>\n<h3>加载顺序</h3>\n<p>加载顺序是指当我们<code>require(X)</code>时，应该按照什么顺序去哪里找<code>X</code>，在官方文档上有<a href=\"https://nodejs.org/dist/latest-v12.x/docs/api/modules.html#modules_all_together\" rel=\"nofollow noreferrer\">详细伪代码</a>，总结下来大概是这么个顺序：</p>\n<blockquote>\n <ol>\n  <li>优先加载内置模块，即使有同名文件，也会优先使用内置模块。</li>\n  <li>不是内置模块，先去缓存找。</li>\n  <li>缓存没有就去找对应路径的文件。</li>\n  <li>不存在对应的文件，就将这个路径作为文件夹加载。</li>\n  <li>对应的文件和文件夹都找不到就去<code>node_modules</code>下面找。</li>\n  <li>还找不到就报错了。</li>\n </ol>\n</blockquote>\n<h3>加载文件夹</h3>\n<p>前面提到找不到文件就找文件夹，但是不可能将整个文件夹都加载进来，加载文件夹的时候也是有一个加载顺序的：</p>\n<blockquote>\n <ol>\n  <li>先看看这个文件夹下面有没有<code>package.json</code>，如果有就找里面的<code>main</code>字段，<code>main</code>字段有值就加载对应的文件。所以如果大家在看一些第三方库源码时找不到入口就看看他<code>package.json</code>里面的<code>main</code>字段吧，比如<code>jquery</code>的<code>main</code>字段就是这样：<code>\"main\": \"dist/jquery.js\"</code>。</li>\n  <li>如果没有<code>package.json</code>或者<code>package.json</code>里面没有<code>main</code>就找<code>index</code>文件。</li>\n  <li>如果这两步都找不到就报错了。</li>\n </ol>\n</blockquote>\n<h3>支持的文件类型</h3>\n<p><code>require</code>主要支持三种文件类型：</p>\n<blockquote>\n <ol>\n  <li><strong>.js</strong>：<code>.js</code>文件是我们最常用的文件类型，加载的时候会先运行整个JS文件，然后将前面说的<code>module.exports</code>作为<code>require</code>的返回值。</li>\n  <li><strong>.json</strong>：<code>.json</code>文件是一个普通的文本文件，直接用<code>JSON.parse</code>将其转化为对象返回就行。</li>\n  <li><strong>.node</strong>：<code>.node</code>文件是C++编译后的二进制文件，纯前端一般很少接触这个类型。</li>\n </ol>\n</blockquote>\n<h2>手写<code>require</code></h2>\n<p>前面其实我们已经将原理讲的七七八八了，下面来到我们的重头戏，自己实现一个<code>require</code>。实现<code>require</code>其实就是实现整个Node.js的模块加载机制，我们再来理一下需要解决的问题：</p>\n<blockquote>\n <ol>\n  <li>通过传入的路径名找到对应的文件。</li>\n  <li>执行找到的文件，同时要注入<code>module</code>和<code>require</code>这些方法和属性，以便模块文件使用。</li>\n  <li>返回模块的<code>module.exports</code></li>\n </ol>\n</blockquote>\n<p>本文的手写代码全部参照Node.js官方源码，函数名和变量名尽量保持一致，其实就是精简版的源码，大家可以对照着看，写到具体方法时我也会贴上对应的源码地址。总体的代码都在这个文件里面：<a href=\"https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js\" rel=\"nofollow noreferrer\">https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js</a></p>\n<h3>Module类</h3>\n<p>Node.js模块加载的功能全部在<code>Module</code>类里面，整个代码使用面向对象的思想，<a href=\"https://segmentfault.com/a/1190000023201844\">如果你对JS的面向对象还不是很熟悉可以先看看这篇文章</a>。<a href=\"https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L168\" rel=\"nofollow noreferrer\"><code>Module</code>类的构造函数</a>也不复杂，主要是一些值的初始化，为了跟官方<code>Module</code>名字区分开，我们自己的类命名为<code>MyModule</code>：</p>\n<pre><code class=\"javascript\">function MyModule(id = '') {\n  this.id = id;       // 这个id其实就是我们require的路径\n  this.path = path.dirname(id);     // path是Node.js内置模块，用它来获取传入参数对应的文件夹路径\n  this.exports = {};        // 导出的东西放这里，初始化为空对象\n  this.filename = null;     // 模块对应的文件名\n  this.loaded = false;      // loaded用来标识当前模块是否已经加载\n}</code></pre>\n<h3>require方法</h3>\n<p>我们一直用的<code>require</code>其实是<code>Module</code>类的一个实例方法，内容很简单，先做一些参数检查，然后调用<code>Module._load</code>方法，源码看这里：<a href=\"https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L970\" rel=\"nofollow noreferrer\">https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L970</a>。精简版的代码如下：</p>\n<pre><code class=\"javascript\">MyModule.prototype.require = function (id) {\n  return Module._load(id);\n}</code></pre>\n<h3>MyModule._load</h3>\n<p><code>MyModule._load</code>是一个静态方法，这才是<code>require</code>方法的真正主体，他干的事情其实是：</p>\n<blockquote>\n <ol>\n  <li>先检查请求的模块在缓存中是否已经存在了，如果存在了直接返回缓存模块的<code>exports</code>。</li>\n  <li>如果不在缓存中，就<code>new</code>一个<code>Module</code>实例，用这个实例加载对应的模块，并返回模块的<code>exports</code>。</li>\n </ol>\n</blockquote>\n<p>我们自己来实现下这两个需求，缓存直接放在<code>Module._cache</code>这个静态变量上，这个变量官方初始化使用的是<code>Object.create(null)</code>，这样可以使创建出来的原型指向<code>null</code>，我们也这样做吧：</p>\n<pre><code class=\"javascript\">MyModule._cache = Object.create(null);\n\nMyModule._load = function (request) {    // request是我们传入的路劲参数\n  const filename = MyModule._resolveFilename(request);\n\n  // 先检查缓存，如果缓存存在且已经加载，直接返回缓存\n  const cachedModule = MyModule._cache[filename];\n  if (cachedModule !== undefined) {\n    return cachedModule.exports;\n  }\n\n  // 如果缓存不存在，我们就加载这个模块\n  // 加载前先new一个MyModule实例，然后调用实例方法load来加载\n  // 加载完成直接返回module.exports\n  const module = new MyModule(filename);\n  \n  // load之前就将这个模块缓存下来，这样如果有循环引用就会拿到这个缓存，但是这个缓存里面的exports可能还没有或者不完整\n  MyModule._cache[filename] = module;\n  \n  module.load(filename);\n  \n  return module.exports;\n}</code></pre>\n<p>上述代码对应的源码看这里：<a href=\"https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L735\" rel=\"nofollow noreferrer\">https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L735</a></p>\n<p>可以看到上述源码还调用了两个方法：<code>MyModule._resolveFilename</code>和<code>MyModule.prototype.load</code>，下面我们来实现下这两个方法。</p>\n<h3><code>MyModule._resolveFilename</code></h3>\n<p><code>MyModule._resolveFilename</code>从名字就可以看出来，这个方法是通过用户传入的<code>require</code>参数来解析到真正的文件地址的，源码中这个方法比较复杂，因为按照前面讲的，他要支持多种参数：内置模块，相对路径，绝对路径，文件夹和第三方模块等等，如果是文件夹或者第三方模块还要解析里面的<code>package.json</code>和<code>index.js</code>。我们这里主要讲原理，所以我们就只实现通过相对路径和绝对路径来查找文件，并支持自动添加<code>js</code>和<code>json</code>两种后缀名:</p>\n<pre><code class=\"javascript\">MyModule._resolveFilename = function (request) {\n  const filename = path.resolve(request);   // 获取传入参数对应的绝对路径\n  const extname = path.extname(request);    // 获取文件后缀名\n\n  // 如果没有文件后缀名，尝试添加.js和.json\n  if (!extname) {\n    const exts = Object.keys(MyModule._extensions);\n    for (let i = 0; i &lt; exts.length; i++) {\n      const currentPath = `${filename}${exts[i]}`;\n\n      // 如果拼接后的文件存在，返回拼接的路径\n      if (fs.existsSync(currentPath)) {\n        return currentPath;\n      }\n    }\n  }\n\n  return filename;\n}</code></pre>\n<p>上述源码中我们还用到了一个静态变量<code>MyModule._extensions</code>，这个变量是用来存各种文件对应的处理方法的，我们后面会实现他。</p>\n<p><code>MyModule._resolveFilename</code>对应的源码看这里：<a href=\"https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L822\" rel=\"nofollow noreferrer\">https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L822</a></p>\n<h3><code>MyModule.prototype.load</code></h3>\n<p><code>MyModule.prototype.load</code>是一个实例方法，这个方法就是真正用来加载模块的方法，这其实也是不同类型文件加载的一个入口，不同类型的文件会对应<code>MyModule._extensions</code>里面的一个方法：</p>\n<pre><code class=\"javascript\">MyModule.prototype.load = function (filename) {\n  // 获取文件后缀名\n  const extname = path.extname(filename);\n\n  // 调用后缀名对应的处理函数来处理\n  MyModule._extensions[extname](this, filename);\n\n  this.loaded = true;\n}</code></pre>\n<p>注意这段代码里面的<code>this</code>指向的是<code>module</code>实例，因为他是一个实例方法。对应的源码看这里: <a href=\"https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L942\" rel=\"nofollow noreferrer\">https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L942</a></p>\n<h3>加载js文件: MyModule._extensions['.js']</h3>\n<p>前面我们说过不同文件类型的处理方法都挂载在<code>MyModule._extensions</code>上面的，我们先来实现<code>.js</code>类型文件的加载：</p>\n<pre><code class=\"javascript\">MyModule._extensions['.js'] = function (module, filename) {\n  const content = fs.readFileSync(filename, 'utf8');\n  module._compile(content, filename);\n}</code></pre>\n<p>可以看到<code>js</code>的加载方法很简单，只是把文件内容读出来，然后调了另外一个实例方法<code>_compile</code>来执行他。对应的源码看这里：<a href=\"https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L1098\" rel=\"nofollow noreferrer\">https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L1098</a></p>\n<h3>编译执行js文件：MyModule.prototype._compile</h3>\n<p><code>MyModule.prototype._compile</code>是加载JS文件的核心所在，也是我们最常使用的方法，这个方法需要将目标文件拿出来执行一遍，执行之前需要将它整个代码包裹一层，以便注入<code>exports, require, module, __dirname, __filename</code>，这也是我们能在JS文件里面直接使用这几个变量的原因。要实现这种注入也不难，假如我们<code>require</code>的文件是一个简单的<code>Hello World</code>，长这样：</p>\n<pre><code class=\"javascript\">module.exports = \"hello world\";</code></pre>\n<p>那我们怎么来给他注入<code>module</code>这个变量呢？答案是执行的时候在他外面再加一层函数，使他变成这样：</p>\n<pre><code class=\"javascript\">function (module) { // 注入module变量，其实几个变量同理\n  module.exports = \"hello world\";\n}</code></pre>\n<p>所以我们如果将文件内容作为一个字符串的话，为了让他能够变成上面这样，我们需要再给他拼接上开头和结尾，我们直接将开头和结尾放在一个数组里面:</p>\n<pre><code class=\"javascript\">MyModule.wrapper = [\n  '(function (exports, require, module, __filename, __dirname) { ',\n  '\\n});'\n];</code></pre>\n<p>注意我们拼接的开头和结尾多了一个<code>()</code>包裹，这样我们后面可以拿到这个匿名函数，在后面再加一个<code>()</code>就可以传参数执行了。然后将需要执行的函数拼接到这个方法中间：</p>\n<pre><code class=\"javascript\">MyModule.wrap = function (script) {\n  return MyModule.wrapper[0] + script + MyModule.wrapper[1];\n};</code></pre>\n<p>这样通过<code>MyModule.wrap</code>包装的代码就可以获取到<code>exports, require, module, __filename, __dirname</code>这几个变量了。知道了这些就可以来写<code>MyModule.prototype._compile</code>了:</p>\n<pre><code class=\"javascript\">MyModule.prototype._compile = function (content, filename) {\n  const wrapper = Module.wrap(content);    // 获取包装后函数体\n\n  // vm是nodejs的虚拟机沙盒模块，runInThisContext方法可以接受一个字符串并将它转化为一个函数\n  // 返回值就是转化后的函数，所以compiledWrapper是一个函数\n  const compiledWrapper = vm.runInThisContext(wrapper, {\n    filename,\n    lineOffset: 0,\n    displayErrors: true,\n  });\n\n  // 准备exports, require, module, __filename, __dirname这几个参数\n  // exports可以直接用module.exports，即this.exports\n  // require官方源码中还包装了一层，其实最后调用的还是this.require\n  // module不用说，就是this了\n  // __filename直接用传进来的filename参数了\n  // __dirname需要通过filename获取下\n  const dirname = path.dirname(filename);\n\n  compiledWrapper.call(this.exports, this.exports, this.require, this,\n    filename, dirname);\n}</code></pre>\n<p>上述代码要注意我们注入进去的几个参数和通过<code>call</code>传进去的<code>this</code>:</p>\n<blockquote>\n <ol>\n  <li><strong>this</strong>:<code>compiledWrapper</code>是通过<code>call</code>调用的，第一个参数就是里面的<code>this</code>，这里我们传入的是<code>this.exports</code>，也就是<code>module.exports</code>，也就是说我们<code>js</code>文件里面<code>this</code>是对<code>module.exports</code>的一个引用。</li>\n  <li><strong>exports</strong>: <code>compiledWrapper</code>正式接收的第一个参数是<code>exports</code>，我们传的也是<code>this.exports</code>,所以<code>js</code>文件里面的<code>exports</code>也是对<code>module.exports</code>的一个引用。</li>\n  <li><strong>require</strong>: 这个方法我们传的是<code>this.require</code>，其实就是<code>MyModule.prototype.require</code>，也就是<code>MyModule._load</code>。</li>\n  <li><strong>module</strong>: 我们传入的是<code>this</code>，也就是当前模块的实例。</li>\n  <li><strong>__filename</strong>：文件所在的绝对路径。</li>\n  <li><strong>__dirname</strong>: 文件所在文件夹的绝对路径。</li>\n </ol>\n</blockquote>\n<p>到这里，我们的JS文件其实已经记载完了，对应的源码看这里:<a href=\"https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L1043\" rel=\"nofollow noreferrer\">https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L1043</a></p>\n<h3>加载json文件: MyModule._extensions['.json']</h3>\n<p>加载<code>json</code>文件就简单多了，只需要将文件读出来解析成<code>json</code>就行了：</p>\n<pre><code class=\"javascript\">MyModule._extensions['.json'] = function (module, filename) {\n  const content = fs.readFileSync(filename, 'utf8');\n  module.exports = JSONParse(content);\n}</code></pre>\n<h2><code>exports</code>和<code>module.exports</code>的区别</h2>\n<p>网上经常有人问，<code>node.js</code>里面的<code>exports</code>和<code>module.exports</code>到底有什么区别，其实前面我们的手写代码已经给出答案了，我们这里再就这个问题详细讲解下。<code>exports</code>和<code>module.exports</code>这两个变量都是通过下面这行代码注入的。</p>\n<pre><code class=\"javascript\">compiledWrapper.call(this.exports, this.exports, this.require, this,\n    filename, dirname);</code></pre>\n<p>初始状态下，<code>exports === module.exports === {}</code>，<code>exports</code>是<code>module.exports</code>的一个引用，如果你一直是这样使用的:</p>\n<pre><code class=\"javascript\">exports.a = 1;\nmodule.exports.b = 2;\n\nconsole.log(exports === module.exports);   // true</code></pre>\n<p>上述代码中，<code>exports</code>和<code>module.exports</code>都是指向同一个对象<code>{}</code>，你往这个对象上添加属性并没有改变这个对象本身的引用地址，所以<code>exports === module.exports</code>一直成立。</p>\n<p>但是如果你哪天这样使用了:</p>\n<pre><code class=\"javascript\">exports = {\n  a: 1\n}</code></pre>\n<p>或者这样使用了:</p>\n<pre><code class=\"javascript\">module.exports = {\n    b: 2\n}</code></pre>\n<p>那其实你是给<code>exports</code>或者<code>module.exports</code>重新赋值了，改变了他们的引用地址，那这两个属性的连接就断开了，他们就不再相等了。<strong>需要注意的是，你对<code>module.exports</code>的重新赋值会作为模块的导出内容，但是你对<code>exports</code>的重新赋值并不能改变模块导出内容，只是改变了<code>exports</code>这个变量而已，因为模块始终是<code>module</code>，导出内容是<code>module.exports</code>。</strong></p>\n<h2>循环引用</h2>\n<p>Node.js对于循环引用是进行了处理的，下面是官方例子：</p>\n<p><code>a.js</code>:</p>\n<pre><code class=\"js\">console.log('a 开始');\nexports.done = false;\nconst b = require('./b.js');\nconsole.log('在 a 中，b.done = %j', b.done);\nexports.done = true;\nconsole.log('a 结束');</code></pre>\n<p><code>b.js</code>:</p>\n<pre><code class=\"js\">console.log('b 开始');\nexports.done = false;\nconst a = require('./a.js');\nconsole.log('在 b 中，a.done = %j', a.done);\nexports.done = true;\nconsole.log('b 结束');</code></pre>\n<p><code>main.js</code>:</p>\n<pre><code class=\"js\">console.log('main 开始');\nconst a = require('./a.js');\nconst b = require('./b.js');\nconsole.log('在 main 中，a.done=%j，b.done=%j', a.done, b.done);</code></pre>\n<p>当 <code>main.js</code> 加载 <code>a.js</code> 时， <code>a.js</code> 又加载 <code>b.js</code>。 此时， <code>b.js</code> 会尝试去加载 <code>a.js</code>。 为了防止无限的循环，会返回一个 <code>a.js</code> 的 <code>exports</code> 对象的 <strong>未完成的副本</strong> 给 <code>b.js</code> 模块。 然后 <code>b.js</code> 完成加载，并将 <code>exports</code> 对象提供给 <code>a.js</code> 模块。</p>\n<p>那么这个效果是怎么实现的呢？答案就在我们的<code>MyModule._load</code>源码里面，注意这两行代码的顺序:</p>\n<pre><code class=\"javascript\">MyModule._cache[filename] = module;\n\nmodule.load(filename);</code></pre>\n<p>上述代码中我们是先将缓存设置了，然后再执行的真正的<code>load</code>，顺着这个思路我能来理一下这里的加载流程:</p>\n<blockquote>\n <ol>\n  <li><code>main</code>加载<code>a</code>，<code>a</code>在真正加载前先去缓存中占一个位置</li>\n  <li><code>a</code>在正式加载时加载了<code>b</code></li>\n  <li><code>b</code>又去加载了<code>a</code>，这时候缓存中已经有<code>a</code>了，所以直接返回<code>a.exports</code>，即使这时候的<code>exports</code>是不完整的。</li>\n </ol>\n</blockquote>\n<h2>总结</h2>\n<ol>\n <li><code>require</code>不是黑魔法，整个Node.js的模块加载机制都是<code>JS</code>实现的。</li>\n <li>每个模块里面的<code>exports, require, module, __filename, __dirname</code>五个参数都不是全局变量，而是模块加载的时候注入的。</li>\n <li>为了注入这几个变量，我们需要将用户的代码用一个函数包裹起来，拼一个字符串然后调用沙盒模块<code>vm</code>来实现。</li>\n <li>初始状态下，模块里面的<code>this, exports, module.exports</code>都指向同一个对象，如果你对他们重新赋值，这种连接就断了。</li>\n <li>对<code>module.exports</code>的重新赋值会作为模块的导出内容，但是你对<code>exports</code>的重新赋值并不能改变模块导出内容，只是改变了<code>exports</code>这个变量而已，因为模块始终是<code>module</code>，导出内容是<code>module.exports</code>。</li>\n <li>为了解决循环引用，模块在加载前就会被加入缓存，下次再加载会直接返回缓存，如果这时候模块还没加载完，你可能拿到未完成的<code>exports</code>。</li>\n <li>Node.js实现的这套加载机制叫<strong>CommonJS</strong>。</li>\n</ol>\n<p><strong>本文完整代码已上传GitHub：<a href=\"https://github.com/dennis-jiang/Front-End-Knowledges/blob/master/Examples/Node.js/Module/MyModule/index.js\" rel=\"nofollow noreferrer\">https://github.com/dennis-jiang/Front-End-Knowledges/blob/master/Examples/Node.js/Module/MyModule/index.js</a></strong></p>\n<h2>参考资料</h2>\n<p>Node.js模块加载源码：<a href=\"https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js\" rel=\"nofollow noreferrer\">https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js</a></p>\n<p>Node.js模块官方文档：<a href=\"http://nodejs.cn/api/modules.html\" rel=\"nofollow noreferrer\">http://nodejs.cn/api/modules.html</a></p>\n<p><strong>文章的最后，感谢你花费宝贵的时间阅读本文，如果本文给了你一点点帮助或者启发，请不要吝啬你的赞和GitHub小星星，你的支持是作者持续创作的动力。</strong></p>\n<p><strong>作者博文GitHub项目地址： <a href=\"https://github.com/dennis-jiang/Front-End-Knowledges\" rel=\"nofollow noreferrer\">https://github.com/dennis-jiang/Front-End-Knowledges</a></strong></p>","descriptionType":"html","publishedDate":"Mon, 31 Aug 2020 02:48:55 +0000","feedId":6615,"bgimg":"","linkMd5":"a4467921a6794822efb2238b9675f769","bgimgJsdelivr":"","metaImg":"","author":"蒋鹏飞","publishedOrCreatedDate":1598931423822},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"当裸辞遇到面试难，这些面试题你需要了解一下","link":"https://segmentfault.com/a/1190000023825596","description":"<blockquote>\n 乘兴裸辞心甚爽，面试工作屡遭难。\n <br>幸得每日一题伴，点击关注莫偷懒。</br>\n</blockquote>\n<p>又要到金九银十的跳槽季了，为了让更多的小伙伴可以在面试的时候取的更好的<code>offer</code>,所以自上月起我每天都会在自己的公众号【前端有的玩】里面推送一到两道面试题，方便找工作的小伙伴每日都会有新的收获。本文就是小编将前期的一些比较经典的每日一题进行了梳理，欢迎大家一起来看看。本文内容首发于公众号【前端有的玩】，关注 <code>===</code> 学会。</p>\n<h3>类数组面试题</h3>\n<p>什么是类数组，类数组就是 拥有<code>length</code>属性，且其他属性（索引）为非负整数的对象，且不具备数组所用于的方法。比如我们常用的<code>document.querySelector</code>返回的<code>NodeLists</code>就是一个类数组。这道题就是和类数组相关的内容.</p>\n<h4>题目</h4>\n<p>请说出以下代码输出的内容，需要区分<code>nodejs</code>,<code>chrome</code>以及<code>chrome</code>去掉<code>splice</code>之后的输出内容</p>\n<pre><code class=\"javascript\">var obj = {\n    '2': 3,\n    '3': 4,\n    'length': 2,\n    'splice': Array.prototype.splice,\n    'push': Array.prototype.push\n}\nobj.push(1)\nobj.push(2)\nconsole.log(obj)</code></pre>\n<h4>答案</h4>\n<p>这道题一共问了三种情况下面的输出，下面依次说明答案</p>\n<ol>\n <li><p><code>node</code>下面输出</p><pre><code>{ '2': 1,\n  '3': 2,\n  length: 4,\n  splice: [Function: splice],\n  push: [Function: push] }</code></pre></li>\n <li><p><code>chrome</code>下面输出</p><pre><code>[empty × 2, 1, 2, splice: ƒ, push: ƒ]</code></pre></li>\n <li><p><code>chrome</code>去掉<code>splice</code>下面输出</p><pre><code>{2: 1, 3: 2, length: 4, push: ƒ}</code></pre></li>\n</ol>\n<p>通过上面输出的内容，可以看出相同的代码，不同情况输出的内容是有所不同的，下面进行详细分解。</p>\n<h4>题解</h4>\n<p>在解答题目之前，我们再看看这段代码</p>\n<pre><code class=\"javascript\">const arr = new Array(2)\n// 输出  2 [empty * 2]\nconsole.log(arr.length, arr)\narr.push(1)\n// 输出  3 [empty * 2, 1]\nconsole.log(arr.length, arr)</code></pre>\n<p>可以看到<code>push</code>方法会将数组的<code>length + 1</code>, 然后将值放在索引为<code>length - 1</code>的位置,比如上面的代码，因为在初始化数组的时候，已经将数组长度指定为了<code>2</code>, 所以在<code>push</code>之后<code>length</code>就变成了<code>3</code>,然后<code>arr[3 - 1] = 1</code></p>\n<p>在<code>MDN</code>上面对<code>push</code>的方法的解释是:</p>\n<blockquote>\n <code>push</code> 方法具有通用性。该方法和 \n <code>call()</code> 或 \n <code>apply()</code> 一起使用时，可应用在类似数组的对象上。\n <code>push</code> 方法根据 \n <code>length</code> 属性来决定从哪里开始插入给定的值。如果 \n <code>length</code> 不能被转成一个数值，则插入的元素索引为 0，包括 \n <code>length</code> 不存在时。当 \n <code>length</code> 不存在时，将会创建它。\n</blockquote>\n<p>根据<code>MDN</code>解释，<code>push</code>既可以使用到数组中，也可以使用到类数组中。而根据前文中对类数组的解释，可以看到题目中的<code>obj</code>就是一个标准的类数组，那就可以在<code>obj</code>上面使用数组的<code>push</code>方法。</p>\n<p>再看<code>obj.push(1)</code>, 因为<code>obj.length = 2</code>, 所以会将<code>length + 1</code>就变成了<code>3</code>, 这时候 索引值时<code>obj[3 - 1] = 1</code> 即<code>obj[2] = 1</code>, 同理 <code>obj.push(2)</code> 也一样的。因为在<code>obj</code>中已经有了属性(索引)<code>2</code>和<code>3</code>，所以在<code>push</code>的时候会覆盖掉<code>2</code>和<code>3</code>上面的默认值。</p>\n<p>所以在<code>nodejs</code>中就会输出</p>\n<pre><code>{ '2': 1,\n  '3': 2,\n  length: 4,\n  splice: [Function: splice],\n  push: [Function: push] }</code></pre>\n<p>但是在<code>chrome</code>控制台中输出</p>\n<pre><code>[empty × 2, 1, 2, splice: ƒ, push: ƒ]</code></pre>\n<p>很奇怪，为什么会输出这样呢？这一块有一个很特殊的陷阱，就是<code>chrome</code>控制台是如何判断打印的内容是数组还是其他对象呢？对于这个，<code>chrome</code>就是通过判断对象上面是否有<code>splice</code>和<code>length</code>这两个属性来判断的，所以如果你将<code>splice</code>去掉之后，就会输出以下内容</p>\n<pre><code>{2: 1, 3: 2, length: 4, push: ƒ}</code></pre>\n<p>你也可以试试下面的代码:</p>\n<pre><code class=\"javascript\">console.log({splice:function(){},length:1})\nconsole.log({slice:function(){},length:1})</code></pre>\n<h3>逻辑面试题之小鼠喝毒药</h3>\n<p>小编当年毕业的时候面试就遇到过好几次逻辑类的面试题，这道题就是一道逻辑类的面试题，一起来看看。</p>\n<h4>题目</h4>\n<p>有16瓶水，其中只有一瓶水有毒，小白鼠喝一滴之后一小时会死，请问最少用多少只小白鼠，在1小时内一定可以找出有毒的水？</p>\n<h4>答案与题解</h4>\n<p>答案是至少需要<code>4</code>只小鼠，怎么理解呢？我们可以用二进制去推理一下：</p>\n<p>假设有4只小鼠，分别是甲乙丙丁,使用二进制来表示小鼠喝药的顺序，<code>1</code>代表喝药,<code>0</code>代表不喝药</p>\n<p>甲: <code>1111 1111 0000 0000</code></p>\n<p>乙: <code>1111 0000 1111 0000</code></p>\n<p>丙: <code>1100 1100 1100 1100</code></p>\n<p>丁: <code>1010 1010 1010 1010</code></p>\n<p>那么我们就可以这样去判断:</p>\n<ol>\n <li>甲乙丙丁都死了，说明第一瓶有毒</li>\n <li>甲乙丙死了，说明第二瓶有毒</li>\n <li>甲乙丁死了，说明第三瓶有毒</li>\n <li>甲乙死了，说明第四瓶有毒</li>\n <li>甲丙丁死了，说明第五瓶有毒</li>\n <li>。。。 依次类推</li>\n</ol>\n<p>其实对于这道题，可以使用<code>2</code>的<code>n</code>次方来判断，比如有<code>32</code>瓶水，那么就是<code>2</code>的<code>5</code>次方，所以就需要<code>5</code>只小鼠。</p>\n<h3>arguments 面试题</h3>\n<p>在<code>ES6</code>中，我们如果一个函数参数个数不确定，我们一般会使用扩展运算符即<code>function(...rest){}</code>,得到一个参数数组<code>rest</code>，但是在<code>ES6</code>之前，我们是不能使用扩展运算符的，这时候就需要考虑使用<code>arguments</code></p>\n<h4>题目</h4>\n<p>请说出以下程序输出的内容(chrome输出内容)</p>\n<pre><code class=\"javascript\">let obj = {\n  arg: 18,\n  foo: function(func) {\n    func()\n    arguments[0]()\n  }\n}\n\nvar age = 10\nfunction fn() {\n  console.log(this.age)\n}\n\nobj.foo(fn)</code></pre>\n<h4>答案</h4>\n<p>本题的答案是:</p>\n<pre><code class=\"javascript\">// 第一个输出 10\nfunc()\n// 第一个输出 undefined\narguments[0]()</code></pre>\n<p>有点出乎意料了吗？</p>\n<p>先来解释一下第一个，为什么不是输出<code>18</code>呢，虽然<code>func()</code>是在<code>foo</code>函数里面调用的，但是并没有显式指明作用域，这时候会使用默认作用域<code>window</code>，而对于浏览器来说，在全局通过<code>var</code>声明的变量会自动挂载到<code>window</code>上面，所以<code>var age = 10</code>相当于<code>window.age = 10</code>, 而第一个<code>func()</code>里面的<code>this.age</code>相当于<code>window.age</code></p>\n<p>第二个可能许多人有点蒙，为啥是<code>undefined</code>,先看一下下面的代码</p>\n<pre><code class=\"javascript\">const arr = [function() {console.log(this[1])}, '我是子君']\n// 输出 我是子君\nconsole.log(arr[0]())</code></pre>\n<p>我们通过<code>arr[0]</code>获取到函数，这时候函数的作用域就是这个数组，所以再调用的时候，<code>this</code>就是<code>arr</code>, 所以<code>this[1]</code>就是数组第二项。</p>\n<p>这时候回过头来看<code>arguments</code>,这个其实是一个类数组，里面存的是函数传入的参数，第一项就是传入的函数，和上面例子一样，<code>arguments[0]</code>的作用域就是<code>arguments</code>,而<code>arguments</code>上面并没有<code>age</code>属性，所以是<code>undefined</code></p>\n<h3>this指向问题</h3>\n<p><code>this</code>指向问题一直是比较混乱的，在箭头函数出现之前，<code>this</code>的指向与代码在哪里定义并没有关系，而是取决于是被谁执行的，正因为此，所以许多开发人员经常会搞不清楚<code>this</code>到底是谁。下面的两道题都是和<code>this</code>指向相关的问题。</p>\n<h4>题目一（青铜）</h4>\n<p>请说出以下代码输出的内容</p>\n<pre><code class=\"javascript\">let num = 1;\nlet obj = {\n    num: 2,\n    add: function() {\n        this.num = 3;\n        (function() {\n            console.log(this.num);\n            this.num = 4;\n        })();\n        console.log(this.num);\n    },\n    sub: function() {\n        console.log(this.num)\n    }\n}\nobj.add();\nconsole.log(obj.num);\nconsole.log(num);\nconst sub = obj.sub;\nsub();</code></pre>\n<h4>题目二（黄金）</h4>\n<p>请说出以下代码输出的内容</p>\n<pre><code class=\"javascript\">var num = 10\nconst obj = {num: 20}\nobj.fn = (function (num) {\n  this.num = num * 3\n  num++\n  return function (n) {\n    this.num += n\n    num++\n    console.log(num)\n  }\n})(obj.num)\nvar fn = obj.fn\nfn(5)\nobj.fn(10)\nconsole.log(num, obj.num)</code></pre>\n<h4>答案</h4>\n<h5>题目一</h5>\n<p>输出结果: <code>1</code>,<code>3</code>,<code>3</code>,<code>4</code>,<code>4</code>， 你答对了吗？下面我们来看看代码解析</p>\n<pre><code class=\"javascript\">var num = 1;\nlet obj = {\n    num: 2,\n    add: function() {\n        this.num = 3;\n          // 这里的立即指向函数，因为我们没有手动去指定它的this指向，所以都会指向window\n        (function() {\n            // 所有这个 this.num 就等于 window.num\n            console.log(this.num);\n            this.num = 4;\n        })();\n        console.log(this.num);\n    },\n    sub: function() {\n        console.log(this.num)\n    }\n}\n// 下面逐行说明打印的内容\n\n/**\n * 在通过obj.add 调用add 函数时，函数的this指向的是obj,这时候第一个this.num=3\n * 相当于 obj.num = 3 但是里面的立即指向函数this依然是window,\n * 所以 立即执行函数里面console.log(this.num)输出1，同时 window.num = 4\n *立即执行函数之后，再输出`this.num`,这时候`this`是`obj`,所以输出3\n */\nobj.add() // 输出 1 3\n\n// 通过上面`obj.add`的执行，obj.name 已经变成了3\nconsole.log(obj.num) // 输出3\n// 这个num是 window.num\nconsole.log(num) // 输出4\n// 如果将obj.sub 赋值给一个新的变量，那么这个函数的作用域将会变成新变量的作用域\nconst sub = obj.sub\n// 作用域变成了window window.num 是 4\nsub() // 输出4</code></pre>\n<h5>题目二</h5>\n<p>输出结果为: <code>22</code> <code>23</code> <code>65</code> <code>30</code>, 你答对了吗？ 下面我们解析一下</p>\n<pre><code class=\"javascript\">var num = 10\nconst obj = {num: 20}\nobj.fn = (function (num) {\n  this.num = num * 3\n  num++\n  return function (n) {\n    this.num += n\n    num++\n    console.log(num)\n  }\n})(obj.num)\nvar fn = obj.fn\nfn(5)\nobj.fn(10)\nconsole.log(num, obj.num)</code></pre>\n<p>我们把上面的代码分为以下几步进行分析</p>\n<ol>\n <li>先看第三行代码，是一个赋值操作，我们知道赋值操作是从右向左的，而<code>=</code>号右边是一个立即执行函数，所以会优先执行立即执行函数，立即执行函数没有手动指定<code>this</code>,这时候<code>this = window</code>，而立即函数的参数<code>num</code>是传进来的<code>obj.num</code>,所以<code>num</code>参数默认值是 <code>20</code></li>\n <li>第四行相当于<code>window.num = 20 * 3</code></li>\n <li>第五行为传入的参数加一，所以 <code>num = 20 + 1</code></li>\n <li><p>第六行<code>return</code>了一个函数，而这个函数就是<code>obj.fn</code>的值, 但是因为<code>return</code>的函数引用了立即执行函数里面的<code>num</code>，所以形成了闭包。这时候</p><pre><code class=\"javascript\">obj.fn = function(n) {\n  this.num += n\n  // 这个num是立即执行函数里面的num\n  num++\n  console.log(num)\n}</code></pre></li>\n <li><code>var fn = obj.fn</code>, 将<code>obj.fn</code>赋值给新的变量，而这个变量的作用域是<code>window</code></li>\n <li>在调用<code>fn(5)</code>的时候， 在第二步，<code>window.num</code>的值已经变成了<code>60</code>, 然后因为这时候<code>fn</code>的<code>this</code>是<code>window</code>, <code>this.num += n</code>相当于<code>window.num += n</code>, 即<code>window.num = 65</code></li>\n <li><code>num++</code>, 因为闭包的原因，第三步<code>num</code>是<code>21</code>,所以这一步 <code>num</code>变成了<code>22</code>, 同时输出<code>22</code></li>\n <li>然后<code>obj.fn(10)</code>,这时候<code>fn</code>的<code>this</code>为<code>obj</code>,<code>obj.num</code>默认值是<code>20</code>, <code>this.num += n</code>相当于 <code>obj.num += 10</code></li>\n <li>和第七步一样， <code>num + 1</code> 输出 <code>23</code></li>\n <li><code>console.log(num, obj.num)</code>相当于 <code>console.log(window.num, obj.num)</code>，从上面几步可知， <code>window.num = 65</code>, <code>obj.num = 30</code>。</li>\n</ol>\n<h5>扩展题</h5>\n<p>如果将上面两道题的 <code>var</code>改成 <code>let</code>, 又会输出什么结果呢？</p>\n<h3>数据类型转换问题</h3>\n<p>虽然在日常开发中，我们隐氏类型转换用的比较少（不一定），但是这个还是面试常问问题，掌握还是要掌握的，一起来看看这道题目吧.</p>\n<h4>题目（王炸/青铜，我也不知道）</h4>\n<p>请说出以下代码输出的内容</p>\n<pre><code class=\"javascript\">console.log([] + [])\nconsole.log({} + [])\nconsole.log([] == ![])\nconsole.log(true + false)</code></pre>\n<h4>答案</h4>\n<p>一起来看看答案吧</p>\n<ol>\n <li>第一行代码</li>\n</ol>\n<pre><code class=\"javascript\">// 输出 \"\" 空字符串\nconsole.log([] + [])</code></pre>\n<p>这行代码输出的是空字符串<code>\"\"</code>， 包装类型在运算的时候，会先调用<code>valueOf</code>方法，如果<code>valueOf</code>返回的还是包装类型，那么再调用<code>toString</code>方法</p>\n<pre><code class=\"javascript\">// 还是 数组\nconst val = [].valueOf()\n// 数组 toString 默认会将数组各项使用逗号 \",\" 隔开, 比如 [1,2,3].toSting 变成了\"1,2,3\",空数组 toString 就是空字符串\nconst val1 = val.toString() // val1 是空字符串</code></pre>\n<p>所以上面的代码相当于</p>\n<pre><code class=\"javascript\">console.log(\"\" + \"\")</code></pre>\n<ol>\n <li><p>第二行代码</p><pre><code class=\"javascript\">// 输出 \"[object Object]\"\nconsole.log({} + [])</code></pre><p>和第一题道理一样，对象 <code>{}</code>隐氏转换成了<code>[object Object]</code>,然后与<code>\"\"</code>相加</p></li>\n <li><p>第三行代码</p><pre><code class=\"javascript\">// 输出 true\nconsole.log([] == ![])</code></pre><p>对于<code>===</code>, 会严格比较两者的值，但是对于<code>==</code>就不一样了</p>\n  <ol>\n   <li>比如 <code>null == undefined</code></li>\n   <li>如果非<code>number</code>与<code>number</code>比较，会将其转换为<code>number</code></li>\n   <li>如果比较的双方中由一方是<code>boolean</code>,那么会先将<code>boolean</code>转换为<code>number</code></li>\n  </ol></li>\n</ol>\n<p>所以对于上面的代码,看下面一步一步分析</p>\n<pre><code class=\"javascript\">// 这个输出 false\nconsole.log(![])\n// 套用上面第三条 将 false 转换为 数值\n// 这个输出 0\nconsole.log(Number(false))\n// 包装类型与 基本类型 == 先将包装类型通过 valueOf toString 转换为基本类型 \n// 输出 \"\"\nconsole.log([].toString())\n// 套用第2条， 将空字符串转换为数值、\n// 输出 0\nconsole.log(Number(\"\"))\n// 所以\nconsole.log(0 == 0)</code></pre>\n<ol>\n <li><p>第四行代码</p><pre><code class=\"javascript\">// 输出 1\nconsole.log(true + false)</code></pre><p>两个基本类型相加，如果其中一方是字符，则将其他的转换为字符相加，否则将类型转换为<code>Number</code>,然后相加, <code>Number(true)</code> 是<code>1</code>, <code>Number(false)</code>是<code>0</code>, 所以结果是 <code>1</code></p></li>\n</ol>\n<h3>总结</h3>\n<p>面试造火箭，工作拧螺丝。虽然我只想拧螺丝，但是我却需要通过造火箭来找到拧螺丝的工作，每日一题，每天都有新的面试题目，欢迎关注公众号【前端有的玩】，拉你进入前端技术交流群，每日一题等着你来一起答题。</p>\n<h3>结语</h3>\n<blockquote>\n 不要吹灭你的灵感和你的想象力; 不要成为你的模型的奴隶。 ——文森特・梵高\n</blockquote>","descriptionType":"html","publishedDate":"Mon, 31 Aug 2020 01:00:00 +0000","feedId":6615,"bgimg":"","linkMd5":"d05281f425c6cf28d5f8cb835c02f0ef","bgimgJsdelivr":"","metaImg":"","author":"子君","publishedOrCreatedDate":1598931423823},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"不要再问我 in，exists 走不走索引了","link":"https://segmentfault.com/a/1190000023825926","description":"<blockquote>\n 微信搜『烟雨星空』，获取最新好文。\n</blockquote>\n<h2>前言</h2>\n<p>最近，有一个业务需求，给我一份数据 A ，把它在数据库 B 中存在，而又比 A 多出的部分算出来。由于数据比较杂乱，我这里简化模型。</p>\n<p>然后就会发现，我去，这不就是 not in ，not exists 嘛。</p>\n<p>那么问题来了，in, not in , exists , not exists 它们有什么区别，效率如何？</p>\n<p>曾经从网上听说，in 和 exists 不会走索引，那么事实真的是这样吗？</p>\n<p>带着疑问，我们研究下去。</p>\n<p><strong>注意：</strong> 在说这个问题时，不说明 MySQL 版本的都是耍流氓，我这里用的是 5.7.18 。</p>\n<h2>用法讲解</h2>\n<p>为了方便，我们创建两张表 t1 和 t2 。并分别加入一些数据。（id为主键，name为普通索引）</p>\n<pre><code class=\"sql\">-- t1\nDROP TABLE IF EXISTS `t1`;\nCREATE TABLE `t1` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) DEFAULT NULL,\n  `address` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx_t1_name` (`name`(191)) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=1009 DEFAULT CHARSET=utf8mb4;\n\nINSERT INTO `t1` VALUES ('1001', '张三', '北京'), ('1002', '李四', '天津'), ('1003', '王五', '北京'), ('1004', '赵六', '河北'), ('1005', '杰克', '河南'), ('1006', '汤姆', '河南'), ('1007', '贝尔', '上海'), ('1008', '孙琪', '北京');\n\n-- t2\nDROP TABLE IF EXISTS `t2`;\nCREATE TABLE `t2`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,\n  `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `idx_t2_name`(`name`(191)) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 1014 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;\n\nINSERT INTO `t2` VALUES (1001, '张三', '北京');\nINSERT INTO `t2` VALUES (1004, '赵六', '河北');\nINSERT INTO `t2` VALUES (1005, '杰克', '河南');\nINSERT INTO `t2` VALUES (1007, '贝尔', '上海');\nINSERT INTO `t2` VALUES (1008, '孙琪', '北京');\nINSERT INTO `t2` VALUES (1009, '曹操', '魏国');\nINSERT INTO `t2` VALUES (1010, '刘备', '蜀国');\nINSERT INTO `t2` VALUES (1011, '孙权', '吴国');\nINSERT INTO `t2` VALUES (1012, '诸葛亮', '蜀国');\nINSERT INTO `t2` VALUES (1013, '典韦', '魏国');</code></pre>\n<p><img src=\"https://segmentfault.com/img/bVbL8mX\" alt=\"\" title=\"\" /></p>\n<p>那么，对于当前的问题，就很简单了，用 not in 或者 not exists 都可以把 t1 表中比 t2 表多出的那部分数据给挑出来。（当然，t2 比 t1 多出来的那部分不算）</p>\n<p>这里假设用 name 来匹配数据。</p>\n<pre><code class=\"sql\">select * from t1 where name not in (select name from t2);\n或者用\nselect * from t1 where not exists (select name from t2 where t1.name=t2.name);</code></pre>\n<p>得到的结果都是一样的。</p>\n<p><img src=\"https://segmentfault.com/img/bVbL8mY\" alt=\"\" title=\"\" /></p>\n<p>但是，需要注意的是，not in 和 not exists 还是有不同点的。</p>\n<p>在使用 not in 的时候，需要保证子查询的匹配字段是非空的。如，此表 t2 中的 name 需要有非空限制。如若不然，就会导致 not in 返回的整个结果集为空。</p>\n<p>例如，我在 t2 表中加入一条 name 为空的数据。</p>\n<pre><code class=\"sql\">INSERT INTO `t2` VALUES (1014, NULL, '魏国');</code></pre>\n<p>则此时，not in 结果就会返回空。</p>\n<p><img src=\"https://segmentfault.com/img/bVbL8mZ\" alt=\"\" title=\"\" /></p>\n<p>另外需要明白的是， exists 返回的结果是一个 boolean 值 true 或者 false ，而不是某个结果集。因为它不关心返回的具体数据是什么，只是外层查询需要拿这个布尔值做判断。</p>\n<p>区别是，用 exists 时，若子查询查到了数据，则返回真。 用 not exists 时，若子查询没有查到数据，则返回真。</p>\n<p>由于 exists 子查询不关心具体返回的数据是什么。因此，以上的语句完全可以修改为如下，</p>\n<pre><code class=\"sql\">-- 子查询中 name 可以修改为其他任意的字段，如此处改为 1 。\nselect * from t1 where not exists (select 1 from t2 where t1.name=t2.name);</code></pre>\n<p>从执行效率来说，1 &gt; column &gt; * 。因此推荐用 select 1。（准确的说应该是常量值）</p>\n<h2>in, exists 执行流程</h2>\n<p>1、 对于 in 查询来说，会先执行子查询，如上边的 t2 表，然后把查询得到的结果和外表 t1 做笛卡尔积，再通过条件进行筛选（这里的条件就是指 name 是否相等），把每个符合条件的数据都加入到结果集中。</p>\n<p>sql 如下，</p>\n<pre><code class=\"sql\">select * from t1 where name in (select name from t2);</code></pre>\n<p>伪代码如下：</p>\n<pre><code class=\"java\">for(x in A){\n    for(y in B){\n        if(condition is true) {result.add();}\n    }\n}</code></pre>\n<p>这里的 condition 其实就是对比两张表中的 name 是否相同。</p>\n<p>2、对于 exists 来说，是先查询遍历外表 t1 ，然后每次遍历时，再检查在内表是否符合匹配条件，即检查是否存在 name 相等的数据。</p>\n<p>sql 如下，</p>\n<pre><code class=\"sql\">select * from t1 where name exists (select 1 from t2);</code></pre>\n<p>伪代码如下：</p>\n<pre><code class=\"java\">for(x in A){\n    if(exists condition is true){result.add();}\n}</code></pre>\n<p>对应于此例，就是从 id 为 1001 开始遍历 t1 表 ，然后遍历时检查 t2 中是否有相等的 name 。</p>\n<p>如 id=1001时，张三存在于 t2 表中，则返回 true，把 t1 中张三的这条记录加入到结果集，继续下次循环。 id=1002 时，李四不在 t2 表中，则返回 false，不做任何操作，继续下次循环。直到遍历完整个 t1 表。</p>\n<h2>是否走索引？</h2>\n<p>针对网上说的 in 和 exists 不走索引，那么究竟是否如此呢？</p>\n<p>我们在 MySQL 5.7.18 中验证一下。（注意版本号哦）</p>\n<h3>单表查询</h3>\n<p>首先，验证单表的最简单的情况。我们就以 t1 表为例，id为主键， name 为普通索引。</p>\n<p>分别执行以下语句，</p>\n<pre><code class=\"sql\">explain select * from t1 where id in (1001,1002,1003,1004);\nexplain select * from t1 where id in (1001,1002,1003,1004,1005);\nexplain select * from t1 where name in ('张三','李四');\nexplain select * from t1 where name in ('张三','李四','王五');</code></pre>\n<p>为什么我要分别查不同的 id 个数呢？ 看截图，</p>\n<p><img src=\"https://segmentfault.com/img/bVbL8m0\" alt=\"\" title=\"\" /></p>\n<p><img src=\"https://segmentfault.com/img/bVbL8m1\" alt=\"\" title=\"\" /></p>\n<p>会惊奇的发现，当 id 是四个值时，还走主键索引。而当 id 是五个值时，就不走索引了。这就很耐人寻味了。</p>\n<p>再看 name 的情况，</p>\n<p><img src=\"https://segmentfault.com/img/bVbL8m2\" alt=\"\" title=\"\" /></p>\n<p><img src=\"https://segmentfault.com/img/bVbL8m3\" alt=\"\" title=\"\" /></p>\n<p>同样的当值多了之后，就不走索引了。</p>\n<p>所以，我猜测这个跟匹配字段的长度有关。按照汉字是三个字节来计算，且程序设计中喜欢用2的n次幂的尿性，这里大概就是以 16 个字节为分界点。</p>\n<p>然而，我又以同样的数据，去我的服务器上查询（版本号 5.7.22），发现四个id值时，就不走索引了。因此，估算这里的临界值为 12 个字节。</p>\n<p>不管怎样，这说明了，在 MySQL 中应该对 in 查询的字节长度是有限制的。（没有官方确切说法，所以，仅供参考）</p>\n<h3>多表涉及子查询</h3>\n<p>我们主要是去看当前的这个例子中的两表查询时， in 和 exists 是否走索引。</p>\n<p>一、分别执行以下语句，主键索引（id）和普通索引（name），在 in , not in 下是否走索引。</p>\n<pre><code class=\"sql\">explain select * from t1 where id in (select id from t2); --1\nexplain select * from t1 where name in (select name from t2); --2\nexplain select * from t1 where id not in (select id from t2); --3\nexplain select * from t1 where name not in (select name from t2); --4</code></pre>\n<p>结果截图如下，</p>\n<p>1、t1 走索引，t2 走索引。</p>\n<p><img src=\"https://segmentfault.com/img/bVbL8m4\" alt=\"1\" title=\"1\" /></p>\n<p>2、t1 不走索引，t2不走索引。（此种情况，实测若把name改为唯一索引，则t1也会走索引）</p>\n<p><img src=\"https://segmentfault.com/img/bVbL8m5\" alt=\"2\" title=\"2\" /></p>\n<p>3、t1 不走索引，t2走索引。</p>\n<p><img src=\"https://segmentfault.com/img/bVbL8m6\" alt=\"3\" title=\"3\" /></p>\n<p>4、t1不走索引，t2不走索引。</p>\n<p><img src=\"https://segmentfault.com/img/bVbL8m7\" alt=\"4\" title=\"4\" /></p>\n<p>我滴天，这结果看起来乱七八糟的，好像走不走索引，完全看心情。</p>\n<p>但是，我们发现只有第一种情况，即用主键索引字段匹配，且用 in 的情况下，两张表才都走索引。</p>\n<p>这个到底是不是规律呢？有待考察，且往下看。</p>\n<p>二、接下来测试，主键索引和普通索引在 exists 和 not exists 下的情况。sql如下，</p>\n<pre><code class=\"sql\">explain select * from t1 where exists (select 1 from t2 where t1.id=t2.id);\nexplain select * from t1 where exists (select 1 from t2 where t1.name=t2.name);\nexplain select * from t1 where not exists (select 1 from t2 where t1.id=t2.id);\nexplain select * from t1 where not exists (select 1 from t2 where t1.name=t2.name);</code></pre>\n<p>这个结果就非常有规律了，且看，</p>\n<p><img src=\"https://segmentfault.com/img/bVbL8m8\" alt=\"\" title=\"\" /></p>\n<p><img src=\"https://segmentfault.com/img/bVbL8na\" alt=\"\" title=\"\" /></p>\n<p><img src=\"https://segmentfault.com/img/bVbL8nb\" alt=\"\" title=\"\" /></p>\n<p><img src=\"https://segmentfault.com/img/bVbL8nc\" alt=\"\" title=\"\" /></p>\n<p>有没有发现， t1 表哪种情况都不会走索引，而 t2 表是有索引的情况下就会走索引。为什么会出现这种情况？</p>\n<p>其实，上一小节说到了 exists 的执行流程，就已经说明问题了。</p>\n<p>它是以外层表为驱动表，无论如何都会循环遍历的，所以会全表扫描。而内层表通过走索引，可以快速判断当前记录是否匹配。</p>\n<h2>效率如何？</h2>\n<p>针对网上说的 exists 一定比 in 的执行效率高，我们做一个测试。</p>\n<p>分别在 t1，t2 中插入 100W，200W 条数据。</p>\n<p>我这里，用的是自定义函数来循环插入，语句参考如下，（没有把表名抽离成变量，因为我没有找到方法，尴尬）</p>\n<pre><code class=\"sql\">-- 传入需要插入数据的id开始值和数据量大小，函数返回结果为最终插入的条数，此值正常应该等于数据量大小。\n-- id自增，循环往 t1 表添加数据。这里为了方便，id、name取同一个变量，address就为北京。\ndelimiter // \ndrop function if exists insert_datas1//\ncreate function insert_datas1(in_start int(11),in_len int(11)) returns int(11)\nbegin  \n  declare cur_len int(11) default 0;\n  declare cur_id int(11);\n  set cur_id = in_start;\n    \n  while cur_len &lt; in_len do\n     insert into t1 values(cur_id,cur_id,'北京');\n  set cur_len = cur_len + 1;\n  set cur_id = cur_id + 1;\n  end while; \n  return cur_len;\nend  \n//\ndelimiter ;\n-- 同样的，往 t2 表插入数据\ndelimiter // \ndrop function if exists insert_datas2//\ncreate function insert_datas2(in_start int(11),in_len int(11)) returns int(11)\nbegin  \n  declare cur_len int(11) default 0;\n  declare cur_id int(11);\n  set cur_id = in_start;\n    \n  while cur_len &lt; in_len do\n     insert into t2 values(cur_id,cur_id,'北京');\n  set cur_len = cur_len + 1;\n  set cur_id = cur_id + 1;\n  end while; \n  return cur_len;\nend  \n//\ndelimiter ;</code></pre>\n<p>在此之前，先清空表里的数据，然后执行函数，</p>\n<pre><code class=\"sql\">select insert_datas1(1,1000000);</code></pre>\n<p>对 t2 做同样的处理，不过为了两张表数据有交叉，就从 70W 开始，然后插入 200W 数据。</p>\n<pre><code class=\"sql\">select insert_datas2(700000,2000000);</code></pre>\n<p>在家里的电脑，实际执行时间，分别为 36s 和 74s。</p>\n<p>不知为何，家里的电脑还没有在 Docker 虚拟机中跑的脚本快。。害，就这样凑合着用吧。</p>\n<p>等我有了<del>新欢</del>钱，就把它换掉，哼哼。</p>\n<p>同样的，把上边的执行计划都执行一遍，进行对比。我这里就不贴图了。</p>\n<h3>in 和 exists 孰快孰慢</h3>\n<p>为了方便，主要拿以下这两个 sql 来对比分析。</p>\n<pre><code class=\"sql\">select * from t1 where id in (select id from t2);\nselect * from t1 where exists (select 1 from t2 where t1.id=t2.id);</code></pre>\n<p>执行结果显示，两个 sql 分别执行 1.3s 和 3.4s 。</p>\n<p>注意此时，t1 表数据量为 100W， t2 表数据量为 200W 。</p>\n<p>按照网上对 in 和 exists 区别的通俗说法，</p>\n<blockquote>\n 如果查询的两个表大小相当，那么用in和exists差别不大；如果两个表中一个较小一个较大，则子查询表大的用exists，子查询表小的用in；\n</blockquote>\n<p>对应于此处就是：</p>\n<ul>\n <li>当 t1 为小表， t2 为大表时，应该用 exists ，这样效率高。</li>\n <li>当 t1 为大表，t2 为小表时，应该用 in，这样效率较高。</li>\n</ul>\n<p>而我用实际数据测试，就把第一种说法给推翻了。因为很明显，t1 是小表，但是 in 比 exists 的执行速度还快。</p>\n<p>为了继续测验它这个观点，我把两个表的内表外表关系调换一下，让 t2 大表作为外表，来对比查询，</p>\n<pre><code class=\"sql\">select * from t2 where id in (select id from t1);\nselect * from t2 where exists (select 1 from t1 where t1.id=t2.id);</code></pre>\n<p>执行结果显示，两个 sql 分别执行 1.8s 和 10.0s 。</p>\n<p>是不是很有意思。 可以发现，</p>\n<ul>\n <li>对于 in 来说，大表小表调换了内外层关系，执行时间并无太大区别。一个是 1.3s，一个是 1.8s。</li>\n <li>对于 exists 来说，大小表调换了内外层关系，执行时间天壤之别，一个是 3.4s ，一个是 10.0s，足足慢了两倍。</li>\n</ul>\n<p>一、以查询优化器维度对比。</p>\n<p>为了探究这个结果的原因。我去查看它们分别在查询优化器中优化后的 sql 。</p>\n<p>以 <code>select * from t1 where id in (select id from t2);</code> 为例，顺序执行以下两个语句。</p>\n<pre><code class=\"sql\">-- 此为 5.7 写法，如果是 5.6版本，需要用 explain extended ...\nexplain select * from t1 where id in (select id from t2);\n-- 本意为显示警告信息。但是和 explain 一块儿使用，就会显示出优化后的sql。需要注意使用顺序。\nshow warnings;</code></pre>\n<p>在结果 Message 里边就会显示我们要的语句。</p>\n<p><img src=\"https://segmentfault.com/img/bVbL8nd\" alt=\"\" title=\"\" /></p>\n<pre><code class=\"sql\">-- message 优化后的sql\nselect `test`.`t1`.`id` AS `id`,`test`.`t1`.`name` AS `name`,`test`.`t1`.`address` AS `address` from `test`.`t2` join `test`.`t1` where (`test`.`t2`.`id` = `test`.`t1`.`id`)</code></pre>\n<p>可以发现，这里它把 in 转换为了 join 来执行。 </p>\n<p>这里没有用 on，而用了 where，是因为当只有 join 时，后边的 on 可以用 where 来代替。即 join on 等价于 join where 。</p>\n<p><strong>PS：</strong> 这里我们也可以发现，select <em> 最终会被转化为具体的字段，知道为什么我们不建议用 select </em> 了吧。</p>\n<p>同样的，以 t2 大表为外表的查询情况，也查看优化后的语句。</p>\n<pre><code class=\"sql\">explain select * from t2 where id in (select id from t1);\nshow warnings;</code></pre>\n<p>我们会发现，它也会转化为 join 的。</p>\n<pre><code class=\"sql\">select `test`.`t2`.`id` AS `id`,`test`.`t2`.`name` AS `name`,`test`.`t2`.`address` AS `address` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`id` = `test`.`t1`.`id`)</code></pre>\n<p>这里不再贴 exists 的转化 sql ，其实它没有什么大的变化。</p>\n<p>二、以执行计划维度对比。</p>\n<p>我们再以执行计划维度来对比他们的区别。</p>\n<pre><code class=\"sql\">explain select * from t1 where id in (select id from t2);\nexplain select * from t2 where id in (select id from t1);\nexplain select * from t1 where exists (select 1 from t2 where t1.id=t2.id);\nexplain select * from t2 where exists (select 1 from t1 where t1.id=t2.id);</code></pre>\n<p>执行结果分别为，</p>\n<p><img src=\"https://segmentfault.com/img/bVbL8ne\" alt=\"1\" title=\"1\" /></p>\n<p><img src=\"https://segmentfault.com/img/bVbL8nf\" alt=\"2\" title=\"2\" /></p>\n<p><img src=\"https://segmentfault.com/img/bVbL8ng\" alt=\"3\" title=\"3\" /></p>\n<p><img src=\"https://segmentfault.com/img/bVbL8nh\" alt=\"4\" title=\"4\" /></p>\n<p>可以发现，对于 in 来说，大表 t2 做外表还是内表，都会走索引的，小表 t1 做内表时也会走索引。看它们的 rows 一列也可以看出来，前两张图结果一样。</p>\n<p>对于 exists 来说，当小表 t1 做外表时，t1 全表扫描，rows 近 100W；当 大表 t2 做外表时， t2 全表扫描，rows 近 200W 。这也是为什么 t2 做外表时，执行效率非常低的原因。</p>\n<p>因为对于 exists 来说，外表总会执行全表扫描的，当然表数据越少越好了。</p>\n<p><strong>最终结论：</strong> 外层大表内层小表，用in。外层小表内层大表，in和exists效率差不多（甚至 in 比 exists 还快，而并不是网上说的 exists 比 in 效率高）。</p>\n<h3>not in 和 not exists 孰快孰慢</h3>\n<p>此外，实测对比 not in 和 not exists 。</p>\n<pre><code class=\"sql\">explain select * from t1 where id not in (select id from t2);\nexplain select * from t1 where not exists (select 1 from t2 where t1.id=t2.id);\nexplain select * from t1 where name not in (select name from t2);\nexplain select * from t1 where not exists (select 1 from t2 where t1.name=t2.name);\n\nexplain select * from t2 where id not in (select id from t1);\nexplain select * from t2 where not exists (select 1 from t1 where t1.id=t2.id);\nexplain select * from t2 where name not in (select name from t1);\nexplain select * from t2 where not exists (select 1 from t1 where t1.name=t2.name);</code></pre>\n<p>小表做外表的情况下。对于主键来说， not exists 比 not in 快。对于普通索引来说， not in 和 not exists 差不了多少，甚至 not in 会稍快。</p>\n<p>大表做外表的情况下，对于主键来说， not in 比 not exists 快。对于普通索引来说， not in 和 not exists 差不了多少，甚至 not in 会稍快。</p>\n<p>感兴趣的同学，可自行尝试。以上边的两个维度（查询优化器和执行计划）分别来对比一下。</p>\n<h3>join 的嵌套循环 (Nested-Loop Join)</h3>\n<p>为了理解为什么这里的 in 会转换为 join ，我感觉有必要了解一下 join 的三种嵌套循环连接。</p>\n<p>1、简单嵌套循环连接，Simple Nested-Loop Join ，简称 SNLJ</p>\n<p>join 即是 inner join ，内连接，它是一个笛卡尔积，即利用双层循环遍历两张表。</p>\n<p>我们知道，一般在 sql 中都会以小表作为驱动表。所以，对于 A，B 两张表，若A的结果集较少，则把它放在外层循环，作为驱动表。自然，B 就在内层循环，作为被驱动表。</p>\n<p>简单嵌套循环，就是最简单的一种情况，没有做任何优化。</p>\n<p>因此，复杂度也是最高的，O(mn)。伪代码如下，</p>\n<pre><code class=\"java\">for(id1 in A){\n    for(id2 in B){\n        if(id1==id2){\n            result.add();\n        }\n    }\n}</code></pre>\n<p>2、索引嵌套循环连接，Index Nested-Loop Join ，简称 INLJ</p>\n<p>看名字也能看出来了，这是通过索引进行匹配的。外层表直接和内层表的索引进行匹配，这样就不需要遍历整个内层表了。利用索引，减少了外层表和内层表的匹配次数。</p>\n<p>所以，此种情况要求内层表的列要有索引。</p>\n<p>伪代码如下，</p>\n<pre><code class=\"java\">for(id1 in A){\n    if(id1 matched B.id){\n        result.add();\n    }\n}</code></pre>\n<p>3、块索引嵌套连接，Block Nested-Loop Join ，简称 BNLJ</p>\n<p>块索引嵌套连接，是通过缓存外层表的数据到 join buffer 中，然后 buffer 中的数据批量和内层表数据进行匹配，从而减少内层循环的次数。</p>\n<p>以外层循环100次为例，正常情况下需要在内层循环读取外层数据100次。如果以每10条数据存入缓存buffer中，并传递给内层循环，则内层循环只需要读取10次(100/10)就可以了。这样就降低了内层循环的读取次数。</p>\n<p>MySQL 官方文档也有相关说明，可以参考：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html#block-nested-loop-join-algorithm\" rel=\"nofollow noreferrer\">https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html#block-nested-loop-join-algorithm</a></p>\n<p>所以，这里转化为 join，可以用到索引嵌套循环连接，从而提高了执行效率。</p>\n<p><strong>声明：</strong> 以上是以我的测试数据为准，测出来的结果。实际真实数据和测试结果很有可能会不太一样。如果有不同意见，欢迎留言讨论。</p>","descriptionType":"html","publishedDate":"Sun, 30 Aug 2020 16:12:26 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbL8mX","linkMd5":"4ea83030c443cca001ccdb773fb8a736","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn56@2020_3/2020/09/01/03-37-52-869_739f709b98d8c6bd.webp","destWidth":549,"destHeight":440,"sourceBytes":54015,"destBytes":15898,"author":"烟雨星空","articleImgCdnMap":{"https://segmentfault.com/img/bVbL8mX":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn56@2020_3/2020/09/01/03-37-52-869_739f709b98d8c6bd.webp","https://segmentfault.com/img/bVbL8mY":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn3@2020_5/2020/09/01/03-38-06-744_2e834841ee524f0f.webp","https://segmentfault.com/img/bVbL8mZ":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn8@2020_1/2020/09/01/03-38-06-332_2c9e0b715951e800.webp","https://segmentfault.com/img/bVbL8m0":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn74@2020_3/2020/09/01/03-38-03-493_63678abe8fff8d59.webp","https://segmentfault.com/img/bVbL8m1":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn58@2020_3/2020/09/01/03-38-02-249_f2bf5ea3c2dc9873.webp","https://segmentfault.com/img/bVbL8m2":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn61@2020_5/2020/09/01/03-38-02-975_ea2356b530a6d1c1.webp","https://segmentfault.com/img/bVbL8m3":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn66@2020_2/2020/09/01/03-38-02-145_82cd0f8a3748d672.webp","https://segmentfault.com/img/bVbL8m4":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn70@2020_1/2020/09/01/03-38-02-027_cf9a2f8b982c874e.webp","https://segmentfault.com/img/bVbL8m5":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn88@2020_3/2020/09/01/03-38-04-585_331f420438e55b19.webp","https://segmentfault.com/img/bVbL8m6":"https://cdn.jsdelivr.net/gh/myreaderx/cdn91@2020_3/2020/09/01/03-38-03-972_1ecc75f1dfdc03b5.webp","https://segmentfault.com/img/bVbL8m7":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn96@2020_6/2020/09/01/03-38-04-529_5309b89f682b87eb.webp","https://segmentfault.com/img/bVbL8m8":null,"https://segmentfault.com/img/bVbL8na":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn33@2020_6/2020/09/01/03-38-02-678_729eb0710dd38d1c.webp","https://segmentfault.com/img/bVbL8nb":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn17@2020_1/2020/09/01/03-38-02-528_4621da4f8c740a98.webp","https://segmentfault.com/img/bVbL8nc":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn21@2020_1/2020/09/01/03-38-01-535_31aaec06eb559545.webp","https://segmentfault.com/img/bVbL8nd":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn25@2020_4/2020/09/01/03-38-02-446_728a5dbae41e6709.webp","https://segmentfault.com/img/bVbL8ne":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn29@2020_3/2020/09/01/03-38-02-437_77821dc89e5fc28c.webp","https://segmentfault.com/img/bVbL8nf":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn38@2020_4/2020/09/01/03-38-01-653_e93146cdac3100d2.webp","https://segmentfault.com/img/bVbL8ng":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn42@2020_1/2020/09/01/03-38-01-832_4a4642035cdfc4c2.webp","https://segmentfault.com/img/bVbL8nh":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn46@2020_6/2020/09/01/03-38-02-084_2677ed46cc718c7f.webp"},"publishedOrCreatedDate":1598931423821},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"60亿次for循环,原来这么多东西","link":"https://segmentfault.com/a/1190000023825766","description":"<h4>起因</h4>\n<ul>\n <li>有人在思否论坛上向我付费提问</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/bVbL9iT\" alt=\"image.png\" title=\"image.png\" /></p>\n<ul>\n <li>当时觉得，这个人问的有问题吧。仔细一看，还是有点东西的</li>\n</ul>\n<h4>问题重现</h4>\n<ul>\n <li>编写一段<code>Node.js</code>代码</li>\n</ul>\n<pre><code>var http = require('http');\n  \nhttp.createServer(function (request, response) {\n    var num = 0\n    for (var i = 1; i &lt; 5900000000; i++) {\n        num += i\n    }\n    response.end('Hello' + num);\n}).listen(8888);</code></pre>\n<ul>\n <li>使用<code>nodemon</code>启动服务,用<code>time curl</code>调用这个接口</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/bVbL9i1\" alt=\"image.png\" title=\"image.png\" /></p>\n<ul>\n <li>首次需要<code>7.xxs</code>耗时</li>\n <li>多次调用后，问题重现</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/bVbL9i4\" alt=\"image.png\" title=\"image.png\" /></p>\n<ul>\n <li>为什么这个耗时突然变高，由于我是调用的是本机服务，我看<code>CPU</code>使用当时很高，差不多打到<code>100%</code>了.但是我后面发现不是这个问题.</li>\n</ul>\n<h4>问题排查</h4>\n<ul>\n <li>排除掉<code>CPU</code>问题，看内存消耗占用。</li>\n</ul>\n<pre><code>var http = require('http');\n\nhttp\n  .createServer(function(request, response) {\n    console.log(request.url, 'url');\n    let used = process.memoryUsage().heapUsed / 1024 / 1024;\n\n    console.log(\n      `The script uses approximately ${Math.round(used * 100) / 100} MB`,\n      'start',\n    );\n    console.time('测试');\n    let num = 0;\n    for (let i = 1; i &lt; 5900000000; i++) {\n      num += i;\n    }\n    console.timeEnd('测试');\n    used = process.memoryUsage().heapUsed / 1024 / 1024;\n    console.log(\n      `The script uses approximately ${Math.round(used * 100) / 100} MB`,\n      'end',\n    );\n    response.end('Hello' + num);\n![](https://imgkr2.cn-bj.ufileos.com/13455121-9d87-42c3-a32e-ea999a2cd09b.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=E3cF2kymC92LifrIC5IOfIZQvnk%253D&amp;Expires=1598883364)\n\n![](https://imgkr2.cn-bj.ufileos.com/1e7b95df-2a48-41c3-827c-3c24b39f4b5b.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=%252FANTTuhgbpIsXslXMc1qCkj2TMU%253D&amp;Expires=1598883362)\n\n  })\n  .listen(8888);</code></pre>\n<ul>\n <li>测试结果：</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/bVbL9i9\" alt=\"image.png\" title=\"image.png\" /></p>\n<ul>\n <li>内存占用和<code>CPU</code>都正常</li>\n <li>跟字符串拼接有关，此刻关闭字符串拼接（此时为了快速测试，我把循环次数降到<code>5.9亿次</code>）</li>\n</ul>\n<ul>\n <li>发现耗时稳定下来了</li>\n</ul>\n<h4>定位问题在字符串拼接，先看看字符串拼接的几种方式</h4>\n<ul>\n <li>一、使用连接符 “+” 把要连接的字符串连起来</li>\n</ul>\n<pre><code>var a = 'java'\nvar b = a + 'script'</code></pre>\n<p>  * 只连接100个以下的字符串建议用这种方法最方便</p>\n<ul>\n <li>二、使用数组的 join 方法连接字符串</li>\n</ul>\n<pre><code>var arr = ['hello','java','script']\nvar str = arr.join(\"\")</code></pre>\n<ul>\n <li>比第一种消耗更少的资源，速度也更快</li>\n <li>三、使用模板字符串，以反引号（ ` ）标识</li>\n</ul>\n<pre><code>var a = 'java'\nvar b = `hello ${a}script`</code></pre>\n<ul>\n <li>四、使用 JavaScript concat() 方法连接字符串</li>\n</ul>\n<pre><code>var a = 'java'\nvar b = 'script'\n\nvar str = a.concat(b)</code></pre>\n<h4>五、使用对象属性来连接字符串</h4>\n<pre><code>function StringConnect(){\n    this.arr = new Array()\n}\n\nStringConnect.prototype.append = function(str) {\n    this.arr.push(str)\n}\n\nStringConnect.prototype.toString = function() {\n    return this.arr.join(\"\")\n}\n\nvar mystr = new StringConnect()\n\nmystr.append(\"abc\")\nmystr.append(\"def\")\nmystr.append(\"g\")\n\nvar str = mystr.toString()</code></pre>\n<h4>更换字符串的拼接方式</h4>\n<ul>\n <li>我把字符串拼接换成了数组的<code>join</code>方式(此时循环<code>5.9</code>亿次)</li>\n</ul>\n<pre><code>var http = require('http');\n\nhttp\n  .createServer(function(request, response) {\n    console.log(request.url, 'url');\n    let used = process.memoryUsage().heapUsed / 1024 / 1024;\n\n    console.log(\n      `The script uses approximately ${Math.round(used * 100) / 100} MB`,\n      'start',\n    );\n    console.time('测试');\n    let num = 0;\n    for (let i = 1; i &lt; 590000000; i++) {\n      num += i;\n    }\n    const arr = ['Hello'];\n    arr.push(num);\n    console.timeEnd('测试');\n    used = process.memoryUsage().heapUsed / 1024 / 1024;\n    console.log(\n      `The script uses approximately ${Math.round(used * 100) / 100} MB`,\n      'end',\n    );\n    response.end(arr.join(''));\n  })\n  .listen(8888);</code></pre>\n<ul>\n <li>测试结果，发现接口调用的耗时稳定了(<code>注意此时是5.9亿次循环</code>)</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/bVbL9jD\" alt=\"image.png\" title=\"image.png\" /></p>\n<ul>\n <li><code>《javascript高级程序设计》</code>中，有一段关于字符串特点的描述，原文大概如下：<code>ECMAScript</code>中的字符串是不可变的，也就是说，字符串一旦创建，他们的值就不能改变。要改变某个变量的保存的的字符串，首先要销毁原来的字符串，然后再用另外一个包含新值的字符串填充该变量</li>\n</ul>\n<h4>就完了？</h4>\n<ul>\n <li>用<code>+</code>直接拼接字符串自然会对性能产生一些影响，因为字符串是不可变的，在操作的时候会产生临时字符串副本，<code>+</code>操作符需要消耗时间，重新赋值分配内存需要消耗时间。</li>\n <li>但是，我更换了代码后，发现，即使没有字符串拼接，也会耗时不稳定</li>\n</ul>\n<pre><code>var http = require('http');\n\nhttp\n  .createServer(function(request, response) {\n    console.log(request.url, 'url');\n    let used = process.memoryUsage().heapUsed / 1024 / 1024;\n\n    console.log(\n      `The script uses approximately ${Math.round(used * 100) / 100} MB`,\n      'start',\n    );\n    console.time('测试');\n    let num = 0;\n    for (let i = 1; i &lt; 5900000000; i++) {\n    //   num++;\n    }\n    const arr = ['Hello'];\n    // arr[1] = num;\n    console.timeEnd('测试');\n    used = process.memoryUsage().heapUsed / 1024 / 1024;\n    console.log(\n      `The script uses approximately ${Math.round(used * 100) / 100} MB`,\n      'end',\n    );\n    response.end('hello');\n  })\n  .listen(8888);</code></pre>\n<ul>\n <li>测试结果：</li>\n <li>现在我怀疑，不仅仅是字符串拼接的效率问题，更重要的是<code>for</code>循环的耗时不一致</li>\n</ul>\n<pre><code>var http = require('http');\n\nhttp\n  .createServer(function(request, response) {\n    console.log(request.url, 'url');\n    let used = process.memoryUsage().heapUsed / 1024 / 1024;\n\n    console.log(\n      `The script uses approximately ${Math.round(used * 100) / 100} MB`,\n      'start',\n    );\n    let num = 0;\n    console.time('测试');\n    for (let i = 1; i &lt; 5900000000; i++) {\n    //   num++;\n    }\n    console.timeEnd('测试');\n    const arr = ['Hello'];\n    // arr[1] = num;\n    used = process.memoryUsage().heapUsed / 1024 / 1024;\n    console.log(\n      `The script uses approximately ${Math.round(used * 100) / 100} MB`,\n      'end',\n    );\n    response.end('hello');\n  })\n  .listen(8888);\n</code></pre>\n<ul>\n <li>测试运行结果：</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/bVbL9jT\" alt=\"image.png\" title=\"image.png\" /></p>\n<ul>\n <li><code>for</code>循环内部的<code>i++</code>其实就是变量不断的重新赋值覆盖</li>\n <li>经过我的测试发现，<code>40亿次</code>跟<code>50亿次</code>的区别，差距很大，<code>40亿次的for循环</code>，都是稳定的，但是<code>50亿次</code>就不稳定了.</li>\n <li><code>Node.js</code>的<code>EventLoop</code>:</li>\n <li>我们目前被阻塞的状态：</li>\n <li>我电脑的<code>CPU</code>使用情况</li>\n</ul>\n<h4>优化方案</h4>\n<ul>\n <li>遇到了<code>60亿</code>次的循环，像有使用多进程异步计算的，但是本质上没有解决这部分循环代码的调用耗时。</li>\n <li>改变策略，拆解单次次数过大的<code>for</code>循环：</li>\n</ul>\n<pre><code>var http = require('http');\n\nhttp\n  .createServer(function(request, response) {\n    console.log(request.url, 'url');\n    let used = process.memoryUsage().heapUsed / 1024 / 1024;\n\n    console.log(\n      `The script uses approximately ${Math.round(used * 100) / 100} MB`,\n      'start',\n    );\n    let num = 0;\n    console.time('测试');\n    for (let i = 1; i &lt; 600000; i++) {\n      num++;\n      for (let j = 0; j &lt; 10000; j++) {\n        num++;\n      }\n    }\n    console.timeEnd('测试');\n    const arr = ['Hello'];\n    console.log(num, 'num');\n    arr[1] = num;\n    used = process.memoryUsage().heapUsed / 1024 / 1024;\n    console.log(\n      `The script uses approximately ${Math.round(used * 100) / 100} MB`,\n      'end',\n    );\n    response.end(arr.join(''));\n  })\n  .listen(8888);\n</code></pre>\n<ul>\n <li>结果，耗时基本稳定，<code>60亿次</code>循环总共：</li>\n</ul>\n<h4>推翻字符串的拼接耗时说法</h4>\n<ul>\n <li>修改代码回最原始的<code>+</code>方式拼接字符串</li>\n</ul>\n<pre><code>var http = require('http');\n\nhttp\n  .createServer(function(request, response) {\n    console.log(request.url, 'url');\n    let used = process.memoryUsage().heapUsed / 1024 / 1024;\n\n    console.log(\n      `The script uses approximately ${Math.round(used * 100) / 100} MB`,\n      'start',\n    );\n    let num = 0;\n    console.time('测试');\n    for (let i = 1; i &lt; 600000; i++) {\n      num++;\n      for (let j = 0; j &lt; 10000; j++) {\n        num++;\n      }\n    }\n    console.timeEnd('测试');\n    // const arr = ['Hello'];\n    console.log(num, 'num');\n    // arr[1] = num;\n    used = process.memoryUsage().heapUsed / 1024 / 1024;\n    console.log(\n      `The script uses approximately ${Math.round(used * 100) / 100} MB`,\n      'end',\n    );\n    response.end(`Hello` + num);\n  })\n  .listen(8888);</code></pre>\n<ul>\n <li>测试结果稳定，符合预期：</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/bVbL9kb\" alt=\"image.png\" title=\"image.png\" /></p>\n<h4>总结：</h4>\n<ul>\n <li>对于单次循环超过一定阀值次数的，用拆解方式，<code>Node.js</code>的运行耗时是稳定，但是如果是循环次数过多，那么就会出现刚才那种情况，阻塞严重，耗时不一样。</li>\n <li>为什么？</li>\n</ul>\n<h4>深度分析问题</h4>\n<ul>\n <li>遍历60亿次，这个数字是有一些大了，如果是40亿次，是稳定的</li>\n <li>这里应该还是跟<code>CPU</code>有一些关系，因为<code>top</code>查看一直是在升高</li>\n <li>此处虽然不是真正意义上的内存泄漏，但是我们如果在一个循环中不仅要不断更新<code>i</code>的值到<code>60亿</code>，还要不断更新<code>num</code>的值<code>60亿</code>，内存使用会不断上升，最终出现两份<code>60亿</code>的数据，然后再回收。（<code>因为GC自动垃圾回收，一样会阻塞主线程</code>，多次接口调用后，<code>CPU</code>占用也会升高）</li>\n <li>使用<code>for</code>循环拆解后：</li>\n</ul>\n<pre><code> for (let i = 1; i &lt; 60000; i++) {\n      num++;\n      for (let j = 0; j &lt; 100000; j++) {\n        num++;\n      }\n    }</code></pre>\n<ul>\n <li>只要<code>num</code>到<code>60亿</code>即可,解决了这个问题。</li>\n</ul>\n<h4>哪些场景会遇到这个类似的超大计算量问题：</h4>\n<ul>\n <li>图片处理</li>\n <li>加解密</li>\n</ul>\n<blockquote>\n 如果是异步的业务场景，也可以用多进程参与解决超大计算量问题，今天这里就不重复介绍了\n</blockquote>\n<h4>最后</h4>\n<ul>\n <li>如果感觉写得不错，可以点个<code>在看</code>/<code>赞</code>,转发一下，让更多人看到</li>\n <li>我是<code>Peter谭老师</code>,欢迎你关注公众号：<code>前端巅峰</code>，后台回复：<code>加群</code>即可加入大前端交流群</li>\n</ul>","descriptionType":"html","publishedDate":"Mon, 31 Aug 2020 01:00:00 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/bVbL9iT","linkMd5":"3628302f81725d25098e883660547b85","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn37@2020_4/2020/09/01/03-37-53-018_9271c05535ae62dc.webp","destWidth":635,"destHeight":130,"sourceBytes":26221,"destBytes":10774,"author":"Peter谭金杰","articleImgCdnMap":{"https://segmentfault.com/img/bVbL9iT":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn37@2020_4/2020/09/01/03-37-53-018_9271c05535ae62dc.webp","https://segmentfault.com/img/bVbL9i1":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn28@2020_4/2020/09/01/03-37-58-240_bfd4fe7f5e137c4d.webp","https://segmentfault.com/img/bVbL9i4":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn23@2020_6/2020/09/01/03-37-58-482_57543efccbe24ada.webp","https://segmentfault.com/img/bVbL9i9":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn32@2020_4/2020/09/01/03-37-58-469_4b0a9d3b01ac1dfd.webp","https://segmentfault.com/img/bVbL9jD":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn35@2020_6/2020/09/01/03-38-03-160_7f661db2e7753ec0.webp","https://segmentfault.com/img/bVbL9jT":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn40@2020_4/2020/09/01/03-37-58-537_91e2bed5f2661da2.webp","https://segmentfault.com/img/bVbL9kb":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn16@2020_6/2020/09/01/03-37-58-621_f7b15167502944c8.webp"},"publishedOrCreatedDate":1598931423820},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"如何优雅的实现消息通信？","link":"https://segmentfault.com/a/1190000023782318","description":"<h3>一、背景</h3>\n<p>作为一名 Web 开发者，在日常工作中，经常都会遇到消息通信的场景。比如实现组件间通信、实现插件间通信、实现不同的系统间通信。那么针对这些场景，我们应该怎么实现消息通信呢？本文阿宝哥将带大家一起来学习如何优雅的实现消息通信。</p>\n<p>好的，接下来我们马上步入正题，这里阿宝哥以一个文章订阅的例子来拉开本文的序幕。小秦与小王是阿宝哥的两个好朋友，他们在阿宝哥的 “<a href=\"http://www.semlinker.com/\" rel=\"nofollow noreferrer\">全栈修仙之路</a>” 博客中发现了 TS 专题文章，刚好他们近期也打算系统地学习 TS，所以他们就开启了 TS 的学习之旅。</p>\n<p>时间就这样过了半个月，小秦和小王都陆续找到了阿宝哥，说 “全栈修仙之路” 博客上的 TS 文章都差不多学完了，他们有空的时候都会到 “<a href=\"http://www.semlinker.com/\" rel=\"nofollow noreferrer\">全栈修仙之路</a>” 博客上查看是否有新发的 TS 文章。他们觉得这样挺麻烦的，看能不能在阿宝哥发完新的 TS 文章之后，主动通知他们。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023782322\" alt=\"\" title=\"\" /></p>\n<p>好友提的建议，阿宝哥怎能拒绝呢？所以阿宝哥分别跟他们说：“我会给博客加个订阅的功能，功能发布后，你填写一下邮箱地址。以后发布新的 TS 文章，系统会及时给你发邮件”。此时新的流程如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023782324\" alt=\"\" title=\"\" /></p>\n<p>在阿宝哥的一顿 “操作” 之后，博客的订阅功能上线了，阿宝哥第一时间通知了小秦与小王，让他们填写各自的邮箱。之后，每当阿宝哥发布新的 TS 文章，他们就会收到新的邮件通知了。</p>\n<p>阿宝哥是个技术宅，对新的技术也很感兴趣。在遇到 <a href=\"https://deno.land/\" rel=\"nofollow noreferrer\">Deno</a> 之后，阿宝哥燃起了学习 Deno 的热情，同时也开启了新的 Deno 专题。在写了几篇 Deno 专题文章之后，两个读者小池和小郭分别联系到我，说他们看到了阿宝哥的 Deno 文章，想跟阿宝哥一起学习 Deno。</p>\n<p>在了解他们的情况之后，阿宝哥突然想到了之前小秦与小王提的建议。因此，又是一顿 “操作” 之后，阿宝哥为了博客增加了专题订阅功能。该功能上线之后，阿宝哥及时联系了小池和小郭，邀请他们订阅 Deno 专题。之后小池和小郭也成为了阿宝哥博客的订阅者。现在的流程变成这样：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023782321\" alt=\"\" title=\"\" /></p>\n<p>这个例子看起来很简单，但它背后却与一些设计思想和设计模式相关联。因此，接下来阿宝哥将分析以上三个场景与软件开发中一些设计思想和设计模式的关联性。</p>\n<h3>二、场景与模式</h3>\n<h4>2.1 消息轮询模式</h4>\n<p>在第一个场景中，小秦和小王为了能查看阿宝哥新发的 TS 文章，他们需要不断地访问 “全栈修仙之路” 博客：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023782322\" alt=\"\" title=\"\" /></p>\n<p>这个场景跟软件开发过程中的轮询模式类似。早期，很多网站为了实现推送技术，所用的技术都是轮询。轮询是指由浏览器每隔一段时间向服务器发出 HTTP 请求，然后服务器返回最新的数据给客户端。常见的轮询方式分为轮询与长轮询，它们的区别如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023402636\" alt=\"\" title=\"\" /></p>\n<p>这种传统的模式带来很明显的缺点，<strong>即浏览器需要不断的向服务器发出请求，然而 HTTP 请求与响应可能会包含较长的头部，其中真正有效的数据可能只是很小的一部分，所以这样会消耗很多带宽资源</strong>。为了解决上述问题 HTML5 定义了 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p>\n<p>WebSocket 是一种网络传输协议，可在单个 TCP 连接上进行全双工通信，位于 OSI 模型的应用层。WebSocket 协议在 2011 年由 IETF 标准化为 <a href=\"https://tools.ietf.org/html/rfc6455\" rel=\"nofollow noreferrer\">RFC 6455</a>，后由 <a href=\"https://tools.ietf.org/html/rfc7936\" rel=\"nofollow noreferrer\">RFC 7936</a> 补充规范。</p>\n<p>既然已经提到了 <a href=\"https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B\" rel=\"nofollow noreferrer\">OSI（Open System Interconnection Model）模型</a>，这里阿宝哥来分享一张很生动、很形象描述 OSI 模型的示意图：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023402648\" alt=\"\" title=\"\" /></p>\n<p>（图片来源：<a href=\"https://www.networkingsphere.com/2019/07/what-is-osi-model.html\" rel=\"nofollow noreferrer\">https://www.networkingsphere....</a>）</p>\n<p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。<strong>在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</strong></p>\n<p>介绍完轮询和 WebSocket 的相关内容之后，接下来我们来看一下 XHR Polling 与 WebSocket 之间的区别：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023402633\" alt=\"\" title=\"\" /></p>\n<p>对于 XHR Polling 与 WebSocket 来说，它们分别对应了消息通信的两种模式，即 Pull（拉）模式与 Push（推）模式：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023782325\" alt=\"\" title=\"\" /></p>\n<p>场景一我们就介绍到这里，对轮询和 WebSocket 感兴趣的小伙伴可以阅读阿宝哥写的 <strong>“<a href=\"http://www.semlinker.com/you-dont-know-websocket/\" rel=\"nofollow noreferrer\">你不知道的 WebSocket</a>”</strong> 这一篇文章。下面我们来继续分析第二个场景。</p>\n<h4>2.2 观察者模式</h4>\n<p>在第二个场景中，为了让小秦和小王能及时收到阿宝哥新发布的 TS 文章，阿宝哥给博客增加了订阅功能。这里假设阿宝哥博客一开始只发布 TS 专题的文章。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023782324\" alt=\"\" title=\"\" /></p>\n<p>针对这个场景，我们可以考虑使用设计模式中观察者模式来实现上述功能。 <strong>观察者模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</strong> </p>\n<p>在观察者模式中有两个主要角色：Subject（主题）和 Observer（观察者）。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023782326\" alt=\"\" title=\"\" /></p>\n<p>在第二个场景中，Subject（主题）就是阿宝哥的 TS 专题文章，而观察者就是小秦和小王。由于观察者模式支持简单的广播通信，当消息更新时，会自动通知所有的观察者。因此对于第二个场景，我们可以考虑使用观察者设计模式来实现上述的功能。接下来，我们来继续分析第三个场景。</p>\n<h4>2.3 发布订阅模式</h4>\n<p>在第三个场景中，为了让小池和小郭能及时收到阿宝哥新发布的 Deno 文章，阿宝哥给博客增加了专题订阅功能。即支持为阿宝哥博客的订阅者分别推送新发布的 TS 或 Deno 文章。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023782321\" alt=\"\" title=\"\" /></p>\n<p>针对这个场景，我们可以考虑使用发布订阅模式来实现上述功能。在软件架构中，发布 — 订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，然后分别发送给不同的订阅者。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在。</p>\n<p>在发布订阅模式中有三个主要角色：Publisher（发布者）、 Channels（通道）和 Subscriber（订阅者）。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023782328\" alt=\"\" title=\"\" /></p>\n<p>在第三个场景中，Publisher（发布者）是阿宝哥，Channels（通道）中 Topic A 和 Topic B 分别对应于 TS 专题和 Deno 专题，而 Subscriber（订阅者）就是小秦、小王、小池和小郭。好的，了解完发布订阅模式，下面我们来介绍一下它的一些应用场景。</p>\n<h3>三、发布订阅模式的应用</h3>\n<h4>3.1 前端框架中模块/页面间消息通信</h4>\n<p>在一些主流的前端框架中，内部也会提供用于模块间或页面间通信的组件。比如在 Vue 框架中，我们可以通过 <code>new Vue()</code> 来创建 EventBus 组件。而在 Ionic 3 中我们可以使用 <code>ionic-angular</code> 模块中的 Events 组件来实现模块间或页面间的消息通信。下面我们来分别介绍在 Vue 和 Ionic 中如何实现模块/页面间的消息通信。</p>\n<h5>3.1.1 Vue 使用 EventBus 进行消息通信</h5>\n<p>在 Vue 中我们可以通过创建 EventBus 来实现组件间或模块间的消息通信，使用方式很简单。在下图中包含两个 Vue 组件：Greet 和 Alert 组件。Alert 组件用于显示消息，而 Greet 组件中包含一个按钮，即下图中 ”显示问候消息“ 的按钮。当用户点击按钮时，Greet 组件会通过 EventBus 把消息传递给 Alert 组件，该组件接收到消息后，会调用 <code>alert</code> 方法把收到的消息显示出来。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023782331\" alt=\"\" title=\"\" /></p>\n<p>以上示例对应的代码如下：</p>\n<p><strong>main.js</strong></p>\n<pre><code class=\"javascript\">Vue.prototype.$bus = new Vue();</code></pre>\n<p><strong>Alert.vue</strong></p>\n<pre><code class=\"html\">&lt;script&gt;\nexport default {\n  name: \"alert\",\n  created() {\n    // 监听alert:message事件\n    this.$bus.$on(\"alert:message\", msg =&gt; {\n      this.showMessage(msg);\n    });\n  },\n  methods: {\n    showMessage(msg) {\n      alert(msg);\n    },\n  },\n  beforeDestroy: function() {\n    // 组件销毁时，移除alert:message事件监听\n    this.$bus.$off(\"alert:message\");\n  }\n}\n&lt;/script&gt;</code></pre>\n<p><strong>Greet.vue</strong></p>\n<pre><code class=\"html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=\"greet(message)\"&gt;显示问候信息&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: \"Greet\",\n  data() {\n    return {\n      message: \"大家好，我是阿宝哥\",\n    };\n  },\n  methods: {\n    greet(msg) {\n      this.$bus.$emit(\"alert:message\", msg);\n    }\n  }\n};\n&lt;/script&gt;</code></pre>\n<h5>3.1.2 Ionic 使用 Events 组件进行消息通信</h5>\n<p>在 Ionic 3 项目中，要实现页面间消息通信很简单。我们只要通过构造注入的方式注入 <code>ionic-angular</code> 模块中提供的 Events 组件即可。具体的使用示例如下所示：</p>\n<pre><code class=\"typescript\">import { Events } from 'ionic-angular';\n\n// first page (publish an event when a user is created)\nconstructor(public events: Events) {}\ncreateUser(user) {\n  console.log('User created!')\n  this.events.publish('user:created', user, Date.now());\n}\n\n\n// second page (listen for the user created event after function is called)\nconstructor(public events: Events) {\n  events.subscribe('user:created', (user, time) =&gt; {\n    // user and time are the same arguments passed in `events.publish(user, time)`\n    console.log('Welcome', user, 'at', time);\n  });\n}</code></pre>\n<p>介绍完发布订阅模式在 Vue 和 Ionic 框架中的应用之后，接下来阿宝哥将介绍该模式在微内核架构中是如何实现插件通信的。</p>\n<h4>3.2 微内核架构中插件通信</h4>\n<p>微内核架构（Microkernel Architecture），有时也被称为插件化架构（Plug-in Architecture），是一种面向功能进行拆分的可扩展性架构，通常用于实现基于产品的应用。微内核架构模式允许你将其他应用程序功能作为插件添加到核心应用程序，从而提供可扩展性以及功能分离和隔离。</p>\n<p>微内核架构模式包括两种类型的架构组件：核心系统（Core System）和插件模块（Plug-in modules）。<strong>应用逻辑被分割为独立的插件模块和核心系统，提供了可扩展性、灵活性、功能隔离和自定义处理逻辑的特性。</strong></p>\n<p>&lt;img src=\"http://cdn.semlinker.com/microkernel-architecture-pattern.png\" alt=\"\" style=\"zoom:60%;\" /&gt;</p>\n<p>对于微内核的核心系统设计来说，它涉及三个关键技术：<strong>插件管理、插件连接和插件通信</strong>，这里我们重点来分析一下插件通信。</p>\n<p>插件通信是指插件间的通信。虽然设计的时候插件间是完全解耦的，但实际业务运行过程中，必然会出现某个业务流程需要多个插件协作，这就要求两个插件间进行通信；<strong>由于插件之间没有直接联系，通信必须通过核心系统，因此核心系统需要提供插件通信机制</strong>。</p>\n<p>这种情况和计算机类似，计算机的 CPU、硬盘、内存、网卡是独立设计的配置，但计算机运行过程中，CPU 和内存、内存和硬盘肯定是有通信的，计算机通过主板上的总线提供了这些组件之间的通信功能。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023782329\" alt=\"\" title=\"\" /></p>\n<p>下面阿宝哥将以基于微内核架构设计的西瓜播放器为例，介绍它的内部是如何提供插件通信机制。在西瓜播放器内部，定义了一个 <code>Player</code> 类来创建播放器实例：</p>\n<pre><code class=\"javascript\">let player = new Player({\n  id: 'mse',\n  url: '//abc.com/**/*.mp4'\n});</code></pre>\n<p><code>Player</code> 类继承于 <code>Proxy</code> 类，而在 <code>Proxy</code> 类内部会通过构造继承的方式继承 <code>EventEmitter</code> 事件派发器：</p>\n<pre><code class=\"javascript\">import EventEmitter from 'event-emitter'\n\nclass Proxy {\n  constructor (options) {\n    this._hasStart = false;\n    // 省略大部分代码\n    EventEmitter(this);\n  }\n}</code></pre>\n<p>所以我们创建的西瓜播放器也是一个事件派发器，利用它就可以实现插件的通信。为了让大家能够更好地理解具体的通信流程，我们以内置的 poster 插件为例，来看一下它内部如何使用事件派发器。</p>\n<p>poster 插件用于在播放器播放音视频前显示海报图，该插件的使用方式如下：</p>\n<pre><code class=\"javascript\">new Player({\n  el:document.querySelector('#mse'),\n  url: 'video_url',\n  poster: '//abc.com/**/*.png' // 默认值\"\"\n});</code></pre>\n<p>poster 插件的对应源码如下：</p>\n<pre><code class=\"javascript\">import Player from '../player'\n\nlet poster = function () {\n  let player = this; \n  let util = Player.util\n  let poster = util.createDom('xg-poster', '', {}, 'xgplayer-poster');\n  let root = player.root\n  if (player.config.poster) {\n    poster.style.backgroundImage = `url(${player.config.poster})`\n    root.appendChild(poster)\n  }\n\n  // 监听播放事件，播放时隐藏封面图\n  function playFunc () {\n    poster.style.display = 'none'\n  }\n  player.on('play', playFunc)\n\n  // 监听销毁事件，执行清理操作\n  function destroyFunc () {\n    player.off('play', playFunc)\n    player.off('destroy', destroyFunc)\n  }\n  player.once('destroy', destroyFunc)\n}\n\nPlayer.install('poster', poster)</code></pre>\n<p>(<a href=\"https://github.com/bytedance/xgplayer/blob/master/packages/xgplayer/src/control/poster.js)\" rel=\"nofollow noreferrer\">https://github.com/bytedance/...</a></p>\n<p>通过观察源码可知，在注册 poster 插件时，会把播放器实例注入到插件中。之后，在插件内部会使用 player 这个事件派发器来监听播放器的 <code>play</code> 和 <code>destroy</code> 事件。当 poster 插件监听到播放器的 <code>play</code> 事件之后，就会隐藏海报图。而当 poster 插件监听到播放器的 <code>destroy</code> 事件时，就会执行清理操作，比如移除已绑定的事件。</p>\n<p>看到这里我们就已经很清楚了，西瓜播放器内部使用 <code>EventEmitter</code> 来提供插件通信机制，每个插件都会注入 player 这个全局的事件派发器，通过它就可以轻松地实现插件间通信了。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023782332\" alt=\"\" title=\"\" /></p>\n<p>提到 <code>EventEmitter</code>，相信很多小伙伴对它并不会陌生。在 Node.js 中有一个名为 <code>events</code> 的内置模块，通过它我们可以方便地实现一个自定义的事件派发器，比如：</p>\n<pre><code class=\"javascript\">const EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n\nmyEmitter.on('event', () =&gt; {\n  console.log('大家好，我是阿宝哥!');\n});\n\nmyEmitter.emit('event');</code></pre>\n<h4>3.3 基于 Redis 实现不同系统间通信</h4>\n<p>在前面我们介绍了发布订阅模式在单个系统中的应用。其实，在日常开发过程中，我们也会遇到不同系统间通信的问题。接下来阿宝哥将介绍如何利用 Redis 提供的发布与订阅功能实现系统间的通信，不过在介绍具体应用前，我们得先熟悉一下 Redis 提供的发布与订阅功能。</p>\n<h5>3.3.1 Redis 发布与订阅功能</h5>\n<p><strong>Redis 订阅功能</strong></p>\n<p>通过 Redis 的 subscribe 命令，我们可以订阅感兴趣的通道，其语法为：<code>SUBSCRIBE channel [channel …]</code>。</p>\n<pre><code class=\"shell\">➜  ~ redis-cli\n127.0.0.1:6379&gt; subscribe deno ts\nReading messages... (press Ctrl-C to quit)\n1) \"subscribe\"\n2) \"deno\"\n3) (integer) 1\n1) \"subscribe\"\n2) \"ts\"\n3) (integer) 2</code></pre>\n<p>在上述命令中，我们通过 <code>subscribe</code> 命令订阅了 deno 和 ts 两个通道。接下来我们新开一个命令行窗口，来测试 Redis 的发布功能。</p>\n<p><strong>Redis 发布功能</strong></p>\n<p>通过 Redis 的 publish 命令，我们可以为指定的通道发布消息，其语法为： <code>PUBLISH channel message</code>。</p>\n<pre><code class=\"shell\">➜  ~ redis-cli\n127.0.0.1:6379&gt; publish ts \"pub/sub design mode\"\n(integer) 1</code></pre>\n<p>当成功发布消息之后，订阅该通道的客户端就会收到消息，对应的控制台就会输出如下信息：</p>\n<pre><code>1) \"message\"\n2) \"ts\"\n3) \"pub/sub design mode\"</code></pre>\n<p>了解完 Redis 的发布与订阅功能，接下来阿宝哥将介绍如何利用 Redis 提供的发布与订阅功能实现不同系统间的通信。</p>\n<h5>3.3.2 实现不同系统间的通信</h5>\n<p>这里我们使用 Node.js 的 <a href=\"https://expressjs.com/zh-cn/\" rel=\"nofollow noreferrer\">Express</a> 框架和 <a href=\"https://www.npmjs.com/package/redis\" rel=\"nofollow noreferrer\">redis</a> 模块来快速搭建不同的 Web 应用，首先创建一个新的 Web 项目并安装一下相关的依赖：</p>\n<pre><code class=\"shell\">$ npm init --yes\n$ npm install express redis</code></pre>\n<p>接着创建一个发布者应用：</p>\n<p><strong>publisher.js</strong></p>\n<pre><code class=\"javascript\">const redis = require(\"redis\");\nconst express = require(\"express\");\n\nconst publisher = redis.createClient();\n\nconst app = express();\n\napp.get(\"/\", (req, res) =&gt; {\n  const article = {\n    id: \"666\",\n    name: \"TypeScript实战之发布订阅模式\",\n  };\n\n  publisher.publish(\"ts\", JSON.stringify(article));\n  res.send(\"阿宝哥写了一篇TS文章\");\n});\n\napp.listen(3005, () =&gt; {\n  console.log(`server is listening on PORT 3005`);\n});</code></pre>\n<p>然后分别创建两个订阅者应用：</p>\n<p><strong>subscriber-1.js</strong></p>\n<pre><code class=\"javascript\">const redis = require(\"redis\");\nconst express = require(\"express\");\n\nconst subscriber = redis.createClient();\n\nconst app = express();\n\nsubscriber.on(\"message\", (channel, message) =&gt; {\n  console.log(\"小王收到了阿宝哥的TS文章: \" + message);\n});\n\nsubscriber.subscribe(\"ts\");\n\napp.get(\"/\", (req, res) =&gt; {\n  res.send(\"我是阿宝哥的粉丝，小王\");\n});\n\napp.listen(3006, () =&gt; {\n  console.log(\"server is listening to port 3006\");\n});</code></pre>\n<p><strong>subscriber-2.js</strong></p>\n<pre><code class=\"javascript\">const redis = require(\"redis\");\nconst express = require(\"express\");\n\nconst subscriber = redis.createClient();\n\n// https://dev.to/ganeshmani/implementing-redis-pub-sub-in-node-js-application-12he\nconst app = express();\n\nsubscriber.on(\"message\", (channel, message) =&gt; {\n  console.log(\"小秦收到了阿宝哥的TS文章: \" + message);\n});\n\nsubscriber.subscribe(\"ts\");\n\napp.get(\"/\", (req, res) =&gt; {\n  res.send(\"我是阿宝哥的粉丝，小秦\");\n});\n\napp.listen(3007, () =&gt; {\n  console.log(\"server is listening to port 3007\");\n});</code></pre>\n<p>接着分别启动上面的三个应用，当所有应用都成功启动之后，在浏览器中访问 <code>http://localhost:3005/</code> 地址，此时上面的两个订阅者应用对应的终端会分别输出以下信息：</p>\n<p><strong>subscriber-1.js</strong></p>\n<pre><code>server is listening to port 3006\n小王收到了阿宝哥的TS文章: {\"id\":\"666\",\"name\":\"TypeScript实战之发布订阅模式\"}</code></pre>\n<p><strong>subscriber-2.js</strong></p>\n<pre><code>server is listening to port 3007\n小秦收到了阿宝哥的TS文章: {\"id\":\"666\",\"name\":\"TypeScript实战之发布订阅模式\"}</code></pre>\n<p>以上示例对应的通信流程如下图所示：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023782333\" alt=\"\" title=\"\" /></p>\n<p>到这里发布订阅模式的应用场景，已经介绍完了。最后，阿宝哥来介绍一下如何使用 TS 实现一个支持发布与订阅功能的 EventEmitter 组件。</p>\n<h3>四、发布订阅模式实战</h3>\n<h4>4.1 定义 EventEmitter 类</h4>\n<pre><code class=\"typescript\">type EventHandler = (...args: any[]) =&gt; any;\n\nclass EventEmitter {\n  private c = new Map&lt;string, EventHandler[]&gt;();\n\n  // 订阅指定的主题\n  subscribe(topic: string, ...handlers: EventHandler[]) {\n    let topics = this.c.get(topic);\n    if (!topics) {\n      this.c.set(topic, topics = []);\n    }\n    topics.push(...handlers);\n  }\n\n  // 取消订阅指定的主题\n  unsubscribe(topic: string, handler?: EventHandler): boolean {\n    if (!handler) {\n      return this.c.delete(topic);\n    }\n\n    const topics = this.c.get(topic);\n    if (!topics) {\n      return false;\n    }\n    \n    const index = topics.indexOf(handler);\n\n    if (index &lt; 0) {\n      return false;\n    }\n    topics.splice(index, 1);\n    if (topics.length === 0) {\n      this.c.delete(topic);\n    }\n    return true;\n  }\n\n  // 为指定的主题发布消息\n  publish(topic: string, ...args: any[]): any[] | null {\n    const topics = this.c.get(topic);\n    if (!topics) {\n      return null;\n    }\n    return topics.map(handler =&gt; {\n      try {\n        return handler(...args);\n      } catch (e) {\n        console.error(e);\n        return null;\n      }\n    });\n  }\n}</code></pre>\n<h4>4.2 使用示例</h4>\n<pre><code class=\"typescript\">const eventEmitter = new EventEmitter();\neventEmitter.subscribe(\"ts\", (msg) =&gt; console.log(`收到订阅的消息：${msg}`) );\n\neventEmitter.publish(\"ts\", \"TypeScript发布订阅模式\");\neventEmitter.unsubscribe(\"ts\");\neventEmitter.publish(\"ts\", \"TypeScript发布订阅模式\");</code></pre>\n<p>以上代码成功运行之后，控制台会输出以下信息：</p>\n<pre><code>收到订阅的消息：TypeScript发布订阅模式</code></pre>\n<h3>五、参考资源</h3>\n<ul>\n <li><a href=\"https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85\" rel=\"nofollow noreferrer\">维基百科 - 发布/订阅</a></li>\n <li><a href=\"https://ionicframework.com/docs/v3/api/util/Events/\" rel=\"nofollow noreferrer\">Ionic 3 - Events</a></li>\n <li><a href=\"https://dev.to/ganeshmani/implementing-redis-pub-sub-in-node-js-application-12he\" rel=\"nofollow noreferrer\">implementing-redis-pub-sub-in-node-js-application</a></li>\n</ul>\n<h3>六、推荐阅读</h3>\n<ul>\n <li><a href=\"http://www.semlinker.com/ts-quickstart-2020/\" rel=\"nofollow noreferrer\">了不起的 TypeScript 入门教程</a></li>\n <li><a href=\"http://www.semlinker.com/master-ts-generic/\" rel=\"nofollow noreferrer\">一文读懂 TypeScript 泛型及应用</a></li>\n <li><a href=\"http://www.semlinker.com/you-dont-know-websocket/\" rel=\"nofollow noreferrer\">你不知道的 WebSocket</a></li>\n <li><a href=\"http://www.semlinker.com/you-dont-know-blob/\" rel=\"nofollow noreferrer\">你不知道的 Blob</a></li>\n <li><a href=\"http://www.semlinker.com/you-dont-know-weakmap/\" rel=\"nofollow noreferrer\">你不知道的 WeakMap</a></li>\n</ul>","descriptionType":"html","publishedDate":"Wed, 26 Aug 2020 23:48:02 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023782322","linkMd5":"c5762ccc3f748952b49f0809e1c1d52e","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn18@2020_2/2020/09/01/03-37-53-253_63eacc2b71b94bb2.webp","destWidth":800,"destHeight":377,"sourceBytes":37483,"destBytes":15764,"author":"阿宝哥","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023782322":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn18@2020_2/2020/09/01/03-37-53-253_63eacc2b71b94bb2.webp","https://segmentfault.com/img/remote/1460000023782324":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn86@2020_1/2020/09/01/03-38-02-646_d2b1346867c82963.webp","https://segmentfault.com/img/remote/1460000023782321":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn1@2020_4/2020/09/01/03-38-01-851_c79aa388a9a4f6e1.webp","https://segmentfault.com/img/remote/1460000023402636":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn54@2020_1/2020/09/01/03-38-04-309_0b083e89fc14ae1f.webp","https://segmentfault.com/img/remote/1460000023402648":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn49@2020_3/2020/09/01/03-38-02-653_65a9eba70fb7fcfc.webp","https://segmentfault.com/img/remote/1460000023402633":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn77@2020_4/2020/09/01/03-38-02-898_1b1c937f60b4823a.webp","https://segmentfault.com/img/remote/1460000023782325":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn89@2020_6/2020/09/01/03-38-02-198_3e586aefbe01cd40.webp","https://segmentfault.com/img/remote/1460000023782326":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn94@2020_6/2020/09/01/03-38-02-255_870a115b75fc1ec3.webp","https://segmentfault.com/img/remote/1460000023782328":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn78@2020_5/2020/09/01/03-38-01-850_a1a56e898066d815.webp","https://segmentfault.com/img/remote/1460000023782331":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn65@2020_1/2020/09/01/03-38-02-425_dbf06a2b8e54cdb1.webp","https://segmentfault.com/img/remote/1460000023782329":null,"https://segmentfault.com/img/remote/1460000023782332":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn70@2020_4/2020/09/01/03-38-07-991_bec13ff2d5db88b9.webp","https://segmentfault.com/img/remote/1460000023782333":"https://cdn.jsdelivr.net/gh/myreaderx/cdn73@2020_3/2020/09/01/03-38-01-673_2cb789f45dd9a9c2.webp"},"publishedOrCreatedDate":1598931423824},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"透视不同的架构思维，赏析架构之美","link":"https://segmentfault.com/a/1190000023800899","description":"<h2>什么是系统架构(Architecture)</h2>\n<blockquote>\n 设计不仅仅指的是外观和感觉，它还包括运作方式。—— 史蒂夫·乔布斯\n</blockquote>\n<p>系统架构（System Architecture），软件架构（Soft Architecture）是 IT 领域常见的名词，架构设计是软件系统构建过程中极其关键的一部分。</p>\n<p>系统架构为什么重要？常见的架构模式都有哪些？跟着 【码哥字节】了解不同的架构设计所运用的不同设计哲学。</p>\n<p>一起来看下常见的架构模式：<strong>Client-Server、Peer to Peer、MVC、Layered、Distribute-Cluster、Micro-Service、Even-Source、Hexagonal</strong> 逐个击破。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023800902\" alt=\"\" title=\"\" /></p>\n<p>Architecture，原意建筑学，其实软件架构的概念就是源于建筑学。建筑学是建筑物设计和建造相关的艺术和技术的综合。建筑学是一门横跨工程技术和人文艺术的学科。它研究的是建筑物可资使用的空间、可供欣赏的形象，以及围绕空间、形象如何产生确立、调整美化等的一系列问题。并且其所研究的对象不仅是建筑物本身，更主要的是研究人们对建筑物的要求及其如何得以满足，研究建筑物实体从无到有的产生过程中相应的策划、设计、实施等。</p>\n<p>建筑学研究建筑的规划、设计和实施。软件架构研究软件的规划、设计和实施。</p>\n<p>在架构设计中，根据业务、技术、组织、灵活性、可扩展性以及可维护性等因素，将应用系统划分成不同的部分，使这些部分之间相互分工、相互协作，从而完成特定的需求。架构贯穿系统实现的整个过程，是软件系统实现的主要参考，是软件系统实现的蓝图。软件系统的规划、设计和实施依架构的设计而组织实施。</p>\n<h2>系统架构为什么重要</h2>\n<p>我们知道摩尔定律——计算机硬件的能力大致每两年提高一倍的速度发展。然而软件开发的流程却没有这样的提速过程，开发成本也没有下降，系统架构的设计方法论和设计模式不断变化，而这个重要的流程依旧没有一个完全可靠和一劳永逸的解决方案。为什么？软件开发过程有什么特别的难题？有下面几点：</p>\n<ol>\n <li>复杂性（Complexity）<p>软件可以说是人类创造的最复杂的系统类型。软件的各个模块之间有各种显性或隐性的依赖关系，随着系统的成长和模块的增多，这些关系的数量往往以几何级数的速度增长。而理解运用这些复杂性的人并没有太多的变化。</p></li>\n <li>不可见性（Invisibility）<p>软件工程师能直接看见源代码，但是源代码不是软件本身。并且静态的源代码和运行的系统也不一样，软件运行环境的复杂性也增加了软件系统的不可预测性。软件系统不能以简单的方式描述出来，设计文档，描述说明，流程图，架构图这些也不过是让复杂的软件系统以更易于理解和易于交流的方式展示，却依旧不能完全描述系统的全貌。</p></li>\n <li>易变性（Changeability）<p>修改软件看似很容易，修改软件比修改硬件容易多了，修改软件系统也比修改一座巍立建筑物容易的多。所以人们自然地期待软件系统能够适应未来的变化。但变化却是复杂的，环境也是复杂的，这些复杂的情况往往让一个易于修改的事情却变成一件越来越困难的事情。</p></li>\n <li>服从性（Conformity）<p>软件系统不能独立存在，它总是运行在硬件上面，也总是要服从系统中其他组成部分的要求，也要服从用户的要求、行业的要求。</p></li>\n</ol>\n<p>软件系统的以上特性使得系统架构的设计显得尤其重要。系统架构设计通过以下方式来解决上面的软件难题：</p>\n<ul>\n <li>抽象<p>抽象是系统架构设计的重要一步。抽象是将复杂的概念简单化。在最高层次上，将软件系统抽象为<strong>对象</strong>和<strong>过程</strong>两个高层次概念。对象可以是系统、组件、接口、类、方法等等不同层次的概念，过程是系统运行的方式和流程。抽象使具象的事物概念化，从而确定边界，易于理解，易于交流。</p></li>\n <li>分解<p>分解与组合相互作用。分解就是将高层次的抽象概念分解成低层次的抽象概念，就是将实体分成小的部件或组成部分，<strong>在应对复杂度的诸多方式中，”分而治之“是一项基本策略，它把大问题持续分解成小问题，直到每一个小问题都能够解决为止。</strong></p></li>\n <li>语言<p>语言的边界就是世界的边界。领域语言、设计语言确定系统的<code>what</code>、<code>how</code>和<code>why</code>。语言使系统显见于文档，设计图等等易于理解的层次，也使得系统的易变性被规范在可预见和可控制的范围之中。</p></li>\n</ul>\n<h2>几种架构模式</h2>\n<h3>Client-Server</h3>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023800903\" alt=\"cs\" title=\"cs\" /></p>\n<p>有了互联网就有了 client-server 模式。client-server 模式以请求-响应方式工作，客户端发送请求信息，服务端接受请求，作出相应处理，然后发回响应信息。所有我们访问的互联网网站都是这种架构。在桌面程序流行的时代，互联网还没有当前这么发达的时代。Client-Server 还只代表 Desktop Client-Server 模式，使用浏览器的方式称之为 B-S 模式，即 Browser-Server 模式。如今 Browser、Desktop Application、Mobile Application、Mobile Web 等统称为 Client。</p>\n<p>因此我们当前访问的大部分网站，如新闻咨询网站、博客网站等等都属于这种模式。</p>\n<h3>Peer to Peer</h3>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023800905\" alt=\"p2p\" title=\"p2p\" /></p>\n<p>端对端服务模式（Peer to Peer，简称 P2P），亦称为“点对点模式”，是指通过互联网将个人与个人连接起来，绕开中心平台而直接提供服务、完成交易的模式。P2P 的早期含意是计算机通信领域中的“对等网络协议”，它打破了传统的 Client/Server(C/S)模式，使得成千上万台彼此连接的计算机都处于对等地位，网络的参与者直接共享他们所拥有的一部分硬件资源（包括处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过互联网，能被其它对等节点(Peer)直接访问而无需经过统一的中间体。在该网络中的参与者既是资源（服务或内容）提供者（Server），又是资源获取者（Client）。</p>\n<p>P2P 模式流行于文件分享与下载、计算与存储、即时通信和协同共享等领域。</p>\n<h3>MVC</h3>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023800904\" alt=\"mvc\" title=\"mvc\" /></p>\n<p>Model-View-Controller，MVC 架构是面向对象编程的一大进步。服务将逻辑划分为三个不同的组建：Model——模型，即数据，通常存储在数据库中，在内存中进行逻辑操作。View——用户可见的组建，用于用户交互和数据展示，如 Web GUI。Controller——逻辑操作，连接 Model 和 View 的组件，操作 Model 逻辑和 View 交互展示逻辑。</p>\n<p>MVC 模式在客户端和 H5 前端都比较流行。也一直是 Web 后端流行的架构模式，在 Java Web 领域催生的 Struts、Spring MVC 等 Web 后台框架，让曾经复杂的 Web 开发变成一种异常简单的开发。</p>\n<p>随着前后端渐渐分离，之前的后台 MVC 已经将 View 完全交于前端，前后端通过相关协议通信，完成 View 数据的传输。</p>\n<h3>Layered</h3>\n<p>分层架构是运用最为广泛的架构模式，几乎每个软件系统都需要通过层（Layer）来隔离不同的关注点（Concern Point），以此应对不同需求的变化，使得这种变化可以独立进行。</p>\n<p><strong>单一职责原则</strong>，是系统设计开发重要的原则。分层架构就时时遵循单一职责原则。不同的层次相互隔离，承担不同的职责。</p>\n<p>说起分层架构，最让人熟知的就是经典的三层架构。经典三层架构自顶向下由用户界面层（User Interface Layer）、业务逻辑层（Business Logic Layer）与数据访问层（Data Access Layer）组成。三层架构是简单 Client-Server 架构的升级。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023800907\" alt=\"three-layer\" title=\"three-layer\" /></p>\n<p>三层架构的经典和流行，以及大量 Web 后台框架对三层架构的靠近，使得 Web 后台开发简单到一个刚刚入门的开发人员就可以进行 web 开发。也正因为此，使得大部分 web 开发人员的思维受限于此，从而成为人人调侃的 CRUD-Boy。随着 MIS 系统时代的渐远，三层架构也开始在一些领域无法成为“银弹“。</p>\n<p>除去经典的三层架构。在领域驱动设计中，Eric Evans 设计了一种经典的四层架构，其在用户界面层与业务逻辑层之间引入了新的一层，即应用层（Application Layer）。其余几层也相应的有所调整。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023800906\" alt=\"ddd\" title=\"ddd\" /></p>\n<h3>Distribute-Cluster</h3>\n<p>之上所提的架构都是在单体架构之下。单体架构和多服务架构是从服务的部署模式、运行模式来考虑。</p>\n<p>单体架构有如下优势：</p>\n<ul>\n <li>易于开发：借助于开发框架，单体应用的开发及其简单，开发人员也很少需要考虑系统、部署、网络等层次的问题。</li>\n <li>易于测试：单体应用部署在一个进程中，环境简单。只要服务启动就可以测试所有的功能。</li>\n <li>易于部署：往往只需要将应用打包成一个简单的包就可。</li>\n <li>易于水平扩展：只需要将程序包部署多个服务即可。</li>\n</ul>\n<p>单体应用的劣势：</p>\n<ul>\n <li>维护成本增加：随着需求的增多，单体系统将越来越臃肿，维护的复杂性也将越来越大。</li>\n <li>持续交互周期长：一方面维护困难，另一方面单体应用在并行开发，并行测试上将十分困难，单体应用十分不适合快速迭代的敏捷开发。</li>\n <li>扩展性差：由于臃肿的系统，将导致系统扩展性变难。系统的升级也需要十分谨慎。</li>\n <li>对新人不友好。</li>\n</ul>\n<p>分布式系统拆分：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023800908\" alt=\"service-scale\" title=\"service-scale\" /></p>\n<p>随着互联网的快速发展，一方面互联网应用访问量级大增，数据量大增。另一方面，应用的迭代速度也不断变快。单体应用的模式已经不适合互联网的快速发展。这样，后台分布式集群架构越来越流行。</p>\n<h3>Micro-Service</h3>\n<p>微服务并没有一个严格的定义。以下是 Martin Fowler 描述的微服务：</p>\n<blockquote>\n 微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、相互配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常基于 HTTP 的 RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境。\n</blockquote>\n<p>微服务通常具有以下特性：</p>\n<ul>\n <li>单一职责：业务独立，团队自主。职责单一的服务应该具有核心的领域，高内聚、低耦合，与其他系统和领域确定明确的边界。</li>\n <li>轻量级通信：通信应该简单，轻量。与语言无关，与平台无关。</li>\n <li>独立性：独立开发，独立测试和独立部署。</li>\n</ul>\n<p><strong>一切选择都是权衡的过程</strong>。微服务解决了单体应用的许多问题，自然也会带来相应的问题。分布式和集群的环境是复杂的，基于此的微服务架构也将具有相应的复杂度。</p>\n<p>随着微服务的流行，微服务的很多问题也被越来越多的框架和服务解决掉了。我们以 Spring Cloud 技术栈为例：</p>\n<ul>\n <li>SpringBoot：单体服务，快速创建项目，快速集成各种框架，易于测试，易于部署。</li>\n <li>Feign：微服务独立部署，通过相关协议通信。Feign 就是一个简单的申明式通信框架，基于 HTTP restful。</li>\n <li>Eureka：独立服务越来越多，服务实例也越来越多。服务治理便是必须的，Eureka 提供高可用的服务注册和服务发现功能。</li>\n <li>Ribbon：Feign 只负责通信，Ribbon 提供客户端负载均衡，是系统优化的部分。</li>\n <li>Hystrix：微服务将带来服务间复杂的依赖关系，分布式和集群的复杂度也将带来许多难以预料的问题。为防止复杂网络和复杂系统某一点的问题导致整个系统的雪崩状态，便有了 Hystrix，Hystrix 是 Spring Cloud 体系中优秀的断路器，可以在系统发生问题时进行服务降级，防止整体系统崩溃。</li>\n <li>Zuul：统一网关，统一网关是以 Facade 模式，对外提供友好的接口，微服务化之后，服务将越来越多，越来越复杂，为了降低外部系统调用的复杂度，统一网关就是常用解决方案。</li>\n <li>Config：服务划分越多，配置将越多，Spring cloud config 提供统一的配置管理。</li>\n <li>Sleuth：服务监控和治理。监控是复杂系统必需的基础设施。系统感知、问题发现、性能定位都需要监控的加持。</li>\n</ul>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023800909\" alt=\"micro-service\" title=\"micro-service\" /></p>\n<h3>Even-Source</h3>\n<p>事件溯源是最新流行一种应用程序体系结构模式。事件源将应用程序进行的状态更改建模为事件的不可变序列或“日志”。事件源不是在现场修改应用程序的状态，而是将触发状态更改的事件存储在不可变的日志中，并将状态更改建模为对日志中事件的响应。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023800910\" alt=\"event-source\" title=\"event-source\" /></p>\n<p>CQRS 模式通常基事件溯源模式。在传统的体系结构中，使用同一数据模型查询和更新数据库。 这十分简单，非常适用于基本的 CRUD 操作。 但是，在更复杂的应用程序中，此方法会变得难以操作。 例如，在读取方面，应用程序可能执行大量不同的查询，返回具有不同形状的数据传输对象 (DTO)。 对象映射可能会变得复杂。 在写入方面，模型可能实施复杂验证和业务逻辑。 结果，模型执行太多操作，过度复杂。</p>\n<p>CQRS（命令查询的责任分离 Command Query Responsibility Segregation ）将读取和写入操作分成不同的模型，使用 <strong>命令</strong> 更新数据，并使用 <strong>查询</strong> 来读取数据。</p>\n<h3>Hexagonal</h3>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023800911\" alt=\"hexagonal\" title=\"hexagonal\" /></p>\n<p><a href=\"http://alistair.cockburn.us/Oops.aspx?aspxerrorpath=/Hexagonal+architecture\" rel=\"nofollow noreferrer\">六边形架构</a>又称“端口和适配器模式”，是 Alistair Cockburn 提出的一种具有对称性特征的架构风格。在这种架构中，系统通过适配器的方式与外部交互，将应用服务与领域服务封装在系统内部。</p>\n<p>六边形架构由以下三个组件组成：</p>\n<ul>\n <li>Ports：又可以分为输入端和输出端，是系统与其他系统交互的接口。</li>\n <li>Adapters：与其他系统的适配层，一方面防止核心系统和领域被外部影响，即防腐;另一方面方便 api 使用。</li>\n <li>Domain：应用和模型是程序的核心。</li>\n</ul>\n<p>六边形架构的核心理念是：应用通过\"端口\"跟外部进行交互。在传统的分层架构中很容易跨越层间的边界，把业务逻辑渗透到其它层中去。六边形架构重要的就是“边界”和“领域”。六边形架构的初衷是为了解决技术与业务系统的解耦合问题，以及技术与技术间的解耦合问题，这一架构从设计模式中来，从业务的实体服务出发，将面向接口的设计具体化的端口协议和适配器实现，服务自身实现独立性和完备性。</p>\n<p><strong>参考：</strong></p>\n<p>《系统架构——复杂系统的产品设计与开发》丹尼尔·塞尔瓦 <br>《构建之法——现代工程》邹欣 <br>《微服务架构与实现》王磊 <br>《领域驱动设计——软件核心复杂性应对之道》Eric Evans <br>《实现领域驱动设计》Vaughn Vernon <br>《Spring Cloud 微服务实战》翟永超 <br>《工程学——无尽的前沿》欧阳莹之 <br>《人月神话》Frederick P. Brooks, Jr.</br></br></br></br></br></br></br></p>\n<p><strong>关注 「码哥字节」后台回复加群，可添加个人微信进入专属技术群。</strong></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000022678951\" alt=\"码哥字节\" title=\"码哥字节\" /></p>\n<p>读者的分享、点赞、在看、收藏三连是最大的鼓励</p>","descriptionType":"html","publishedDate":"Fri, 28 Aug 2020 03:05:01 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023800902","linkMd5":"64bc9675c6ac1a4ac8b541d7e50d33a2","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn34@2020_5/2020/09/01/03-37-52-935_d18c0ad76604edca.webp","destWidth":800,"destHeight":600,"sourceBytes":159143,"destBytes":36220,"author":"码哥字节","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023800902":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn34@2020_5/2020/09/01/03-37-52-935_d18c0ad76604edca.webp","https://segmentfault.com/img/remote/1460000023800903":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn7@2020_6/2020/09/01/03-37-57-135_5e06ef97840859dc.webp","https://segmentfault.com/img/remote/1460000023800905":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn99@2020_5/2020/09/01/03-37-58-388_d76a533bf4a4d9e1.webp","https://segmentfault.com/img/remote/1460000023800904":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn3@2020_2/2020/09/01/03-37-57-836_2cacdf5262d99ea2.webp","https://segmentfault.com/img/remote/1460000023800907":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn91@2020_6/2020/09/01/03-37-58-467_be4b0fc8d17c8257.webp","https://segmentfault.com/img/remote/1460000023800906":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn95@2020_1/2020/09/01/03-37-59-025_f574f7576d5afcd2.webp","https://segmentfault.com/img/remote/1460000023800908":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn88@2020_2/2020/09/01/03-37-58-630_fc372fe7cee00b99.webp","https://segmentfault.com/img/remote/1460000023800909":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn83@2020_3/2020/09/01/03-37-58-085_6b90dfd595d34ec3.webp","https://segmentfault.com/img/remote/1460000023800910":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn76@2020_1/2020/09/01/03-37-58-486_851debfe07753166.webp","https://segmentfault.com/img/remote/1460000023800911":null,"https://segmentfault.com/img/remote/1460000022678951":null},"publishedOrCreatedDate":1598931423822},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"2020年中大厂前端面试总结","link":"https://segmentfault.com/a/1190000023783535","description":"<h2>前言</h2> \n<p>本次面试面试了很多家公司，包括 360，美团，猿辅导，小米，腾讯地图，头条，新东方，快手，知乎等几家公司，刚开始去面试的时候那段时间状态不是很好（基本每天都加班到很晚，周六日也没有休息的那种，而且当时心态真的是差到爆，很多平时自己很会的东西，被问到居然答不上来），基本一面就挂的那种（360，美团，猿辅导），越面越失望，后来就直接不面试了，调整自己的状态，请假休息，好好睡了两天两夜之后，调整自己的心态，开始准备面试，接下来的面试就顺利的很多。</p> \n<p>本篇面试题总结并没有按照公司那样分类而是按照知识点进行简单分类，很多面试题问的频率非常高，所以面试的时候如果第一次问完，没回答上来或者回答的不太好，一定要在面完的第一时间记录下来并且查找资料，否则就忘记了，或者之后再看就没有了当时迫切想知道具体答案的那种心情了（有迫切的想知道某些知识的心情的时候目标很明确，学东西也会印象深刻记得牢）。</p> \n<blockquote>\n  本文链接地址较多，建议查看原文，阅读体验会好一些。下面给出的答案有的是自己总结的，有的是从网上找到写的很不错的相关文章，但是这些都仅供参考，不一定是最佳的答案，如果有很好的答案，欢迎留言一起讨论互相学习，有的还没有放上合适的链接，之后会不算补充进去，毕竟每道题涉及到的内容真的挺多的。 \n</blockquote> \n<p>下面题目中标记有 <strong>【高频】</strong> 的至少被问过两次，标记有 <strong>【超高频】</strong> 的基本面试的每家公司都问到了。</p> \n<h2>笔试题</h2> \n<ol> \n <li><strong>【超高频】</strong> 写一个深拷贝，考虑 正则，Date这种类型的数据</li> \n <li><strong>【高频】</strong> Vue自定义指令懒加载</li> \n</ol> \n<ul> \n <li><a href=\"https://mp.weixin.qq.com/s/36oBZMd-m-2k5EKPghfG3A\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s/36oBZMd-m-2k5EKPghfG3A</a></li> \n</ul> \n<ol> \n <li>判断DOM标签的合法性，标签的闭合，span里面不能有div，写一个匹配DOM标签的正则</li> \n</ol> \n<ul> \n <li><a href=\"https://mp.weixin.qq.com/s/MtHUsWtGQ8k8mxl9oR8_xA\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s/MtHUsWtGQ8k8mxl9oR8_xA</a></li> \n</ul> \n<ol> \n <li>替换日期格式，xxxx-yy-zz 替换成 xxx-zz-yy</li> \n</ol> \n<p>可以使用 正则的捕获组来实现</p> \n<pre><code class=\"js\">var reg = /(\\d{2})\\.(\\d{2})\\/(\\d{4})/\nvar data = '10.24/2017'\ndata = data.replace(reg, '$3-$1-$2')\nconsole.log(data)//2017-10-24</code></pre> \n<ol> \n <li><strong>【高频】</strong> 实现Promise.all, Promise.allSettled</li> \n <li>获取一段DOM节点中标签个数最多的标签</li> \n</ol> \n<ul> \n <li><a href=\"https://mp.weixin.qq.com/s/MtHUsWtGQ8k8mxl9oR8_xA\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s/MtHUsWtGQ8k8mxl9oR8_xA</a></li> \n</ul> \n<ol> \n <li>写一个简单的diff</li> \n</ol> \n<ul> \n <li><a href=\"https://mp.weixin.qq.com/s/w2b9Wn7QWXhy2qf2JX3Kbw\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s/w2b9Wn7QWXhy2qf2JX3Kbw</a></li> \n</ul> \n<ol> \n <li><strong>【高频】</strong> 手写节流</li> \n</ol> \n<ul> \n <li><a href=\"https://mp.weixin.qq.com/s/fNrn94emmLMfuKN_Ukpi6A\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s/fNrn94emmLMfuKN_Ukpi6A</a></li> \n</ul> \n<ol> \n <li>手写ES6的继承</li> \n <li>实现一个自定义hook - usePrevious</li> \n</ol> \n<pre><code class=\"ts\">import { useRef } from 'react';\n\nexport type compareFunction&lt;T&gt; = (prev: T | undefined, next: T) =&gt; boolean;\n\nexport default &lt;T&gt;(state: T, compare?: compareFunction&lt;T&gt;): T | undefined =&gt; {\n  const prevRef = useRef&lt;T&gt;();\n  const curRef = useRef&lt;T&gt;();\n\n  const needUpdate = typeof compare === 'function' ? compare(curRef.current, state) : true;\n  if (needUpdate) {\n    prevRef.current = curRef.current;\n    curRef.current = state;\n  }\n\n  return prevRef.current;\n};</code></pre> \n<blockquote>\n  更多自定义hook的写法可以参考 \n <a href=\"https://github.com/alibaba/hooks\" rel=\"nofollow noreferrer\">hooks</a> \n</blockquote> \n<ol> \n <li><strong>【高频】</strong> 实现一个vue的双向绑定</li> \n</ol> \n<blockquote>\n  其他题目的答案之前做了整理，可以在 \n <a href=\"https://wangyaxing.cn/blog/jsCode/\" rel=\"nofollow noreferrer\">前端学习总结-手写代码系列</a>中看到 \n</blockquote> \n<h3>笔试题中的算法题</h3> \n<ol> \n <li>二叉树的最大深度</li> \n</ol> \n<ul> \n <li><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\" rel=\"nofollow noreferrer\">原题地址</a></li> \n</ul> \n<ol> \n <li>另一个树的子树</li> \n</ol> \n<ul> \n <li><a href=\"https://leetcode-cn.com/problems/subtree-of-another-tree/\" rel=\"nofollow noreferrer\">原题地址</a></li> \n</ul> \n<ol> \n <li>相同的树</li> \n</ol> \n<ul> \n <li><a href=\"https://leetcode-cn.com/problems/same-tree/\" rel=\"nofollow noreferrer\">原题地址</a></li> \n</ul> \n<ol> \n <li>翻转二叉树</li> \n</ol> \n<ul> \n <li><a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\" rel=\"nofollow noreferrer\">原题地址</a></li> \n</ul> \n<ol> \n <li><strong>【高频】</strong> 斐波那契数列</li> \n</ol> \n<ul> \n <li><a href=\"https://leetcode-cn.com/problems/fibonacci-number/\" rel=\"nofollow noreferrer\">原题地址</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s/LvJiAO9O6Vh7TwZLbVr_PA\" rel=\"nofollow noreferrer\">相关题解</a></li> \n</ul> \n<ol> \n <li><strong>【高频】</strong> 合并两个有序数组</li> \n</ol> \n<ul> \n <li><a href=\"https://leetcode-cn.com/problems/merge-sorted-array/\" rel=\"nofollow noreferrer\">原题地址</a></li> \n</ul> \n<ol> \n <li><strong>【高频】</strong> 打乱数组</li> \n</ol> \n<ul> \n <li><a href=\"https://leetcode-cn.com/problems/shuffle-an-array/\" rel=\"nofollow noreferrer\">原题地址</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s/1XW1bL4Wa8NBBg5Jx0D7GA\" rel=\"nofollow noreferrer\">相关题解</a></li> \n</ul> \n<ol> \n <li>数组区间</li> \n</ol> \n<h2>webpack 和babel相关的问题</h2> \n<ol> \n <li>babel的缓存是怎么实现的</li> \n <li><p>webapck的HMR，怎么配置：</p> \n  <ul> \n   <li>浏览器是如何更新的</li> \n   <li>如何做到页面不刷新也就就自动更新的</li> \n   <li>webpack-dev-server webapck-dev-middleware</li> \n  </ul></li> \n</ol> \n<blockquote>\n  相关文章： \n <a href=\"https://github.com/Jocs/jocs.github.io/issues/15\" rel=\"nofollow noreferrer\">Webpack Hot Module Replacement 的原理解析</a> \n</blockquote> \n<ol> \n <li>自己有没有写过ast, webpack通过什么把公共的部分抽出来的，属性配置是什么</li> \n <li>webpack怎么配置mock转发代理，mock的服务，怎么拦截转换的</li> \n <li>webapck的plugin和loader的编写， webapck plugin和loader的顺序</li> \n <li>webpack的打包构建优化，体积和速度</li> \n <li>DLLPlugin原理，为什么不直接使用压缩版本的js</li> \n</ol> \n<h2>HTTP</h2> \n<ol> \n <li><strong>【超高频】</strong> 缓存（强缓存），如何设置缓存</li> \n</ol> \n<ul> \n <li><a href=\"https://juejin.im/post/6844904153043435533\" rel=\"nofollow noreferrer\">图解 HTTP 缓存</a></li> \n <li><a href=\"https://juejin.im/post/6844903757872889870\" rel=\"nofollow noreferrer\">深入浅出浏览器缓存机制</a></li> \n</ul> \n<ol> \n <li><strong>【高频】</strong> HTTP2， HTTP2的性能优化方面，真的优化很多么?</li> \n <li><strong>【高频】</strong> 简单请求和复杂请求</li> \n</ol> \n<ul> \n <li><a href=\"https://www.ruanyifeng.com/blog/2016/04/cors.html\" rel=\"nofollow noreferrer\">阮一峰-跨域资源共享 CORS 详解</a></li> \n <li><a href=\"https://juejin.im/post/6844903873400799240\" rel=\"nofollow noreferrer\">CORS原理及@koa/cors源码解析</a></li> \n</ul> \n<ol> \n <li><strong>【高频】</strong> HTTPS的整个详细过程</li> \n</ol> \n<ul> \n <li><a href=\"https://juejin.im/post/6847902222764736520\" rel=\"nofollow noreferrer\">HTTPS是如何保证安全的</a></li> \n <li><a href=\"https://juejin.im/post/6844903830916694030\" rel=\"nofollow noreferrer\">深入理解HTTPS工作原理</a></li> \n</ul> \n<ol> \n <li>301和302的区别</li> \n</ol> \n<ul> \n <li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\" rel=\"nofollow noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></li> \n</ul> \n<ol> \n <li>怎么用get实现post，就是使用get方法但是参数放到request body中</li> \n <li>TCP和UDP的区别</li> \n</ol> \n<ul> \n <li><a href=\"https://juejin.im/post/6844903800336023560\" rel=\"nofollow noreferrer\">TCP和UDP比较</a></li> \n <li><a href=\"https://zhuanlan.zhihu.com/p/24860273\" rel=\"nofollow noreferrer\">TCP和UDP的区别</a></li> \n</ul> \n<blockquote>\n  更多可以查看 \n <a href=\"https://github.com/funnycoderstar/blog/issues/127\" rel=\"nofollow noreferrer\">【面试题】HTTP知识点整理(附答案) </a> \n</blockquote> \n<h2>CSS</h2> \n<ol> \n <li><p><strong>【超高频】</strong> flex相关的问题</p> \n  <ul> \n   <li>说一下flex</li> \n   <li>flex: 1具体代表什么, 有什么应用场景</li> \n   <li>flex-basic 是什么含义</li> \n  </ul></li> \n</ol> \n<p>相关文章：<a href=\"https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" rel=\"nofollow noreferrer\">Flex 布局教程：语法篇</a></p> \n<ol> \n <li>css var 自定义变量的兼容性</li> \n <li>行内元素和块级元素的区别</li> \n <li>position有哪些值，分别是什么含义</li> \n <li>盒模型</li> \n <li><p>CSS的实现</p> \n  <ul> \n   <li>淘宝购物车添加商品到购物车的动画（<a href=\"https://www.zhangxinxu.com/wordpress/2018/08/css-css3-%e6%8a%9b%e7%89%a9%e7%ba%bf%e5%8a%a8%e7%94%bb/\" rel=\"nofollow noreferrer\">这回试试使用CSS实现抛物线运动效果</a>）</li> \n   <li>toolTip的实现 (<a href=\"https://www.jianshu.com/p/fdfa8058a015)\" rel=\"nofollow noreferrer\">https://www.jianshu.com/p/fdf...</a></li> \n  </ul></li> \n <li><strong>【高频】</strong> 实现固定宽高比(width: height = 4: 3)的div，怎么设置</li> \n <li><strong>【高频】</strong> 伪类和伪元素</li> \n</ol> \n<blockquote>\n  更多可以查看 \n <a href=\"https://juejin.im/post/6844904117819850765\" rel=\"nofollow noreferrer\">【面试题】CSS知识点整理(附答案)</a> \n</blockquote> \n<h2>JavaScript</h2> \n<ol> \n <li>单例的应用</li> \n <li><strong>【超高频】</strong> 什么是闭包，闭包的应用场景</li> \n</ol> \n<ul> \n <li><a href=\"https://segmentfault.com/a/1190000023356598\">深入理解JavaScript闭包之什么是闭包</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000023425946\">深入理解JavaScript闭包之闭包的使用场景</a></li> \n</ul> \n<ol> \n <li>如何判断 当前浏览器是否支持webp</li> \n <li>proxy除了拦截它的getter和setter外，还能做什么</li> \n <li>同步阻塞，异步非阻塞</li> \n <li>弱引用，WeakMap和Map的区别</li> \n <li><strong>【高频】</strong> 安全相关 XSS的反射型是什么，怎么避免</li> \n</ol> \n<ul> \n <li><a href=\"https://juejin.im/post/6844904179182354439\" rel=\"nofollow noreferrer\">web安全之XSS实例解析</a></li> \n <li><a href=\"https://juejin.im/post/6844904180918779918\" rel=\"nofollow noreferrer\">Web安全之CSRF实例解析</a></li> \n</ul> \n<ol> \n <li><strong>【超高频】</strong> 事件循环</li> \n</ol> \n<ul> \n <li><a href=\"https://segmentfault.com/a/1190000022805523\">JavaScript中的Event Loop（事件循环）机制</a></li> \n</ul> \n<ol> \n <li><strong>【超高频】</strong> promise相关的问题， 说一下你对Promise的了解</li> \n</ol> \n<ul> \n <li><a href=\"https://es6.ruanyifeng.com/#docs/promise\" rel=\"nofollow noreferrer\">ECMAScript 6 入门之Promise对象</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000023783535#\">手写一个Promose</a></li> \n</ul> \n<ol> \n <li><strong>【超高频】</strong> 浏览器渲染（从输入url到页面渲染的完成过程）</li> \n <li><strong>【超高频】</strong> 首屏加载优化， 通过哪些指标去衡量性能优化的</li> \n <li>canvas和svg分别是干什么的</li> \n</ol> \n<ul> \n <li><a href=\"https://www.zhihu.com/question/19690014\" rel=\"nofollow noreferrer\">SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？</a></li> \n</ul> \n<ol> \n <li>牛客网如何监听你调到了其他页面</li> \n</ol> \n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/hidden\" rel=\"nofollow noreferrer\"><code>document.hidden</code></a>，监听 <code>docuemnt.vibibleChange</code>事件</p> \n<pre><code class=\"js\">document.addEventListener(\"visibilitychange\", function() {\n  console.log( document.hidden );\n});</code></pre> \n<ol> \n <li>JS原生3种绑定事件</li> \n</ol> \n<pre><code class=\"js\">// 1. 在标签中直接绑定\n&lt;button onclick=\"handleClick()\" &gt;自定义函数&lt;/button&gt;\n\n// 2. 在js事件中获取dom事件绑定\n\n&lt;button id=\"btn\" onclick=\"handleClick()\" &gt;dom事件绑定&lt;/button&gt;\ndocument.getElementById('btn').onclick=handleClick();\n\n// 3. 事件监听addEventListener\nelementDOM.addEventListener(eventName,handle,useCapture);</code></pre> \n<ol> \n <li>简单说一下你对 websocket 了解多少？</li> \n</ol> \n<ul> \n <li><a href=\"https://www.zhihu.com/question/20215561\" rel=\"nofollow noreferrer\">WebSocket 是什么原理？为什么可以实现持久连接？</a></li> \n</ul> \n<ol> \n <li>实现复杂数据(去重元素是对象，数组)的数组去重 (* 3)</li> \n <li>基本数据类型有哪些， 为什么symbol是一个函数， BigInt为什么可以用来存储大整数</li> \n <li>什么是依赖注入</li> \n <li><p>JS类型转换</p> \n  <ul> \n   <li><code>String([])</code> 为 <code>’‘</code>， <code>String({})</code>结果是什么什么? 答案是：<code>'[object object]'</code></li> \n   <li>其他一些很经典的类型转换考察，当时没记那么清楚，大家可以去网上看一下</li> \n  </ul></li> \n <li>富文本编辑器相关的js知识</li> \n</ol> \n<ul> \n <li><a href=\"https://juejin.im/post/6844903871110709256\" rel=\"nofollow noreferrer\">富文本原理了解一下？</a></li> \n <li><a href=\"https://juejin.im/post/6844903555900375048\" rel=\"nofollow noreferrer\">富文本编辑器初探</a></li> \n <li><a href=\"https://zhuanlan.zhihu.com/p/90931631\" rel=\"nofollow noreferrer\">编辑器初体验</a></li> \n</ul> \n<ol> \n <li>cli工具的一些实现逻辑</li> \n</ol> \n<h2>Vue</h2> \n<ol> \n <li><strong>【高频】</strong> vue3.0的新特性，了解compose api和react hooks的区别</li> \n <li>new Vue做了什么</li> \n <li>双向绑定原理</li> \n <li>vue组件通信方法</li> \n</ol> \n<h2>React</h2> \n<ol> \n <li><strong>【高频】</strong> React hooks 相关的问题</li> \n</ol> \n<ul> \n <li>为什么引入，什么原理</li> \n <li>hooks如何监听响应的，内部是如何做到只有数据修改的时候才执行函数</li> \n <li>依赖的值发生变化，需要不停地监听和绑定事件</li> \n <li>render props 和HOC相比的优缺点</li> \n <li>和mixin，hoc区别在哪儿</li> \n</ul> \n<ol> \n <li>创建ref的几种方法</li> \n <li>context怎么使用，内部原理怎么做到的</li> \n <li><strong>【超高频】</strong> React新的生命周期，为什么 getDrivedStatefromProps是静态的</li> \n <li>react中TS的声明</li> \n <li>redux相关的问题</li> \n</ol> \n<ul> \n <li>redux使用方法，为什么action要返回一个函数，返回一个对象可以么</li> \n <li>state为什么要设计成不可变的</li> \n</ul> \n<blockquote>\n  相关文章 \n <a href=\"https://juejin.im/post/5c1b6925e51d455ac91d6bac\" rel=\"nofollow noreferrer\">为什么redux要返回一个新的state引发的血案</a>， \n <a href=\"http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html\" rel=\"nofollow noreferrer\">阮一峰-Redux 入门教程（一）：基本用法</a> \n</blockquote> \n<ol> \n <li><strong>【高频】</strong> diff算法</li> \n <li><strong>【高频】</strong> key的作用</li> \n <li>immer和imutable的区别</li> \n <li><strong>【高频】</strong> react性能优化, fiber架构</li> \n</ol> \n<blockquote>\n  更多可以查看 \n <a href=\"https://github.com/funnycoderstar/blog/issues/129\" rel=\"nofollow noreferrer\">【面试题】React知识点整理(附答案)</a> \n</blockquote> \n<h2>面试结果</h2> \n<p>大概说一下本人的大概情况，本科三年左右工作经验，非计算机专业，大三下学习决定转行学习前端，过程反正挺艰辛的，一直到现在还在恶补计算机的一些知识。毕业半年左右，一个偶然的机会，进入阿里文娱（哈哈，当时面试的时候也写过面经，感兴趣的可以看一下 当时写的面经 <a href=\"https://wangyaxing.cn/blog/interview/%E9%9D%A2%E7%BB%8F/2017.html#_2017%E9%9D%A2%E6%9C%AB%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93\" rel=\"nofollow noreferrer\">2017面末面试总结</a>），现在因为个人原因，决定考虑新的机会。</p> \n<p>面试差不多最开始是中3月中旬开始准备的，中间停了差不多小一个月又开始重新面试的，到最后拿到offer差不多5月底左右，历时近3个月吧，最近抽时间把这些题目总结了一下，算是给自己一个交代吧，上面很多题目自己回答的其实很多都不是很全面，标有 <strong>【高频】</strong> 及 <strong>【超高频】</strong> 刚开始回答的不好，后来认真学习总结了一下，之后再被问到，基本都回答得差不多</p> \n<p>一般提到面试，肯定都会想问一下面试结果，我就大概的说一下面试结果，哈哈，其实不太想说，因为挺惨的，并没有像很多大佬一样“已拿字节阿里腾讯各大厂offer”，但是毕竟是自己的经历，无论结果如何都要坦然接受，之前没好好学习，那之后多学习就是。360，美团，猿辅导最开始的一面挂，小米二面的时候面试官告知说要求招5年以上工作经验的，所以就直接告知不符合（哈哈，可能就是跟小米没有缘分吧，刚毕业的时候面试，终面被拒说要3年以上工作经验的，现在够3年工作经验了，却又要求5年工作年限），腾讯地图和头条都是hr直接找过来的，自己并没有投递，就顺便面了一下，二面面完之后，以为挂了，后来过了一周多（可能是作为备胎把），又打电话过来约面试，其实之前面试大概了解了一下部门相关的情况，感觉不是自己想去的，并不是说部门不好，可能做的事情跟现在的情况太像了，所以想做出一些改变。当时家里面又有好多事情处理，也没有太多的时间，就直接拒绝了，这件事儿也给自己以后提个醒，投简历之前要先想明白自己想要什么样的，可以列一些目标，而不是因为急于找工作，猎头和hr直接打电话过来就直接面试。</p> \n<h2>心得</h2> \n<h3>面试公司的选择</h3> \n<p>本次面试有几家公司（腾讯地图，头条，360教育，新东方等）全部都是猎头和hr直接打电话过来让面试的，当时就抱着试试的态度，就直接面试了，面试的过程中感觉可能都不太合适（所以面试的时候要问一下公司部门的具体工作内容），换工作的时候尽量找相关部门的人内推，首先内推的部门你肯定会提前有所了解，而且还可以帮忙看看进度啥的，面试过了说不定还能成为好朋友，哈哈（所以平时要多结交一些大佬，一般大佬的人脉都很广泛，而且他们很可以给你内推，甚至可以把他们自己的经验分享给你）。</p> \n<p>总是要想好自己现在出现什么问题了，为什么打算离职，下一份工作想要什么样儿的，毕竟一份工作要干很长时间。</p> \n<h3>面试准备</h3> \n<p>推荐一些很好的文章：</p> \n<ul> \n <li><a href=\"https://juejin.im/post/6844904093425598471\" rel=\"nofollow noreferrer\">在阿里我是如何当面试官的</a></li> \n <li><a href=\"https://juejin.im/post/6844904097556987917\" rel=\"nofollow noreferrer\">阿里前端攻城狮们写了一份前端面试题答案，请查收</a></li> \n <li><a href=\"https://juejin.im/post/6844904031735775245\" rel=\"nofollow noreferrer\">大厂面试中遇到的几十道 webpack 与 react 面试题</a></li> \n <li><a href=\"https://juejin.im/post/6844903703917363207\" rel=\"nofollow noreferrer\">三年前端，面试思考（头条蚂蚁美团offer）</a></li> \n <li><a href=\"https://juejin.im/post/6844904154675183623\" rel=\"nofollow noreferrer\">大厂面试复盘(微信/阿里/头条，均拿offer)</a></li> \n <li><a href=\"https://juejin.im/post/6844904151369908232\" rel=\"nofollow noreferrer\">霖呆呆的近期面试128题汇总</a></li> \n <li><a href=\"https://juejin.im/post/6844904112568401933\" rel=\"nofollow noreferrer\">一年半，三本，收到30K+的offer，你也可以</a></li> \n <li><a href=\"https://juejin.im/post/6844904161830502407\" rel=\"nofollow noreferrer\">蚂蚁、字节、滴滴面试经历总结</a></li> \n <li><a href=\"https://juejin.im/post/6844904137495150599\" rel=\"nofollow noreferrer\">一年半经验前端社招7家大厂&amp;独角兽全过经历 | 掘金技术征文</a></li> \n</ul> \n<p>好文章真的太多了，哈哈，这里就不全部放出来了，关于面试，我也准备做了一些总结，可以查看 <a href=\"https://github.com/funnycoderstar/blog\" rel=\"nofollow noreferrer\">个人博客</a></p> \n<h3>算法</h3> \n<p>基本每家公司多多少少都会问很多算法题，算法题对于我这种基本没什么基础的人来说，碰到了就很恐惧，但是没有其他的办法，就是两个字 “多练”，这里推荐我看过的几篇文章：</p> \n<ul> \n <li><a href=\"https://mp.weixin.qq.com/s/QvXIDpyrpiOmvEhcOUUmxQ\" rel=\"nofollow noreferrer\">天生不聪明</a></li> \n <li><a href=\"https://juejin.im/post/5f05087cf265da22d466f60f\" rel=\"nofollow noreferrer\">写给前端的算法进阶指南，我是如何两个月零基础刷200题</a>：</li> \n <li><a href=\"https://juejin.im/post/5d5b307b5188253da24d3cd1\" rel=\"nofollow noreferrer\">前端该如何准备数据结构和算法？</a></li> \n <li><a href=\"https://juejin.im/post/5ed32e0151882542fd351696\" rel=\"nofollow noreferrer\">前端算法渣的救赎之路</a></li> \n <li><a href=\"https://juejin.im/post/5958bac35188250d892f5c91\" rel=\"nofollow noreferrer\">我接触过的前端数据结构与算法</a></li> \n <li><a href=\"https://www.bruceyj.com/front-end-interview-summary/front-end/front-end-thinking/1-how-to-get-in-leetcode-contest.html\" rel=\"nofollow noreferrer\">作为前端，我是如何在Leetcode 算法比赛中进入前100的？</a></li> \n <li><a href=\"https://www.cxyxiaowu.com/10830.html\" rel=\"nofollow noreferrer\">LeetCode 按照怎样的顺序来刷题比较好？</a></li> \n</ul> \n<p>其他的一些想法，之前也写了一篇文章 <a href=\"https://mp.weixin.qq.com/s/5D7vi6WZOGfv3guBWhvOcg\" rel=\"nofollow noreferrer\">关于面试的一点心得</a>，感兴趣的也可以看一下。也非常欢迎大家关注我的公众号 【牧码的星星】以及加我微信进行交流，公众号也会偶尔分享一些学习的一些心得。</p> \n<p><img src=\"https://segmentfault.com/img/remote/1460000023222841\" alt=\"\" title=\"\" /></p>","descriptionType":"html","publishedDate":"Thu, 27 Aug 2020 01:46:04 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023222841","linkMd5":"c7060f2797d69d7b9c52c8e7904d4c4b","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn30@2020_3/2020/09/01/03-37-53-696_78af2b780400053b.webp","destWidth":420,"destHeight":153,"sourceBytes":39242,"destBytes":10100,"author":"木子星兮","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023222841":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn30@2020_3/2020/09/01/03-37-53-696_78af2b780400053b.webp"},"publishedOrCreatedDate":1598931423824},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"揭开数组的真面目","link":"https://segmentfault.com/a/1190000023816361","description":"<p>数组做为一种基础的数据存储结构，应用十分广泛。数组是用<strong>连续</strong>的内存空间来存储<strong>固定长度</strong>的、<strong>相同数据类型</strong>的一种数据结构。数据结构是跟语言无关的，这里，使用java来进行数组的相关操作。数组的索引是从0开始的。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023816365\" alt=\"\" title=\"\" /></p>\n<h2>一 数组初始化</h2>\n<p>创建数据有两种方式，一种是先声明一个固定长度的数据，然后再给数组赋值，另一种是直接赋值。</p>\n<p><strong>第一种</strong>：</p>\n<pre><code class=\"java\">数据类型[] 数组名称 = new 数据类型[长度];</code></pre>\n<p>这里的[]标识这声明了一个数组，这个[]除了可以放在数据类型后面，也可以放在数组名词后面，效果一样。假如我申明一个长度为<code>2</code>的<code>long</code>类型的数组，并赋值：</p>\n<pre><code class=\"java\">long[] arr = new long[2];\narr[0] = 1;\narr[1] = 2;</code></pre>\n<p><strong>第二种</strong>：</p>\n<pre><code class=\"java\">数据类型[] 数组名称 = {元素1,元素2, ...};</code></pre>\n<p>这样在数组初始化的时候直接给数组赋值，数组的长度由元素的个数决定。</p>\n<h2>二 自定义类封装数组实现数据操作</h2>\n<pre><code class=\"java\">public class MyArray {\n    \n    // 自定义数组\n    private long[] arr;\n    // 有效数据长度\n    private int element;\n\n    public MyArray(){\n        arr = new long[9];\n    }\n\n    public MyArray(int maxsize){\n        arr = new long[maxsize];\n    }\n    /**\n     * 显示数组元素\n     */\n    public void display(){\n        System.out.print(\"[\");\n        for (int i = 0; i &lt; element; i++) {\n            System.out.print(arr[i]+\" \");\n        }\n        System.out.print(\"]\");\n    }\n}</code></pre>\n<h3>2.1 添加元素</h3>\n<p>数组是用连续的内存空间来存储数据的，则每次添加的时候会往当前数组的最后一个元素上添加元素，一次就可以加上元素，所以它的复杂度为O(1)，假如定义一个长度为<code>9</code>数组，数组中已经有两个元素，则添加第三个元素如下：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023816364\" alt=\"\" title=\"\" /></p>\n<pre><code class=\"java\">public void add(long value){\n    arr[element] = value;\n    element++;\n}</code></pre>\n<h3>2.2 根据值查询元素位置</h3>\n<p>这种查找方式也叫做线性查找，就是根据传入的值循环去遍历元素，来获取对应的位置，理论上平均查询一个元素需要花费N/2次，所以它的复杂度为O(N)。</p>\n<pre><code class=\"java\">public int find(long value){\n    int i;\n    for (i = 0; i &lt; element; i++) {\n        if(value == arr[i]){\n            break;\n        }\n    }\n    if(i == element){\n        return -1;\n    }else {\n        return i;\n    }\n}</code></pre>\n<h3>2.3 根据索引查询元素</h3>\n<p>根据索引来查找元素，也就是获取对应位置的元素，其复杂度为O(1)。</p>\n<pre><code class=\"java\">public long get(int index){\n    if(index &gt;= element || index &lt; 0){\n        throw new ArrayIndexOutOfBoundsException();\n    }else {\n        return arr[index];\n    }\n}</code></pre>\n<h3>2.4 根据索引删除元素</h3>\n<p>删除对应索引的元素后，我们需要将所有改索引后面的元素，向前移动一位。假如我要删除索引为2的元素，如下：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023816367\" alt=\"\" title=\"\" /></p>\n<p>理论上平均删除一个元素，我们需要移动N/2次，所以它复杂度也为O(N)。</p>\n<pre><code class=\"java\">public void delete(int index){\n    if(index &gt;= element || index &lt; 0){\n        throw new ArrayIndexOutOfBoundsException();\n    }else {\n        for (int i = index; i &lt; element; i++) {\n            arr[index] = arr[index+1];\n        }\n        element --;\n    }\n}</code></pre>\n<h3>2.5 修改元素</h3>\n<p>修改某个位置的元素，直接根据索引就一次就可以修改对应的元素，所以它的复杂度为O(1)。</p>\n<pre><code class=\"java\">public void change(int index,long newValue){\n    if(index &gt;= element || index &lt; 0){\n        throw new ArrayIndexOutOfBoundsException();\n    }else {\n        arr[index] = newValue;\n    }\n}</code></pre>\n<h2>三 有序数组</h2>\n<p>有序数组是数组的一种特殊类型，有序数组中的元素按照某种顺序进行排列。</p>\n<h3>3.1 添加元素</h3>\n<p>在添加元素的时候，将元素按顺序添加到某个位置。如下，在一个数组中添加一个<code>33</code>的元素。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023816366\" alt=\"\" title=\"\" /></p>\n<p>首先，将索引为3的元素移动到索引为4的位置，然后将索引为2的元素移动到索引为3的位置，最后将33添加到索引为2的位置。理论上插入一个元素需要移动元素的个数为N/2个，所以它的复杂度为O(N)。</p>\n<pre><code class=\"java\">public void add(long value){\n    int i;\n    for (i = 0; i &lt; element; i++) {\n        if(arr[i]&gt;value){\n            break;\n        }\n    }\n\n    for (int j = element; j &gt; i; j--){\n        arr[j] = arr[j-1];\n    }\n    arr[i] = value;\n    element++;\n}</code></pre>\n<h3>3.2 二分法根据元素查询索引</h3>\n<p>在无序数组中，使用线性法进行查找相关元素，线性法即按索引按个查找。有序数组可以使用二分法来查找元素，二分发是指将一个数组从中间分成两个，判断元素位于哪个数组中，然后重复这样的操作。</p>\n<p>假如有<code>8</code>个元素的一个数组，数组内容为有序的0-7的序列，要查找5这个元素，第一次分成0-3和4-7两个数组，然后再将4-7分成4-5和6-7连个数组，最后再将4-5分成4和5就查询出来具体的元素了，这样分割3次就可以查询出长度为8的数组中具体的元素，其复杂度即为O(logN)（logN在计算机中底数一般指的是2，意思为2的几次方等于n）。</p>\n<pre><code class=\"java\">public int search(long value){\n    // 中间值\n    int middle = 0;\n    // 最小值\n    int low = 0;\n    // 最大值\n    int pow = element;\n    while (true){\n        middle = (low + pow) / 2;\n        if(arr[middle] == value){\n            return middle;\n        }else if (low &gt; pow){\n            return -1;\n        }else{\n            if(arr[middle] &gt; value){\n                pow = middle - 1;\n            }else{\n                low = middle + 1;\n            }\n        }\n    }\n}</code></pre>\n<h2>四 总结</h2>\n<p>复杂度越低意味着算法更加优秀，所以O(1) &gt; O(logN) &gt; O(N) &gt; O(N^2)。</p>\n<table>\n <thead>\n  <tr>\n   <th>算法</th>\n   <th>复杂度</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <td>线性查找</td>\n   <td>O(N)</td>\n  </tr>\n  <tr>\n   <td>二分法查找</td>\n   <td>O(logN)</td>\n  </tr>\n  <tr>\n   <td>无序数组插入</td>\n   <td>O(1)</td>\n  </tr>\n  <tr>\n   <td>有序数组插入</td>\n   <td>O(N)</td>\n  </tr>\n  <tr>\n   <td>无序数组删除</td>\n   <td>O(N)</td>\n  </tr>\n  <tr>\n   <td>有序数组删除</td>\n   <td>O(N)</td>\n  </tr>\n </tbody>\n</table>\n<ol>\n <li>无序数组插入快，查找和删除慢</li>\n <li>有序数组查找快，插入和删除慢</li>\n</ol>\n<h2>关注我、不迷路</h2>\n<p>如果觉得文章不错，欢迎<strong>关注</strong>、<strong>点赞</strong>、<strong>收藏</strong>，你们的支持是我创作的动力，感谢大家。</p>\n<p>如果文章写的有问题，请不要吝啬，欢迎留言指出，我会及时核查修改。</p>\n<p>如果你还想更加深入的了解我，可以微信搜索「<strong>Java旅途</strong>」进行关注。回复「<strong>1024</strong>」即可获得学习视频及精美电子书。每天7:30准时推送技术文章，让你的上班路不在孤独，而且每月还有送书活动，助你提升硬实力！</p>","descriptionType":"html","publishedDate":"Sat, 29 Aug 2020 07:04:31 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023816365","linkMd5":"e505db913e7db589be14dae583b6857f","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx/cdn45@2020_3/2020/09/01/03-37-53-775_e98d7572e3ba7b1d.webp","destWidth":446,"destHeight":130,"sourceBytes":3831,"destBytes":5068,"author":"Java旅途","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023816365":"https://cdn.jsdelivr.net/gh/myreaderx/cdn45@2020_3/2020/09/01/03-37-53-775_e98d7572e3ba7b1d.webp","https://segmentfault.com/img/remote/1460000023816364":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn5@2020_6/2020/09/01/03-38-01-977_c2e482d914b8eb8c.webp","https://segmentfault.com/img/remote/1460000023816367":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn13@2020_4/2020/09/01/03-38-02-822_79954f784a546609.webp","https://segmentfault.com/img/remote/1460000023816366":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn10@2020_4/2020/09/01/03-38-03-428_a7565d0037293afc.webp"},"publishedOrCreatedDate":1598931423821},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"想了解一个异地多校平台的架构演进过程吗？ 让我来告诉你！","link":"https://segmentfault.com/a/1190000023812011","description":"<p>一、背景</p>\n<p><strong>项目介绍</strong></p>\n<p><strong>励步双师课堂是以录播视频和线下中教老师结合的 AI 智能化面授教学课程。课堂中有三个角色：</strong></p>\n<ul>\n <li>主播老师: 视频哈佛外教老师，带着小朋友进行英文知识点的教学。主要承载“教”的职能。</li>\n <li>主教老师: 主要负责引导，陪伴，激励小朋友，组织课堂纪律，关注小朋友上课的情况，和家长进行一对一沟通等等。主要承载“育”的职能。</li>\n <li>学生: 上课小朋友，2-8 岁。</li>\n</ul>\n<p>目前整体的教学组织架构是以深圳研发中心示范班+加盟校区的方式进行教学研发、培训、常规授课。通常新功能会先预发布到深圳示范班预授，稳定后才会发布到其他加盟校区。这样既能保证其他加盟校区稳定教学、又能快速迭代新功能。以下一个简化的组织架构图。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023812015\" alt=\"\" title=\"\"> </img></p>\n<p>上文已经提到双师课堂是以录播的形式进行教学，必然需要课件视频。其中课件视频会经历几个流程：录制、上传、打点、审核、教学使用。早期起步阶段只有深圳研发中示范班授课，因此课件视频存储在本地机房，在同一内网下能正常使用。随着产品逐渐打磨成形，必然要落地到加盟校区使用。可是一个迫切要解决的问题摆在我们面前：加盟校区如何获取课件视频？</p>\n<p>要解决的几个问题：</p>\n<ol>\n <li>一个课件视频的容量比较大: <strong>1-2G</strong>, 一节课的课件视频总和:&nbsp;<strong>2-3G</strong>。研发中心的教研人员如何快速上传课件视频和预览课件视频，并且支持加盟校区主播端播放线上课件视频</li>\n <li>加盟校区外网环境不稳定的情况下，如何保证课件视频流畅地播放.</li>\n <li>如何在研发中心示范班和加盟校区间针对课件视频做灰度发布和A/B测试</li>\n</ol>\n<p>在这样背景下，蒲公英发布平台在内部开始推进。总得来说大概经历3个阶段:</p>\n<ul>\n <li>阶段1: 课件视频从 “研发中心本地机房” =&gt; “云端OSS”</li>\n <li>阶段2: 课件视频从&nbsp;“研发中心本地机房” =&gt; “云端OSS” =&gt;&nbsp;“校区机房”</li>\n <li>阶段3:&nbsp;教学资源从&nbsp;“研发中心本地机房” =&gt; “云端OSS” =&gt; “发布平台(管理)” =&gt;&nbsp;“校区机房”</li>\n</ul>\n<p>&nbsp;<img src=\"https://segmentfault.com/img/remote/1460000023812016\" alt=\"\" title=\"\">&nbsp;&nbsp;</img></p>\n<p>二、蒲公英总体架构图</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023812014\" alt=\"\" title=\"\"> </img></p>\n<p>上方是蒲公英的总体架构图。最上层是现阶段支持的发布资源类型：课件视频/图片、APP安装包、页面静态资源、互动多媒体资源、docker镜像、脚本文件、Nodejs扩展库DLL等 </p>\n<p>下半部分是云端和校区的系统:</p>\n<ul>\n <li>CMDB：管理校区资产信息。蒲公英将发布的资源和cmdb的资产信息(校区城市、分校、教室、教学设备、校区服务器)关联一起.</li>\n <li>版本管理：记录各终端使用的各类资源的当前版本号、历史版本、版本升级依赖.</li>\n <li>发布平台：后台系统，负责资源的手动发布、自动发布、灰度发布、回滚等发布策略</li>\n <li>Mercedes Server: 负责接收上游发布平台的资源分发消息、转发消息给相应校区节点的Agent服务</li>\n <li>Beetle: 负责上传资源/下载资源</li>\n <li>Talgate：负责Mercedes Server和所有校区节点Agent服务地注册，会话连接管理，消息通信等</li>\n <li>Mercedes Agent: 负责接收Server的分发消息、调度Beetle从云端OSS下载资源、同校区两台服务器的资源同步</li>\n <li>Cadillac: 负责接受校区教室主播端访问内网资源请求、校区教学服务的api gateway.</li>\n</ul>\n<p>三、起源</p>\n<p>痛点：课件视频文件很大，教研老师上传视频时间长、上传过程出现网络波动或者关闭页面需重新上传。课件打点审核通过后，如何快速提供给示范班使用。</p>\n<p>解法：</p>\n<ul>\n <li>课件系统是一个提供给教研老师制作课件、管理课件的后台系统。它是一个BS架构的WEB系统，上传文件的方式是通过http直传，上传过程中一旦有中断，只能重新上传， 这样大大降低教研老师工作效率。经过调研决定采用tus协议实现断点续传上传大文件。tus协议是一种基于HTTP/1.1和HTTP/2机制用于文件断点续传。这里画了一个大致上传流程图，详细内容请查看tus官方文档(<a href=\"https://tus.io/\" rel=\"nofollow noreferrer\">https://tus.io/</a>)。<p><img src=\"https://segmentfault.com/img/remote/1460000023812017\" alt=\"\" title=\"\" /></p></li>\n <li>教研老师上传课件后，还需经过审核员预览、审核通过后才能交付使用。因此考虑可以先上传到研发中心的资源服务器，因为是在同一个内网环境，不需要经过外网，这样加快了上传速度。待课件经审核员审核通过后，再经由资源服务器上传到云端OSS。</li>\n <li>课件视频上传问题已经解决了。但加盟校区的主播端播放视频的优化方案还未到位，考虑到示范班和加盟校区想尽早使用，前线业务不能耽搁的情况下。我们评估了走外网播放视频方案的可行性：校区教学网络外接两条电信线路上网，一条为30M专线网络，一条为200M拨号光纤。互为备份，避免单线故障。我们在研发中心模拟校区的实际网络带宽，使用10台PC 通过有线网卡，同时播放视频，通过监控防火墙出口流量峰值、查看cacti 流量实时状况，并实际在PC 体验视频播放的流畅度<p><img src=\"https://segmentfault.com/img/remote/1460000023812018\" alt=\"\" title=\"\" /></p></li>\n</ul>\n<p>测试结果：流量下行峰值为173.8M，平均值为50M。 流量上行峰值为5M. PC播放视频的实际体验效果不错，流畅度良好. </p>\n<p>就这样这套方案平稳地帮我们过滤到下一个阶段。</p>\n<p>下面给出早期版本的简化架构图:</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023812020\" alt=\"\" title=\"\"> </img></p>\n<p>相应的简化流程：课件 =&gt; 断点续传 =&gt; 在线预览播放 =&gt; 审核通过，触发上传任务 =&gt; 异步上传到oss =&gt; 主播端播放课件视频</p>\n<p>落地效果：基本满足早期业务需求</p>\n<p><strong>四、资源分发</strong></p>\n<p>痛点：各校区当地外网环境无法100%保证全天候稳定，主播端在线播放课件视频出现卡顿、加载中现象。极端情况下影响正常授课。</p>\n<p>解法：课件资源如果在授课前已经存储在校区的服务器、开始授课时主播端只需要从内网拉取资源，这样就不依赖于外网环境。源着这个思路开始构思一个异地多校的资源分发系统。</p>\n<p>Q：资源分发系统的云端Server和分校节点Agent如何端到端的实时通信?</p>\n<p>A：复用双师教学系统的长连接网关服务Talgate，各个节点(server, agent)需要先往网关中心Talgate注册，建立长连接数据通道。</p>\n<p>Q：如何保证长连接通信双方消息不丢失?</p>\n<p>A：ACK+ 超时重传 + 去重</p>\n<ul>\n <li>Server推送消息时，携带一个标识 SID，推送出消息后会将当前消息添加到“待 ACK 消息列表”。Agent成功接收消息后，会给Server回一个业务层的 ACK 包，包中携带有本条接收消息的 SID。Server接收后，会从“待 ACK 消息列表”记录中删除此条消息。【ACK】</li>\n <li>如果Agent接收不到消息，Server的“待 ACK 消息列表”会维护一个超时计时器，一定时间内如果没有收到Agent的 ACK 包，会从“待 ACK 消息列表”中重新取出那条消息进行重推。【超时重传】</li>\n <li>如果Agent接收到消息了，but ACK包丢了，导致Server重传消息，可能会让Agent收到重复的消息，这时Agent需要根据SID来进行业务层的去重。 【去重】</li>\n</ul>\n<p>&nbsp;<img src=\"https://segmentfault.com/img/remote/1460000023812019\" alt=\"\" title=\"\">&nbsp;</img></p>\n<p>Q：Server或者Agent宕机可能导致重传失效。下一次重新连接上，Agent之前有若干条消息丢失，怎么办?</p>\n<p>A：Server需要进行完整性检查，利用“时间戳比对”机制，发现Agent“有消息丢失”的情况，可以重新同步丢失的数据。</p>\n<ul>\n <li>Server给接收方Agent推送 task1，顺便带上一个最新的时间戳 timestamp1，接收方 Agent 收到 task1 后，更新本地最新消息的时间戳为 timestamp1。</li>\n <li>Server推送第二条消息 task2，带上一个当前最新的时间戳 timestamp2，task2 在推送过程中由于某种原因接收方 Agent 和 Server连接断开，导致 task2 没有成功送达到接收方 Agent。</li>\n <li>Agent 重新连上Server，携带本地最新的时间戳 timestamp1，Server将Agent 暂存的消息中时间戳大于 timestamp1 的所有消息返回给Agent，其中就包括之前没有成功的 task2。</li>\n <li>Agent 收到 task2 后，更新本地最新消息的时间戳为 timestamp2。通过时间戳机制，Agent 可以成功地让丢失的 task2 进行补偿发送。&nbsp;</li>\n</ul>\n<p>&nbsp;<img src=\"https://segmentfault.com/img/remote/1460000023812023\" alt=\"\" title=\"\">&nbsp;</img></p>\n<p>Q: 校区Agent收到任务后，开始从云端OSS下载资源，如何避免重复下载，下载资源失败怎么办?</p>\n<p>A：Beetle是上传/下载服务组件，部署在校区，负责接收Agent的下载指令，执行实际的从云端下载资源文件的工作。</p>\n<ul>\n <li>Beetle先从本地文件列表检查文件是否已经下载或者下载中，若已经下载则返回成功，若正在下载中则返回下载中，否则执行下一步。</li>\n <li>Beetle计算待下载文件大小 检查是否大于 可用容量(磁盘剩余容量-下载中文件大小)，若大于的情况，现在方案是返回失败。后续迭代方案是给资源文件按等级、文件大小做加权值，优先下载权值高的文件。</li>\n <li>Beetle对于大文件的下载，按断点续传下载文件，若出现网络不稳定下载失败，根据配置文件的重试次数，执行重试机制。若重试后无效，返回失败。</li>\n <li>Agent收到下载失败结果，更新分发任务状态为“下载失败”，通知Server任务失败。并触发告警到质量监控平台。</li>\n</ul>\n<p>&nbsp;<img src=\"https://segmentfault.com/img/remote/1460000023812024\" alt=\"\" title=\"\">&nbsp;</img></p>\n<p>Q: 如果校区存储资源的一台服务器出现故障，如何保证资源正常加载？</p>\n<p>A：每个校区部署两台服务器，使用LVS做主机冗余，避免一台机器宕机，出现单点故障。</p>\n<ul>\n <li>Mercedes Server根据校区节在网关注册的先后顺序选举Master，先给校区Master 服务器A发送分发任务，服务器A完成资源分发后，需同步资源给Slave服务器B。</li>\n <li>使用类Rsync+Sesync的机制实现服务器文件双向同步，双方比对文件列表，若发现缺失则同步资源。</li>\n <li>如果服务器A出现故障无法使用，服务器B被选举为Master，接管资源分发任务，待故障机器A恢复后，服务器B检查是否有新资源要同步给服务器A， 有则同步资源。<p><img src=\"https://segmentfault.com/img/remote/1460000023812026\" alt=\"\" title=\"\" /></p></li>\n</ul>\n<p>Q: 如果资源没有及时分发到校区节点，如何保证主播端正常加载资源？</p>\n<p>A：每个校区的网关服务Cadillac提供查询课件资源文件URL，Cadillac会检查资源文件是否发布，如果发布则返回内网URL地址，若未发布则返回外网URL地址。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023812021\" alt=\"\" title=\"\"> </img></p>\n<p>另外避免一些误操作导致已经发布的资源丢失的情况，而无法提前发现，建立了一套预警机制：Cadillac每晚11点会查询往后7天所有校区课表的课件资源URL列表，通过http head方法批量检查资源是否存在于内网，若不存在则触发告警、流转到质量监控报警平台。</p>\n<p>Q: 如果校区两台服务器都出现硬件故障或者长时间断电的情况下，如何保证主播端正常加载课件资源？</p>\n<p>A：主播端当主动探测到校区内网服务器无法工作后，自动切换到外网访问云端服务，加载外网课件资源。</p>\n<p>下面给出相应的简化架构图：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023812022\" alt=\"\" title=\"\"> </img></p>\n<p>相应的简化流程：课件 =&gt; 断点续传 =&gt; 在线预览播放 =&gt; 审核通过，触发上传任务 =&gt; 异步上传到oss &nbsp;=&gt; Mercedes Server创建课件分发任务 =&gt; 选取指定校区的Master服务器、给它发送任务 =&gt; Mercedes Agent接收到任务、记录任务、给Beetle发送下载任务、Beetle接到任务、记录下载任务、下载课件 =&gt; 校区服务器双向同步资源 =&gt; 内网不可用时切换到外网.</p>\n<p>落地效果：课件资源不依赖外网环境，主播端正常播放课件视频，提高教学系统的可用性。</p>\n<p>五、多类型资源分发、版本管理</p>\n<p>痛点：现有课件分发策略粒度比较粗，仅支持自动分发到所有校区。 一旦课件内容有问题，必将影响所有校区的正常教学。</p>\n<p>解法：搭建统一发布平台，打通上游业务系统、CI/CD系统和下游资源分发系统。管理资源版本号、发布记录、制定按城市、校区、版本三个维度的发布策略。监控发布流程，出现失败的任务触发告警。</p>\n<p>Q: 蒲公英发布平台除了支持课件视频发布外，也支持包括互动多媒体资源、安装包、Nodejs扩展库DLL、页面静态资源、脚本文件、Docker镜像等多种类型资源的发布。不同类型资源是否有共性，能不能抽象成通用的一种资源，实现统一管理？</p>\n<p>A：多种类型资源都有一些必要的属性：类型、发布源、版本号、文件名称、文件大小、文件存放OSS地址、MD5值、创建时间等，由此可以抽象成：“资源”、“发布任务”、“发布策略”、”发布任务历史“ 四个实体对象组成蒲公英的基础单元。</p>\n<p>Q：其他类型资源的分发方式是否跟课件资源一样：由蒲公英主动推送分发任务给校区节点，再由校区Agent执行下载资源操作？</p>\n<p>A：对于主播端、主教端、电子班牌、手表这类安装包，需要客户端执行下载安装操作。显然无法保证客户端24小时在线，蒲公英有发布任务时，很大概率是客户端不在线或者正在授课使用中，无法实时升级。因此被动接受发布任务的方式不适用于客户端升级。所以蒲公英需要提供接口给客户端检查是否有新版本更新，由客户端定期检查和执行升级。另外考虑到所有客户端都是运行在校区内，为了减少外网环境的依赖，大文件的安装包先分发到校区服务器，再由校区网关Cadillac提供版本更新接口，提高客户端升级成功率。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023812025\" alt=\"\" title=\"\"> </img></p>\n<p>相应的简化流程：课件 =&gt; 断点续传 =&gt; 在线预览播放 =&gt; 审核通过，触发上传任务 =&gt; 异步上传到oss =&gt; 创建课件分发任务 =&gt; 蒲公英发布 =&gt; 选取指定校区的Master服务器、给它发送任务 =&gt; Mercedes Agent接收到任务、记录任务、给Beetle发送下载任务、Beetle接到任务、记录下载任务、下载课件 =&gt; 校区服务器同步资源 =&gt; 内网不可用、切换外网.</p>\n<p>落地效果：蒲公英统一发布平台上线1个月左右来共发布250+个课件、1000+个互动多媒体资源、20+次客户端版本（主播端、主教端、手表）升级。 </p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023812027\" alt=\"\" title=\"\"> </img></p>\n<p>六、未来规划</p>\n<p>持续优化各服务组件，优化系统使用交互体验，优化用户角色权限 ，解藕业务侧逻辑，解藕部署环境的依赖，引入多租户的组织结构，开放能力给集团其他伙伴使用。</p>\n<p>七、经验总结</p>\n<p>从技术架构角度来说，励步双师教学系统是一个异地多校的分布式架构，它复杂度来源主要包括：高可用，可扩展性。这里主要介绍了分布式资源分发（蒲公英）平台的架构演进过程，基于业务发展阶段，分别引入资源分发、资源双备、版本管理，灰度发布等功能。<br><strong>招聘信息</strong></br></p>\n<p>好未来技术团队正在热招前端、算法、后台开发等各个方向高级开发工程师岗位，大家可点击本公众号“技术招聘”栏目了解详情，欢迎感兴趣的伙伴加入我们！</p>\n<p><strong>也许你还想看</strong></p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI4MDM5MTAzNA==&amp;mid=2247483964&amp;idx=2&amp;sn=a8f1b52d3ca00a6fae100cbe555e0897&amp;chksm=ebb87e29dccff73f0c1afc8362bf7add48f5203f0117f32e0f2e2bba4d928a7c3b1bb84741fe&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">DStack--基于flutter的混合开发框架</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI4MDM5MTAzNA==&amp;mid=2247483856&amp;idx=1&amp;sn=e48f6c63e11c86a550fdcbdb8f90c26b&amp;chksm=ebb87dc5dccff4d357dc39137e2e74f741a2b65b908c54887658dc5e985ab62681ec39c1d111&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">WebRTC源码分析——视频流水线建立（上）</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI4MDM5MTAzNA==&amp;mid=2247483785&amp;idx=1&amp;sn=b9964373d5b5a07954d531b124c9dc4a&amp;chksm=ebb87d9cdccff48a877b8be329f0070b9a640509ae7ede1d2360775fa7f58f5393fe8729532b&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">\"考试\"背后的科学：教育测量中的理论与模型（IRT篇）</a></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023812028\" alt=\"\" title=\"\" /></p>","descriptionType":"html","publishedDate":"Fri, 28 Aug 2020 13:58:11 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023812015","linkMd5":"bb083b060b9526f397749b24ba2bc49d","destWidth":800,"destHeight":368,"sourceBytes":160163,"destBytes":24242,"author":"好未来技术团队","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023812015":null,"https://segmentfault.com/img/remote/1460000023812016":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn19@2020_2/2020/09/01/03-37-58-415_7bf5efcc28b01482.webp","https://segmentfault.com/img/remote/1460000023812014":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn1@2020_2/2020/09/01/03-37-59-102_f7a2741924437066.webp","https://segmentfault.com/img/remote/1460000023812017":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn11@2020_3/2020/09/01/03-37-58-099_d559206594babf73.webp","https://segmentfault.com/img/remote/1460000023812018":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn15@2020_6/2020/09/01/03-37-58-587_e2bb91c02e9b96c8.webp","https://segmentfault.com/img/remote/1460000023812020":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn46@2020_4/2020/09/01/03-38-03-502_5a9fad4bc424908e.webp","https://segmentfault.com/img/remote/1460000023812019":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn7@2020_4/2020/09/01/03-37-58-737_f133316bf7d9ffad.webp","https://segmentfault.com/img/remote/1460000023812023":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn42@2020_3/2020/09/01/03-38-02-231_7c0b271e5e4fba84.webp","https://segmentfault.com/img/remote/1460000023812024":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn28@2020_3/2020/09/01/03-38-00-359_e40e747998354ff6.webp","https://segmentfault.com/img/remote/1460000023812026":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn58@2020_6/2020/09/01/03-38-01-597_0323d52533d33245.webp","https://segmentfault.com/img/remote/1460000023812021":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn49@2020_3/2020/09/01/03-38-02-962_eb7e20f9c1b97194.webp","https://segmentfault.com/img/remote/1460000023812022":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn37@2020_6/2020/09/01/03-38-02-144_10bdcbe8f719ccb8.webp","https://segmentfault.com/img/remote/1460000023812025":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn34@2020_5/2020/09/01/03-38-01-716_06bf46776b22f34e.webp","https://segmentfault.com/img/remote/1460000023812027":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn62@2020_3/2020/09/01/03-38-02-459_f7d1bcdacb9d28e3.webp","https://segmentfault.com/img/remote/1460000023812028":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn54@2020_6/2020/09/01/03-38-02-566_d4b9b296dc9e6839.webp"},"publishedOrCreatedDate":1598931423822},{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","title":"动态规划问题为什么要画表格？","link":"https://segmentfault.com/a/1190000023784647","description":"<blockquote>\n 本文是我的 91 算法第一期的部分讲义内容。 91 算法第一期已经接近尾声，二期的具体时间关注我的公众号即可，一旦开放，会第一时间在公众号《力扣加加》通知大家。\n</blockquote>\n<p>动态规划可以理解为是<strong>查表的递归（记忆化）</strong>。那么什么是递归？什么是查表（记忆化）？</p>\n<h2>递归</h2>\n<p>定义： 递归是指在函数的定义中使用函数自身的方法。</p>\n<p>算法中使用递归可以很简单地完成一些用循环实现的功能，比如二叉树的左中右序遍历。递归在算法中有非常广泛的使用，包括现在日趋流行的函数式编程。</p>\n<blockquote>\n 纯粹的函数式编程中没有循环，只有递归。\n</blockquote>\n<p>有意义的递归算法会把问题分解成规模缩小的同类子问题，当子问题缩写到寻常的时候，我们可以知道它的解。然后我们建立递归函数之间的联系即可解决原问题，这也是我们使用递归的意义。准确来说， 递归并不是算法，它是和迭代对应的一种编程方法。只不过，我们通常借助递归去分解问题而已。</p>\n<p>一个问题要使用递归来解决必须有递归终止条件（算法的有穷性），也就是顺递归会逐步缩小规模到寻常。</p>\n<p>虽然以下代码也是递归，但由于其无法结束，因此不是一个有效的算法：</p>\n<pre><code class=\"py\">def f(n):\n  return n + f(n - 1)</code></pre>\n<p>更多的情况应该是：</p>\n<pre><code class=\"py\">def f(n):\n  if n == 1: return 1\n  return n + f(n - 1)</code></pre>\n<h3>练习递归</h3>\n<p>一个简单练习递归的方式是将你写的迭代全部改成递归形式。比如你写了一个程序，功能是“将一个字符串逆序输出”，那么使用迭代将其写出来会非常容易，那么你是否可以使用递归写出来呢？通过这样的练习，可以让你逐步适应使用递归来写程序。</p>\n<p>如果你已经对递归比较熟悉了，那么我们继续往下看。</p>\n<h3>递归中的重复计算</h3>\n<p>递归中可能存在这么多的重复计算，为了消除这种重复计算，一种简单的方式就是记忆化递归。即一边递归一边使用“记录表”（比如哈希表或者数组）记录我们已经计算过的情况，当下次再次碰到的时候，如果之前已经计算了，那么直接返回即可，这样就避免了重复计算。而<strong>动态规划中 DP 数组其实和这里“记录表”的作用是一样的</strong>。</p>\n<h3>递归的时间复杂度分析</h3>\n<p>敬请期待我的新书。</p>\n<h3>小结</h3>\n<p>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。这里我列举了几道算法题目，这几道算法题目都可以用递归轻松写出来：</p>\n<ul>\n <li>递归实现 sum</li>\n <li>二叉树的遍历</li>\n <li>走楼梯问题</li>\n <li>汉诺塔问题</li>\n <li>杨辉三角</li>\n</ul>\n<p>当你已经适应了递归的时候，那就让我们继续学习动态规划吧！</p>\n<h2>动态规划</h2>\n<p>如果你已经熟悉了递归的技巧，那么使用递归解决问题非常符合人的直觉，代码写起来也比较简单。这个时候我们来关注另一个问题 - <strong>重复计算</strong> 。我们可以通过分析（可以尝试画一个递归树），可以看出递归在缩小问题规模的同时<strong>是否可能会重复计算</strong>。 <a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/279.perfect-squares.md\" rel=\"nofollow noreferrer\">279.perfect-squares</a> 中 我通过递归的方式来解决这个问题，同时内部维护了一个缓存来存储计算过的运算，这么做可以减少很多运算。 这其实和动态规划有着异曲同工的地方。</p>\n<blockquote>\n 小提示：如果你发现并没有重复计算，那么就没有必要用记忆化递归或者动态规划了。\n</blockquote>\n<p>因此动态规划就是枚举所以可能。不过相比暴力枚举，动态规划不会有重复计算。因此如何保证枚举时不重不漏是关键点之一。 递归由于使用了函数调用栈来存储数据，因此如果栈变得很大，那么会容易爆栈。</p>\n<h3>爆栈</h3>\n<p>我们结合求和问题来讲解一下，题目是给定一个数组，求出数组中所有项的和，要求使用递归实现。</p>\n<p>代码：</p>\n<pre><code class=\"js\">function sum(nums) {\n  if (nums.length === 0) return 0;\n  if (nums.length === 1) return nums[0];\n\n  return nums[0] + sum(nums.slice(1));\n}</code></pre>\n<p>我们用递归树来直观地看一下。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023784651\" alt=\"dynamic-programming-1\" title=\"dynamic-programming-1\" /></p>\n<p>这种做法本身没有问题，但是每次执行一个函数都有一定的开销，拿 JS 引擎执行 JS 来说，每次函数执行都会进行入栈操作，并进行预处理和执行过程，所以内存会有额外的开销，数据量大的时候很容易造成爆栈。</p>\n<blockquote>\n 浏览器中的 JS 引擎对于代码执行栈的长度是有限制的，超过会爆栈，抛出异常。\n</blockquote>\n<h3>重复计算</h3>\n<p>我们再举一个重复计算的例子，问题描述：</p>\n<p>一个人爬楼梯，每次只能爬 1 个或 2 个台阶，假设有 n 个台阶，那么这个人有多少种不同的爬楼梯方法？</p>\n<p>由于上第 n 级台阶一定是从 n - 1 或者 n - 2 来的，因此 上第 n 级台阶的数目就是 <code>上 n - 1 级台阶的数目加上 n - 1 级台阶的数目</code>。</p>\n<p>递归代码：</p>\n<pre><code class=\"js\">function climbStairs(n) {\n  if (n === 1) return 1;\n  if (n === 2) return 2;\n  return climbStairs(n - 1) + climbStairs(n - 2);\n}</code></pre>\n<p>我们继续用一个递归树来直观感受以下：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023784650\" alt=\"dynamic-programming-2\" title=\"dynamic-programming-2\" /></p>\n<blockquote>\n 红色表示重复的计算\n</blockquote>\n<p>可以看出这里面有很多重复计算，我们可以使用一个 hashtable 去缓存中间计算结果，从而省去不必要的计算。</p>\n<p>那么动态规划是怎么解决这个问题呢？ 答案也是“查表”，不过区别于递归使用函数调用栈，动态规划通常使用的是 dp 数组，数组的索引通常是问题规模，值通常是递归函数的返回值。<code>递归是从问题的结果倒推，直到问题的规模缩小到寻常。 动态规划是从寻常入手， 逐步扩大规模到最优子结构。</code></p>\n<p>如果上面的爬楼梯问题，使用动态规划，代码是这样的：</p>\n<pre><code class=\"js\">function climbStairs(n) {\n  if (n == 1) return 1;\n  const dp = new Array(n);\n  dp[0] = 1;\n  dp[1] = 2;\n\n  for (let i = 2; i &lt; n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  return dp[dp.length - 1];\n}</code></pre>\n<p>不会也没关系，我们将递归的代码稍微改造一下。其实就是将函数的名字改一下：</p>\n<pre><code class=\"js\">function dp(n) {\n  if (n === 1) return 1;\n  if (n === 2) return 2;\n  return dp(n - 1) + dp(n - 2);\n}</code></pre>\n<blockquote>\n dp[n] 和 dp(n) 对比看，这样是不是有点理解了呢? 只不过递归用调用栈枚举状态， 而动态规划使用迭代枚举状态。\n</blockquote>\n<p>动态规划的查表过程如果画成图，就是这样的：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000023784652\" alt=\"dynamic-programming-3\" title=\"dynamic-programming-3\" /></p>\n<blockquote>\n 虚线代表的是查表过程\n</blockquote>\n<p>这道题目是动态规划中最简单的问题了，因为设计到单个因素的变化，如果涉及到多个因素，就比较复杂了，比如著名的背包问题，挖金矿问题等。</p>\n<p>对于单个因素的，我们最多只需要一个一维数组即可，对于如背包问题我们需要二维数组等更高纬度。</p>\n<p>爬楼梯我们并没有必要使用一维数组，而是借助两个变量来实现的，空间复杂度是 O(1)。代码：</p>\n<pre><code class=\"js\">function climbStairs(n) {\n  if (n === 1) return 1;\n  if (n === 2) return 2;\n\n  let a = 1;\n  let b = 2;\n  let temp;\n\n  for (let i = 3; i &lt;= n; i++) {\n    temp = a + b;\n    a = b;\n    b = temp;\n  }\n\n  return temp;\n}</code></pre>\n<p>之所以能这么做，是因为爬楼梯问题的状态转移方程中<strong>当前状态只和前两个状态有关</strong>，因此只需要存储这两个即可。 动态规划问题有很多这种讨巧的方式，这个技巧叫做滚动数组。</p>\n<p>再次强调一下：</p>\n<ul>\n <li>如果说递归是从问题的结果倒推，直到问题的规模缩小到寻常。 那么动态规划就是从寻常入手， 逐步扩大规模到最优子结构。</li>\n <li>记忆化递归和动态规划没有本质不同。都是枚举状态，并根据状态直接的联系逐步推导求解。</li>\n <li>动态规划性能通常更好。 一方面是递归的栈开销，一方面是滚动数组的技巧。</li>\n</ul>\n<h3>动态规划的三个要素</h3>\n<ol>\n <li>状态转移方程</li>\n <li>临界条件</li>\n <li>枚举状态</li>\n</ol>\n<blockquote>\n 可以看出，用递归解决也是一样的思路\n</blockquote>\n<p>在上面讲解的爬楼梯问题中，如果我们用 f(n) 表示爬 n 级台阶有多少种方法的话，那么：</p>\n<pre><code>f(1) 与 f(2) 就是【边界】\nf(n) = f(n-1) + f(n-2) 就是【状态转移公式】\n</code></pre>\n<p>我用动态规划的形式表示一下：</p>\n<pre><code>dp[0] 与 dp[1] 就是【边界】\ndp[n] = dp[n - 1] + dp[n - 2] 就是【状态转移方程】</code></pre>\n<p>可以看出两者是多么的相似。</p>\n<p>实际上临界条件相对简单，大家只有多刷几道题，里面就有感觉。困难的是找到状态转移方程和枚举状态。这两个核心点的都建立在<strong>已经抽象好了状态</strong>的基础上。比如爬楼梯的问题，如果我们用 f(n) 表示爬 n 级台阶有多少种方法的话，那么 f(1), f(2), ... 就是各个<strong>独立的状态</strong>。</p>\n<p>不过状态的定义都有特点的套路。 比如一个字符串的状态，通常是 dp[i] 表示字符串 s 以 i 结尾的 ....。 比如两个字符串的状态，通常是 dpi 表示字符串 s1 以 i 结尾，s2 以 j 结尾的 ....。</p>\n<p>当然状态转移方程可能不止一个， 不同的转移方程对应的效率也可能大相径庭，这个就是比较玄学的话题了，需要大家在做题的过程中领悟。</p>\n<p>搞定了状态的定义，那么我们来看下状态转移方程。</p>\n<h4>状态转移方程</h4>\n<p>爬楼梯问题由于上第 n 级台阶一定是从 n - 1 或者 n - 2 来的，因此 上第 n 级台阶的数目就是 <code>上 n - 1 级台阶的数目加上 n - 1 级台阶的数目</code>。</p>\n<p>上面的这个理解是核心， 它就是我们的状态转移方程，用代码表示就是 <code>f(n) = f(n - 1) + f(n - 2)</code>。</p>\n<p>实际操作的过程，有可能题目和爬楼梯一样直观，我们不难想到。也可能隐藏很深或者维度过高。 如果你实在想不到，可以尝试画图打开思路，这也是我刚学习动态规划时候的方法。当你做题量上去了，你的题感就会来，那个时候就可以不用画图了。</p>\n<p>状态转移方程实在是没有什么灵丹妙药，不同的题目有不同的解法。状态转移方程同时也是解决动态规划问题中最最困难和关键的点，大家一定要多多练习，提高题感。接下来，我们来看下不那么困难，但是新手疑问比较多的问题 - <strong>如何枚举状态</strong>。</p>\n<h4>如何枚举状态</h4>\n<p>前面说了如何枚举状态，才能不重不漏是枚举状态的关键所在。</p>\n<ul>\n <li>如果是一维状态，那么我们使用一层循环可以搞定。</li>\n <li>如果是两维状态，那么我们使用两层循环可以搞定。</li>\n <li>。。。</li>\n</ul>\n<p>这样可以保证不重不漏。</p>\n<p>但是实际操作的过程有很多细节比如:</p>\n<ul>\n <li>一维状态我是先枚举左边的还是右边的？（从左到右遍历还是从右到左遍历）</li>\n <li>二维状态我是先枚举左上边的还是右上的，还是左下的还是右下的？</li>\n <li>里层循环和外层循环的位置关系（可以互换么）</li>\n <li>。。。</li>\n</ul>\n<p>其实这个东西和很多因素有关，很难总结出一个规律，而且我认为也完全没有必要去总结规律。不过这里我还是总结了一个关键点，那就是：</p>\n<ul>\n <li><strong>如果你没有使用滚动数组的技巧</strong>，那么遍历顺序取决于状态转移方程。比如:</li>\n</ul>\n<pre><code class=\"py\">for i in range(1, n + 1):\n  dp[i] = dp[i - 1] + 1;</code></pre>\n<p>那么我们就需要从左到右遍历，原因很简单，因为 dp[i] 依赖于 dp[i - 1]，因此计算 dp[i] 的时候， dp[i - 1] 需要已经计算好了。</p>\n<blockquote>\n 二维的也是一样的，大家可以试试。\n</blockquote>\n<ul>\n <li><strong>如果你使用了滚动数组的技巧</strong>，则怎么遍历都可以，但是不同的遍历意义通常不不同的。比如我将二维的压缩到了一维：</li>\n</ul>\n<pre><code class=\"py\">for i in range(1, n + 1):\n  for j in range(1, n + 1):\n    dp[j] = dp[j - 1] + 1;</code></pre>\n<p>这样是可以的。 dp[j - 1] 实际上指的是压缩前的 dpi</p>\n<p>而：</p>\n<pre><code class=\"py\">for i in range(1, n + 1):\n  #  倒着遍历\n  for j in range(n, 0, -1):\n    dp[j] = dp[j - 1] + 1;</code></pre>\n<p>这样也是可以的。 但是 dp[j - 1] 实际上指的是压缩前的 dpi - 1。因此实际中采用怎么样的遍历手段取决于题目。我特意写了一个 <a href=\"https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/solution/wan-quan-bei-bao-wen-ti-tao-lu-ti-1449-shu-wei-che/\" rel=\"nofollow noreferrer\">【完全背包问题】套路题（1449. 数位成本和为目标值的最大数字</a> 文章，通过一个具体的例子告诉大家不同的遍历有什么实际不同，强烈建议大家看看，并顺手给个三连。</p>\n<ul>\n <li>关于里外循环的问题，其实和上面原理类似。</li>\n</ul>\n<p>这个比较微妙，大家可以参考这篇文章理解一下 <a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/518.coin-change-2.md\" rel=\"nofollow noreferrer\">0518.coin-change-2</a>。</p>\n<h4>小结</h4>\n<p>关于如何确定临界条件通常是比较简单的，多做几个题就可以快速掌握。</p>\n<p>关于如何确定状态转移方程，这个其实比较困难。 不过所幸的是，这些套路性比较强， 比如一个字符串的状态，通常是 dp[i] 表示字符串 s 以 i 结尾的 ....。 比如两个字符串的状态，通常是 dpi 表示字符串 s1 以 i 结尾，s2 以 j 结尾的 ....。 这样遇到新的题目可以往上套， 实在套不出那就先老实画图，不断观察，提高题感。</p>\n<p>关于如何枚举状态，如果没有滚动数组， 那么根据转移方程决定如何枚举即可。 如果用了滚动数组，那么要注意压缩后和压缩前的 dp 对应关系即可。</p>\n<h3>动态规划为什么要画表格</h3>\n<p>动态规划问题要画表格，但是有的人不知道为什么要画，就觉得这个是必然的，必要要画表格才是动态规划。</p>\n<p>其实动态规划本质上是将大问题转化为小问题，然后大问题的解是和小问题有关联的，换句话说大问题可以由小问题进行计算得到。这一点是和用递归解决一样的， 但是动态规划是一种类似查表的方法来缩短时间复杂度和空间复杂度。</p>\n<p>画表格的目的就是去不断推导，完成状态转移， 表格中的每一个 cell 都是一个<code>小问题</code>， 我们填表的过程其实就是在解决问题的过程，</p>\n<p>我们先解决规模为寻常的情况，然后根据这个结果逐步推导，通常情况下，表格的右下角是问题的最大的规模，也就是我们想要求解的规模。</p>\n<p>比如我们用动态规划解决背包问题， 其实就是在不断根据之前的小问题<code>A[i - 1][j] A[i -1][w - wj]</code>来询问：</p>\n<ul>\n <li>应该选择它</li>\n <li>还是不选择它</li>\n</ul>\n<p>至于判断的标准很简单，就是价值最大，因此我们要做的就是对于选择和不选择两种情况分别求价值，然后取最大，最后更新 cell 即可。</p>\n<p>其实大部分的动态规划问题套路都是“选择”或者“不选择”，也就是说是一种“选择题”。 并且大多数动态规划题目还伴随着空间的优化（滚动数组），这是动态规划相对于传统的记忆化递归优势的地方。除了这点优势，就是上文提到的使用动态规划可以减少递归产生的函数调用栈，因此性能上更好。</p>\n<h3>相关问题</h3>\n<ul>\n <li><a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/91.decode-ways.md\" rel=\"nofollow noreferrer\">0091.decode-ways</a></li>\n <li><a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/139.word-break.md\" rel=\"nofollow noreferrer\">0139.word-break</a></li>\n <li><a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/0198.house-robber.md\" rel=\"nofollow noreferrer\">0198.house-robber</a></li>\n <li><a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/309.best-time-to-buy-and-sell-stock-with-cooldown.md\" rel=\"nofollow noreferrer\">0309.best-time-to-buy-and-sell-stock-with-cooldown</a></li>\n <li><a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/322.coin-change.md\" rel=\"nofollow noreferrer\">0322.coin-change</a></li>\n <li><a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/416.partition-equal-subset-sum.md\" rel=\"nofollow noreferrer\">0416.partition-equal-subset-sum</a></li>\n <li><a href=\"https://github.com/azl397985856/leetcode/blob/master/problems/518.coin-change-2.md\" rel=\"nofollow noreferrer\">0518.coin-change-2</a></li>\n</ul>\n<h2>总结</h2>\n<p>本篇文章总结了算法中比较常用的两个方法 - 递归和动态规划。递归的话可以拿树的题目练手，动态规划的话则将我上面推荐的刷完，再考虑去刷力扣的动态规划标签即可。</p>\n<p>大家前期学习动态规划的时候，可以先尝试使用记忆化递归解决。然后将其改造为动态规划，这样多练习几次就会有感觉。之后大家可以练习一下滚动数组，这个技巧很有用，并且相对来说比较简单。 比较动态规划的难点在于<strong>枚举所以状态（无重复）</strong> 和 <strong>寻找状态转移方程</strong>。</p>\n<p>如果你只能记住一句话，那么请记住：<code>递归是从问题的结果倒推，直到问题的规模缩小到寻常。 动态规划是从寻常入手， 逐步扩大规模到最优子结构。</code></p>\n<p>另外，大家可以去 LeetCode 探索中的 <a href=\"https://leetcode-cn.com/explore/orignial/card/recursion-i/\" rel=\"nofollow noreferrer\">递归 I</a> 中进行互动式学习。</p>","descriptionType":"html","publishedDate":"Thu, 27 Aug 2020 02:26:24 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000023784651","linkMd5":"7310966b6085403854e482ceee0ea6eb","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn12@2020_4/2020/09/01/03-37-52-928_3b94d4ec2d2d2935.webp","destWidth":800,"destHeight":519,"sourceBytes":47545,"destBytes":10700,"author":"lucifer","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000023784651":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn12@2020_4/2020/09/01/03-37-52-928_3b94d4ec2d2d2935.webp","https://segmentfault.com/img/remote/1460000023784650":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn48@2020_1/2020/09/01/03-37-58-071_3bdf674a4f693dcc.webp","https://segmentfault.com/img/remote/1460000023784652":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn44@2020_5/2020/09/01/03-37-58-670_4e0d2a153be681f3.webp"},"publishedOrCreatedDate":1598931423824}],"record":{"createdTime":"2020-09-01 11:37:03","updatedTime":"2020-09-01 11:37:03","feedId":6615,"fetchDate":"Tue, 01 Sep 2020 03:37:03 +0000","fetchMs":2919,"handleMs":7617,"totalMs":86718,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"0b0c85e73588d8e91f644a00731eafd7","hostName":"us-037*","requestId":"86b6d7a447cf4a439b712bd8b0b9b6f7_6615","contentType":"application/atom+xml; charset=UTF-8","totalBytes":10805794,"bgimgsTotal":13,"bgimgsGithubTotal":12,"articlesImgsTotal":110,"articlesImgsGithubTotal":102,"successGithubMap":{"myreaderx8":4,"myreaderx7":4,"myreaderx15":4,"myreaderx6":4,"myreaderx16":4,"myreaderx10":4,"myreaderx4":4,"myreaderx32":4,"myreaderx11":4,"myreaderx33":4,"myreaderx3":4,"myreaderx2":4,"myreaderx12":4,"myreaderx1":4,"myreaderx13":4,"myreaderx30":3,"myreaderx31":3,"myreaderx18":3,"myreaderx19":4,"myreaderx":4,"myreaderx25":4,"myreaderx27":3,"myreaderx21":4,"myreaderx22":4,"myreaderx24":3,"myreaderx5oss":3,"myreaderx29":4},"failGithubMap":{"myreaderx14":4,"myreaderx23":3}},"feed":{"createdTime":"2020-08-25 04:33:08","updatedTime":"2020-08-25 07:11:24","id":6615,"name":"SegmentFault 最新的文章","url":"http://segmentfault.com/feeds/blogs","subscriber":null,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"https://segmentfault.com"},"noPictureArticleList":[{"createdTime":"2020-09-01 11:38:19","updatedTime":"2020-09-01 11:38:19","id":null,"feedId":6615,"linkMd5":"11320f189f6b74cb092e6a54ca53cc59"},{"createdTime":"2020-09-01 11:38:19","updatedTime":"2020-09-01 11:38:19","id":null,"feedId":6615,"linkMd5":"320be39dd093985807704133bf69c403"},{"createdTime":"2020-09-01 11:38:19","updatedTime":"2020-09-01 11:38:19","id":null,"feedId":6615,"linkMd5":"4ea83030c443cca001ccdb773fb8a736"},{"createdTime":"2020-09-01 11:38:19","updatedTime":"2020-09-01 11:38:19","id":null,"feedId":6615,"linkMd5":"c5762ccc3f748952b49f0809e1c1d52e"},{"createdTime":"2020-09-01 11:38:19","updatedTime":"2020-09-01 11:38:19","id":null,"feedId":6615,"linkMd5":"64bc9675c6ac1a4ac8b541d7e50d33a2"},{"createdTime":"2020-09-01 11:38:19","updatedTime":"2020-09-01 11:38:19","id":null,"feedId":6615,"linkMd5":"bb083b060b9526f397749b24ba2bc49d"}],"tmpCommonImgCdnBytes":399932,"tmpBodyImgCdnBytes":10405862,"tmpBgImgCdnBytes":0,"extra4":{"start":1598931412405,"total":0,"statList":[{"spend":3803,"msg":"获取xml内容"},{"spend":7617,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":23447,"msg":"正文链接上传到cdn"}]},"extra5":110,"extra6":110,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812015","sourceStatusCode":200,"destWidth":800,"destHeight":368,"sourceBytes":160163,"destBytes":24242,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2955,"convertSpendMs":16,"createdTime":"2020-09-01 11:37:50","host":"europe65*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d,bb083b060b9526f397749b24ba2bc49d","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn53/contents/2020/09/01/03-37-53-254_e97c9edb20d53908.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:37:53 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["DBFC:B2EC:51D4F28:62C0F4E:5F4DC1FD"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598934022"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn53/contents/2020/09/01/03-37-53-254_e97c9edb20d53908.webp","historyStatusCode":[],"spendMs":245},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"156.4 KB","destSize":"23.7 KB","compressRate":"15.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812015","sourceStatusCode":200,"destWidth":800,"destHeight":368,"sourceBytes":160163,"destBytes":24242,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":1549,"convertSpendMs":16,"createdTime":"2020-09-01 11:37:53","host":"europe65*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d,bb083b060b9526f397749b24ba2bc49d","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn53/contents/2020/09/01/03-37-54-881_e97c9edb20d53908.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:37:55 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["DBFC:B2EC:51D4FD9:62C1918:5F4DC211"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598934022"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn53/contents/2020/09/01/03-37-54-881_e97c9edb20d53908.webp","historyStatusCode":[],"spendMs":243},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"156.4 KB","destSize":"23.7 KB","compressRate":"15.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023835988","sourceStatusCode":200,"destWidth":432,"destHeight":317,"sourceBytes":6657,"destBytes":4720,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3041,"convertSpendMs":21,"createdTime":"2020-09-01 11:37:55","host":"us-51*","referer":"https://segmentfault.com/a/1190000023835978","linkMd5ListStr":"11320f189f6b74cb092e6a54ca53cc59","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn67/contents/2020/09/01/03-37-58-689_3099b5e126ff69fc.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:37:58 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["B388:72D9:39A0DDC:63826A1:5F4DC20C"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598934022"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn67/contents/2020/09/01/03-37-58-689_3099b5e126ff69fc.webp","historyStatusCode":[],"spendMs":42},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"6.5 KB","destSize":"4.6 KB","compressRate":"70.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023835988","sourceStatusCode":200,"destWidth":432,"destHeight":317,"sourceBytes":6657,"destBytes":4720,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":1403,"convertSpendMs":17,"createdTime":"2020-09-01 11:37:58","host":"us-51*","referer":"https://segmentfault.com/a/1190000023835978","linkMd5ListStr":"11320f189f6b74cb092e6a54ca53cc59","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn67/contents/2020/09/01/03-38-00-087_3099b5e126ff69fc.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:38:00 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["B388:72D9:39A0E93:6382D07:5F4DC216"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598934022"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn67/contents/2020/09/01/03-38-00-087_3099b5e126ff69fc.webp","historyStatusCode":[],"spendMs":63},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"6.5 KB","destSize":"4.6 KB","compressRate":"70.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023835986","sourceStatusCode":500,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":5764,"convertSpendMs":0,"createdTime":"2020-09-01 11:37:55","host":"us-004*","referer":"https://segmentfault.com/a/1190000023835978","linkMd5ListStr":"11320f189f6b74cb092e6a54ca53cc59","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[500],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000022678951","sourceStatusCode":200,"destWidth":800,"destHeight":292,"sourceBytes":26554,"destBytes":26554,"feedId":6615,"totalSpendMs":2333,"convertSpendMs":0,"createdTime":"2020-09-01 11:37:59","host":"europe64*","referer":"https://segmentfault.com/a/1190000023800899","linkMd5ListStr":"64bc9675c6ac1a4ac8b541d7e50d33a2","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn97/contents/2020/09/01/03-38-01-606_437227b461a5c9c8.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:38:01 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["CAFA:B2ED:A970E01:CD056E7:5F4DC20A"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598933988"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn97/contents/2020/09/01/03-38-01-606_437227b461a5c9c8.webp","historyStatusCode":[],"spendMs":254},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.9 KB","destSize":"25.9 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023782329","sourceStatusCode":200,"destWidth":400,"destHeight":312,"sourceBytes":20244,"destBytes":20244,"feedId":6615,"totalSpendMs":2759,"convertSpendMs":0,"createdTime":"2020-09-01 11:37:59","host":"us-038*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn81/contents/2020/09/01/03-38-02-078_3fc0b3a2d370d207.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:38:02 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["A472:3EAC:3952A8A:651CE7E:5F4DC1FF"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598934022"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn81/contents/2020/09/01/03-38-02-078_3fc0b3a2d370d207.webp","historyStatusCode":[],"spendMs":57},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"19.8 KB","destSize":"19.8 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023800911","sourceStatusCode":200,"destWidth":800,"destHeight":600,"sourceBytes":35530,"destBytes":18036,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":6407,"convertSpendMs":19,"createdTime":"2020-09-01 11:37:56","host":"us-020*","referer":"https://segmentfault.com/a/1190000023800899","linkMd5ListStr":"64bc9675c6ac1a4ac8b541d7e50d33a2","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn71/contents/2020/09/01/03-38-02-872_1f46b502f35473c5.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:38:03 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["862C:217F:1E85BCC:4A15202:5F4DC213"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598933988"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn71/contents/2020/09/01/03-38-02-872_1f46b502f35473c5.webp","historyStatusCode":[],"spendMs":498},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"34.7 KB","destSize":"17.6 KB","compressRate":"50.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000022678951","sourceStatusCode":200,"destWidth":800,"destHeight":292,"sourceBytes":26554,"destBytes":26554,"feedId":6615,"totalSpendMs":1476,"convertSpendMs":0,"createdTime":"2020-09-01 11:38:01","host":"europe64*","referer":"https://segmentfault.com/a/1190000023800899","linkMd5ListStr":"64bc9675c6ac1a4ac8b541d7e50d33a2","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn97/contents/2020/09/01/03-38-03-157_437227b461a5c9c8.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:38:03 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["AF28:B3A0:4B29248:5AC5FFF:5F4DC21A"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598933988"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn97/contents/2020/09/01/03-38-03-157_437227b461a5c9c8.webp","historyStatusCode":[],"spendMs":254},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.9 KB","destSize":"25.9 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023782329","sourceStatusCode":200,"destWidth":400,"destHeight":312,"sourceBytes":20244,"destBytes":20244,"feedId":6615,"totalSpendMs":1354,"convertSpendMs":0,"createdTime":"2020-09-01 11:38:02","host":"us-032*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn81/contents/2020/09/01/03-38-03-457_3fc0b3a2d370d207.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:38:03 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["96F8:64CE:414EF52:6E16D99:5F4DC217"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598934022"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn81/contents/2020/09/01/03-38-03-457_3fc0b3a2d370d207.webp","historyStatusCode":[],"spendMs":44},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"19.8 KB","destSize":"19.8 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8m8","sourceStatusCode":200,"destWidth":800,"destHeight":82,"sourceBytes":28661,"destBytes":7812,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":1392,"convertSpendMs":6,"createdTime":"2020-09-01 11:38:02","host":"europe64*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn99/contents/2020/09/01/03-38-04-019_cee64acbc1e076d8.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:38:04 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["AF28:B3A0:4B2931C:5AC607F:5F4DC21B"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598934022"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn99/contents/2020/09/01/03-38-04-019_cee64acbc1e076d8.webp","historyStatusCode":[],"spendMs":178},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"28 KB","destSize":"7.6 KB","compressRate":"27.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023835986","sourceStatusCode":500,"sourceBytes":0,"destBytes":0,"feedId":6615,"totalSpendMs":3200,"convertSpendMs":0,"createdTime":"2020-09-01 11:38:01","host":"europe-25*","referer":"https://segmentfault.com/a/1190000023835978","linkMd5ListStr":"11320f189f6b74cb092e6a54ca53cc59","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[500],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8m8","sourceStatusCode":200,"destWidth":800,"destHeight":82,"sourceBytes":28661,"destBytes":7812,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":1286,"convertSpendMs":6,"createdTime":"2020-09-01 11:38:04","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn99/contents/2020/09/01/03-38-05-464_cee64acbc1e076d8.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:38:05 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["9652:5E45:865A188:A235FCD:5F4DC21A"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598934022"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn99/contents/2020/09/01/03-38-05-464_cee64acbc1e076d8.webp","historyStatusCode":[],"spendMs":168},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"28 KB","destSize":"7.6 KB","compressRate":"27.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023800911","sourceStatusCode":200,"destWidth":800,"destHeight":600,"sourceBytes":35530,"destBytes":18036,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2563,"convertSpendMs":18,"createdTime":"2020-09-01 11:38:03","host":"europe64*","referer":"https://segmentfault.com/a/1190000023800899","linkMd5ListStr":"64bc9675c6ac1a4ac8b541d7e50d33a2","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn71/contents/2020/09/01/03-38-05-824_1f46b502f35473c5.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:38:06 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["CAFA:B2ED:A97169D:CD072EB:5F4DC21C"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598933988"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn71/contents/2020/09/01/03-38-05-824_1f46b502f35473c5.webp","historyStatusCode":[],"spendMs":244},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"34.7 KB","destSize":"17.6 KB","compressRate":"50.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829033","sourceStatusCode":200,"destWidth":800,"destHeight":433,"sourceBytes":90628,"destBytes":13720,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":7618,"convertSpendMs":33,"createdTime":"2020-09-01 11:38:03","host":"us-020*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn11/contents/2020/09/01/03-38-09-918_9759b589d7ef9f27.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:38:10 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["862C:217F:1E85D9F:4A15815:5F4DC21B"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598933988"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn11/contents/2020/09/01/03-38-09-918_9759b589d7ef9f27.webp","historyStatusCode":[],"spendMs":1089},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"88.5 KB","destSize":"13.4 KB","compressRate":"15.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829033","sourceStatusCode":200,"destWidth":800,"destHeight":433,"sourceBytes":90628,"destBytes":13720,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":1519,"convertSpendMs":18,"createdTime":"2020-09-01 11:38:11","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx23/cdn11/contents/2020/09/01/03-38-12-440_9759b589d7ef9f27.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 69189253.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Tue, 01 Sep 2020 03:38:12 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"status":["403 Forbidden"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["DAF0:7A58:45864CF:54546CB:5F4DC21A"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, read:packages, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1598933988"],"x-xss-protection":["1; mode=block"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx23/cdn11/contents/2020/09/01/03-38-12-440_9759b589d7ef9f27.webp","historyStatusCode":[],"spendMs":240},"base64UserPassword":null,"token":"df0b9******************************93a6e"},"githubUser":"myreaderx23","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"88.5 KB","destSize":"13.4 KB","compressRate":"15.1%"}],"extra10_invalidATagHrefValue":{"https://segmentfault.com/a/1190000023783535_#":"https://segmentfault.com/a/1190000023783535#"},"extra111_proxyServerAndStatMap":{"http://europe-56.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-032.herokuapp.com/":{"failCount":0,"successCount":4,"resultList":[200,200,200,200]},"http://us-53.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe68.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-007.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe63.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-028.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://europe-60.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-024.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-52.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-038.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-020.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-025.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://europe69.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-017.herokuapp.com/":{"failCount":0,"successCount":4,"resultList":[200,200,200,200]},"http://europe21.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-004.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,500]},"http://us-033.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://europe64.herokuapp.com/":{"failCount":0,"successCount":6,"resultList":[200,200,200,200,200,200]},"http://us-008.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://europe-22.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-016.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-029.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-012.herokuapp.com/":{"failCount":0,"successCount":4,"resultList":[200,200,200,200]},"http://us-013.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-55.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-021.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-005.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://europe-58.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe61.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-009.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-006.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe-25.herokuapp.com/":{"failCount":1,"successCount":4,"resultList":[200,200,200,500,200]},"http://us-001.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-031.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-036.herokuapp.com/":{"failCount":0,"successCount":4,"resultList":[200,200,200,200]},"http://europe-59.herokuapp.com/":{"failCount":0,"successCount":3,"resultList":[200,200,200]},"http://us-51.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://europe67.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-023.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-040.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-027.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8mX","sourceStatusCode":200,"destWidth":549,"destHeight":440,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn56@2020_3/2020/09/01/03-37-52-869_739f709b98d8c6bd.webp","sourceBytes":54015,"destBytes":15898,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3342,"convertSpendMs":13,"createdTime":"2020-09-01 11:37:50","host":"europe66*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736,4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"52.7 KB","destSize":"15.5 KB","compressRate":"29.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023784651","sourceStatusCode":200,"destWidth":800,"destHeight":519,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn12@2020_4/2020/09/01/03-37-52-928_3b94d4ec2d2d2935.webp","sourceBytes":47545,"destBytes":10700,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3445,"convertSpendMs":12,"createdTime":"2020-09-01 11:37:50","host":"europe70*","referer":"https://segmentfault.com/a/1190000023784647","linkMd5ListStr":"7310966b6085403854e482ceee0ea6eb,7310966b6085403854e482ceee0ea6eb","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"46.4 KB","destSize":"10.4 KB","compressRate":"22.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL9iT","sourceStatusCode":200,"destWidth":635,"destHeight":130,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn37@2020_4/2020/09/01/03-37-53-018_9271c05535ae62dc.webp","sourceBytes":26221,"destBytes":10774,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3463,"convertSpendMs":7,"createdTime":"2020-09-01 11:37:50","host":"europe62*","referer":"https://segmentfault.com/a/1190000023825766","linkMd5ListStr":"3628302f81725d25098e883660547b85,3628302f81725d25098e883660547b85","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.6 KB","destSize":"10.5 KB","compressRate":"41.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023800902","sourceStatusCode":200,"destWidth":800,"destHeight":600,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn34@2020_5/2020/09/01/03-37-52-935_d18c0ad76604edca.webp","sourceBytes":159143,"destBytes":36220,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3496,"convertSpendMs":28,"createdTime":"2020-09-01 11:37:50","host":"europe-24*","referer":"https://segmentfault.com/a/1190000023800899","linkMd5ListStr":"64bc9675c6ac1a4ac8b541d7e50d33a2,64bc9675c6ac1a4ac8b541d7e50d33a2","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"155.4 KB","destSize":"35.4 KB","compressRate":"22.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023782322","sourceStatusCode":200,"destWidth":800,"destHeight":377,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn18@2020_2/2020/09/01/03-37-53-253_63eacc2b71b94bb2.webp","sourceBytes":37483,"destBytes":15764,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3797,"convertSpendMs":13,"createdTime":"2020-09-01 11:37:50","host":"europe-58*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e,c5762ccc3f748952b49f0809e1c1d52e,c5762ccc3f748952b49f0809e1c1d52e","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"36.6 KB","destSize":"15.4 KB","compressRate":"42.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023222841","sourceStatusCode":200,"destWidth":420,"destHeight":153,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn30@2020_3/2020/09/01/03-37-53-696_78af2b780400053b.webp","sourceBytes":39242,"destBytes":10100,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3993,"convertSpendMs":6,"createdTime":"2020-09-01 11:37:50","host":"us-011*","referer":"https://segmentfault.com/a/1190000023783535","linkMd5ListStr":"c7060f2797d69d7b9c52c8e7904d4c4b,c7060f2797d69d7b9c52c8e7904d4c4b","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"38.3 KB","destSize":"9.9 KB","compressRate":"25.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829022","sourceStatusCode":200,"destWidth":447,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn42@2020_5/2020/09/01/03-37-53-725_787fee427414f64f.webp","sourceBytes":42564,"destBytes":11140,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4003,"convertSpendMs":17,"createdTime":"2020-09-01 11:37:50","host":"us-040*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403,320be39dd093985807704133bf69c403","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"41.6 KB","destSize":"10.9 KB","compressRate":"26.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023816365","sourceStatusCode":200,"destWidth":446,"destHeight":130,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn45@2020_3/2020/09/01/03-37-53-775_e98d7572e3ba7b1d.webp","sourceBytes":3831,"destBytes":5068,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4088,"convertSpendMs":4,"createdTime":"2020-09-01 11:37:50","host":"us-027*","referer":"https://segmentfault.com/a/1190000023816361","linkMd5ListStr":"e505db913e7db589be14dae583b6857f,e505db913e7db589be14dae583b6857f","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"3.7 KB","destSize":"4.9 KB","compressRate":"132.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023835981","sourceStatusCode":200,"destWidth":800,"destHeight":619,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn21@2020_2/2020/09/01/03-37-53-749_148d9cc269b7b49b.webp","sourceBytes":150577,"destBytes":20332,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4102,"convertSpendMs":33,"createdTime":"2020-09-01 11:37:50","host":"us-035*","referer":"https://segmentfault.com/a/1190000023835978","linkMd5ListStr":"11320f189f6b74cb092e6a54ca53cc59,11320f189f6b74cb092e6a54ca53cc59","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"147 KB","destSize":"19.9 KB","compressRate":"13.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL11b","sourceStatusCode":200,"destWidth":800,"destHeight":450,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn50@2020_2/2020/09/01/03-37-53-800_320f368bba9b5746.webp","sourceBytes":72666,"destBytes":56028,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4267,"convertSpendMs":20,"createdTime":"2020-09-01 11:37:50","host":"us-015*","referer":"https://segmentfault.com/a/1190000023801496","linkMd5ListStr":"b134f90b7371ef57332d75c0b700b0c2,b134f90b7371ef57332d75c0b700b0c2","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"71 KB","destSize":"54.7 KB","compressRate":"77.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL09U","sourceStatusCode":200,"destWidth":320,"destHeight":200,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn9@2020_5/2020/09/01/03-37-53-209_227eed20c6d87d00.webp","sourceBytes":1142328,"destBytes":164322,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4321,"convertSpendMs":261,"createdTime":"2020-09-01 11:37:50","host":"europe69*","referer":"https://segmentfault.com/a/1190000023798228","linkMd5ListStr":"d167da38ff728721e4952cff6ba6724a,d167da38ff728721e4952cff6ba6724a","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"1.1 MB","destSize":"160.5 KB","compressRate":"14.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLZP0","sourceStatusCode":200,"destWidth":800,"destHeight":474,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn26@2020_3/2020/09/01/03-37-54-717_26cf72c0c5b11837.webp","sourceBytes":313452,"destBytes":43586,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3835,"convertSpendMs":27,"createdTime":"2020-09-01 11:37:51","host":"us-023*","referer":"https://segmentfault.com/a/1190000023787562","linkMd5ListStr":"dca2daa8a54c47eee063881bb9368430,dca2daa8a54c47eee063881bb9368430","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"306.1 KB","destSize":"42.6 KB","compressRate":"13.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023835989","sourceStatusCode":200,"destWidth":474,"destHeight":297,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn70@2020_2/2020/09/01/03-37-56-978_718ac95e2e6a9d79.webp","sourceBytes":16510,"destBytes":8630,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2014,"convertSpendMs":7,"createdTime":"2020-09-01 11:37:55","host":"us-040*","referer":"https://segmentfault.com/a/1190000023835978","linkMd5ListStr":"11320f189f6b74cb092e6a54ca53cc59","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"16.1 KB","destSize":"8.4 KB","compressRate":"52.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023800903","sourceStatusCode":200,"destWidth":800,"destHeight":600,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn7@2020_6/2020/09/01/03-37-57-135_5e06ef97840859dc.webp","sourceBytes":107093,"destBytes":18428,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2243,"convertSpendMs":28,"createdTime":"2020-09-01 11:37:55","host":"us-027*","referer":"https://segmentfault.com/a/1190000023800899","linkMd5ListStr":"64bc9675c6ac1a4ac8b541d7e50d33a2","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"104.6 KB","destSize":"18 KB","compressRate":"17.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023800904","sourceStatusCode":200,"destWidth":800,"destHeight":600,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn3@2020_2/2020/09/01/03-37-57-836_2cacdf5262d99ea2.webp","sourceBytes":143663,"destBytes":25458,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3074,"convertSpendMs":24,"createdTime":"2020-09-01 11:37:55","host":"europe63*","referer":"https://segmentfault.com/a/1190000023800899","linkMd5ListStr":"64bc9675c6ac1a4ac8b541d7e50d33a2","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"140.3 KB","destSize":"24.9 KB","compressRate":"17.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL9i1","sourceStatusCode":200,"destWidth":657,"destHeight":412,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn28@2020_4/2020/09/01/03-37-58-240_bfd4fe7f5e137c4d.webp","sourceBytes":49956,"destBytes":10684,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3332,"convertSpendMs":17,"createdTime":"2020-09-01 11:37:55","host":"us-55*","referer":"https://segmentfault.com/a/1190000023825766","linkMd5ListStr":"3628302f81725d25098e883660547b85","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"48.8 KB","destSize":"10.4 KB","compressRate":"21.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL11d","sourceStatusCode":200,"destWidth":800,"destHeight":369,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn91@2020_1/2020/09/01/03-37-58-244_8d1b710f42a44156.webp","sourceBytes":99395,"destBytes":15712,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3361,"convertSpendMs":21,"createdTime":"2020-09-01 11:37:55","host":"us-55*","referer":"https://segmentfault.com/a/1190000023801496","linkMd5ListStr":"b134f90b7371ef57332d75c0b700b0c2","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"97.1 KB","destSize":"15.3 KB","compressRate":"15.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023784650","sourceStatusCode":200,"destWidth":800,"destHeight":385,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn48@2020_1/2020/09/01/03-37-58-071_3bdf674a4f693dcc.webp","sourceBytes":38399,"destBytes":10524,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3304,"convertSpendMs":15,"createdTime":"2020-09-01 11:37:55","host":"europe-59*","referer":"https://segmentfault.com/a/1190000023784647","linkMd5ListStr":"7310966b6085403854e482ceee0ea6eb","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"37.5 KB","destSize":"10.3 KB","compressRate":"27.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLYfS","sourceStatusCode":200,"destWidth":794,"destHeight":346,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn63@2020_3/2020/09/01/03-37-58-322_ae3aff3564aecd3b.webp","sourceBytes":157791,"destBytes":24544,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3464,"convertSpendMs":38,"createdTime":"2020-09-01 11:37:55","host":"us-55*","referer":"https://segmentfault.com/a/1190000023787562","linkMd5ListStr":"dca2daa8a54c47eee063881bb9368430","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"154.1 KB","destSize":"24 KB","compressRate":"15.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812016","sourceStatusCode":200,"destWidth":664,"destHeight":370,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn19@2020_2/2020/09/01/03-37-58-415_7bf5efcc28b01482.webp","sourceBytes":62786,"destBytes":8834,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3507,"convertSpendMs":23,"createdTime":"2020-09-01 11:37:55","host":"us-024*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"61.3 KB","destSize":"8.6 KB","compressRate":"14.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL11f","sourceStatusCode":200,"destWidth":738,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn95@2020_6/2020/09/01/03-37-58-429_d01a93f13494880c.webp","sourceBytes":280439,"destBytes":24136,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3558,"convertSpendMs":36,"createdTime":"2020-09-01 11:37:55","host":"us-032*","referer":"https://segmentfault.com/a/1190000023801496","linkMd5ListStr":"b134f90b7371ef57332d75c0b700b0c2","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"273.9 KB","destSize":"23.6 KB","compressRate":"8.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023835990","sourceStatusCode":200,"destWidth":788,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn56@2020_4/2020/09/01/03-37-58-430_93934df93f8b9105.webp","sourceBytes":80561,"destBytes":20182,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3564,"convertSpendMs":35,"createdTime":"2020-09-01 11:37:55","host":"us-024*","referer":"https://segmentfault.com/a/1190000023835978","linkMd5ListStr":"11320f189f6b74cb092e6a54ca53cc59","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"78.7 KB","destSize":"19.7 KB","compressRate":"25.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023835983","sourceStatusCode":200,"destWidth":779,"destHeight":102,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn64@2020_1/2020/09/01/03-37-58-336_a5a9f542f4afb62e.webp","sourceBytes":13644,"destBytes":18124,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3479,"convertSpendMs":9,"createdTime":"2020-09-01 11:37:55","host":"europe-25*","referer":"https://segmentfault.com/a/1190000023835978","linkMd5ListStr":"11320f189f6b74cb092e6a54ca53cc59","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"13.3 KB","destSize":"17.7 KB","compressRate":"132.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLYfM","sourceStatusCode":200,"destWidth":800,"destHeight":460,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn68@2020_6/2020/09/01/03-37-58-464_61ddaa75fdc0b5b4.webp","sourceBytes":474668,"destBytes":39466,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3615,"convertSpendMs":34,"createdTime":"2020-09-01 11:37:55","host":"us-032*","referer":"https://segmentfault.com/a/1190000023787562","linkMd5ListStr":"dca2daa8a54c47eee063881bb9368430","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"463.5 KB","destSize":"38.5 KB","compressRate":"8.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023800909","sourceStatusCode":200,"destWidth":800,"destHeight":600,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn83@2020_3/2020/09/01/03-37-58-085_6b90dfd595d34ec3.webp","sourceBytes":82308,"destBytes":38252,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3496,"convertSpendMs":29,"createdTime":"2020-09-01 11:37:55","host":"europe-59*","referer":"https://segmentfault.com/a/1190000023800899","linkMd5ListStr":"64bc9675c6ac1a4ac8b541d7e50d33a2","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"80.4 KB","destSize":"37.4 KB","compressRate":"46.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL11c","sourceStatusCode":200,"destWidth":800,"destHeight":364,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn100@2020_6/2020/09/01/03-37-58-491_aed931b01bc971ba.webp","sourceBytes":84757,"destBytes":13630,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3635,"convertSpendMs":18,"createdTime":"2020-09-01 11:37:55","host":"us-008*","referer":"https://segmentfault.com/a/1190000023801496","linkMd5ListStr":"b134f90b7371ef57332d75c0b700b0c2","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"82.8 KB","destSize":"13.3 KB","compressRate":"16.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023800907","sourceStatusCode":200,"destWidth":800,"destHeight":600,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn91@2020_6/2020/09/01/03-37-58-467_be4b0fc8d17c8257.webp","sourceBytes":137004,"destBytes":16162,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3663,"convertSpendMs":26,"createdTime":"2020-09-01 11:37:55","host":"us-024*","referer":"https://segmentfault.com/a/1190000023800899","linkMd5ListStr":"64bc9675c6ac1a4ac8b541d7e50d33a2","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"133.8 KB","destSize":"15.8 KB","compressRate":"11.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL096","sourceStatusCode":200,"destWidth":800,"destHeight":480,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn10@2020_5/2020/09/01/03-37-58-539_efe6e4b19f6012d9.webp","sourceBytes":59502,"destBytes":19634,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3666,"convertSpendMs":18,"createdTime":"2020-09-01 11:37:55","host":"us-028*","referer":"https://segmentfault.com/a/1190000023798228","linkMd5ListStr":"d167da38ff728721e4952cff6ba6724a","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"58.1 KB","destSize":"19.2 KB","compressRate":"33%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812017","sourceStatusCode":200,"destWidth":800,"destHeight":431,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn11@2020_3/2020/09/01/03-37-58-099_d559206594babf73.webp","sourceBytes":174634,"destBytes":27352,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3582,"convertSpendMs":20,"createdTime":"2020-09-01 11:37:55","host":"europe-59*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"170.5 KB","destSize":"26.7 KB","compressRate":"15.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023835987","sourceStatusCode":200,"destWidth":704,"destHeight":314,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn88@2020_3/2020/09/01/03-37-58-456_ce9a5c21e316ff27.webp","sourceBytes":20372,"destBytes":14876,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3583,"convertSpendMs":12,"createdTime":"2020-09-01 11:37:55","host":"europe67*","referer":"https://segmentfault.com/a/1190000023835978","linkMd5ListStr":"11320f189f6b74cb092e6a54ca53cc59","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"19.9 KB","destSize":"14.5 KB","compressRate":"73%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023835985","sourceStatusCode":200,"destWidth":779,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn80@2020_3/2020/09/01/03-37-58-498_ec6ffbbfb1079ac1.webp","sourceBytes":123816,"destBytes":35502,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3714,"convertSpendMs":33,"createdTime":"2020-09-01 11:37:55","host":"us-016*","referer":"https://segmentfault.com/a/1190000023835978","linkMd5ListStr":"11320f189f6b74cb092e6a54ca53cc59","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"120.9 KB","destSize":"34.7 KB","compressRate":"28.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023835984","sourceStatusCode":200,"destWidth":771,"destHeight":443,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn75@2020_4/2020/09/01/03-37-58-547_c5267cfd3bf7c079.webp","sourceBytes":52162,"destBytes":21556,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3704,"convertSpendMs":19,"createdTime":"2020-09-01 11:37:55","host":"us-028*","referer":"https://segmentfault.com/a/1190000023835978","linkMd5ListStr":"11320f189f6b74cb092e6a54ca53cc59","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"50.9 KB","destSize":"21.1 KB","compressRate":"41.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812018","sourceStatusCode":200,"destWidth":800,"destHeight":279,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn15@2020_6/2020/09/01/03-37-58-587_e2bb91c02e9b96c8.webp","sourceBytes":220425,"destBytes":29898,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3754,"convertSpendMs":23,"createdTime":"2020-09-01 11:37:55","host":"us-036*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"215.3 KB","destSize":"29.2 KB","compressRate":"13.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023800905","sourceStatusCode":200,"destWidth":800,"destHeight":600,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn99@2020_5/2020/09/01/03-37-58-388_d76a533bf4a4d9e1.webp","sourceBytes":80999,"destBytes":24196,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3633,"convertSpendMs":22,"createdTime":"2020-09-01 11:37:55","host":"europe-25*","referer":"https://segmentfault.com/a/1190000023800899","linkMd5ListStr":"64bc9675c6ac1a4ac8b541d7e50d33a2","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"79.1 KB","destSize":"23.6 KB","compressRate":"29.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL9kb","sourceStatusCode":200,"destWidth":616,"destHeight":729,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn16@2020_6/2020/09/01/03-37-58-621_f7b15167502944c8.webp","sourceBytes":314462,"destBytes":53304,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3831,"convertSpendMs":38,"createdTime":"2020-09-01 11:37:55","host":"us-016*","referer":"https://segmentfault.com/a/1190000023825766","linkMd5ListStr":"3628302f81725d25098e883660547b85","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"307.1 KB","destSize":"52.1 KB","compressRate":"17%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023835991","sourceStatusCode":200,"destWidth":800,"destHeight":448,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn51@2020_6/2020/09/01/03-37-58-589_6cea6f4153ccda38.webp","sourceBytes":135028,"destBytes":27404,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3838,"convertSpendMs":29,"createdTime":"2020-09-01 11:37:55","host":"us-036*","referer":"https://segmentfault.com/a/1190000023835978","linkMd5ListStr":"11320f189f6b74cb092e6a54ca53cc59","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"131.9 KB","destSize":"26.8 KB","compressRate":"20.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL9i9","sourceStatusCode":200,"destWidth":629,"destHeight":641,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn32@2020_4/2020/09/01/03-37-58-469_4b0a9d3b01ac1dfd.webp","sourceBytes":310635,"destBytes":73600,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3831,"convertSpendMs":33,"createdTime":"2020-09-01 11:37:55","host":"us-032*","referer":"https://segmentfault.com/a/1190000023825766","linkMd5ListStr":"3628302f81725d25098e883660547b85","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"303.4 KB","destSize":"71.9 KB","compressRate":"23.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023800908","sourceStatusCode":200,"destWidth":800,"destHeight":600,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn88@2020_2/2020/09/01/03-37-58-630_fc372fe7cee00b99.webp","sourceBytes":272259,"destBytes":40994,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3908,"convertSpendMs":38,"createdTime":"2020-09-01 11:37:55","host":"us-036*","referer":"https://segmentfault.com/a/1190000023800899","linkMd5ListStr":"64bc9675c6ac1a4ac8b541d7e50d33a2","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"265.9 KB","destSize":"40 KB","compressRate":"15.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL9i4","sourceStatusCode":200,"destWidth":648,"destHeight":406,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn23@2020_6/2020/09/01/03-37-58-482_57543efccbe24ada.webp","sourceBytes":113737,"destBytes":25406,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3835,"convertSpendMs":15,"createdTime":"2020-09-01 11:37:55","host":"europe67*","referer":"https://segmentfault.com/a/1190000023825766","linkMd5ListStr":"3628302f81725d25098e883660547b85","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"111.1 KB","destSize":"24.8 KB","compressRate":"22.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023835982","sourceStatusCode":200,"destWidth":800,"destHeight":104,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn59@2020_1/2020/09/01/03-37-58-947_c6e6d48e1f719d09.webp","sourceBytes":26518,"destBytes":9152,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4025,"convertSpendMs":6,"createdTime":"2020-09-01 11:37:55","host":"us-012*","referer":"https://segmentfault.com/a/1190000023835978","linkMd5ListStr":"11320f189f6b74cb092e6a54ca53cc59","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.9 KB","destSize":"8.9 KB","compressRate":"34.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023784652","sourceStatusCode":200,"destWidth":800,"destHeight":426,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn44@2020_5/2020/09/01/03-37-58-670_4e0d2a153be681f3.webp","sourceBytes":56418,"destBytes":19418,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3914,"convertSpendMs":15,"createdTime":"2020-09-01 11:37:55","host":"europe21*","referer":"https://segmentfault.com/a/1190000023784647","linkMd5ListStr":"7310966b6085403854e482ceee0ea6eb","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"55.1 KB","destSize":"19 KB","compressRate":"34.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL9jT","sourceStatusCode":200,"destWidth":625,"destHeight":322,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn40@2020_4/2020/09/01/03-37-58-537_91e2bed5f2661da2.webp","sourceBytes":45104,"destBytes":23424,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4086,"convertSpendMs":15,"createdTime":"2020-09-01 11:37:55","host":"us-008*","referer":"https://segmentfault.com/a/1190000023825766","linkMd5ListStr":"3628302f81725d25098e883660547b85","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"44 KB","destSize":"22.9 KB","compressRate":"51.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023800910","sourceStatusCode":200,"destWidth":800,"destHeight":600,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn76@2020_1/2020/09/01/03-37-58-486_851debfe07753166.webp","sourceBytes":32319,"destBytes":26868,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4086,"convertSpendMs":27,"createdTime":"2020-09-01 11:37:55","host":"us-008*","referer":"https://segmentfault.com/a/1190000023800899","linkMd5ListStr":"64bc9675c6ac1a4ac8b541d7e50d33a2","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"31.6 KB","destSize":"26.2 KB","compressRate":"83.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812019","sourceStatusCode":200,"destWidth":800,"destHeight":428,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn7@2020_4/2020/09/01/03-37-58-737_f133316bf7d9ffad.webp","sourceBytes":139916,"destBytes":21964,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4038,"convertSpendMs":25,"createdTime":"2020-09-01 11:37:55","host":"europe21*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"136.6 KB","destSize":"21.4 KB","compressRate":"15.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023800906","sourceStatusCode":200,"destWidth":800,"destHeight":600,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn95@2020_1/2020/09/01/03-37-59-025_f574f7576d5afcd2.webp","sourceBytes":62294,"destBytes":27698,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4184,"convertSpendMs":20,"createdTime":"2020-09-01 11:37:55","host":"us-012*","referer":"https://segmentfault.com/a/1190000023800899","linkMd5ListStr":"64bc9675c6ac1a4ac8b541d7e50d33a2","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"60.8 KB","destSize":"27 KB","compressRate":"44.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812014","sourceStatusCode":200,"destWidth":800,"destHeight":434,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn1@2020_2/2020/09/01/03-37-59-102_f7a2741924437066.webp","sourceBytes":173453,"destBytes":29644,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4251,"convertSpendMs":27,"createdTime":"2020-09-01 11:37:55","host":"us-007*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"169.4 KB","destSize":"28.9 KB","compressRate":"17.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbJgYT","sourceStatusCode":200,"destWidth":800,"destHeight":189,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn24@2020_5/2020/09/01/03-37-59-160_7f8323e1c3c7e5a5.webp","sourceBytes":129123,"destBytes":22456,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2352,"convertSpendMs":14,"createdTime":"2020-09-01 11:37:57","host":"us-012*","referer":"https://segmentfault.com/a/1190000023787562","linkMd5ListStr":"dca2daa8a54c47eee063881bb9368430","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"126.1 KB","destSize":"21.9 KB","compressRate":"17.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbLZP7","sourceStatusCode":200,"destWidth":500,"destHeight":500,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn20@2020_3/2020/09/01/03-37-59-849_c9d3de54bab8926e.webp","sourceBytes":2412,"destBytes":10326,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4927,"convertSpendMs":11,"createdTime":"2020-09-01 11:37:55","host":"us-004*","referer":"https://segmentfault.com/a/1190000023787562","linkMd5ListStr":"dca2daa8a54c47eee063881bb9368430","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"2.4 KB","destSize":"10.1 KB","compressRate":"428.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL1ag","sourceStatusCode":200,"destWidth":320,"destHeight":200,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn79@2020_4/2020/09/01/03-37-59-143_6d3087a652bb0127.webp","sourceBytes":759963,"destBytes":159912,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":5203,"convertSpendMs":437,"createdTime":"2020-09-01 11:37:55","host":"europe21*","referer":"https://segmentfault.com/a/1190000023798228","linkMd5ListStr":"d167da38ff728721e4952cff6ba6724a","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"742.2 KB","destSize":"156.2 KB","compressRate":"21%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812024","sourceStatusCode":200,"destWidth":800,"destHeight":304,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn28@2020_3/2020/09/01/03-38-00-359_e40e747998354ff6.webp","sourceBytes":126594,"destBytes":19862,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3329,"convertSpendMs":15,"createdTime":"2020-09-01 11:37:58","host":"europe-25*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"123.6 KB","destSize":"19.4 KB","compressRate":"15.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8nf","sourceStatusCode":200,"destWidth":800,"destHeight":78,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn38@2020_4/2020/09/01/03-38-01-653_e93146cdac3100d2.webp","sourceBytes":29666,"destBytes":8072,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2704,"convertSpendMs":5,"createdTime":"2020-09-01 11:37:59","host":"europe-22*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"29 KB","destSize":"7.9 KB","compressRate":"27.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8nc","sourceStatusCode":200,"destWidth":800,"destHeight":83,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn21@2020_1/2020/09/01/03-38-01-535_31aaec06eb559545.webp","sourceBytes":29856,"destBytes":8146,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2969,"convertSpendMs":6,"createdTime":"2020-09-01 11:37:59","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"29.2 KB","destSize":"8 KB","compressRate":"27.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023782321","sourceStatusCode":200,"destWidth":800,"destHeight":461,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn1@2020_4/2020/09/01/03-38-01-851_c79aa388a9a4f6e1.webp","sourceBytes":58358,"destBytes":24592,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3239,"convertSpendMs":20,"createdTime":"2020-09-01 11:37:59","host":"us-52*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e,c5762ccc3f748952b49f0809e1c1d52e","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"57 KB","destSize":"24 KB","compressRate":"42.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023782333","sourceStatusCode":200,"destWidth":800,"destHeight":311,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn73@2020_3/2020/09/01/03-38-01-673_2cb789f45dd9a9c2.webp","sourceBytes":30282,"destBytes":11354,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3213,"convertSpendMs":10,"createdTime":"2020-09-01 11:37:59","host":"europe-22*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"29.6 KB","destSize":"11.1 KB","compressRate":"37.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023816364","sourceStatusCode":200,"destWidth":469,"destHeight":207,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn5@2020_6/2020/09/01/03-38-01-977_c2e482d914b8eb8c.webp","sourceBytes":4209,"destBytes":3976,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3289,"convertSpendMs":92,"createdTime":"2020-09-01 11:37:59","host":"us-029*","referer":"https://segmentfault.com/a/1190000023816361","linkMd5ListStr":"e505db913e7db589be14dae583b6857f","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"4.1 KB","destSize":"3.9 KB","compressRate":"94.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812026","sourceStatusCode":200,"destWidth":800,"destHeight":277,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn58@2020_6/2020/09/01/03-38-01-597_0323d52533d33245.webp","sourceBytes":163071,"destBytes":28330,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3397,"convertSpendMs":13,"createdTime":"2020-09-01 11:37:59","host":"europe-56*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"159.2 KB","destSize":"27.7 KB","compressRate":"17.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8ng","sourceStatusCode":200,"destWidth":800,"destHeight":67,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn42@2020_1/2020/09/01/03-38-01-832_4a4642035cdfc4c2.webp","sourceBytes":29571,"destBytes":8840,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2855,"convertSpendMs":5,"createdTime":"2020-09-01 11:37:59","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"28.9 KB","destSize":"8.6 KB","compressRate":"29.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8m4","sourceStatusCode":200,"destWidth":800,"destHeight":86,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn70@2020_1/2020/09/01/03-38-02-027_cf9a2f8b982c874e.webp","sourceBytes":27033,"destBytes":7132,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2208,"convertSpendMs":41,"createdTime":"2020-09-01 11:38:00","host":"us-029*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"26.4 KB","destSize":"7 KB","compressRate":"26.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8nh","sourceStatusCode":200,"destWidth":800,"destHeight":80,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn46@2020_6/2020/09/01/03-38-02-084_2677ed46cc718c7f.webp","sourceBytes":26996,"destBytes":8152,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3055,"convertSpendMs":6,"createdTime":"2020-09-01 11:37:59","host":"us-038*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"26.4 KB","destSize":"8 KB","compressRate":"30.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812025","sourceStatusCode":200,"destWidth":658,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn34@2020_5/2020/09/01/03-38-01-716_06bf46776b22f34e.webp","sourceBytes":270148,"destBytes":35532,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3887,"convertSpendMs":32,"createdTime":"2020-09-01 11:37:59","host":"europe64*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"263.8 KB","destSize":"34.7 KB","compressRate":"13.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8m1","sourceStatusCode":200,"destWidth":800,"destHeight":127,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn58@2020_3/2020/09/01/03-38-02-249_f2bf5ea3c2dc9873.webp","sourceBytes":40394,"destBytes":11694,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3053,"convertSpendMs":9,"createdTime":"2020-09-01 11:37:59","host":"us-001*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"39.4 KB","destSize":"11.4 KB","compressRate":"28.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023782328","sourceStatusCode":200,"destWidth":800,"destHeight":321,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn78@2020_5/2020/09/01/03-38-01-850_a1a56e898066d815.webp","sourceBytes":42128,"destBytes":17882,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3533,"convertSpendMs":10,"createdTime":"2020-09-01 11:37:59","host":"europe-60*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"41.1 KB","destSize":"17.5 KB","compressRate":"42.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023782325","sourceStatusCode":200,"destWidth":800,"destHeight":320,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn89@2020_6/2020/09/01/03-38-02-198_3e586aefbe01cd40.webp","sourceBytes":32824,"destBytes":16576,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3604,"convertSpendMs":11,"createdTime":"2020-09-01 11:37:59","host":"us-013*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"32.1 KB","destSize":"16.2 KB","compressRate":"50.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812022","sourceStatusCode":200,"destWidth":721,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn37@2020_6/2020/09/01/03-38-02-144_10bdcbe8f719ccb8.webp","sourceBytes":288753,"destBytes":38068,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4008,"convertSpendMs":46,"createdTime":"2020-09-01 11:37:59","host":"us-52*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"282 KB","destSize":"37.2 KB","compressRate":"13.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8m3","sourceStatusCode":200,"destWidth":800,"destHeight":151,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn66@2020_2/2020/09/01/03-38-02-145_82cd0f8a3748d672.webp","sourceBytes":40177,"destBytes":12636,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2897,"convertSpendMs":13,"createdTime":"2020-09-01 11:38:00","host":"us-52*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"39.2 KB","destSize":"12.3 KB","compressRate":"31.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023782326","sourceStatusCode":200,"destWidth":800,"destHeight":425,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn94@2020_6/2020/09/01/03-38-02-255_870a115b75fc1ec3.webp","sourceBytes":37872,"destBytes":16634,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3666,"convertSpendMs":12,"createdTime":"2020-09-01 11:37:59","host":"us-001*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"37 KB","destSize":"16.2 KB","compressRate":"43.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812023","sourceStatusCode":200,"destWidth":800,"destHeight":640,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn42@2020_3/2020/09/01/03-38-02-231_7c0b271e5e4fba84.webp","sourceBytes":240621,"destBytes":35892,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4038,"convertSpendMs":217,"createdTime":"2020-09-01 11:37:59","host":"us-029*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"235 KB","destSize":"35.1 KB","compressRate":"14.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023782331","sourceStatusCode":200,"destWidth":800,"destHeight":404,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn65@2020_1/2020/09/01/03-38-02-425_dbf06a2b8e54cdb1.webp","sourceBytes":25911,"destBytes":10330,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3909,"convertSpendMs":23,"createdTime":"2020-09-01 11:37:59","host":"us-021*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.3 KB","destSize":"10.1 KB","compressRate":"39.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812027","sourceStatusCode":200,"destWidth":800,"destHeight":239,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn62@2020_3/2020/09/01/03-38-02-459_f7d1bcdacb9d28e3.webp","sourceBytes":113807,"destBytes":27034,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4032,"convertSpendMs":11,"createdTime":"2020-09-01 11:37:59","host":"us-033*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"111.1 KB","destSize":"26.4 KB","compressRate":"23.8%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8ne","sourceStatusCode":200,"destWidth":800,"destHeight":93,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn29@2020_3/2020/09/01/03-38-02-437_77821dc89e5fc28c.webp","sourceBytes":28318,"destBytes":7324,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3751,"convertSpendMs":25,"createdTime":"2020-09-01 11:37:59","host":"us-021*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"27.7 KB","destSize":"7.2 KB","compressRate":"25.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8nb","sourceStatusCode":200,"destWidth":800,"destHeight":75,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn17@2020_1/2020/09/01/03-38-02-528_4621da4f8c740a98.webp","sourceBytes":28611,"destBytes":8044,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3745,"convertSpendMs":6,"createdTime":"2020-09-01 11:37:59","host":"europe68*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"27.9 KB","destSize":"7.9 KB","compressRate":"28.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8na","sourceStatusCode":200,"destWidth":800,"destHeight":84,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn33@2020_6/2020/09/01/03-38-02-678_729eb0710dd38d1c.webp","sourceBytes":30567,"destBytes":8042,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3729,"convertSpendMs":9,"createdTime":"2020-09-01 11:37:59","host":"us-009*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"29.9 KB","destSize":"7.9 KB","compressRate":"26.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8nd","sourceStatusCode":200,"destWidth":800,"destHeight":160,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn25@2020_4/2020/09/01/03-38-02-446_728a5dbae41e6709.webp","sourceBytes":52786,"destBytes":15024,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3873,"convertSpendMs":9,"createdTime":"2020-09-01 11:37:59","host":"us-033*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"51.5 KB","destSize":"14.7 KB","compressRate":"28.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023402648","sourceStatusCode":200,"destWidth":710,"destHeight":722,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn49@2020_3/2020/09/01/03-38-02-653_65a9eba70fb7fcfc.webp","sourceBytes":116090,"destBytes":60068,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3718,"convertSpendMs":30,"createdTime":"2020-09-01 11:37:59","host":"us-025*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"113.4 KB","destSize":"58.7 KB","compressRate":"51.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023816367","sourceStatusCode":200,"destWidth":471,"destHeight":253,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn13@2020_4/2020/09/01/03-38-02-822_79954f784a546609.webp","sourceBytes":8159,"destBytes":7664,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4060,"convertSpendMs":8,"createdTime":"2020-09-01 11:37:59","host":"us-005*","referer":"https://segmentfault.com/a/1190000023816361","linkMd5ListStr":"e505db913e7db589be14dae583b6857f","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"8 KB","destSize":"7.5 KB","compressRate":"93.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812028","sourceStatusCode":200,"destWidth":720,"destHeight":321,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn54@2020_6/2020/09/01/03-38-02-566_d4b9b296dc9e6839.webp","sourceBytes":58469,"destBytes":23482,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4305,"convertSpendMs":12,"createdTime":"2020-09-01 11:37:59","host":"europe68*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"57.1 KB","destSize":"22.9 KB","compressRate":"40.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023402633","sourceStatusCode":200,"destWidth":800,"destHeight":449,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn77@2020_4/2020/09/01/03-38-02-898_1b1c937f60b4823a.webp","sourceBytes":54875,"destBytes":22740,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2294,"convertSpendMs":17,"createdTime":"2020-09-01 11:38:01","host":"us-005*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"53.6 KB","destSize":"22.2 KB","compressRate":"41.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023782324","sourceStatusCode":200,"destWidth":800,"destHeight":341,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn86@2020_1/2020/09/01/03-38-02-646_d2b1346867c82963.webp","sourceBytes":44651,"destBytes":19082,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4329,"convertSpendMs":27,"createdTime":"2020-09-01 11:37:59","host":"us-025*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e,c5762ccc3f748952b49f0809e1c1d52e","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"43.6 KB","destSize":"18.6 KB","compressRate":"42.7%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812021","sourceStatusCode":200,"destWidth":800,"destHeight":476,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn49@2020_3/2020/09/01/03-38-02-962_eb7e20f9c1b97194.webp","sourceBytes":182008,"destBytes":30918,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4661,"convertSpendMs":19,"createdTime":"2020-09-01 11:37:59","host":"us-005*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"177.7 KB","destSize":"30.2 KB","compressRate":"17%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023816366","sourceStatusCode":200,"destWidth":459,"destHeight":222,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn10@2020_4/2020/09/01/03-38-03-428_a7565d0037293afc.webp","sourceBytes":6179,"destBytes":5390,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4887,"convertSpendMs":7,"createdTime":"2020-09-01 11:37:59","host":"us-017*","referer":"https://segmentfault.com/a/1190000023816361","linkMd5ListStr":"e505db913e7db589be14dae583b6857f","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"6 KB","destSize":"5.3 KB","compressRate":"87.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023812020","sourceStatusCode":200,"destWidth":800,"destHeight":453,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx7/cdn46@2020_4/2020/09/01/03-38-03-502_5a9fad4bc424908e.webp","sourceBytes":95812,"destBytes":16846,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":5240,"convertSpendMs":18,"createdTime":"2020-09-01 11:37:59","host":"us-017*","referer":"https://segmentfault.com/a/1190000023812011","linkMd5ListStr":"bb083b060b9526f397749b24ba2bc49d","githubUser":"myreaderx7","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"93.6 KB","destSize":"16.5 KB","compressRate":"17.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8m0","sourceStatusCode":200,"destWidth":800,"destHeight":130,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn74@2020_3/2020/09/01/03-38-03-493_63678abe8fff8d59.webp","sourceBytes":49844,"destBytes":15104,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3391,"convertSpendMs":13,"createdTime":"2020-09-01 11:38:01","host":"us-017*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"48.7 KB","destSize":"14.8 KB","compressRate":"30.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8m2","sourceStatusCode":200,"destWidth":800,"destHeight":160,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn61@2020_5/2020/09/01/03-38-02-975_ea2356b530a6d1c1.webp","sourceBytes":49750,"destBytes":15732,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4240,"convertSpendMs":10,"createdTime":"2020-09-01 11:38:00","host":"europe64*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"48.6 KB","destSize":"15.4 KB","compressRate":"31.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL9jD","sourceStatusCode":200,"destWidth":640,"destHeight":490,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn35@2020_6/2020/09/01/03-38-03-160_7f661db2e7753ec0.webp","sourceBytes":68206,"destBytes":35556,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":7593,"convertSpendMs":19,"createdTime":"2020-09-01 11:37:56","host":"us-020*","referer":"https://segmentfault.com/a/1190000023825766","linkMd5ListStr":"3628302f81725d25098e883660547b85","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"66.6 KB","destSize":"34.7 KB","compressRate":"52.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8m6","sourceStatusCode":200,"destWidth":800,"destHeight":76,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn91@2020_3/2020/09/01/03-38-03-972_1ecc75f1dfdc03b5.webp","sourceBytes":27819,"destBytes":7054,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2073,"convertSpendMs":6,"createdTime":"2020-09-01 11:38:02","host":"us-012*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"27.2 KB","destSize":"6.9 KB","compressRate":"25.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829029","sourceStatusCode":200,"destWidth":447,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn28@2020_1/2020/09/01/03-38-04-334_84b41de998f544de.webp","sourceBytes":21435,"destBytes":7172,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2083,"convertSpendMs":23,"createdTime":"2020-09-01 11:38:03","host":"us-040*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"20.9 KB","destSize":"7 KB","compressRate":"33.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829032","sourceStatusCode":200,"destWidth":448,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn16@2020_2/2020/09/01/03-38-04-291_7f6b1c0bd813e1e3.webp","sourceBytes":52445,"destBytes":14194,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2271,"convertSpendMs":20,"createdTime":"2020-09-01 11:38:02","host":"us-009*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"51.2 KB","destSize":"13.9 KB","compressRate":"27.1%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829028","sourceStatusCode":200,"destWidth":452,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn31@2020_3/2020/09/01/03-38-04-361_b3febd452e1a81fb.webp","sourceBytes":21128,"destBytes":6886,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2112,"convertSpendMs":16,"createdTime":"2020-09-01 11:38:03","host":"us-028*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"20.6 KB","destSize":"6.7 KB","compressRate":"32.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023402636","sourceStatusCode":200,"destWidth":800,"destHeight":381,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn54@2020_1/2020/09/01/03-38-04-309_0b083e89fc14ae1f.webp","sourceBytes":49561,"destBytes":21390,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":5285,"convertSpendMs":12,"createdTime":"2020-09-01 11:37:59","host":"us-013*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"48.4 KB","destSize":"20.9 KB","compressRate":"43.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8m5","sourceStatusCode":200,"destWidth":800,"destHeight":97,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn88@2020_3/2020/09/01/03-38-04-585_331f420438e55b19.webp","sourceBytes":37230,"destBytes":9454,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2772,"convertSpendMs":8,"createdTime":"2020-09-01 11:38:02","host":"us-023*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"36.4 KB","destSize":"9.2 KB","compressRate":"25.4%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829023","sourceStatusCode":200,"destWidth":450,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn51@2020_2/2020/09/01/03-38-04-628_ba283ef1d7058c22.webp","sourceBytes":44608,"destBytes":11374,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2293,"convertSpendMs":53,"createdTime":"2020-09-01 11:38:03","host":"us-036*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"43.6 KB","destSize":"11.1 KB","compressRate":"25.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829021","sourceStatusCode":200,"destWidth":448,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn56@2020_3/2020/09/01/03-38-04-649_9d931e81099ea1d8.webp","sourceBytes":36820,"destBytes":10070,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2209,"convertSpendMs":16,"createdTime":"2020-09-01 11:38:03","host":"us-025*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"36 KB","destSize":"9.8 KB","compressRate":"27.3%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8m7","sourceStatusCode":200,"destWidth":800,"destHeight":72,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn96@2020_6/2020/09/01/03-38-04-529_5309b89f682b87eb.webp","sourceBytes":25862,"destBytes":6854,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2646,"convertSpendMs":5,"createdTime":"2020-09-01 11:38:02","host":"europe-25*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.3 KB","destSize":"6.7 KB","compressRate":"26.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829030","sourceStatusCode":200,"destWidth":450,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx1/cdn23@2020_3/2020/09/01/03-38-05-249_72717722b790ff6e.webp","sourceBytes":21552,"destBytes":7244,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3210,"convertSpendMs":15,"createdTime":"2020-09-01 11:38:03","host":"europe61*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403","githubUser":"myreaderx1","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"21 KB","destSize":"7.1 KB","compressRate":"33.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829024","sourceStatusCode":200,"destWidth":448,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn47@2020_3/2020/09/01/03-38-05-567_82bf961b3771e401.webp","sourceBytes":51630,"destBytes":12686,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3240,"convertSpendMs":16,"createdTime":"2020-09-01 11:38:03","host":"europe-58*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"50.4 KB","destSize":"12.4 KB","compressRate":"24.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8mZ","sourceStatusCode":200,"destWidth":740,"destHeight":190,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn8@2020_1/2020/09/01/03-38-06-332_2c9e0b715951e800.webp","sourceBytes":8302,"destBytes":8214,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4234,"convertSpendMs":15,"createdTime":"2020-09-01 11:38:02","host":"us-031*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"8.1 KB","destSize":"8 KB","compressRate":"98.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829026","sourceStatusCode":200,"destWidth":452,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx33/cdn39@2020_4/2020/09/01/03-38-06-544_02ac04abae4be91f.webp","sourceBytes":61866,"destBytes":15236,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":3820,"convertSpendMs":25,"createdTime":"2020-09-01 11:38:03","host":"us-006*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403","githubUser":"myreaderx33","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"60.4 KB","destSize":"14.9 KB","compressRate":"24.6%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVbL8mY","sourceStatusCode":200,"destWidth":800,"destHeight":155,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn3@2020_5/2020/09/01/03-38-06-744_2e834841ee524f0f.webp","sourceBytes":20035,"destBytes":5442,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":4745,"convertSpendMs":11,"createdTime":"2020-09-01 11:38:02","host":"us-53*","referer":"https://segmentfault.com/a/1190000023825926","linkMd5ListStr":"4ea83030c443cca001ccdb773fb8a736","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"19.6 KB","destSize":"5.3 KB","compressRate":"27.2%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023782332","sourceStatusCode":200,"destWidth":800,"destHeight":325,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn70@2020_4/2020/09/01/03-38-07-991_bec13ff2d5db88b9.webp","sourceBytes":44410,"destBytes":22182,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":2307,"convertSpendMs":13,"createdTime":"2020-09-01 11:38:06","host":"us-009*","referer":"https://segmentfault.com/a/1190000023782318","linkMd5ListStr":"c5762ccc3f748952b49f0809e1c1d52e","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"43.4 KB","destSize":"21.7 KB","compressRate":"49.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829031","sourceStatusCode":200,"destWidth":446,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn19@2020_1/2020/09/01/03-38-09-750_f0051cf8e9511243.webp","sourceBytes":4465322,"destBytes":2317306,"targetWebpQuality":75,"feedId":6615,"totalSpendMs":8999,"convertSpendMs":5267,"createdTime":"2020-09-01 11:38:02","host":"europe-22*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"4.3 MB","destSize":"2.2 MB","compressRate":"51.9%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829025","sourceStatusCode":200,"destWidth":446,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn43@2020_2/2020/09/01/03-38-10-106_cb9aeb358d5a2ab3.webp","sourceBytes":6675886,"destBytes":3573690,"targetWebpQuality":60,"feedId":6615,"totalSpendMs":9517,"convertSpendMs":5366,"createdTime":"2020-09-01 11:38:03","host":"europe69*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"6.4 MB","destSize":"3.4 MB","compressRate":"53.5%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000023829027","sourceStatusCode":200,"destWidth":446,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn35@2020_4/2020/09/01/03-38-17-565_db27bcfb0a32ede7.webp","sourceBytes":9143158,"destBytes":2670314,"targetWebpQuality":45,"feedId":6615,"totalSpendMs":16087,"convertSpendMs":12093,"createdTime":"2020-09-01 11:38:03","host":"us-017*","referer":"https://segmentfault.com/a/1190000023829018","linkMd5ListStr":"320be39dd093985807704133bf69c403","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"8.7 MB","destSize":"2.5 MB","compressRate":"29.2%"}],"successGithubMap":{"myreaderx8":4,"myreaderx7":4,"myreaderx15":4,"myreaderx6":4,"myreaderx16":4,"myreaderx10":4,"myreaderx4":4,"myreaderx32":4,"myreaderx11":4,"myreaderx33":4,"myreaderx3":4,"myreaderx2":4,"myreaderx12":4,"myreaderx1":4,"myreaderx13":4,"myreaderx30":3,"myreaderx31":3,"myreaderx18":3,"myreaderx19":4,"myreaderx":4,"myreaderx25":4,"myreaderx27":3,"myreaderx21":4,"myreaderx22":4,"myreaderx24":3,"myreaderx5oss":3,"myreaderx29":4},"failGithubMap":{"myreaderx14":4,"myreaderx23":3}}