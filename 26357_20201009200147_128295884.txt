{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-10 04:01:21","updatedTime":"2020-10-10 04:01:21","title":"Java 单例真的写对了么?","link":"https://www.race604.com/java-double-checked-singleton/","description":"<img src=\"https://img.race604.com/IMG_20160211_144329.jpg\" alt=\"Java 单例真的写对了么?\"><p>单例模式是最简单的设计模式，实现也非常“简单”。一直以为我写没有问题，直到被 Coverity 打脸。</p>\n\n<h2 id=\"1\">1. 暴露问题</h2>\n\n<p>前段时间，有段代码被 Coverity 警告了，简化一下代码如下，为了方便后面分析，我在这里标上了一些序号：</p>\n\n<pre><code class=\"language-java\">private static SettingsDbHelper sInst = null;  \npublic static SettingsDbHelper getInstance(Context context) {  \n    if (sInst == null) {                              // 1\n        synchronized (SettingsDbHelper.class) {       // 2\n            SettingsDbHelper inst = sInst;            // 3\n            if (inst == null) {                       // 4\n                inst = new SettingsDbHelper(context); // 5\n                sInst = inst;                         // 6\n            }\n        }\n    }\n    return sInst;                                     // 7\n}\n</code></pre>\n\n<p>大家知道，这可是高大上的 <em>Double Checked locking</em> 模式，保证多线程安全，而且高性能的单例实现，比下面的单例实现，“逼格”不知道高到哪里去了：</p>\n\n<pre><code class=\"language-java\">private static SettingsDbHelper sInst = null;  \npublic static synchronized SettingsDbHelper getInstance(Context context) {  \n    if (sInst == null) {\n        sInst = new SettingsDbHelper(context);\n    }\n    return sInst;\n}\n</code></pre>\n\n<p>你一个机器人竟敢警告我代码写的不对，我一度怀疑它不认识这种写法（后面将证明我是多么幼稚，啪。。。）。然后，它认真的给我分析这段代码为什么有问题，如下图所示：</p>\n\n<p><img src=\"https://img.race604.com/coverity-report.jpg\" alt=\"Java 单例真的写对了么?\"></p>\n\n<h2 id=\"2\">2. 原因分析</h2>\n\n<p>Coverity 是静态代码分析工具，它会模拟其实际运行情况。例如这里，假设有两个线程进入到这段代码，其中红色的部分是运行的步骤解析，开头的标号表示其运行顺序。关于 Coverity 的详细文档可以参考<a href=\"https://ondemand.coverity.com/reference/\">这里</a>，这里简单解析一下其运行情况如下：</p>\n\n<ol>\n<li>线程 1 运行到 1 处，第一次进入，这里肯定是为 <code>true</code> 的；  </li>\n<li>线程 1 运行到 2 处，获得锁 <code>SettingsDbHelper.class</code>；  </li>\n<li>线程 1 运行到 3 和 4 处，赋值 <code>inst = sInst</code>，这时 sInst 还是 null，所以继续往下运行，创建一个新的实例；  </li>\n<li>线程 1 运行到 6 处，修改 sInst 的值。这一步非常关键，这里的解析是，因为这些修改可能因为和其他赋值操作运行被重新排序（Re-order），这就可能导致先修改了 sInst 的值，而 <code>new SettingsDbHelper(context)</code> 这个构造函数并没有执行完。而在这个时候，程序切换到线程 2；  </li>\n<li>线程 2 运行到 1 处，因为第 4 步的时候，线程 1 已经给 sInst 赋值了，所以 <code>sInst == null</code> 的判断为 <code>false</code>，线程 2 就直接返回 sInst 了，但是这个时候 sInst 并没有被初始化完成，直接使用它可能会导致程序崩溃。</li>\n</ol>\n\n<p>上面解析得好像很清楚，但是关键在第 4 步，为什么会出现 Re-Order？赋值了，但没有初始化又是怎么回事？这是由于 Java 的内存模型决定的。问题主要出现在这 5 和 6 两行，这里的构造函数可能会被编译成内联的（inline），在 Java 虚拟机中运行的时候编译成执行指令以后，可以用如下的伪代码来表示：</p>\n\n<pre><code>inst = allocat()； // 分配内存  \nsInst = inst;  \nconstructor(inst); // 真正执行构造函数  \n</code></pre>\n\n<p>说到内存模型，这里就不小心触及了 Java 中比较复杂的内容——多线程编程和 Java 内存模型。在这里，我们可以简单的理解就是，构造函数可能会被分为两块：先分配内存并赋值，再初始化。关于 Java 内存模型（JMM）的详解，可以参考这个系列文章 <a href=\"http://www.infoq.com/cn/articles/java-memory-model-1\">《深入理解Java内存模型》</a>，一共有 7 篇（<a href=\"http://www.infoq.com/cn/articles/java-memory-model-1\">一</a>，<a href=\"http://www.infoq.com/cn/articles/java-memory-model-2\">二</a>，<a href=\"http://www.infoq.com/cn/articles/java-memory-model-3\">三</a>，<a href=\"http://www.infoq.com/cn/articles/java-memory-model-4\">四</a>，<a href=\"http://www.infoq.com/cn/articles/java-memory-model-5\">五</a>，<a href=\"http://www.infoq.com/cn/articles/java-memory-model-6\">六</a>，<a href=\"http://www.infoq.com/cn/articles/java-memory-model-7\">七</a>）。</p>\n\n<h2 id=\"3\">3. 解决方案</h2>\n\n<p>上面的问题的解决方法是，在 Java 5 之后，引入扩展关键字 <code>volatile</code> 的功能，它能保证：</p>\n\n<blockquote>\n  <p>对 <code>volatile</code> 变量的写操作，不允许和它之前的读写操作打乱顺序；对 <code>volatile</code> 变量的读操作，不允许和它之后的读写乱序。</p>\n</blockquote>\n\n<p>关于 <strong>volatile</strong> 关键字原理详解请参考上面的 <a href=\"http://www.infoq.com/cn/articles/java-memory-model-4\"><em>深入理解内存模型（四）</em></a>。</p>\n\n<p>所以，上面的操作，只需要对 sInst 变量添加 <code>volatile</code> 关键字修饰即可。但是，我们知道，对 volatile 变量的读写操作是一个比较重的操作，所以上面的代码还可以优化一下，如下：</p>\n\n<pre><code class=\"language-java\">private static volatile SettingsDbHelper sInst = null;  // &#60;&#60;&#60; 这里添加了 volatile  \npublic static SettingsDbHelper getInstance(Context context) {  \n    SettingsDbHelper inst = sInst;  // &#60;&#60;&#60; 在这里创建临时变量\n    if (inst == null) {\n        synchronized (SettingsDbHelper.class) {\n            inst = sInst;\n            if (inst == null) {\n                inst = new SettingsDbHelper(context);\n                sInst = inst;\n            }\n        }\n    }\n    return inst;  // &#60;&#60;&#60; 注意这里返回的是临时变量\n}\n</code></pre>\n\n<p>通过这样修改以后，在运行过程中，除了第一次以外，其他的调用只要访问 volatile 变量 sInst 一次，这样能提高 25% 的性能（<a href=\"https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java\">Wikipedia</a>）。</p>\n\n<p>有读者提到，这里为什么需要再定义一个临时变量 <code>inst</code>？通过前面的对 <em>volatile</em> 关键字作用解释可知，访问 volatile 变量，需要保证一些执行顺序，所以的开销比较大。这里定义一个临时变量，在 <code>sInst</code> 不为空的时候（这是绝大部分的情况），只要在开始访问一次 volatile 变量，返回的是临时变量。如果没有此临时变量，则需要访问两次，而降低了效率。</p>\n\n<p>最后，关于单例模式，还有一个更有趣的实现，它能够延迟初始化（lazy initialization），并且多线程安全，还能保证高性能，如下：</p>\n\n<pre><code class=\"language-java\">class Foo {  \n    private static class HelperHolder {\n       public static final Helper helper = new Helper();\n    }\n\n    public static Helper getHelper() {\n        return HelperHolder.helper;\n    }\n}\n</code></pre>\n\n<p>延迟初始化，这里是利用了 Java 的语言特性，内部类只有在使用的时候，才回去加载，从而初始化内部静态变量。关于线程安全，这是 Java 运行环境自动给你保证的，在加载的时候，会自动隐形的同步。在访问对象的时候，不需要同步 Java 虚拟机又会自动给你取消同步，所以效率非常高。</p>\n\n<p>另外，关于 <strong>final</strong> 关键字的原理，请参考 <a href=\"http://www.infoq.com/cn/articles/java-memory-model-6\"><em>深入理解Java内存模型（六）</em></a>。</p>\n\n<p>补充一下，有同学提醒有一种更加 Hack 的实现方式--单个成员的<strong>枚举</strong>，据称是最佳的单例实现方法，如下：</p>\n\n<pre><code class=\"language-java\">public enum Foo {  \n    INSTANCE;\n}\n</code></pre>\n\n<p>详情可以参考 <a href=\"http://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java\">这里</a>。</p>\n\n<h3 id=\"4\">4. 总结</h3>\n\n<p>在 Java 中，涉及到多线程编程，问题就会复杂很多，有些 Bug 甚至会超出你的想象。通过上面的介绍，开始对自己的代码运行情况都不那么自信了。其实大可不必这样担心，这种仅仅发生在多线程编程中，遇到有临界值访问的时候，直接使用 <strong>synchronized</strong> 关键字能够解决绝大部分的问题。</p>\n\n<p>对于 Coverity，开始抱着敬畏知心，它是由一流的计算机科学家创建的。Coverity 作为一个程序，本身知道的东西比我们多得多，而且还比我认真，它指出的问题必须认真对待和分析。</p>\n\n<hr>\n\n<p>参考文章：</p>\n\n<ol>\n<li><a href=\"https://en.wikipedia.org/wiki/Double-checked_locking\">https://en.wikipedia.org/wiki/Double-checked_locking</a>  </li>\n<li><a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html\">http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a>  </li>\n<li><a href=\"http://www.oracle.com/technetwork/articles/javase/bloch-effective-08-qa-140880.html\">http://www.oracle.com/technetwork/articles/javase/bloch-effective-08-qa-140880.html</a>  </li>\n<li><a href=\"http://www.ibm.com/developerworks/java/library/j-dcl/index.html\">http://www.ibm.com/developerworks/java/library/j-dcl/index.html</a>  </li>\n<li><a href=\"http://www.infoq.com/cn/articles/java-memory-model-1\">http://www.infoq.com/cn/articles/java-memory-model-1</a></li>\n</ol>","descriptionType":"html","publishedDate":"Tue, 22 Mar 2016 01:02:00 +0000","feedId":26357,"bgimg":"https://img.race604.com/IMG_20160211_144329.jpg","linkMd5":"1e3d1fb7ffbb0c5483b7e6d861b35f08","sourceBytes":0,"destBytes":0,"author":"Race604","articleImgCdnMap":{"https://img.race604.com/IMG_20160211_144329.jpg":null,"https://img.race604.com/coverity-report.jpg":null},"publishedOrCreatedDate":1602273681370}],"record":{"createdTime":"2020-10-10 04:01:21","updatedTime":"2020-10-10 04:01:21","feedId":26357,"fetchDate":"Fri, 09 Oct 2020 20:01:21 +0000","fetchMs":2140,"handleMs":221,"totalMs":28695,"newArticles":0,"totalArticles":15,"status":1,"type":0,"ip":"a673d2967a041fd98f60051496a85ec7","hostName":"us-039*","requestId":"cd714dea5be74d9b83375a3f6baa3249_26357","contentType":"text/xml; charset=utf-8","totalBytes":0,"bgimgsTotal":1,"bgimgsGithubTotal":0,"articlesImgsTotal":2,"articlesImgsGithubTotal":0,"successGithubMap":{},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:38:21","updatedTime":"2020-09-07 04:38:04","id":26357,"name":"Jlog","url":"http://www.race604.com/rss/","subscriber":124,"website":null,"icon":"https://www.race604.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn29@2020_6/2020/09/06/20-37-26-538_8646508251cd1775.ico","description":"Coding, thoughts. @Android笔记","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2020-10-10 04:01:47","updatedTime":"2020-10-10 04:01:47","id":null,"feedId":26357,"linkMd5":"1e3d1fb7ffbb0c5483b7e6d861b35f08"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1602273678754,"total":0,"statList":[{"spend":2395,"msg":"获取xml内容"},{"spend":252,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":12149,"msg":"正文链接上传到cdn"}]},"extra5":2,"extra6":2,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://img.race604.com/IMG_20160211_144329.jpg","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":26357,"totalSpendMs":6372,"convertSpendMs":0,"createdTime":"2020-10-10 04:01:21","host":"us-017*","referer":"https://www.race604.com/java-double-checked-singleton/","linkMd5ListStr":"1e3d1fb7ffbb0c5483b7e6d861b35f08,1e3d1fb7ffbb0c5483b7e6d861b35f08","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://img.race604.com/IMG_20160211_144329.jpg","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":26357,"totalSpendMs":7442,"convertSpendMs":0,"createdTime":"2020-10-10 04:01:27","host":"us-020*","referer":"https://www.race604.com/java-double-checked-singleton/","linkMd5ListStr":"1e3d1fb7ffbb0c5483b7e6d861b35f08,1e3d1fb7ffbb0c5483b7e6d861b35f08","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://img.race604.com/coverity-report.jpg","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":26357,"totalSpendMs":6245,"convertSpendMs":0,"createdTime":"2020-10-10 04:01:35","host":"us-006*","referer":"https://www.race604.com/java-double-checked-singleton/","linkMd5ListStr":"1e3d1fb7ffbb0c5483b7e6d861b35f08","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"https://img.race604.com/coverity-report.jpg","sourceStatusCode":0,"sourceBytes":0,"destBytes":0,"feedId":26357,"totalSpendMs":5688,"convertSpendMs":0,"createdTime":"2020-10-10 04:01:41","host":"europe-24*","referer":"https://www.race604.com/java-double-checked-singleton/","linkMd5ListStr":"1e3d1fb7ffbb0c5483b7e6d861b35f08","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[0],"sourceSize":"0","destSize":"0"}],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-006.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[0]},"http://europe-24.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[0]}},"extra12ImgCdnSuccessResultVector":[],"successGithubMap":{},"failGithubMap":{}}