{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2021-04-10 00:55:25","updatedTime":"2021-04-10 00:55:25","title":"⚡️ React Native 启动速度优化——Native 篇（内含源码分析）","link":"https://segmentfault.com/a/1190000039797508","description":"<p>Web 开发有一个经典问题：「<strong>浏览器中从输入 URL 到页面渲染的这个过程中都发生了什么？</strong>」</p>\n<p>据我考据这个问题起码有<strong>十年</strong>历史了。在日新月异学不动的前端圈子里，这个问题能一直被问，就是因为因为它是个非常好的问题，涉及非常多的知识点，平时做一些性能优化，都可以从这个问题出发，分析性能瓶颈，然后对症下药进行优化。</p>\n<p>不过今天我们不谈 Web 的性能优化，只是借助刚刚的那个那个经典问题的分析思路，<strong>从 React Native 的启动到页面的第一次渲染完成，结合 React Native 的源码和 1.0 的新架构，一一分析 React Native 的启动性能优化之路</strong>。</p>\n<blockquote>\n 如果你喜欢我的文章，希望点赞👍 收藏 📁 评论 💬 三连支持一下，谢谢你，这对我真的很重要！\n</blockquote>\n<blockquote>\n <strong>阅读提醒</strong>：\n <br>1.文章中的源码内容为 RN 0.64 版本<br>2.源码分析内容涉及 <code>Objective-C</code>、<code>Java</code>、<code>C++</code>、<code>JavaScript</code> 四门语言，我尽量讲得通俗易懂一些，若实在不理解可以直接看结论</br></br>\n</blockquote>\n<h2>0.React Native 启动流程</h2>\n<p>React Native 作为一个 Web 前端友好的混合开发框架，启动时可以大致分为两个部分：</p>\n<ul>\n <li>Native 容器的运行</li>\n <li>JavaScript 代码的运行</li>\n</ul>\n<p>其中 Native 容器启动在现有架构（版本号小于 1.0.0）里：大致可以分为 3 个部分：</p>\n<ul>\n <li>Native 容器初始化</li>\n <li>Native Modules 的<strong>全量</strong>绑定</li>\n <li>JSEngine 的初始化</li>\n</ul>\n<p>容器初始化后，舞台就交给了 JavaScript，流程可以细分为 2 个部分：</p>\n<ul>\n <li>JavaScript 代码的加载、解析和执行</li>\n <li>JS Component 的构建</li>\n</ul>\n<p>最后 JS Thread 把计算好的布局信息发送到 Native 端，计算 Shadow Tree，最后由 UI Thread 进行布局和渲染。</p>\n<blockquote>\n 关于渲染部分的性能优化可以见我之前写的\n <a href=\"https://supercodepower.com/react_native_performance_optimization_guides\" rel=\"nofollow noreferrer\">《React Native 性能优化指南》</a>，我从\n <strong>渲染</strong>、\n <strong>图片</strong>、\n <strong>动画</strong>、\n <strong>长列表</strong>等方向介绍了 RN 渲染优化的常见套路，感兴趣的读者可以前往查看，我这里就不多介绍了。\n</blockquote>\n<p>上面的几个步骤，我画了一张图，下面我以这张图为目录，从左向右介绍各个步骤的优化方向：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039797510\" alt=\"\" title=\"\" /></p>\n<blockquote>\n <strong>提示</strong>：React Native 初始化时，有可能多个任务\n <strong>并行执行</strong>，所以上图只能表示 React Native 初始化的大致流程，并不和实际代码的执行时序一一对应。\n</blockquote>\n<h2>1.升级 React Native</h2>\n<p>想提升 React Native 应用的性能，最一劳永逸的方法就是<strong>升级 RN 的大版本</strong>了。我们的应用从 0.59 升级到 0.62 之后，我们的 APP 没有做任何的性能优化工作，启动时间直接缩短了 1/2。当 React Native 的新架构发布后，启动速度和渲染速度都会大大加强。</p>\n<p>当然，RN 的版本升级并不容易（横跨 iOS Android JS 三端，兼容破坏性更新），我之前写过一篇<a href=\"https://supercodepower.com/docs/react-native-upgrade/index\" rel=\"nofollow noreferrer\">《React Native 升级指南（0.59 -&gt; 0.62）》</a>的文章，如果有升级想法的老铁可以阅读参考一下。</p>\n<h2>2.Native 容器初始化</h2>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039797511\" alt=\"\" title=\"\" /></p>\n<p>容器的初始化肯定是从 APP 的入口文件开始分析，下面我会<strong>挑选一些关键代码</strong>，梳理一下初始化的流程。</p>\n<h3>iOS 源码分析</h3>\n<h4>1.AppDelegate.m</h4>\n<p><code>AppDelegate.m</code> 是 iOS 的入口文件，代码非常精简，主要内容如下所示：</p>\n<pre><code class=\"objectivec\">// AppDelegate.m\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n  // 1.初始化一个 RCTBridge 实现加载 jsbundle 的方法\n  RCTBridge *bridge = [[RCTBridge alloc] initWithDelegate:self launchOptions:launchOptions];\n\n  // 2.利用 RCTBridge 初始化一个 RCTRootView\n  RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge\n                                                   moduleName:@\"RN64\"\n                                            initialProperties:nil];\n\n  // 3.初始化 UIViewController\n  self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n  UIViewController *rootViewController = [UIViewController new];\n  \n  // 4.将 RCTRootView 赋值给 UIViewController 的 view\n  rootViewController.view = rootView;\n  self.window.rootViewController = rootViewController;\n  [self.window makeKeyAndVisible];\n  return YES;\n}</code></pre>\n<p>总的来看入口文件就做了三件事：</p>\n<ul>\n <li>初始化一个 <code>RCTBridge</code> 实现加载 jsbundle 的方法</li>\n <li>利用 <code>RCTBridge</code> 初始化一个 <code>RCTRootView</code></li>\n <li>将 <code>RCTRootView</code> 赋值给 <code>UIViewController</code> 的 view 实现 UI 的挂载</li>\n</ul>\n<p>从入口源码我们可以发现，所有的初始化工作都<strong>指向</strong> <code>RCTRootView</code>，所以接下来我们看看 <code>RCTRootView</code> 干了些啥。</p>\n<h4>2.RCTRootView</h4>\n<p>我们先看一下 <code>RCTRootView</code> 的头文件，删繁就简，我们只看我们关注的一些方法：</p>\n<pre><code class=\"objectivec\">// RCTRootView.h\n\n@interface RCTRootView : UIView\n\n// AppDelegate.m 中用到的初始化方法\n- (instancetype)initWithBridge:(RCTBridge *)bridge\n                    moduleName:(NSString *)moduleName\n             initialProperties:(nullable NSDictionary *)initialProperties NS_DESIGNATED_INITIALIZER;</code></pre>\n<p>从头文件看出：</p>\n<ul>\n <li><code>RCTRootView</code> 继承自 <code>UIView</code>，所以它本质上就是一个 UI 组件；</li>\n <li><code>RCTRootView</code> 调用 <code>initWithBridge</code> 初始化时要传入一个已经初始化的 <code>RCTBridge</code></li>\n</ul>\n<p>在 <code>RCTRootView.m</code> 文件里，<code>initWithBridge</code> 初始化时会监听一系列的 JS 加载监听函数，监听到 JS Bundle 文件加载结束后，就会调用 JS 里的 <code>AppRegistry.runApplication()</code>，启动 RN 应用。</p>\n<p>分析到这里，我们发现 <code>RCTRootView.m</code> 只是实现了对 <code>RCTBridge</code> 的的各种事件监听，<strong>并不是初始化的核心</strong>，所以我们就又要转到 <code>RCTBridge</code> 这个文件上去。</p>\n<h4>3.RCTBridge.m</h4>\n<p><code>RCTBridge.m</code> 里，初始化的调用路径有些长，全贴源码有些长，总之最后调用的是 <code>(void)setUp</code>，核心代码如下：</p>\n<pre><code class=\"objectivec\">- (Class)bridgeClass\n{\n  return [RCTCxxBridge class];\n}\n\n- (void)setUp {\n  // 获取bridgeClass 默认是 RCTCxxBridge\n  Class bridgeClass = self.bridgeClass;\n  // 初始化 RTCxxBridge\n  self.batchedBridge = [[bridgeClass alloc] initWithParentBridge:self];\n  // 启动 RTCxxBridge\n  [self.batchedBridge start];\n}</code></pre>\n<p>我们可以看到，<code>RCTBridge</code> 的初始化又指向了 <code>RTCxxBridge</code>。</p>\n<h4>4.RTCxxBridge.mm</h4>\n<p><code>RTCxxBridge</code> 可以说是 React Native 初始化的<strong>核心</strong>，我查阅了一些资料，貌似 <code>RTCxxBridge</code> 曾用名为 <code>RCTBatchedBridge</code>，所以可以粗暴的把这两个类当成一回事儿。</p>\n<p>因为在 <code>RCTBridge</code> 里调用了 <code>RTCxxBridge</code> 的 <code>start</code> 方法，我们就从 <code>start</code> 方法来看看做了些什么。</p>\n<pre><code class=\"objectivec\">// RTCxxBridge.mm\n\n- (void)start {\n  // 1.初始化 JSThread，后续所有的 js 代码都在这个线程里面执行\n  _jsThread = [[NSThread alloc] initWithTarget:[self class] selector:@selector(runRunLoop) object:nil];\n  [_jsThread start];\n  \n  // 创建并行队列\n  dispatch_group_t prepareBridge = dispatch_group_create();\n  \n  // 2.注册所有的 native modules\n  [self registerExtraModules];\n  (void)[self _initializeModules:RCTGetModuleClasses() withDispatchGroup:prepareBridge lazilyDiscovered:NO];\n  \n  // 3.初始化 JSExecutorFactory 实例\n  std::shared_ptr&lt;JSExecutorFactory&gt; executorFactory;\n  \n  // 4.初始化底层 Instance 实例，也就是 _reactInstance\n  dispatch_group_enter(prepareBridge);\n  [self ensureOnJavaScriptThread:^{\n    [weakSelf _initializeBridge:executorFactory];\n    dispatch_group_leave(prepareBridge);\n  }];\n  \n  // 5.加载 js 代码\n  dispatch_group_enter(prepareBridge);\n  __block NSData *sourceCode;\n  [self\n      loadSource:^(NSError *error, RCTSource *source) {\n        if (error) {\n          [weakSelf handleError:error];\n        }\n\n        sourceCode = source.data;\n        dispatch_group_leave(prepareBridge);\n      }\n      onProgress:^(RCTLoadingProgress *progressData) {\n      }\n  ];\n  \n  // 6.等待 native moudle 和 JS 代码加载完毕后就执行 JS\n  dispatch_group_notify(prepareBridge, dispatch_get_global_queue(QOS_CLASS_USER_INTERACTIVE, 0), ^{\n    RCTCxxBridge *strongSelf = weakSelf;\n    if (sourceCode &amp;&amp; strongSelf.loading) {\n      [strongSelf executeSourceCode:sourceCode sync:NO];\n    }\n  });\n}</code></pre>\n<p>上面代码比较长，里面用到了 <strong>GCD 多线程</strong>的一些知识点，用文字描述大致是如下的流程：</p>\n<ol>\n <li>初始化 js 线程 <code>_jsThread</code></li>\n <li>在主线程上注册所有 <code>native modules</code></li>\n <li>准备 <code>js</code> 和 <code>Native</code> 之间的桥和 js 运行环境</li>\n <li>在 JS 线程上创建消息队列 <code>RCTMessageThread</code>，初始化 <code>_reactInstance</code></li>\n <li>在 JS 线程上加载 JS Bundle</li>\n <li>等上面的事情全部做完后，执行 JS 代码</li>\n</ol>\n<p>其实上面的六个点都可以深挖下去，但是本节涉及到的源码内容到这里就可以了，感兴趣的读者可以结合我最后给出的参考资料和 React Native 源码深挖探索一下。</p>\n<h3>Android 源码分析</h3>\n<h4>1.MainActivity.java &amp; MainApplication.java</h4>\n<p>和 iOS 一样，启动流程我们先从入口文件开始分析，我们先看 <code>MainActivity.java</code>：</p>\n<p><code>MainActivity</code> 继承自 <code>ReactActivity</code>，<code>ReactActivity</code> 又继承自 <code>AppCompatActivity</code>：</p>\n<pre><code class=\"java\">// MainActivity.java\n\npublic class MainActivity extends ReactActivity {\n  // 返回组件名，和 js 入口注册名字一致\n  @Override\n  protected String getMainComponentName() {\n    return \"rn_performance_demo\";\n  }\n}</code></pre>\n<p>我们再从 Android 的入口文件 <code>MainApplication.java</code> 开始分析：</p>\n<pre><code class=\"java\">// MainApplication.java\n\npublic class MainApplication extends Application implements ReactApplication {\n\n  private final ReactNativeHost mReactNativeHost =\n      new ReactNativeHost(this) {\n        // 返回 app 需要的 ReactPackage，添加需要加载的模块，\n        // 这个地方就是我们在项目中添加依赖包时需要添加第三方 package 的地方\n        @Override\n        protected List&lt;ReactPackage&gt; getPackages() {\n          @SuppressWarnings(\"UnnecessaryLocalVariable\")\n          List&lt;ReactPackage&gt; packages = new PackageList(this).getPackages();\n          return packages;\n        }\n\n        // js bundle 入口文件，设置为 index.js\n        @Override\n        protected String getJSMainModuleName() {\n          return \"index\";\n        }\n      };\n\n  @Override\n  public ReactNativeHost getReactNativeHost() {\n    return mReactNativeHost;\n  }\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    // SoLoader：加载C++底层库\n    SoLoader.init(this, /* native exopackage */ false);\n  }\n}</code></pre>\n<p><code>ReactApplication</code> 接口很简单，要求我们创建一个 <code>ReactNativeHost</code> 对象：</p>\n<pre><code class=\"java\">public interface ReactApplication {\n  ReactNativeHost getReactNativeHost();\n}</code></pre>\n<p>从上面的分析我们可以看出一切指向了 <code>ReactNativeHost</code> 这个类，下面我们就看一下它。</p>\n<h4>2.ReactNativeHost.java</h4>\n<p><code>ReactNativeHost</code> 主要的工作就是创建了 <code>ReactInstanceManager</code>:</p>\n<pre><code class=\"java\">public abstract class ReactNativeHost {\n  protected ReactInstanceManager createReactInstanceManager() {\n    ReactMarker.logMarker(ReactMarkerConstants.BUILD_REACT_INSTANCE_MANAGER_START);\n    ReactInstanceManagerBuilder builder =\n        ReactInstanceManager.builder()\n            // 应用上下文\n            .setApplication(mApplication)\n            // JSMainModulePath 相当于应用首页的 js Bundle，可以传递 url 从服务器拉取 js Bundle\n            // 当然这个只在 dev 模式下可以使用\n            .setJSMainModulePath(getJSMainModuleName())\n            // 是否开启 dev 模式\n            .setUseDeveloperSupport(getUseDeveloperSupport())\n            // 红盒的回调\n            .setRedBoxHandler(getRedBoxHandler())\n            .setJavaScriptExecutorFactory(getJavaScriptExecutorFactory())\n            .setUIImplementationProvider(getUIImplementationProvider())\n            .setJSIModulesPackage(getJSIModulePackage())\n            .setInitialLifecycleState(LifecycleState.BEFORE_CREATE);\n\n    // 添加 ReactPackage\n    for (ReactPackage reactPackage : getPackages()) {\n      builder.addPackage(reactPackage);\n    }\n    \n    // 获取 js Bundle 的加载路径\n    String jsBundleFile = getJSBundleFile();\n    if (jsBundleFile != null) {\n      builder.setJSBundleFile(jsBundleFile);\n    } else {\n      builder.setBundleAssetName(Assertions.assertNotNull(getBundleAssetName()));\n    }\n    ReactInstanceManager reactInstanceManager = builder.build();\n    return reactInstanceManager;\n  }\n}</code></pre>\n<h4>3.ReactActivityDelegate.java</h4>\n<p>我们再回到 <code>ReactActivity</code>，它自己并没有做什么事情，所有的功能都由它的委托类 <code>ReactActivityDelegate</code> 来完成，所以我们直接看<code>ReactActivityDelegate</code>是怎么实现的：</p>\n<pre><code class=\"java\">public class ReactActivityDelegate {\n  protected void onCreate(Bundle savedInstanceState) {\n    String mainComponentName = getMainComponentName();\n    mReactDelegate =\n        new ReactDelegate(\n            getPlainActivity(), getReactNativeHost(), mainComponentName, getLaunchOptions()) {\n          @Override\n          protected ReactRootView createRootView() {\n            return ReactActivityDelegate.this.createRootView();\n          }\n        };\n    if (mMainComponentName != null) {\n      // 载入 app 页面\n      loadApp(mainComponentName);\n    }\n  }\n  \n  protected void loadApp(String appKey) {\n    mReactDelegate.loadApp(appKey);\n    // Activity 的 setContentView() 方法\n    getPlainActivity().setContentView(mReactDelegate.getReactRootView());\n  }\n}</code></pre>\n<p><code>onCreate()</code> 的时候又实例化了一个 <code>ReactDelegate</code>，我们再看看它的实现。</p>\n<h4>4.ReactDelegate.java</h4>\n<p>在 <code>ReactDelegate.java</code> 里，我没看见它做了两件事：</p>\n<ul>\n <li>创建 <code>ReactRootView</code> 作为根视图</li>\n <li>调用 <code>getReactNativeHost().getReactInstanceManager()</code> 启动 RN 应用</li>\n</ul>\n<pre><code class=\"java\">public class ReactDelegate {\n  public void loadApp(String appKey) {\n    if (mReactRootView != null) {\n      throw new IllegalStateException(\"Cannot loadApp while app is already running.\");\n    }\n    // 创建 ReactRootView 作为根视图\n    mReactRootView = createRootView();\n    // 启动 RN 应用\n    mReactRootView.startReactApplication(\n        getReactNativeHost().getReactInstanceManager(), appKey, mLaunchOptions);\n  }\n}</code></pre>\n<p>基础的启动流程本节涉及到的源码内容到这里就可以了，感兴趣的读者可以结合我最后给出的参考资料和 React Native 源码深挖探索一下。</p>\n<h3>优化建议</h3>\n<p>对于 React Native 为主体的应用，APP 启动后就要立马初始化 RN 容器，基本上没有什么优化思路；但是 Native 为主的混合开发 APP 却有招：</p>\n<p><strong>既然初始化耗时最长，我们在正式进入 React Native 容器前提前初始化不就好了？</strong></p>\n<p>这个方法非常的常见，因为很多 H5 容器也是这样做的。正式进入 WebView 网页前，先做一个 WebView 容器池，提前初始化 WebView，进入 H5 容器后，直接加载数据渲染，以达到网页秒开的效果。</p>\n<p><strong>RN 容器池</strong>这个概念看着很玄乎，其实就是一个 <code>Map</code>，<code>key</code> 为 RN 页面的 <code>componentName</code>（即 <code>AppRegistry.registerComponent(appName, Component)</code> 中传入的 <code>appName</code>），<code>value</code> 就是一个已经实例化的 <code>RCTRootView/ReactRootView</code>。</p>\n<p>APP 启动后找个触发时机提前初始化，进入 RN 容器前先读容器池，如果有匹配的容器，直接拿来用即可，没有匹配的再重新初始化。</p>\n<p>写两个很简单的案例，iOS 可以如下图所示，构建 RN 容器池：</p>\n<pre><code class=\"objectivec\">@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, RCTRootView *&gt; *rootViewRool;\n\n// 容器池\n-(NSMutableDictionary&lt;NSString *, RCTRootView *&gt; *)rootViewRool {\n  if (!_rootViewRool) {\n    _rootViewRool = @{}.mutableCopy;\n  }\n  \n  return _rootViewRool;\n}\n\n\n// 缓存 RCTRootView\n-(void)cacheRootView:(NSString *)componentName path:(NSString *)path props:(NSDictionary *)props bridge:(RCTBridge *)bridge {\n  // 初始化\n  RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge\n                                                   moduleName:componentName\n                                            initialProperties:props];\n  // 实例化后要加载到屏幕的最下面，否则不能触发视图渲染\n  [[UIApplication sharedApplication].keyWindow.rootViewController.view insertSubview:rootView atIndex:0];\n  rootView.frame = [UIScreen mainScreen].bounds;\n  \n  // 把缓存好的 RCTRootView 放到容器池中\n  NSString *key = [NSString stringWithFormat:@\"%@_%@\", componentName, path];\n  self.rootViewRool[key] = rootView;\n}\n\n\n// 读取容器\n-(RCTRootView *)getRootView:(NSString *)componentName path:(NSString *)path props:(NSDictionary *)props bridge:(RCTBridge *)bridge {\n  NSString *key = [NSString stringWithFormat:@\"%@_%@\", componentName, path];\n  RCTRootView *rootView = self.rootViewRool[key];\n  if (rootView) {\n    return rootView;\n  }\n  \n  // 兜底逻辑\n  return [[RCTRootView alloc] initWithBridge:bridge moduleName:componentName initialProperties:props];\n}</code></pre>\n<p>Android 如下构建 RN 容器池：</p>\n<pre><code class=\"java\">private HashMap&lt;String, ReactRootView&gt; rootViewPool = new HashMap&lt;&gt;();\n\n// 创建容器\nprivate ReactRootView createRootView(String componentName, String path, Bundle props, Context context) {\n    ReactInstanceManager bridgeInstance = ((ReactApplication) application).getReactNativeHost().getReactInstanceManager();\n    ReactRootView rootView = new ReactRootView(context);\n\n    if(props == null) {\n        props = new Bundle();\n    }\n    props.putString(\"path\", path);\n\n    rootView.startReactApplication(bridgeInstance, componentName, props);\n\n    return rootView;\n}\n\n// 缓存容器\npublic void cahceRootView(String componentName, String path, Bundle props, Context context) {\n    ReactRootView rootView = createRootView(componentName, path, props, context);\n    String key = componentName + \"_\" + path;\n\n    // 把缓存好的 RCTRootView 放到容器池中\n    rootViewPool.put(key, rootView);\n}\n\n// 读取容器\npublic ReactRootView getRootView(String componentName, String path, Bundle props, Context context) {\n    String key = componentName + \"_\" + path;\n    ReactRootView rootView = rootViewPool.get(key);\n\n    if (rootView != null) {\n        rootView.setAppProperties(newProps);\n        rootViewPool.remove(key);\n        return rootView;\n    }\n\n    // 兜底逻辑\n    return createRootView(componentName, path, props, context);\n}</code></pre>\n<p>当然，由于每次 <code>RCTRootView/ReactRootView</code> 都要占用一定的内存，所以什么时候实例化，实例化几个容器，池的大小限制，什么时候清除容器，都需要结合业务进行实践和摸索。</p>\n<h2>3.Native Modules 绑定</h2>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039797515\" alt=\"\" title=\"\" /></p>\n<h3>iOS 源码分析</h3>\n<p>iOS 的 Native Modules 有 3 块儿内容，大头是中间的 <code>_initializeModules</code> 函数：</p>\n<pre><code class=\"objectivec\">// RCTCxxBridge.mm\n\n- (void)start {\n  // 初始化 RCTBridge 时调用 initWithBundleURL_moduleProvider_launchOptions 中的 moduleProvider 返回的 native modules\n  [self registerExtraModules];\n  \n  // 注册所有的自定义 Native Module\n  (void)[self _initializeModules:RCTGetModuleClasses() withDispatchGroup:prepareBridge lazilyDiscovered:NO];\n  \n  // 初始化所有懒加载的 native module，只有用 Chrome debug 时才会调用\n  [self registerExtraLazyModules];\n}</code></pre>\n<p>我们看看 <code>_initializeModules</code> 函数做了什么：</p>\n<pre><code class=\"objectivec\">// RCTCxxBridge.mm\n\n- (NSArray&lt;RCTModuleData *&gt; *)_initializeModules:(NSArray&lt;Class&gt; *)modules\n                               withDispatchGroup:(dispatch_group_t)dispatchGroup\n                                lazilyDiscovered:(BOOL)lazilyDiscovered\n{\n    for (RCTModuleData *moduleData in _moduleDataByID) {\n      if (moduleData.hasInstance &amp;&amp; (!moduleData.requiresMainQueueSetup || RCTIsMainQueue())) {\n        // Modules that were pre-initialized should ideally be set up before\n        // bridge init has finished, otherwise the caller may try to access the\n        // module directly rather than via `[bridge moduleForClass:]`, which won't\n        // trigger the lazy initialization process. If the module cannot safely be\n        // set up on the current thread, it will instead be async dispatched\n        // to the main thread to be set up in _prepareModulesWithDispatchGroup:.\n        (void)[moduleData instance];\n      }\n    }\n    _moduleSetupComplete = YES;\n    [self _prepareModulesWithDispatchGroup:dispatchGroup];\n}</code></pre>\n<p>根据 <code>_initializeModules</code> 和 <code>_prepareModulesWithDispatchGroup</code> 的注释，可以看出 iOS 在 JS Bundle 加载的过程中（在 <strong>JSThead 线程</strong>进行），同时在<strong>主线程</strong>初始化所有的 Native Modules。</p>\n<p>结合前面的源码分析，我们可以看出 React Native iOS 容器初始化的时候，会<strong>初始化所有的 Native Modules</strong>，若 <code>Native Modules</code> 比较多，就会影响 Android RN 容器的启动时间。</p>\n<h3>Android 源码分析</h3>\n<p>关于 Native Modules 的注册，其实在 <code>MainApplication.java</code> 这个入口文件里已经给出了线索：</p>\n<pre><code class=\"java\">// MainApplication.java\n\nprotected List&lt;ReactPackage&gt; getPackages() {\n  @SuppressWarnings(\"UnnecessaryLocalVariable\")\n  List&lt;ReactPackage&gt; packages = new PackageList(this).getPackages();\n  // Packages that cannot be autolinked yet can be added manually here, for example:\n  // packages.add(new MyReactNativePackage());\n  return packages;\n}</code></pre>\n<p>由于 0.60 之后 React Native 启用了 <code>auto link</code>，安装的第三方 Native Modules 都在 <code>PackageList</code> 里，所以我们只要 <code>getPackages()</code> 一下就能获取 <code>auto link</code> 的 Modules。</p>\n<p>源码里，在 <code>ReactInstanceManager.java</code> 这个文件中，会运行 <code>createReactContext()</code> 创建 <code>ReactContext</code>，这里面有一步就是注册 <code>nativeModules</code> 的注册表：</p>\n<pre><code class=\"java\">// ReactInstanceManager.java\n\nprivate ReactApplicationContext createReactContext(\n  JavaScriptExecutor jsExecutor, \n  JSBundleLoader jsBundleLoader) {\n  \n  // 注册 nativeModules 注册表\n  NativeModuleRegistry nativeModuleRegistry = processPackages(reactContext, mPackages, false);\n}</code></pre>\n<p>根据函数调用，我们追踪到 <code>processPackages()</code> 这个函数里，利用一个 for 循环把 mPackages 里的 Native Modules 全部加入注册表：</p>\n<pre><code class=\"java\">// ReactInstanceManager.java\n\nprivate NativeModuleRegistry processPackages(\n    ReactApplicationContext reactContext,\n    List&lt;ReactPackage&gt; packages,\n    boolean checkAndUpdatePackageMembership) {\n  // 创建 JavaModule 注册表 Builder，用来创建 JavaModule 注册表，\n  // JavaModule 注册表将所有的 JavaModule 注册到 CatalystInstance 中\n  NativeModuleRegistryBuilder nativeModuleRegistryBuilder =\n      new NativeModuleRegistryBuilder(reactContext, this);\n\n  // 给 mPackages 加锁\n  // mPackages 类型为 List&lt;ReactPackage&gt;，与 MainApplication.java 里的 packages 对应\n  synchronized (mPackages) {\n    for (ReactPackage reactPackage : packages) {\n      try {\n        // 循环处理我们在 Application 里注入的 ReactPackage，处理的过程就是把各自的 Module 添加到对应的注册表中\n        processPackage(reactPackage, nativeModuleRegistryBuilder);\n      } finally {\n        Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);\n      }\n    }\n  }\n\n  NativeModuleRegistry nativeModuleRegistry;\n  try {\n    // 生成 Java Module 注册表\n    nativeModuleRegistry = nativeModuleRegistryBuilder.build();\n  } finally {\n    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);\n    ReactMarker.logMarker(BUILD_NATIVE_MODULE_REGISTRY_END);\n  }\n\n  return nativeModuleRegistry;\n}</code></pre>\n<p>最后调用 <code>processPackage()</code> 进行真正的注册：</p>\n<pre><code class=\"java\">// ReactInstanceManager.java\n\nprivate void processPackage(\n    ReactPackage reactPackage,\n    NativeModuleRegistryBuilder nativeModuleRegistryBuilder\n) {\n  nativeModuleRegistryBuilder.processPackage(reactPackage);\n}</code></pre>\n<p>从上面的流程可以看出，Android 注册 <code>Native Modules</code> 的时候是<strong>同步全量注册</strong>的，若 <code>Native Modules</code> 比较多，就会影响 Android RN 容器的启动时间。</p>\n<h3>优化建议</h3>\n<p>说实话，<strong>Native Modules 全量绑定在现有的架构里是无解的</strong>：不管这个 Native Methods 你有没有用到，容器启动时先全部初始化一遍。在新的 RN 架构里，TurboModules 会解决这个问题（本文下一小节会介绍）。</p>\n<p>如果非要说优化，其实还有个思路，你不是全量初始化吗，那我让 Native Modules 的数量减少不就行了？新架构里有一步叫做 <strong>Lean Core</strong>，就是精简 React Native 核心，把一些功能/组件从 RN 的主工程项目里移出去（例如 <code>WebView</code> 组件），交给社区维护，你想用的时候再单独下载集成。</p>\n<p>这样做的好处主要有几点：</p>\n<ul>\n <li>核心更加精简，RN 维护者有更多的精力维护主要功能</li>\n <li>减小 Native Modules 的绑定耗时和多余的 JS 加载时间，包体积的减小，对初始化性能更友好（我们升级 RN 版本到 0.62 后初始化速度提升一倍，基本都是 Lean Core 的功劳）</li>\n <li>加快迭代速度，优化开发体验等</li>\n</ul>\n<p>现在 <strong>Lean Core</strong> 的工作基本已经完成，更多讨论可见<a href=\"https://github.com/react-native-community/discussions-and-proposals/issues/6\" rel=\"nofollow noreferrer\">官方 issues 讨论区</a>，我们只要同步升级 React Native 版本就可以享用 <strong>Lean Core</strong> 的成果。</p>\n<h2>4.RN 新架构如何优化启动性能</h2>\n<p>React Native 新架构已经跳票快两年了，每次问进度，官方回复都是“别催了别催了在做了在做了”。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039797513\" alt=\"\" title=\"\" /></p>\n<p>我个人去年期待了一整年，但是啥都没等到，所以 RN 啥时候更新到 1.0.0 版本，我已经不在乎了。虽然 RN 官方一直在鸽，但是不得不说他们的新架构还是有些东西的，市面上存在关于 RN 新架构的文章和视频我基本都看了一遍，所以个人对新架构还是有个整体的认知。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039797512\" alt=\"\" title=\"\" /></p>\n<p>因为新架构还没有正式放出，所以具体细节上肯定还存在一些差异，具体执行细节还是要等 React Native 官方为准。</p>\n<h3>JSI</h3>\n<p>JSI 的全名是 <strong>JavaScript Interface</strong>，一个用 C++ 写的框架，作用是<strong>支持 JS 直接调用 Native 方法</strong>，而不是现在通过 Bridge 异步通讯。</p>\n<p>JS 直接调用 Native 如何理解呢？我们举一个最简单的例子。在浏览器上调用 <code>setTimeout</code> <code>document.getElementById</code> 这类 API 的时候，其实就是在 JS 侧直接调用 Native Code，我们可以在浏览器控制台里验证一下：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000039797514\" alt=\"\" title=\"\" /></p>\n<p>比如说我执行了一条命令：</p>\n<pre><code class=\"javascript\">let el = document.createElement('div')</code></pre>\n<p>变量 <code>el</code> 持有的不是一个 JS 对象，而是一个在 C++ 中被实例化的对象。对于 el 持有的这个对象我们再设置一下相关属性：</p>\n<pre><code class=\"javascript\">el.setAttribute('width', 100)</code></pre>\n<p>这时候其实是 JS <strong>同步调用</strong> C++ 中的 <code>setWidth</code> 方法，改变这个元素的宽度。</p>\n<p>React Native 新架构中的 JSI，主要就是起这个作用的，借助 JSI，我们可以用 JS 直接获得 C++ 对象的引用（<strong>Host Objects</strong>），进而直接控制 UI，直接调用 Native Modules 的方法，省去 bridge 异步通讯的开销。</p>\n<p>下面我们举个小例子，来看一下 Java/OC 如何借助 JSI 向 JS 暴露同步调用的方法。</p>\n<pre><code class=\"cpp\">#pragma once\n\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\n#include &lt;jsi/jsi.h&gt;\n\n// SampleJSIObject 继承自 HostObject，表示这个一个暴露给 JS 的对象\n// 对于 JS 来说，JS 可以直接同步调用这个对象上的属性和方法\nclass JSI_EXPORT SampleJSIObject : public facebook::jsi::HostObject {\n\npublic: \n\n// 第一步\n// 将 window.__SampleJSIObject 暴露给JavaScript\n// 这是一个静态函数，一般在应用初始化时从 ObjC/Java 中调用\nstatic void SampleJSIObject::install(jsi::Runtime &amp;runtime) {\n  runtime.global().setProperty(\n      runtime,\n      \"__sampleJSIObject\",\n      jsi::Function::createFromHostFunction(\n          runtime,\n          jsi::PropNameID::forAscii(runtime, \"__SampleJSIObject\"),\n          1,\n          [binding](jsi::Runtime&amp; rt, const jsi::Value&amp; thisVal, const jsi::Value* args, size_t count) {\n            // 返回调用 window.__SampleJSIObject 时得到的内容\n            return std::make_shared&lt;SampleJSIObject&gt;();\n          }));\n}\n\n// 类似于 getter，每次 JS 访问这个对象的时候，都要经过这个方法，作用类似于一个包装器\n// 比如说我们调用 window.__sampleJSIObject.method1()，这个方法就会被调用\njsi::Value TurboModule::get(jsi::Runtime&amp; runtime, const jsi::PropNameID&amp; propName) {\n  // 调用方法名\n  // 比如说调用 window.__sampleJSIObject.method1() 时，propNameUtf8 就是 method1\n  std::string propNameUtf8 = propName.utf8(runtime);\n\n  return jsi::Function::createFromHostFunction(\n    runtime,\n    propName,\n    argCount,\n    [](facebook::jsi::Runtime &amp;rt, const facebook::jsi::Value &amp;thisVal, const facebook::jsi::Value *args, size_t count) {\n      if (propNameUtf8 == 'method1') {\n        // 调用 method1 时，相关的函数处理逻辑\n      }\n    });\n}\n  \nstd::vector&lt;PropNameID&gt; getPropertyNames(Runtime&amp; rt){\n}\n  \n}</code></pre>\n<p>上面的例子比较简短，想要深入了解 JSI，可以看<a href=\"https://medium.com/@christian.falch/https-medium-com-christian-falch-react-native-jsi-challenge-1201a69c8fbf\" rel=\"nofollow noreferrer\">《React Native JSI Challenge》</a>这篇文章或直接阅读源码。</p>\n<h3>TurboModules</h3>\n<p>经过前面的源码分析，我们可以得知，现有架构里，Native 初始化时会<strong>全量加载 native modules</strong>，随着业务的迭代，native modules 只会越来越多，这里的耗时会越来越长。</p>\n<p>TurboModules 就可以一次性解决这个问题。在新架构里，native modules 是<strong>懒加载</strong>的，也就是说只有你调用相应的 native modules 时才会初始化加载，这样就解决了初始化全量加载耗时较长的问题。</p>\n<p>TurboModules 的调用路径大概是这样的：</p>\n<ol>\n <li>先用 JSI 创建一个顶层的「Native Modules Proxy」，称之为 <code>global.__turboModuleProxy</code></li>\n <li>访问一个 Native Modules，比如说要访问 <code>SampleTurboModule</code>，我们先在 JavaScript 侧执行 <code>require('NativeSampleTurboModule')</code></li>\n <li>在 NativeSampleTurboModule.js 这个文件里，我们先调用 <code>TurboModuleRegistry.getEnforcing()</code>，然后就会调用 <code>global.__turboModuleProxy(\"SampleTurboModule\")</code></li>\n <li>调用 <code>global.__turboModuleProxy</code> 的时候，就会调用第一步 JSI 暴露的 Native 方法，这时候 C++ 层通过传入的字符串 \"SampleTurboModule\"，找到 ObjC/Java 的实现，最后返回一个对应的 JSI 对象</li>\n <li>现在我们得到了 <code>SampleTurboModule</code> 的 JSI 对象，就可以用 JavaScript 同步调用 JSI 对象上的属性和方法</li>\n</ol>\n<p>通过上面的步骤，我们可以看到借助 TurboModules， Native Modules 只有<strong>初次调用</strong>的时候才会加载，这样就彻底干掉 React Native 容器初始化时<strong>全量加载</strong> Native Modules 时的时间；同时我们可以借助 JSI 实现 JS 和 Native 的同步调用，耗时更少，效率更高。</p>\n<h2>总结</h2>\n<p>本文主要从 <strong>Native</strong> 的角度出发，从源码分析 React Native <strong>现有架构</strong>的启动流程，总结了几个 Native 层的性能优化点；最后又简单介绍了一下React Native 的<strong>新架构</strong>。下一篇文章我会讲解如何从 <strong>JavaScript</strong> 入手，优化 React Native 的启动速度。</p>\n<hr>\n <blockquote>\n  如果你喜欢我的文章，希望点赞👍 收藏 📁 评论 💬 三连支持一下，谢谢你，这对我真的很重要！\n </blockquote>\n <p>欢迎大家关注我的微信公众号：卤蛋实验室，目前专注前端技术，对图形学也有一些微小研究。</p>\n <p>原文链接 👉 <a href=\"https://supercodepower.com/react-native-performance-native\" rel=\"nofollow noreferrer\">⚡️ React Native 启动速度优化——Native 篇（内含源码分析）</a>：更新更及时，阅读体验更佳</p>\n <h2>参考</h2>\n <p><a href=\"https://supercodepower.com/react_native_performance_optimization_guides\" rel=\"nofollow noreferrer\">React Native 性能优化指南</a></p>\n <p><a href=\"https://supercodepower.com/docs/react-native-upgrade/index\" rel=\"nofollow noreferrer\">React Native 升级指南（0.59 -&gt; 0.62）</a></p>\n <p><a href=\"https://www.youtube.com/watch?v=nphKGWjhg2M\" rel=\"nofollow noreferrer\">Chain React 2019 - Ram Narasimhan - Performance in React Native</a></p>\n <p><a href=\"http://blog.nparashuram.com/2019/01/react-natives-new-architecture-glossary.html#turbomodules\" rel=\"nofollow noreferrer\">React Native's new architecture - Glossary of terms</a></p>\n <p><a href=\"https://medium.com/@christian.falch/https-medium-com-christian-falch-react-native-jsi-challenge-1201a69c8fbf\" rel=\"nofollow noreferrer\">React Native JSI Challenge</a></p>\n <p><a href=\"https://github.com/react-native-community/discussions-and-proposals/blob/master/proposals/0002-Turbo-Modules.md\" rel=\"nofollow noreferrer\">RFC0002: Turbo Modules ™</a></p>\n <p><a href=\"https://mrgaogang.github.io/react/ReactNative%E4%B8%8EiOS%E5%8E%9F%E7%94%9F%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96.html#%E7%BC%98%E8%B5%B7\" rel=\"nofollow noreferrer\">ReactNative与iOS原生通信原理解析-初始化</a></p>\n <p><a href=\"http://slides.com/qianmeng/react-native-ios-sourceread\" rel=\"nofollow noreferrer\">React Native iOS 源码解析</a></p>\n <p><a href=\"https://github.com/sucese/react-native/blob/master/doc/ReactNative%E6%BA%90%E7%A0%81%E7%AF%87/1ReactNative%E6%BA%90%E7%A0%81%E7%AF%87%EF%BC%9A%E6%BA%90%E7%A0%81%E5%88%9D%E8%AF%86.md\" rel=\"nofollow noreferrer\">ReactNative源码篇：源码初识</a></p>\n <p><a href=\"https://time.geekbang.org/dailylesson/detail/100056865\" rel=\"nofollow noreferrer\">如何用React Native预加载方案解决白屏问题</a></p>\n <hr />\n</hr>","descriptionType":"html","publishedDate":"Fri, 09 Apr 2021 02:39:20 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000039797510","linkMd5":"852ec7d4f8235e20bd252fb4a7b4e21e","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn26@2020_4/2021/04/09/16-55-35-700_2768b2a846aa0ade.webp","destWidth":732,"destHeight":275,"sourceBytes":46630,"destBytes":46630,"author":"卤代烃","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000039797510":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn26@2020_4/2021/04/09/16-55-35-700_2768b2a846aa0ade.webp","https://segmentfault.com/img/remote/1460000039797511":null,"https://segmentfault.com/img/remote/1460000039797515":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn38@2020_1/2021/04/09/16-55-40-079_baf6e23a018c5a8e.webp","https://segmentfault.com/img/remote/1460000039797513":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn45@2020_6/2021/04/09/16-55-42-425_959a438de45f571b.webp","https://segmentfault.com/img/remote/1460000039797512":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn30@2020_3/2021/04/09/16-55-40-706_80ceb665d1e5953c.webp","https://segmentfault.com/img/remote/1460000039797514":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn39@2020_1/2021/04/09/16-55-40-399_7715f18bb48659c6.webp"},"publishedOrCreatedDate":1617987325018}],"record":{"createdTime":"2021-04-10 00:55:25","updatedTime":"2021-04-10 00:55:25","feedId":6615,"fetchDate":"Fri, 09 Apr 2021 16:55:25 +0000","fetchMs":5432,"handleMs":66,"totalMs":26308,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"5c919425566c2ed25e5b6c5f0652f0b0","hostName":"europe68*","requestId":"0482706d97ff453897b07747c9a4d3bb_6615","contentType":"application/atom+xml; charset=UTF-8","totalBytes":276270,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":6,"articlesImgsGithubTotal":5,"successGithubMap":{"myreaderx25":1,"myreaderx15":1,"myreaderx21":1,"myreaderx12":1,"myreaderx30":1},"failGithubMap":{"myreaderx14":1}},"feed":{"createdTime":"2020-08-25 04:33:08","updatedTime":"2021-04-03 14:32:14","id":6615,"name":"SegmentFault 最新的文章","url":"http://segmentfault.com/feeds/blogs","subscriber":null,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx63/cdn75@2020_2/2021/04/03/06-32-08-760_eb238dca7c8e9f0e.jpg","description":"","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2021-04-10 00:55:42","updatedTime":"2021-04-10 00:55:42","id":null,"feedId":6615,"linkMd5":"852ec7d4f8235e20bd252fb4a7b4e21e"}],"tmpCommonImgCdnBytes":46630,"tmpBodyImgCdnBytes":229640,"tmpBgImgCdnBytes":0,"extra4":{"start":1617987316640,"total":0,"statList":[{"spend":8313,"msg":"获取xml内容"},{"spend":66,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":6373,"msg":"正文链接上传到cdn"}]},"extra5":6,"extra6":6,"extra7ImgCdnFailResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039797511","sourceStatusCode":200,"destWidth":732,"destHeight":275,"sourceBytes":46872,"destBytes":46872,"feedId":6615,"totalSpendMs":3892,"convertSpendMs":0,"createdTime":"2021-04-10 00:55:36","host":"us-029*","referer":"https://segmentfault.com/a/1190000039797508","linkMd5ListStr":"852ec7d4f8235e20bd252fb4a7b4e21e","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn34/contents/2021/04/09/16-55-40-558_dee786269ebc75d0.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 09 Apr 2021 16:55:40 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["CF4E:1395:1054B4B:1AF0B25:6070870C"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1617990096"],"x-ratelimit-used":["61"],"x-xss-protection":["0"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn34/contents/2021/04/09/16-55-40-558_dee786269ebc75d0.webp","historyStatusCode":[],"spendMs":91},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"45.8 KB","destSize":"45.8 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039797511","sourceStatusCode":200,"destWidth":732,"destHeight":275,"sourceBytes":46872,"destBytes":46872,"feedId":6615,"totalSpendMs":1943,"convertSpendMs":0,"createdTime":"2021-04-10 00:55:40","host":"us-004*","referer":"https://segmentfault.com/a/1190000039797508","linkMd5ListStr":"852ec7d4f8235e20bd252fb4a7b4e21e","rawMap":{"githubUrl":"https://api.github.com/repos/myreaderx14/cdn34/contents/2021/04/09/16-55-42-640_dee786269ebc75d0.webp","resp":{"code":403,"msg":"Forbidden","body":"{\n  \"message\": \"API rate limit exceeded for user ID 68584859.\",\n  \"documentation_url\": \"https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\"\n}\n","headerMap":{"access-control-allow-origin":["*"],"access-control-expose-headers":["ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, Deprecation, Sunset"],"content-security-policy":["default-src 'none'"],"content-type":["application/json; charset=utf-8"],"date":["Fri, 09 Apr 2021 16:55:42 GMT"],"referrer-policy":["origin-when-cross-origin, strict-origin-when-cross-origin"],"server":["GitHub.com"],"strict-transport-security":["max-age=31536000; includeSubdomains; preload"],"transfer-encoding":["chunked"],"vary":["Accept-Encoding, Accept, X-Requested-With"],"x-accepted-oauth-scopes":["repo"],"x-content-type-options":["nosniff"],"x-frame-options":["deny"],"x-github-media-type":["github.v3; format=json"],"x-github-request-id":["8D5A:6E89:126927:50401F:6070870E"],"x-oauth-scopes":["admin:enterprise, admin:gpg_key, admin:org, admin:org_hook, admin:public_key, admin:repo_hook, delete:packages, delete_repo, gist, notifications, repo, user, workflow, write:discussion, write:packages"],"x-ratelimit-limit":["60"],"x-ratelimit-remaining":["0"],"x-ratelimit-reset":["1617990096"],"x-ratelimit-used":["61"],"x-xss-protection":["0"]},"exceptionMsg":"Unexpected code 403,url is : https://api.github.com/repos/myreaderx14/cdn34/contents/2021/04/09/16-55-42-640_dee786269ebc75d0.webp","historyStatusCode":[],"spendMs":38},"base64UserPassword":null,"token":"6b67d******************************91b08"},"githubUser":"myreaderx14","githubHttpCode":403,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"45.8 KB","destSize":"45.8 KB","compressRate":"100%"}],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-004.herokuapp.com/":{"failCount":0,"successCount":2,"resultList":[200,200]},"http://us-005.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-51.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe67.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-029.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039797510","sourceStatusCode":200,"destWidth":732,"destHeight":275,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn26@2020_4/2021/04/09/16-55-35-700_2768b2a846aa0ade.webp","sourceBytes":46630,"destBytes":46630,"feedId":6615,"totalSpendMs":4988,"convertSpendMs":0,"createdTime":"2021-04-10 00:55:31","host":"europe63*","referer":"https://segmentfault.com/a/1190000039797508","linkMd5ListStr":"852ec7d4f8235e20bd252fb4a7b4e21e,852ec7d4f8235e20bd252fb4a7b4e21e","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"45.5 KB","destSize":"45.5 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039797515","sourceStatusCode":200,"destWidth":732,"destHeight":275,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx21/cdn38@2020_1/2021/04/09/16-55-40-079_baf6e23a018c5a8e.webp","sourceBytes":46868,"destBytes":46868,"feedId":6615,"totalSpendMs":3635,"convertSpendMs":0,"createdTime":"2021-04-10 00:55:36","host":"us-004*","referer":"https://segmentfault.com/a/1190000039797508","linkMd5ListStr":"852ec7d4f8235e20bd252fb4a7b4e21e","githubUser":"myreaderx21","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"45.8 KB","destSize":"45.8 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039797514","sourceStatusCode":200,"destWidth":732,"destHeight":203,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn39@2020_1/2021/04/09/16-55-40-399_7715f18bb48659c6.webp","sourceBytes":69028,"destBytes":69028,"feedId":6615,"totalSpendMs":3968,"convertSpendMs":0,"createdTime":"2021-04-10 00:55:36","host":"us-005*","referer":"https://segmentfault.com/a/1190000039797508","linkMd5ListStr":"852ec7d4f8235e20bd252fb4a7b4e21e","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"67.4 KB","destSize":"67.4 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039797512","sourceStatusCode":200,"destWidth":732,"destHeight":523,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn30@2020_3/2021/04/09/16-55-40-706_80ceb665d1e5953c.webp","sourceBytes":88326,"destBytes":88326,"feedId":6615,"totalSpendMs":4265,"convertSpendMs":0,"createdTime":"2021-04-10 00:55:36","host":"us-51*","referer":"https://segmentfault.com/a/1190000039797508","linkMd5ListStr":"852ec7d4f8235e20bd252fb4a7b4e21e","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"86.3 KB","destSize":"86.3 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039797513","sourceStatusCode":200,"destWidth":100,"destHeight":99,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn45@2020_6/2021/04/09/16-55-42-425_959a438de45f571b.webp","sourceBytes":25418,"destBytes":25418,"feedId":6615,"totalSpendMs":6340,"convertSpendMs":0,"createdTime":"2021-04-10 00:55:36","host":"europe67*","referer":"https://segmentfault.com/a/1190000039797508","linkMd5ListStr":"852ec7d4f8235e20bd252fb4a7b4e21e","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.8 KB","destSize":"24.8 KB","compressRate":"100%"}],"successGithubMap":{"myreaderx25":1,"myreaderx15":1,"myreaderx21":1,"myreaderx12":1,"myreaderx30":1},"failGithubMap":{"myreaderx14":1}}