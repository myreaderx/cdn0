{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-12-03 21:57:39","updatedTime":"2020-12-03 21:57:39","title":"Python文件的读写操作","link":"https://www.biaodianfu.com/?p=2711","description":"<p>使用Python编程时，经常会遇到读写文件的操作。对于读写文件的各种模式（如阅读、写入、追加等）有时真的会迷惑人，以及搞不清open、read、readline、readlines、write、writelines等方法的使用也会把你绕的云里雾里。</p>\n<p>期望这篇文章能够帮你更好的了解应该如何读写文件，并在最恰当的地方用最合适的方法。</p>\n<p><img class=\"alignnone size-full wp-image-2713\" src=\"https://www.biaodianfu.com/wp-content/uploads/2020/11/python-read-file.jpg\" alt=\"\" width=\"750\" height=\"346\" /></p>\n<h2>什么是文件？</h2>\n<p>在我们开始研究如何使用Python中的文件之前，了解文件究竟是什么以及现代操作系统如何处理它们的某些方面是非常重要的。</p>\n<p>从本质上讲，文件是用于存储数据的连续字节集。这些数据以特定格式组织，可以是任何像文本文件一样简单的数据，也可以像程序可执行文件一样复杂。最后，这些字节文件被翻译成二进制文件1，0以便计算机更容易处理。</p>\n<p>大多数现代文件系统上的文件由三个主要部分组成：</p>\n<ul>\n<li><strong>标题(Header)</strong>：有关文件内容的元数据（文件名，大小，类型等）</li>\n<li><strong>数据(Data)</strong>： 由创建者或编辑者编写的文件内容</li>\n<li><strong>文件结束（EOF）</strong>：表示文件结尾的特殊字符</li>\n</ul>\n<p><img class=\"alignnone size-full wp-image-2712\" src=\"https://www.biaodianfu.com/wp-content/uploads/2020/11/file.jpg\" alt=\"\" width=\"337\" height=\"551\" /></p>\n<p>数据表示的内容取决于所使用的格式规范，通常由扩展名表示。例如，扩展名为.gif的文件最可能符合<a href=\"https://en.wikipedia.org/wiki/GIF\">图形交换格式</a>规范。有数百个（如果不是数千个）<a href=\"https://en.wikipedia.org/wiki/List_of_filename_extensions\">文件扩展名</a>。</p>\n<h2>文件路径</h2>\n<p>在操作系统上访问文件时，需要文件路径。文件路径是表示文件位置的字符串。它分为三个主要部分：</p>\n<ul>\n<li>文件夹路径：文件系统上的文件夹位置，后续文件夹由正斜杠/（Unix）或反斜杠\\（Windows）分隔</li>\n<li>文件名：文件的实际名称</li>\n<li>扩展名：文件路径的末尾预先设置了句号（.），用于表示文件类型</li>\n</ul>\n<p>Python文件路径相关操作：</p>\n<ul>\n<li>使用getcwd()可获得当前工作目录，即当前Python脚本工作的目录路径，类似Linux中pwd命令\n<ul>\n<li>如果想打印Windows中包含中文的文件名或路径，需要使用“GBK”进行decode</li>\n</ul>\n</li>\n<li>合并路径使用path.join()\n<ul>\n<li>Windows中的反斜杠与Linux中的正斜杠使用sep（反斜杠需要使用\\\\转义）</li>\n</ul>\n</li>\n<li>相对路径\n<ul>\n<li>（.）点表示当前文件夹</li>\n<li>（.. ）点点表示父文件夹</li>\n</ul>\n</li>\n<li>相对路径、绝对路径转换\n<ul>\n<li>path.abspath(path)：返回绝对路径</li>\n<li>path.isabs(path)：判断是否是绝对路径</li>\n<li>path.relpath(path,start)：返回相对路径</li>\n</ul>\n</li>\n<li>路径分割：</li>\n<li>path.dirname(path)：返回文件所在目录，os.path.basename(path)：返回文件名</li>\n<li>path.split(path) == (os.path.dirname(path), os.path.basename(path)).silit(os.sep)是将路径按分隔符分割</li>\n<li>path.basename()：获取文件名</li>\n<li>path.splitext()：分离扩展名</li>\n<li>查看文件大小：path.getsize(filename)，只能统计文件，不同统计文件夹，如需统计文件夹需要自行遍历。</li>\n<li>获取文件属性：stat(file)</li>\n<li>检查路径有效性\n<ul>\n<li>path.exists：路径是否存在</li>\n<li>path.isdir：是否为目录</li>\n<li>path.isfile：是否是文件</li>\n</ul>\n</li>\n<li>返回指定目录下的所有文件和目录名：listdir()</li>\n</ul>\n<p>其他方法：</p>\n<ul>\n<li>删除文件:os.remove()</li>\n<li>删除目录：removedirs(r&#8221;c:\\python &#8220;)</li>\n<li>重命名：rename(old， new) #文件或目录都是使用这条命令</li>\n<li>创建多级目录：makedirs(r&#8221;c：\\python\\test&#8221;)，其会创建中间文件夹，类似Linux命令 mkdir -p</li>\n<li>创建单个目录：mkdir(&#8220;test&#8221;)</li>\n<li>修改文件权限与时间戳：chmod(file)</li>\n</ul>\n<p>目录操作：</p>\n<ul>\n<li>复制文件：\n<ul>\n<li>copyfile(&#8220;oldfile&#8221;, &#8220;newfile&#8221;) #oldfile和newfile都只能是文件</li>\n<li>copy(&#8220;oldfile&#8221;, &#8220;newfile&#8221;) #oldfile只能是文件夹，newfile可以是文件，也可以是目标目录</li>\n</ul>\n</li>\n<li>复制文件夹：copytree(&#8220;olddir&#8221;, &#8220;newdir&#8221;) #olddir和newdir都只能是目录，且newdir必须不存在</li>\n<li>移动文件(目录)：move(&#8220;oldpos&#8221;,&#8221;newpos&#8221;)</li>\n<li>删除目录\n<ul>\n<li>rmdir(&#8220;dir&#8221;) #只能删除空目录</li>\n<li>rmtree(&#8220;dir&#8221;) #空目录、有内容的目录都可以删</li>\n</ul>\n</li>\n</ul>\n<h2>行结尾</h2>\n<p>处理文件数据时经常遇到的一个问题是新行或行结尾的表示。行结尾起源于莫尔斯电码时代，使用一个特定的符号被用来表示传输的结束或一行的结尾。</p>\n<p>后来，国际标准化组织（ISO）和美国标准协会（ASA）对电传打字机进行了标准化。ASA标准规定行尾应使用回车（序列CR或\\r）和换行（LF或\\n）字符（CR+LF或\\r\\n）。然而，ISO标准允许CR+LF字符或仅LF字符。</p>\n<p>Windows使用CR+LF字符表示新行，而Unix和较新的Mac版本仅使用LF字符。当你处理来源于不同操作系统上的文件时，这可能会导致一些复杂情况。这是一个简单的例子。假设我们检查在Windows系统上创建的文件dog_breeds.txt：</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"raw\">Pug\\r\\n\nJack Russel Terrier\\r\\n\nEnglish Springer Spaniel\\r\\n\nGerman Shepherd\\r\\n\nStaffordshire Bull Terrier\\r\\n\nCavalier King Charles Spaniel\\r\\n\nGolden Retriever\\r\\n\nWest Highland White Terrier\\r\\n\nBoxer\\r\\n\nBorder Terrier\\r\\n\n</pre>\n<p>同样的输出将在Unix设备上以不同方式解释：</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"raw\">Pug\\r\n\\n\nJack Russel Terrier\\r\n\\n\nEnglish Springer Spaniel\\r\n\\n\nGerman Shepherd\\r\n\\n\nStaffordshire Bull Terrier\\r\n\\n\nCavalier King Charles Spaniel\\r\n\\n\nGolden Retriever\\r\n\\n\nWest Highland White Terrier\\r\n\\n\nBoxer\\r\n\\n\nBorder Terrier\\r\n\\n</pre>\n<p>解决方案：</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\">with open('test.txt', 'r') as f:\n    for line in f.readlines():\n    line = line.strip('\\n')\n</pre>\n<h2>Python遍历文件夹方法</h2>\n<h3>使用walk()</h3>\n<p>输出总是先文件夹后文件名</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"># -*- coding: utf-8 -*- \nimport os \ndef echo_path(root_dir): \n    list_dirs = os.walk(root_dir) \n    for root, dirs, files in list_dirs: \n        for d in dirs: \n            print os.path.join(root, d)\n        for f in files: \n            print os.path.join(root, f)\n</pre>\n<h3>使用listdir</h3>\n<p>按照目录树结构以及按照首字母排序进行输出的。</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"># -*- coding: utf-8 -*- \nimport os \n\ndef echo_path(root_dir): \n    for dir_list in os.listdir(root_dir): \n        path = os.path.join(root_dir, dir_list) \n        print(path)\n        if os.path.isdir(path): \n            echo_path(path)\n</pre>\n<h3>glob模块</h3>\n<p>glob模块是最简单的模块之一，内容非常少。用它可以查找符合特定规则的文件路径名。</p>\n<p><strong>glob.glob</strong></p>\n<p>返回所有匹配的文件路径列表。它只有一个参数pathname，定义了文件路径匹配规则，这里可以是绝对路径，也可以是相对路径。示例：</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\">import glob  \n\n#获取指定目录下的所有图片  \nprint(glob.glob(r\"E:\\Picture\\*\\*.jpg\") )\n\n#获取上级目录的所有.py文件  \nprint(glob.glob(r'../*.py') #相对路径)\n</pre>\n<p><strong>glob.iglob</strong></p>\n<p>获取一个可编历对象，使用它可以逐个获取匹配的文件路径名。与glob.glob()的区别是：glob.glob同时获取所有的匹配路径，而 glob.iglob一次只获取一个匹配路径，即生成器。</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">import glob\n\nfile = glob.iglob(r'../*.py')\nprint(file) #&#60;generator object iglob at 0x00B9FF80&#62; \n\nfor py in f:\n    print(py)\n</pre>\n<h2>Python读写文件内容</h2>\n<h3>使用with语句打开文件</h3>\n<p>在Python中读写文件需要3个步骤：</p>\n<ul>\n<li>调用open函数，返回一个File对象</li>\n<li>调用File对象的read()或write()方法</li>\n<li>调用File对象的close() 方法，关闭该文件</li>\n</ul>\n<p>文件常用打开模式：</p>\n<ul>\n<li>&#8216;r&#8217;：只读（缺省。如果文件不存在，则抛出错误）</li>\n<li>&#8216;w&#8217;：只写（如果文件不存在，则自动创建文件）</li>\n<li>&#8216;a&#8217;：附加到文件末尾</li>\n<li>&#8216;r+&#8217;：读写</li>\n</ul>\n<p>如果需要以二进制方式打开文件，需要在mode后面加上字符&#8221;b&#8221;，比如&#8221;rb&#8221;&#8221;wb&#8221;等</p>\n<p>如果不用with语句，代码如下：</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\">file = open(\"/tmp/foo.txt\")\ndata = file.read()\nfile.close()\n</pre>\n<p>这里有两个问题:</p>\n<ul>\n<li>可能忘记关闭文件句柄；</li>\n<li>文件读取数据发生异常，没有进行任何处理。</li>\n</ul>\n<p>加强版代码：</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\">try:\n    f = open('xxx')\nexcept:\n    print 'fail to open'\n    exit(-1)\ntry:\n    do something\nexcept:\n    do something\nfinally:\n     f.close()\n</pre>\n<p>虽然这段代码运行良好，但是太冗长了。with除了有更优雅的语法，还可以很好的处理上下文环境产生的异常。</p>\n<p>with版本的代码：</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\">with open(\"/tmp/foo.txt\") as file:\n    data = file.read()\n</pre>\n<p>with的工作流程：</p>\n<ul>\n<li>紧跟with后面的语句被求值后，返回对象的 __enter__() 方法被调用，这个方法的返回值将被赋值给as后面的变量。</li>\n<li>当with后面的代码块全部被执行完之后，将调用前面返回对象的 __exit__()方法。</li>\n</ul>\n<p>有时你可能想要读取文件并同时写入另一个文件。如果你使用在学习如何写入文件时显示的示例，它实际上可以合并到以下内容中：</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\">d_path = 'dog_breeds.txt'\nd_r_path = 'dog_breeds_reversed.txt'\nwith open(d_path, 'r') as reader, open(d_r_path, 'w') as writer:\n    dog_breeds = reader.readlines()\n    writer.writelines(reversed(dog_breeds))\n</pre>\n<h3>文本读取：read()、readline()、readlines()的区别</h3>\n<p><strong>read()</strong></p>\n<p>read()是最简单的一种方法，一次性读取文件的所有内容放在一个大字符串中，即存在内存中。</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\">f = open('test.txt') \ntry:\n    file_context = file_object.read() \n    file_context = open(file).read().splitlines()   // file_context是一个list，每行文本内容是list中的一个元素\nfinally:\n    file_object.close()\n</pre>\n<p>read()的优点：</p>\n<ul>\n<li>方便、简单</li>\n<li>一次性独读出文件放在一个大字符串中，速度最快</li>\n</ul>\n<p>read()的缺点：</p>\n<ul>\n<li>文件过大的时候，占用内存会过大</li>\n</ul>\n<p><strong>readline()</strong></p>\n<p>readline()是逐行读取文本，结果是一个list</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\">with open(file) as f:\n    line = f.readline()\n    while line:\n        print(line)\n        line = f.readline()\n</pre>\n<p>readline()的优点：</p>\n<ul>\n<li>占用内存小，逐行读取</li>\n</ul>\n<p>readline()的缺点：</p>\n<ul>\n<li>由于是逐行读取，速度比较慢</li>\n</ul>\n<p><strong>readlines()</strong></p>\n<p>readlines()一次性读取文本的所有内容，结果是一个list</p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\">with open(file) as f:\n  for line in f.readlines():\n     print(line)\n</pre>\n<p>这种方法读取的文本内容，每行文本末尾都会带一个&#8217;\\n&#8217;换行符 (可以使用L.rstrip(&#8216;\\n&#8217;)去掉换行符）</p>\n<p>readlines()的优点：</p>\n<ul>\n<li>一次性读取文本内容，速度比较快</li>\n</ul>\n<p>readlines()的缺点：</p>\n<ul>\n<li>随着文本的增大，占用内存会越来越多</li>\n</ul>\n<h3>文本写入：write()与writelines()</h3>\n<ul>\n<li>write()传入的是字符串</li>\n<li>writelines()传入的数一个数组</li>\n</ul>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\">lines = ['line1', 'line2']\nwith open('filename.txt', 'w') as f:\n    f.write('\\n'.join(lines))\n\nlines = ['line1', 'line2']\nwith open('filename.txt', 'w') as f:\n    f.writelines(\"%s\\n\" % l for l in lines)\n</pre>\n<h2>不要重复造轮子</h2>\n<p>在处理文件时可能会遇到常见情况。大多数情况可以使用其他模块处理。您可能需要使用的两种常见文件类型是.csv和.json。</p>\n<ul>\n<li><a href=\"https://www.biaodianfu.com/pandas-excel-csv.html\">用Python读写Excel、CSV文件</a></li>\n<li><a href=\"https://www.biaodianfu.com/python-json-jsonp.html\">在Python中处理JSON数据</a></li>\n<li><a href=\"https://www.biaodianfu.com/python-xml.html\">用Python处理XML文件</a></li>\n</ul>\n<p>此外，还有内置库，可以使用它们来帮助你：</p>\n<ul>\n<li><a href=\"https://docs.python.org/3.7/library/wave.html\">wave</a>：读写WAV文件（音频）</li>\n<li><a href=\"https://docs.python.org/3/library/aifc.html\">aifc</a>：读写AIFF和AIFC文件（音频）</li>\n<li><a href=\"https://docs.python.org/3/library/sunau.html\">sunau</a>：读取和写入Sun AU文件</li>\n<li><a href=\"https://docs.python.org/3/library/tarfile.html\">tarfile</a>：读取和写入tar归档文件</li>\n<li><a href=\"https://docs.python.org/3/library/zipfile.html\">zipfile</a>：使用ZIP存档</li>\n<li><a href=\"https://docs.python.org/3/library/configparser.html\">configparser</a>：轻松创建和解析配置文件</li>\n<li><a href=\"https://docs.python.org/3/library/msilib.html\">msilib</a>：读取和写入Microsoft Installer文件</li>\n<li><a href=\"https://docs.python.org/3/library/plistlib.html\">plistlib</a>：生成并解析Mac OS X .plist文件</li>\n</ul>\n<p>还有更多的东西。此外，PyPI还有更多第三方工具可用。以下是一些流行的包：</p>\n<ul>\n<li><a href=\"https://pypi.org/project/PyPDF2/\">PyPDF2</a>：一个可以分割，合并和转换 PDF 页面的库。</li>\n<li><a href=\"https://pypi.org/project/Pillow/\">Pillow</a>：图像阅读和操作</li>\n<li><a href=\"https://github.com/python-openxml/python-docx\">python-docx</a>：读取，查询以及修改 Microsoft Word 2007+ docx 文件</li>\n<li><a href=\"https://github.com/scanny/python-pptx\">python-pptx</a>：读取，查询以及修改 Microsoft PowerPoint 2007+ pptx 文件</li>\n<li><a href=\"https://github.com/mitsuhiko/unp\">unp</a>：一个用来方便解包归档文件的命令行工具</li>\n</ul>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://realpython.com/read-write-files-python/\">Reading and Writing Files in Python (Guide)</a></li>\n</ul>\n<div class='yarpp-related-rss'>\n<h3>相关文章:</h3><ol>\n<li><a href=\"https://www.biaodianfu.com/nlp-tools.html\" rel=\"bookmark\" title=\"自然语言处理工具包推荐\">自然语言处理工具包推荐 </a></li>\n<li><a href=\"https://www.biaodianfu.com/word2vec-doc2vec-imdb-sentiment-analysis.html\" rel=\"bookmark\" title=\"Word2Vec自然语言情感分析实战\">Word2Vec自然语言情感分析实战 </a></li>\n<li><a href=\"https://www.biaodianfu.com/crf.html\" rel=\"bookmark\" title=\"条件随机场CRF及CRF++安装与使用\">条件随机场CRF及CRF++安装与使用 </a></li>\n</ol>\n</div>\n","descriptionType":"html","publishedDate":"Thu, 26 Nov 2020 02:41:30 +0000","feedId":51265,"bgimg":"https://www.biaodianfu.com/wp-content/uploads/2020/11/python-read-file.jpg","linkMd5":"a6574f9ac40f3b93799bb51e5d0a7158","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn83@2020_2/2020/12/03/13-57-48-423_36cc527a624e495b.webp","destWidth":750,"destHeight":346,"sourceBytes":75881,"destBytes":38624,"author":"钱魏Way","articleImgCdnMap":{"https://www.biaodianfu.com/wp-content/uploads/2020/11/python-read-file.jpg":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn83@2020_2/2020/12/03/13-57-48-423_36cc527a624e495b.webp","https://www.biaodianfu.com/wp-content/uploads/2020/11/file.jpg":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn88@2020_3/2020/12/03/13-58-02-657_30d0118ef888f0bb.webp"},"publishedOrCreatedDate":1607003859650}],"record":{"createdTime":"2020-12-03 21:57:39","updatedTime":"2020-12-03 21:57:39","feedId":51265,"fetchDate":"Thu, 03 Dec 2020 13:57:39 +0000","fetchMs":2528,"handleMs":13,"totalMs":26959,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"ccad6689203ccd26028ef97974dd9d21","hostName":"europe-23*","requestId":"1646ed2703f2454192d1e2666d4bfbfd_51265","contentType":"text/xml;charset=UTF-8","totalBytes":43172,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":2,"articlesImgsGithubTotal":2,"successGithubMap":{"myreaderx3":1,"myreaderx2":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 03:59:47","updatedTime":"2020-11-12 14:59:26","id":51265,"name":"标点符","url":"https://www.biaodianfu.com/feed","subscriber":62,"website":null,"icon":"https://www.biaodianfu.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx65/cdn25@2020_5/2020/11/12/06-59-23-963_42b20d4f8d4a0964.ico","description":"格物致知→知行合一","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":38624,"tmpBodyImgCdnBytes":4548,"tmpBgImgCdnBytes":0,"extra4":{"start":1607003856575,"total":0,"statList":[{"spend":3062,"msg":"获取xml内容"},{"spend":13,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":14142,"msg":"正文链接上传到cdn"}]},"extra5":2,"extra6":2,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://europe63.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://www.biaodianfu.com/wp-content/uploads/2020/11/python-read-file.jpg","sourceStatusCode":200,"destWidth":750,"destHeight":346,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn83@2020_2/2020/12/03/13-57-48-423_36cc527a624e495b.webp","sourceBytes":75881,"destBytes":38624,"targetWebpQuality":75,"feedId":51265,"totalSpendMs":9582,"convertSpendMs":14,"createdTime":"2020-12-03 21:57:39","host":"us-001*","referer":"https://www.biaodianfu.com/?p=2711","linkMd5ListStr":"a6574f9ac40f3b93799bb51e5d0a7158,a6574f9ac40f3b93799bb51e5d0a7158","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"74.1 KB","destSize":"37.7 KB","compressRate":"50.9%"},{"code":1,"isDone":false,"source":"https://www.biaodianfu.com/wp-content/uploads/2020/11/file.jpg","sourceStatusCode":200,"destWidth":337,"destHeight":551,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn88@2020_3/2020/12/03/13-58-02-657_30d0118ef888f0bb.webp","sourceBytes":12524,"destBytes":4548,"targetWebpQuality":75,"feedId":51265,"totalSpendMs":14101,"convertSpendMs":7,"createdTime":"2020-12-03 21:57:49","host":"europe63*","referer":"https://www.biaodianfu.com/?p=2711","linkMd5ListStr":"a6574f9ac40f3b93799bb51e5d0a7158","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"12.2 KB","destSize":"4.4 KB","compressRate":"36.3%"}],"successGithubMap":{"myreaderx3":1,"myreaderx2":1},"failGithubMap":{}}