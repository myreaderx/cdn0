{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-09-21 13:28:30","updatedTime":"2020-09-21 13:28:30","title":"你还在redux中写重复啰嗦的样板代码吗","link":"https://juejin.im/post/6874751458508537864","description":"<div class=\"markdown-body\"><h2 data-id=\"heading-0\">前言</h2>\n<blockquote>\n<p>📢 博客首发 : <a href=\"https://github.com/PDKSophia/blog.io\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">阿宽的博客</a></p>\n</blockquote>\n<blockquote>\n<p>📢 团队博客: <a href=\"https://github.com/SugarTurboS/Blogs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SugarTurboS</a></p>\n</blockquote>\n<blockquote>\n<p>🌈 仓库源码 : <a href=\"https://github.com/SugarTurboS/rc-redux-model\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">rc-redux-model</a> ，求个 ✨ star</p>\n</blockquote>\n<p>最近受 JPL 同学的启发，写了一个中间件 <code>rc-redux-model</code>，下边记录一下我的从 0 到 1</p>\n<p>大家应该知道，<strong>react 是单向数据流的形式</strong>，它不存在数据向上回溯的技能，你要么就是向下分发，要么就是自己内部管理。</p>\n<img width=\"650\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67cf879c34bd4ecfafdc1443e4b8b8ab~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\">\n<p>react 中，有 props 和 state，当我想从父组件给子组件传递数据的时候，可通过 props 进行数据传递，如果我想在组件内部自行管理状态，那可以选择使用 state。</p>\n<p>很快，我遇到了一个问题，那就是兄弟组件之间如何进行通信？答案就是在父组件中管理 state，通过 props 下发给各子组件，子组件通过回调方式，进行通信</p>\n<img width=\"450\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c1e195cc4294dfdbb82bd3faeaefd0a~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\">\n<p>这会存在什么问题？你会发现如果你想共享数据，你得把所有需要共享的 state 集中放到所有组件顶层，然后分发给所有组件。</p>\n<p>为此，需要一个库，来作为更加牛逼、专业的顶层 state 发给各组件，于是，我引入了 redux。</p>\n<h2 data-id=\"heading-1\">redux 体验</h2>\n<p>redux 可以说是较成熟，生态圈较完善的一个库了，搭配 <a href=\"https://github.com/zalmoxisus/redux-devtools-extension\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">redux-devtools-extension</a> 这个 chrome 插件，让你开发更加快乐。然，世间万物，皆有利弊。</p>\n<p>本身我使用 redux 并不会有什么所谓的“痛点”，<strong>因为 redux 默认只支持同步操作，让使用者自行选择处理异步</strong>，对于异步请求 redux 是无能为力的。可以这么说，它保证自己是纯粹的，脏活累活都丢给别人去干。</p>\n<p>于是我的痛点在于 : 如何处理异步请求，为此我使用了 redux-saga 去解决异步的问题</p>\n<p>但是在使用 <code>redux + redux-saga</code> 中，我发现，这会让我的 <strong>[重复性]</strong> 工作变多(逐步晋升 CV 工程师)，因为它在我们项目中，会存在啰嗦的样板代码。</p>\n<p>举个 🌰 : 异步请求，获取用户信息，我需要创建 <code>sagas/user.js</code>、<code>reducers/user.js</code>、<code>actions/user.js</code>，为了统一管理 const，我还会有一个 <code>const/user.js</code>，然后在这些文件之间来回切换。</p>\n<blockquote>\n<p>分文件应该是一种默认的规范吧？</p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-comment\">// const/user.js</span>\n<span class=\"hljs-keyword\">const</span> FETCH_USER_INFO = <span class=\"hljs-string\">'FETCH_USER_INFO'</span>\n<span class=\"hljs-keyword\">const</span> FETCH_USER_INFO_SUCCESS = <span class=\"hljs-string\">'FETCH_USER_INFO_SUCCESS'</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-comment\">// actions/user.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetchUserInfo</span>(<span class=\"hljs-params\">params, callback</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">type</span>: FETCH_USER_INFO,\n    params,\n    callback,\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-comment\">// sagas/user.js</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">fetchUserInfoSaga</span>(<span class=\"hljs-params\">{ params, callback }</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">yield</span> call(fetch.callAPI, {\n    <span class=\"hljs-attr\">actionName</span>: FETCH_USER_INFO,\n    params,\n  })\n  <span class=\"hljs-keyword\">if</span> (res.code === <span class=\"hljs-number\">0</span>) {\n    <span class=\"hljs-keyword\">yield</span> put({\n      <span class=\"hljs-attr\">type</span>: FETCH_USER_INFO_SUCCESS,\n      <span class=\"hljs-attr\">data</span>: res.data,\n    })\n    callback && callback()\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">throw</span> res.msg\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-comment\">// reducers/user.js</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">userReducer</span>(<span class=\"hljs-params\">state, action</span>) </span>{\n  <span class=\"hljs-keyword\">switch</span> (action.type) {\n    <span class=\"hljs-keyword\">case</span> FETCH_USER_INFO_SUCCESS:\n      <span class=\"hljs-keyword\">return</span> Immutable.set(state, <span class=\"hljs-string\">'userInfo'</span>, action.data)\n  }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>没错， 这种样板代码，简直就是 CV 操作，只需要 copy 一份，修改一下名称，对我个人而言，这会让我不够专注，分散管理 const、action、saga、reducer 一套流程，需要不断的跳跃思路。</p>\n<p>而且文件数量会变多，我是真的不喜欢如此<code>繁琐</code>的流程，有没有好的框架能帮我把这些事都做完呢？</p>\n<h2 data-id=\"heading-2\">dva</h2>\n<p><strong>dva，基于 redux 和 redux-saga 的数据流方案，让你在一个 model 文件中写所有的 <code>action、state、effect、reducers</code>等，然后为了简化开发体验，内置了 react-router 和 fetch</strong>.</p>\n<p>聊聊我对 dva 的看法，官方说了，基于 <code>redux</code> + <code>redux-saga</code> 的方案，只是在你写的时候，都写在一个 model 文件，然后它帮你做一些处理；其次它是一个框架，而不是一个库，是否意味着: 我在项目开始之前，我就需要确定项目的架构是不是用 dva，如果开发一半，我想换成 dva 这种状态管理的写法，而去引入 dva ，是否不合理？</p>\n<p>再或者，我只是做一些 demo、写点小型的个人项目，但我又想像写 dva 的数据状态管理 model 那种方式，引入 dva 是不是反而变得笨重呢？</p>\n<p>回过头来看，我的出发点是 : 在于解决繁琐重复的工作，store 文件分散，state 类型和赋值错误的问题，为此，对于跟我一样的用户，提供了一个写状态管理较为[舒服]的书写方式，大部分情况下兼容原先项目，只需要安装这个包，就能引入一套数据管理方案，写起来又舒服简洁，开心开心的撸代码，不香吗？</p>\n<h2 data-id=\"heading-3\">再次明确</h2>\n<p><strong>rc-redux-model 出发点在于解决繁琐重复的工作，store 文件分散，state 类型和赋值错误的问题，为此，对于跟我一样的用户，提供了一个写状态管理较为[舒服]的书写方式，大部分情况下兼容原先项目</strong>~</p>\n<ul>\n<li>为了解决[store 文件分散]，参考借鉴了 dva 写状态管理的方式，一个 model 中写所有的 <code>action、state、reducers</code></li>\n<li>为了解决[繁琐重复的工作]，提供默认的 action，用户不需要自己写修改 state 的 action，只需要调用默认提供的 <code>[model.namespace/setStore]</code> 即可，从而将一些重复的代码从 model 文件中剔除</li>\n<li>为了解决[state 类型和赋值错误]，在每次修改 state 值时候，都会进行检测，如果不通过则报错提示</li>\n</ul>\n<h2 data-id=\"heading-4\">初建雏形</h2>\n<p>由于之前看过 redux 源码，同时也看了一下 redux-thunk 的源码，并且查阅了一些相关文章，有了一些知识储备，说干就干～</p>\n<p>参考了 dva 中对 model 的参数说明，因为我没有了 redux-saga ，所以是没有 <code>effect</code> 这个属性的，于是初步得到我的 model 参数</p>\n<img width=\"300\" class=\"lazyload\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f31616f946e4f6197bffb9dfcf880c5~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\">\n<p>按照我的设想，我会存在多个 model 文件，聚集在一起之后，得到的是一个数组 :</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">import</span> aModel <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./aModel'</span>\n<span class=\"hljs-keyword\">import</span> bModel <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./bModel'</span>\n<span class=\"hljs-keyword\">import</span> cModel <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./cModel'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> [aModel, bModel, cModel]\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>我所希望的是 : 传入一个 <code>Array<IModelProps></code>，得到一个 <code>RcReduxModel</code> 对象，该对象拥有得给我导出 :</p>\n<ul>\n<li>reducers: 所有 model.reducers 集合，这样我可以无障碍的用在 <code>store.combineReducers</code>中了，同时可以兼容你现有的项目，因为只要你用了 redux， 那么你肯定得通过 <code>combineReducers API</code> 去集合所有的 reducers</li>\n</ul>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-comment\">// createStore.js</span>\n<span class=\"hljs-keyword\">import</span> models <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./models'</span>\n<span class=\"hljs-keyword\">import</span> RcReduxModel <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rc-redux-model'</span>\n\n<span class=\"hljs-keyword\">const</span> reduxModel = <span class=\"hljs-keyword\">new</span> RcReduxModel(models)\n\n<span class=\"hljs-keyword\">const</span> reducerList = combineReducers(reduxModel.reducers)\n<span class=\"hljs-keyword\">return</span> createStore(reducerList)\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 data-id=\"heading-5\">异步处理</h2>\n<p>其实我更加希望的是，由用户自行处理异步，然后再发起同步Action，将数据塞到 redux 中，但是异步处理还是得提供的，所以就得想，该如何处理异步问题？</p>\n<p>相对比 <code>redux-thunk</code> 与 <code>redux-saga</code> ，在看了 thunk 的源码之后，觉得其极简单，并且更倾向于我的出发点，出于学习，以及在使用上带给我的[体验]，我在想，能否参考一波源码，然后实现一个？</p>\n<blockquote>\n<p>issues区有人提问<a href=\"https://github.com/SugarTurboS/rc-redux-model/issues/6\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">为什么使用redux-thunk不使用redux-saga做为中间件？</a>，感兴趣的可以看看</p>\n</blockquote>\n<p>于是，我去将 <code>redux-thunk</code> 的源码看了一遍，最后得出了一个解决方案 : 对比 redux-thunk ，其内部在于判断你的 action 是 function 还是 object，从而判断你的 action 是同步还是异步；而在 <code>rc-redux-model</code> 中，甭管三七二十一，我规定的每一个 action 都是异步的，也就是你发起的每一个 action，都是函数 :</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">aModel = {\n  <span class=\"hljs-attr\">action</span>: {\n    <span class=\"hljs-comment\">// 这两个 action 都是 function</span>\n    firstAction: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ getState, dispatch }</span>) =></span> {},\n    <span class=\"hljs-attr\">secondAction</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ getState, dispatch }</span>) =></span> {},\n  },\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>即使你想要发起一个同步 action，去修改 state 的值，我也会将其作为异步进行处理，也就是你修改 state 值，你需要这么写 :</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-comment\">// 组件</span>\n<span class=\"hljs-keyword\">this</span>.props.dispatch({\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'aModel/setStateA'</span>,\n  <span class=\"hljs-attr\">payload</span>: <span class=\"hljs-string\">'666'</span>,\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">aModel = {\n  <span class=\"hljs-attr\">namespace</span>: <span class=\"hljs-string\">'aModel'</span>,\n  <span class=\"hljs-attr\">state</span>: {\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">'111'</span>,\n  },\n  <span class=\"hljs-attr\">action</span>: {\n    <span class=\"hljs-comment\">// 这里是异步action，这里需要用户自己手动 dispatch 去修改 state 值</span>\n    setStateA: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ currentAction, dispatch, commit }</span>) =></span> {\n      dispatch({\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'aModel/CHANGE_STATE_A'</span>,\n        <span class=\"hljs-attr\">payload</span>: currentAction.payload,\n      })\n      <span class=\"hljs-comment\">// 或者是使用 commit</span>\n      <span class=\"hljs-comment\">//   commit({</span>\n      <span class=\"hljs-comment\">//     type: 'CHANGE_STATE_A',</span>\n      <span class=\"hljs-comment\">//     payload: currentAction.payload,</span>\n      <span class=\"hljs-comment\">//   })</span>\n    },\n  },\n  <span class=\"hljs-attr\">reducers</span>: {\n    [<span class=\"hljs-string\">'CHANGE_STATE_A'</span>](state, payload) {\n      <span class=\"hljs-keyword\">return</span> {\n        ...state,\n        <span class=\"hljs-attr\">a</span>: payload,\n      }\n    },\n  },\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>明确了这两点，接下来就只需要开发即可。如果前边看过我写 redux 源码分析到话，可以知道 reducer 是一个纯函数，所以我注册 reducer 中时，一定要明确这点: (以下代码摘抄 rc-redux-model 源码)</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\">public registerReducers(model: IModelProps) {\n    <span class=\"hljs-keyword\">const</span> { namespace, state, reducers } = model\n    <span class=\"hljs-comment\">// 1检查 reducers</span>\n    invariant(reducers, <span class=\"hljs-string\">`model's reducers must be defined, but got undefined`</span>)\n\n    <span class=\"hljs-comment\">// 1.1 得到所有 reducers 中的 action</span>\n    <span class=\"hljs-keyword\">const</span> reducersActionTypes = <span class=\"hljs-built_in\">Object</span>.keys(reducers)\n\n    <span class=\"hljs-comment\">// 1.2 reducers 是一个纯函数，function(state, action) {}</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">storeState: any, storeAction: any</span>) =></span> {\n      <span class=\"hljs-keyword\">const</span> newState = storeState || state\n      <span class=\"hljs-comment\">// 1.3 对 action 进行处理，规定 action.type 都是 namespace/actionName 的格式</span>\n      <span class=\"hljs-keyword\">const</span> reducersActionKeys = storeAction.type.split(<span class=\"hljs-string\">'/'</span>)\n\n      <span class=\"hljs-keyword\">const</span> reducersActionModelName = reducersActionKeys[<span class=\"hljs-number\">0</span>]\n      <span class=\"hljs-keyword\">const</span> reducersActionSelfName = reducersActionKeys[<span class=\"hljs-number\">1</span>]\n\n      <span class=\"hljs-comment\">// 1.3.1 如果不是当前的 model</span>\n      <span class=\"hljs-keyword\">if</span> (reducersActionModelName !== namespace) <span class=\"hljs-keyword\">return</span> newState\n      <span class=\"hljs-comment\">// 1.3.2 如果在 reducers 中存在这个 action</span>\n      <span class=\"hljs-keyword\">if</span> (reducersActionTypes.includes(reducersActionSelfName)) {\n        <span class=\"hljs-keyword\">return</span> reducers[reducersActionSelfName](newState, storeAction.payload)\n      }\n      <span class=\"hljs-keyword\">return</span> newState\n    }\n  }\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>其次是对于中间件的开发，每一个中间件都是 <code>store => next => action</code> 的形式(不太了解中间件的可以自行去了解一波)，所以我很简单就可以写出这段代码 ：</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">const</span> registerMiddleWare = <span class=\"hljs-function\">(<span class=\"hljs-params\">models: any</span>) =></span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">{ dispatch, getState }</span>) =></span> (next: any) => <span class=\"hljs-function\">(<span class=\"hljs-params\">action: any</span>) =></span> {\n    <span class=\"hljs-comment\">// 这个 action 是我 this.props.dispatch 发起的action</span>\n    <span class=\"hljs-comment\">// 所以我需要找到它具体对应的是哪个 model.namespace 的</span>\n    <span class=\"hljs-comment\">// 前边已经对 model.namespace 做了判断，确保每个 model.namespace 必须唯一，不能重复</span>\n    <span class=\"hljs-comment\">// 找到该 model，然后再找到这个 model.action 中对应我发起的 action</span>\n    <span class=\"hljs-comment\">// 因为每一个 action 都是以 [model.namespace/actionName] 的形式，所以我可以 split 之后得到 namespace</span>\n    <span class=\"hljs-keyword\">const</span> actionKeyTypes = action.type.split(<span class=\"hljs-string\">'/'</span>)\n    <span class=\"hljs-keyword\">const</span> actionModelName = actionKeyTypes[<span class=\"hljs-number\">0</span>]\n    <span class=\"hljs-keyword\">const</span> actionSelfName = actionKeyTypes[<span class=\"hljs-number\">1</span>]\n\n    <span class=\"hljs-keyword\">const</span> currentModel = getCurrentModel(actionModelName, models)\n\n    <span class=\"hljs-keyword\">if</span> (currentModel) {\n      <span class=\"hljs-keyword\">const</span> currentModelAction = currentModel.action\n        ? currentModel.action[actionSelfName]\n        : <span class=\"hljs-literal\">null</span>\n      <span class=\"hljs-comment\">// 参考redux-thunk的写法，判断是不是function，如果是，说明是个thunk</span>\n      <span class=\"hljs-keyword\">if</span> (currentModelAction && <span class=\"hljs-keyword\">typeof</span> currentModelAction === <span class=\"hljs-string\">'function'</span>) {\n        <span class=\"hljs-keyword\">return</span> currentModelAction({\n          dispatch,\n          getState,\n          <span class=\"hljs-attr\">currentAction</span>: action,\n        })\n      }\n      <span class=\"hljs-comment\">// 因为这里的action，可能是一个发到reducer，修改state的值</span>\n      <span class=\"hljs-comment\">// 但是在 model.action 中是直接写的是 commit reducerAction</span>\n      <span class=\"hljs-comment\">// 而我的每一个action都要[model.namespace/actionName]格式</span>\n      <span class=\"hljs-comment\">// 所以这里需要处理，并且判断这个action是不是在reducers中存在</span>\n      <span class=\"hljs-comment\">// 这里就不贴代码了，感兴趣的直接去看源码～</span>\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> next(action)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>上边是摘抄了部分源码，感兴趣的小伙伴可以去看看源码，并不多，并且源码中我都写了注释。经过不断调试，并且通过 jest 写了单元测试，并没有啥毛病，于是我兴致勃勃得给身边的同事安利了一波，没想到被 👊 打击了</p>\n<h2 data-id=\"heading-6\">提供默认行为，自动注册 action 及 reducers</h2>\n<p>“只有被怼过，才能知道你做的是什么破玩意”，在我给小伙伴安利的时候，他问 : “那你这东西，有什么用？”，我说写状态数据像写 dva 一样舒服，于是他又说，那我为什么不用 dva 呢？</p>\n<p>解释一波后，他接着说: “不可否认的是，你这个库，写状态数据起来确实舒服，但我作为一个使用者，要在组里推广使用，仅靠此功能，是无法说服我组里的人都用你这个东西，除非你还能提供一些功能。比如说，你的 action 都是异步的，等价于修改 state 的 action，都需要我自己去写，假设我有 20 个 state，意味着我得在 model.action 中，写对应的 20 个修改 state 的 action，然后在 model.reducers 中同样写 20 个相对应的 reducer，作为使用者，我的工作量是不是很大，如果你能提供一个默认的 action 行为给我，那么我还可能会用”</p>\n<p>仔细一想，确实如此，那我就提供一个默认的 action，用于用户修改 state 的值吧，当我提供了此 action 之后，我又发现，所有修改 state 的 action，都走同一个 <code>action.type</code>，那么在 <a href=\"https://github.com/zalmoxisus/redux-devtools-extension\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">redux-devtools-extension</a> 中，是很难发现这个 action 触发，具体是为了修改哪个 state 值。</p>\n<p>但是正如使用者说的，如果有 20 个 state 值，那么我为用户自动注册 20 个 action，用户在使用上是否需要记住每一个 state 对应的 action 呢？这肯定是极其不合理的，所以最终解决方案为 : 为每一个 state ，自动注册对应的 action 和 reducer， 同时再提供了一个默认的 action(setStore)</p>\n<blockquote>\n<p>✨ 例 : state 有 n 个值，那么最终会自动注册 n+1 个 action，用户只需要记住并调用默认的这个 action 即可</p>\n</blockquote>\n<img width=\"700\" class=\"lazyload\" src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8413cfa4f5049cc8b6eface77808736~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\">\n<p>用户只需要调用默认提供的 <code>setStore</code> 即可，然后根据 key 进行判断，从而转发到对应到 action 上 ～ 使用起来极其简单</p>\n<blockquote>\n<p><strong>对外提供统一默认 action，方便用户使用；对内根据 key，进行真实 action 的转发</strong></p>\n</blockquote>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">this</span>.props.dispatch({\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'[model.namespace]/setStore'</span>,\n  <span class=\"hljs-attr\">payload</span>: {\n    <span class=\"hljs-attr\">key</span>: [model.state.key]\n    values: [your values]\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 data-id=\"heading-7\">数据不可变</h2>\n<p>在函数式编程语言中，数据是不可变的，所有的数据一旦产生，就不能改变其中的值，如果要改变，那就只能生成一个新的数据。在我的项目中，我使用了 <code>seamless-immutable</code>，那么在 model.state 中，我使用了 Immutable 包裹了 state，然后调用默认提供的 action，最后会报错，懂的都懂 !</p>\n<p>那么该怎么办呢？于是...我又在内部支持了 Immutable ，提供一个配置参数 openSeamlessImmutable，默认为 false，请注意，如果你的 state 是 Immutable，而在 model 中不设置此配置，那么会报错 !!!</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-comment\">// 使用 seamless-immutable</span>\n\n<span class=\"hljs-keyword\">import</span> Immutable <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'seamless-immutable'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">namespace</span>: <span class=\"hljs-string\">'appModel'</span>,\n  <span class=\"hljs-attr\">state</span>: Immutable({}),\n  <span class=\"hljs-attr\">openSeamlessImmutable</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">// 必须开启此配置!!!!!</span>\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 data-id=\"heading-8\">进一步处理类型不一致</h2>\n<p>不可避免，开发人员会存在一定的疏忽，有时在 <code>model.state</code> 中定义好某个值的类型，但在改的时候却将其改为另一个类型，例如 :</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">namespace</span>: <span class=\"hljs-string\">'userModel'</span>,\n  <span class=\"hljs-attr\">state</span>: {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">''</span>, <span class=\"hljs-comment\">// 这里定义 name 为 string 类型</span>\n  },\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>但在修改此 state value 时，传递的确是一个非 string 类型的值</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">this</span>.props.dispatch({\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'userModel/setStore'</span>,\n  <span class=\"hljs-attr\">payload</span>: {\n    <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">'name'</span>,\n    <span class=\"hljs-attr\">values</span>: {}, <span class=\"hljs-comment\">// 这里 name 变成了object</span>\n  },\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>这其实是不合理的，在 rc-redux-model 中，会针对需要修改的 <code>state[key]</code> 做一些类型检测处理，如 👍</p>\n<img width=\"600\" class=\"lazyload\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/630cc474b5e14dcab8d98fabda8709de~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\">\n<p>所有修改 state 的值，前提是 : 该值已经在 state 中定义，以下情况也会报错提示</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">namespace</span>: <span class=\"hljs-string\">'userModel'</span>,\n  <span class=\"hljs-attr\">state</span>: {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">''</span>, <span class=\"hljs-comment\">// 这里只定义 state 中存在 name</span>\n  },\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>此时想修改 state 中的另一属性值</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">this</span>.props.dispatch({\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'userModel/setStore'</span>,\n  <span class=\"hljs-attr\">payload</span>: {\n    <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">'testName'</span>,\n    <span class=\"hljs-attr\">values</span>: <span class=\"hljs-string\">'1'</span>, <span class=\"hljs-comment\">// 这里想修改 testName 属性的值</span>\n  },\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>极度不合理，因为你在 state 中并没有声明此属性， rc-redux-model 会默认帮你做检测</p>\n<img width=\"600\" class=\"lazyload\" src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6263f40d5a1449cd999b32f07d0981f1~tplv-k3u1fbpfcp-zoom-1.image\" data-width=\"800\" data-height=\"600\" referrerpolicy=\"no-referrer\">\n<h2 data-id=\"heading-9\">安利一波</h2>\n<p>更多相关信息可前往 : 🌈 <a href=\"https://github.com/SugarTurboS/rc-redux-model\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">rc-redux-model</a> 中查看，同时有问题可以在 <a href=\"https://github.com/SugarTurboS/rc-redux-model/issues\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">issues</a> 中交流</p>\n<blockquote>\n<p>rc-redux-model : 参考了 dva 的数据流方案，在一个 model 文件中写所有的 <code>action</code>、<code>reducer</code>、<code>state</code>，解读了 <code>redux-thunk</code> 的源码，内部实现了一个中间件，同时提供默认行为 action，调用此 action 可以直接修改任意值的 state，方便简洁，让你忍不住说 <code>WC</code></p>\n</blockquote>\n<h3 data-id=\"heading-10\">特性</h3>\n<ul>\n<li>轻巧简洁，写数据管理就跟写 <code>dva</code> 一样舒服</li>\n<li>异步请求由用户自行处理，内部支持 call 方法，可调用提供的方法进行转发，该方法返回的是一个 Promise</li>\n<li>参考 <code>redux-thunk</code>，内部实现独立的中间件，所有的 action 都是异步 action</li>\n<li>提供默认行为 action，调用此 action ，可以修改任意的 state 值，解决你重复性写 action 、reducers 问题</li>\n<li>内置 <code>seamless-immutable</code> ，只需开启配置，让你的数据不可变</li>\n<li>默认检测不规范的赋值与类型错误，让你的数据更加健壮</li>\n</ul>\n<h3 data-id=\"heading-11\">使用</h3>\n<p>如有疑问，看下边的相关说明~ 同时对于如何在项目中使用，<a href=\"https://github.com/SugarTurboS/rc-redux-model/issues/3\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">👉 可以点这里</a></p>\n<h4 data-id=\"heading-12\">提供默认 action，无需额外多写 action/reducers</h4>\n<p>原先，我们想要修改 state 值，需要在 reducers 中定义好 action，但现在， <code>rc-redux-model</code> 提供默认的 action 用于修改，所以在 model 中，只需要定义 state 值即可</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">namespace</span>: <span class=\"hljs-string\">'appModel'</span>,\n  <span class=\"hljs-attr\">state</span>: {\n    <span class=\"hljs-attr\">value1</span>: <span class=\"hljs-string\">''</span>,\n  },\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<p>在页面中，只需要调用默认的 <code>[model.namespace/setStore]</code> 就可以修改 state 里的值了，美滋滋，不需要你自己在 action、reducers 去写很多重复的修改 state 代码</p>\n<pre><code class=\"hljs language-js copyable\" lang=\"js\"><span class=\"hljs-keyword\">this</span>.props.dispatch({\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'appModel/setStore'</span>,\n  <span class=\"hljs-attr\">payload</span>: {\n    <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">'value1'</span>,\n    <span class=\"hljs-attr\">values</span>: <span class=\"hljs-string\">'appModel_state_value1'</span>,\n  },\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n<h2 data-id=\"heading-13\">结尾</h2>\n<p>到此，终于将一套流程走完，同时在组里的项目拉了个分支，实践使用了一波，完美兼容，未出问题。于是交付了第一个可使用的版本，这次一个中间件的开发，让我对 redux 的了解更近异步，最后，👏 欢迎大家留言一起交流</p>\n<h2 data-id=\"heading-14\">相关链接</h2>\n<ul>\n<li><a href=\"https://github.com/SugarTurboS/rc-redux-model\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">rc-redux-model</a></li>\n<li><a href=\"https://github.com/SugarTurboS/rc-redux-model/issues/2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">rc-redux-model从0到1</a></li>\n<li><a href=\"https://github.com/SugarTurboS\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SugarTurboS</a></li>\n<li><a href=\"https://github.com/PDKSophia/blog.io\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">阿宽的博客</a></li>\n</ul></div> <div class=\"image-viewer-box\" data-v-78c9b824><!----></div>","descriptionType":"text/html","publishedDate":"Sun, 20 Sep 2020 17:48:04 +0000","feedId":12740,"bgimg":"","linkMd5":"c9ea4101c07afbc906bc1fa40f1135ee","bgimgJsdelivr":"","metaImg":"","author":"彭道宽","articleImgCdnMap":{"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67cf879c34bd4ecfafdc1443e4b8b8ab~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn85@2020_4/2020/09/21/05-28-30-903_4868cd057145dcf6.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c1e195cc4294dfdbb82bd3faeaefd0a~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn73@2020_4/2020/09/21/05-28-32-269_014e231f4221a6f0.webp","https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f31616f946e4f6197bffb9dfcf880c5~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn90@2020_1/2020/09/21/05-28-31-144_943dac95f8ccad41.webp","https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8413cfa4f5049cc8b6eface77808736~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx/cdn82@2020_1/2020/09/21/05-28-32-331_5fe81cf9e41bd283.webp","https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/630cc474b5e14dcab8d98fabda8709de~tplv-k3u1fbpfcp-zoom-1.image":null,"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6263f40d5a1449cd999b32f07d0981f1~tplv-k3u1fbpfcp-zoom-1.image":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn70@2020_5/2020/09/21/05-28-31-931_e6cf72afe0bfda27.webp"},"publishedOrCreatedDate":1600666110622}],"record":{"createdTime":"2020-09-21 13:28:30","updatedTime":"2020-09-21 13:28:30","feedId":12740,"fetchDate":"Mon, 21 Sep 2020 05:28:30 +0000","fetchMs":62,"handleMs":57,"totalMs":120630,"newArticles":0,"totalArticles":5,"status":1,"type":0,"ip":"39ec31ae66b3a830abe9c60d89cc45e6","hostName":"us-030*","requestId":"9cfe4aa40dcb4b418f78d18d65cb3024_12740","contentType":"application/xml; charset=utf-8","totalBytes":124048,"bgimgsTotal":0,"bgimgsGithubTotal":0,"articlesImgsTotal":6,"articlesImgsGithubTotal":5,"successGithubMap":{"myreaderx22":1,"myreaderx2":1,"myreaderx12":1,"myreaderx5oss":1,"myreaderx":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:37:55","updatedTime":"2020-09-05 16:40:22","id":12740,"name":"掘金前端","url":"https://rsshub.app/juejin/category/frontend","subscriber":243,"website":null,"icon":"https://juejin.im/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx65/cdn53@2020_2/2020/09/05/08-40-02-078_24cb365749d306f2.ico","description":"掘金前端 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2020-09-21 13:30:31","updatedTime":"2020-09-21 13:30:31","id":null,"feedId":12740,"linkMd5":"c9ea4101c07afbc906bc1fa40f1135ee"}],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":124048,"tmpBgImgCdnBytes":0,"extra4":{"start":1600666110471,"total":0,"statList":[{"spend":95,"msg":"获取xml内容"},{"spend":57,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":120458,"msg":"正文链接上传到cdn"}]},"extra5":6,"extra6":5,"extra7ImgCdnFailResultVector":[null,null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-032.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-54.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe66.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-003.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://us-015.herokuapp.com/":{"failCount":1,"successCount":1,"resultList":[200,null]},"http://us-027.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67cf879c34bd4ecfafdc1443e4b8b8ab~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":1746,"destHeight":190,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn85@2020_4/2020/09/21/05-28-30-903_4868cd057145dcf6.webp","sourceBytes":23043,"destBytes":13124,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":968,"convertSpendMs":15,"createdTime":"2020-09-21 13:28:30","host":"us-54*","referer":"https://juejin.im/post/6874751458508537864","linkMd5ListStr":"c9ea4101c07afbc906bc1fa40f1135ee","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"22.5 KB","destSize":"12.8 KB","compressRate":"57%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f31616f946e4f6197bffb9dfcf880c5~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":570,"destHeight":300,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn90@2020_1/2020/09/21/05-28-31-144_943dac95f8ccad41.webp","sourceBytes":27164,"destBytes":13138,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":1253,"convertSpendMs":8,"createdTime":"2020-09-21 13:28:30","host":"us-032*","referer":"https://juejin.im/post/6874751458508537864","linkMd5ListStr":"c9ea4101c07afbc906bc1fa40f1135ee","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"26.5 KB","destSize":"12.8 KB","compressRate":"48.4%"},{"code":1,"isDone":false,"source":"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6263f40d5a1449cd999b32f07d0981f1~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":663,"destHeight":246,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx5oss/cdn70@2020_5/2020/09/21/05-28-31-931_e6cf72afe0bfda27.webp","sourceBytes":71549,"destBytes":47786,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":2244,"convertSpendMs":20,"createdTime":"2020-09-21 13:28:30","host":"us-027*","referer":"https://juejin.im/post/6874751458508537864","linkMd5ListStr":"c9ea4101c07afbc906bc1fa40f1135ee","githubUser":"myreaderx5oss","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"69.9 KB","destSize":"46.7 KB","compressRate":"66.8%"},{"code":1,"isDone":false,"source":"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c1e195cc4294dfdbb82bd3faeaefd0a~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":1156,"destHeight":816,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn73@2020_4/2020/09/21/05-28-32-269_014e231f4221a6f0.webp","sourceBytes":49333,"destBytes":30116,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":2476,"convertSpendMs":41,"createdTime":"2020-09-21 13:28:30","host":"us-015*","referer":"https://juejin.im/post/6874751458508537864","linkMd5ListStr":"c9ea4101c07afbc906bc1fa40f1135ee","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"48.2 KB","destSize":"29.4 KB","compressRate":"61%"},{"code":1,"isDone":false,"source":"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8413cfa4f5049cc8b6eface77808736~tplv-k3u1fbpfcp-zoom-1.image","sourceStatusCode":200,"destWidth":1223,"destHeight":445,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn82@2020_1/2020/09/21/05-28-32-331_5fe81cf9e41bd283.webp","sourceBytes":50117,"destBytes":19884,"targetWebpQuality":75,"feedId":12740,"totalSpendMs":2551,"convertSpendMs":22,"createdTime":"2020-09-21 13:28:30","host":"europe66*","referer":"https://juejin.im/post/6874751458508537864","linkMd5ListStr":"c9ea4101c07afbc906bc1fa40f1135ee","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"48.9 KB","destSize":"19.4 KB","compressRate":"39.7%"}],"successGithubMap":{"myreaderx22":1,"myreaderx2":1,"myreaderx12":1,"myreaderx5oss":1,"myreaderx":1},"failGithubMap":{}}