{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2022-03-14 19:15:04","updatedTime":"2022-03-14 19:15:04","title":"Solid.js 就是我理想中的 React","link":"http://weixin.sogou.com/weixin?type=2&query=%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%B7%85+Solid.js%20%E5%B0%B1%E6%98%AF%E6%88%91%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%20React","description":"<div><div><div id=\"media\" class=\"rich_media_thumb_wrp\">\n\n            <img class=\"rich_media_thumb\" src=\"http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/XIibZ0YbvibkV3G0MndibNNpuv69CkgHuIvEzh1ERhhbwPXC2Sv3cKpAokjDib87dPZwe8QSoXqfxVlbDkyn9M0d8g/0?wx_fmt=jpeg?imageView2/1/w/600\">\n        </div>\n    \n\n    \n\n    <div class=\"rich_media_content\" id=\"js_content\">\n                    \n\n                    \n                    \n                    \n                    <section style=\"text-align: center;margin-bottom: 20px;\"><img class=\"rich_pages wxw-img js_insertlocalimg\" data-ratio=\"0.66640625\" data-s=\"300,640\" data-type=\"jpeg\" data-w=\"1280\" style=\"max-width: 600px\" src=\"http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/XIibZ0YbvibkV3G0MndibNNpuv69CkgHuIvJvIyQ2YmCia0x85avwsmySQcezKkFFa9ME13cFowQAe5zXYXZJW8Hqw/640?wx_fmt=jpeg\"></section><section style=\"color: rgb(63, 63, 63);font-size: 16px;font-family: Avenir, -apple-system-font, 微软雅黑, sans-serif;box-sizing: border-box;\"><section style=\"box-sizing: border-box;font-size: 14px;color: rgb(145, 145, 145);text-align: left;line-height: 1em;margin-top: 13px;padding-left: 14px;\">作者 | Nick Scialli\t</section><section style=\"box-sizing: border-box;font-size: 14px;color: rgb(145, 145, 145);text-align: left;line-height: 1em;margin-top: 13px;padding-left: 14px;\">\n\t\t译者 | 王强\t</section><section style=\"box-sizing: border-box;font-size: 14px;color: rgb(145, 145, 145);text-align: left;line-height: 1em;margin-top: 13px;padding-left: 14px;\">\n\t\t策划 | 闫园园\t</section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">我大约在三年前开始在工作中使用 React。巧合的是，当时正好是 React Hooks 出来的时候。我当时的项目代码库有很多类组件，总让我觉得很笨重。</p><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">我们来看看下面的例子：一个每秒递增一次的计数器。</p><section class=\"code-snippet__fix code-snippet__js\"><ul class=\"code-snippet__line-index code-snippet__js\"><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class=\"code-snippet__js\" data-lang=\"kotlin\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__class\"><span class=\"code-snippet__keyword\">class</span> <span class=\"code-snippet__title\">Counter</span> <span class=\"code-snippet__title\">extends</span> <span class=\"code-snippet__title\">React</span>.<span class=\"code-snippet__title\">Component</span> </span>{</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">constructor</span>() {</span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__keyword\">super</span>();</span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__keyword\">this</span>.state = { count: <span class=\"code-snippet__number\">0</span> };</span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__keyword\">this</span>.increment = <span class=\"code-snippet__keyword\">this</span>.increment.bind(<span class=\"code-snippet__keyword\">this</span>);</span></code><code><span class=\"code-snippet_outer\">  }</span></code><code><span class=\"code-snippet_outer\">  increment() {</span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__keyword\">this</span>.setState({ count: <span class=\"code-snippet__keyword\">this</span>.state.count + <span class=\"code-snippet__number\">1</span> });</span></code><code><span class=\"code-snippet_outer\">  }</span></code><code><span class=\"code-snippet_outer\">  componentDidMount() {</span></code><code><span class=\"code-snippet_outer\">    setInterval(() =&gt; {</span></code><code><span class=\"code-snippet_outer\">      <span class=\"code-snippet__keyword\">this</span>.increment();</span></code><code><span class=\"code-snippet_outer\">    }, <span class=\"code-snippet__number\">1000</span>);</span></code><code><span class=\"code-snippet_outer\">  }</span></code><code><span class=\"code-snippet_outer\">  render() {</span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__keyword\">return</span> <div>The count <span class=\"code-snippet__keyword\">is</span>: {<span class=\"code-snippet__keyword\">this</span>.state.count}</div>;</span></code><code><span class=\"code-snippet_outer\">  }</span></code><code><span class=\"code-snippet_outer\">}</span></code></pre></section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">对于一个自动递增的计数器来说要写这么多代码可不算少。更多的模板和仪式意味着出错的可能性更大，开发体验也更差。</p><section style=\"box-sizing: border-box;text-align: center;font-size: 20px;\">\n\t\t<span style=\"height: 65px;line-height: 95px;color: rgb(60, 112, 198);border-bottom: 2px solid rgb(27, 95, 160);background-image: url(\" https: no-repeat initial inline-block>Hooks 很漂亮，但是容易出错</span>\n\t</section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">当 hooks 出现的时候我非常兴奋。我的计数器可以简化为以下写法：</p><section class=\"code-snippet__fix code-snippet__js\"><ul class=\"code-snippet__line-index code-snippet__js\"><li><li><li><li><li><li><li><li><li></ul><pre class=\"code-snippet__js\" data-lang=\"javascript\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__function\"><span class=\"code-snippet__keyword\">function</span> <span class=\"code-snippet__title\">Counter</span>(<span class=\"code-snippet__params\"></span>) </span>{</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">const</span> [count, setCount] = useState(<span class=\"code-snippet__number\">0</span>);</span></code><code><span class=\"code-snippet_outer\">  useEffect(<span class=\"code-snippet__function\"><span class=\"code-snippet__params\">()</span> =&gt;</span> {</span></code><code><span class=\"code-snippet_outer\">    setInterval(<span class=\"code-snippet__function\"><span class=\"code-snippet__params\">()</span> =&gt;</span> {</span></code><code><span class=\"code-snippet_outer\">      setCount(count + <span class=\"code-snippet__number\">1</span>);</span></code><code><span class=\"code-snippet_outer\">    }, <span class=\"code-snippet__number\">1000</span>);</span></code><code><span class=\"code-snippet_outer\">  }, []);</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">return</span> <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">div</span>&gt;</span>The count is: {count}<span class=\"code-snippet__tag\"><span class=\"code-snippet__name\">div</span>&gt;</span>;</span></code><code><span class=\"code-snippet_outer\">}</span></code></pre></section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">等等，这其实是不对的。我们的 useEffect hook 在 count 周围有一个陈旧闭包，因为我们没有把 count 包含在 useEffect 依赖数组中。从依赖数组中省略变量是 React hooks 的一个常见错误，如果你忘记了，有一些 linting 规则会警告你的。</p><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">我稍后会回到这个问题上。现在，我们把缺少的 count 变量添加到依赖数组中：</p><section class=\"code-snippet__fix code-snippet__js\"><ul class=\"code-snippet__line-index code-snippet__js\"><li><li><li><li><li><li><li><li><li></ul><pre class=\"code-snippet__js\" data-lang=\"javascript\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__function\"><span class=\"code-snippet__keyword\">function</span> <span class=\"code-snippet__title\">Counter</span>(<span class=\"code-snippet__params\"></span>) </span>{</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">const</span> [count, setCount] = useState(<span class=\"code-snippet__number\">0</span>);</span></code><code><span class=\"code-snippet_outer\">  useEffect(<span class=\"code-snippet__function\"><span class=\"code-snippet__params\">()</span> =&gt;</span> {</span></code><code><span class=\"code-snippet_outer\">    setInterval(<span class=\"code-snippet__function\"><span class=\"code-snippet__params\">()</span> =&gt;</span> {</span></code><code><span class=\"code-snippet_outer\">      setCount(count + <span class=\"code-snippet__number\">1</span>);</span></code><code><span class=\"code-snippet_outer\">    }, <span class=\"code-snippet__number\">1000</span>);</span></code><code><span class=\"code-snippet_outer\">  }, [count]);</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">return</span> <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">div</span>&gt;</span>The count is: {count}<span class=\"code-snippet__tag\"><span class=\"code-snippet__name\">div</span>&gt;</span>;</span></code><code><span class=\"code-snippet_outer\">}</span></code></pre></section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">但现在我们遇到了另一个问题，看看应用程序的运行效果：</p><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\"><img class=\"rich_pages wxw-img\" data-ratio=\"0.398876404494382\" data-type=\"gif\" data-w=\"356\" height=\"auto\" width=\"356\" src=\"http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/XIibZ0YbvibkV3G0MndibNNpuv69CkgHuIv2uZJS8ESSIp4n3ysOCfXm7AuGOAib8aFEYkeZjlH0jvmLzRHMZ9XANw/640?wx_fmt=gif\" style=\"max-width: 600px\"></p><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">精通 React 的人们可能知道发生了什么事情，因为你每天都在与这种问题作斗争：我们创建了太多的间隔（每次重新运行效果时都会创建一个新间隔，也就是每次我们增加 count 时间隔都会增加）。可以通过几种方式来解决这个问题：</p><ul style=\"margin-top: 14px;line-height: 1.75em;text-align: left;\" class=\"list-paddingleft-1\"><li style=\"text-align: left;\"><p>从清除间隔的 useEffect hook 返回一个清理函数</p></li><li style=\"text-align: left;\"><p>使用 setTimeout 代替 setInterval（还是要使用清理函数）</p></li><li style=\"text-align: left;\"><p>使用 setCount 的函数形式来避免直接引用当前值</p></li></ul><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">事实上哪种办法都行得通。我们在这里实现最后一个选项：</p><section class=\"code-snippet__fix code-snippet__js\"><ul class=\"code-snippet__line-index code-snippet__js\"><li><li><li><li><li><li><li><li><li></ul><pre class=\"code-snippet__js\" data-lang=\"javascript\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__function\"><span class=\"code-snippet__keyword\">function</span> <span class=\"code-snippet__title\">Counter</span>(<span class=\"code-snippet__params\"></span>) </span>{</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">const</span> [count, setCount] = useState(<span class=\"code-snippet__number\">0</span>);</span></code><code><span class=\"code-snippet_outer\">  useEffect(<span class=\"code-snippet__function\"><span class=\"code-snippet__params\">()</span> =&gt;</span> {</span></code><code><span class=\"code-snippet_outer\">    setInterval(<span class=\"code-snippet__function\"><span class=\"code-snippet__params\">()</span> =&gt;</span> {</span></code><code><span class=\"code-snippet_outer\">      setCount(<span class=\"code-snippet__function\">(<span class=\"code-snippet__params\">count</span>) =&gt;</span> count + <span class=\"code-snippet__number\">1</span>);</span></code><code><span class=\"code-snippet_outer\">    }, <span class=\"code-snippet__number\">1000</span>);</span></code><code><span class=\"code-snippet_outer\">  }, []);</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">return</span> <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">div</span>&gt;</span>The count is: {count}<span class=\"code-snippet__tag\"><span class=\"code-snippet__name\">div</span>&gt;</span>;</span></code><code><span class=\"code-snippet_outer\">}</span></code></pre></section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">我们的计数器修好了！由于依赖数组中没有任何内容，因此我们只创建了一个间隔。由于我们为计数设置器使用了回调函数，因此永远不会在 count 变量上有陈旧闭包。</p><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">这是一个人为做出来的例子，但除非你已经使用 React 一段时间，否则它仍然很令人困惑。我们中有许多人每天都会遇到更复杂的情况，即使是最有经验的 React 开发人员也会为之头痛不已。</p><section style=\"box-sizing: border-box;text-align: center;font-size: 20px;\">\n\t\t<span style=\"height: 65px;line-height: 95px;color: rgb(60, 112, 198);border-bottom: 2px solid rgb(27, 95, 160);background-image: url(\" https: no-repeat initial inline-block>假的响应性</span>\n\t</section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">我思考了很多关于 hooks 的事情，想知道为什么它们感觉不太对劲。结果我通过探索 Solid.js 找到了答案。</p><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">React hooks 的问题在于 React 并不是真正的响应式设计。如果 linter 知道一个效果（或回调或 memo）hook 何时缺少依赖项，那么为什么框架不能自动检测依赖项并对这些更改做出响应呢？</p><section style=\"box-sizing: border-box;text-align: center;font-size: 20px;\">\n\t\t<span style=\"height: 65px;line-height: 95px;color: rgb(60, 112, 198);border-bottom: 2px solid rgb(27, 95, 160);background-image: url(\" https: no-repeat initial inline-block>深入研究 Solid.js</span>\n\t</section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">关于 Solid，首先要注意的是它没有尝试重新发明轮子：它看起来很像 React，因为 React 有一些显眼的模式：单向、自上而下的状态；JSX；组件驱动的架构。</p><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">如果我们用 Solid 重写 Counter 组件，会这样开始：</p><section class=\"code-snippet__fix code-snippet__js\"><ul class=\"code-snippet__line-index code-snippet__js\"><li><li><li><li><li></ul><pre class=\"code-snippet__js\" data-lang=\"javascript\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__function\"><span class=\"code-snippet__keyword\">function</span> <span class=\"code-snippet__title\">Counter</span>(<span class=\"code-snippet__params\"></span>) </span>{</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">const</span> [count, setCount] = createSignal(<span class=\"code-snippet__number\">0</span>);</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">return</span> <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">div</span>&gt;</span>The count is: {count()}<span class=\"code-snippet__tag\"><span class=\"code-snippet__name\">div</span>&gt;</span>;</span></code><code><span class=\"code-snippet_outer\">}</span></code><code><span class=\"code-snippet_outer\"><br></span></code></pre></section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">到目前为止我们看到了一个很大的不同点：count 是一个函数。这称为访问器（accessor），它是 Solid 工作机制的重要组成部分。当然，我们这里没有关于按间隔递增 count 的内容，所以下面把它添加进去：</p><section class=\"code-snippet__fix code-snippet__js\"><ul class=\"code-snippet__line-index code-snippet__js\"><li><li><li><li><li><li><li></ul><pre class=\"code-snippet__js\" data-lang=\"javascript\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__function\"><span class=\"code-snippet__keyword\">function</span> <span class=\"code-snippet__title\">Counter</span>(<span class=\"code-snippet__params\"></span>) </span>{</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">const</span> [count, setCount] = createSignal(<span class=\"code-snippet__number\">0</span>);</span></code><code><span class=\"code-snippet_outer\">  setInterval(<span class=\"code-snippet__function\"><span class=\"code-snippet__params\">()</span> =&gt;</span> {</span></code><code><span class=\"code-snippet_outer\">    setCount(count() + <span class=\"code-snippet__number\">1</span>);</span></code><code><span class=\"code-snippet_outer\">  }, <span class=\"code-snippet__number\">1000</span>);</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">return</span> <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">div</span>&gt;</span>The count is: {count()}<span class=\"code-snippet__tag\"><span class=\"code-snippet__name\">div</span>&gt;</span>;</span></code><code><span class=\"code-snippet_outer\">}</span></code></pre></section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">这肯定行不通，对吧？每次组件渲染时不会设置新的间隔吗？</p><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">没有。它就这么正常运行了。</p><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">但为什么会这样？好吧，事实证明 Solid 不需要重新运行 Counter 函数来重渲染新的计数。事实上，它根本不需要重新运行 Counter 函数。如果我们在 Counter 函数中添加一个 console.log 语句，就会看到它只运行一次。</p><section class=\"code-snippet__fix code-snippet__js\"><ul class=\"code-snippet__line-index code-snippet__js\"><li><li><li><li><li><li><li><li></ul><pre class=\"code-snippet__js\" data-lang=\"javascript\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__function\"><span class=\"code-snippet__keyword\">function</span> <span class=\"code-snippet__title\">Counter</span>(<span class=\"code-snippet__params\"></span>) </span>{</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">const</span> [count, setCount] = createSignal(<span class=\"code-snippet__number\">0</span>);</span></code><code><span class=\"code-snippet_outer\">  setInterval(<span class=\"code-snippet__function\"><span class=\"code-snippet__params\">()</span> =&gt;</span> {</span></code><code><span class=\"code-snippet_outer\">    setCount(count() + <span class=\"code-snippet__number\">1</span>);</span></code><code><span class=\"code-snippet_outer\">  }, <span class=\"code-snippet__number\">1000</span>);</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__built_in\">console</span>.log(<span class=\"code-snippet__string\">'The Counter function was called!'</span>);</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">return</span> <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">div</span>&gt;</span>The count is: {count()}<span class=\"code-snippet__tag\"><span class=\"code-snippet__name\">div</span>&gt;</span>;</span></code><code><span class=\"code-snippet_outer\">}</span></code></pre></section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">在我们的控制台中，只有一个孤独的日志语句：</p><section class=\"code-snippet__fix code-snippet__js\"><ul class=\"code-snippet__line-index code-snippet__js\"><li></ul><pre class=\"code-snippet__js\" data-lang=\"javascript\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__string\">\"The Counter function was called!\"</span></span></code></pre></section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">在 Solid 中，除非我们明确要求，否则代码不会多次运行。</p><section style=\"box-sizing: border-box;text-align: center;font-size: 20px;\">\n\t\t<span style=\"height: 65px;line-height: 95px;color: rgb(60, 112, 198);border-bottom: 2px solid rgb(27, 95, 160);background-image: url(\" https: no-repeat initial inline-block>但是 hooks 呢？</span>\n\t</section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">于是我在 Solid 中解决了 React useEffect hook 的问题，而无需编写看起来像 hooks 的东西。我们可以扩展我们的计数器例子来探索 Solid 效果。</p><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">如果我们想在每次计数增加时 console.log count 怎么办？你的第一反应可能是在我们的函数中使用 console.log：</p><section class=\"code-snippet__fix code-snippet__js\"><ul class=\"code-snippet__line-index code-snippet__js\"><li><li><li><li><li><li><li><li></ul><pre class=\"code-snippet__js\" data-lang=\"javascript\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__function\"><span class=\"code-snippet__keyword\">function</span> <span class=\"code-snippet__title\">Counter</span>(<span class=\"code-snippet__params\"></span>) </span>{</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">const</span> [count, setCount] = createSignal(<span class=\"code-snippet__number\">0</span>);</span></code><code><span class=\"code-snippet_outer\">  setInterval(<span class=\"code-snippet__function\"><span class=\"code-snippet__params\">()</span> =&gt;</span> {</span></code><code><span class=\"code-snippet_outer\">    setCount(count() + <span class=\"code-snippet__number\">1</span>);</span></code><code><span class=\"code-snippet_outer\">  }, <span class=\"code-snippet__number\">1000</span>);</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__built_in\">console</span>.log(<span class=\"code-snippet__string\">`The count is <span class=\"code-snippet__subst\">${count()}</span>`</span>);</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">return</span> <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">div</span>&gt;</span>The count is: {count()}<span class=\"code-snippet__tag\"><span class=\"code-snippet__name\">div</span>&gt;</span>;</span></code><code><span class=\"code-snippet_outer\">}</span></code></pre></section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">但这不起作用。请记住，Counter 函数只运行一次！但我们可以使用 Solid 的 createEffect 函数来获得想要的效果：</p><section class=\"code-snippet__fix code-snippet__js\"><ul class=\"code-snippet__line-index code-snippet__js\"><li><li><li><li><li><li><li><li><li><li></ul><pre class=\"code-snippet__js\" data-lang=\"javascript\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__function\"><span class=\"code-snippet__keyword\">function</span> <span class=\"code-snippet__title\">Counter</span>(<span class=\"code-snippet__params\"></span>) </span>{</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">const</span> [count, setCount] = createSignal(<span class=\"code-snippet__number\">0</span>);</span></code><code><span class=\"code-snippet_outer\">  setInterval(<span class=\"code-snippet__function\"><span class=\"code-snippet__params\">()</span> =&gt;</span> {</span></code><code><span class=\"code-snippet_outer\">    setCount(count() + <span class=\"code-snippet__number\">1</span>);</span></code><code><span class=\"code-snippet_outer\">  }, <span class=\"code-snippet__number\">1000</span>);</span></code><code><span class=\"code-snippet_outer\">  createEffect(<span class=\"code-snippet__function\"><span class=\"code-snippet__params\">()</span> =&gt;</span> {</span></code><code><span class=\"code-snippet_outer\">    <span class=\"code-snippet__built_in\">console</span>.log(<span class=\"code-snippet__string\">`The count is <span class=\"code-snippet__subst\">${count()}</span>`</span>);</span></code><code><span class=\"code-snippet_outer\">  });</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">return</span> <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">div</span>&gt;</span>The count is: {count()}<span class=\"code-snippet__tag\"><span class=\"code-snippet__name\">div</span>&gt;</span>;</span></code><code><span class=\"code-snippet_outer\">}</span></code></pre></section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">这行得通！而且我们甚至不必告诉 Solid，说这个效果取决于 count 变量。这才是真正的响应式设计。如果在 createEffect 函数内部调用了第二个访问器，它也会让效果运行起来。</p><section style=\"box-sizing: border-box;text-align: center;font-size: 20px;\">\n\t\t<span style=\"height: 65px;line-height: 95px;color: rgb(60, 112, 198);border-bottom: 2px solid rgb(27, 95, 160);background-image: url(\" https: no-repeat initial inline-block>一些更有趣的 Solid 概念</span>\n\t</section><section style=\"box-sizing: border-box;text-align: center;\">\n\t\t<span style=\"display: inline-block;height: 38px;line-height: 42px;color: rgb(60, 112, 198);background-image: url(\" https: left center no-repeat initial>响应性，而不是生命周期 hooks</span>\n\t</section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">如果你已经在 React 领域有一段时间的经验了，那么下面的代码更改可能真的会让你大跌眼镜：</p><section class=\"code-snippet__fix code-snippet__js\"><ul class=\"code-snippet__line-index code-snippet__js\"><li><li><li><li><li><li><li><li><li><li></ul><pre class=\"code-snippet__js\" data-lang=\"javascript\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__keyword\">const</span> [count, setCount] = createSignal(<span class=\"code-snippet__number\">0</span>);</span></code><code><span class=\"code-snippet_outer\">setInterval(<span class=\"code-snippet__function\"><span class=\"code-snippet__params\">()</span> =&gt;</span> {</span></code><code><span class=\"code-snippet_outer\">  setCount(count() + <span class=\"code-snippet__number\">1</span>);</span></code><code><span class=\"code-snippet_outer\">}, <span class=\"code-snippet__number\">1000</span>);</span></code><code><span class=\"code-snippet_outer\">createEffect(<span class=\"code-snippet__function\"><span class=\"code-snippet__params\">()</span> =&gt;</span> {</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__built_in\">console</span>.log(<span class=\"code-snippet__string\">`The count is <span class=\"code-snippet__subst\">${count()}</span>`</span>);</span></code><code><span class=\"code-snippet_outer\">});</span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__function\"><span class=\"code-snippet__keyword\">function</span> <span class=\"code-snippet__title\">Counter</span>(<span class=\"code-snippet__params\"></span>) </span>{</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">return</span> <span class=\"code-snippet__tag\">&lt;<span class=\"code-snippet__name\">div</span>&gt;</span>The count is: {count()}<span class=\"code-snippet__tag\"><span class=\"code-snippet__name\">div</span>&gt;</span>;</span></code><code><span class=\"code-snippet_outer\">}</span></code></pre></section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">并且代码仍然是有效的。我们的 count 信号不需要存在于一个组件函数中，依赖它的效果也不需要。一切都只是响应式系统的一部分，“生命周期 hooks”实际上并没有起到太大的作用。</p><section style=\"box-sizing: border-box;text-align: center;\">\n\t\t<span style=\"display: inline-block;height: 38px;line-height: 42px;color: rgb(60, 112, 198);background-image: url(\" https: left center no-repeat initial>细粒度的 DOM 更新</span>\n\t</section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">前面我主要关注的是 Solid 的开发体验（例如更容易编写没有错误的代码），但 Solid 的性能表现也得到了很多赞誉。其强大性能的一个关键来源是它直接与 DOM 交互（无虚拟 DOM）并执行“细粒度”的 DOM 更新。</p><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">考虑对我们的计数器进行以下调整：</p><section class=\"code-snippet__fix code-snippet__js\"><ul class=\"code-snippet__line-index code-snippet__js\"><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre class=\"code-snippet__js\" data-lang=\"php\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__function\"><span class=\"code-snippet__keyword\">function</span> <span class=\"code-snippet__title\">Counter</span><span class=\"code-snippet__params\">()</span> </span>{</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">const</span> [count, setCount] = createSignal(<span class=\"code-snippet__number\">0</span>);</span></code><code><span class=\"code-snippet_outer\">  setInterval(() =&gt; {</span></code><code><span class=\"code-snippet_outer\">    setCount(count() + <span class=\"code-snippet__number\">1</span>);</span></code><code><span class=\"code-snippet_outer\">  }, <span class=\"code-snippet__number\">1000</span>);</span></code><code><span class=\"code-snippet_outer\">  <span class=\"code-snippet__keyword\">return</span> (</span></code><code><span class=\"code-snippet_outer\">    <div><code><span class=\"code-snippet_outer\">      The {(console.log(<span class=\"code-snippet__string\">'DOM update A'</span>), <span class=\"code-snippet__keyword\">false</span>)} count is:{<span class=\"code-snippet__string\">' '</span>}</span></code><code><span class=\"code-snippet_outer\">      {(console.log(<span class=\"code-snippet__string\">'DOM update B'</span>), count())}</span></code><code><span class=\"code-snippet_outer\">    </span></code></div></span></code><code><span class=\"code-snippet_outer\">  );</span></code><code><span class=\"code-snippet_outer\">}</span></code></pre></section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">运行它会在控制台中获得以下日志：</p><section class=\"code-snippet__fix code-snippet__js\"><ul class=\"code-snippet__line-index code-snippet__js\"><li><li><li><li><li><li><li></ul><pre class=\"code-snippet__js\" data-lang=\"properties\"><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">DOM</span> <span class=\"code-snippet__string\">update A</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">DOM</span> <span class=\"code-snippet__string\">update B</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">DOM</span> <span class=\"code-snippet__string\">update B</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">DOM</span> <span class=\"code-snippet__string\">update B</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">DOM</span> <span class=\"code-snippet__string\">update B</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">DOM</span> <span class=\"code-snippet__string\">update B</span></span></code><code><span class=\"code-snippet_outer\"><span class=\"code-snippet__attr\">DOM update B</span></span></code></pre></section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">换句话说，每秒更新的唯一内容是包含 count 的一小部分 DOM。Solid 甚至没有重新运行同一 div 中较早的 console.log。</p><section style=\"box-sizing: border-box;text-align: center;font-size: 20px;\">\n\t\t<span style=\"height: 65px;line-height: 95px;color: rgb(60, 112, 198);border-bottom: 2px solid rgb(27, 95, 160);background-image: url(\" https: no-repeat initial inline-block>小结</span>\n\t</section><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\">在过去的几年里我很喜欢使用 React；在处理实际的 DOM 时，我总感觉它有着正确的抽象级别。话虽如此，我也开始注意到 React hooks 代码经常变得容易出错。我感觉 Solid.js 使用了 React 的许多符合人体工程学的部分，同时最大程度减少了混乱和错误。本文向你展示的是 Solid 的一些让我惊叹的部分，感兴趣的话我建议你查看 https://www.solidjs.com 并自己探索这个框架。</p><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\"><span style=\"color: rgb(136, 136, 136);\"><strong><span style=\"color: rgb(136, 136, 136);font-size: 14px;\">原文链接：</span></strong></span></p><p style=\"box-sizing: border-box;white-space: pre-line;padding-top: 23px;padding-right: 8px;padding-left: 8px;color: rgb(74, 74, 74);line-height: 1.75em;\"><span style=\"font-size: 14px;color: rgb(136, 136, 136);\">https://typeofnan.dev/solid-js-feels-like-what-i-always-wanted-react-to-be/</span></p></section>\n                </div>\n\n    \n    <br>\n\n    \n        <a target=\"_blank\" href=\"http://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247513757&amp;idx=1&amp;sn=a828aa97c450b90c13ef0bd4a6fdbb5a&amp;chksm=f95203dece258ac8df119db9485edae25af640ccb7d6ec3f965cd1d7835059ace6cb8bf29a44#rd\" style=\"color: blue\" class=\"media_tool_meta meta_primary\">文章原文</a>\n        <br>\n    \n\n    \n\n    <img alt=\"\" width=\"1px\" height=\"1px\" class=\"\" style=\"width:1px;height:1px;display:none\" src=\"http://www.jintiankansha.me/rss_static/19192/pR8ZrKfGmw\"></div></div>","descriptionType":"html","publishedDate":"Fri, 11 Mar 2022 07:15:00 +0000","feedId":2775,"bgimg":"http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/XIibZ0YbvibkV3G0MndibNNpuv69CkgHuIvEzh1ERhhbwPXC2Sv3cKpAokjDib87dPZwe8QSoXqfxVlbDkyn9M0d8g/0?wx_fmt=jpeg?imageView2/1/w/600","linkMd5":"ad537433b8a91a9e5e476daeae1f7203","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn46@2020_5/2022/03/14/11-16-22-117_2889ac6213d1788d.webp","destWidth":1080,"destHeight":460,"sourceBytes":68661,"destBytes":46940,"author":"","articleImgCdnMap":{"http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/XIibZ0YbvibkV3G0MndibNNpuv69CkgHuIvEzh1ERhhbwPXC2Sv3cKpAokjDib87dPZwe8QSoXqfxVlbDkyn9M0d8g/0?wx_fmt=jpeg?imageView2/1/w/600":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn46@2020_5/2022/03/14/11-16-22-117_2889ac6213d1788d.webp","http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/XIibZ0YbvibkV3G0MndibNNpuv69CkgHuIvJvIyQ2YmCia0x85avwsmySQcezKkFFa9ME13cFowQAe5zXYXZJW8Hqw/640?wx_fmt=jpeg":null,"http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/XIibZ0YbvibkV3G0MndibNNpuv69CkgHuIv2uZJS8ESSIp4n3ysOCfXm7AuGOAib8aFEYkeZjlH0jvmLzRHMZ9XANw/640?wx_fmt=gif":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn76@2020_1/2022/03/14/11-18-46-985_136daf8a78a0fe9e.webp","http://www.jintiankansha.me/rss_static/19192/pR8ZrKfGmw":null},"publishedOrCreatedDate":1647256504074}],"record":{"createdTime":"2022-03-14 19:15:04","updatedTime":"2022-03-14 19:15:04","feedId":2775,"fetchDate":"Mon, 14 Mar 2022 11:15:04 +0000","fetchMs":426,"handleMs":20,"totalMs":224433,"newArticles":0,"totalArticles":5,"status":1,"type":0,"ip":"bc1eecef1292254c09de6c1e66b750f3","hostName":"europe-22*","requestId":"e8443b4a5128440b9f52774b0be7b873_2775","contentType":"application/rss+xml","totalBytes":67096,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":4,"articlesImgsGithubTotal":2,"successGithubMap":{"myreaderx15":1,"myreaderx2":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-24 21:31:44","updatedTime":"2020-09-01 10:14:55","id":2775,"name":"前端之巅","url":"http://feedmaker.kindle4rss.com/feeds/frontshow.weixin.xml","subscriber":null,"website":null,"icon":"http://www.sogou.com/images/logo/new/favicon.ico?v=4","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx63/cdn48@2020_6/2020/09/01/02-14-41-796_d24121c9beed1de6.ico","description":"InfoQ大前端技术社群：囊括前端、移动、Node全栈一线技术，紧跟业界发展步伐。","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2022-03-14 19:18:47","updatedTime":"2022-03-14 19:18:47","id":null,"feedId":2775,"linkMd5":"ad537433b8a91a9e5e476daeae1f7203"}],"tmpCommonImgCdnBytes":46940,"tmpBodyImgCdnBytes":20156,"tmpBgImgCdnBytes":0,"extra4":{"start":1647256502985,"total":0,"statList":[{"spend":1069,"msg":"获取xml内容"},{"spend":20,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":144503,"msg":"正文链接上传到cdn"}]},"extra5":4,"extra6":3,"extra7ImgCdnFailResultVector":[null,{"code":1,"isDone":false,"source":"http://www.jintiankansha.me/rss_static/19192/pR8ZrKfGmw","sourceStatusCode":405,"sourceBytes":0,"destBytes":0,"feedId":2775,"totalSpendMs":452,"convertSpendMs":0,"createdTime":"2022-03-14 19:16:23","host":"us-009*","referer":"http://weixin.sogou.com/weixin?type=2&query=%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%B7%85+Solid.js%20%E5%B0%B1%E6%98%AF%E6%88%91%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%20React","linkMd5ListStr":"ad537433b8a91a9e5e476daeae1f7203","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[405],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/XIibZ0YbvibkV3G0MndibNNpuv69CkgHuIv2uZJS8ESSIp4n3ysOCfXm7AuGOAib8aFEYkeZjlH0jvmLzRHMZ9XANw/640?wx_fmt=gif","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":2775,"totalSpendMs":773,"convertSpendMs":0,"createdTime":"2022-03-14 19:16:22","host":"europe21*","referer":"http://weixin.sogou.com/weixin?type=2&query=%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%B7%85+Solid.js%20%E5%B0%B1%E6%98%AF%E6%88%91%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%20React","linkMd5ListStr":"ad537433b8a91a9e5e476daeae1f7203","extra22GetBytesInfo":"2、Referer字段 ： http://weixin.sogou.com/weixin?type=2&query=%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%B7%85+Solid.js%20%E5%B0%B1%E6%98%AF%E6%88%91%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%20React","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"http://www.jintiankansha.me/rss_static/19192/pR8ZrKfGmw","sourceStatusCode":405,"sourceBytes":0,"destBytes":0,"feedId":2775,"totalSpendMs":479,"convertSpendMs":0,"createdTime":"2022-03-14 19:16:23","host":"us-020*","referer":"http://weixin.sogou.com/weixin?type=2&query=%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%B7%85+Solid.js%20%E5%B0%B1%E6%98%AF%E6%88%91%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%20React","linkMd5ListStr":"ad537433b8a91a9e5e476daeae1f7203","extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[405],"sourceSize":"0","destSize":"0"},null,{"code":1,"isDone":false,"source":"http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/XIibZ0YbvibkV3G0MndibNNpuv69CkgHuIv2uZJS8ESSIp4n3ysOCfXm7AuGOAib8aFEYkeZjlH0jvmLzRHMZ9XANw/640?wx_fmt=gif","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":2775,"totalSpendMs":773,"convertSpendMs":0,"createdTime":"2022-03-14 19:16:22","host":"europe21*","referer":"http://weixin.sogou.com/weixin?type=2&query=%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%B7%85+Solid.js%20%E5%B0%B1%E6%98%AF%E6%88%91%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%20React","linkMd5ListStr":"ad537433b8a91a9e5e476daeae1f7203","extra22GetBytesInfo":"2、Referer字段 ： http://weixin.sogou.com/weixin?type=2&query=%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%B7%85+Solid.js%20%E5%B0%B1%E6%98%AF%E6%88%91%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%20React","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},{"code":1,"isDone":false,"source":"http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/XIibZ0YbvibkV3G0MndibNNpuv69CkgHuIv2uZJS8ESSIp4n3ysOCfXm7AuGOAib8aFEYkeZjlH0jvmLzRHMZ9XANw/640?wx_fmt=gif","sourceStatusCode":403,"sourceBytes":0,"destBytes":0,"feedId":2775,"totalSpendMs":773,"convertSpendMs":0,"createdTime":"2022-03-14 19:16:22","host":"europe21*","referer":"http://weixin.sogou.com/weixin?type=2&query=%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%B7%85+Solid.js%20%E5%B0%B1%E6%98%AF%E6%88%91%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%20React","linkMd5ListStr":"ad537433b8a91a9e5e476daeae1f7203","extra22GetBytesInfo":"2、Referer字段 ： http://weixin.sogou.com/weixin?type=2&query=%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%B7%85+Solid.js%20%E5%B0%B1%E6%98%AF%E6%88%91%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%20React","extra23historyStatusCode":[403,403],"sourceSize":"0","destSize":"0"},null],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-020.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[405]},"http://europe-25.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[403]},"http://europe21.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[403]},"http://us-021.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://europe67.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-015.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[403]},"http://us-009.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[405]},"http://us-011.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_jpg/XIibZ0YbvibkV3G0MndibNNpuv69CkgHuIvEzh1ERhhbwPXC2Sv3cKpAokjDib87dPZwe8QSoXqfxVlbDkyn9M0d8g/0?wx_fmt=jpeg?imageView2/1/w/600","sourceStatusCode":200,"destWidth":1080,"destHeight":460,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn46@2020_5/2022/03/14/11-16-22-117_2889ac6213d1788d.webp","sourceBytes":68661,"destBytes":46940,"targetWebpQuality":75,"feedId":2775,"totalSpendMs":17474,"convertSpendMs":44,"createdTime":"2022-03-14 19:16:05","host":"europe62*","referer":"http://weixin.sogou.com/weixin?type=2&query=%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%B7%85+Solid.js%20%E5%B0%B1%E6%98%AF%E6%88%91%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%20React","linkMd5ListStr":"ad537433b8a91a9e5e476daeae1f7203,ad537433b8a91a9e5e476daeae1f7203","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"compressRate":"68.4%","sourceSize":"67.1 KB","destSize":"45.8 KB"},{"code":1,"isDone":false,"source":"http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_gif/XIibZ0YbvibkV3G0MndibNNpuv69CkgHuIv2uZJS8ESSIp4n3ysOCfXm7AuGOAib8aFEYkeZjlH0jvmLzRHMZ9XANw/640?wx_fmt=gif","sourceStatusCode":200,"destWidth":356,"destHeight":142,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn76@2020_1/2022/03/14/11-18-46-985_136daf8a78a0fe9e.webp","sourceBytes":42451,"destBytes":20156,"targetWebpQuality":75,"feedId":2775,"totalSpendMs":22261,"convertSpendMs":53,"createdTime":"2022-03-14 19:18:25","host":"europe67*","referer":"http://weixin.sogou.com/weixin?type=2&query=%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%B7%85+Solid.js%20%E5%B0%B1%E6%98%AF%E6%88%91%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%20React","linkMd5ListStr":"ad537433b8a91a9e5e476daeae1f7203","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"compressRate":"47.5%","sourceSize":"41.5 KB","destSize":"19.7 KB"}],"successGithubMap":{"myreaderx15":1,"myreaderx2":1},"failGithubMap":{}}