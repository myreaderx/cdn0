{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-14 11:37:03","updatedTime":"2020-10-14 11:37:03","title":"File Downloads Done Right","link":"http://www.therailsway.com/2009/2/22/file-downloads-done-right","description":"\n            <p>Getting your file downloads right is one of the most important parts of your File Management functionality.  A poorly implemented download function can make your application painful to use, not just for downloaders, but for everyone else too.</p>\n\n\n\t<p>Thankfully it’s also one of the easiest things to get right.</p>\n\n\n\t<h2>The simple version</h2>\n\n\n\t<p>For the purposes of this article let’s assume that your application needs to provide access to a large zip file, but that access should be restricted to logged in users.</p>\n\n\n\t<p>The first choice we have to make is where to store this file.  In this case there’s really only one wrong answer, and that’s to store it in the public folder of your rails application. Every file stored in public will be served by our webserver without the involvement of our rails application.  This makes it impossible for us to check that the user has logged in.  Unless your files are <strong>completely</strong> public, you shouldn’t go anywhere near the public folder.</p>\n\n\n\t<p>So let’s assume we’ve stored the zip file in:</p>\n\n\n\t<pre><code>/home/railsway/downloads/huge.zip</code></pre>\n\n\n\t<p>Next we need a simple download action to send the file to the user, thankfully rails has this built right in:</p>\n\n\n<pre class=\"sh_ruby\">\n  before_filter :login_required\n  def download\n    send_file '/home/railsway/downloads/huge.zip', :type=&gt;\"application/zip\" \n  end\n</pre>\n\n\t<p>Now when our users click the download link, they’ll be asked to choose a location and then be able to view the file.  The bad news is, there’s a catch here.   The good news is it’s easy to fix.</p>\n\n\n\t<h2>What’s the catch?</h2>\n\n\n\t<p>The problem here is one of scarce resources, and that resource is your rails processes.  Whether you’re using mongrel, fastcgi or passenger you have a limited number of rails processes available to handle application requests.  When one of your users makes a request, you want to know that you either have a process free to handle the request, or that one will become free in short order. If you don’t, users will face an agonizing wait for pages to load, or see their browser sessions timeout entirely.</p>\n\n\n\t<p>When you use the default behaviour of send_file to send the file out to the user,  your rails process will read through the entire file, copying the contents of the file to the output stream as it goes.  For small files like images this probably isn’t that big of a deal, but for something enormous like a 200M zip file, using send_file will tie up a process for a long time. Users on slow connections will soak up a rails process for correspondingly longer.</p>\n\n\n\t<p>If you get a large number of downloads running, you may find all your rails processes taken up by downloaders, with none left to serve any other users.  For all intents and purposes your site is down: you’ve instituted a denial of service attack against yourself.</p>\n\n\n\t<h2>What about threads?</h2>\n\n\n\t<p>Unfortunately threads in ruby won’t save us.  The combination of blocking IO and green threads mean that even though you’re doing the work in a thread, it’s blocking the entire process most of the time anyway.  JRuby users may get a performance improvement, but it’s still going to be a noticeable consumption of resources when compared to letting a web server stream the file.</p>\n\n\n\t<p>Don’t believe everything you read on the internet, threads and ruby just won’t help you with most of this stuff.</p>\n\n\n\t<h2>So What’s the Solution?</h2>\n\n\n\t<p>Thankfully this problem was solved a long time ago by the guys at live journal. They used perl instead of ruby, but had the same problems.  Downloading files would block their application processes for too long, and cause other users to have to wait.  Their solution was elegant and simple.  Instead of making the application processes stream the file to the user, they simply tell the webserver what file to send, and let the web server bother with the details of streaming the file out to the client.</p>\n\n\n\t<p>Their particular solution is quite cumbersome to set up and use, but there’s a very similar solution available called X-Sendfile.  It’s supported out of the box with later versions of lighttpd, and available as a <a href=\"http://tn123.ath.cx/mod_xsendfile/\">module for apache</a>.</p>\n\n\n\t<p>The way it works is instead of sending the file to our users, our rails application will simply check they’re allowed to download it (using our login_required filter) then write the name of the file into a special response header then render an empty response.  Once apache sees that response it will read the file from disk and stream it out to the user.  So your headers will look something like:</p>\n\n\n\t<pre><code>X-Sendfile: /home/railsway/downloads/huge.zip</code></pre>\n\n\n\t<p>The apache module has a slightly annoying default setting that prevents it from sending files outside the public folder, so you’ll need to add the following configuration option:</p>\n\n\n\t<pre><code>XSendFileAllowAbove on</code></pre>\n\n\n\t<p>Thankfully for rails users x-sendfile support is built right in to rails, allowing us to make a few minor changes and we’re done.</p>\n\n\n<pre class=\"sh_ruby\">  \n  before_filter :login_required\n  def download\n    send_file '/home/railsway/downloads/huge.zip', :type=&gt;\"application/zip\", :x_sendfile=&gt;true\n  end\n</pre>\n\n\t<p>With that, we’re done.  Our rails process just make a quick authorization check and render a short response, and apache uses its own optimised file streaming code to send the file down to our users. Meanwhile, the rails process is free to go on to the next request.</p>\n\n\n\t<p>Nginx users can use a similar header called X-AccelRedirect.  This is a little more fiddly to set up, and requires your application to write a special internal <span class=\"caps\">URL</span> to the http response rather than the full path, but in terms of scalability and resource contention, it’s just as great.  There’s an <a href=\"http://blog.kovyrin.net/2006/11/01/nginx-x-accel-redirect-php-rails/\">intro to the nginx module</a> available if you’re an nginx user.  If only uploads were this easy!</p>\n\n\n\t<h2>Up Next</h2>\n\n\n\t<p>The next article in the series will cover my experiences when dealing with the <strong>storage</strong> of your files.  Should you use S3?  What about blobs, <span class=\"caps\">NFS</span>, GFS or MogileFS?</p>\n          ","descriptionType":"html","publishedDate":"Sun, 22 Feb 2009 02:44:00 +0000","feedId":41263,"bgimg":"","linkMd5":"ca28d5598f5aeff09fb37cac85a4e489","bgimgJsdelivr":"","metaImg":"","author":"Koz","publishedOrCreatedDate":1602646623544}],"record":{"createdTime":"2020-10-14 11:37:03","updatedTime":"2020-10-14 11:37:03","feedId":41263,"fetchDate":"Wed, 14 Oct 2020 03:37:03 +0000","fetchMs":2190,"handleMs":180200,"totalMs":182395,"newArticles":0,"totalArticles":15,"status":1,"type":0,"ip":"08cc7d7b1ce844c0994701dd817046a1","hostName":"us-51*","requestId":"c45ab625bf1446b2b633e3c93fa1c9ad_41263","contentType":"text/xml; charset=UTF-8","totalBytes":0,"bgimgsTotal":0,"bgimgsGithubTotal":0,"articlesImgsTotal":0,"articlesImgsGithubTotal":0,"successGithubMap":{},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 03:23:30","updatedTime":"2020-09-07 05:43:13","id":41263,"name":"The Rails Way - Home","url":"http://feeds.feedburner.com/TheRailsWay","subscriber":78,"website":null,"icon":"http://www.therailsway.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"http://www.therailsway.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":0,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1602646441150,"total":0,"statList":[{"spend":2194,"msg":"获取xml内容"},{"spend":180200,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":0,"msg":"正文链接上传到cdn"}]},"extra5":0,"extra6":0,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{},"extra12ImgCdnSuccessResultVector":[],"successGithubMap":{},"failGithubMap":{}}