{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2021-04-05 17:50:13","updatedTime":"2021-04-05 17:50:13","title":"你还在用 Logback？Log4j2 的异步性能已经无敌了，还不快试试","link":"https://segmentfault.com/a/1190000039751787","description":"<p><a href=\"http://logback.qos.ch/\" rel=\"nofollow noreferrer\"><strong>Logback</strong></a> 算是 JAVA 里一个老牌的日志框架，从 06 年开始第一个版本，迭代至今也十几年了。不过 logback 最近一个稳定版本还停留在 2017 年，好几年都没有更新；logback 的兄弟 slf4j 最近一个稳定版也是 2017 年，有点凉凉的意思。</p>\n<p>而且 logback 的异步性能实在拉跨，功能简陋，配置又繁琐，远不及 Apache 的新一代日志框架 - <a href=\"http://logging.apache.org/\" rel=\"nofollow noreferrer\"><strong>Log4j2</strong></a></p>\n<p><strong>目前来看，Log4j2 就是王者，其他日志框架都不是对手</strong></p>\n<h2>Log4j2 简介</h2>\n<p>Apache Log4j 2 是 Log4j(1) 的升级版，比它的祖先 Log4j 1. x 有了很大的改进，和 logback 对比有很大的改进。除了内部设计的调整外，主要有以下几点的大升级：</p>\n<ul>\n <li>更简化的配置</li>\n <li>更强大的参数格式化</li>\n <li>最夸张的异步性能</li>\n</ul>\n<p>Log4j 2 中，分为 <strong>API(log4j-api）</strong>和<strong>实现 (log4j-core)</strong> 两个模块。API 和 slf4j 是一个类型，属于日志抽象 / 门面，而实现部分，才是 Log4j 2 的核心。</p>\n<ul>\n <li>org.apache.logging.log4j » log4j-api</li>\n <li>org.apache.logging.log4j » log4j-core</li>\n</ul>\n<h2>最牛逼的性能</h2>\n<h3>最强的异步性能</h3>\n<p>这个特性，算是 Log4j2 最强之处了。log4j2 在目前 JAVA 中的日志框架里，异步日志的性能是最高的，没有之一。</p>\n<p>先来看一下，几种日志框架 benchmark 对比结果（log4j2 官方测试结果）： <img src=\"https://segmentfault.com/img/remote/1460000039751790\" alt=\"\" title=\"\"> 从图上可以看出，log4j2 的异步（全异步，非混合模式）下的性能，远超 log4j1 和 logback，简直吊打。压力越大的情况下，吞吐上的差距就越大。<strong>在 64 线程测试下，log4j2 的吞吐达到了 180w+/s，而 logback/log4j1 只有不到 20w，相差近十倍</strong></img></p>\n<h3>零 GC（Garbage-free）</h3>\n<p>从 2.6 版本开始（2016 年），log4j2 默认就以零 GC 模式运行了。什么叫零 GC 呢？就是不会由于 log4j2 而导致 GC。</p>\n<p>log4j2 中<strong>各种 Message 对象，字符串数组，字节数组等全部复用</strong>，不重复创建，大大减少了无用对象的创建，从而做到 “零 GC”。</p>\n<h3>更高性能 I/O 写入的支持</h3>\n<p>log4j 还提供了一个 MemoryMappedFileAppender，I/O 部分使用 MemoryMappedFile 来实现，可以得到极高的 I/O 性能。<strong>不过在使用 MemoryMappedFileAppender 之前，得确定你足够了解 MemoryMappedFile 的相关知识，否则不要轻易使用呦。</strong></p>\n<h2>更强大的参数格式化</h2>\n<p>API 模块和 slf4j 相比，提供了更丰富的参数格式化功能。</p>\n<h3>使用<code>{}</code>占位符格式化参数</h3>\n<p>在 slf4j 里，我们可以用<code>{}</code>的方式来实现 “format” 的功能（参数会直接 toString 替换占位符），像下面这样：</p>\n<pre><code>logger.debug(\"Logging in user {} with birthday {}\", user.getName(), user.getBirthdayCalendar());</code></pre>\n<h3>使用 String.format 的形式格式化参数</h3>\n<p>log4j2 中除了支持<code>{}</code>的参数占位符，还支持 String.format 的形式：</p>\n<pre><code>public static Logger logger = LogManager.getFormatterLogger(\"Foo\");\n \nlogger.debug(\"Logging in user %s with birthday %s\", user.getName(), user.getBirthdayCalendar());\nlogger.debug(\"Logging in user %1$s with birthday %2$tm %2$te,%2$tY\", user.getName(), user.getBirthdayCalendar());\nlogger.debug(\"Integer.MAX_VALUE = %,d\", Integer.MAX_VALUE);\nlogger.debug(\"Long.MAX_VALUE = %,d\", Long.MAX_VALUE);</code></pre>\n<p><strong> 注意，如果想使用 String.format 的形式，需要使用<code>LogManager.getFormatterLogger</code>而不是<code>LogManager.getLogger</code></strong></p>\n<h3>使用 logger.printf 格式化参数</h3>\n<p>log4j2 的 Logger 接口中，还有一个<code>printf</code>方法，无需创建<code>LogManager.getFormatterLogger</code>，就可以使用<code>String.format</code>的形式</p>\n<pre><code>logger.printf(Level.INFO, \"Logging in user %1$s with birthday %2$tm %2$te,%2$tY\", user.getName(), user.getBirthdayCalendar());\n\nlogger.debug(\"Opening connection to {}...\", someDataSource);</code></pre>\n<h3>“惰性” 打日志（lazy logging）</h3>\n<p>这个功能虽然小，但非常实用。</p>\n<p>在某些业务流程里，为了留根或追溯问题，需要完整的打印入参，一般是把入参给用 JSON/XML 序列化后用 <strong>debug</strong> 级别打印：</p>\n<pre><code>logger.debug(\"入参报文：{}\",JSON.toJSONString(policyDTO));</code></pre>\n<p>如果需要追溯问题时，会将系统的日志级别调到 debug/trace，这样就可以打印。但是这里有个问题，<strong>虽然在 info 级别下 debug 不会输出内容，但 JSON.toJSONString() 这个序列化的代码一定会执行，严重影响正常流程下的执行效率。</strong></p>\n<p>我们期望的结果是 info 级别下，连序列化都不执行。这里可以通过<code>isDebugEnable</code>来判断当前配置下 debug 级别是否可以输出：</p>\n<pre><code>if(logger.isDebugEnabled()){\n    logger.debug(\"入参报文：{}\",JSON.toJSONString(policyDTO));\n}</code></pre>\n<p>这样虽然可以避免不必要的序列化，但每个地方都这么写还是有点难受的，一行变成了三行。</p>\n<p>log4j2 的 logger 对象，提供了一系列 lambda 的支持，通过这些接口可以实现 “惰性” 打日志：</p>\n<pre><code>void debug(String message, Supplier&lt;?&gt;... paramSuppliers);\nvoid info(String message, Supplier&lt;?&gt;... paramSuppliers);\nvoid trace(String message, Supplier&lt;?&gt;... paramSuppliers);\nvoid error(String message, Supplier&lt;?&gt;... paramSuppliers);\n\n\nlogger.debug(\"入参报文：{}\",() -&gt; JSON.toJSONString(policyDTO));\n\nif(logger.isDebugEnabled()){\n    logger.debug(\"入参报文：{}\",JSON.toJSONString(policyDTO));\n}</code></pre>\n<p>这种 Supplier + Lambda 的形式，等同于上面的先判断 isDebugEnable 然后打印，三行的代码变成了一行。嗯，真香。</p>\n<h2>更简化的配置</h2>\n<p>Log4j 2 同时支持 XML/JSON/YML/Properties 四种形式的配置文件，不过最主流的还是 XML 的方式，最直观。</p>\n<p>来看一下 logback 和 log4j2 的配置文件对比，同样功能的配置下：</p>\n<h3>logback.xml</h3>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;appender name = \"File\" class= \"ch.qos.logback.core.rolling.RollingFileAppender\"&gt;\n        &lt;file&gt;logs/app.log&lt;/file&gt;\n        &lt;rollingPolicy&gt;\n            &lt;fileNamePattern&gt;logs/archives/app-%d{yyyy-MM-dd}.log.gz&lt;/fileNamePattern&gt;\n                        \n              &lt;maxFileSize&gt;1 GB&lt;/maxFileSize&gt;\n        &lt;/rollingPolicy&gt;\n    &lt;/appender&gt;\n    &lt;root level=\"info\"&gt;\n      &lt;appender-ref ref=\"File\"/&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;</code></pre>\n<h3>log4j2.xml</h3>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Configuration xmlns:xi=\"http://www.w3.org/2001/XInclude\"\n               status=\"warn\" &gt;\n    &lt;Appenders&gt;\n          &lt;RollingFile logs/archives/app-%d{yyyy-MM-dd}-%i.log.gz\"&gt;\n              &lt;PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] [%e] [%X{rid}] %level %c - %msg%n\"/&gt;\n              &lt;Policies&gt;\n                  &lt;TimeBasedTriggeringPolicy /&gt;\n                  \n                  &lt;SizeBasedTriggeringPolicy size=\"1 GB\"/&gt;\n              &lt;/Policies&gt;\n          &lt;/RollingFile&gt;\n    &lt;/Appenders&gt;\n    &lt;Loggers&gt;\n        &lt;Root level=\"INFO\"&gt;\n            &lt;AppenderRef ref=\"File\"/&gt;\n        &lt;/Root&gt;\n    &lt;/Loggers&gt;\n&lt;/Configuration&gt;</code></pre>\n<p>在 log4j2 中，appender 的配置从使用 Appender 实现名即标签名的形式，语法上更简洁一些：</p>\n<pre><code>&lt;RollingFile &gt;\n  \n&lt;appender name = \"File\" class= \"ch.qos.logback.core.rolling.RollingFileAppender\"&gt;\n复制代码\n</code></pre>\n<h2>与其他日志抽象 / 门面适配</h2>\n<p>log4j2 由于拆分为 API 和 实现两部分，所以可能也需要和其他日志框架进行适配，详细的日志框架适配方案请参考我的另一篇文章《<a href=\"https://juejin.cn/post/6945220055399399455\" rel=\"nofollow noreferrer\">【可能是全网最全的】JAVA 日志框架适配 / 冲突解决方案</a>》 <img src=\"https://segmentfault.com/img/remote/1460000039751789\" alt=\"\" title=\"\" /></p>\n<h2>其他的特点</h2>\n<ol>\n <li>异步队列使用高性能队列 - <strong>LMAX Disruptor&nbsp;</strong></li>\n <li><a href=\"https://logging.apache.org/log4j/2.x/manual/appenders.html\" rel=\"nofollow noreferrer\">Appender 丰富，有 <strong>JMS/JPA/KAFKA/Http/MONGODB/CouchDB/Socket/Script</strong> 等各种 Appender 的支持</a></li>\n <li><a href=\"https://logging.apache.org/log4j/2.x/manual/customloglevels.html\" rel=\"nofollow noreferrer\">支持自定义日志级别</a></li>\n <li>……</li>\n</ol>\n<h2>基本用法</h2>\n<p>终于介绍完了 Log4j2 的强大，现在来介绍下 Log4j2 的基本使用。</p>\n<h3>引用 log4j2 的 maven 依赖</h3>\n<p>log4j-api 在 log4j-core 中已经有依赖了，直接依赖 core 即可</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n    &lt;version&gt;2.14.1&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>注意，引用 log4j2 时，需要注意项目中是否有多套日志框架共存 / 冲突，需要适配的问题。细节请参考上面的<strong>与其他日志抽象 / 门面适配</strong></p>\n<h3>配置文件示例</h3>\n<p>首先是配置文件，默认的配置文件路径为：<code>classpath:log4j2.xml</code>（推荐使用 xml）</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Configuration xmlns:xi=\"http://www.w3.org/2001/XInclude\"\n               status=\"warn\" name=\"XInclude\"&gt;\n    &lt;Properties&gt;\n      &lt;Property name=\"PATTERN\" value=\"%d{yyyy-MM-dd HH:mm:ss.SSS} %5p [%t] %-40.40c{1.} : %m%n\"/&gt;\n    &lt;/Properties&gt;\n    &lt;Appenders&gt;\n              &lt;!-- 输出到控制台，仅在本地开发环境使用 --&gt;\n          &lt;Console name=\"Console\" target=\"SYSTEM_OUT\"&gt;\n            &lt;PatternLayout pattern=\"${PATTERN}\"/&gt;\n          &lt;/Console&gt;\n              &lt;!--输出到日志文件，滚动分割日志文件，自动打包gz--&gt;\n          &lt;RollingFile name=\"File\" fileName=\"logs/app.log\" filePattern=\"logs/archives/app-%d{yyyy-MM-dd}-%i.log.gz\"&gt;\n              &lt;PatternLayout pattern=\"${PATTERN}\"/&gt;\n              &lt;Policies&gt;\n                    &lt;!--默认一天一个文件--&gt;\n                  &lt;TimeBasedTriggeringPolicy /&gt;\n                  &lt;!--一天内大于size就单独分隔--&gt;\n                  &lt;SizeBasedTriggeringPolicy size=\"1 GB\"/&gt;\n              &lt;/Policies&gt;\n          &lt;/RollingFile&gt;\n    &lt;/Appenders&gt;\n    &lt;Loggers&gt;\n          &lt;!-- 添加你的自定义logger，一般用于区分包名的日志，不同包名不同的级别/appender --&gt;\n          &lt;!-- additivity 意思是，调用完当前appender，是否继续调用parent logger appender，默认true--&gt;\n          &lt;Logger name=\"your logger/package name\" level=\"debug\" additivity=\"false\"/&gt;\n          &lt;!--默认的Root Logger 级别--&gt;\n        &lt;Root level=\"INFO\"&gt;\n              &lt;!--这里需要区分下环境（配合maven profile之类的）--&gt;\n              &lt;!-- 开发环境使用Console Appender，生产环境使用File Appender --&gt;\n            &lt;AppenderRef ref=\"Console\"/&gt;\n              &lt;AppenderRef ref=\"File\"/&gt;\n        &lt;/Root&gt;\n    &lt;/Loggers&gt;\n&lt;/Configuration&gt;</code></pre>\n<h3>XML 配置文件语法</h3>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;;\n&lt;Configuration&gt;\n  &lt;Properties&gt;\n    &lt;Property &gt;value&lt;/property&gt;\n    &lt;Property /&gt;\n  &lt;/Properties&gt;\n  &lt;filter  ... /&gt;\n  &lt;Appenders&gt;\n    &lt;appender ... &gt;\n      &lt;filter  ... /&gt;\n    &lt;/appender&gt;\n    ...\n  &lt;/Appenders&gt;\n  &lt;Loggers&gt;\n    &lt;Logger &gt;\n      &lt;filter  ... /&gt;\n    &lt;/Logger&gt;\n    ...\n    &lt;Root level=\"level\"&gt;\n      &lt;AppenderRef ref=\"name\"/&gt;\n    &lt;/Root&gt;\n  &lt;/Loggers&gt;\n&lt;/Configuration&gt;</code></pre>\n<h3>创建 Logger</h3>\n<p>直接使用 log4j2 的 api：</p>\n<pre><code>import org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nLogger logger = LogManager.getLogger(Log4j2Test.class);\nlogger.error(...);\nlogger.warn(...);\nlogger.info(...);\nlogger.debug(...);\nlogger.trace(...);</code></pre>\n<p>如果是配合 slf4j 使用也是可以的，只需要按照前面说的，提前做好适配，然后使用 slf4j 的 api 即可。不过如果是新系统的话，建议直接上 log4j2 的 api 吧，可以享受所有 log4j2 的功能，使用 slf4j 之类的 api 时，上面说的参数格式化之类的功能就无法使用了。</p>\n<h3>全异步配置（重要！！）</h3>\n<p>推荐配置 <strong>log4j2</strong> <strong>全异步（all async），在你的启动脚本中增加一个系统变量的配置：</strong></p>\n<pre><code>-Dlog4j2.contextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</code></pre>\n<h2>总结</h2>\n<p>Log4j2 如今性能最强，功能最强，而且持续更新维护。还在等什么？是时候替换你的 logback/log4j1 了！</p>\n<blockquote>\n 原创不易，转载请在开头著名文章来源和作者。如果我的文章对您有帮助，请点赞 / 收藏 / 关注鼓励支持一下吧❤❤❤❤❤❤\n</blockquote>","descriptionType":"html","publishedDate":"Thu, 01 Apr 2021 00:50:00 +0000","feedId":6615,"bgimg":"https://segmentfault.com/img/remote/1460000039751790","linkMd5":"7331e55ea05e366060f78f1e988ab882","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn81@2020_4/2021/04/05/09-50-19-270_cb2a0b37bcc047a6.webp","destWidth":732,"destHeight":385,"sourceBytes":35990,"destBytes":35990,"author":"空无","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000039751790":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn81@2020_4/2021/04/05/09-50-19-270_cb2a0b37bcc047a6.webp","https://segmentfault.com/img/remote/1460000039751789":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn85@2020_6/2021/04/05/09-50-22-927_822a9e2699849442.webp"},"publishedOrCreatedDate":1617616213508}],"record":{"createdTime":"2021-04-05 17:50:13","updatedTime":"2021-04-05 17:50:13","feedId":6615,"fetchDate":"Mon, 05 Apr 2021 09:50:13 +0000","fetchMs":3793,"handleMs":64,"totalMs":25559,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"8f2970d485f5ded6455f244eb3f7d3cd","hostName":"europe66*","requestId":"b4c659aa88794b639f3471fcb50a8d56_6615","contentType":"application/atom+xml; charset=UTF-8","totalBytes":95798,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":2,"articlesImgsGithubTotal":2,"successGithubMap":{"myreaderx6":1,"myreaderx18":1},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:33:08","updatedTime":"2021-04-03 14:32:14","id":6615,"name":"SegmentFault 最新的文章","url":"http://segmentfault.com/feeds/blogs","subscriber":null,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx63/cdn75@2020_2/2021/04/03/06-32-08-760_eb238dca7c8e9f0e.jpg","description":"","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":35990,"tmpBodyImgCdnBytes":59808,"tmpBgImgCdnBytes":0,"extra4":{"start":1617616197651,"total":0,"statList":[{"spend":15793,"msg":"获取xml内容"},{"spend":64,"msg":"解释文章"},{"spend":1,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":3601,"msg":"正文链接上传到cdn"}]},"extra5":2,"extra6":2,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-007.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039751790","sourceStatusCode":200,"destWidth":732,"destHeight":385,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn81@2020_4/2021/04/05/09-50-19-270_cb2a0b37bcc047a6.webp","sourceBytes":35990,"destBytes":35990,"feedId":6615,"totalSpendMs":3546,"convertSpendMs":0,"createdTime":"2021-04-05 17:50:16","host":"us-019*","referer":"https://segmentfault.com/a/1190000039751787","linkMd5ListStr":"7331e55ea05e366060f78f1e988ab882,7331e55ea05e366060f78f1e988ab882","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"35.1 KB","destSize":"35.1 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000039751789","sourceStatusCode":200,"destWidth":732,"destHeight":470,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn85@2020_6/2021/04/05/09-50-22-927_822a9e2699849442.webp","sourceBytes":59808,"destBytes":59808,"feedId":6615,"totalSpendMs":3424,"convertSpendMs":0,"createdTime":"2021-04-05 17:50:19","host":"us-007*","referer":"https://segmentfault.com/a/1190000039751787","linkMd5ListStr":"7331e55ea05e366060f78f1e988ab882","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"58.4 KB","destSize":"58.4 KB","compressRate":"100%"}],"successGithubMap":{"myreaderx6":1,"myreaderx18":1},"failGithubMap":{}}