{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-11-18 16:17:16","updatedTime":"2020-11-18 16:17:16","title":"Golang协程并发的流水线模型","link":"https://segmentfault.com/a/1190000038212342","description":"<h2>背景</h2>\n<p>最近由于性能问题，后端服务一直在做python到golang的迁移和重构。go语言精简优雅，既有编译型语言的严谨和高性能，又有解释型语言的开发效率，出色的并发性能也是go区别于其他语言的一大特色。go的并发编程代码虽然简单，但重在其并发模型和流程的设计。所以这里总结下golang协程并发常用的流水线模型。</p>\n<h2>简单的流水线思维</h2>\n<p>流水线模式并不是什么新奇的概念，但是它能极大地提高生产效率。比如实际生活中的汽车生产流水线，流水线上的每一个流程负责不同的工作，比如第一个流程是拼装车身，第二个流程是安装发动机，第三个流程是装轮胎...，这些步骤我们可以类比成go并发流程中的协程，每一个协程就是一个任务。流水线上面传递的车身、发动机、轮胎，这些我们可以类比成协程间需要传递的数据，而在这些流程（协程）间传递这些配件（数据），自然就要通过传送带（channel）。在流水线上，我们装四个轮胎肯定不是一个一个来装的，肯定是有四个机械臂同时来装。因此装轮胎这个步骤我们有4个协程在并发工作来提高效率。这么一来，流水线模型的基本要素就构成了。<br> Golang的并发模型灵感其实都来自我们生活，对程序而言，高的生产效率就是高的性能。<strong>在Golang中，流水线由多个流程节点组成，流程之间通过channel连接，每个流程节点可以由多个同时运行的goroutine组成。</strong><br> <img src=\"https://segmentfault.com/img/bVcKuEG\" alt=\"image.png\" title=\"image.png\" /></br></br></p>\n<h2>如何构造流水线</h2>\n<p>有了流水线模式的思维，接下来就是如何构造流水线了。简单来说，其实就是通过channel将任务流程连接起来，两个相邻的流程互为生产者和消费者，通过channel进行通信。耗时的流程可以将任务分散到多个协程来执行。<br> 我们先来看一个最简单的流水线，如下图，A是生产者流程，B是它的消费流程，同时又是C的生产者流程。A，B，C三个协程直接，通过读写channel进行通信。<br> <img src=\"https://segmentfault.com/img/bVcKuIQ\" alt=\"image.png\" title=\"image.png\" /></br></br></p>\n<p>那如果此时B流程可以将a channel中的任务并发执行呢，很简单，我们只需要起多个B协程就可以了。如下图。<br> <img src=\"https://segmentfault.com/img/bVcKuJA\" alt=\"image.png\" title=\"image.png\" /></br></p>\n<p><strong>总之，我们构造流水线并发的思路是关注数据的流动，数据流动的过程交给channel，channel两端数据处理的每个环节都交给goroutine，这个流程连起来，就构成了流水线模型。</strong></p>\n<h2>关于channel</h2>\n<p>为什么我们可以选择channel来进行协程间的通信呢，协程之间又是怎么保持同步顺序呢，当然这都要归功于channel。channel是go提供的进程内协程间的通信方式，它是协程/线程安全的，channe的读写阻塞会导致协程的切换。<br> channel的操作和状态组合可以有以下几种情况：<br> <img src=\"https://segmentfault.com/img/bVcKuLU\" alt=\"image.png\" title=\"image.png\" /></br></br></p>\n<pre><code>**有1个特殊场景**：当`nil`的通道在`select`的某个`case`中时，这个case会阻塞，但不会造成死锁。\n</code></pre>\n<p>channel不仅可以保证协程安全的数据流动，还可以保证协程的同步。当有并发问题时，channel也是我们首先应该想到的数据结构。不过，当使用有缓冲区的channel时，才能达到协程并发的效果，并且生产者和消费者的协程间是相对同步的。使用无缓冲区的channel时，是没有并发效果的，协程间是绝对同步的，生产者和消费者必须同时写和读协程才能运行。<br> channel关注的是数据的流动，这种场景下都可以考虑使用channel。比如：消息传递、信号广播、任务分发、结果汇总、同步与异步、并发控制... 更多的不在这里赘述了，总之，<strong>Share memory by communicating, don't communicate by sharing memory.</strong></br></p>\n<h2>流水线模型实例</h2>\n<p>举个简单栗子，计算80000以内的质数并输出。<br> 这个例子如果我们采用非并发的方式，就是for循环80000，挨个判断是不是素数再输出。不过如果我们采用流水线的并发模型会更高效。<br> 从数据流动的角度来分析，需要遍历生成1-80000的数字到一个channel中，数字判断是否为素数，输出结果到一个channel中。因此我们需要两个channel，channel的两端就设计成协程即可。<br> 1、遍历生成原始80000个数据（生产者）<br> 2、计算这80000个数据中的素数（生产者+消费者）<br> 3、取结果输出（消费者）</br></br></br></br></br></p>\n<pre><code class=\"go\">package gen_channel\nimport \"fmt\"\nimport \"time\"\nfunc generate_source(data_source_chan chan int) {\n   for i := 1; i &lt;= 80000; i++ {\n      data_source_chan &lt;- i\n   }\n   fmt.Println(\"写入协程结束\")\n   close(data_source_chan)\n}\nfunc generate_sushu(data_source_chan chan int, data_result_chan chan int, gen_chan chan bool) {\n   for num:= range data_source_chan {\n      falg := true\n for i := 2; i &lt; num; i++ {\n         if num%i == 0 {\n            falg = false\n break }\n      }\n      if falg == true {\n         data_result_chan &lt;- num\n      }\n   }\n   fmt.Println(\"该协程结束\")\n   gen_chan &lt;- true\n}\nfunc workpool(data_source_chan chan int, data_result_chan chan int, gen_chan chan bool, gen_num int){\n   // 开启8个协程\n for i := 0; i &lt; gen_num; i++ {\n      go generate_sushu(data_source_chan, data_result_chan, gen_chan)\n   }\n}\nfunc Channel_main() {\n   data_source_chan := make(chan int, 2000)\n   data_result_chan := make(chan int, 2000)\n   gen_chan := make(chan bool, 8)\n   time1 := time.Now().Unix()\n   go generate_source(data_source_chan)\n   // 协程池,任务分发\n   workpool(data_source_chan, data_result_chan, gen_chan, 8)\n   go func() {\n      for i := 0; i &lt; 8; i++ {\n         &lt;-gen_chan\n      }\n      close(data_result_chan)\n      fmt.Println(\"spend timeis \", time.Now().Unix()-time1)\n   }()\n   for date_result := range data_result_chan {\n      fmt.Println(date_result)\n   }\n}</code></pre>","descriptionType":"html","publishedDate":"Wed, 18 Nov 2020 07:31:36 +0000","feedId":23280,"bgimg":"https://segmentfault.com/img/bVcKuEG","linkMd5":"b463ada8647821d37e813a6e7b110778","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn84@2020_4/2020/11/18/08-17-25-338_6805778bd1a3aaf6.webp","destWidth":800,"destHeight":515,"sourceBytes":117650,"destBytes":117650,"author":"屈天航","articleImgCdnMap":{"https://segmentfault.com/img/bVcKuEG":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn84@2020_4/2020/11/18/08-17-25-338_6805778bd1a3aaf6.webp","https://segmentfault.com/img/bVcKuIQ":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn91@2020_6/2020/11/18/08-17-29-442_89e6d9ef1c1a955a.webp","https://segmentfault.com/img/bVcKuJA":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn96@2020_5/2020/11/18/08-17-32-013_cb624c86beaa138f.webp","https://segmentfault.com/img/bVcKuLU":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn88@2020_1/2020/11/18/08-17-30-213_e9c138b6871f50d2.webp"},"publishedOrCreatedDate":1605687436612}],"record":{"createdTime":"2020-11-18 16:17:16","updatedTime":"2020-11-18 16:17:16","feedId":23280,"fetchDate":"Wed, 18 Nov 2020 08:17:16 +0000","fetchMs":5604,"handleMs":11745,"totalMs":34806,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"7be5a6429a423a68cef7abf798e66509","hostName":"us-022*","requestId":"febea5e6ee994b7db22f3fbc36a272fa_23280","contentType":"application/atom+xml; charset=UTF-8","totalBytes":172498,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":4,"articlesImgsGithubTotal":4,"successGithubMap":{"myreaderx6":1,"myreaderx27":1,"myreaderx12":1,"myreaderx13":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:29:58","updatedTime":"2020-11-12 13:51:25","id":23280,"name":"SegmentFault 最新的文章","url":"https://segmentfault.com/feeds/blogs","subscriber":142,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":null,"description":"","weekly":null,"link":"https://segmentfault.com"},"noPictureArticleList":[],"tmpCommonImgCdnBytes":117650,"tmpBodyImgCdnBytes":54848,"tmpBgImgCdnBytes":0,"extra4":{"start":1605687418332,"total":0,"statList":[{"spend":6538,"msg":"获取xml内容"},{"spend":11746,"msg":"解释文章"},{"spend":2,"msg":"上传封面图到cdn"},{"spend":6,"msg":"修正封面图上传失败重新上传"},{"spend":6659,"msg":"正文链接上传到cdn"}]},"extra5":4,"extra6":4,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://europe-25.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://europe63.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-51.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcKuEG","sourceStatusCode":200,"destWidth":800,"destHeight":515,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn84@2020_4/2020/11/18/08-17-25-338_6805778bd1a3aaf6.webp","sourceBytes":117650,"destBytes":117650,"feedId":23280,"totalSpendMs":6548,"convertSpendMs":0,"createdTime":"2020-11-18 16:17:19","host":"us-012*","referer":"https://segmentfault.com/a/1190000038212342","linkMd5ListStr":"b463ada8647821d37e813a6e7b110778,b463ada8647821d37e813a6e7b110778","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"114.9 KB","destSize":"114.9 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcKuIQ","sourceStatusCode":200,"destWidth":800,"destHeight":127,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn91@2020_6/2020/11/18/08-17-29-442_89e6d9ef1c1a955a.webp","sourceBytes":6236,"destBytes":6236,"feedId":23280,"totalSpendMs":3709,"convertSpendMs":0,"createdTime":"2020-11-18 16:17:26","host":"europe63*","referer":"https://segmentfault.com/a/1190000038212342","linkMd5ListStr":"b463ada8647821d37e813a6e7b110778","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"6.1 KB","destSize":"6.1 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcKuLU","sourceStatusCode":200,"destWidth":800,"destHeight":197,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn88@2020_1/2020/11/18/08-17-30-213_e9c138b6871f50d2.webp","sourceBytes":18760,"destBytes":18760,"feedId":23280,"totalSpendMs":4885,"convertSpendMs":0,"createdTime":"2020-11-18 16:17:26","host":"europe-25*","referer":"https://segmentfault.com/a/1190000038212342","linkMd5ListStr":"b463ada8647821d37e813a6e7b110778","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"18.3 KB","destSize":"18.3 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/bVcKuJA","sourceStatusCode":200,"destWidth":800,"destHeight":427,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn96@2020_5/2020/11/18/08-17-32-013_cb624c86beaa138f.webp","sourceBytes":29852,"destBytes":29852,"feedId":23280,"totalSpendMs":6622,"convertSpendMs":0,"createdTime":"2020-11-18 16:17:26","host":"us-51*","referer":"https://segmentfault.com/a/1190000038212342","linkMd5ListStr":"b463ada8647821d37e813a6e7b110778","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"29.2 KB","destSize":"29.2 KB","compressRate":"100%"}],"successGithubMap":{"myreaderx6":1,"myreaderx27":1,"myreaderx12":1,"myreaderx13":1},"failGithubMap":{}}