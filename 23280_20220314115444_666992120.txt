{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2022-03-14 19:54:34","updatedTime":"2022-03-14 19:54:34","title":"什么是 LRU 算法？","link":"https://segmentfault.com/a/1190000041542627","description":"<p><code>缓存</code> 是我们写代码过程中常用的一种手段，是一种空间换时间的做法。就拿我们经常使用的 HTTP 协议，其中也存在强缓存和协商缓存两种缓存方式。当我们打开一个网站的时候，浏览器会查询该请求的响应头，通过判断响应头中是否有 <code>Cache-Control</code>、<code>Last-Modified</code>、<code>ETag</code> 等字段，来确定是否直接使用之前下载的资源缓存，而不是重新从服务器进行下载。</p>\n<p>下面就是当我们访问百度时，某些资源命中了协商缓存，服务端返回 <code>304</code> 状态码，还有一部分资源命中了强缓存，直接读取了本地缓存。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000041542629\" alt=\"\" title=\"\" /></p>\n<p>但是，缓存并不是无限制的，会有大小的限制。无论是我们的 <code>cookie</code>（不同浏览器有所区别，一般在 <code>4KB</code> 左右），还是 <code>localStorage</code>（和 <code>cookie</code> 一样，不同浏览器有所区别，有些浏览器为 <code>5MB</code>，有些浏览器为 <code>10MB</code>），都会有大小限制。</p>\n<p>这个时候就需要涉及到一种算法，需要将超出大小限制的缓存进行淘汰，一般的规则是淘汰掉最近没有被访问到的缓存，也就是今天要介绍的主角：<strong>LRU</strong> （<code>Least recently used</code>：最近最少使用）。当然除了 LRU，常见的缓存淘汰还有 FIFO（<code>first-in, first-out</code>：先进先出） 和 LFU（<code>Least frequently used</code>：最少使用）。</p>\n<h2>什么是 LRU？</h2>\n<p><strong>LRU</strong> （<code>Least recently used</code>：最近最少使用）算法在缓存写满的时候，会根据所有数据的访问记录，淘汰掉未来被访问几率最低的数据。也就是说该算法认为，最近被访问过的数据，在将来被访问的几率最大。</p>\n<p>为了方便理解 LRU 算法的全流程，画了一个简单的图：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000041542630\" alt=\"\" title=\"\" /></p>\n<ol>\n <li>假设我们有一块内存，一共能够存储 5 数据块；</li>\n <li>依次向内存存入A、B、C、D、E，此时内存已经存满；</li>\n <li>再次插入新的数据时，会将在内存存放时间最久的数据A淘汰掉；</li>\n <li>当我们在外部再次读取数据B时，已经处于末尾的B会被标记为活跃状态，提到头部，数据C就变成了存放时间最久的数据；</li>\n <li>再次插入新的数据G，存放时间最久的数据C就会被淘汰掉；</li>\n</ol>\n<h2>算法实现</h2>\n<p>下面通过一段简单的代码来实现这个逻辑。</p>\n<pre><code class=\"js\">class LRUCache {\n    list = [] // 用于标记先后顺序\n    cache = {} // 用于缓存所有数据\n    capacity = 0 // 缓存的最大容量\n    constructor (capacity) {\n    // 存储 LRU 可缓存的最大容量\n        this.capacity = capacity\n    }\n}</code></pre>\n<p>基本的结构如上所示，LRU需要实现的就是两个方法：<code>get</code> 和 <code>put</code>。</p>\n<pre><code class=\"js\">class LRUCache {\n  // 获取数据\n    get (key) { }\n  // 存储数据\n    put (key, value) { }\n}</code></pre>\n<p>我们现在看看如何进行数据的存储：</p>\n<pre><code class=\"js\">class LRUCache {\n  // 存储数据\n    put (key, value) {\n    // 存储之前需要先判断长度是否达到上限\n    if (this.list.length &gt;= this.capacity) {\n      // 由于每次存储后，都会将 key 放入 list 最后，\n      // 所以，需要取出第一个 key，并删除cache中的数据。\n            const latest = this.list.shift()\n            delete this.cache[latest]\n        }\n    // 写入缓存\n        this.cache[key] = value\n    // 写入缓存后，需要将 key 放入 list 的最后\n        this.list.push(key)\n  }\n}</code></pre>\n<p>然后，在每次获取数据时，都需要更新 <code>list</code>，将当前获取的 <code>key</code> 放到 <code>list</code> 的最后。</p>\n<pre><code class=\"js\">class LRUCache {\n  // 获取数据\n    get (key) {\n        if (this.cache[key] !== undefined) {\n        // 如果 key 对应的缓存存在\n      // 在返回缓存之前，需要重新激活 key\n            this.active(key)\n            return this.cache[key]\n        }\n        return undefined\n  }\n  // 重新激活key，将指定 key 移动到 list 最后\n    active (key) {\n    // 先将 key 在 list 中删除\n        const idx = this.list.indexOf(key)\n        if (idx !== -1) {\n            this.list.splice(idx, 1)\n    }\n    // 然后将 key 放到 list 最后面\n        this.list.push(key)\n    }\n}</code></pre>\n<p>这个时候，其实还没有完全实现，因为除了 <code>get</code> 操作，<code>put</code> 操作也需要将对应的 <code>key</code> 重新激活。</p>\n<pre><code class=\"js\">class LRUCache {\n  // 存储数据\n    put (key, value) {\n        if (this.cache[key]) {\n            // 如果该 key 之前存在，将 key 重新激活\n            this.active(key)\n            this.cache[key] = value\n      // 而且此时缓存的长度不会发生变化\n      // 所以不需要进行后续的长度判断，可以直接返回\n            return\n        }\n\n    // 存储之前需要先判断长度是否达到上限\n    if (this.list.length &gt;= this.capacity) {\n      // 由于每次存储后，都会将 key 放入 list 最后，\n      // 所以，需要取出第一个 key，并删除cache中的数据。\n            const latest = this.list.shift()\n            delete this.cache[latest]\n        }\n    // 写入缓存\n        this.cache[key] = value\n    // 写入缓存后，需要将 key 放入 list 的最后\n        this.list.push(key)\n  }\n}</code></pre>\n<hr>\n <p>可能会有人觉得这种算法在前端没有什么应用场景，说起来，在 Vue 的内置组件 <a href=\"https://github.com/vuejs/core/blob/main/packages/runtime-core/src/components/KeepAlive.ts#L302\" rel=\"nofollow noreferrer\"><code>keep-alive</code></a> 中就使用到了 <code>LRU</code> 算法。</p>\n <p><img src=\"https://segmentfault.com/img/remote/1460000041542631\" alt=\"\" title=\"\" /></p>\n <p>后续应该还会继续介绍一下 <code>LFU</code> 算法，敬请期待……</p>\n</hr>","descriptionType":"html","publishedDate":"Mon, 14 Mar 2022 01:02:39 +0000","feedId":23280,"bgimg":"https://segmentfault.com/img/remote/1460000041542629","linkMd5":"bb59cf91cecda234f5c9e5cb4bb9f505","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn59@2020_2/2022/03/14/11-54-40-491_7410383ad609b4c0.webp","destWidth":732,"destHeight":241,"sourceBytes":31160,"destBytes":31160,"author":"Shenfq","articleImgCdnMap":{"https://segmentfault.com/img/remote/1460000041542629":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn59@2020_2/2022/03/14/11-54-40-491_7410383ad609b4c0.webp","https://segmentfault.com/img/remote/1460000041542630":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn64@2020_6/2022/03/14/11-54-43-391_f334ccc6e44febf9.webp","https://segmentfault.com/img/remote/1460000041542631":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn66@2020_6/2022/03/14/11-54-43-741_6a43563960304412.webp"},"publishedOrCreatedDate":1647258874456}],"record":{"createdTime":"2022-03-14 19:54:34","updatedTime":"2022-03-14 19:54:34","feedId":23280,"fetchDate":"Mon, 14 Mar 2022 11:54:34 +0000","fetchMs":3002,"handleMs":388,"totalMs":30978,"newArticles":0,"totalArticles":50,"status":1,"type":0,"ip":"af0629e1ae74a27744b4cbd27b40a78e","hostName":"us-024*","requestId":"9d9888a8bf68496d8801e7c67451a88e_23280","contentType":"application/atom+xml; charset=UTF-8","totalBytes":118606,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":3,"articlesImgsGithubTotal":3,"successGithubMap":{"myreaderx15":1,"myreaderx22":1,"myreaderx12":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 02:29:58","updatedTime":"2021-04-03 13:59:11","id":23280,"name":"SegmentFault 最新的文章","url":"https://segmentfault.com/feeds/blogs","subscriber":142,"website":null,"icon":"https://segmentfault.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx62/cdn43@2020_1/2021/04/03/05-58-55-048_eb238dca7c8e9f0e.jpg","description":"","weekly":null,"link":null},"noPictureArticleList":[],"tmpCommonImgCdnBytes":31160,"tmpBodyImgCdnBytes":87446,"tmpBgImgCdnBytes":0,"extra4":{"start":1647258853013,"total":0,"statList":[{"spend":21055,"msg":"获取xml内容"},{"spend":388,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":3060,"msg":"正文链接上传到cdn"}]},"extra5":3,"extra6":3,"extra7ImgCdnFailResultVector":[],"extra10_invalidATagHrefValue":{},"extra111_proxyServerAndStatMap":{"http://us-031.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]},"http://us-030.herokuapp.com/":{"failCount":0,"successCount":1,"resultList":[200]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000041542629","sourceStatusCode":200,"destWidth":732,"destHeight":241,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn59@2020_2/2022/03/14/11-54-40-491_7410383ad609b4c0.webp","sourceBytes":31160,"destBytes":31160,"feedId":23280,"totalSpendMs":3057,"convertSpendMs":0,"createdTime":"2022-03-14 19:54:37","host":"europe65*","referer":"https://segmentfault.com/a/1190000041542627","linkMd5ListStr":"bb59cf91cecda234f5c9e5cb4bb9f505,bb59cf91cecda234f5c9e5cb4bb9f505","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"30.4 KB","destSize":"30.4 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000041542630","sourceStatusCode":200,"destWidth":613,"destHeight":732,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn64@2020_6/2022/03/14/11-54-43-391_f334ccc6e44febf9.webp","sourceBytes":39302,"destBytes":39302,"feedId":23280,"totalSpendMs":2742,"convertSpendMs":0,"createdTime":"2022-03-14 19:54:40","host":"us-030*","referer":"https://segmentfault.com/a/1190000041542627","linkMd5ListStr":"bb59cf91cecda234f5c9e5cb4bb9f505","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"38.4 KB","destSize":"38.4 KB","compressRate":"100%"},{"code":1,"isDone":false,"source":"https://segmentfault.com/img/remote/1460000041542631","sourceStatusCode":200,"destWidth":732,"destHeight":581,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn66@2020_6/2022/03/14/11-54-43-741_6a43563960304412.webp","sourceBytes":48144,"destBytes":48144,"feedId":23280,"totalSpendMs":3036,"convertSpendMs":0,"createdTime":"2022-03-14 19:54:40","host":"us-031*","referer":"https://segmentfault.com/a/1190000041542627","linkMd5ListStr":"bb59cf91cecda234f5c9e5cb4bb9f505","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"47 KB","destSize":"47 KB","compressRate":"100%"}],"successGithubMap":{"myreaderx15":1,"myreaderx22":1,"myreaderx12":1},"failGithubMap":{}}