{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-10-13 14:31:35","updatedTime":"2020-10-13 14:31:35","title":"Extracting Flash Memory using JTAG","link":"http://18.130.251.17/?p=204","description":"<p>I previously mentioned dumping memory contents using SPI, with a BusPirate. Sometimes that’s not feasible – such as if the flash memory module is a little inaccessible and you’re not feeling like deconstructing the board just yet.</p> \n<p>An alternative is to pull memory over JTAG. I talked about <a href=\"http://18.130.251.17/jtagulating-jtag/\">accessing JTAG and interacting with a chip using OpenOCD</a> previously, however this time around I’d like to go a step further.</p> \n<p>The board I’m using in this example is a Netgear DG834Gv1, which has an exposed JTAG, shown below on the bottom right of the board (in red):</p> \n<figure class=\"wp-block-image size-large\"> \n <img loading=\"lazy\" width=\"1024\" height=\"576\" src=\"https://gracefulsecurity.com/wp-content/uploads/2020/02/JTAG-and-UART-1024x576.jpg\" alt=\"\" class=\"wp-image-205\" srcset=\"https://gracefulsecurity.com/wp-content/uploads/2020/02/JTAG-and-UART-1024x576.jpg 1024w, https://gracefulsecurity.com/wp-content/uploads/2020/02/JTAG-and-UART-300x169.jpg 300w, https://gracefulsecurity.com/wp-content/uploads/2020/02/JTAG-and-UART-768x432.jpg 768w, https://gracefulsecurity.com/wp-content/uploads/2020/02/JTAG-and-UART-1536x864.jpg 1536w, https://gracefulsecurity.com/wp-content/uploads/2020/02/JTAG-and-UART-1200x675.jpg 1200w, https://gracefulsecurity.com/wp-content/uploads/2020/02/JTAG-and-UART.jpg 1710w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" /> \n</figure> \n<span id=\"more-204\"></span> \n<p>I’ll pick up from where the <a href=\"http://18.130.251.17/jtagulating-jtag/\">previous post</a> left off, at that point we had connected OpenOCD to the device and ran “scan_chain”, which I use just to confirm communications are working as expected. However now we’re going to set up an additional config file which maps out the CPU and Memory.</p> \n<p>We’ll need a few details about the chips – on this board their markings are visible which makes things a little easier. For example, the CPU can be seen near the centre of the board – marked TNETD7301GDU. This will lead to the data-sheet which will lead to the information required for the config file. For example, the data-sheet says it’s a Texas Instruments AR7, which is a MIPS architecture.</p> \n<p>It’s worth pointing out that for the DG834Gv1, OpenOCD already has a configuration file – but I’ll include what I’m using here so you can take a look at what it contains and what each part does:</p> \n<pre class=\"wp-block-preformatted\">adapter_khz 1000\n transport select jtag\n\nset partition_list {\n     all { \"All 4MB\"         0x90000000 0x00400000  }\n}\n\njtag newtap ti-ar7 cpu -irlen 5 -expected-id 0x0000100F\ntarget create ti-ar7 mips_m4k -endian little -chain-position ti-ar7.cpu\n flash bank ti-ar7.norflash cfi 0x90000000 0x00400000 2 2 ti-ar7</pre> \n<p>So with the above, we’re configuring information about the CPU architecture, and the flash memory we’d like to interact with. On this board there is 4MB of flash (determined by looking at the chips on the board and finding their data-sheets – then this is defined on the last line of the config file with the flash bank command). The CPU architecture is given as a target create command, are defined as MIPS.</p> \n<p>We’re setting it up to pull the entire flash contents over JTAG here. If you would like to pull a “piece” of memory instead, you can arbitrarily alter the “partition_list” variable by changing the start (here that’s set to 0x90000000) and length (which here is 0x00400000, that’s hex for 4MB) variables. </p> \n<p>So above I’ve just configured “all” to refer to the entire memory content – but alternatively you could configure something like this:</p> \n<pre class=\"wp-block-preformatted\">set partition_list {     <br>loader    { \"Bootloader (ADAM2)\"      0x90000000 0x00020000 }     <br>firmware    { \"Kernel+rootfs\"       0x90020000 0x003d0000 }     <br>config    { \"Bootloader config space\" 0x903f0000 0x00010000 } <br>}</br></br></br></br></pre> \n<p>This set up is sourced from the OpenOCD configuration file for the DG384v3 board and shows how you can separate bits out from the memory, if you know the layout and only want a specific piece. However, this “partition” separation isn’t mandated, you can (as with my config file above) pull out the whole thing. Separating it in the way the OpenOCD file does allows you to optionally pull specific areas of memory if so desired.</p> \n<p>To actually extract the contents, the above configuration file can be supplied along side the configuration file for your JTAG interface (as before I’m using a UM232H) and the firmware-recovery tools files. Then you can extract the memory like this:</p> \n<pre class=\"wp-block-preformatted\">openocd -f /usr/share/openocd/scripts/interface/ftdi/um232h.cfg -f /home/hollyw/config3.cfg -f tools/firmware-recovery.tcl -c \"dump_part all output.bin\"</pre> \n<p>The above command will load the configuration for the UM232H, which <a href=\"http://18.130.251.17/jtagulating-jtag/\">as mentioned previously</a> is the JTAG interface that I’m using. It will configure the architecture and memory layout – defining an “all” partition referring to the full 4MB of flash. It then loads the “dump_part” function from firmware-recovery.tcl and uses it to output the flash contents to a file called output.bin!</p> \n<figure class=\"wp-block-image size-large\"> \n <img loading=\"lazy\" width=\"1024\" height=\"542\" src=\"http://18.130.251.17/wp-content/uploads/2020/02/ABitOverJTAG-1-1024x542.png\" alt=\"\" class=\"wp-image-206\" srcset=\"https://gracefulsecurity.com/wp-content/uploads/2020/02/ABitOverJTAG-1-1024x542.png 1024w, https://gracefulsecurity.com/wp-content/uploads/2020/02/ABitOverJTAG-1-300x159.png 300w, https://gracefulsecurity.com/wp-content/uploads/2020/02/ABitOverJTAG-1-768x407.png 768w, https://gracefulsecurity.com/wp-content/uploads/2020/02/ABitOverJTAG-1.png 1076w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" /> \n</figure> \n<p> That’s it! </p> \n<p>The post <a href=\"https://gracefulsecurity.com/extracting-flash-memory-using-jtag/\" target=\"_blank\">Extracting Flash Memory using JTAG</a> first appeared on <a href=\"https://gracefulsecurity.com/\" target=\"_blank\">GracefulSecurity</a>.</p>","descriptionType":"html","publishedDate":"Tue, 19 Mar 2019 09:00:00 +0000","feedId":38542,"bgimg":"https://gracefulsecurity.com/wp-content/uploads/2020/02/JTAG-and-UART-1024x576.jpg","linkMd5":"583a153b9634d0ac75e7324ae6ce21ef","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn78@2020_1/2020/10/13/06-32-36-558_dc9947df43fa58f4.webp","destWidth":1024,"destHeight":576,"sourceBytes":119890,"destBytes":86178,"author":"HollyGraceful","articleImgCdnMap":{"https://gracefulsecurity.com/wp-content/uploads/2020/02/JTAG-and-UART-1024x576.jpg":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn78@2020_1/2020/10/13/06-32-36-558_dc9947df43fa58f4.webp","http://18.130.251.17/wp-content/uploads/2020/02/ABitOverJTAG-1-1024x542.png":null},"publishedOrCreatedDate":1602570695613}],"record":{"createdTime":"2020-10-13 14:31:35","updatedTime":"2020-10-13 14:31:35","feedId":38542,"fetchDate":"Tue, 13 Oct 2020 06:31:35 +0000","fetchMs":1155,"handleMs":40,"totalMs":186703,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"3b520398b65f82a2a83818c2716ca970","hostName":"us-015*","requestId":"f389c413a0d449d4a9a1cc86c909b539_38542","contentType":"application/rss+xml; charset=UTF-8","totalBytes":86178,"bgimgsTotal":1,"bgimgsGithubTotal":1,"articlesImgsTotal":2,"articlesImgsGithubTotal":1,"successGithubMap":{"myreaderx3":1},"failGithubMap":{}},"feed":{"createdTime":"2020-09-07 03:14:28","updatedTime":"2020-09-07 05:29:49","id":38542,"name":"GracefulSecurity","url":"https://www.gracefulsecurity.com/feed/","subscriber":83,"website":null,"icon":"https://gracefulsecurity.com/favicon.ico","icon_jsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx63/cdn51@2020_5/2020/09/06/21-29-48-565_efa7f8a14ab972d4.png","description":"","weekly":null,"link":null},"noPictureArticleList":[{"createdTime":"2020-10-13 14:34:41","updatedTime":"2020-10-13 14:34:41","id":null,"feedId":38542,"linkMd5":"583a153b9634d0ac75e7324ae6ce21ef"}],"tmpCommonImgCdnBytes":86178,"tmpBodyImgCdnBytes":0,"tmpBgImgCdnBytes":0,"extra4":{"start":1602570694333,"total":0,"statList":[{"spend":1240,"msg":"获取xml内容"},{"spend":40,"msg":"解释文章"},{"spend":0,"msg":"上传封面图到cdn"},{"spend":0,"msg":"修正封面图上传失败重新上传"},{"spend":122924,"msg":"正文链接上传到cdn"}]},"extra5":2,"extra6":1,"extra7ImgCdnFailResultVector":[null,null],"extra10_invalidATagHrefValue":{"http://18.130.251.17/?p=204_/jtagulating-jtag/":"http://18.130.251.17/jtagulating-jtag/"},"extra111_proxyServerAndStatMap":{"http://europe69.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]},"http://europe-58.herokuapp.com/":{"failCount":1,"successCount":0,"resultList":[null]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://gracefulsecurity.com/wp-content/uploads/2020/02/JTAG-and-UART-1024x576.jpg","sourceStatusCode":200,"destWidth":1024,"destHeight":576,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx3/cdn78@2020_1/2020/10/13/06-32-36-558_dc9947df43fa58f4.webp","sourceBytes":119890,"destBytes":86178,"targetWebpQuality":75,"feedId":38542,"totalSpendMs":1804,"convertSpendMs":30,"createdTime":"2020-10-13 14:32:36","host":"europe70*","referer":"http://18.130.251.17/?p=204","linkMd5ListStr":"583a153b9634d0ac75e7324ae6ce21ef,583a153b9634d0ac75e7324ae6ce21ef","githubUser":"myreaderx3","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"117.1 KB","destSize":"84.2 KB","compressRate":"71.9%"}],"successGithubMap":{"myreaderx3":1},"failGithubMap":{}}