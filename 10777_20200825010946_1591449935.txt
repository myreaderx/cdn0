{"code":1,"isDone":false,"toInsertArticleList":[{"createdTime":"2020-08-25 09:04:55","updatedTime":"2020-08-25 09:04:55","title":"参与定制行业标准-《数据资产管理实践白皮书3.0》","link":"https://blog.liuts.com/post/255/","description":"\n \n\t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2018数据资产管理大会，在中国信息通信研究院、中国通信标准化协会的主导下，于12月13日在北京国家会议中心隆重召开。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=415\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=415\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\" width=\"800\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;大会现场,腾讯游戏大数据管理负责人刘天斯详尽地展示了游戏数据服务场景、腾讯游戏数据资产管理的体系架构，将数据资产管理在一个具体场景中的实践作为一个主题，并分享了大数据资产管理体系中的元数据管理、质量管理、影响评估、价值评估等方面的内容。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=420\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=420\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\" width=\"800\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;刘天斯在分享中指出，只有帮业务“用好、管好、看好”大数据资产，才能助力业务充分发挥数据的价值，实现数据资产化，提升产品市场竞争力。大数据资产管理体系中的“三好”能力模型，也是评判数据资产管理能力建设的标准。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;关于数据价值评估，在行业内率先提出数据热度、广度和收益度的“三度”价值评估方法论，为当前业界共同面临的数据价值评估难，提供了新的思考方向。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;大会正式发布《数据资产管理实践白皮书3.0》，腾讯游戏代表互联网企业参与制定了该大数据技术标准。个人也作为主要编写人，正式成为白皮书的编委会成员。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=417\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=417\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><a href=\"https://blog.liuts.com/attachment.php?fid=418\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=418\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>下载白皮书：<br/><a href=\"http://www.caict.ac.cn/kxyj/qwfb/bps/201812/P020181214608773379834.pdf\" target=\"_blank\">http://www.caict.ac.cn/kxyj/qwfb/bps/201812/P020181214608773379834.pdf</a><br/>Tags - <a href=\"https://blog.liuts.com/tags/%25E7%2599%25BD%25E7%259A%25AE%25E4%25B9%25A6/\" rel=\"tag\">白皮书</a> , <a href=\"https://blog.liuts.com/tags/%25E5%25A4%25A7%25E6%2595%25B0%25E6%258D%25AE/\" rel=\"tag\">大数据</a> , <a href=\"https://blog.liuts.com/tags/%25E8%25B5%2584%25E4%25BA%25A7%25E7%25AE%25A1%25E7%2590%2586/\" rel=\"tag\">资产管理</a> , <a href=\"https://blog.liuts.com/tags/%25E6%2595%25B0%25E6%258D%25AE%25E8%25B5%2584%25E4%25BA%25A7%25E7%25AE%25A1%25E7%2590%2586%25E5%25AE%259E%25E8%25B7%25B5%25E7%2599%25BD%25E7%259A%25AE%25E4%25B9%25A63.0/\" rel=\"tag\">数据资产管理实践白皮书3.0</a>\n\n","descriptionType":"text/html","publishedDate":"Tue, 29 Jan 2019 08:44:50 +0000","feedId":10777,"bgimg":"","linkMd5":"668ed1a0b63a78d3738856199aefd8c3","bgimgJsdelivr":"","metaImg":"","author":"刘天斯 <liutiansi@gmail.com>","articleImgCdnMap":{"https://blog.liuts.com/attachment.php?fid=415":null,"https://blog.liuts.com/attachment.php?fid=420":null,"https://blog.liuts.com/attachment.php?fid=417":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn31@2020_6/2020/08/25/01-08-21-427_057715b2ff364b6e.webp","https://blog.liuts.com/attachment.php?fid=418":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn36@2020_5/2020/08/25/01-07-53-718_0f90bd37b3dcd83c.webp"},"publishedOrCreatedDate":1598317495134},{"createdTime":"2020-08-25 09:04:55","updatedTime":"2020-08-25 09:04:55","title":"《Python自动化运维：技术与最佳实践》上架了","link":"https://blog.liuts.com/post/244/","description":"\n \n\t<br/>【当当】 <a href=\"http://product.dangdang.com/23593858.html\" target=\"_blank\">http://product.dangdang.com/23593858.html</a><br/>【京东】 <a href=\"http://item.jd.com/11571426.html\" target=\"_blank\">http://item.jd.com/11571426.html</a><br/>【亚马逊】 <a href=\"http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00P5VKZWW\" target=\"_blank\">http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00P5VKZWW</a><br/>【天猫】 <a href=\"http://detail.tmall.com/item.htm?spm=a1z10.3.w4011-7555161747.28.SgDdii&id=42141530490&rn=3a7da8b28eea552fb6ebb6ed43ab024d&abbucket=18\" target=\"_blank\">http://detail.tmall.com/item.htm?spm=a1z10.3.w4011-7555161747.28.SgDdii&id=42141530490&rn=3a7da8b28eea552fb6ebb6ed43ab024d&abbucket=18</a><br/>【China-pub】 <a href=\"http://product.china-pub.com/3804188\" target=\"_blank\">http://product.china-pub.com/3804188</a><br/><br/>《python自动化运维：技术与最佳实践》附带示例及案例源码<br/>【国内镜像】（JD云汇）https://code.jd.com/yorkoliu/pyauto<br/>【国外镜像】（Github）https://github.com/yorkoliu/pyauto<br/>【源码打包下载】（zip）http://share.weiyun.com/9e4bfc70a9af8840927b92910ab80d8b<br/><br/><a href=\"https://blog.liuts.com/attachment.php?fid=363\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=363\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><strong>一、内容简介</strong><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;本书在中国运维领域将有“划时代”的重要意义：一方面，这是国内第一本从纵、深和实践角度探讨Python在运维领域应用的著作；一方面本书的作者是中国运维领域的“偶像级”人物，本书是他在天涯社区和腾讯近10年工作经验的结晶。因为作者实战经验丰富，所以能高屋建瓴、直指痛处，围绕Python自动化运维这个主题，不仅详细介绍了系统基础信息、服务监控、数据报表、系统安全等基础模块，而且深入讲解了自动化操作、系统管理、配置管理、集群管理及大数据应用等高级功能。最重要的是，完整重现了4个来自实际生产环境的不同功能运维平台的综合案例，展示了完整的平台架构及开发流程。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;全书一共16章：基础篇（1-4章）详细介绍了系统基础信息、业务服务监控、定制业务质量报表、系统安全等基础和常用模块；高级篇（5-12章）深入讲解了批量运维管理器pexpect、paramiko、Fabric，集中化管理平台Ansible、Saltstack，统一网络控制器Func等高级功能，涵盖自动化操作、系统管理、配置管理、集群管理及大数据应用等主题；案例篇（13-16章）详细介绍了4个来自不同平台的运维案例，如何从零开始打造一个B/S自动化运维平台、如何打造Linux系统安全审计功能、如何构建分布式质量监控平台、如何构建桌面版C/S自动化运维平台，这4个案例均来自实际生产环境。<br/><br/><strong>二、目录</strong><br/>前　　言<br/>第一部分　基础篇<br/>第1章　系统基础信息模块详解 2<br/>1.1　系统性能信息模块psutil 2<br/>1.1.1　获取系统性能信息 3<br/>1.1.2　系统进程管理方法 6<br/>1.2　实用的IP地址处理模块IPy 7<br/>1.2.1　IP地址、网段的基本处理 8<br/>1.2.2　多网络计算方法详解 9<br/>1.3　DNS处理模块dnspython 11<br/>1.3.1　模块域名解析方法详解 11<br/>1.3.2　常见解析类型示例说明 12<br/>1.3.3　实践：DNS域名轮循业务监控 14<br/>第2章　业务服务监控详解 17<br/>2.1　文件内容差异对比方法 17<br/>2.1.1　示例1：两个字符串的差异对比 17<br/>2.1.2　生成美观的对比HTML格式文档 19<br/>2.1.3　示例2：对比Nginx配置文件差异 19<br/>2.2　文件与目录差异对比方法 21<br/>2.2.1　模块常用方法说明 21<br/>2.2.2　实践：校验源与备份目录差异 25<br/>2.3　发送电子邮件模块smtplib 27<br/>2.3.1　smtplib模块的常用类与方法 27<br/>2.3.2　定制个性化的邮件格式方法 28<br/>2.3.3　定制常用邮件格式示例详解 29<br/>2.4　探测Web服务质量方法 34<br/>2.4.1　模块常用方法说明 35<br/>2.4.2　实践：实现探测Web服务质量 36<br/>第3章　定制业务质量报表详解 39<br/>3.1　数据报表之Excel操作模块 39<br/>3.1.1　模块常用方法说明 41<br/>3.1.2　实践：定制自动化业务流量报表周报 48<br/>3.2　Python与rrdtool的结合模块 50<br/>3.2.1　rrdtool模块常用方法说明 51<br/>3.2.2　实践：实现网卡流量图表绘制 53<br/>3.3　生成动态路由轨迹图 56<br/>3.3.1　模块常用方法说明 56<br/>3.3.2　实践：实现TCP探测目标服务路由轨迹 57<br/>第4章　Python与系统安全 60<br/>4.1　构建集中式的病毒扫描机制 60<br/>4.1.1　模块常用方法说明 61<br/>4.1.2　实践：实现集中式的病毒扫描 61<br/>4.2　实现高效的端口扫描器 64<br/>4.2.1　模块常用方法说明 64<br/>4.2.2　实践：实现高效的端口扫描 66<br/>第二部分　高级篇<br/>第5章　系统批量运维管理器pexpect详解 70<br/>5.1　pexpect的安装 70<br/>5.2　pexpect的核心组件 71<br/>5.2.1　spawn类 71<br/>5.2.2　run函数 74<br/>5.2.3　pxssh类 75<br/>5.3　pexpect应用示例 76<br/>5.3.1　实现一个自动化FTP操作 76<br/>5.3.2　远程文件自动打包并下载 77<br/>第6章　系统批量运维管理器paramiko详解 79<br/>6.1　paramiko的安装 79<br/>6.2　paramiko的核心组件 81<br/>6.2.1　SSHClient类 81<br/>6.2.2　SFTPClient类 82<br/>6.3　paramiko应用示例 85<br/>6.3.1　实现密钥方式登录远程主机 85<br/>6.3.2　实现堡垒机模式下的远程命令执行 85<br/>6.3.3　实现堡垒机模式下的远程文件上传 88<br/>第7章　系统批量运维管理器Fabric详解 91<br/>7.1　Fabric的安装 91<br/>7.2　fab的常用参数 92<br/>7.3　fabfile的编写 93<br/>7.3.1　全局属性设定 93<br/>7.3.2　常用API 94<br/>7.3.3　示例1：查看本地与远程主机信息 95<br/>7.3.4　示例2：动态获取远程目录列表 96<br/>7.3.5　示例3：网关模式文件上传与执行 97<br/>7.4　Fabric应用示例 98<br/>7.4.1　示例1：文件打包、上传与校验 98<br/>7.4.2　示例2：部署LNMP业务服务环境 99<br/>7.4.3　示例3：生产环境代码包发布管理 101<br/>第8章　从“零”开发一个轻量级WebServer 104<br/>8.1　Yorserver介绍 104<br/>8.1.1　功能特点 104<br/>8.1.2　配置文件 105<br/>8.2　功能实现方法 106<br/>8.2.1　HTTP缓存功能 107<br/>8.2.2　HTTP压缩功能 111<br/>8.2.3　HTTP SSL功能 111<br/>8.2.4　目录列表功能 114<br/>8.2.5　动态CGI功能 114<br/>第9章　集中化管理平台Ansible详解 118<br/>9.1　YAML语言 119<br/>9.1.1　块序列描述 120<br/>9.1.2　块映射描述 120<br/>9.2　Ansible的安装 121<br/>9.2.1　业务环境说明 121<br/>9.2.2　安装EPEL 122<br/>9.2.3　安装Ansible 122<br/>9.2.4　Ansible配置及测试 122<br/>9.2.5　配置Linux主机SSH无密码访问 123<br/>9.3　定义主机与组规则 124<br/>9.3.1　定义主机与组 124<br/>9.3.2　定义主机变量 125<br/>9.3.3　定义组变量 125<br/>9.3.4　分离主机与组特定数据 126<br/>9.4　匹配目标 127<br/>9.5　Ansible常用模块及API 127<br/>9.6　playbook介绍 132<br/>9.6.1　定义主机与用户 132<br/>9.6.2　任务列表 133<br/>9.6.3　执行playbook 134<br/>9.7　playbook角色与包含声明 135<br/>9.7.1　包含文件，鼓励复用 135<br/>9.7.2　角色 136<br/>9.8　获取远程主机系统信息：Facts 141<br/>9.9　变量 142<br/>9.9.1　Jinja2过滤器 143<br/>9.9.2　本地Facts 143<br/>9.9.3　注册变量 144<br/>9.10　条件语句 145<br/>9.11　循环 146<br/>9.12　示例讲解 147<br/>第10章　集中化管理平台Saltstack详解 155<br/>10.1　Saltstack的安装 156<br/>10.1.1　业务环境说明 156<br/>10.1.2　安装EPEL 156<br/>10.1.3　安装Saltstack 156<br/>10.1.4　Saltstack防火墙配置 157<br/>10.1.5　更新Saltstack配置及安装校验 157<br/>10.2　利用Saltstack远程执行命令 158<br/>10.3　Saltstack常用模块及API 161<br/>10.4　grains组件 166<br/>10.4.1　grains常用操作命令 167<br/>10.4.2　定义grains数据 167<br/>10.5　pillar组件 170<br/>10.5.1　pillar的定义 171<br/>10.5.2　pillar的使用 173<br/>10.6　state介绍 174<br/>10.6.1　state的定义 174<br/>10.6.2　state的使用 175<br/>10.7　示例：基于Saltstack实现的配置集中化管理 177<br/>10.7.1　环境说明 177<br/>10.7.2　主控端配置说明 177<br/>10.7.3　配置pillar 179<br/>10.7.4　配置state 180<br/>10.7.5　校验结果 183<br/>第11章　统一网络控制器Func详解 185<br/>11.1　Func的安装 186<br/>11.1.1　业务环境说明 186<br/>11.1.2　安装Func 186<br/>11.2　Func常用模块及API 189<br/>11.2.1　选择目标主机 190<br/>11.2.2　常用模块详解 190<br/>11.3　自定义Func模块 194<br/>11.4　非Python API接口支持 198<br/>11.5　Func的Facts支持 199<br/>第12章　Python大数据应用详解 202<br/>12.1　环境说明 202<br/>12.2　Hadoop部署 203<br/>12.3　使用Python编写MapReduce 207<br/>12.3.1　用原生Python编写MapReduce详解 208<br/>12.3.2　用Mrjob框架编写MapReduce详解 212<br/>12.4　实战分析 216<br/>12.4.1　示例场景 216<br/>12.4.2　网站访问流量统计 217<br/>12.4.3　网站HTTP状态码统计 219<br/>12.4.4　网站分钟级请求数统计 220<br/>12.4.5　网站访问来源IP统计 221<br/>12.4.6　网站文件访问统计 222<br/>第三部分　案例篇<br/>第13章　从零开始打造B/S自动化运维平台 226<br/>13.1　平台功能介绍 226<br/>13.2　系统构架设计 227<br/>13.3　数据库结构设计 228<br/>13.3.1　数据库分析 228<br/>13.3.2　数据字典 228<br/>13.3.3　数据库模型 229<br/>13.4　系统环境部署 230<br/>13.4.1　系统环境说明 230<br/>13.4.2　系统平台搭建 230<br/>13.4.3　开发环境优化 233<br/>13.5　系统功能模块设计 235<br/>13.5.1　前端数据加载模块 235<br/>13.5.2　数据传输模块设计 237<br/>13.5.3　平台功能模块扩展 240<br/>第14章　打造Linux系统安全审计功能 245<br/>14.1　平台功能介绍 245<br/>14.2　系统构架设计 246<br/>14.3　数据库结构设计 247<br/>14.3.1　数据库分析 247<br/>14.3.2　数据字典 247<br/>14.4　系统环境部署 248<br/>14.4.1　系统环境说明 248<br/>14.4.2　上报主机配置 248<br/>14.5　服务器端功能设计 252<br/>14.5.1　Django配置 252<br/>14.5.2　功能实现方法 253<br/>第15章　构建分布式质量监控平台 256<br/>15.1　平台功能介绍 256<br/>15.2　系统构架设计 257<br/>15.3　数据库结构设计 258<br/>15.3.1　数据库分析 258<br/>15.3.2　数据字典 258<br/>15.3.3　数据库模型 259<br/>15.4　系统环境部署 260<br/>15.4.1　系统环境说明 260<br/>15.4.2　数据采集角色 260<br/>15.4.3　rrdtool作业 261<br/>15.5　服务器端功能设计 263<br/>15.5.1　Django配置 263<br/>15.5.2　业务增加功能 264<br/>15.5.3　业务报表功能 266<br/>第16章　构建桌面版C/S自动化运维平台 269<br/>16.1　平台功能介绍 269<br/>16.2　系统构架设计 270<br/>16.3　数据库结构设计 271<br/>16.3.1　数据库分析 271<br/>16.3.2　数据字典 272<br/>16.3.3　数据库模型 272<br/>16.4　系统环境部署 273<br/>16.4.1　系统环境说明 273<br/>16.4.2　系统环境搭建 273<br/>16.5　系统功能模块设计 274<br/>16.5.1　用户登录模块 274<br/>16.5.2　系统配置功能 275<br/>16.5.3　服务器分类模块 277<br/>16.5.4　系统升级功能 280<br/>16.5.5　客户端模块编写 284<br/>16.5.6　执行功能模块 287<br/>16.5.7　平台程序发布 289<br/><br/><strong>三、书摘与插画</strong><br/><a href=\"http://img32.ddimg.cn/imgother/201411/04_1/201411041308481672.jpg\" target=\"_blank\"><img src=\"http://img32.ddimg.cn/imgother/201411/04_1/201411041308481672.jpg\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/><a href=\"http://img37.ddimg.cn/imgother/201411/04_1/201411041308511387.jpg\" target=\"_blank\"><img src=\"http://img37.ddimg.cn/imgother/201411/04_1/201411041308511387.jpg\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/><a href=\"http://img38.ddimg.cn/imgother/201411/04_1/201411041308531388.jpg\" target=\"_blank\"><img src=\"http://img38.ddimg.cn/imgother/201411/04_1/201411041308531388.jpg\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/><a href=\"http://img39.ddimg.cn/imgother/201411/04_1/201411041308531389.jpg\" target=\"_blank\"><img src=\"http://img39.ddimg.cn/imgother/201411/04_1/201411041308531389.jpg\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>Tags - <a href=\"https://blog.liuts.com/tags/python%25E8%2587%25AA%25E5%258A%25A8%25E5%258C%2596%25E8%25BF%2590%25E7%25BB%25B4%25EF%25BC%259A%25E6%258A%2580%25E6%259C%25AF%25E4%25B8%258E%25E6%259C%2580%25E4%25BD%25B3%25E5%25AE%259E%25E8%25B7%25B5/\" rel=\"tag\">python自动化运维：技术与最佳实践</a> , <a href=\"https://blog.liuts.com/tags/python/\" rel=\"tag\">python</a> , <a href=\"https://blog.liuts.com/tags/%25E8%2587%25AA%25E5%258A%25A8%25E5%258C%2596/\" rel=\"tag\">自动化</a> , <a href=\"https://blog.liuts.com/tags/%25E8%25BF%2590%25E7%25BB%25B4/\" rel=\"tag\">运维</a> , <a href=\"https://blog.liuts.com/tags/%25E5%2588%2598%25E5%25A4%25A9%25E6%2596%25AF/\" rel=\"tag\">刘天斯</a> , <a href=\"https://blog.liuts.com/tags/python%25E4%25B9%25A6%25E7%25B1%258D/\" rel=\"tag\">python书籍</a>\n\n","descriptionType":"text/html","publishedDate":"Wed, 05 Nov 2014 08:29:14 +0000","feedId":10777,"bgimg":"https://blog.liuts.com/attachment.php?fid=363","linkMd5":"789d193ed87d45ffd97176dd5112ca5e","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn16@2020_6/2020/08/25/01-05-01-018_83e28d90ea38e062.webp","destWidth":800,"destHeight":800,"sourceBytes":98618,"destBytes":35770,"author":"刘天斯 <liutiansi@gmail.com>","articleImgCdnMap":{"https://blog.liuts.com/attachment.php?fid=363":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn16@2020_6/2020/08/25/01-05-01-018_83e28d90ea38e062.webp","http://img32.ddimg.cn/imgother/201411/04_1/201411041308481672.jpg":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn3@2020_4/2020/08/25/01-07-00-722_de8577432f1e7158.webp","http://img37.ddimg.cn/imgother/201411/04_1/201411041308511387.jpg":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn91@2020_1/2020/08/25/01-07-00-050_bdff03249f850a73.webp","http://img38.ddimg.cn/imgother/201411/04_1/201411041308531388.jpg":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn100@2020_3/2020/08/25/01-06-59-633_38994bcd6dd61526.webp","http://img39.ddimg.cn/imgother/201411/04_1/201411041308531389.jpg":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn8@2020_4/2020/08/25/01-06-59-562_27c043487409862d.webp"},"publishedOrCreatedDate":1598317495135},{"createdTime":"2020-08-25 09:04:55","updatedTime":"2020-08-25 09:04:55","title":"大数据资产管理在腾讯游戏的实践【原创】","link":"https://blog.liuts.com/post/254/","description":"\n \n\t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;数据是资产的概念已经成为行业共识。然而现实中，对数据资产的管理和应用往往还处于摸索阶段，数据资产管理面临诸多挑战。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;为进一步促进数据资产价值相关问题的研究交流，2018年12月13日，由中国信息通信研究院、中国通信标准化协会主办，TC601大数据技术标准推进委员会承办的“2018数据资产管理大会”在京召开。腾讯游戏大数据管理负责人、高级工程师刘天斯进行了《大数据资产管理在腾讯游戏的实践》的演讲。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=414\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=414\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>Tags - <a href=\"https://blog.liuts.com/tags/%25E5%25A4%25A7%25E6%2595%25B0%25E6%258D%25AE/\" rel=\"tag\">大数据</a> , <a href=\"https://blog.liuts.com/tags/%25E8%25B5%2584%25E4%25BA%25A7%25E7%25AE%25A1%25E7%2590%2586/\" rel=\"tag\">资产管理</a> , <a href=\"https://blog.liuts.com/tags/%25E5%2585%2583%25E6%2595%25B0%25E6%258D%25AE/\" rel=\"tag\">元数据</a> , <a href=\"https://blog.liuts.com/tags/%25E6%2595%25B0%25E6%258D%25AE%25E4%25BB%25B7%25E5%2580%25BC/\" rel=\"tag\">数据价值</a>\n\n","descriptionType":"text/html","publishedDate":"Tue, 29 Jan 2019 08:31:13 +0000","feedId":10777,"bgimg":"https://blog.liuts.com/attachment.php?fid=414","linkMd5":"629fb0ec07335c6bc22c7a82ff0f6d0b","author":"刘天斯 <liutiansi@gmail.com>","articleImgCdnMap":{"https://blog.liuts.com/attachment.php?fid=414":null},"publishedOrCreatedDate":1598317495134},{"createdTime":"2020-08-25 09:04:55","updatedTime":"2020-08-25 09:04:55","title":"《python自动化运维：技术与最佳实践》之OMServer平台环境部署详解【主控制端】","link":"https://blog.liuts.com/post/246/","description":"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主控端是OMServer的核心角色，负责接收加密的协议串且进行解密，解析成OMServer调用的任务模块，同时结合角色中的saltstack、ansible或func组件，向目标业务服务器集群（被控机）发送执行任务，执行完毕后，将返回的执行结果加解密处理，最后逐级返回给系统管理员，角色所在位置见以下架构图：\n<br />\n<a href=\"https://blog.liuts.com/attachment.php?fid=366\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=366\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\" /></a>\n<br />\n<strong>一、环境部署</strong>\n<br />1、部署saltstack、ansible或func组件，详细见本书相关章节，此处省略；\n<br />\n<br />2、安装rpyc模块\n<br />\n<textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# wget https://pypi.python.org/packages/source/r/rpyc/rpyc-3.2.3.tar.gz --no-check-certificate\n# tar -zxvf rpyc-3.2.3.tar.gz\n# cd rpyc-3.2.3\n# python setup.py install\n</textarea>\n<br />3、下载主控端源码\n<br />#cd /home \n<br />download github地址：https://github.com/yorkoliu/pyauto/tree/master/第十三章/OMServer\n<br />\n<br />修改OMServer/config.py主配置文件\n<br />\n<textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\n# -*- coding: utf-8 -*-\n#!/usr/bin/env python\nAUTO_PLATFORM = \"saltstack\"&nbsp;&nbsp;&nbsp;&nbsp;#指定组件环境，支持saltstack、ansible、func\n\n#密钥，与项目中setting.py的SECRET_KEY变量保持一致\nSECRET_KEY = \"ctmj#&amp;8hrgow_^sj$ejt@9fzsmh_o)-=(byt5jmg=e3#foya6u\"\n</textarea>\n<br />4、编写任务模块\n<br />&nbsp;&nbsp;&nbsp;&nbsp;1）在WEB前端点击【添加模块】，指定模块名称、描述、参数接口信息，提交后记录生成的模块ID（数字）；\n<br />&nbsp;&nbsp;&nbsp;&nbsp;2）在主控端OMServer/modules目录存放了各个组件的模块，以不同目录名作为区分，任务模块名称由“Mid_”+模块ID组成，与前端生成的模块ID进行关联，如Mid_1007.py，可参考现有示例进行修改。\n<br />\n<br />5、启动服务\n<br />\n<textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n&nbsp;&nbsp;&nbsp;&nbsp;# cd /home/OMServer\n&nbsp;&nbsp;&nbsp;&nbsp;# python OMservermain.py &amp;\n\n&nbsp;&nbsp;&nbsp;&nbsp;检查11511端口是否已监听\n&nbsp;&nbsp;&nbsp;&nbsp;# netstat -an|grep 11511\n</textarea>\n<br />\n<br />\n<strong>二、校验环境</strong>\n<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，打开浏览器访问http://omserver.domain.com（自定义域名，可通过修改hosts实现），效果图如下。\n<br />\n<a href=\"https://blog.liuts.com/attachment.php?fid=367\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=367\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\" /></a>\n<br />\n<br />\n<strong>三、基于Python构建可扩展的自动化运维平台（WOT分享主题）</strong>\n<br />\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/42901993?startSlide=2\" width=\"510\" height=\"420\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen=\"\"> </iframe> \n<div style=\"margin-bottom:5px\"> \n <strong> <a href=\"https://www.slideshare.net/liutiansi/python-42901993\" title=\"基于Python构建可扩展的自动化运维平台\" target=\"_blank\">基于Python构建可扩展的自动化运维平台</a> </strong> from \n <strong><a href=\"https://www.slideshare.net/liutiansi\" target=\"_blank\">我在slideshare.net上的所有分享</a></strong> \n</div>\n<br />Tags - \n<a href=\"https://blog.liuts.com/tags/python%25E8%2587%25AA%25E5%258A%25A8%25E5%258C%2596%25E8%25BF%2590%25E7%25BB%25B4%25EF%25BC%259A%25E6%258A%2580%25E6%259C%25AF%25E4%25B8%258E%25E6%259C%2580%25E4%25BD%25B3%25E5%25AE%259E%25E8%25B7%25B5/\" rel=\"tag\">python自动化运维：技术与最佳实践</a> , \n<a href=\"https://blog.liuts.com/tags/python/\" rel=\"tag\">python</a> , \n<a href=\"https://blog.liuts.com/tags/omserver/\" rel=\"tag\">omserver</a> , \n<a href=\"https://blog.liuts.com/tags/%25E7%258E%25AF%25E5%25A2%2583%25E9%2583%25A8%25E7%25BD%25B2/\" rel=\"tag\">环境部署</a>","descriptionType":"text/html","publishedDate":"Sat, 20 Dec 2014 22:34:26 +0000","feedId":10777,"bgimg":"https://blog.liuts.com/attachment.php?fid=366","linkMd5":"973f821a7a3a5f825eaf21ec216f09bb","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn12@2020_1/2020/08/25/01-05-05-993_a3f7d7bc59526cb7.webp","destWidth":864,"destHeight":390,"sourceBytes":207987,"destBytes":35036,"author":"刘天斯 <liutiansi@gmail.com>","articleImgCdnMap":{"https://blog.liuts.com/attachment.php?fid=366":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn12@2020_1/2020/08/25/01-05-05-993_a3f7d7bc59526cb7.webp","https://blog.liuts.com/attachment.php?fid=367":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn56@2020_2/2020/08/25/01-07-31-287_5ded02267d6fd1b2.webp"},"publishedOrCreatedDate":1598317495135},{"createdTime":"2020-08-25 09:04:55","updatedTime":"2020-08-25 09:04:55","title":"《python自动化运维：技术与最佳实践》之OMServer平台环境部署详解【Web服务端】","link":"https://blog.liuts.com/post/245/","description":"\n \n\t<br/>&#160;&#160;&#160;&#160;&#160;&#160; 《python自动化运维：技术与最佳实践》书籍发布已经1个月有余，根据读者反馈，在部署OMServer平台时遇到很多困难及问题，尤其是第一次部署Django环境的读者。因此，作者对书籍中OMServer环境部署章节的内容进行扩充，以便让每位读者都可以轻易完成平台搭建。OMServer平台涉及两个角色，其中一个为Web服务端，运行在Django及rpyc环境，另一角色为主控端，需要部署saltstack、ansible或func主控端环境，本文介绍Web服务端的部署详细步骤。<br/><br/>---环境版本说明---<br/>* Python&#160;&#160;版本&#160;&#160;2.6.6<br/>* Django&#160;&#160;版本&#160;&#160; 1.4.9<br/>* nginx&#160;&#160;版本&#160;&#160;1.5.9<br/>* pcre&#160;&#160;版本&#160;&#160;8.34<br/>* rpyc&#160;&#160;版本&#160;&#160;3.2.3<br/>* uwsgi&#160;&#160;版本&#160;&#160;2.0.4<br/>* django-debug-toolbar&#160;&#160;版本&#160;&#160;0.8.5<br/><br/> <strong>一、Django环境部署</strong><br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# yum install -y zlib-devel #Nginx环境初始化，安装gzip包\n# yum -y install python-devel mysql-devel zlib-devel openssl-devel&#160;&#160;#MySQL-python关联包\n\n# mkdir –p /data/logs/&#160;&#160;&#160;&#160;#创建uwsgi日志目录\n# mkdir –p /data/www/&#160;&#160;&#160;&#160;#创建项目目录\n# mkdir -p /home/install/Django && cd /home/install/Django&#160;&#160;&#160;&#160;#创建安装包目录\n</textarea><br/>1、安装pcre，pcre是一个轻量级的正则表达式函数库，Nginx的HTTP Rewrite模块会用到，最新版本为8.34（对于OMServer平台环境来说是非必选项）。<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.34.tar.gz\n# tar -zxvf pcre-8.34.tar.gz\n# cd pcre-8.34\n#./configure\n# make && make install\n# cd ..\n</textarea><br/>2、安装Nginx，Nginx是最流行的高性能HTTP服务器，最新版本为1.5.9。<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# wget http://nginx.org/download/nginx-1.5.9.tar.gz\n# tar -zxvf nginx-1.5.9.tar.gz\n# cd nginx-1.5.9\n#./configure --user=nobody --group=nobody --prefix=/usr/local/nginx --with-http_stub_status_module --with-cc-opt='-O3' --with-cpu-opt=opteron\n# make && make install\n# cd ..\n</textarea><br/>3、安装 MySQL-python，MySQL-python是Python访问MySQL数据库的第三方模块库，最新版本为1.2.3c1。<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# wget http://pypi.python.org/packages/source/M/MySQL-python/MySQL-python-1.2.5.zip --no-check-certificate\n# unzip MySQL-python-1.2.5.zip\n# cd MySQL-python-1.2.5\n# python setup.py install\n# cd ..\n</textarea><br/>4、rpyc模块安装，用于平台与主控端做数据通讯交互。<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# wget https://pypi.python.org/packages/source/r/rpyc/rpyc-3.2.3.tar.gz --no-check-certificate\n# tar -zxvf rpyc-3.2.3.tar.gz\n# cd rpyc-3.2.3\n# python setup.py install\n</textarea><br/>5、安装uwsgi。uwsgi是一个快速的、纯C语言开发的、自维护、对开发者友好的WSGI服务器，旨在提供专业的Python web应用发布和开发，最新版本为2.0.4。<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# wget http://projects.unbit.it/downloads/uwsgi-2.0.4.tar.gz\n# tar -zxvf uwsgi-2.0.4.tar.gz\n# cd uwsgi-2.0.4\n# make\n</textarea><br/>出现如下代码成功安装：<br/>################# uWSGI configuration #################<br/>pcre = True<br/>kernel = Linux<br/>malloc = libc<br/>execinfo = False<br/>ifaddrs = True<br/>ssl = True<br/>zlib = True<br/>locking = pthread_mutex<br/>plugin_dir = .<br/>timer = timerfd<br/>yaml = embedded<br/>json = False<br/>filemonitor = inotify<br/>routing = True<br/>debug = False<br/>capabilities = False<br/>xml = False<br/>event = epoll<br/>############## end of uWSGI configuration #############<br/>total build time: 17 seconds<br/>*** uWSGI is ready, launch it with ./uwsgi ***<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# vi /etc/ld.so.conf&#160;&#160;&#160;&#160;#添加动态链接库目录/usr/local/lib\n添加行：/usr/local/lib\n# ldconfig&#160;&#160;&#160;&#160;#使之生效\n\n# cp uwsgi /usr/bin\n# cd ..\n</textarea><br/>6、安装Django，Django是一个Python最流行的开源Web开发框架，最新版本为1.6.5。考虑到兼容与稳定性，本案例使用1.4.9版本进行开发。<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# wget https://www.djangoproject.com/m/releases/1.4/Django-1.4.9.tar.gz\n# tar -zxvf Django-1.4.9.tar.gz\n# cd Django-1.4.9\n# python setup.py install\n</textarea><br/>创建一个demo项目，以便验证环境是否正确安装部署。<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\n# cd /data/www\n# django-admin.py startproject demo\n\n# 由于Django1.4版本后对项目目录做了改动，即将manage.py管理任务命令单独放在项目根目录。为后续与OMServer平台目录结构相兼容，我们对目录结构进行调整。\n# cd demo/demo && mv * ../ && cd .. && rm -rf demo\n\n# 最终文件目录结构如下：\n# ls\n__init__.py&#160;&#160;manage.py&#160;&#160;settings.py&#160;&#160;urls.py&#160;&#160;wsgi.py\n</textarea><br/>7、django-debug-toolbar的安装（Django调试利器）<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# wget http://blog.liuts.com/Django/django-debug-toolbar-master.tar.gz\n# tar -zxvf django-debug-toolbar-master.tar.gz\n# cd django-debug-toolbar-master/\n# python setup.py install\n</textarea><br/>8、配置Nginx，修改/usr/local/nginx/conf/nginx.conf，最终完整配置如下：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\nuser&#160;&#160;nobody;\nworker_processes&#160;&#160;2;\n\n#error_log&#160;&#160;logs/error.log;\n#error_log&#160;&#160;logs/error.log&#160;&#160;notice;\n#error_log&#160;&#160;logs/error.log&#160;&#160;info;\n\n#pid&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;logs/nginx.pid;\n\n\nevents &#123;\n&#160;&#160;&#160;&#160;worker_connections&#160;&#160;10240;\n&#125;\n\n\nhttp &#123;\n&#160;&#160;&#160;&#160;include&#160;&#160;&#160;&#160;&#160;&#160; mime.types;\n&#160;&#160;&#160;&#160;default_type&#160;&#160;application/octet-stream;\n\n&#160;&#160;&#160;&#160;#log_format&#160;&#160;main&#160;&#160;'$remote_addr - $remote_user [$time_local] \"$request\" '\n&#160;&#160;&#160;&#160;#&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;'$status $body_bytes_sent \"$http_referer\" '\n&#160;&#160;&#160;&#160;#&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;'\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n&#160;&#160;&#160;&#160;#access_log&#160;&#160;logs/access.log&#160;&#160;main;\n\n&#160;&#160;&#160;&#160;sendfile&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;on;\n&#160;&#160;&#160;&#160;tcp_nopush&#160;&#160;&#160;&#160; on;\n\n&#160;&#160;&#160;&#160;keepalive_timeout&#160;&#160;65;\n\n&#160;&#160;&#160;&#160;gzip&#160;&#160;on;\n&#160;&#160;&#160;&#160;server &#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;listen 80;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;server_name demo.domain.com;\n\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;location / &#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;uwsgi_pass 127.0.0.1:9000;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;include uwsgi_params;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;uwsgi_param UWSGI_CHDIR&#160;&#160;/data/www/demo;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;uwsgi_param UWSGI_SCRIPT wsgi;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;access_log off;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#125;\n\n&#160;&#160;&#160;&#160;&#125;\n\n&#125;\n</textarea><br/><span style=\"color: #DC143C;\">* uwsgi_param UWSGI_SCRIPT wsgi;参数值wsgi对应项目目录中的wsgi.py，此处文件前缀与参数值要保持一致。</span><br/><br/>9、配置uwsgi，创建uwsgi配置文件/usr/local/nginx/conf/uwsgi.ini，详细内容如下：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n[uwsgi]\nsocket = 0.0.0.0:9000\nmaster = true\npidfile = /usr/local/nginx/uwsgi.pid\nprocesses = 8\nworkers = 2\nchdir = /data/www/demo\npythonpath = /data/www\nprofiler=true\nmemory-report=true\nenable-threads = true\nlogdate=true\nlimit-as=6048\ndaemonize=/data/logs/django.log\n</textarea><br/>---关键参数及说明---<br/>1）chdir 指定项目目录；<br/>2）pythonpath 指定项目目录上一级<br/>3）processes 指定进程数<br/>4）workers 分配CPU的核数<br/>5）limit-as 子进程分配的内存大小<br/>6）max-requests 分配最大的请求数<br/><br/>&#160;&#160;&#160;&#160;启动uwsgi与nginx服务，建议配置成服务自启动脚本，便于后续的日常维护。详细启动脚本这里不展开说明，有兴趣的读者可参阅互联网上已经存在的相关资源。<br/>&#160;&#160;&#160;&#160;最后启动uwsgi与nginx服务<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# /usr/bin/uwsgi --ini /usr/local/nginx/conf/uwsgi.ini\n# /usr/local/nginx/sbin/nginx\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;访问http://demo.domain.com，出现如图所示的页面说明Django+uwsgi环境部署成功！<br/><a href=\"https://blog.liuts.com/attachment.php?fid=364\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=364\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/><strong>二、OMServer项目部署</strong><br/>1、修改Nginx配置<br/>添加OMServer项目站点配置，[server]域具体内容如下：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n&#160;&#160;&#160;&#160;server &#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;listen 80;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;server_name omserver.domain.com;\n\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;location / &#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;uwsgi_pass 127.0.0.1:9001;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;include uwsgi_params;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;uwsgi_param UWSGI_CHDIR&#160;&#160;/data/www/OMserverweb;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;uwsgi_param UWSGI_SCRIPT django_wsgi;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;access_log off;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#125;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;location ^~ /static &#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root /data/www/OMserverweb;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#125;\n\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;location ~* ^.+&#92;.(mpg&#124;avi&#124;mp3&#124;swf&#124;zip&#124;tgz&#124;gz&#124;rar&#124;bz2&#124;doc&#124;xls&#124;exe&#124;ppt&#124;txt&#124;tar&#124;mid&#124;midi&#124;wav&#124;rtf&#124;mpeg)$ &#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root /data/www/OMserverweb/static;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;access_log off;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#125;\n&#160;&#160;&#160;&#160;&#125;\n</textarea><br/><span style=\"color: #DC143C;\"><br/>&#160;&#160;1）切记修改UWSGI_SCRIPT为django_wsgi;<br/>&#160;&#160;2）监听uwsgi端口修改成127.0.0.1:9001;&#160;&#160;&#160;&#160;#多个站点使用不同端口区分<br/></span><br/><br/>2、添加omserver项目uwsgi配置<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# cd /usr/local/nginx/conf\n# vi uwsgi_omserver.ini\n[uwsgi]\nsocket = 0.0.0.0:9001\nmaster = true\npidfile = /usr/local/nginx/uwsgi_omserver.pid\nprocesses = 8\nchdir = /data/www/OMserverweb\npythonpath = /data/www\nprofiler=true\nmemory-report=true\nenable-threads = true\nlogdate=true\nlimit-as=6048\ndaemonize=/data/logs/django_omserver.log\n</textarea><br/>3、项目源码配置<br/>&#160;&#160;1）项目源码：<br/>&#160;&#160;&#160;&#160;# cd /data/www<br/>&#160;&#160;&#160;&#160;下载地址：https://github.com/yorkoliu/pyauto/tree/master/第十三章/OMserverweb<br/>&#160;&#160;2）导入数据库结构(Mysql)<br/>&#160;&#160;&#160;&#160;下载地址：https://github.com/yorkoliu/pyauto/blob/master/第十三章/SQL/OMServer.sql<br/>&#160;&#160;3）修改setting.py（数据库信息）<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\nDATABASES = &#123;\n&#160;&#160;&#160;&#160;'default': &#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;'ENGINE': 'django.db.backends.mysql', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;'NAME': 'OMServer',&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# Or path to database file if using sqlite3.\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;'USER': 'omserver_user',&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# Not used with sqlite3.\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;'PASSWORD': 'J8w3jZXSG#y34',&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# Not used with sqlite3.\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;'HOST': '192.168.1.10',&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# Set to empty string for localhost. Not used with sqlite3.\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;'PORT': '3306',&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# Set to empty string for default. Not used with sqlite3.\n&#160;&#160;&#160;&#160;&#125;\n&#125;\n</textarea><br/>&#160;&#160; 4）修改主控端rpyc主机IP<br/>&#160;&#160;&#160;&#160;OMserverweb/autoadmin/views.py<br/>&#160;&#160;&#160;&#160;<textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\n&#160;&#160;&#160;&#160;... ...\n&#160;&#160;&#160;&#160;try:\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;conn=rpyc.connect('192.168.1.20',11511)&#160;&#160;&#160;&#160;#修改此处的rpyc主机地址；\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;conn.root.login('OMuser','KJS23o4ij09gHF734iuhsdfhkGYSihoiwhj38u4h')\n&#160;&#160;&#160;&#160;except Exception,e:\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;logger.error('connect rpyc server error:'+str(e))\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return HttpResponse('connect rpyc server error:'+str(e))\n&#160;&#160;&#160;&#160;... ...\n&#160;&#160;&#160;&#160;</textarea><br/>启动项目uwsgi及Nginx服务<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# /usr/bin/uwsgi --ini /usr/local/nginx/conf/uwsgi_omserver.ini\n# killall -9 nginx\n# /usr/local/nginx/sbin/nginx\n</textarea><br/>4、访问http://omserver.domain.com，出现以下系统界面说明部署成功！<br/><a href=\"https://blog.liuts.com/attachment.php?fid=365\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=365\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/>下一步配置<a href=\"http://blog.liuts.com/post/246/\" target=\"_blank\">《python自动化运维：技术与最佳实践》之OMServer平台环境部署详解【主控制端】</a><br/><br/>补：平台涉及开源组件包下载：<br/>Django-1.4.9.tar.gz <a href=\"http://blog.liuts.com/Django/Django-1.4.9.tar.gz\" target=\"_blank\">下载</a><br/>uwsgi-2.0.4.tar.gz <a href=\"http://blog.liuts.com/Django/uwsgi-2.0.4.tar.gz\" target=\"_blank\">下载</a><br/>rpyc-3.2.3.tar.gz <a href=\"http://blog.liuts.com/Django/rpyc-3.2.3.tar.gz\" target=\"_blank\">下载</a><br/>pcre-8.34.tar.gz <a href=\"http://blog.liuts.com/Django/pcre-8.34.tar.gz\" target=\"_blank\">下载</a><br/>nginx-1.5.9.tar.gz <a href=\"http://blog.liuts.com/Django/nginx-1.5.9.tar.gz\" target=\"_blank\">下载</a><br/>MySQL-python-1.2.5.zip <a href=\"http://blog.liuts.com/Django/MySQL-python-1.2.5.zip\" target=\"_blank\">下载</a><br/>django-debug-toolbar-master.tar.gz <a href=\"http://blog.liuts.com/Django/django-debug-toolbar-master.tar.gz\" target=\"_blank\">下载</a><br/>Tags - <a href=\"https://blog.liuts.com/tags/omserver/\" rel=\"tag\">omserver</a> , <a href=\"https://blog.liuts.com/tags/django%25E7%258E%25AF%25E5%25A2%2583/\" rel=\"tag\">django环境</a> , <a href=\"https://blog.liuts.com/tags/python%25E8%25BF%2590%25E7%25BB%25B4%25E8%2587%25AA%25E5%258A%25A8%25E5%258C%2596/\" rel=\"tag\">python运维自动化</a>\n\n","descriptionType":"text/html","publishedDate":"Sun, 07 Dec 2014 05:11:55 +0000","feedId":10777,"bgimg":"https://blog.liuts.com/attachment.php?fid=364","linkMd5":"a7bf600c1068b113ac9836f9e8942384","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn19@2020_2/2020/08/25/01-05-02-877_7c6d4a5b3411d8fe.webp","destWidth":960,"destHeight":208,"sourceBytes":105970,"destBytes":22396,"author":"刘天斯 <liutiansi@gmail.com>","articleImgCdnMap":{"https://blog.liuts.com/attachment.php?fid=364":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn19@2020_2/2020/08/25/01-05-02-877_7c6d4a5b3411d8fe.webp","https://blog.liuts.com/attachment.php?fid=365":null},"publishedOrCreatedDate":1598317495137},{"createdTime":"2020-08-25 09:04:55","updatedTime":"2020-08-25 09:04:55","title":"从天涯到腾讯：10年，不苟且的运维之路","link":"https://blog.liuts.com/post/250/","description":"\n \n\t<strong>导言</strong><br/>最近比较关注大数据、云计算、Docker、DevOps等几个方向，一会也简单围绕这几点跟大家做个交流。<br/>聊运维人生这个主题有点大，^_^就先从个人怎么入运维这行说起吧。<br/><br/><strong>人在天涯</strong><br/>2003年毕业后的第一份工作是当php、java程序员，人力紧张时还要兼顾美工设计的工作。<br/>工作中一次偶然的机会看到导师在黑压压的界面中敲入不同指令，第一感觉非常震撼，很COOL，联想到《黑客帝国》电影中的画面，与之前接触到的Windows系统完全不一样，后来才晓得是Redhat9（红帽9）。此时还是一名普通码农。<br/>2005年的10月，进入第二个东家-天涯社区，人生的第一个转折点在此酝酿。<br/>由于赶上了公司快速发展的阶段，接触到了很多开源技术，包括LVS、Squid、Haproxy、MongoDB、Mysql、Cfengine等等，也不断应用在生产环境，取得了非常不错的效果，重点业务的高可用持续保持在99.99%。<br/><br/><strong>如何高效运营？</strong><br/>随之新的问题也陆续出现，包括如何更好整合各类开源组件，发挥其最大效能，另一个是如何高效运营。不可否认，具有开发背景的运维人员有着先天性的优势，可以在不同角色之间进行思考，视野被放大。<br/>事实上在天涯6年就做一件事，即主导并实施天涯社区从Windows技术路线往开源架构改造，驱动这个事情有两原因，一个是运营管理成本、另一个是正版化给企业带来的高额成本（视窗+Sqlserver License）。<br/>改造最大难点是没有可参考及借签的对象，文档资料不全。完全依靠原有人员的技术储备，不断摸索。经过“试错 -> 失败 -> 回滚 -> 再尝试”的过程，个人能力在此期间也得到了一次升华。<br/>对Linux环境下的C++做了深入的研究学习，具备这样的知识对开源软件的架构、分层理解及故障定位有很大的帮助。改造后的天涯新架构在当时比较具有代表性且通用。<br/><br/>架构图如下：<br/><a href=\"https://blog.liuts.com/attachment/201605/1463409409_27114a47.png\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment/201605/1463409409_27114a47.png\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\" width=\"900\"/></a><br/><br/>2010年天涯IT管理架构<br/><a href=\"https://blog.liuts.com/attachment/201605/1463409409_8588fb5c.png\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment/201605/1463409409_8588fb5c.png\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/>天涯期间的开源项目<br/><a href=\"https://blog.liuts.com/attachment/201605/1463409409_108210fb.png\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment/201605/1463409409_108210fb.png\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>取之开源，同样也回馈开源，以下为个人在天涯期间的开源项目，其中开源后的“LVS管理平台”第一时间被国内某证卷公司采用，当时感觉很有成就感。<br/>比较有意思的“服务器机柜模拟图平台”项目，不少公司在此基础上陆续出升级版本，平台截图如下：<br/><a href=\"https://blog.liuts.com/attachment/201605/1463409409_541109dd.png\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment/201605/1463409409_541109dd.png\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>可以通过下面网址，访问在线版本<br/>https://blog.liuts.com/idc/<br/><br/>后面也将内部的运维管理平台原型做了开源，同时也在《Python自动化运维实践》书籍中做了介绍，下面为OMServer平台截图<br/><a href=\"https://blog.liuts.com/attachment/201605/1463409409_6886032b.jpg\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment/201605/1463409409_6886032b.jpg\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>源码托管在:<br/>http://github.com/yorkoliu/pyauto<br/><br/>小经验：<br/>05年开始写博客，当时目的比较单纯，即当笔记本来用，后来慢慢演变成交流沟通的平台，收到很多同行的评论、邮件，也认识了很多业界大牛，很多好友到现在还保持联系。<br/><br/>坚持写博客是一件非常困难的事。但在荣获了2010年度《十大杰出IT博客》的同时，也让我领悟到每写一篇博客其实就是个人对工作、生活的一次总结。不但可以锻炼你的语言组织、逻辑思维、表达等能力，还可以给你增加人气，提升个人影响力 ^_^。<br/><br/><strong>腾讯CDN运维之旅</strong><br/>2011年加盟腾讯，主要负责了腾讯静态、下载类的CDN运维，截止当前已有400+加速节点（包括静态内容平台、游戏下载平台、UGC加速平台、流媒体平台、动态加速平台等），总带宽突破10Tb，覆盖了腾讯QQ、微信、QQ空间、腾讯视频等业务。<br/>流量调度主要通过GSLB来实现，部分业务基于httpDNS来实现。<br/>腾讯自建CDN除了强大的资源部署外，软实力方面做得非常不错，比如：协议栈优化TCP传输、DiskTank解决小文件读写瓶颈与碎片、链路实时调整等，其中链路实时调整依赖全网拓扑的实时测速的数据作为依据，调整事件是通过调用公司的GSLB接口进行刷新。<br/><br/>调度示意图如下：<br/><a href=\"https://blog.liuts.com/attachment/201605/1463409468_4178f19c.png\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment/201605/1463409468_4178f19c.png\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/>What happened?<br/><br/>运维期间碰到最头疼的问题还是小运营商的域名、内容劫持，表现形式为TTL、目标指向、内容劫持等几个方面。<br/><br/>Why?：运营这样做的初衷是什么？<br/><br/>减少运营商LDNS设备的性能负载；<br/>减少运营商跨网结算成本；<br/>嵌入捆绑广告营销策略等。<br/>How?：解决的一些思路，发现问题：<br/><br/>主动：遍历域名在所有运营商LDNS的解析结果，与公司的威权GSLB记录做比较，存在异常的解析可以立马被定位；<br/>被动：产品投拆、网友论坛反馈等渠道。目前还没有彻底解决问题的方案，原因是站在运营商的角度，适当的劫持是合理的，不过可以通过商务去推动解决（局部），关于内容劫持比较好的解决方案就是上HTTPS。<br/><br/><strong>腾讯数据运营大舞台</strong><br/><br/>2013 年至今负责腾讯游戏大数据运营体系的建设，支撑百余款游戏的数据接入、传输、ETL分析、大数据基础平台运维等工作，确保日7000亿条(50T)日志流水传输，以及日均10万次计算任务调度质量。<br/>在IT基础服务方面，利用Docker技术及DevOps理念，对游戏数据应用实施持续交付流程、服务弹性调度的落地，以及开发团队与运维团队融合制度的定制。<br/><br/>数据运营简介<br/><br/>当前腾讯游戏数据传输、存储规模：<br/><a href=\"https://blog.liuts.com/attachment/201605/1463409468_78029eb9.png\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment/201605/1463409468_78029eb9.png\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/>游戏大数据服务架构图：<br/><a href=\"https://blog.liuts.com/attachment/201605/1463409468_9025602e.png\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment/201605/1463409468_9025602e.png\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/>其中存储与计算都采用公司级的数据服务平台-TDW（基于Hadoop+Hive构建），传输采用自研的TDBank平台，类似于开源Flume+Kafka的技术方案。<br/>数据采集采用自研的Tglog方案，更轻量、传输效率更高，支持UDP及TCP版本，两个特点：<br/>耦和度低、标准开放接口、接入成本低；<br/>统一化数据运营标准协议XML、数据本地化容灾。<br/>Tglog简介：<br/><br/>也简单介绍下Tglog日志格式的定义吧，分两部分，一为日志描述，二为实体日志。<br/><br/>下图为日志格式描述文件（XML格式）：<br/><a href=\"https://blog.liuts.com/attachment/201605/1463409468_64727afb.png\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment/201605/1463409468_64727afb.png\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/>下图为采集原始日志格式（表名&#124;字段值1&#124;字段值2&#124;… …）：<br/><a href=\"https://blog.liuts.com/attachment/201605/1463409468_9670586e.png\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment/201605/1463409468_9670586e.png\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/>支撑数据应用-iData(腾讯智能化游戏数据分析平台)，提供了游戏生命周期管理，且每个环节都结合了数据挖掘算法，做到精准玩家触达，精细化运营的目的。<br/><a href=\"https://blog.liuts.com/attachment/201605/1463409484_186959b2.png\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment/201605/1463409484_186959b2.png\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/>运维支撑难点：<br/><br/>如何保障海量游戏日志的采集、传输质量达到99.999% 的SLA标准?<br/>需要从几个维度入手，包括元数据管理、数据地图、数据字典、血缘关系、数据对账、安全审计等。同时要确保与各类数据变更的强联动，感兴趣今后可以展开来讨论哈。<br/>二级数据分析集群我们采用Flume+Spark，调度使用Mesos来实现，同时也结合kubernetes来实现长服务组件的调度，有兴趣今后可展开讨论。<br/><br/><strong>我的DevOps观</strong><br/>Why DevOps?<br/>DevOps是开发者和运维之间的高度协同与融合，这个过程贯穿整个软件开发生命周期，从业务规划到创建、交付再到反馈。<br/>需要注意一点是，不仅仅包括是开发和运维团队，真正的 DevOps 方法需要业务部门、测试人员、企业高管、合作伙伴和供应商等配合完成。<br/>主流观点<br/>为什么要DevOps，国内认同度比较高的几个观点，更多可搜索老王分享过的一些文章。<br/><br/>改善团队协作；<br/>帮助控管风险、成本、减少浪费；<br/>提升软件品质；<br/>提高软件迭代速度。<br/>个人观点<br/>个人更趋向于IBM的诠释，即增强客户体验、提高创新能力、更快实现价值。<br/><br/>建立一种机制，从所交付软件应用的所有利益相关方快速获取反馈，利益相关方包括客户、业务部门、用户、供应商、合作伙伴等等；<br/>目标是减少浪费和返工，并将资源转移给价值更高的活动；<br/>将软件快速、高效和可靠地交付于生产的文化、实践和自动化，快速达成目标，实现价值。<br/>How?<br/>怎么去做DevOps？<br/>调整考核和激励机制；<br/>绑定开发、测试、运维，共同输出价值；<br/>全面自动化，减少人工干预；<br/>开展培训和组织开发活动；<br/>制定新体系结构标准。<br/>持续集成、交付、部署是一个非常好的切入点，DevOps全景图：<br/><a href=\"https://blog.liuts.com/attachment/201605/1463409484_33089eb6.png\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment/201605/1463409484_33089eb6.png\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\" width=\"900\"/></a><br/>So What is it?<br/>Devops就是:<br/><br/>CALMS - Culture（文化）<br/>Automation（自动化）<br/>Lean （Lean[精益]理论，其思想源于消除浪费）<br/>Measurement（量化）包括监控、指标、分析<br/>Sharing（分享）<br/>补充概念<br/>很多人会混淆持续交付(Continuous Delivery)、持续部署(Continuous Deployment)两个概念。<br/>简单说明下，持续交付并不是指软件每一个改动都要尽快的部署到产品环境中，它指的是任何的修改都已证明可以在任何时候实施部署，而持续部署是将所有通过了自动化测试的改动都自动的部署到产品环境里。<br/><br/>DEVOPS最终目标及原则方向：<br/><br/>运维要成为一等公民；<br/>让开发人员完成一切；<br/>谁构建，谁运行。<br/>经验点：<br/><br/>前期的沟通铺垫很重要，一定要了解公司内部利益相关方，包括开发负责人、运维主管、项目主管、产品负责人等的诉求及关注点，尽可能共同捆绑目标及输出价值，不同角色区别只在于分工。<br/>其次是让大老板了解DevOps的收益，且要得到老板的支持，因为DevOps落地是一项长期工作，不可能在短期内看到收益。<br/>量化的指标一定要清晰，且直观易懂，包括业务监控平台、分析报告，同时需要提供至少一种产品或用户反馈的途径，可以是产品官网、在线客服，这对提升平台的品质，直接影响产品口碑。这里直接使用了公司现有的非常完善的基础组件及渠道。<br/>持续集成、交付、部署，我们使用了SVN+Jenkins+Docker+应用商店（镜像）。<br/>第一期自动化部署我们采用了HECD架构实现，第二期计划是与蓝鲸平台打通，通过APP形式来实现从集成至部署的封环，很大程度提高了软件迭代的速度及频率，对提升软件品质及运维服务水平至关重要。<br/>此项工作一定要做好，这也是让相关利益方切身感受变化的关键一环。<br/><br/>小知识<br/>什么是HECD架构：构建一个高可用及自动发现的Docker基础架构-HECD<br/>https://blog.liuts.com/post/242/<br/><br/><strong>从业经验</strong><br/><br/>最后再简单分享个人在运维领域从业的两个小经验：<br/><br/>1、一步一个脚印，切忌一步到位。<br/>关于运维自动化这件事情，几乎所有的IT企业都在做，看似是一件非常好的事情，忽略了前提条件，往往付出更大的代价及运营成本。<br/>之前所提到的前提条件便是运维体系“标准化”、“流程化”、“规范化”的建设，覆盖企业中资源、版本、业务发布、监控、事件管理等环节。有了这些作为基础铺垫，运维自动化的建设才会很顺利实施，达成预期。<br/>自动化程度的高低很大程度是随公司所处不同发展阶段，不断去演变而来，不要想着去复制BAT的架构，一步到位是一个很大的误区。<br/><br/>2、运筹帷幄，主动耦合。<br/>对业务的生命周期进行管理，是运维扮演的角色。<br/>一个产品在规划之初运维人员须第一时间介入参与，根据产品特点，提供业务平台前期架构设计、资源评估等数据。<br/>当产品进入开发阶段，须与开发人员保持密切沟通与互动，提供业务接入、缓存、存储、监控、安全等方面规范，以便在编码阶段更好磨合与对接，避免上线后反复做不必要的版本迭代，也使得开发出来的产品具备更高的可运维性。<br/>待业务上线后，务必定期同步相关运营数据给产品与开发人员侧，为后续优化、改进的工作提供数据支持，这也恰恰能体现运维人员的专业性及团队合作意识。<br/><br/><strong>一个感悟</strong><br/><br/>运维体系中各个环节的工作犹如散落在地上的珠子，每个珠子分别代表事件、资源、监控、安全、自动化、日常工作等。<br/>看似是七零八落的，我们需要利用“流程”这条线将所有的珠子串起来。珠子的前后顺序及间隔由“标准规范”来控制。<br/>这样就形成了一条完整的链子，是一个有机的整体，最后会促使运维工作开展得井井有条。这条链子扣在三个点子上，就是“质量”、“效率”、“成本”。<br/><br/><strong>如何保持竞争力？</strong><br/><br/>很喜欢乔希·维茨金在《学习之道》书中一句名言：追求卓越的关键在于，要坚持充满活力，长期的学习过程，不再满足于原地踏步、平平庸庸。<br/>作为一名优秀的运维工程师，应该将学习成果与日常工作相结合，独立及深入思考发现的问题，善于发现不同问题之间的联系，并把它们升华为方法论，最后再做总结与传承。<br/>我的感悟：不断学习才是保持竞争力的唯一途径，不断思考和总结会成为你潜意识的行为；<br/>我的行动：坚持每天1~2小时的学习时间，从未停止。<br/><br/>那么问题来了：<br/>如学习的动力不源于兴趣或好奇心怎么办？<br/>这里跟大家分享我与团队小伙伴探讨的一个观点：<br/>首先应该静下心好好思考，自己5、10年后想过什么样的生活，可以预见的状态是上有老下有小、背着沉重的房贷、车贷。<br/>如此时再去与一个毕业生竞争同一工作岗位，必然会丧失了所有的优势与竞争力，被行业所淘汰只是时间问题。<br/>因此，想过衣食无忧生活，在职业发展过程中处于不败之地，那么，从现在开始就应该怀着空怀心态，不断打怪升级，使自己变得更加强大。<br/>引用萧帮主一分享主题：“危机前的自我拯救”，没有这个勇气或行动是否考虑该转行了？<br/><br/><strong>如何挖掘专利？</strong><br/><br/>再聊聊运维人员如何写专利，在很多人眼里，写专利是一件非常复杂且很难做到的事情，甚至会认为这是开发人员更擅长的领域。<br/>其实写专利并不像大家想象的那么遥远，只要是一个可以实现的方法或思路就能写成专利。比如运维平台当中的一个功能点、一个快速安全扫描的方法、一项容灾传输的技术、自动化测试案例思路、一种有效服务监控的手段等。这些点子都可以写成一个发明专利。<br/>当然，创新及新颖性非常重要，可以先对比现有的技术实现，突出该发明的优势及亮点，就可以开始写交底书了。<br/>如真的没有一点头绪，大家也可以参考个人写过的一些专利，访问中国专利局网，检索发明人：“刘天斯”<br/>http://www.pss-system.gov.cn/sipopublicsearch/search/searchHome-searchIndex.shtml <br/><br/><strong>一则小广告^_^：</strong><br/><a href=\"https://blog.liuts.com/attachment/201605/1463409484_21389414.jpg\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment/201605/1463409484_21389414.jpg\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>在个人著作《Python自动化运维：技术与最佳实践》中也分享一些运维自动化的实现方法与实践案例，供大家参考。<br/>另一著作《Docker深入详解》预计8月上市，敬请关注！谢谢大家的聆听。<br/><br/><strong>Q&A</strong><br/><br/>Q1：自行研发tglog对于海量日志传输是否主要走的udp协议？如果是走的udp协议，怎么去解决一些数据包传输中数据乱序以及数据反序列化问题，或者做了哪些协议层面的优化？<br/>A: 是的，主要走的是UDP协议。tglog同时也是一套数据日志的规范，约束开发人员打日志的标准。<br/>目前未碰到数据乱序以及数据反序列化问题，以前面临一个比较大的问题是丢包情况，尤其在流量高峰期时段更为明显。<br/>后面在内核、IO优化得到缓解，但无法规避，所以我们对比较重要的日志采用TCP传输。比如玩家消费流水。<br/><br/>Q2：规范化、标准化遇到最大问题是什么？我们遇到就是无法行政干涉开发如何写代码？有什么好的方式去引导规范？尤其是开发有很繁重的开发任务.<br/>A: 这已经不是运维层面推动的事情，必须升级到运维及开发的上层领导，开发任务繁重不是理由，上线后出问题一样得不偿失，提前抛出风险，让开发人员认真做好上线前的评估。<br/><br/>Q3：Docker化应用，是否面临胖容器还是瘦容器问题，即每个容器单进程还是多进程，你们这块是如何使用的？<br/>A: 这块没有统一的标准，看实际业务场景来决定，我们遵循一个原则是：最大化解耦。<br/>另外一个需要考虑的点：是否为原子调度单元。<br/>Tags - <a href=\"https://blog.liuts.com/tags/%25E5%2588%2598%25E5%25A4%25A9%25E6%2596%25AF/\" rel=\"tag\">刘天斯</a> , <a href=\"https://blog.liuts.com/tags/%25E8%25BF%2590%25E7%25BB%25B4/\" rel=\"tag\">运维</a> , <a href=\"https://blog.liuts.com/tags/%25E5%25A4%25A9%25E6%25B6%25AF/\" rel=\"tag\">天涯</a> , <a href=\"https://blog.liuts.com/tags/%25E8%2585%25BE%25E8%25AE%25AF/\" rel=\"tag\">腾讯</a> , <a href=\"https://blog.liuts.com/tags/devops/\" rel=\"tag\">devops</a> , <a href=\"https://blog.liuts.com/tags/%25E5%25A4%25A7%25E6%2595%25B0%25E6%258D%25AE/\" rel=\"tag\">大数据</a> , <a href=\"https://blog.liuts.com/tags/cdn/\" rel=\"tag\">cdn</a>\n\n","descriptionType":"text/html","publishedDate":"Tue, 17 May 2016 02:51:17 +0000","feedId":10777,"bgimg":"","linkMd5":"f401c182083f10370c108f306083fd94","bgimgJsdelivr":"","metaImg":"","author":"刘天斯 <liutiansi@gmail.com>","articleImgCdnMap":{"https://blog.liuts.com/attachment/201605/1463409409_27114a47.png":null,"https://blog.liuts.com/attachment/201605/1463409409_8588fb5c.png":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn84@2020_2/2020/08/25/01-07-53-265_717fec7726da0b97.webp","https://blog.liuts.com/attachment/201605/1463409409_108210fb.png":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn88@2020_1/2020/08/25/01-08-02-563_a6189b8f0d3d6fb7.webp","https://blog.liuts.com/attachment/201605/1463409409_541109dd.png":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn83@2020_4/2020/08/25/01-07-02-922_f9bbf90cd4c376ae.webp","https://blog.liuts.com/attachment/201605/1463409409_6886032b.jpg":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn100@2020_5/2020/08/25/01-07-12-505_d2e3d6fdb1243fee.webp","https://blog.liuts.com/attachment/201605/1463409468_4178f19c.png":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn7@2020_5/2020/08/25/01-07-17-422_5b1b57b5e61615c7.webp","https://blog.liuts.com/attachment/201605/1463409468_78029eb9.png":null,"https://blog.liuts.com/attachment/201605/1463409468_9025602e.png":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn4@2020_6/2020/08/25/01-07-12-583_d77cb02832e07d30.webp","https://blog.liuts.com/attachment/201605/1463409468_64727afb.png":null,"https://blog.liuts.com/attachment/201605/1463409468_9670586e.png":null,"https://blog.liuts.com/attachment/201605/1463409484_186959b2.png":null,"https://blog.liuts.com/attachment/201605/1463409484_33089eb6.png":null,"https://blog.liuts.com/attachment/201605/1463409484_21389414.jpg":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn95@2020_4/2020/08/25/01-08-02-683_d36fcee06e6f76bf.webp"},"publishedOrCreatedDate":1598317495134},{"createdTime":"2020-08-25 09:04:55","updatedTime":"2020-08-25 09:04:55","title":"专家视野  刘天斯：腾讯游戏大数据价值评估思路","link":"https://blog.liuts.com/post/253/","description":"\n \n\t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;近年来，数据成为资产逐渐成为行业共识。然而，相对于实物资产，企业对于数据资产的管理还处于非常原始的阶段，数据资产价值评估还存在很多问题和挑战。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;为进一步促进数据资产价值评估相关问题的研究交流，推动通用的数据价值评估机制建立，2018年10月15日上午，CCSA TC601大数据技术标准推进委员会在中国信通院召开“数据资产价值评估研讨会”。刘天斯进行了题目为《腾讯游戏大数据价值评估思路》的报告。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=413\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=413\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>Tags - <a href=\"https://blog.liuts.com/tags/%25E5%25A4%25A7%25E6%2595%25B0%25E6%258D%25AE/\" rel=\"tag\">大数据</a> , <a href=\"https://blog.liuts.com/tags/%25E8%25B5%2584%25E4%25BA%25A7%25E7%25AE%25A1%25E7%2590%2586/\" rel=\"tag\">资产管理</a> , <a href=\"https://blog.liuts.com/tags/%25E5%2585%2583%25E6%2595%25B0%25E6%258D%25AE/\" rel=\"tag\">元数据</a>\n\n","descriptionType":"text/html","publishedDate":"Tue, 29 Jan 2019 08:26:41 +0000","feedId":10777,"bgimg":"https://blog.liuts.com/attachment.php?fid=413","linkMd5":"269961617c9cb1d1b6bc18e9a8ef11a4","author":"刘天斯 <liutiansi@gmail.com>","articleImgCdnMap":{"https://blog.liuts.com/attachment.php?fid=413":null},"publishedOrCreatedDate":1598317495134},{"createdTime":"2020-08-25 09:04:55","updatedTime":"2020-08-25 09:04:55","title":"腾讯游戏大数据解密：DevOps持续改进之道-布道【原创】","link":"https://blog.liuts.com/post/252/","description":"\n \n\t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2016年12月3日，在深圳圣淘沙酒店，运维帮、云技术、Linux中国三大社区联合主办主办了运维世界大会OpsWorld，演讲内容全程无广告，只谈技术，受到了广大观众的一直好评。本文根据刘天斯老师演讲内容整理而成。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=398\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=398\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我分享的主题是“DevOps持续改进之道——布道”。我刚才已经做了简单的介绍，这里再罗嗦一下，我叫刘天斯，现在是在腾讯互动娱乐负责大数据的运营。在互联网行业已经从业了13年，也算是一个老鸟，之前在天涯，工作了6年多。PPT右侧是我的两本著作，第二本是关于Docker的，如果大家关注Docker，可以在网上购买这本书来看看。我个人最近关注的方向有自动化运维、云计算、大数据、Docker&#160;&#160;DevOps等。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=399\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=399\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这是我今天分享的大纲，总共分四大块，第一块是跟大家简单介绍一下我的DevOps观，第二点我会介绍我们布道平台在持续集成与交付这块是怎么做的。第三点会介绍布道在线服务运营能力。最后给大家做一个总结。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=400\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=400\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;可能大部分人都认为DevOps无非是基于文化+技术这两个点在企业里面落地，这是大部分人之前的思维，在2015年底举行的全球DevOps峰会上，Gartner把DevOps做了进一步的划分，在文化和技术后面又细化出了过程和人。DevOps并非目标，但它可帮助您实现目标，企业的目标是更快地交付价值，DevOps是辅助我们完成这样一个目标的手段。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DevOps产生的价值，我比较认同IBM给出的解释，总共有三点，第一，它认为这个会增强客户的体验。这是比较容易理解的，第二点是提高创新能力，这个不好理解，创新和它有什么关系呢？它的说法是这样的，通过DevOps去实践，通过精益的方法论去减少我们的浪费、返工，将我们现有的价值及精力投入到更有价值的事情，创新是其中的一个非常重要的点。第三个就是更快的实现价值。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DevOps应该是永无止境的，它是一个持续改进的过程，它没有终点，它的目的是对影响交付质量的对象进行持续的改进，包括我们的技术、流程、团队，甚至企业的文化等。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;那我们怎么去检验我们的软件交付过程是不是高效的？我个人总结了一个“短”五个“快”。短就是我们交付软件的开发周期要短，快就是排错、解决问题、测试、部署、反馈这个闭环一定要快，不知道大家认不认可这样的观点，一会儿我们可以讨论一下。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=401\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=401\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Gartner在去年底提出DevOps的模型，它分为四个点，除了文化、技术，它还延伸出了过程和人这两个角色。我们首先从【技术】来看，这里面加亮的部分是重点要关注的，一个是【基础设施即代码】，第二个是【一键安装程序构建，测试、部署】，第三个是【监控一切】，第四个是【连续监控】。在【过程】里面，我认为应该关注的是【持续集成】、【测序】、【交付】这几个方面，另外还要关注到【自动化的构建】，包括【自动化发布】。我觉得【失败总结】这一点是比较重要的，当我们过程失败之后，必须要知道失败在哪里，要进行总结。另外一个是一切都要工具化，一切都要版本化。除了代码以外，我们的脚本或者是配置文件都要通过版本化进行管理。在文化这部分，我认为比较重要的就是协作的文化，还有持续的改进，还有学习的文化，这三个都不难理解，但是我认为，这里面是不是还遗漏了一点？我觉得少了信息的共享、透明，我认为这是非常关键。为什么这个很重要？在我们内部定期都会组织相关的讨论会，去讨论我们项目中碰到的问题以及风险，这些都是需要关注的，另外一点就是IBM提出的一个概念，运维要“左移”，意思是运维要在开发的生命周期阶段提前介入。这样做有什么好处呢？好处是有助于运维的问题提前在开发阶段提前暴露，我认为这是非常关键的一点。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面简单介绍一下我们服务的背景，我们为谁服务，服务什么样的平台。大家看一下我们的规模，当前的数据量每天入库7600亿条日志，大概80T，占公司总存储的26%。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=402\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=402\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这是我们的服务精细化的场景，这个背景是怎么来的？因为我们已经具备了海量的游戏数据，我们也在思考，怎么通过数据去驱动我们做精细化的运营。这也是我们目前不断在思考的。DataMore是我们思考出来的一个解决方案，它目前包括三个层次，第一个是大数据H5应用，比如说我们经常看到朋友圈大家分享的自己玩游戏的对局信息，这些数据都是由我们这边提供的。第二个是场景化的标签服务，我们会针对不同玩家打标签，打完标签就通过我们的精细化触达平台，针对性的做一些触达和营销活动。第三个是应用产品，比如说我们的游戏助手、官网，甚至是游戏里面的个人中心，大家会看到自己在游戏中的状态、成长轨迹、对战信息等，这些都可以看到，这就是游戏业务典型的一个服务化的场景。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=403\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=403\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面再介绍一下我们的数据服务的架构，这个其实也没有太多的技术含量，基本上都是业界主流的能力，包括最左侧的游戏的数据源，它有两类，一类是游戏内的，一类是游戏外的。平台组件有三大块，一是数据接入，数据接入包括实时传输、离线传输，第二个是数据处理，包括实时计算引擎、离线引擎，第三个是数据储存，包括KV存储、DB存储、位图索引、HDFS等。我们的服务引擎这一块包括数据分析引擎、数据接口中心、运营规则引擎、用户触达中心，业务应用就是报表统计、数据分析、触达运营，总体来讲就是包括这样三块：数据采集、存储计算、应用落地。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=404\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=404\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这是我们的DataMore体系的技术架构，整个架构层次也比较简单，最上层是STGW，这是腾讯非常强大的一个负载均衡平台，再下面是二级代理。逻辑层我们现在有GoServer&#160;&#160;PHP Server。实时数据层用的都是业界主流数据库存储技术，比如TRedis、Hbase、Postgresql等。最低层是数据计算层，包括实时计算引擎、离线计算引擎。当前整个服务的PV大概是6.35亿，日发布变更15次，单次发布时间是10秒，也就是一个容器起启的时间。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面介绍一下今天的主角“布道”。布道是我们数据服务全流程解决方案，采用了DevOps的思想实现软件的快速迭代、快速试错，最终提升软件交付的质量和达到持续改进的目的。它有几个特点，第一个是基于腾讯蓝鲸PaaS平台快速构建。蓝鲸本身就是一个PaaS平台，我们基于蓝鲸之上构建服务层的SaaS，本身布道就是基于最上层的SaaS服务。第二个是建立在DevOps的思想实践。我们这个实践思路来源于我刚才分享的Gartner发布的DevOps模型。各关键节点间之间的联系都是我们参考的样本。第三是面向运维、开发、测试、项目PM。第四个是具备持续集成、交付、部署等快速迭代的能力。第五是具备服务质量跟踪、用户舆情、持续反馈能力。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=405\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=405\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这是布道的能力体系，大家可以看一下，实际上包括两大块，一个是持续集成交付，另外一个是在线运营。其中服务质量和持续改进是贯穿整个服务生命周期。<a href=\"https://blog.liuts.com/attachment.php?fid=406\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=406\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这是布道服务层的架构，刚才提到了这一块，第一块持续集成&交付是采用业界主流的架构，且比较通用，我就不详细再讲了。我们的在线运营是基于HECD的架构，实现Docker的发现注册与发现，最上层就是我们的接入层，比较简单高效，因为没有太多其它逻辑关联耦合的节点。这里的TDocker是部门内部基于Docker构建的容器服务解决方案。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;以DevOps形成的运营服务闭环，它的内涵及核心就是实现持续改进。首先通过我们的CICD的快速通道，实现软件平台的快速迭代，在质量管理方面，我们通过监控、安全、故障自愈、BUG修复等方式进行质量管理。在用户反馈方面，我们建立一个通道，会收集并响应用户的反馈，包括来源于客服和对外网舆情的采集，会将这些信息反馈给开发人员，开发人员收到反馈之后，会在功能或者bug这一块做功能修复，最终就会形成一个持续改进的闭环，而且是一个良性的闭环。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=407\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=407\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;再简单介绍一下我们持续集成&交付的架构，刚才已经有提到，这里就简单说一下里面的几点细节。首先采用Docker架构具有一些优势，它可以保持跨环境一致性，天然易移植性，还有易于版本控制。然后CI&CD在流程方面做到编译并构建版本镜像，推送镜像仓库，触发交付作业并快速实现预览。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;以上介绍的是行业的主流做法，各家的方案都是大同小异的，我们在这个过程中加入了一些独特的东西，一个是代码扫描的工具coverity，它能够发现比较深层次代码逻辑问题，比如内存泄露、溢出、数组越界、未初始化等等，且目前支持的语言也比较多。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;另外一个是通过引入外网的流量，帮助我们实现压测，甚至做到一定BUG定位，它能达到百分之百的仿真的效果，具体的细节大家简单看一下PPT，整个步骤也非常简单，不是很复杂，它的特点是可以达到真实的模拟测试验证，有助于提前发现问题，有效降低发布风险。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=408\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=408\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这是一个案例，开发人员提交他的版本，然后进行预发布，在预发布里面有预览校验软件功能，也可引入外部的流量来进行预览，出现BUG会这个过程中被发现。我们在实践过程中碰到几点问题，在这里也跟大家一起分享。第一点是在容器中做源码的编译合不合理，不知道大家是怎么做的，我们给的结论是不合理。每个项目它用的第三方包或者功能组件是不一样的，可能A项目用的是A、B、C组件，B项目用的是1、2、3组件，不同的组件你在编译的时候去部署它的编译环境，这样会使我们的容器越来越臃肿，所以我们把这个环境迁移到另外一种角色（jenkinsslave），让它做源码的编译，编译完了就打包成镜像，保证镜像中没有太多无用的数据文件。第二点是容器性能的监控最优方案。我们使用Docker的时候有没发现一个问题?在容器中无论我们执行free、top、uptime、vmstat等命令，看到的都是主宿机的性能信息，原因是由于Docker的隔离性做得不够彻底导致。我们可以通过LXCFS这个组件帮助我们增强Docker的隔离性，它可以提供一个虚拟的PROC文件系统，另外也提供了容器自身的Cgroup的目录树，跟容器中的PORC目录是一一对应的。如何使用？我们Dockerrun的时候，通过“-v”参数，实现容器proc文件与Lxcfsproc的映射，效果是容器中看到的只是容器本身的内存、CPU等信息。比如说我们看CPU核数，看到的只是分配好的0、1、2、4的核数。第三点是容器在CI阶段的网络选择。这里只是给个建议，我们生产环境Tdocker使用的网络模型SRIOV，是通过硬件虚拟网卡的方式实现，然后Docker再通过IPlink做映射，但是我们在CI阶段，它是一个隔离的开发专区，它跟普通的IDC是不一样的，由于硬性相对比较老久，硬件虚拟化兼容性差，因此我们使用了Docker Macvlan方案，原理是通过创建网卡子接口与容器接口之间做映射，缺点是要求Linux Kernel 3.10.0及Docker>=1.12.0的环境。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这是我们的线上服务。项目上线的时候，每个PM都有一个习惯，都会最大化去的申请资源，在极端情况下还会远远超过他的预估值，这个时候怎么办？只需要评估扩容的需求量为多少，什么样的机型配置，提交Tdocker在线扩容就可以了，后面的事情就交给布道去处理。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=409\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=409\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在告警方面我也分享一些思路，在腾讯已经有一套非常成熟的告警系统，我们在这里只是提供一些跟我们业务逻辑相关的策略，我们的思路首先是统一日志规范，每个人的开发水平和习惯都不一样，我们给他们统一一个规范，这个规范叫Tlog，另外引入基础+特性这两个指标。看到的这个DEMO，它通过XML的模式描述日志的结构。特性是跟业务绑定相关的，我这里有一些服务，这个服务我发了一些金币，发到某个区间可能出现问题了，我们就需要开发人员把这个发放的数值打印出来，我们好做一个曲线的跟踪。采集完之后就会进入一个日志采集环节，这个架构也很简单，就是LVS+Keepalive，采集完之后，这里就分两条线，一个是实时，一个是离线的。我们采用的是蓝鲸的实时数据平台，能够实现特性指标多维度的配置。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这是蓝鲸的智能监控的界面。它是实时流，内部用的是Storm做实时分析，然后支持定义灵活的配置，有支持SQL的函数，比如支持某个字段的累加、求和，这个频率可以控制为10分钟、15分钟。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=410\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=410\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面是我们安全这一块做的东西，首先是安全防御，在腾讯内部，安全这一块已经做得非常强悍，为什么我还讲安全呢？因为在公司层面做的安全防护更多是通用性或者基础类的防护，WAF更侧重在业务逻辑层，它的架构非常简单，通过布道做一些规则的下发到WAF，例如XSS、CC、UA、URI的规则等等，然后开启日志追踪，通过传输、实时分析防护日志，最终做到防护报告实时展示。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;规则校验步骤与大家简单介绍一下，目前采用Nginx+LUA结合的方式，它的防护流程是在检查端口及域名是否匹配规则，匹配就下发规则，然后检查黑白IP名单，后面再开启CC防护，以及开启userAgent检查，最后是开启URI检查注入、XSS、SSRF等。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;下面是舆情监控这一块，我们在这里特点就是关键词的实时监控、定时报送推送。从下面这个图可以看到，某一款游戏在某此活动期间的口碑展示情况，有多少是正面的，有多少是负面的报告。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=411\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=411\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最后做一个总结，在线运营的运营经验，第一个是资源评估，我们要定一个标准，根据实际服务场景来做出评估，而不是拍脑袋做。这个评估有一个公式：设计数量=（PV/86400）×2/单机承载最大QPS/0.8。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;第二个是灰度+热力度对蓝绿发布。蓝绿发布的目的是让我们的用户没有感知，我们做蓝绿发布，操作的步骤很多，一旦人工接触多了，就容易出现误操作。我们采用的是热更新方式，原理是服务A进程收到关闭信号量之后，启动B进程来接收已经创建的连接或新连接，当A进程连接完全释放之后就会自动关闭，整个过程用户无感知。灰度实际就是放量检验这个效果及功能，如中间没有出现问题，只需两步就完成变更。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;第三个是修复了Supervisor一个bug。Supervisor没办法对进程fork子进程进行管理，所以我们修复了这个bug，如大家碰到同样的问题可以私下找我，我会给大家具体的解决方法。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最后是一个数据流向监控的实现思路。首先简单介绍一下为什么要做这个流向监控。数据的流向监控在业界目前没有较好的方案，当我们的数据链、处理链、服务链拉得很长的时候，如何感知当数据源头有发生变更或异常，影响到我们的最终服务，这是非常难度的，而且它跟我们的业务特点关系非常大。同样我们逆向推导也是成立的，我发现玩家的某个对局数据不对，本来是胜局结果变成了负局，怎么确认数据是从哪个节点负责计算或存储的？这个非常有挑战性，这需要我们的数据服务能力一步一步做叠加，需要不断做扩展与关联，才能够达到某一个层次的服务水平。目前我们做的还没那么完美。首先我们要具备元数据管理，还有元信息的管理，这是非常重要的两层。第二个是要有数据字典管理，我们给数据表名称、字段说明，结构性的定义及标签。第三个就是血缘关系，能够定义到任务之间的关系。第四个是数据服务的注册，这是比较核心的一点，怎么注册，我们怎么知道你用了哪个数据源呢？这很关键，我们内部开发了一个通用组件，比如说你要引用后端的数据层，你必须使用这个组件接入，这样关系才能够建立起来，所以应用配置文件也是单独生成的。而最上游我们会提供一个数据流向查询，我们用了A数据，查下来就知道它在这个过程经过了哪些关键点，有可能是存储、计算、分析、接口等。<a href=\"https://blog.liuts.com/attachment.php?fid=412\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=412\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;最后快速做一个总结，这是我们的持续服务的体系，在持续运营状态下，我们具备质量监控、舆情监控、容量管理、安全管理、故障治愈、故障修复等能力，同时收集用户服务体验、产品、BUG、新功能、吐槽点，将这些信息反馈给产品人员、开发人员和运维人员。再通过持续集成交付、发布变更管理，做到快速迭代及部署，最后就形成了良性的、持续改进的闭环。 <br/><br/>1、【提问】：你刚才提到了资源分配的公式，你们那个公式是怎么总结出来的？那个公式的基础是以什么样的结果作为标准的？<br/>【刘天斯】：这个公式也不是我们发明的，也是借鉴了很多前辈思路，我们只是在这个基础上做改进，结合我们自己的业务场景，包括我们服务是什么样的类型，因为服务类型不同，它的要求不一样，配置不一样，它的生命周期也不一样，它能够反映出来的效果和能力、访问量都不一样，比如服务到底是CPU型还是内存或IO型，完全不一样。这就带来一个问题，我们怎么定一个标准？我们目前聚焦在接入这块的逻辑层，供参考的是8核、4G内存，硬盘100到150G的配置。<br/><br/>2、【提问】：我是来自创维公司负责运维的。今天讲的是DevOps，DevOps要快速迭代到什么样的程度才行？像您现在做的一个平台一天发布15次，我不知道你在前面需要进行多长时间的准备？比如说线上的实时导流导多长时间是合适的？这个度我们一直拿捏不准，能帮我们解答一下，提点好的建议吗？【刘天斯】：在互联网行业我们大部分都是采用敏捷开发的模式，这样会产生技术的债务，这是必然的。你是传统行业吗？<br/>【提问】：我们前身是传统行业，现在我们是互联网电视，相当于做电视上的服务，我们是非常快捷的，每天都发布，每天改bug，不停地迭代，而且需求也特别多，开发也忙不过来，我们运维也感觉到准备不足。<br/>【刘天斯】：互联网这种快速发展的模式，势必会带来很多技术的债务，我觉得这是正常的。我们的互联网发展很快，必须要先要有一个雏形产品出来，然后再不断地迭代，这是大部分互联网公司或者是刚刚转型公司采用的模式，这种模式出现的问题我认为是很正常的问题，包括在腾讯也一样有这样的问题，他评估不到我在某个阶段要花多长时间去检验我们是否够快、是否高效。我们在布道这个环节下一步就是预发布，预发布追求的并不是快，而是能不能在临门一脚之前发现一些致命的问题，因此，可以在持续交付阶段追求快，而不应在预发布阶段。<br/>Tags - <a href=\"https://blog.liuts.com/tags/%25E5%25A4%25A7%25E6%2595%25B0%25E6%258D%25AE/\" rel=\"tag\">大数据</a> , <a href=\"https://blog.liuts.com/tags/%25E5%25B8%2583%25E9%2581%2593/\" rel=\"tag\">布道</a> , <a href=\"https://blog.liuts.com/tags/%25E5%2588%2598%25E5%25A4%25A9%25E6%2596%25AF/\" rel=\"tag\">刘天斯</a>\n\n","descriptionType":"text/html","publishedDate":"Mon, 19 Dec 2016 13:45:08 +0000","feedId":10777,"bgimg":"https://blog.liuts.com/attachment.php?fid=398","linkMd5":"02d2450ac03ced4daf17a745547032e4","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn3@2020_4/2020/08/25/01-05-06-064_f69404c6130778aa.webp","destWidth":640,"destHeight":417,"sourceBytes":211260,"destBytes":19808,"author":"刘天斯 <liutiansi@gmail.com>","articleImgCdnMap":{"https://blog.liuts.com/attachment.php?fid=398":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn3@2020_4/2020/08/25/01-05-06-064_f69404c6130778aa.webp","https://blog.liuts.com/attachment.php?fid=399":null,"https://blog.liuts.com/attachment.php?fid=400":null,"https://blog.liuts.com/attachment.php?fid=401":null,"https://blog.liuts.com/attachment.php?fid=402":null,"https://blog.liuts.com/attachment.php?fid=403":null,"https://blog.liuts.com/attachment.php?fid=404":null,"https://blog.liuts.com/attachment.php?fid=405":null,"https://blog.liuts.com/attachment.php?fid=406":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn59@2020_5/2020/08/25/01-08-12-242_f8a272c9fafd3616.webp","https://blog.liuts.com/attachment.php?fid=407":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn64@2020_2/2020/08/25/01-07-06-550_7b0b7ef7047d9ef5.webp","https://blog.liuts.com/attachment.php?fid=408":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn75@2020_5/2020/08/25/01-07-12-653_ce10acbed53e9865.webp","https://blog.liuts.com/attachment.php?fid=409":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn80@2020_2/2020/08/25/01-07-15-430_313739c61fb81eac.webp","https://blog.liuts.com/attachment.php?fid=410":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn12@2020_5/2020/08/25/01-07-06-939_5d55249d08e36a2d.webp","https://blog.liuts.com/attachment.php?fid=411":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn24@2020_6/2020/08/25/01-07-10-608_57d29507c4c3d590.webp","https://blog.liuts.com/attachment.php?fid=412":"https://cdn.jsdelivr.net/gh/myreaderx/cdn28@2020_1/2020/08/25/01-07-08-772_cebea431feccc2c8.webp"},"publishedOrCreatedDate":1598317495135},{"createdTime":"2020-08-25 09:04:55","updatedTime":"2020-08-25 09:04:55","title":"基于Django与Celery实现异步对列任务","link":"https://blog.liuts.com/post/248/","description":"\n \n\t&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在运营系统中经常用到异步方式来处理我们的任务，比如将业务上线流程串成任务再写入队列，通过后台作业节点去调度执行。比较典型的案例为腾讯的蓝鲸、织云、云智慧等平台。本译文结合Django+Celery+Redis实现一个定期从Flickr 获取图片并展示的简单案例，方便大家理解实现异步对列任务的过程。<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;刚接触django的时候，我经历过的最让人沮丧的事情是需要定期运行一段代码。我写了一个需要每天上午12点执行一个动作的不错的函数。很简单是不是？错了。事实证明，这对我来说是一个巨大的困难点，因为，那时我使用Cpane类型的虚拟主机管理系统，它能专门提供一个很友好，很方便的图形用户界面来设置cron作业。<br/>&#160;&#160;&#160;&#160;&#160;&#160; 经过反复研究，我发现了一个很好的解决方案 - Celery，一个用于在后台运行任务的强大的异步作业队列。但是，这也导致了其它的问题，因为我无法找到一系列简单的指令将celery集成到Django项目中。<br/>&#160;&#160;&#160;&#160;&#160;&#160; 当然，我最终还是设法成功搞定了它 - 这正是本文将介绍的内容：如何将celery集成到一个Django项目，创建周期性任务。<br/>&#160;&#160;&#160;&#160;&#160;&#160; 该项目利用Python3.4，Django的1.8.2，celery3.1.18和Redis3.0.2.<br/><br/><strong>一、概述</strong><br/>&#160;&#160;&#160;&#160;&#160;&#160; 由于大篇幅的文字，为了您的方便，请参阅下表中的每一步的简要信息，并获取相关的代码。<br/>步骤&#160;&#160;&#160;&#160;&#160;&#160;概要&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Git标签<br/>样板&#160;&#160;&#160;&#160;&#160;&#160;样板下载&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a href=\"https://github.com/realpython/Picha/releases/tag/v1\" target=\"_blank\">V1</a><br/>建立&#160;&#160;&#160;&#160;&#160;&#160;集成Celery和Django&#160;&#160;&#160;&#160;&#160;&#160;<a href=\"https://github.com/realpython/Picha/releases/tag/v2\" target=\"_blank\">V2</a><br/>Celery任务&#160;&#160;&#160;&#160;添加基本的Celery任务&#160;&#160;&#160;&#160;<a href=\"https://github.com/realpython/Picha/releases/tag/v3\" target=\"_blank\">V3</a><br/>周期性任务&#160;&#160;&#160;&#160;添加周期性任务&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a href=\"https://github.com/realpython/Picha/releases/tag/v4\" target=\"_blank\">V4</a><br/>本地运行&#160;&#160;&#160;&#160;本地运行我们的应用程序&#160;&#160;&#160;&#160;<a href=\"https://github.com/realpython/Picha/releases/tag/v5\" target=\"_blank\">V5</a><br/>远程运行&#160;&#160;&#160;&#160;远程运行我们的应用程序&#160;&#160;&#160;&#160;<a href=\"https://github.com/realpython/Picha/releases/tag/v5\" target=\"_blank\">V5</a><br/><br/><strong>二、什么是Celery</strong><br/>&#160;&#160;&#160;&#160;&#160;&#160; “Celery是一个异步任务队列/基于分布式消息传递的作业队列。它侧重于实时操作，但对调度的支持也很好。”本文，我们将重点讲解周期性执行任务的调度特点。<br/>&#160;&#160;&#160;&#160;&#160;&#160; 为什么这一点有用呢？<br/>&#160;&#160;&#160;&#160;&#160;&#160;•回想一下你不得不在将来运行某一特定任务的经历。也许你需要每隔一小时访问一个API。或者，也许你需要在这一天结束时发送一批电子邮件。不论任务大小，Celery都可以使得调度周期性任务变的很容易。<br/>&#160;&#160;&#160;&#160;&#160;&#160;•你永远不希望终端用户等待那些不必要的页面加载或动作执行完成。如果你的应用程序工作流的一部分是一个需要很长时间的程序，当资源可用时，你就可以使用Celery在后台执行这段程序，从而使你的应用程序可以继续响应客户端的请求。这样可以使任务在应用程序的环境之外运行。<br/><br/><strong>三、构建项目</strong><br/>&#160;&#160;&#160;&#160;&#160;&#160; 在深入了解Celery之前，先从Github库中获取开始项目。确保激活一个虚拟的环境，安装必要的软件，并运行迁移。然后启动服务器，通过你的浏览器导航到http://localhost:8000/。你应当能看到‘恭喜你的第一个Django页面’。完成后，关闭服务器。<br/>&#160;&#160;&#160;&#160;&#160;&#160; 接下来，我们开始安装celery。<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n$ pip install celery==3.1.18\n$ pip freeze > requirements.txt\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 现在，我们通过简单的三步将celery集成到django项目中。<br/><strong>步骤一：创建celery.py</strong><br/>在“picha“目录下，创建celery.py，代码如下：<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\nfrom __future__ import absolute_import\nimport os\nfrom celery import Celery\nfrom django.conf import settings\n\n# set the default Django settings module for the 'celery' program.\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'picha.settings')\napp = Celery('picha')\n\n# Using a string here means the worker will not have to\n# pickle the object when using Windows.\napp.config_from_object('django.conf:settings')\napp.autodiscover_tasks(lambda: settings.INSTALLED_APPS)\n\n\n@app.task(bind=True)\ndef debug_task(self):\n&#160;&#160;&#160;&#160;print('Request: &#123;0!r&#125;'.format(self.request))\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 请注意代码中的注释。<br/><strong>步骤二：引入celery应用</strong><br/>为了确保在django启动时加载了celery应用，在settings.py旁边新建__init__.py，并添加以下代码到__init__.py中。<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\nfrom __future__ import absolute_import\n\n# This will make sure the app is always imported when\n# Django starts so that shared_task will use this app.\nfrom .celery import app as celery_app\n</textarea><br/>完成以上步骤后，你的项目目录应该是这样的：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n├── manage.py\n├── picha\n│&#160;&#160; ├── __init__.py\n│&#160;&#160; ├── celery.py\n│&#160;&#160; ├── settings.py\n│&#160;&#160; ├── urls.py\n│&#160;&#160; └── wsgi.py\n└── requirements.txt\n</textarea><br/><strong>步骤三：安装 Redis作为Celery的“中间件”</strong><br/>&#160;&#160;&#160;&#160;Celery使用中间件在django项目与celery监控者之间传递消息。在本教程中，我们使用redis作为消息中间代理。<br/>首先，从官方下载页面或通过brew（BREW安装Redis）安装Redis，然后打开你的终端上，在一个新的终端窗口，启动服务器：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n$ redis-server\n</textarea><br/>你可以通过在终端中输入如下命令测试Redis是否正常工作。<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n$ redis-cli ping\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; Redis应该回复PONG - 试试吧！<br/>&#160;&#160;&#160;&#160;&#160;&#160; 一旦Redis正常启动了，把下面的代码添加到你的settings.py文件中：<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\n# CELERY STUFF\nBROKER_URL = 'redis://localhost:6379'\nCELERY_RESULT_BACKEND = 'redis://localhost:6379'\nCELERY_ACCEPT_CONTENT = ['application/json']\nCELERY_TASK_SERIALIZER = 'json'\nCELERY_RESULT_SERIALIZER = 'json'\nCELERY_TIMEZONE = 'Africa/Nairobi'\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 你还需要添加Redis的作为Django项目的依赖：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n$ pip install redis==2.10.3\n$ pip freeze > requirements.txt\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 就是这样了！你现在应该能够在Django中使用Celery。有关设置Celery与Django的更多信息，请查看官方Celery文档。<br/>在继续下面步骤之前，让我们进行一些完整性检查，以确保一切都是正常的。<br/>测试Celery worker已准备好接收任务：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n$ celery -A picha worker -l info\n...\n[2015-07-07 14:07:07,398: INFO/MainProcess] Connected to redis://localhost:6379//\n[2015-07-07 14:07:07,410: INFO/MainProcess] mingle: searching for neighbors\n[2015-07-07 14:07:08,419: INFO/MainProcess] mingle: all alone\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 使用CTRL-C杀死该段程序。现在，测试Celery任务调度程序是否已经准备好：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n$ celery -A picha beat -l info\n...\n[2015-07-07 14:08:23,054: INFO/MainProcess] beat: Starting...\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 在上述完成时再次终止该进程。<br/><br/><strong>1、Celery任务</strong><br/>&#160;&#160;&#160;&#160;&#160;&#160; Celery利用celery调用的常规Python函数作为任务。<br/>&#160;&#160;&#160;&#160;&#160;&#160; 例如，让我们把这个基本函数变为celery的任务：<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\ndef add(x, y):\n&#160;&#160;&#160;&#160;return x + y\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 首先，添加一个装饰器。<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\nfrom celery.decorators import task\n\n@task(name=\"sum_two_numbers\")\ndef add(x, y):\n&#160;&#160;&#160;&#160;return x + y\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 然后你可以通过以下方式利用celery异步运行该任务：<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\nadd.delay(7, 8)\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 很简单，对不对？<br/>所以，这对于解决类似你要加载一个网页，而不需要用户等待一些后台程序的完成这些类型的任务来说是非常完美的。<br/>&#160;&#160;&#160;&#160;&#160;&#160;让我们来看一个例子...<br/>让我们再回到Django项目的版本3，它包括一个接受来自用户的反馈的应用程序，人们形象地称之为反馈：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n├── feedback\n│&#160;&#160; ├── __init__.py\n│&#160;&#160; ├── admin.py\n│&#160;&#160; ├── emails.py\n│&#160;&#160; ├── forms.py\n│&#160;&#160; ├── models.py\n│&#160;&#160; ├── tests.py\n│&#160;&#160; └── views.py\n├── manage.py\n├── picha\n│&#160;&#160; ├── __init__.py\n│&#160;&#160; ├── celery.py\n│&#160;&#160; ├── settings.py\n│&#160;&#160; ├── urls.py\n│&#160;&#160; └── wsgi.py\n├── requirements.txt\n└── templates\n&#160;&#160;&#160;&#160;├── base.html\n&#160;&#160;&#160;&#160;└── feedback\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;├── contact.html\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;└── email\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;├── feedback_email_body.txt\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;└── feedback_email_subject.txt\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 安装新的必要软件，启动应用程序，并导航到http://localhost:8000/feedback/。你应该看到如下结果：<br/><a href=\"https://blog.liuts.com/attachment.php?fid=376\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=376\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>让我们连接celery任务。<br/><br/><strong>2、添加任务</strong><br/>&#160;&#160;&#160;&#160;&#160;&#160; 基本上，用户提交反馈表后，我们希望让他继续以他舒服的方式往下进行，而我们在后台进行处理反馈，发送电子邮件等等。<br/>要做到这一点，首先添加一个叫tasks.py的文件到“feedback”目录：<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\nfrom celery.decorators import task\nfrom celery.utils.log import get_task_logger\n\nfrom feedback.emails import send_feedback_email\n\nlogger = get_task_logger(__name__)\n\n\n@task(name=\"send_feedback_email_task\")\ndef send_feedback_email_task(email, message):\n&#160;&#160;&#160;&#160;\"\"\"sends an email when feedback form is filled successfully\"\"\"\n&#160;&#160;&#160;&#160;logger.info(\"Sent feedback email\")\n&#160;&#160;&#160;&#160;return send_feedback_email(email, message)\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 然后按照如下内容更新forms.py：<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\nfrom django import forms\nfrom feedback.tasks import send_feedback_email_task\n\n\nclass FeedbackForm(forms.Form):\n&#160;&#160;&#160;&#160;email = forms.EmailField(label=\"Email Address\")\n&#160;&#160;&#160;&#160;message = forms.CharField(\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;label=\"Message\", widget=forms.Textarea(attrs=&#123;'rows': 5&#125;))\n&#160;&#160;&#160;&#160;honeypot = forms.CharField(widget=forms.HiddenInput(), required=False)\n\n&#160;&#160;&#160;&#160;def send_email(self):\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# try to trick spammers by checking whether the honeypot field is\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# filled in; not super complicated/effective but it works\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if self.cleaned_data['honeypot']:\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return False\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;send_feedback_email_task.delay(\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.cleaned_data['email'], self.cleaned_data['message'])\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 大体上，send_feedback_email_task.delay(email, message)的函数过程，并发送反馈电子邮件等都是在用户继续使用该网站的同时作为后台进程运行。<br/>注：在views.py中的success_url被设置为将用户重定向到/ 目录，这个目录还不存在。我们会在下一节设置这个终点启动。<br/><br/><strong>3、周期任务</strong><br/>&#160;&#160;&#160;&#160;&#160;&#160; 通常情况下，你经常需要安排一个任务在特定的时间运行 - 例如，一个web scraper 可能需要每天都运行。这样的任务，被称为周期性任务，很容易建立利用celery启动。<br/>&#160;&#160;&#160;&#160;&#160;&#160; celery使用“celery beat”来安排定期任务。celery beat定期运行任务，然后由celery worker执行任务。<br/>例如，下面的任务计划每15分钟运行一次：<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\nfrom celery.task.schedules import crontab\nfrom celery.decorators import periodic_task\n\n\n@periodic_task(run_every=(crontab(minute='*/15')), name=\"some_task\", ignore_result=True)\ndef some_task():\n&#160;&#160;&#160;&#160;# do something\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 让我们通过往Django项目中添加功能来看一个更强大的例子。<br/>回到Django项目版本4，它包括另一个新的应用程序，叫做photos，这个应用程序使用 Flickr API获取新照片用来显示在网站：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n├── feedback\n│&#160;&#160; ├── __init__.py\n│&#160;&#160; ├── admin.py\n│&#160;&#160; ├── emails.py\n│&#160;&#160; ├── forms.py\n│&#160;&#160; ├── models.py\n│&#160;&#160; ├── tasks.py\n│&#160;&#160; ├── tests.py\n│&#160;&#160; └── views.py\n├── manage.py\n├── photos\n│&#160;&#160; ├── __init__.py\n│&#160;&#160; ├── admin.py\n│&#160;&#160; ├── models.py\n│&#160;&#160; ├── settings.py\n│&#160;&#160; ├── tests.py\n│&#160;&#160; ├── utils.py\n│&#160;&#160; └── views.py\n├── picha\n│&#160;&#160; ├── __init__.py\n│&#160;&#160; ├── celery.py\n│&#160;&#160; ├── settings.py\n│&#160;&#160; ├── urls.py\n│&#160;&#160; └── wsgi.py\n├── requirements.txt\n└── templates\n&#160;&#160;&#160;&#160;├── base.html\n&#160;&#160;&#160;&#160;├── feedback\n&#160;&#160;&#160;&#160;│&#160;&#160; ├── contact.html\n&#160;&#160;&#160;&#160;│&#160;&#160; └── email\n&#160;&#160;&#160;&#160;│&#160;&#160;&#160;&#160;&#160;&#160; ├── feedback_email_body.txt\n&#160;&#160;&#160;&#160;│&#160;&#160;&#160;&#160;&#160;&#160; └── feedback_email_subject.txt\n&#160;&#160;&#160;&#160;└── photos\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;└── photo_list.html\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 安装新的必要软件，运行迁移，然后启动服务器，以确保一切都是好的。重新测试反馈表。这次，它应该重定向好了。<br/>&#160;&#160;&#160;&#160;&#160;&#160; 下一步是什么？<br/>&#160;&#160;&#160;&#160;&#160;&#160; 既然我们需要周期性的调用Flickr API，以获取更多的照片添加到我们的网站，我们可以添加一个celery任务。<br/><br/><strong>4、添加任务</strong><br/>往photos应用中添加一个tasks.py。<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\nfrom celery.task.schedules import crontab\nfrom celery.decorators import periodic_task\nfrom celery.utils.log import get_task_logger\n\nfrom photos.utils import save_latest_flickr_image\n\nlogger = get_task_logger(__name__)\n\n\n@periodic_task(\n&#160;&#160;&#160;&#160;run_every=(crontab(minute='*/15')),\n&#160;&#160;&#160;&#160;name=\"task_save_latest_flickr_image\",\n&#160;&#160;&#160;&#160;ignore_result=True\n)\ndef task_save_latest_flickr_image():\n&#160;&#160;&#160;&#160;\"\"\"\n&#160;&#160;&#160;&#160;Saves latest image from Flickr\n&#160;&#160;&#160;&#160;\"\"\"\n&#160;&#160;&#160;&#160;save_latest_flickr_image()\n&#160;&#160;&#160;&#160;logger.info(\"Saved image from Flickr\")\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 在这里，我们通过在一个task中包装这个函数，来实现每15分钟运行一次save_latest_flickr_image()函数。该@periodic_task装饰器抽象出代码来运行celery任务，使得tasks.py干净，易于阅读！<br/><br/><strong>5、本地运行</strong><br/>&#160;&#160;&#160;&#160;&#160;&#160; 准备开始运行了？<br/>&#160;&#160;&#160;&#160;&#160;&#160; 在Django应用程序和Redis运行的前提下，打开两个新的终端窗口/标签。在每一个新的窗口中，导航到你的项目目录，激活你的虚拟环境，然后运行下面的命令（每个窗口一个）：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n$ celery -A picha worker -l info\n$ celery -A picha beat -l info\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 当你访问http://127.0.0.1:8000/ 网址的时候，你现在应该能看到一个图片。我们的应用程序每15分钟从Flickr 获取一张图片。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=377\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=377\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><a href=\"https://blog.liuts.com/attachment.php?fid=378\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=378\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>通过photos/tasks.py查看代码。点击“Feedback”按钮发送一些反馈意见：<br/><a href=\"https://blog.liuts.com/attachment.php?fid=379\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=379\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><a href=\"https://blog.liuts.com/attachment.php?fid=380\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=380\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;&#160;&#160; 以上是通过celery任务运行的。更多的请查看<span style=\"color: #FF4500;\">feedback/tasks.py</span>。<br/>&#160;&#160;&#160;&#160;&#160;&#160; 就这样，你成功的启动并运行了 Picha项目！<br/>&#160;&#160;&#160;&#160;&#160;&#160; 当你本地开发Django项目时，这是一个很好的测试，但是当你需要部署到生产环境- 就像 DigitalOcean时，就不那么合适了。为此，建议你通过使用Supervisor在后台作为一个守护进程运行celery worker和调度器。<br/><br/><strong>6、远程运行</strong><br/>&#160;&#160;&#160;&#160;&#160;&#160; 安装很简单。从版本库中获取版本5（如果你还没有的话）。然后，SSH到远程服务器，并运行：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n$ sudo apt-get install supervisor\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 然后，通过在远程服务器上“/etc/supervisor/conf.d/” 目录下添加配置文件来告知Supervisor celery的workers。在我们的例子中，我们需要两个这样的配置文件 - 一个用于Celery worker，一个是Celery scheduler。<br/>在本地，在项目的根目录下创建一个“supervisor”的文件夹，然后添加下面的文件。<br/><span style=\"color: #8B0000;\">Celery Worker: picha_celery.conf</span><br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\n; ==================================\n;&#160;&#160;celery worker supervisor example\n; ==================================\n\n; the name of your supervisord program\n[program:pichacelery]\n\n; Set full path to celery program if using virtualenv\ncommand=/home/mosh/.virtualenvs/picha/bin/celery worker -A picha --loglevel=INFO\n\n; The directory to your Django project\ndirectory=/home/mosh/sites/picha\n\n; If supervisord is run as the root user, switch users to this UNIX user account\n; before doing any processing.\nuser=mosh\n\n; Supervisor will start as many instances of this program as named by numprocs\nnumprocs=1\n\n; Put process stdout output in this file\nstdout_logfile=/var/log/celery/picha_worker.log\n\n; Put process stderr output in this file\nstderr_logfile=/var/log/celery/picha_worker.log\n\n; If true, this program will start automatically when supervisord is started\nautostart=true\n\n; May be one of false, unexpected, or true. If false, the process will never\n; be autorestarted. If unexpected, the process will be restart when the program\n; exits with an exit code that is not one of the exit codes associated with this\n; process’ configuration (see exitcodes). If true, the process will be\n; unconditionally restarted when it exits, without regard to its exit code.\nautorestart=true\n\n; The total number of seconds which the program needs to stay running after\n; a startup to consider the start successful.\nstartsecs=10\n\n; Need to wait for currently executing tasks to finish at shutdown.\n; Increase this if you have very long running tasks.\nstopwaitsecs = 600\n\n; When resorting to send SIGKILL to the program to terminate it\n; send SIGKILL to its whole process group instead,\n; taking care of its children as well.\nkillasgroup=true\n\n; if your broker is supervised, set its priority higher\n; so it starts first\npriority=998\n</textarea><br/><span style=\"color: #8B0000;\">Celery Scheduler: picha_celerybeat.conf</span><br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\n; ================================\n;&#160;&#160;celery beat supervisor example\n; ================================\n\n; the name of your supervisord program\n[program:pichacelerybeat]\n\n; Set full path to celery program if using virtualenv\ncommand=/home/mosh/.virtualenvs/picha/bin/celerybeat -A picha --loglevel=INFO\n\n; The directory to your Django project\ndirectory=/home/mosh/sites/picha\n\n; If supervisord is run as the root user, switch users to this UNIX user account\n; before doing any processing.\nuser=mosh\n\n; Supervisor will start as many instances of this program as named by numprocs\nnumprocs=1\n\n; Put process stdout output in this file\nstdout_logfile=/var/log/celery/picha_beat.log\n\n; Put process stderr output in this file\nstderr_logfile=/var/log/celery/picha_beat.log\n\n; If true, this program will start automatically when supervisord is started\nautostart=true\n\n; May be one of false, unexpected, or true. If false, the process will never\n; be autorestarted. If unexpected, the process will be restart when the program\n; exits with an exit code that is not one of the exit codes associated with this\n; process’ configuration (see exitcodes). If true, the process will be\n; unconditionally restarted when it exits, without regard to its exit code.\nautorestart=true\n\n; The total number of seconds which the program needs to stay running after\n; a startup to consider the start successful.\nstartsecs=10\n\n; if your broker is supervised, set its priority higher\n; so it starts first\npriority=999\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 注：确保更新这些文件的路径，以匹配你的远程服务器的文件系统。<br/>基本上，这些supervisor 配置文件告诉supervisord如何运行并管理我们的'programs'（因为它们是由supervisord调用）。<br/>&#160;&#160;&#160;&#160;&#160;&#160; 在上面的例子中，我们已经创建了两个名为“pichacelery”和“pichacelerybeat”的supervisord程序。<br/>现在，只需将这些文件拷贝到远程服务器的/etc/supervisor/conf.d/目录下。<br/>&#160;&#160;&#160;&#160;&#160;&#160; 我们还需要在远程服务器上创建上面脚本中提到的日志文件：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n$ touch /var/log/celery/picha_worker.log\n$ touch /var/log/celery/picha_beat.log\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 最后，运行以下命令，使 Supervisor 知道它所管理的程序的存在 - 例如，pichacelery和pichacelerybeat：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n$ sudo supervisorctl reread\n$ sudo supervisorctl update\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 运行以下命令停止，启动，和/或检查pichacelery程序的状态：<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n$ sudo supervisorctl stop pichacelery\n$ sudo supervisorctl start pichacelery\n$ sudo supervisorctl status pichacelery\n</textarea><br/>&#160;&#160;&#160;&#160;&#160;&#160; 你可以通过阅读官方文档获取Supervisor的更多信息。<br/><br/><strong>7、最后提示</strong><br/>&#160;&#160;&#160;&#160;&#160;&#160; 1. 千万不要传递Django模型对象到celery任务。为了避免模型对象在传递给celery任务之前已经改变了，传递celery的主键给celery。然后，在运行之前使用主键从数据库中获取对象。<br/>&#160;&#160;&#160;&#160;&#160;&#160; 2. 默认celery调度会在本地创建一些文件存储它的调度表。这些文件是“celerybeat-schedule.db”和“celerybeat.pid”。如果你在使用版本控制系统，比如Git（你应该使用！），请忽略这个文件，不要将它们添加到你的代码库中，因为它们是为本地运行的进程服务的。<br/><br/><strong>8、下一步</strong><br/>&#160;&#160;&#160;&#160;&#160;&#160; 以上就是将celery集成到一个django项目的基本介绍。<br/>想要更多？<br/>1. 深入研究官方celery用户指南，以了解更多信息。<br/>2. 创建一个Fabfile来设置Supervisor和配置文件。确保添加命令到reread和 update Supervisor。<br/>3. 从repo中获取这个项目，并打开一个Pull 请求来添加一个新的celery任务。<br/>编码快乐！<br/><br/>原文：<a href=\"https://realpython.com/blog/python/asynchronous-tasks-with-django-and-celery/\" target=\"_blank\">https://realpython.com/blog/python/asynchronous-tasks-with-django-and-celery/</a><br/>Tags - <a href=\"https://blog.liuts.com/tags/django/\" rel=\"tag\">django</a> , <a href=\"https://blog.liuts.com/tags/celery/\" rel=\"tag\">celery</a> , <a href=\"https://blog.liuts.com/tags/%25E5%25BC%2582%25E6%25AD%25A5/\" rel=\"tag\">异步</a> , <a href=\"https://blog.liuts.com/tags/%25E4%25BB%25BB%25E5%258A%25A1/\" rel=\"tag\">任务</a> , <a href=\"https://blog.liuts.com/tags/%25E5%25AF%25B9%25E5%2588%2597/\" rel=\"tag\">对列</a>\n\n","descriptionType":"text/html","publishedDate":"Tue, 18 Aug 2015 11:42:06 +0000","feedId":10777,"bgimg":"https://blog.liuts.com/attachment.php?fid=376","linkMd5":"4a50385db38a197878e05f7acb8b7bbe","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn8@2020_5/2020/08/25/01-04-58-182_43128dea2e429e59.webp","destWidth":828,"destHeight":415,"sourceBytes":30183,"destBytes":8042,"author":"刘天斯 <liutiansi@gmail.com>","articleImgCdnMap":{"https://blog.liuts.com/attachment.php?fid=376":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn8@2020_5/2020/08/25/01-04-58-182_43128dea2e429e59.webp","https://blog.liuts.com/attachment.php?fid=377":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn27@2020_1/2020/08/25/01-07-54-127_e2984606a44c3183.webp","https://blog.liuts.com/attachment.php?fid=378":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn36@2020_5/2020/08/25/01-07-18-105_2ef28618f2106b2e.webp","https://blog.liuts.com/attachment.php?fid=379":"https://cdn.jsdelivr.net/gh/myreaderx/cdn40@2020_1/2020/08/25/01-07-58-381_c6d2d3b31955b971.webp","https://blog.liuts.com/attachment.php?fid=380":null},"publishedOrCreatedDate":1598317495139},{"createdTime":"2020-08-25 09:04:55","updatedTime":"2020-08-25 09:04:55","title":"基于kubernetes构建Docker集群管理详解","link":"https://blog.liuts.com/post/247/","description":"\n \n\t<br/><strong>一、前言</strong><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Kubernetes 是Google开源的容器集群管理系统，基于Docker构建一个容器的调度服务，提供资源调度、均衡容灾、服务注册、动态扩缩容等功能套件，目前最新版本为0.6.2。本文介绍如何基于Centos7.0构建Kubernetes平台，在正式介绍之前，大家有必要先理解Kubernetes几个核心概念及其承担的功能。以下为Kubernetes的架构设计图：<br/><a href=\"https://blog.liuts.com/attachment.php?fid=368\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=368\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>1. Pods<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在Kubernetes系统中，调度的最小颗粒不是单纯的容器，而是抽象成一个Pod，Pod是一个可以被创建、销毁、调度、管理的最小的部署单元。比如一个或一组容器。<br/>2. Replication Controllers<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Replication Controller是Kubernetes系统中最有用的功能，实现复制多个Pod副本，往往一个应用需要多个Pod来支撑，并且可以保证其复制的副本数，即使副本所调度分配的主宿机出现异常，通过Replication Controller可以保证在其它主宿机启用同等数量的Pod。Replication Controller可以通过repcon模板来创建多个Pod副本，同样也可以直接复制已存在Pod，需要通过Label selector来关联。<br/>3、Services<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Services是Kubernetes最外围的单元，通过虚拟一个访问IP及服务端口，可以访问我们定义好的Pod资源，目前的版本是通过iptables的nat转发来实现，转发的目标端口为Kube_proxy生成的随机端口，目前只提供GOOGLE云上的访问调度，如GCE。如果与我们自建的平台进行整合？请关注下篇《kubernetes与HECD架构的整合》文章。<br/>4、Labels<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Labels是用于区分Pod、Service、Replication Controller的key/value键值对，仅使用在Pod、Service、 Replication Controller之间的关系识别，但对这些单元本身进行操作时得使用name标签。<br/>5、Proxy<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Proxy不但解决了同一主宿机相同服务端口冲突的问题，还提供了Service转发服务端口对外提供服务的能力，Proxy后端使用了随机、轮循负载均衡算法。<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;说说个人一点看法，目前Kubernetes 保持一周一小版本、一个月一大版本的节奏，迭代速度极快，同时也带来了不同版本操作方法的差异，另外官网文档更新速度相对滞后及欠缺，给初学者带来一定挑战。在上游接入层官方侧重点还放在GCE（Google Compute Engine）的对接优化，针对个人私有云还未推出一套可行的接入解决方案。在v0.5版本中才引用service代理转发的机制，且是通过iptables来实现，在高并发下性能令人担忧。但作者依然看好Kubernetes未来的发展，至少目前还未看到另外一个成体系、具备良好生态圈的平台，相信在V1.0时就会具备生产环境的服务支撑能力。<br/><br/><strong>一、环境部署</strong><br/>1、平台版本说明<br/>&#160;&#160;&#160;&#160;1）Centos7.0 OS<br/>&#160;&#160;&#160;&#160;2）Kubernetes V0.6.2<br/>&#160;&#160;&#160;&#160;3）etcd version 0.4.6<br/>&#160;&#160;&#160;&#160;4）Docker version 1.3.2<br/><br/>2、平台环境说明<br/><a href=\"https://blog.liuts.com/attachment.php?fid=369\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=369\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/>3、环境安装<br/>&#160;&#160;&#160;&#160;1）系统初始化工作（所有主机）<br/>&#160;&#160;&#160;&#160;系统安装-选择[最小化安装]<br/>&#160;&#160;&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>&#160;&#160;&#160;&#160;# yum -y install wget ntpdate bind-utils<br/>&#160;&#160;&#160;&#160;# wget http://mirror.centos.org/centos/7/extras/x86_64/Packages/epel-release-7-2.noarch.rpm<br/>&#160;&#160;&#160;&#160;# yum update<br/>&#160;&#160;&#160;&#160;</div></div><br/>&#160;&#160;&#160;&#160;CentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙（熟悉度更高，非必须）。<br/>&#160;&#160;&#160;&#160;1.1、关闭firewall：<br/>&#160;&#160;&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>&#160;&#160;&#160;&#160;# systemctl stop firewalld.service #停止firewall<br/>&#160;&#160;&#160;&#160;# systemctl disable firewalld.service #禁止firewall开机启动<br/>&#160;&#160;&#160;&#160;</div></div><br/>&#160;&#160;&#160;&#160;1.2、安装iptables防火墙<br/>&#160;&#160;&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>&#160;&#160;&#160;&#160;# yum install iptables-services #安装<br/>&#160;&#160;&#160;&#160;# systemctl start iptables.service #最后重启防火墙使配置生效<br/>&#160;&#160;&#160;&#160;# systemctl enable iptables.service #设置防火墙开机启动<br/>&#160;&#160;&#160;&#160;</div></div><br/>&#160;&#160;&#160;&#160;2）安装Etcd（192.168.1.10主机）<br/>&#160;&#160;&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>&#160;&#160;&#160;&#160;# mkdir -p /home/install && cd /home/install&#160;&#160;<br/>&#160;&#160;&#160;&#160;# wget https://github.com/coreos/etcd/releases/download/v0.4.6/etcd-v0.4.6-linux-amd64.tar.gz&#160;&#160;<br/>&#160;&#160;&#160;&#160;# tar -zxvf etcd-v0.4.6-linux-amd64.tar.gz&#160;&#160;<br/>&#160;&#160;&#160;&#160;# cd etcd-v0.4.6-linux-amd64&#160;&#160;<br/>&#160;&#160;&#160;&#160;# cp etcd* /bin/&#160;&#160;<br/>&#160;&#160;&#160;&#160;# /bin/etcd -version&#160;&#160;<br/>&#160;&#160;&#160;&#160;etcd version 0.4.6&#160;&#160;<br/>&#160;&#160;&#160;&#160;</div></div><br/>&#160;&#160;&#160;&#160;启动服务etcd服务，如有提供第三方管理需求，另需在启动参数中添加“-cors='*'”参数。<br/>&#160;&#160;&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>&#160;&#160;&#160;&#160;# mkdir /data/etcd&#160;&#160;<br/>&#160;&#160;&#160;&#160;# /bin/etcd -name etcdserver -peer-addr 192.168.1.10:7001 -addr 192.168.1.10:4001 -data-dir /data/etcd -peer-bind-addr 0.0.0.0:7001 -bind-addr 0.0.0.0:4001 &<br/>&#160;&#160;&#160;&#160;</div></div><br/>&#160;&#160;&#160;&#160;配置etcd服务防火墙，其中4001为服务端口，7001为集群数据交互端口。<br/>&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>&#160;&#160;&#160;&#160;# iptables -I INPUT -s 192.168.1.0/24 -p tcp --dport 4001 -j ACCEPT<br/>&#160;&#160;&#160;&#160;# iptables -I INPUT -s 192.168.1.0/24 -p tcp --dport 7001 -j ACCEPT<br/>&#160;&#160; </div></div><br/><br/>&#160;&#160;&#160;&#160;3）安装Kubernetes（涉及所有Master、Minion主机）<br/>&#160;&#160;&#160;&#160;通过yum源方式安装，默认将安装etcd, docker, and cadvisor相关包。<br/>&#160;&#160;&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>&#160;&#160;&#160;&#160;# curl https://copr.fedoraproject.org/coprs/eparis/kubernetes-epel-7/repo/epel-7/eparis-kubernetes-epel-7-epel-7.repo -o /etc/yum.repos.d/eparis-kubernetes-epel-7-epel-7.repo<br/>&#160;&#160;&#160;&#160;#yum -y install kubernetes<br/>&#160;&#160;&#160;&#160;</div></div><br/>&#160;&#160;&#160;&#160;升级至v0.6.2，覆盖bin文件即可，方法如下：<br/>&#160;&#160;&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>&#160;&#160;&#160;&#160;# mkdir -p /home/install && cd /home/install<br/>&#160;&#160;&#160;&#160;# wget https://github.com/GoogleCloudPlatform/kubernetes/releases/download/v0.6.2/kubernetes.tar.gz<br/>&#160;&#160;&#160;&#160;# tar -zxvf kubernetes.tar.gz<br/>&#160;&#160;&#160;&#160;# tar -zxvf kubernetes/server/kubernetes-server-linux-amd64.tar.gz<br/>&#160;&#160;&#160;&#160;# cp kubernetes/server/bin/kube* /usr/bin<br/>&#160;&#160;&#160;&#160;</div></div><br/>&#160;&#160;&#160;&#160;校验安装结果，出版以下信息说明安装正常。<br/>&#160;&#160;&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>&#160;&#160;&#160;&#160;[root@SN2014-12-200 bin]# /usr/bin/kubectl version<br/>&#160;&#160;&#160;&#160;Client Version: version.Info&#123;Major:\"0\", Minor:\"6+\", GitVersion:\"v0.6.2\", GitCommit:\"729fde276613eedcd99ecf5b93f095b8deb64eb4\", GitTreeState:\"clean\"&#125;<br/>&#160;&#160;&#160;&#160;Server Version: &version.Info&#123;Major:\"0\", Minor:\"6+\", GitVersion:\"v0.6.2\", GitCommit:\"729fde276613eedcd99ecf5b93f095b8deb64eb4\", GitTreeState:\"clean\"&#125;<br/>&#160;&#160;&#160;&#160;</div></div><br/>&#160;&#160;&#160;&#160;4）Kubernetes配置（仅Master主机）<br/>&#160;&#160;&#160;&#160;master运行三个组件,包括apiserver、scheduler、controller-manager，相关配置项也只涉及这三块。<br/>4.1、【/etc/kubernetes/config】<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# Comma seperated list of nodes in the etcd cluster\nKUBE_ETCD_SERVERS=\"--etcd_servers=http://192.168.1.10:4001\"\n\n# logging to stderr means we get it in the systemd journal\nKUBE_LOGTOSTDERR=\"--logtostderr=true\"\n\n# journal message level, 0 is debug\nKUBE_LOG_LEVEL=\"--v=0\"\n\n# Should this cluster be allowed to run privleged docker containers\nKUBE_ALLOW_PRIV=\"--allow_privileged=false\"\n</textarea><br/>4.2、【/etc/kubernetes/apiserver】<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# The address on the local server to listen to.\nKUBE_API_ADDRESS=\"--address=0.0.0.0\"\n\n# The port on the local server to listen on.\nKUBE_API_PORT=\"--port=8080\"\n\n# How the replication controller and scheduler find the kube-apiserver\nKUBE_MASTER=\"--master=192.168.1.200:8080\"\n\n# Port minions listen on\nKUBELET_PORT=\"--kubelet_port=10250\"\n\n# Address range to use for services\nKUBE_SERVICE_ADDRESSES=\"--portal_net=10.254.0.0/16\"\n\n# Add you own!\nKUBE_API_ARGS=\"\"\n</textarea><br/>4.3、【/etc/kubernetes/controller-manager】<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# Comma seperated list of minions\nKUBELET_ADDRESSES=\"--machines= 192.168.1.201,192.168.1.202\"\n\n# Add you own!\nKUBE_CONTROLLER_MANAGER_ARGS=\"\"\n</textarea><br/>4.4、【/etc/kubernetes/scheduler】<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# Add your own!\nKUBE_SCHEDULER_ARGS=\"\"\n</textarea><br/>&#160;&#160;&#160;&#160;启动master侧相关服务<br/>&#160;&#160;&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>&#160;&#160;&#160;&#160;# systemctl daemon-reload<br/>&#160;&#160;&#160;&#160;# systemctl start kube-apiserver.service kube-controller-manager.service kube-scheduler.service<br/>&#160;&#160;&#160;&#160;# systemctl enable kube-apiserver.service kube-controller-manager.service kube-scheduler.service<br/>&#160;&#160;&#160;&#160;</div></div><br/>&#160;&#160;&#160;&#160;5）Kubernetes配置（仅minion主机）<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;minion运行两个组件,包括kubelet、proxy，相关配置项也只涉及这两块。<br/>&#160;&#160;&#160;&#160;Docker启动脚本更新<br/>&#160;&#160;&#160;&#160;# vi /etc/sysconfig/docker<br/>&#160;&#160;&#160;&#160;添加：-H tcp://0.0.0.0:2375，最终配置如下，以便以后提供远程API维护。<br/>&#160;&#160;&#160;&#160;OPTIONS=--selinux-enabled -H tcp://0.0.0.0:2375 -H fd://<br/><br/>&#160;&#160;&#160;&#160;修改minion防火墙配置，通常master找不到minion主机多半是由于端口没有连通。<br/>&#160;&#160;&#160;&#160;iptables -I INPUT -s 192.168.1.200 -p tcp --dport 10250 -j ACCEPT<br/><br/>&#160;&#160;&#160;&#160;修改kubernetes minion端配置，以192.168.1.201主机为例，其它minion主机同理。<br/>5.1、【/etc/kubernetes/config】<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n# Comma seperated list of nodes in the etcd cluster\nKUBE_ETCD_SERVERS=\"--etcd_servers=http://192.168.1.10:4001\"\n\n# logging to stderr means we get it in the systemd journal\nKUBE_LOGTOSTDERR=\"--logtostderr=true\"\n\n# journal message level, 0 is debug\nKUBE_LOG_LEVEL=\"--v=0\"\n\n# Should this cluster be allowed to run privleged docker containers\nKUBE_ALLOW_PRIV=\"--allow_privileged=false\"\n</textarea><br/>5.2、【/etc/kubernetes/kubelet】<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\n###\n# kubernetes kubelet (minion) config\n\n# The address for the info server to serve on (set to 0.0.0.0 or \"\" for all interfaces)\nKUBELET_ADDRESS=\"--address=0.0.0.0\"\n\n# The port for the info server to serve on\nKUBELET_PORT=\"--port=10250\"\n\n# You may leave this blank to use the actual hostname\nKUBELET_HOSTNAME=\"--hostname_override=192.168.1.201\"\n\n# Add your own!\nKUBELET_ARGS=\"\"\n</textarea><br/>5.3、【/etc/kubernetes/proxy】<br/><textarea name=\"code\" class=\"c\" rows=\"15\" cols=\"100\">\nKUBE_PROXY_ARGS=\"\"\n</textarea><br/>启动kubernetes服务<br/>&#160;&#160;&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/># systemctl daemon-reload<br/># systemctl enable docker.service kubelet.service kube-proxy.service<br/># systemctl start docker.service kubelet.service kube-proxy.service<br/>&#160;&#160;&#160;&#160;</div></div><br/>3、校验安装(在master主机操作，或可访问master主机8080端口的client api主机)<br/>&#160;&#160;1) kubernetes常用命令<br/>&#160;&#160;&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/># kubectl get minions&#160;&#160;&#160;&#160;#查查看minion主机<br/># kubectl get pods&#160;&#160;&#160;&#160;#查看pods清单<br/># kubectl get services 或 kubectl get services -o json&#160;&#160;&#160;&#160;#查看service清单<br/># kubectl get replicationControllers&#160;&#160;&#160;&#160;#查看replicationControllers清单<br/># for i in `kubectl get pod&#124;tail -n +2&#124;awk '&#123;print $1&#125;'`; do kubectl delete pod $i; done&#160;&#160;&#160;&#160;#删除所有pods<br/>&#160;&#160;&#160;&#160;</div></div><br/>&#160;&#160;&#160;&#160;或者通过Server api for REST方式（推荐，及时性更高）：<br/>&#160;&#160;&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/># curl -s -L http://192.168.1.200:8080/api/v1beta1/version &#124; python -mjson.tool&#160;&#160;&#160;&#160;#查看kubernetes版本<br/># curl -s -L http://192.168.1.200:8080/api/v1beta1/pods &#124; python -mjson.tool&#160;&#160;&#160;&#160;#查看pods清单<br/># curl -s -L http://192.168.1.200:8080/api/v1beta1/replicationControllers &#124; python -mjson.tool&#160;&#160;&#160;&#160;#查看replicationControllers清单<br/># curl -s -L http://192.168.1.200:8080/api/v1beta1/minions &#124; python -m json.tool&#160;&#160;&#160;&#160;#查查看minion主机<br/># curl -s -L http://192.168.1.200:8080/api/v1beta1/services &#124; python -m json.tool&#160;&#160;&#160;&#160;#查看service清单<br/>&#160;&#160;&#160;&#160; </div></div><br/><span style=\"color: #DC143C;\">注：在新版kubernetes中，所有的操作命令都整合至kubectl，包括kubecfg、kubectl.sh、kubecfg.sh等</span><br/><br/>&#160;&#160;2）创建测试pod单元<br/>&#160;&#160; # /home/kubermange/pods && cd /home/kubermange/pods<br/>&#160;&#160; # vi apache-pod.json<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\n&#123;\n&#160;&#160;\"id\": \"fedoraapache\",\n&#160;&#160;\"kind\": \"Pod\",\n&#160;&#160;\"apiVersion\": \"v1beta1\",\n&#160;&#160;\"desiredState\": &#123;\n&#160;&#160;&#160;&#160;\"manifest\": &#123;\n&#160;&#160;&#160;&#160;&#160;&#160;\"version\": \"v1beta1\",\n&#160;&#160;&#160;&#160;&#160;&#160;\"id\": \"fedoraapache\",\n&#160;&#160;&#160;&#160;&#160;&#160;\"containers\": [&#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;\"name\": \"fedoraapache\",\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;\"image\": \"fedora/apache\",\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;\"ports\": [&#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;\"containerPort\": 80,\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;\"hostPort\": 8080\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#125;]\n&#160;&#160;&#160;&#160;&#160;&#160;&#125;]\n&#160;&#160;&#160;&#160;&#125;\n&#160;&#160;&#125;,\n&#160;&#160;\"labels\": &#123;\n&#160;&#160;&#160;&#160;\"name\": \"fedoraapache\"\n&#160;&#160;&#125;\n&#125;\n</textarea><br/>&#160;&#160;&#160;&#160;# kubectl create -f apache-pod.json<br/>&#160;&#160;&#160;&#160;# kubectl get pod<br/><div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>NAME&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;IMAGE(S)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;HOST&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LABELS&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;STATUS<br/>fedoraapache&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fedora/apache&#160;&#160;&#160;&#160;&#160;&#160; 192.168.1.202/&#160;&#160;&#160;&#160;&#160;&#160;name=fedoraapache&#160;&#160; Running<br/></div></div><br/>&#160;&#160;&#160;&#160;启动浏览器访问http://192.168.1.202:8080/，对应的服务端口切记在iptables中已添加。效果图如下：<br/><a href=\"https://blog.liuts.com/attachment.php?fid=370\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=370\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/>&#160;&#160;&#160;&#160;观察kubernetes在etcd中的数据存储结构<br/><a href=\"https://blog.liuts.com/attachment.php?fid=373\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=373\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/>&#160;&#160;&#160;&#160;观察单个pods的数据存储结构，以json的格式存储。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=374\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=374\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/><strong>二、实战操作</strong><br/>&#160;&#160;&#160;&#160;任务：通过Kubernetes创建一个LNMP架构的服务集群，以及观察其负载均衡，涉及镜像“yorko/webserver”已经push至registry.hub.docker.com，大家可以通过“docker pull yorko/webserver”下载。<br/>&#160;&#160;&#160;&#160;<div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>&#160;&#160;&#160;&#160;# mkdir -p /home/kubermange/replication && mkdir -p /home/kubermange/service<br/>&#160;&#160;&#160;&#160;# cd /home/kubermange/replication <br/>&#160;&#160;&#160;&#160;</div></div><br/>1、 创建一个replication ，本例直接在replication模板中创建pod并复制，也可独立创建pod再通过replication来复制。<br/>【replication/lnmp-replication.json】<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\n&#123;\n&#160;&#160;\"id\": \"webserverController\",\n&#160;&#160;\"kind\": \"ReplicationController\",\n&#160;&#160;\"apiVersion\": \"v1beta1\",\n&#160;&#160;\"labels\": &#123;\"name\": \"webserver\"&#125;,\n&#160;&#160;\"desiredState\": &#123;\n&#160;&#160;&#160;&#160;\"replicas\": 2,\n&#160;&#160;&#160;&#160;\"replicaSelector\": &#123;\"name\": \"webserver_pod\"&#125;,\n&#160;&#160;&#160;&#160;\"podTemplate\": &#123;\n&#160;&#160;&#160;&#160;&#160;&#160;\"desiredState\": &#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"manifest\": &#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"version\": \"v1beta1\",\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"id\": \"webserver\",\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"volumes\": [\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#123;\"name\":\"httpconf\", \"source\":&#123;\"hostDir\":&#123;\"path\":\"/etc/httpd/conf\"&#125;&#125;&#125;,\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#123;\"name\":\"httpconfd\", \"source\":&#123;\"hostDir\":&#123;\"path\":\"/etc/httpd/conf.d\"&#125;&#125;&#125;,\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#123;\"name\":\"httproot\", \"source\":&#123;\"hostDir\":&#123;\"path\":\"/data\"&#125;&#125;&#125;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;],\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"containers\": [&#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"name\": \"webserver\",\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"image\": \"yorko/webserver\",\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"command\": [\"/bin/sh\", \"-c\", \"/usr/bin/supervisord -c /etc/supervisord.conf\"],\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"volumeMounts\": [\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#123;\"name\":\"httpconf\", \"mountPath\":\"/etc/httpd/conf\"&#125;,\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#123;\"name\":\"httpconfd\", \"mountPath\":\"/etc/httpd/conf.d\"&#125;,\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#123;\"name\":\"httproot\", \"mountPath\":\"/data\"&#125;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;],\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"cpu\": 100,\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"memory\": 50000000,\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"ports\": [&#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"containerPort\": 80,\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#125;,&#123;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \"containerPort\": 22,\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#125;]\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#125;]\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#125;\n&#160;&#160;&#160;&#160;&#160;&#160; &#125;,\n&#160;&#160;&#160;&#160;&#160;&#160; \"labels\": &#123;\"name\": \"webserver_pod\"&#125;,\n&#160;&#160;&#160;&#160;&#160;&#160;&#125;,\n&#160;&#160;&#125;\n&#125;\n</textarea><br/>&#160;&#160;&#160;&#160;执行创建命令<br/>&#160;&#160;&#160;&#160;#kubectl create -f lnmp-replication.json<br/>&#160;&#160;&#160;&#160;观察生成的pod副本清单：<br/>[root@SN2014-12-200 replication]# kubectl get pod<br/><div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>NAME&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; IMAGE(S)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;HOST&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LABELS&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; STATUS<br/>84150ab7-89f8-11e4-970d-000c292f1620&#160;&#160; yorko/webserver&#160;&#160;&#160;&#160; 192.168.1.202/&#160;&#160;&#160;&#160;&#160;&#160;name=webserver_pod&#160;&#160; Running<br/>84154ed5-89f8-11e4-970d-000c292f1620&#160;&#160; yorko/webserver&#160;&#160;&#160;&#160; 192.168.1.201/&#160;&#160;&#160;&#160;&#160;&#160;name=webserver_pod&#160;&#160; Running<br/>840beb1b-89f8-11e4-970d-000c292f1620&#160;&#160; yorko/webserver&#160;&#160;&#160;&#160; 192.168.1.202/&#160;&#160;&#160;&#160;&#160;&#160;name=webserver_pod&#160;&#160; Running<br/>84152d93-89f8-11e4-970d-000c292f1620&#160;&#160; yorko/webserver&#160;&#160;&#160;&#160; 192.168.1.202/&#160;&#160;&#160;&#160;&#160;&#160;name=webserver_pod&#160;&#160; Running<br/>840db120-89f8-11e4-970d-000c292f1620&#160;&#160; yorko/webserver&#160;&#160;&#160;&#160; 192.168.1.201/&#160;&#160;&#160;&#160;&#160;&#160;name=webserver_pod&#160;&#160; Running<br/>8413b4f3-89f8-11e4-970d-000c292f1620&#160;&#160; yorko/webserver&#160;&#160;&#160;&#160; 192.168.1.201/&#160;&#160;&#160;&#160;&#160;&#160;name=webserver_pod&#160;&#160; Running<br/></div></div><br/>2、创建一个service，通过selector指定 \"name\": \"webserver_pod\"与pods关联。<br/>【service/lnmp-service.json】<br/><textarea name=\"code\" class=\"python\" rows=\"15\" cols=\"100\">\n&#123;\n&#160;&#160;\"id\": \"webserver\",\n&#160;&#160;\"kind\": \"Service\",\n&#160;&#160;\"apiVersion\": \"v1beta1\",\n&#160;&#160;\"selector\": &#123;\n&#160;&#160;&#160;&#160;\"name\": \"webserver_pod\",\n&#160;&#160;&#125;,\n&#160;&#160;\"protocol\": \"TCP\",\n&#160;&#160;\"containerPort\": 80,\n&#160;&#160;\"port\": 8080\n&#125;\n</textarea><br/>&#160;&#160;&#160;&#160;执行创建命令：<br/>&#160;&#160;&#160;&#160;# kubectl create -f lnmp-service.json<br/><br/>&#160;&#160;&#160;&#160;登录minion主机（192.168.1.201），查询主宿机生成的iptables转发规则（最后一行）<br/>&#160;&#160;&#160;&#160;# iptables -nvL -t nat<br/><div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>Chain KUBE-PROXY (2 references)<br/> pkts bytes target&#160;&#160;&#160;&#160; prot opt in&#160;&#160;&#160;&#160; out&#160;&#160;&#160;&#160; source&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; destination&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br/>&#160;&#160;&#160;&#160;2&#160;&#160; 120 REDIRECT&#160;&#160; tcp&#160;&#160;--&#160;&#160;*&#160;&#160;&#160;&#160;&#160;&#160;*&#160;&#160;&#160;&#160;&#160;&#160; 0.0.0.0/0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.254.102.162&#160;&#160;&#160;&#160;&#160;&#160; /* kubernetes */ tcp dpt:443 redir ports 47700<br/>&#160;&#160;&#160;&#160;1&#160;&#160;&#160;&#160;60 REDIRECT&#160;&#160; tcp&#160;&#160;--&#160;&#160;*&#160;&#160;&#160;&#160;&#160;&#160;*&#160;&#160;&#160;&#160;&#160;&#160; 0.0.0.0/0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.254.28.74&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; /* kubernetes-ro */ tcp dpt:80 redir ports 60099<br/>&#160;&#160;&#160;&#160;0&#160;&#160;&#160;&#160; 0 REDIRECT&#160;&#160; tcp&#160;&#160;--&#160;&#160;*&#160;&#160;&#160;&#160;&#160;&#160;*&#160;&#160;&#160;&#160;&#160;&#160; 0.0.0.0/0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.254.216.51&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* webserver */ tcp dpt:8080 redir ports 40689<br/></div></div><br/>&#160;&#160;&#160;&#160;访问测试，http://192.168.1.201:40689/info.php，刷新浏览器发现proxy后端的变化，默认为随机轮循算法。<br/><a href=\"https://blog.liuts.com/attachment.php?fid=371\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=371\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><a href=\"https://blog.liuts.com/attachment.php?fid=372\" target=\"_blank\"><img src=\"https://blog.liuts.com/attachment.php?fid=372\" class=\"insertimage\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\" border=\"0\"/></a><br/><br/><strong>三、测试过程</strong><br/>&#160;&#160;&#160;&#160;1、pods自动复制、销毁测试，观察kubernetes自动保持副本数（6份）<br/>删除replicationcontrollers中一个副本fedoraapache<br/>[root@SN2014-12-200 pods]# kubectl delete pods fedoraapache<br/>I1219 23:59:39.305730&#160;&#160;&#160;&#160;9516 restclient.go:133] Waiting for completion of operation 142530<br/>fedoraapache<br/><div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>[root@SN2014-12-200 pods]# kubectl get pods<br/>NAME&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; IMAGE(S)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;HOST&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LABELS&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;STATUS<br/>5d70892e-8794-11e4-970d-000c292f1620&#160;&#160; fedora/apache&#160;&#160;&#160;&#160;&#160;&#160; 192.168.1.201/&#160;&#160;&#160;&#160;&#160;&#160;name=fedoraapache&#160;&#160; Running<br/>5d715e56-8794-11e4-970d-000c292f1620&#160;&#160; fedora/apache&#160;&#160;&#160;&#160;&#160;&#160; 192.168.1.202/&#160;&#160;&#160;&#160;&#160;&#160;name=fedoraapache&#160;&#160; Running<br/>5d717f8d-8794-11e4-970d-000c292f1620&#160;&#160; fedora/apache&#160;&#160;&#160;&#160;&#160;&#160; 192.168.1.202/&#160;&#160;&#160;&#160;&#160;&#160;name=fedoraapache&#160;&#160; Running<br/>5d71c584-8794-11e4-970d-000c292f1620&#160;&#160; fedora/apache&#160;&#160;&#160;&#160;&#160;&#160; 192.168.1.201/&#160;&#160;&#160;&#160;&#160;&#160;name=fedoraapache&#160;&#160; Running<br/>5d71a494-8794-11e4-970d-000c292f1620&#160;&#160; fedora/apache&#160;&#160;&#160;&#160;&#160;&#160; 192.168.1.202/&#160;&#160;&#160;&#160;&#160;&#160;name=fedoraapache&#160;&#160; Running<br/></div></div><br/>#自动生成出一个副本，保持6份的效果<br/><div class=\"quote\"><div class=\"quote-title\">引用</div><div class=\"quote-content\"><br/>[root@SN2014-12-200 pods]# kubectl get pods<br/>NAME&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; IMAGE(S)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;HOST&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LABELS&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;STATUS<br/>5d717f8d-8794-11e4-970d-000c292f1620&#160;&#160; fedora/apache&#160;&#160;&#160;&#160;&#160;&#160; 192.168.1.202/&#160;&#160;&#160;&#160;&#160;&#160;name=fedoraapache&#160;&#160; Running<br/>5d71c584-8794-11e4-970d-000c292f1620&#160;&#160; fedora/apache&#160;&#160;&#160;&#160;&#160;&#160; 192.168.1.201/&#160;&#160;&#160;&#160;&#160;&#160;name=fedoraapache&#160;&#160; Running<br/>5d71a494-8794-11e4-970d-000c292f1620&#160;&#160; fedora/apache&#160;&#160;&#160;&#160;&#160;&#160; 192.168.1.202/&#160;&#160;&#160;&#160;&#160;&#160;name=fedoraapache&#160;&#160; Running<br/>2a8fb993-8798-11e4-970d-000c292f1620&#160;&#160; fedora/apache&#160;&#160;&#160;&#160;&#160;&#160; 192.168.1.201/&#160;&#160;&#160;&#160;&#160;&#160;name=fedoraapache&#160;&#160; Running<br/>5d70892e-8794-11e4-970d-000c292f1620&#160;&#160; fedora/apache&#160;&#160;&#160;&#160;&#160;&#160; 192.168.1.201/&#160;&#160;&#160;&#160;&#160;&#160;name=fedoraapache&#160;&#160; Running<br/>5d715e56-8794-11e4-970d-000c292f1620&#160;&#160; fedora/apache&#160;&#160;&#160;&#160;&#160;&#160; 192.168.1.202/&#160;&#160;&#160;&#160;&#160;&#160;name=fedoraapache&#160;&#160; Running<br/></div></div><br/>2、测试不同角色模块中的hostPort<br/>&#160;&#160;&#160;&#160;1）pod中hostPort为空，而replicationcontrollers为指定端口，则异常；两侧都指定端口，相同或不同时都异常；pod的hostport为指定，另replicationcon为空，则正常；pod的hostport为空，另replicationcon为空，则正常；结论是在replicationcontrollers场景不能指定hostport，否则异常，待持续测试。<br/>&#160;&#160;&#160;&#160;2）结论：在replicationcontronllers.json中，\"replicaSelector\": &#123;\"name\": \"webserver_pod\"&#125;要与\"labels\": &#123;\"name\": \"webserver_pod\"&#125;以及service中的\"selector\": &#123;\"name\": \"webserver_pod\"｝保持一致；<br/><br/>请关注下篇《kubernetes与HECD架构的整合》，近期推出。<br/><br/>参考文献：<br/>https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/getting-started-guides/fedora/fedora_manual_config.md<br/>https://github.com/GoogleCloudPlatform/kubernetes/blob/master/DESIGN.md<br/>http://www.infoq.com/cn/articles/Kubernetes-system-architecture-introduction<br/><br/>转载请注明来源 http://blog.liuts.com/post/247/<br/>Tags - <a href=\"https://blog.liuts.com/tags/docker/\" rel=\"tag\">docker</a> , <a href=\"https://blog.liuts.com/tags/kubernetes/\" rel=\"tag\">kubernetes</a> , <a href=\"https://blog.liuts.com/tags/%25E5%25AE%25B9%25E5%2599%25A8%25E7%25AE%25A1%25E7%2590%2586/\" rel=\"tag\">容器管理</a> , <a href=\"https://blog.liuts.com/tags/%25E5%2588%2598%25E5%25A4%25A9%25E6%2596%25AF/\" rel=\"tag\">刘天斯</a>\n\n","descriptionType":"text/html","publishedDate":"Mon, 22 Dec 2014 13:41:54 +0000","feedId":10777,"bgimg":"https://blog.liuts.com/attachment.php?fid=368","linkMd5":"199700d68880e5c0c6880b7bbd8c7532","bgimgJsdelivr":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn31@2020_5/2020/08/25/01-05-08-777_25b5296b816b94e8.webp","destWidth":851,"destHeight":629,"sourceBytes":172790,"destBytes":36408,"author":"刘天斯 <liutiansi@gmail.com>","articleImgCdnMap":{"https://blog.liuts.com/attachment.php?fid=368":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn31@2020_5/2020/08/25/01-05-08-777_25b5296b816b94e8.webp","https://blog.liuts.com/attachment.php?fid=369":null,"https://blog.liuts.com/attachment.php?fid=370":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn19@2020_1/2020/08/25/01-07-17-131_30c1b26e52dedf5b.webp","https://blog.liuts.com/attachment.php?fid=373":null,"https://blog.liuts.com/attachment.php?fid=374":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn32@2020_1/2020/08/25/01-09-01-138_f15d17fc68594fdd.webp","https://blog.liuts.com/attachment.php?fid=371":null,"https://blog.liuts.com/attachment.php?fid=372":null},"publishedOrCreatedDate":1598317495141}],"record":{"createdTime":"2020-08-25 09:04:55","updatedTime":"2020-08-25 09:04:55","feedId":10777,"fetchDate":"Tue, 25 Aug 2020 01:04:55 +0000","fetchMs":2254,"handleMs":4335,"totalMs":297425,"newArticles":0,"totalArticles":10,"status":1,"type":0,"ip":"34.241.215.20","hostName":"europe65.herokuapp.com","requestId":"90ab317031ef48d3b7597a78d430ecc8_10777","contentType":"application/xml","totalBytes":927270,"bgimgsTotal":8,"bgimgsGithubTotal":6,"articlesImgsTotal":55,"articlesImgsGithubTotal":32,"successGithubMap":{"myreaderx25":2,"myreaderx8":1,"myreaderx14":2,"myreaderx15":2,"myreaderx27":2,"myreaderx6":1,"myreaderx16":1,"myreaderx10":2,"myreaderx32":1,"myreaderx4":2,"myreaderx11":1,"myreaderx22":1,"myreaderx12":1,"myreaderx2":1,"myreaderx13":1,"myreaderx24":2,"myreaderx30":2,"myreaderx31":1,"myreaderx29":1,"myreaderx18":1,"myreaderx19":2,"myreaderx":2},"failGithubMap":{}},"feed":{"createdTime":"2020-08-25 04:36:11","updatedTime":"2020-08-25 04:36:11","id":10777,"name":"运维进行时","url":"http://blog.liuts.com/feed.php","subscriber":null,"website":null,"icon":"https://blog.liuts.com/favicon.ico","icon_jsdelivr":null,"description":"互联网运维与架构","weekly":null,"link":"https://blog.liuts.com"},"noPictureArticleList":[{"createdTime":"2020-08-25 09:09:45","updatedTime":"2020-08-25 09:09:45","id":null,"feedId":10777,"linkMd5":"668ed1a0b63a78d3738856199aefd8c3"},{"createdTime":"2020-08-25 09:09:45","updatedTime":"2020-08-25 09:09:45","id":null,"feedId":10777,"linkMd5":"629fb0ec07335c6bc22c7a82ff0f6d0b"},{"createdTime":"2020-08-25 09:09:45","updatedTime":"2020-08-25 09:09:45","id":null,"feedId":10777,"linkMd5":"a7bf600c1068b113ac9836f9e8942384"},{"createdTime":"2020-08-25 09:09:45","updatedTime":"2020-08-25 09:09:45","id":null,"feedId":10777,"linkMd5":"f401c182083f10370c108f306083fd94"},{"createdTime":"2020-08-25 09:09:45","updatedTime":"2020-08-25 09:09:45","id":null,"feedId":10777,"linkMd5":"269961617c9cb1d1b6bc18e9a8ef11a4"},{"createdTime":"2020-08-25 09:09:45","updatedTime":"2020-08-25 09:09:45","id":null,"feedId":10777,"linkMd5":"02d2450ac03ced4daf17a745547032e4"},{"createdTime":"2020-08-25 09:09:45","updatedTime":"2020-08-25 09:09:45","id":null,"feedId":10777,"linkMd5":"4a50385db38a197878e05f7acb8b7bbe"},{"createdTime":"2020-08-25 09:09:45","updatedTime":"2020-08-25 09:09:45","id":null,"feedId":10777,"linkMd5":"199700d68880e5c0c6880b7bbd8c7532"}],"tmpCommonImgCdnBytes":157460,"tmpBodyImgCdnBytes":769810,"tmpBgImgCdnBytes":0,"extra4":{"start":1598317488312,"total":0,"statList":[{"spend":2495,"msg":"获取xml内容"},{"spend":4335,"msg":"解释文章"},{"spend":127265,"msg":"上传封面图到cdn"},{"spend":1,"msg":"修正封面图上传失败重新上传"},{"spend":168473,"msg":"正文链接上传到cdn"}]},"extra5":55,"extra6":32,"extra7ImgCdnFailResultVector":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"extra10_invalidATagHrefValue":{"https://blog.liuts.com/post/246/_//www.slideshare.net/liutiansi/python-42901993":"https://www.slideshare.net/liutiansi/python-42901993","https://blog.liuts.com/post/246/_//www.slideshare.net/liutiansi":"https://www.slideshare.net/liutiansi"},"extra111_proxyServerAndStatMap":{"http://us-032.herokuapp.com/":{"failCount":3,"successCount":1,"resultList":[200,null,null,null]},"http://europe-58.herokuapp.com/":{"failCount":3,"successCount":0,"resultList":[null,null,null]},"http://us-028.herokuapp.com/":{"failCount":3,"successCount":0,"resultList":[null,null,null]},"http://us-024.herokuapp.com/":{"failCount":2,"successCount":1,"resultList":[200,null,null]},"http://us-020.herokuapp.com/":{"failCount":5,"successCount":1,"resultList":[200,null,null,null,null,null]},"http://europe-25.herokuapp.com/":{"failCount":2,"successCount":2,"resultList":[200,null,null,200]},"http://us-54.herokuapp.com/":{"failCount":6,"successCount":4,"resultList":[200,200,200,200,null,null,null,null,null,null]},"http://us-036.herokuapp.com/":{"failCount":5,"successCount":2,"resultList":[200,200,null,null,null,null,null]},"http://europe21.herokuapp.com/":{"failCount":1,"successCount":2,"resultList":[200,200,null]},"http://europe62.herokuapp.com/":{"failCount":3,"successCount":0,"resultList":[null,null,null]},"http://us-004.herokuapp.com/":{"failCount":2,"successCount":2,"resultList":[200,null,null,200]},"http://europe67.herokuapp.com/":{"failCount":1,"successCount":2,"resultList":[200,200,null]},"http://us-008.herokuapp.com/":{"failCount":5,"successCount":3,"resultList":[200,null,null,200,null,null,null,200]},"http://us-016.herokuapp.com/":{"failCount":5,"successCount":3,"resultList":[200,200,200,null,null,null,null,null]},"http://us-040.herokuapp.com/":{"failCount":2,"successCount":2,"resultList":[200,200,null,null]},"http://us-012.herokuapp.com/":{"failCount":3,"successCount":1,"resultList":[200,null,null,null]}},"extra12ImgCdnSuccessResultVector":[{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=376","sourceStatusCode":200,"destWidth":828,"destHeight":415,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn8@2020_5/2020/08/25/01-04-58-182_43128dea2e429e59.webp","sourceBytes":30183,"destBytes":8042,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":3632,"convertSpendMs":22,"createdTime":"2020-08-25 09:04:55","host":"us-54*","referer":"https://blog.liuts.com/post/248/","linkMd5ListStr":"4a50385db38a197878e05f7acb8b7bbe,4a50385db38a197878e05f7acb8b7bbe","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"29.5 KB","destSize":"7.9 KB","compressRate":"26.6%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=363","sourceStatusCode":200,"destWidth":800,"destHeight":800,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn16@2020_6/2020/08/25/01-05-01-018_83e28d90ea38e062.webp","sourceBytes":98618,"destBytes":35770,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":6500,"convertSpendMs":29,"createdTime":"2020-08-25 09:04:55","host":"us-020*","referer":"https://blog.liuts.com/post/244/","linkMd5ListStr":"789d193ed87d45ffd97176dd5112ca5e,789d193ed87d45ffd97176dd5112ca5e","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"96.3 KB","destSize":"34.9 KB","compressRate":"36.3%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=364","sourceStatusCode":200,"destWidth":960,"destHeight":208,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx8/cdn19@2020_2/2020/08/25/01-05-02-877_7c6d4a5b3411d8fe.webp","sourceBytes":105970,"destBytes":22396,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":8519,"convertSpendMs":20,"createdTime":"2020-08-25 09:04:55","host":"us-008*","referer":"https://blog.liuts.com/post/245/","linkMd5ListStr":"a7bf600c1068b113ac9836f9e8942384,a7bf600c1068b113ac9836f9e8942384","githubUser":"myreaderx8","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"103.5 KB","destSize":"21.9 KB","compressRate":"21.1%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=366","sourceStatusCode":200,"destWidth":864,"destHeight":390,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx11/cdn12@2020_1/2020/08/25/01-05-05-993_a3f7d7bc59526cb7.webp","sourceBytes":207987,"destBytes":35036,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":11569,"convertSpendMs":15,"createdTime":"2020-08-25 09:04:55","host":"us-032*","referer":"https://blog.liuts.com/post/246/","linkMd5ListStr":"973f821a7a3a5f825eaf21ec216f09bb,973f821a7a3a5f825eaf21ec216f09bb","githubUser":"myreaderx11","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"203.1 KB","destSize":"34.2 KB","compressRate":"16.8%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=398","sourceStatusCode":200,"destWidth":640,"destHeight":417,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn3@2020_4/2020/08/25/01-05-06-064_f69404c6130778aa.webp","sourceBytes":211260,"destBytes":19808,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":12015,"convertSpendMs":23,"createdTime":"2020-08-25 09:04:55","host":"europe67*","referer":"https://blog.liuts.com/post/252/","linkMd5ListStr":"02d2450ac03ced4daf17a745547032e4,02d2450ac03ced4daf17a745547032e4","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"206.3 KB","destSize":"19.3 KB","compressRate":"9.4%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=368","sourceStatusCode":200,"destWidth":851,"destHeight":629,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn31@2020_5/2020/08/25/01-05-08-777_25b5296b816b94e8.webp","sourceBytes":172790,"destBytes":36408,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":14266,"convertSpendMs":47,"createdTime":"2020-08-25 09:04:55","host":"us-036*","referer":"https://blog.liuts.com/post/247/","linkMd5ListStr":"199700d68880e5c0c6880b7bbd8c7532,199700d68880e5c0c6880b7bbd8c7532","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"168.7 KB","destSize":"35.6 KB","compressRate":"21.1%"},{"code":1,"isDone":false,"source":"http://img39.ddimg.cn/imgother/201411/04_1/201411041308531389.jpg","sourceStatusCode":200,"destWidth":811,"destHeight":608,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn8@2020_4/2020/08/25/01-06-59-562_27c043487409862d.webp","sourceBytes":78973,"destBytes":32972,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":2973,"convertSpendMs":18,"createdTime":"2020-08-25 09:06:57","host":"us-012*","referer":"https://blog.liuts.com/post/244/","linkMd5ListStr":"789d193ed87d45ffd97176dd5112ca5e","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"77.1 KB","destSize":"32.2 KB","compressRate":"41.8%"},{"code":1,"isDone":false,"source":"http://img38.ddimg.cn/imgother/201411/04_1/201411041308531388.jpg","sourceStatusCode":200,"destWidth":824,"destHeight":634,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn100@2020_3/2020/08/25/01-06-59-633_38994bcd6dd61526.webp","sourceBytes":125663,"destBytes":46996,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":3128,"convertSpendMs":53,"createdTime":"2020-08-25 09:06:57","host":"us-036*","referer":"https://blog.liuts.com/post/244/","linkMd5ListStr":"789d193ed87d45ffd97176dd5112ca5e","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"122.7 KB","destSize":"45.9 KB","compressRate":"37.4%"},{"code":1,"isDone":false,"source":"http://img37.ddimg.cn/imgother/201411/04_1/201411041308511387.jpg","sourceStatusCode":200,"destWidth":821,"destHeight":479,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx18/cdn91@2020_1/2020/08/25/01-07-00-050_bdff03249f850a73.webp","sourceBytes":310302,"destBytes":46238,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":3509,"convertSpendMs":22,"createdTime":"2020-08-25 09:06:57","host":"us-040*","referer":"https://blog.liuts.com/post/244/","linkMd5ListStr":"789d193ed87d45ffd97176dd5112ca5e","githubUser":"myreaderx18","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"303 KB","destSize":"45.2 KB","compressRate":"14.9%"},{"code":1,"isDone":false,"source":"http://img32.ddimg.cn/imgother/201411/04_1/201411041308481672.jpg","sourceStatusCode":200,"destWidth":818,"destHeight":497,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx32/cdn3@2020_4/2020/08/25/01-07-00-722_de8577432f1e7158.webp","sourceBytes":69736,"destBytes":28192,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":4125,"convertSpendMs":31,"createdTime":"2020-08-25 09:06:57","host":"us-004*","referer":"https://blog.liuts.com/post/244/","linkMd5ListStr":"789d193ed87d45ffd97176dd5112ca5e","githubUser":"myreaderx32","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"68.1 KB","destSize":"27.5 KB","compressRate":"40.4%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment/201605/1463409409_541109dd.png","sourceStatusCode":200,"destWidth":531,"destHeight":245,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn83@2020_4/2020/08/25/01-07-02-922_f9bbf90cd4c376ae.webp","sourceBytes":63832,"destBytes":26522,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":7095,"convertSpendMs":14,"createdTime":"2020-08-25 09:06:57","host":"europe-25*","referer":"https://blog.liuts.com/post/250/","linkMd5ListStr":"f401c182083f10370c108f306083fd94","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"62.3 KB","destSize":"25.9 KB","compressRate":"41.5%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=407","sourceStatusCode":200,"destWidth":640,"destHeight":470,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx6/cdn64@2020_2/2020/08/25/01-07-06-550_7b0b7ef7047d9ef5.webp","sourceBytes":34020,"destBytes":29348,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":9930,"convertSpendMs":17,"createdTime":"2020-08-25 09:06:57","host":"us-016*","referer":"https://blog.liuts.com/post/252/","linkMd5ListStr":"02d2450ac03ced4daf17a745547032e4","githubUser":"myreaderx6","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"33.2 KB","destSize":"28.7 KB","compressRate":"86.3%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=410","sourceStatusCode":200,"destWidth":640,"destHeight":479,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx13/cdn12@2020_5/2020/08/25/01-07-06-939_5d55249d08e36a2d.webp","sourceBytes":37503,"destBytes":33032,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":10354,"convertSpendMs":15,"createdTime":"2020-08-25 09:06:57","host":"us-54*","referer":"https://blog.liuts.com/post/252/","linkMd5ListStr":"02d2450ac03ced4daf17a745547032e4","githubUser":"myreaderx13","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"36.6 KB","destSize":"32.3 KB","compressRate":"88.1%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=412","sourceStatusCode":200,"destWidth":640,"destHeight":477,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn28@2020_1/2020/08/25/01-07-08-772_cebea431feccc2c8.webp","sourceBytes":26040,"destBytes":22068,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":12541,"convertSpendMs":12,"createdTime":"2020-08-25 09:06:57","host":"europe21*","referer":"https://blog.liuts.com/post/252/","linkMd5ListStr":"02d2450ac03ced4daf17a745547032e4","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"25.4 KB","destSize":"21.6 KB","compressRate":"84.7%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=411","sourceStatusCode":200,"destWidth":640,"destHeight":472,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn24@2020_6/2020/08/25/01-07-10-608_57d29507c4c3d590.webp","sourceBytes":33318,"destBytes":32468,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":14054,"convertSpendMs":25,"createdTime":"2020-08-25 09:06:57","host":"us-008*","referer":"https://blog.liuts.com/post/252/","linkMd5ListStr":"02d2450ac03ced4daf17a745547032e4","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"32.5 KB","destSize":"31.7 KB","compressRate":"97.4%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment/201605/1463409409_6886032b.jpg","sourceStatusCode":200,"destWidth":818,"destHeight":497,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx30/cdn100@2020_5/2020/08/25/01-07-12-505_d2e3d6fdb1243fee.webp","sourceBytes":67179,"destBytes":27006,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":15879,"convertSpendMs":18,"createdTime":"2020-08-25 09:06:57","host":"us-016*","referer":"https://blog.liuts.com/post/250/","linkMd5ListStr":"f401c182083f10370c108f306083fd94","githubUser":"myreaderx30","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"65.6 KB","destSize":"26.4 KB","compressRate":"40.2%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=408","sourceStatusCode":200,"destWidth":640,"destHeight":476,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx2/cdn75@2020_5/2020/08/25/01-07-12-653_ce10acbed53e9865.webp","sourceBytes":38904,"destBytes":32038,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":16082,"convertSpendMs":18,"createdTime":"2020-08-25 09:06:57","host":"us-54*","referer":"https://blog.liuts.com/post/252/","linkMd5ListStr":"02d2450ac03ced4daf17a745547032e4","githubUser":"myreaderx2","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"38 KB","destSize":"31.3 KB","compressRate":"82.4%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment/201605/1463409468_9025602e.png","sourceStatusCode":200,"destWidth":889,"destHeight":509,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx31/cdn4@2020_6/2020/08/25/01-07-12-583_d77cb02832e07d30.webp","sourceBytes":80067,"destBytes":54250,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":16114,"convertSpendMs":35,"createdTime":"2020-08-25 09:06:57","host":"us-024*","referer":"https://blog.liuts.com/post/250/","linkMd5ListStr":"f401c182083f10370c108f306083fd94","githubUser":"myreaderx31","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"78.2 KB","destSize":"53 KB","compressRate":"67.8%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=409","sourceStatusCode":200,"destWidth":640,"destHeight":479,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx22/cdn80@2020_2/2020/08/25/01-07-15-430_313739c61fb81eac.webp","sourceBytes":42914,"destBytes":36716,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":18820,"convertSpendMs":15,"createdTime":"2020-08-25 09:06:57","host":"us-032*","referer":"https://blog.liuts.com/post/252/","linkMd5ListStr":"02d2450ac03ced4daf17a745547032e4","githubUser":"myreaderx22","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"41.9 KB","destSize":"35.9 KB","compressRate":"85.6%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=370","sourceStatusCode":200,"destWidth":994,"destHeight":172,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn19@2020_1/2020/08/25/01-07-17-131_30c1b26e52dedf5b.webp","sourceBytes":32842,"destBytes":3410,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":20500,"convertSpendMs":10,"createdTime":"2020-08-25 09:06:57","host":"us-040*","referer":"https://blog.liuts.com/post/247/","linkMd5ListStr":"199700d68880e5c0c6880b7bbd8c7532","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"32.1 KB","destSize":"3.3 KB","compressRate":"10.4%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment/201605/1463409468_4178f19c.png","sourceStatusCode":200,"destWidth":668,"destHeight":350,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx27/cdn7@2020_5/2020/08/25/01-07-17-422_5b1b57b5e61615c7.webp","sourceBytes":97830,"destBytes":25108,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":21450,"convertSpendMs":14,"createdTime":"2020-08-25 09:06:57","host":"europe67*","referer":"https://blog.liuts.com/post/250/","linkMd5ListStr":"f401c182083f10370c108f306083fd94","githubUser":"myreaderx27","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"95.5 KB","destSize":"24.5 KB","compressRate":"25.7%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=378","sourceStatusCode":200,"destWidth":713,"destHeight":283,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx24/cdn36@2020_5/2020/08/25/01-07-18-105_2ef28618f2106b2e.webp","sourceBytes":60160,"destBytes":27164,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":18536,"convertSpendMs":12,"createdTime":"2020-08-25 09:07:00","host":"europe67*","referer":"https://blog.liuts.com/post/248/","linkMd5ListStr":"4a50385db38a197878e05f7acb8b7bbe","githubUser":"myreaderx24","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"58.8 KB","destSize":"26.5 KB","compressRate":"45.2%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=367","sourceStatusCode":200,"destWidth":1002,"destHeight":588,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx10/cdn56@2020_2/2020/08/25/01-07-31-287_5ded02267d6fd1b2.webp","sourceBytes":161800,"destBytes":20694,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":24670,"convertSpendMs":25,"createdTime":"2020-08-25 09:07:07","host":"europe21*","referer":"https://blog.liuts.com/post/246/","linkMd5ListStr":"973f821a7a3a5f825eaf21ec216f09bb","githubUser":"myreaderx10","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"158 KB","destSize":"20.2 KB","compressRate":"12.8%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=418","sourceStatusCode":200,"destWidth":600,"destHeight":581,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx15/cdn36@2020_5/2020/08/25/01-07-53-718_0f90bd37b3dcd83c.webp","sourceBytes":103720,"destBytes":42798,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":57219,"convertSpendMs":65,"createdTime":"2020-08-25 09:06:57","host":"us-036*","referer":"https://blog.liuts.com/post/255/","linkMd5ListStr":"668ed1a0b63a78d3738856199aefd8c3","githubUser":"myreaderx15","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"101.3 KB","destSize":"41.8 KB","compressRate":"41.3%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=377","sourceStatusCode":200,"destWidth":990,"destHeight":409,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx29/cdn27@2020_1/2020/08/25/01-07-54-127_e2984606a44c3183.webp","sourceBytes":320096,"destBytes":31682,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":57541,"convertSpendMs":25,"createdTime":"2020-08-25 09:06:57","host":"us-016*","referer":"https://blog.liuts.com/post/248/","linkMd5ListStr":"4a50385db38a197878e05f7acb8b7bbe","githubUser":"myreaderx29","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"312.6 KB","destSize":"30.9 KB","compressRate":"9.9%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment/201605/1463409409_8588fb5c.png","sourceStatusCode":200,"destWidth":845,"destHeight":497,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx16/cdn84@2020_2/2020/08/25/01-07-53-265_717fec7726da0b97.webp","sourceBytes":310399,"destBytes":31926,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":56663,"convertSpendMs":35,"createdTime":"2020-08-25 09:06:57","host":"us-020*","referer":"https://blog.liuts.com/post/250/","linkMd5ListStr":"f401c182083f10370c108f306083fd94","githubUser":"myreaderx16","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"303.1 KB","destSize":"31.2 KB","compressRate":"10.3%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=379","sourceStatusCode":200,"destWidth":1002,"destHeight":565,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx/cdn40@2020_1/2020/08/25/01-07-58-381_c6d2d3b31955b971.webp","sourceBytes":313602,"destBytes":27936,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":58111,"convertSpendMs":41,"createdTime":"2020-08-25 09:07:01","host":"us-54*","referer":"https://blog.liuts.com/post/248/","linkMd5ListStr":"4a50385db38a197878e05f7acb8b7bbe","githubUser":"myreaderx","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"306.3 KB","destSize":"27.3 KB","compressRate":"8.9%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment/201605/1463409484_21389414.jpg","sourceStatusCode":200,"destWidth":191,"destHeight":263,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx4/cdn95@2020_4/2020/08/25/01-08-02-683_d36fcee06e6f76bf.webp","sourceBytes":14114,"destBytes":7476,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":6011,"convertSpendMs":9,"createdTime":"2020-08-25 09:07:57","host":"us-004*","referer":"https://blog.liuts.com/post/250/","linkMd5ListStr":"f401c182083f10370c108f306083fd94","githubUser":"myreaderx4","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"13.8 KB","destSize":"7.3 KB","compressRate":"53%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment/201605/1463409409_108210fb.png","sourceStatusCode":200,"destWidth":779,"destHeight":267,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx19/cdn88@2020_1/2020/08/25/01-08-02-563_a6189b8f0d3d6fb7.webp","sourceBytes":24978,"destBytes":23620,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":6178,"convertSpendMs":13,"createdTime":"2020-08-25 09:07:57","host":"europe-25*","referer":"https://blog.liuts.com/post/250/","linkMd5ListStr":"f401c182083f10370c108f306083fd94","githubUser":"myreaderx19","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"24.4 KB","destSize":"23.1 KB","compressRate":"94.6%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=406","sourceStatusCode":200,"destWidth":640,"destHeight":478,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx14/cdn59@2020_5/2020/08/25/01-08-12-242_f8a272c9fafd3616.webp","sourceBytes":37688,"destBytes":29640,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":12947,"convertSpendMs":38,"createdTime":"2020-08-25 09:08:00","host":"us-54*","referer":"https://blog.liuts.com/post/252/","linkMd5ListStr":"02d2450ac03ced4daf17a745547032e4","githubUser":"myreaderx14","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"36.8 KB","destSize":"28.9 KB","compressRate":"78.6%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=417","sourceStatusCode":200,"destWidth":597,"destHeight":775,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx25/cdn31@2020_6/2020/08/25/01-08-21-427_057715b2ff364b6e.webp","sourceBytes":93293,"destBytes":19426,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":24774,"convertSpendMs":55,"createdTime":"2020-08-25 09:07:57","host":"us-008*","referer":"https://blog.liuts.com/post/255/","linkMd5ListStr":"668ed1a0b63a78d3738856199aefd8c3","githubUser":"myreaderx25","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"91.1 KB","destSize":"19 KB","compressRate":"20.8%"},{"code":1,"isDone":false,"source":"https://blog.liuts.com/attachment.php?fid=374","sourceStatusCode":200,"destWidth":673,"destHeight":652,"fixedGithubDest":"https://cdn.jsdelivr.net/gh/myreaderx12/cdn32@2020_1/2020/08/25/01-09-01-138_f15d17fc68594fdd.webp","sourceBytes":227339,"destBytes":31084,"targetWebpQuality":75,"feedId":10777,"totalSpendMs":58820,"convertSpendMs":21,"createdTime":"2020-08-25 09:08:03","host":"us-008*","referer":"https://blog.liuts.com/post/247/","linkMd5ListStr":"199700d68880e5c0c6880b7bbd8c7532","githubUser":"myreaderx12","githubHttpCode":201,"extra22GetBytesInfo":"1、没有Referer字段","extra23historyStatusCode":[200],"sourceSize":"222 KB","destSize":"30.4 KB","compressRate":"13.7%"}],"successGithubMap":{"myreaderx25":2,"myreaderx8":1,"myreaderx14":2,"myreaderx15":2,"myreaderx27":2,"myreaderx6":1,"myreaderx16":1,"myreaderx10":2,"myreaderx32":1,"myreaderx4":2,"myreaderx11":1,"myreaderx22":1,"myreaderx12":1,"myreaderx2":1,"myreaderx13":1,"myreaderx24":2,"myreaderx30":2,"myreaderx31":1,"myreaderx29":1,"myreaderx18":1,"myreaderx19":2,"myreaderx":2},"failGithubMap":{}}